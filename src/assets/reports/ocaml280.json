{"filename":"src/lib/crypto/kimchi_backend/pasta/basic/kimchi_pasta_basic.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Kimchi_backend_common","counters":[]},{"line":"","counters":[]},{"line":"module Rounds : sig","counters":[]},{"line":"  open Pickles_types","counters":[]},{"line":"","counters":[]},{"line":"  module Wrap : Nat.Add.Intf_transparent","counters":[]},{"line":"","counters":[]},{"line":"  module Wrap_vector : Vector.With_version(Wrap).S","counters":[]},{"line":"","counters":[]},{"line":"  module Step : Nat.Add.Intf_transparent","counters":[]},{"line":"","counters":[]},{"line":"  module Step_vector : Vector.With_version(Step).S","counters":[]},{"line":"end = struct","counters":[]},{"line":"  open Pickles_types","counters":[]},{"line":"  module Wrap = Nat.N15","counters":[]},{"line":"  module Step = Nat.N16","counters":[]},{"line":"","counters":[]},{"line":"  (* Think about versioning here! These vector types *will* change","counters":[]},{"line":"     serialization if the numbers above change, and so will require a new","counters":[]},{"line":"     version number. Thus, it's important that these are modules with new","counters":[]},{"line":"     versioned types, and not just module aliases to the corresponding vector","counters":[]},{"line":"     implementation.","counters":[]},{"line":"  *)","counters":[]},{"line":"","counters":[]},{"line":"  module Wrap_vector = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      [@@@no_toplevel_latest_type]","counters":[]},{"line":"","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type 'a t = 'a Vector.Vector_15.Stable.V1.t","counters":[{"col_start":8,"col_end":8,"count":5},{"col_start":16,"col_end":16,"count":3},{"col_start":20,"col_end":20,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"        [@@deriving compare, yojson, sexp, hash, equal]","counters":[{"col_start":54,"col_end":54,"count":3}]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    type 'a t = 'a Vector.Vector_15.t","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"    [@@deriving compare, yojson, sexp, hash, equal]","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"","counters":[]},{"line":"    let map = Vector.map","counters":[]},{"line":"","counters":[]},{"line":"    let of_list_exn = Vector.Vector_15.of_list_exn","counters":[]},{"line":"","counters":[]},{"line":"    let to_list = Vector.to_list","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Step_vector = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      [@@@no_toplevel_latest_type]","counters":[]},{"line":"","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type 'a t = 'a Vector.Vector_16.Stable.V1.t","counters":[{"col_start":8,"col_end":8,"count":7},{"col_start":16,"col_end":16,"count":3},{"col_start":20,"col_end":20,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"        [@@deriving compare, yojson, sexp, hash, equal]","counters":[{"col_start":54,"col_end":54,"count":7}]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    type 'a t = 'a Vector.Vector_16.t","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"    [@@deriving compare, yojson, sexp, hash, equal]","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"","counters":[]},{"line":"    let map = Vector.map","counters":[]},{"line":"","counters":[]},{"line":"    let of_list_exn = Vector.Vector_16.of_list_exn","counters":[]},{"line":"","counters":[]},{"line":"    let to_list = Vector.to_list","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(* why use a functor here? *)","counters":[]},{"line":"module Bigint256 =","counters":[]},{"line":"  Kimchi_backend_common.Bigint.Make","counters":[]},{"line":"    (Pasta_bindings.BigInt256)","counters":[]},{"line":"    (struct","counters":[]},{"line":"      let length_in_bytes = 32","counters":[]},{"line":"    end)","counters":[]},{"line":"","counters":[]},{"line":"(* the two pasta fields and curves *)","counters":[]},{"line":"","counters":[]},{"line":"module Fp = Field.Make (struct","counters":[]},{"line":"  module Bigint = Bigint256","counters":[]},{"line":"  include Pasta_bindings.Fp","counters":[]},{"line":"  module Vector = Kimchi_bindings.FieldVectors.Fp","counters":[]},{"line":"end)","counters":[]},{"line":"","counters":[]},{"line":"module Fq = Field.Make (struct","counters":[]},{"line":"  module Bigint = Bigint256","counters":[]},{"line":"  include Pasta_bindings.Fq","counters":[]},{"line":"  module Vector = Kimchi_bindings.FieldVectors.Fq","counters":[]},{"line":"end)","counters":[]},{"line":"","counters":[]},{"line":"module Vesta = struct","counters":[]},{"line":"  module Params = struct","counters":[]},{"line":"    open Fq","counters":[]},{"line":"","counters":[]},{"line":"    let a = zero","counters":[]},{"line":"","counters":[]},{"line":"    let b = of_int 5","counters":[{"col_start":17,"col_end":17,"count":1}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  include Curve.Make (Fq) (Fp) (Params) (Pasta_bindings.Vesta)","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Pallas = struct","counters":[]},{"line":"  module Params = struct","counters":[]},{"line":"    open Fp","counters":[]},{"line":"","counters":[]},{"line":"    let a = zero","counters":[]},{"line":"","counters":[]},{"line":"    let b = of_int 5","counters":[{"col_start":17,"col_end":17,"count":1}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  include Curve.Make (Fp) (Fq) (Params) (Pasta_bindings.Pallas)","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(* the polynomial commitment types *)","counters":[]},{"line":"","counters":[]},{"line":"module Fq_poly_comm = Kimchi_backend_common.Poly_comm.Make (struct","counters":[]},{"line":"  module Curve = Pallas","counters":[]},{"line":"  module Base_field = Fp","counters":[]},{"line":"","counters":[]},{"line":"  module Backend = struct","counters":[]},{"line":"    type t = Curve.Affine.Backend.t Kimchi_types.poly_comm","counters":[]},{"line":"","counters":[]},{"line":"    let shifted ({ shifted; _ } : t) = shifted","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"    let unshifted ({ unshifted; _ } : t) = unshifted","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"","counters":[]},{"line":"    let make :","counters":[]},{"line":"        Curve.Affine.Backend.t array -> Curve.Affine.Backend.t option -> t =","counters":[]},{"line":"     fun unshifted shifted : t -> { shifted; unshifted }","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"  end","counters":[]},{"line":"end)","counters":[]},{"line":"","counters":[]},{"line":"module Fp_poly_comm = Kimchi_backend_common.Poly_comm.Make (struct","counters":[]},{"line":"  module Curve = Vesta","counters":[]},{"line":"  module Base_field = Fq","counters":[]},{"line":"","counters":[]},{"line":"  module Backend = struct","counters":[]},{"line":"    type t = Curve.Affine.Backend.t Kimchi_types.poly_comm","counters":[]},{"line":"","counters":[]},{"line":"    let shifted ({ shifted; _ } : t) = shifted","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"    let unshifted ({ unshifted; _ } : t) = unshifted","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"","counters":[]},{"line":"    let make :","counters":[]},{"line":"        Curve.Affine.Backend.t array -> Curve.Affine.Backend.t option -> t =","counters":[]},{"line":"     fun unshifted shifted : t -> { shifted; unshifted }","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"  end","counters":[]},{"line":"end)","counters":[{"col_start":3,"col_end":3,"count":2}]}]}