{"filename":"src/lib/transaction/transaction_union.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Mina_base","counters":[]},{"line":"open Signature_lib","counters":[]},{"line":"open Snark_params.Tick","counters":[]},{"line":"open Currency","counters":[]},{"line":"module Tag = Transaction_union_tag","counters":[]},{"line":"module Payload = Transaction_union_payload","counters":[]},{"line":"","counters":[]},{"line":"type ('payload, 'pk, 'signature) t_ =","counters":[{"col_start":0,"col_end":0,"count":0}]},{"line":"  { payload : 'payload; signer : 'pk; signature : 'signature }","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":10,"col_end":10,"count":0},{"col_start":14,"col_end":14,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":46,"col_end":46,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"[@@deriving equal, sexp, hash, hlist]","counters":[]},{"line":"","counters":[]},{"line":"type t = (Payload.t, Public_key.t, Signature.t) t_","counters":[]},{"line":"","counters":[]},{"line":"type var = (Payload.var, Public_key.var, Signature.var) t_","counters":[]},{"line":"","counters":[]},{"line":"let typ : (var, t) Typ.t =","counters":[]},{"line":"  Typ.of_hlistable","counters":[{"col_start":17,"col_end":17,"count":1}]},{"line":"    [ Payload.typ; Public_key.typ; Schnorr.Chunked.Signature.typ ]","counters":[]},{"line":"    ~var_to_hlist:t__to_hlist ~var_of_hlist:t__of_hlist","counters":[]},{"line":"    ~value_to_hlist:t__to_hlist ~value_of_hlist:t__of_hlist","counters":[]},{"line":"","counters":[]},{"line":"(** For SNARK purposes, we inject [Transaction.t]s into a single-variant 'tagged-union' record capable of","counters":[]},{"line":"    representing all the variants. We interpret the fields of this union in different ways depending on","counters":[]},{"line":"    the value of the [payload.body.tag] field, which represents which variant of [Transaction.t] the value","counters":[]},{"line":"    corresponds to.","counters":[]},{"line":"","counters":[]},{"line":"    Sometimes we interpret fields in surprising ways in different cases to save as much space in the SNARK as possible (e.g.,","counters":[]},{"line":"    [payload.body.public_key] is interpreted as the recipient of a payment, the new delegate of a stake","counters":[]},{"line":"    delegation command, and a fee transfer recipient for both coinbases and fee-transfers.","counters":[]},{"line":"*)","counters":[]},{"line":"let of_transaction : Signed_command.t Transaction.Poly.t -> t = function","counters":[]},{"line":"  | Command cmd ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let Signed_command.Poly.{ payload; signer; signature } =","counters":[]},{"line":"        (cmd :> Signed_command.t)","counters":[]},{"line":"      in","counters":[]},{"line":"      { payload = Transaction_union_payload.of_user_command_payload payload","counters":[{"col_start":66,"col_end":66,"count":0}]},{"line":"      ; signer","counters":[]},{"line":"      ; signature","counters":[]},{"line":"      }","counters":[]},{"line":"  | Coinbase { receiver; fee_transfer; amount } ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let { Coinbase.Fee_transfer.receiver_pk = other_pk; fee = other_amount } =","counters":[]},{"line":"        Option.value","counters":[]},{"line":"          ~default:","counters":[]},{"line":"            (Coinbase.Fee_transfer.create ~receiver_pk:receiver ~fee:Fee.zero)","counters":[]},{"line":"          fee_transfer","counters":[]},{"line":"      in","counters":[]},{"line":"      { payload =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          { common =","counters":[]},{"line":"              { fee = other_amount","counters":[]},{"line":"              ; fee_token = Token_id.default","counters":[]},{"line":"              ; fee_payer_pk = other_pk","counters":[]},{"line":"              ; nonce = Account.Nonce.zero","counters":[]},{"line":"              ; valid_until = Mina_numbers.Global_slot.max_value","counters":[]},{"line":"              ; memo = Signed_command_memo.empty","counters":[]},{"line":"              }","counters":[]},{"line":"          ; body =","counters":[]},{"line":"              { source_pk = other_pk","counters":[]},{"line":"              ; receiver_pk = receiver","counters":[]},{"line":"              ; token_id = Token_id.default","counters":[]},{"line":"              ; amount","counters":[]},{"line":"              ; tag = Tag.Coinbase","counters":[]},{"line":"              ; token_locked = false","counters":[]},{"line":"              }","counters":[]},{"line":"          }","counters":[]},{"line":"      ; signer = Public_key.decompress_exn other_pk","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"      ; signature = Signature.dummy","counters":[]},{"line":"      }","counters":[]},{"line":"  | Fee_transfer tr -> (","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let two { Fee_transfer.receiver_pk = pk1; fee = fee1; fee_token }","counters":[]},{"line":"          { Fee_transfer.receiver_pk = pk2; fee = fee2; fee_token = token_id } :","counters":[]},{"line":"          t =","counters":[]},{"line":"        { payload =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            { common =","counters":[]},{"line":"                { fee = fee2","counters":[]},{"line":"                ; fee_token","counters":[]},{"line":"                ; fee_payer_pk = pk2","counters":[]},{"line":"                ; nonce = Account.Nonce.zero","counters":[]},{"line":"                ; valid_until = Mina_numbers.Global_slot.max_value","counters":[]},{"line":"                ; memo = Signed_command_memo.empty","counters":[]},{"line":"                }","counters":[]},{"line":"            ; body =","counters":[]},{"line":"                { source_pk = pk2","counters":[]},{"line":"                ; receiver_pk = pk1","counters":[]},{"line":"                ; token_id","counters":[]},{"line":"                ; amount = Amount.of_fee fee1","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"                ; tag = Tag.Fee_transfer","counters":[]},{"line":"                ; token_locked = false","counters":[]},{"line":"                }","counters":[]},{"line":"            }","counters":[]},{"line":"        ; signer = Public_key.decompress_exn pk2","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"        ; signature = Signature.dummy","counters":[]},{"line":"        }","counters":[]},{"line":"      in","counters":[]},{"line":"      match Fee_transfer.to_singles tr with","counters":[]},{"line":"      | `One ({ receiver_pk; fee = _; fee_token } as t) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          two t","counters":[]},{"line":"            (Fee_transfer.Single.create ~receiver_pk ~fee:Fee.zero ~fee_token)","counters":[]},{"line":"      | `Two (t1, t2) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          two t1 t2 )","counters":[]},{"line":"","counters":[]},{"line":"let fee_excess (t : t) = Transaction_union_payload.fee_excess t.payload","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"let expected_supply_increase (t : t) =","counters":[]},{"line":"  Transaction_union_payload.expected_supply_increase t.payload","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":61,"col_end":61,"count":1}]}]}