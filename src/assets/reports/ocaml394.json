{"filename":"src/lib/perf_histograms/histogram.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"(** Loosely modelled on https://chromium.googlesource.com/chromium/src/+/HEAD/tools/metrics/histograms/README.md *)","counters":[]},{"line":"","counters":[]},{"line":"module Make (Elem : sig","counters":[]},{"line":"  type t [@@deriving yojson, bin_io]","counters":[]},{"line":"","counters":[]},{"line":"  module Params : sig","counters":[]},{"line":"    type t0 = t","counters":[]},{"line":"","counters":[]},{"line":"    type t","counters":[]},{"line":"","counters":[]},{"line":"    val buckets : t -> int","counters":[]},{"line":"","counters":[]},{"line":"    val create : ?min:t0 -> ?max:t0 -> ?buckets:int -> unit -> t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  val bucket : params:Params.t -> t -> [ `Index of int | `Overflow | `Underflow ]","counters":[]},{"line":"","counters":[]},{"line":"  val interval_of_bucket : params:Params.t -> int -> t * t","counters":[]},{"line":"end) =","counters":[]},{"line":"struct","counters":[]},{"line":"  type t =","counters":[]},{"line":"    { buckets : int Array.t","counters":[]},{"line":"    ; intervals : (Elem.t * Elem.t) List.t","counters":[]},{"line":"    ; mutable underflow : int","counters":[]},{"line":"    ; mutable overflow : int","counters":[]},{"line":"    ; params : Elem.Params.t","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let create ?buckets ?min ?max () =","counters":[]},{"line":"    let params = Elem.Params.create ?min ?max ?buckets () in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let intervals =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      List.init (Elem.Params.buckets params) ~f:(fun i ->","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"          Elem.interval_of_bucket ~params i )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    in","counters":[]},{"line":"    { buckets = Array.init (Elem.Params.buckets params) ~f:(fun _ -> 0)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":46,"col_end":46,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"    ; intervals","counters":[]},{"line":"    ; underflow = 0","counters":[]},{"line":"    ; overflow = 0","counters":[]},{"line":"    ; params","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let clear t =","counters":[]},{"line":"    Array.fill t.buckets ~pos:0 ~len:(Array.length t.buckets) 0 ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"    t.underflow <- 0 ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    t.overflow <- 0","counters":[]},{"line":"","counters":[]},{"line":"  module Pretty = struct","counters":[]},{"line":"    type t =","counters":[{"col_start":4,"col_end":4,"count":1},{"col_start":9,"col_end":9,"count":2}]},{"line":"      { values : int list","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"      ; intervals : (Elem.t * Elem.t) list","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"      ; underflow : int","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"      ; overflow : int","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"      }","counters":[]},{"line":"    [@@deriving yojson, bin_io_unversioned, fields]","counters":[{"col_start":50,"col_end":50,"count":4}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let report { intervals; buckets; underflow; overflow; params = _ } =","counters":[]},{"line":"    { Pretty.values = Array.to_list buckets; intervals; underflow; overflow }","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"","counters":[]},{"line":"  let add ({ params; _ } as t) e =","counters":[]},{"line":"    match Elem.bucket ~params e with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | `Index i ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        t.buckets.(i) <- Int.succ t.buckets.(i)","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"    | `Overflow ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        t.overflow <- t.overflow + 1","counters":[]},{"line":"    | `Underflow ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        t.underflow <- t.underflow + 1","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Exp_time_spans = Make (struct","counters":[]},{"line":"  (** Note: All time spans are represented in JSON as floating point millis *)","counters":[]},{"line":"  type t = Time.Span.t [@@deriving bin_io_unversioned]","counters":[{"col_start":2,"col_end":2,"count":1},{"col_start":7,"col_end":7,"count":1},{"col_start":53,"col_end":53,"count":4}]},{"line":"","counters":[]},{"line":"  let to_yojson t = `Float (Time.Span.to_ms t)","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"","counters":[]},{"line":"  let of_yojson t =","counters":[]},{"line":"    let open Ppx_deriving_yojson_runtime in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    match t with","counters":[]},{"line":"    | `Float ms ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Result.Ok (Time.Span.of_ms ms)","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"    | _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Result.Error \"Not a floating point milliseconds value\"","counters":[]},{"line":"","counters":[]},{"line":"  module Params = struct","counters":[]},{"line":"    type t0 = t","counters":[]},{"line":"","counters":[]},{"line":"    type t = { a : float; b : float; buckets : int }","counters":[]},{"line":"","counters":[]},{"line":"    let buckets { buckets; _ } = buckets","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"","counters":[]},{"line":"    (* See http://mathworld.wolfram.com/LeastSquaresFittingLogarithmic.html *)","counters":[]},{"line":"    let fit min max buckets =","counters":[]},{"line":"      let x0, y0 = (Time.Span.to_ms min, Float.zero) in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"      let x1, y1 = (Time.Span.to_ms max, Float.of_int buckets) in","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"      let n = 2.0 in","counters":[]},{"line":"      let sum f = f (x0, y0) +. f (x1, y1) in","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"      let b =","counters":[]},{"line":"        let num =","counters":[]},{"line":"          let f1 (x, y) = y *. Float.log x in","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"          let f2 (_, y) = y in","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"          let f3 (x, _) = Float.log x in","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"          let left = n *. sum f1 in","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"          let right = sum f2 *. sum f3 in","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"          left -. right","counters":[]},{"line":"        in","counters":[]},{"line":"        let denom =","counters":[]},{"line":"          let f1 (x, _) =","counters":[]},{"line":"            let lnx = Float.log x in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            lnx *. lnx","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          in","counters":[]},{"line":"          let f2 (x, _) = Float.log x in","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"          let right = sum f2 in","counters":[]},{"line":"          (n *. sum f1) -. (right *. right)","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"        in","counters":[]},{"line":"        num /. denom","counters":[]},{"line":"      in","counters":[]},{"line":"      let a =","counters":[]},{"line":"        let num =","counters":[]},{"line":"          let f1 (_, y) = y in","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"          let f2 (x, _) = Float.log x in","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"          sum f1 -. (b *. sum f2)","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"        in","counters":[]},{"line":"        num /. n","counters":[]},{"line":"      in","counters":[]},{"line":"      (a, b)","counters":[]},{"line":"","counters":[]},{"line":"    let create ?(min = Time.Span.of_sec 1.) ?(max = Time.Span.of_min 10.)","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":52,"col_end":52,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"        ?(buckets = 50) () =","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"      let a, b = fit min max buckets in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      { a; b; buckets }","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let interval_of_bucket ~params:{ Params.a; b; _ } i =","counters":[]},{"line":"    (* f-1(y) = e^{y/b - a/b} *)","counters":[]},{"line":"    let f_1 y =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let y = Float.of_int y in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Float.exp ((y /. b) -. (a /. b))","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    in","counters":[]},{"line":"    (Time.Span.of_ms (f_1 i), Time.Span.of_ms (f_1 (i + 1)))","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"","counters":[]},{"line":"  let bucket ~params:{ Params.a; b; buckets } span =","counters":[]},{"line":"    let x = Time.Span.to_ms span in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    if Float.( <= ) x 0.0 then `Underflow","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"    else","counters":[]},{"line":"      (* y = a + b log(x) *)","counters":[]},{"line":"      let res = a +. (b *. Float.log x) |> Int.of_float in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"      if res >= buckets then `Overflow","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"      else if res < 0 then `Underflow","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"      else `Index res","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"end)","counters":[]},{"line":"","counters":[]},{"line":"let%test_unit \"reports properly with overflows and underflows and table hits\" =","counters":[]},{"line":"  let open Exp_time_spans in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let tbl =","counters":[]},{"line":"    create ~buckets:50 ~min:(Time.Span.of_ms 1.) ~max:(Time.Span.of_day 1.) ()","counters":[{"col_start":43,"col_end":43,"count":0},{"col_start":70,"col_end":70,"count":0}]},{"line":"  in","counters":[]},{"line":"  let r = report tbl in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  assert (r.Pretty.underflow = 0) ;","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":9,"col_end":9,"count":0}]},{"line":"  assert (r.Pretty.overflow = 0) ;","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"  (* underflow *)","counters":[]},{"line":"  add tbl (Time.Span.of_us 100.) ;","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"  (* in the table *)","counters":[]},{"line":"  add tbl (Time.Span.of_ms 100.) ;","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"  add tbl (Time.Span.of_sec 100.) ;","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"  add tbl (Time.Span.of_day 0.5) ;","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"  (* overflow *)","counters":[]},{"line":"  add tbl (Time.Span.of_day 2.) ;","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"  let r = report tbl in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  assert (List.sum ~f:Fn.id (module Int) r.Pretty.values = 3) ;","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":9,"col_end":9,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"  assert (r.Pretty.underflow = 1) ;","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"  assert (r.Pretty.overflow = 1)","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":31,"col_end":31,"count":2}]}]}