{"filename":"src/lib/cli_lib/commands.ml","lines":[{"line":"open Signature_lib","counters":[]},{"line":"open Core_kernel","counters":[]},{"line":"open Async","counters":[]},{"line":"","counters":[]},{"line":"let generate_keypair =","counters":[]},{"line":"  Command.async ~summary:\"Generate a new public, private keypair\"","counters":[{"col_start":14,"col_end":14,"count":1}]},{"line":"    (let open Command.Let_syntax in","counters":[]},{"line":"    let%map_open privkey_path = Flag.privkey_write_path in","counters":[]},{"line":"    Exceptions.handle_nicely","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    @@ fun () ->","counters":[]},{"line":"    let env = Secrets.Keypair.env in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    if Option.is_some (Sys.getenv env) then","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"      eprintf \"Using password from environment variable %s\\n\" env ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":12,"col_end":12,"count":0}]},{"line":"    let open Deferred.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let kp = Keypair.create () in","counters":[]},{"line":"    let%bind () = Secrets.Keypair.Terminal_stdin.write_exn kp ~privkey_path in","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"    printf \"Keypair generated\\nPublic key: %s\\nRaw public key: %s\\n\"","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ( kp.public_key |> Public_key.compress","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"      |> Public_key.Compressed.to_base58_check )","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"      (Rosetta_coding.Coding.of_public_key kp.public_key) ;","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"    exit 0)","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"let validate_keypair =","counters":[]},{"line":"  Command.async ~summary:\"Validate a public, private keypair\"","counters":[{"col_start":14,"col_end":14,"count":1}]},{"line":"    (let open Command.Let_syntax in","counters":[]},{"line":"    let open Core_kernel in","counters":[]},{"line":"    let%map_open privkey_path = Flag.privkey_write_path in","counters":[]},{"line":"    Exceptions.handle_nicely","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    @@ fun () ->","counters":[]},{"line":"    let read_pk () =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let pubkey_path = privkey_path ^ \".pub\" in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      try","counters":[]},{"line":"        In_channel.with_file pubkey_path ~f:(fun in_channel ->","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"            match In_channel.input_line in_channel with","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            | Some line -> (","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                try Public_key.Compressed.of_base58_check_exn line","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"                with _exn ->","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                  eprintf","counters":[]},{"line":"                    \"Could not create public key in file %s from text: %s\\n\"","counters":[]},{"line":"                    pubkey_path line ;","counters":[]},{"line":"                  exit 1 )","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"            | None ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                eprintf \"No public key found in file %s\\n\" pubkey_path ;","counters":[]},{"line":"                exit 1 )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"      with exn ->","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"        eprintf \"Could not read public key file %s, error: %s\\n\" pubkey_path","counters":[]},{"line":"          (Exn.to_string exn) ;","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"        exit 1","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    in","counters":[]},{"line":"    let compare_public_keys ~pk_from_disk ~pk_from_keypair =","counters":[]},{"line":"      if Public_key.Compressed.equal pk_from_disk pk_from_keypair then","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        printf \"Public key on-disk is derivable from private key\\n\"","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      else (","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"        eprintf","counters":[]},{"line":"          \"Public key read from disk %s different than public key %s derived \\","counters":[]},{"line":"           from private key\\n\"","counters":[]},{"line":"          (Public_key.Compressed.to_base58_check pk_from_disk)","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"          (Public_key.Compressed.to_base58_check pk_from_keypair) ;","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"        exit 1 )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    in","counters":[]},{"line":"    let validate_transaction keypair =","counters":[]},{"line":"      let dummy_payload = Mina_base.Signed_command_payload.dummy in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let signature =","counters":[]},{"line":"        Mina_base.Signed_command.sign_payload keypair.Keypair.private_key","counters":[]},{"line":"          dummy_payload","counters":[]},{"line":"      in","counters":[]},{"line":"      let message = Mina_base.Signed_command.to_input_legacy dummy_payload in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let verified =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Schnorr.Legacy.verify signature","counters":[]},{"line":"          (Snark_params.Tick.Inner_curve.of_affine keypair.public_key)","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"          message","counters":[]},{"line":"      in","counters":[]},{"line":"      if verified then printf \"Verified a transaction using specified keypair\\n\"","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"      else (","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"        eprintf \"Failed to verify a transaction using the specific keypair\\n\" ;","counters":[]},{"line":"        exit 1 )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    in","counters":[]},{"line":"    let open Deferred.Let_syntax in","counters":[]},{"line":"    let%bind () =","counters":[]},{"line":"      let password =","counters":[]},{"line":"        lazy (Secrets.Keypair.Terminal_stdin.prompt_password \"Enter password: \")","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"      in","counters":[]},{"line":"      match%map Secrets.Keypair.read ~privkey_path ~password with","counters":[]},{"line":"      | Ok keypair ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let pk_from_disk = read_pk () in","counters":[]},{"line":"          compare_public_keys ~pk_from_disk","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ~pk_from_keypair:(keypair.public_key |> Public_key.compress) ;","counters":[{"col_start":70,"col_end":70,"count":0}]},{"line":"          validate_transaction keypair","counters":[]},{"line":"      | Error err ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          eprintf \"Could not read the specified keypair: %s\\n\"","counters":[]},{"line":"            (Secrets.Privkey_error.to_string err) ;","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"          exit 1","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    in","counters":[]},{"line":"    exit 0)","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"let validate_transaction =","counters":[]},{"line":"  Command.async","counters":[{"col_start":14,"col_end":14,"count":1}]},{"line":"    ~summary:","counters":[]},{"line":"      \"Validate the signature on one or more transactions, provided to stdin \\","counters":[]},{"line":"       in rosetta format\"","counters":[]},{"line":"    ( Command.Param.return","counters":[{"col_start":25,"col_end":25,"count":1}]},{"line":"    @@ fun () ->","counters":[]},{"line":"    let num_fails = ref 0 in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    (* TODO upgrade to yojson 2.0.0 when possible to use seq_from_channel","counters":[]},{"line":"     * instead of the deprecated stream interface *)","counters":[]},{"line":"    let jsons = Yojson.Safe.stream_from_channel In_channel.stdin in","counters":[]},{"line":"    ( match[@alert \"--deprecated\"]","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        Or_error.try_with (fun () ->","counters":[]},{"line":"            Caml.Stream.iter","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (fun transaction_json ->","counters":[]},{"line":"                match","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Rosetta_lib.Transaction.to_mina_signed transaction_json","counters":[]},{"line":"                with","counters":[]},{"line":"                | Ok cmd ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    if Mina_base.Signed_command.check_signature cmd then","counters":[]},{"line":"                      Format.eprintf \"Transaction was valid@.\"","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                    else (","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                      incr num_fails ;","counters":[]},{"line":"                      Format.eprintf \"Transaction was invalid@.\" )","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                | Error err ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    incr num_fails ;","counters":[]},{"line":"                    Format.eprintf","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      \"@[<v>Failed to validate transaction:@,\\","counters":[]},{"line":"                       %s@,\\","counters":[]},{"line":"                       Failed with error:%s@]@.\"","counters":[]},{"line":"                      (Yojson.Safe.pretty_to_string transaction_json)","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                      (Yojson.Safe.pretty_to_string","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                         (Error_json.error_to_yojson err) ) )","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"              jsons )","counters":[]},{"line":"      with","counters":[]},{"line":"    | Ok () ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ()","counters":[]},{"line":"    | Error err ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Format.eprintf \"@[<v>Error:@,%s@,@]@.\"","counters":[]},{"line":"          (Yojson.Safe.pretty_to_string (Error_json.error_to_yojson err)) ;","counters":[{"col_start":38,"col_end":38,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"        Format.printf \"Invalid transaction.@.\" ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Core_kernel.exit 1 ) ;","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"    if !num_fails > 0 then (","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"      Format.printf \"Some transactions failed to verify@.\" ;","counters":[]},{"line":"      exit 1 )","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    else","counters":[]},{"line":"      let[@alert \"--deprecated\"] first = Caml.Stream.peek jsons in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      match first with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Format.printf \"Could not parse any transactions@.\" ;","counters":[]},{"line":"          exit 1","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"      | _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Format.printf \"All transactions were valid@.\" ;","counters":[]},{"line":"          exit 0 )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"module Vrf = struct","counters":[]},{"line":"  let generate_witness =","counters":[]},{"line":"    Command.async","counters":[{"col_start":16,"col_end":16,"count":1}]},{"line":"      ~summary:","counters":[]},{"line":"        \"Generate a vrf evaluation witness. This may be used to calculate \\","counters":[]},{"line":"         whether a given private key will win a given slot (by checking \\","counters":[]},{"line":"         threshold_met = true in the JSON output), or to generate a witness \\","counters":[]},{"line":"         that a 3rd account_update can use to verify a vrf evaluation.\"","counters":[]},{"line":"      (let open Command.Let_syntax in","counters":[]},{"line":"      let%map_open privkey_path = Flag.privkey_write_path","counters":[]},{"line":"      and global_slot =","counters":[]},{"line":"        flag \"--global-slot\" ~doc:\"NUM Global slot to evaluate the VRF for\"","counters":[{"col_start":11,"col_end":11,"count":1}]},{"line":"          (required int)","counters":[{"col_start":18,"col_end":18,"count":1}]},{"line":"      and epoch_seed =","counters":[]},{"line":"        flag \"--epoch-seed\" ~doc:\"SEED Epoch seed to evaluate the VRF with\"","counters":[{"col_start":11,"col_end":11,"count":1}]},{"line":"          (required string)","counters":[{"col_start":18,"col_end":18,"count":1}]},{"line":"      and delegator_index =","counters":[]},{"line":"        flag \"--delegator-index\"","counters":[{"col_start":11,"col_end":11,"count":1}]},{"line":"          ~doc:\"NUM The index of the delegating account in the epoch ledger\"","counters":[]},{"line":"          (required int)","counters":[{"col_start":18,"col_end":18,"count":1}]},{"line":"      and generate_outputs =","counters":[]},{"line":"        flag \"--generate-outputs\"","counters":[{"col_start":11,"col_end":11,"count":1}]},{"line":"          ~doc:","counters":[]},{"line":"            \"true|false Whether to generate the vrf in addition to the witness \\","counters":[]},{"line":"             (default: false)\"","counters":[]},{"line":"          (optional_with_default false bool)","counters":[{"col_start":31,"col_end":31,"count":1}]},{"line":"      and delegated_stake =","counters":[]},{"line":"        flag \"--delegated-stake\"","counters":[{"col_start":11,"col_end":11,"count":1}]},{"line":"          ~doc:","counters":[]},{"line":"            \"AMOUNT The balance of the delegating account in the epoch ledger\"","counters":[]},{"line":"          (optional int)","counters":[{"col_start":18,"col_end":18,"count":1}]},{"line":"      and total_stake =","counters":[]},{"line":"        flag \"--total-stake\"","counters":[{"col_start":11,"col_end":11,"count":1}]},{"line":"          ~doc:\"AMOUNT The total balance of all accounts in the epoch ledger\"","counters":[]},{"line":"          (optional int)","counters":[{"col_start":18,"col_end":18,"count":1}]},{"line":"      in","counters":[]},{"line":"      Exceptions.handle_nicely","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      @@ fun () ->","counters":[]},{"line":"      let env = Secrets.Keypair.env in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      if Option.is_some (Sys.getenv env) then","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"        eprintf \"Using password from environment variable %s\\n\" env ;","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":14,"col_end":14,"count":0}]},{"line":"      let open Deferred.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      (* TODO-someday: constraint constants from config file. *)","counters":[]},{"line":"      let constraint_constants =","counters":[]},{"line":"        Genesis_constants.Constraint_constants.compiled","counters":[]},{"line":"      in","counters":[]},{"line":"      let%bind () =","counters":[]},{"line":"        let password =","counters":[]},{"line":"          lazy","counters":[]},{"line":"            (Secrets.Keypair.Terminal_stdin.prompt_password \"Enter password: \")","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"        in","counters":[]},{"line":"        match%bind Secrets.Keypair.read ~privkey_path ~password with","counters":[]},{"line":"        | Ok keypair ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let open Consensus_vrf.Layout in","counters":[]},{"line":"            let evaluation =","counters":[]},{"line":"              Evaluation.of_message_and_sk ~constraint_constants","counters":[]},{"line":"                { global_slot = Mina_numbers.Global_slot.of_int global_slot","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"                ; epoch_seed =","counters":[]},{"line":"                    Mina_base.Epoch_seed.of_base58_check_exn epoch_seed","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"                ; delegator_index","counters":[]},{"line":"                }","counters":[]},{"line":"                keypair.private_key","counters":[]},{"line":"            in","counters":[]},{"line":"            let evaluation =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              match (delegated_stake, total_stake) with","counters":[]},{"line":"              | Some delegated_stake, Some total_stake ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  { evaluation with","counters":[]},{"line":"                    vrf_threshold =","counters":[]},{"line":"                      Some","counters":[]},{"line":"                        { delegated_stake =","counters":[]},{"line":"                            Currency.Balance.of_int delegated_stake","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                        ; total_stake = Currency.Amount.of_int total_stake","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"                        }","counters":[]},{"line":"                  }","counters":[]},{"line":"              | _ ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  evaluation","counters":[]},{"line":"            in","counters":[]},{"line":"            let evaluation =","counters":[]},{"line":"              if generate_outputs then","counters":[]},{"line":"                Evaluation.compute_vrf ~constraint_constants evaluation","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"              else evaluation","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"            in","counters":[]},{"line":"            Format.printf \"%a@.\"","counters":[]},{"line":"              (Yojson.Safe.pretty_print ?std:None)","counters":[]},{"line":"              (Evaluation.to_yojson evaluation) ;","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"            Deferred.return ()","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"        | Error err ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            eprintf \"Could not read the specified keypair: %s\\n\"","counters":[]},{"line":"              (Secrets.Privkey_error.to_string err) ;","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"            exit 1","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"      in","counters":[]},{"line":"      exit 0)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"  let batch_generate_witness =","counters":[]},{"line":"    Command.async","counters":[{"col_start":16,"col_end":16,"count":1}]},{"line":"      ~summary:","counters":[]},{"line":"        \"Generate a batch of vrf evaluation witnesses from {\\\"globalSlot\\\": _, \\","counters":[]},{"line":"         \\\"epochSeed\\\": _, \\\"delegatorIndex\\\": _} JSON message objects read on \\","counters":[]},{"line":"         stdin\"","counters":[]},{"line":"      (let open Command.Let_syntax in","counters":[]},{"line":"      let%map_open privkey_path = Flag.privkey_write_path in","counters":[]},{"line":"      Exceptions.handle_nicely","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      @@ fun () ->","counters":[]},{"line":"      let env = Secrets.Keypair.env in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      if Option.is_some (Sys.getenv env) then","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"        eprintf \"Using password from environment variable %s\\n\" env ;","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":14,"col_end":14,"count":0}]},{"line":"      let open Deferred.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      (* TODO-someday: constraint constants from config file. *)","counters":[]},{"line":"      let constraint_constants =","counters":[]},{"line":"        Genesis_constants.Constraint_constants.compiled","counters":[]},{"line":"      in","counters":[]},{"line":"      let%bind () =","counters":[]},{"line":"        let password =","counters":[]},{"line":"          lazy","counters":[]},{"line":"            (Secrets.Keypair.Terminal_stdin.prompt_password \"Enter password: \")","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"        in","counters":[]},{"line":"        match%bind Secrets.Keypair.read ~privkey_path ~password with","counters":[]},{"line":"        | Ok keypair ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let lexbuf = Lexing.from_channel In_channel.stdin in","counters":[]},{"line":"            let lexer = Yojson.init_lexer () in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            Deferred.repeat_until_finished () (fun () ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"                Deferred.Or_error.try_with (fun () ->","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"                    try","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      let message_json =","counters":[]},{"line":"                        Yojson.Safe.from_lexbuf ~stream:true lexer lexbuf","counters":[]},{"line":"                      in","counters":[]},{"line":"                      let open Consensus_vrf.Layout in","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                      let message =","counters":[]},{"line":"                        Result.ok_or_failwith (Message.of_yojson message_json)","counters":[{"col_start":63,"col_end":63,"count":0}]},{"line":"                      in","counters":[]},{"line":"                      let evaluation =","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        Evaluation.of_message_and_sk ~constraint_constants","counters":[]},{"line":"                          message keypair.private_key","counters":[]},{"line":"                      in","counters":[]},{"line":"                      Format.printf \"%a@.\"","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        (Yojson.Safe.pretty_print ?std:None)","counters":[]},{"line":"                        (Evaluation.to_yojson evaluation) ;","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"                      Deferred.return (`Repeat ())","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"                    with Yojson.End_of_input -> return (`Finished ()) )","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                >>| function","counters":[]},{"line":"                | Ok x ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    x","counters":[]},{"line":"                | Error err ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    Format.eprintf \"@[<v>Error:@,%s@,@]@.\"","counters":[]},{"line":"                      (Yojson.Safe.pretty_to_string","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                         (Error_json.error_to_yojson err) ) ;","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                    `Repeat () )","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"        | Error err ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            eprintf \"Could not read the specified keypair: %s\\n\"","counters":[]},{"line":"              (Secrets.Privkey_error.to_string err) ;","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"            exit 1","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"      in","counters":[]},{"line":"      exit 0)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"  let batch_check_witness =","counters":[]},{"line":"    Command.async","counters":[{"col_start":16,"col_end":16,"count":1}]},{"line":"      ~summary:","counters":[]},{"line":"        \"Check a batch of vrf evaluation witnesses read on stdin. Outputs the \\","counters":[]},{"line":"         verified vrf evaluations (or no vrf output if the witness is \\","counters":[]},{"line":"         invalid), and whether the vrf output satisfies the threshold values \\","counters":[]},{"line":"         if given. The threshold should be included in the JSON for each vrf \\","counters":[]},{"line":"         as the 'vrfThreshold' field, of format {delegatedStake: 1000, \\","counters":[]},{"line":"         totalStake: 1000000000}. The threshold is not checked against a \\","counters":[]},{"line":"         ledger; this should be done manually to confirm whether threshold_met \\","counters":[]},{"line":"         in the output corresponds to an actual won block.\"","counters":[]},{"line":"      ( Command.Param.return @@ Exceptions.handle_nicely","counters":[{"col_start":27,"col_end":27,"count":1},{"col_start":55,"col_end":55,"count":1}]},{"line":"      @@ fun () ->","counters":[]},{"line":"      let open Deferred.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      (* TODO-someday: constraint constants from config file. *)","counters":[]},{"line":"      let constraint_constants =","counters":[]},{"line":"        Genesis_constants.Constraint_constants.compiled","counters":[]},{"line":"      in","counters":[]},{"line":"      let lexbuf = Lexing.from_channel In_channel.stdin in","counters":[]},{"line":"      let lexer = Yojson.init_lexer () in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%bind () =","counters":[]},{"line":"        Deferred.repeat_until_finished () (fun () ->","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"            Deferred.Or_error.try_with (fun () ->","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"                try","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  let evaluation_json =","counters":[]},{"line":"                    Yojson.Safe.from_lexbuf ~stream:true lexer lexbuf","counters":[]},{"line":"                  in","counters":[]},{"line":"                  let open Consensus_vrf.Layout in","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  let evaluation =","counters":[]},{"line":"                    Result.ok_or_failwith (Evaluation.of_yojson evaluation_json)","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"                  in","counters":[]},{"line":"                  let evaluation =","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    Evaluation.compute_vrf ~constraint_constants evaluation","counters":[]},{"line":"                  in","counters":[]},{"line":"                  Format.printf \"%a@.\"","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    (Yojson.Safe.pretty_print ?std:None)","counters":[]},{"line":"                    (Evaluation.to_yojson evaluation) ;","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"                  Deferred.return (`Repeat ())","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"                with Yojson.End_of_input -> return (`Finished ()) )","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"            >>| function","counters":[]},{"line":"            | Ok x ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                x","counters":[]},{"line":"            | Error err ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Format.eprintf \"@[<v>Error:@,%s@,@]@.\"","counters":[]},{"line":"                  (Yojson.Safe.pretty_to_string","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"                     (Error_json.error_to_yojson err) ) ;","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"                `Repeat () )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"      in","counters":[]},{"line":"      exit 0 )","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"  let command_group =","counters":[]},{"line":"    Command.group ~summary:\"Commands for vrf evaluations\"","counters":[{"col_start":16,"col_end":16,"count":1}]},{"line":"      [ (\"generate-witness\", generate_witness)","counters":[]},{"line":"      ; (\"batch-generate-witness\", batch_generate_witness)","counters":[]},{"line":"      ; (\"batch-check-witness\", batch_check_witness)","counters":[]},{"line":"      ]","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}