{"filename":"src/libp2p_ipc/build.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Ipc","counters":[]},{"line":"","counters":[]},{"line":"module type Struct_builder_intf = sig","counters":[]},{"line":"  type struct_t","counters":[]},{"line":"","counters":[]},{"line":"  type t = struct_t builder_t","counters":[]},{"line":"","counters":[]},{"line":"  val init_root : ?message_size:int -> unit -> t","counters":[]},{"line":"","counters":[]},{"line":"  val to_reader : t -> struct_t reader_t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"type 'a op = 'a builder_t -> unit","counters":[]},{"line":"","counters":[]},{"line":"let noop : 'a op = Fn.ignore","counters":[]},{"line":"","counters":[]},{"line":"(* even though all of the `op` functions have the same definition, we define them with separate","counters":[]},{"line":"   types because the signature `forall a b c. (a -> b -> c)` would unsafely allow us to not fully","counters":[]},{"line":"   apply functions when constructing the DSL *)","counters":[]},{"line":"let op (type a b) (op : a builder_t -> b -> unit) (value : b) : a op =","counters":[]},{"line":" fun builder -> op builder value","counters":[{"col_start":1,"col_end":1,"count":1},{"col_start":16,"col_end":16,"count":1}]},{"line":"","counters":[]},{"line":"let list_op (type a b cap)","counters":[]},{"line":"    (op : a builder_t -> b list -> (cap, b, Builder.array_t) Capnp.Array.t)","counters":[]},{"line":"    (value : b list) : a op =","counters":[]},{"line":" fun builder -> ignore (op builder value : _ Capnp.Array.t)","counters":[{"col_start":1,"col_end":1,"count":4},{"col_start":16,"col_end":16,"count":4},{"col_start":25,"col_end":25,"count":4}]},{"line":"","counters":[]},{"line":"let reader_op (type a b) (op : a builder_t -> b reader_t -> b builder_t)","counters":[]},{"line":"    (value : b reader_t) : a op =","counters":[]},{"line":" fun builder -> ignore (op builder value : b builder_t)","counters":[{"col_start":1,"col_end":1,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"let builder_op (type a b) (op : a builder_t -> b builder_t -> b builder_t)","counters":[]},{"line":"    (value : b builder_t) : a op =","counters":[]},{"line":" fun builder -> ignore (op builder value : b builder_t)","counters":[{"col_start":1,"col_end":1,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"let optional (type a b c) (dsl_op : (a builder_t -> b -> c) -> b -> a op)","counters":[]},{"line":"    (op : a builder_t -> b -> c) (value : b option) : a op =","counters":[]},{"line":" fun builder -> Option.iter value ~f:(fun v -> dsl_op op v builder)","counters":[{"col_start":1,"col_end":1,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"","counters":[]},{"line":"let ( *> ) (type a) (x : a op) (y : a op) : a op =","counters":[]},{"line":" fun builder -> x builder ; y builder","counters":[{"col_start":1,"col_end":1,"count":4},{"col_start":16,"col_end":16,"count":4},{"col_start":28,"col_end":28,"count":4}]},{"line":"","counters":[]},{"line":"let build' (type a) (module B : Struct_builder_intf with type struct_t = a)","counters":[]},{"line":"    (op : a op) : a builder_t =","counters":[]},{"line":"  let r = B.init_root () in","counters":[{"col_start":2,"col_end":2,"count":1}]},{"line":"  op r ; r","counters":[{"col_start":2,"col_end":2,"count":1},{"col_start":9,"col_end":9,"count":1}]},{"line":"","counters":[]},{"line":"let build (type a) (module B : Struct_builder_intf with type struct_t = a)","counters":[]},{"line":"    (op : a op) : a reader_t =","counters":[]},{"line":"  B.to_reader (build' (module B) op)","counters":[{"col_start":2,"col_end":2,"count":1},{"col_start":20,"col_end":20,"count":1},{"col_start":35,"col_end":35,"count":2}]}]}