{"filename":"src/lib/mina_base/zkapp_basic.ml","lines":[{"line":"[%%import \"/src/config.mlh\"]","counters":[]},{"line":"","counters":[{"col_start":0,"col_end":0,"count":1}]},{"line":"open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"let field_of_bool = Mina_base_util.field_of_bool","counters":[]},{"line":"","counters":[]},{"line":"[%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"open Snark_params.Tick","counters":[]},{"line":"open Signature_lib","counters":[]},{"line":"","counters":[]},{"line":"[%%endif]","counters":[]},{"line":"","counters":[]},{"line":"let int_to_bits ~length x = List.init length ~f:(fun i -> (x lsr i) land 1 = 1)","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"","counters":[]},{"line":"let int_of_bits =","counters":[]},{"line":"  List.foldi ~init:0 ~f:(fun i acc b -> if b then acc lor (1 lsl i) else acc)","counters":[{"col_start":40,"col_end":40,"count":0},{"col_start":50,"col_end":50,"count":0},{"col_start":73,"col_end":73,"count":0}]},{"line":"","counters":[]},{"line":"module Transition = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type 'a t = { prev : 'a; next : 'a }","counters":[{"col_start":6,"col_end":6,"count":1},{"col_start":14,"col_end":14,"count":4},{"col_start":20,"col_end":20,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"      [@@deriving hlist, sexp, equal, yojson, hash, compare]","counters":[{"col_start":59,"col_end":59,"count":3}]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  let to_input { prev; next } ~f =","counters":[]},{"line":"    Random_oracle_input.Chunked.append (f prev) (f next)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"","counters":[]},{"line":"  [%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"  let typ t =","counters":[]},{"line":"    Typ.of_hlistable [ t; t ] ~var_to_hlist:to_hlist ~var_of_hlist:of_hlist","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ~value_to_hlist:to_hlist ~value_of_hlist:of_hlist","counters":[]},{"line":"","counters":[]},{"line":"  [%%endif]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Flagged_data = struct","counters":[]},{"line":"  type ('flag, 'a) t = { flag : 'flag; data : 'a } [@@deriving hlist, fields]","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"  [%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"  let typ flag t =","counters":[]},{"line":"    Typ.of_hlistable [ flag; t ] ~var_to_hlist:to_hlist ~var_of_hlist:of_hlist","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ~value_to_hlist:to_hlist ~value_of_hlist:of_hlist","counters":[]},{"line":"","counters":[]},{"line":"  [%%endif]","counters":[]},{"line":"","counters":[]},{"line":"  let to_input' { flag; data } ~flag:f ~data:d =","counters":[]},{"line":"    Random_oracle_input.Chunked.(append (f flag) (d data))","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Flagged_option = struct","counters":[]},{"line":"  type ('bool, 'a) t = { is_some : 'bool; data : 'a } [@@deriving hlist, fields]","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"","counters":[]},{"line":"  let to_input' ~field_of_bool { is_some; data } ~f =","counters":[]},{"line":"    Random_oracle_input.Chunked.(","counters":[{"col_start":4,"col_end":4,"count":49}]},{"line":"      append (packed (field_of_bool is_some, 1)) (f data))","counters":[{"col_start":19,"col_end":19,"count":49},{"col_start":34,"col_end":34,"count":49},{"col_start":50,"col_end":50,"count":49}]},{"line":"","counters":[]},{"line":"  let to_input { is_some; data } ~default ~f =","counters":[]},{"line":"    let data = if is_some then data else default in","counters":[{"col_start":4,"col_end":4,"count":15},{"col_start":31,"col_end":31,"count":0},{"col_start":41,"col_end":41,"count":15}]},{"line":"    to_input' { is_some; data } ~f","counters":[]},{"line":"","counters":[]},{"line":"  let of_option t ~default =","counters":[]},{"line":"    match t with","counters":[{"col_start":4,"col_end":4,"count":15}]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":15}]},{"line":"        { is_some = false; data = default }","counters":[]},{"line":"    | Some data ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { is_some = true; data }","counters":[]},{"line":"","counters":[]},{"line":"  let to_option { is_some; data } = Option.some_if is_some data","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"","counters":[]},{"line":"  let map ~f { is_some; data } = { is_some; data = f data }","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"","counters":[]},{"line":"  [%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"  let if_ ~(if_ : 'b -> then_:'var -> else_:'var -> 'var) b ~then_ ~else_ =","counters":[]},{"line":"    { is_some =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        Run.run_checked","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"          (Boolean.if_ b ~then_:then_.is_some ~else_:else_.is_some)","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"    ; data = if_ b ~then_:then_.data ~else_:else_.data","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let typ t =","counters":[]},{"line":"    Typ.of_hlistable [ Boolean.typ; t ] ~var_to_hlist:to_hlist","counters":[{"col_start":4,"col_end":4,"count":20}]},{"line":"      ~var_of_hlist:of_hlist ~value_to_hlist:to_hlist ~value_of_hlist:of_hlist","counters":[]},{"line":"","counters":[]},{"line":"  let option_typ ~default t =","counters":[]},{"line":"    Typ.transport (typ t) ~there:(of_option ~default) ~back:to_option","counters":[{"col_start":4,"col_end":4,"count":20},{"col_start":21,"col_end":21,"count":20}]},{"line":"","counters":[]},{"line":"  [%%endif]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Set_or_keep = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type 'a t = 'a Mina_wire_types.Mina_base.Zkapp_basic.Set_or_keep.V1.t =","counters":[{"col_start":6,"col_end":6,"count":8},{"col_start":14,"col_end":14,"count":4}]},{"line":"        | Set of 'a","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"        | Keep","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      [@@deriving sexp, equal, compare, hash, yojson]","counters":[{"col_start":52,"col_end":52,"count":17}]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  let map t ~f = match t with Keep -> Keep | Set x -> Set (f x)","counters":[{"col_start":17,"col_end":17,"count":2},{"col_start":30,"col_end":30,"count":2},{"col_start":45,"col_end":45,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"","counters":[]},{"line":"  let to_option = function Set x -> Some x | Keep -> None","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":45,"col_end":45,"count":15}]},{"line":"","counters":[]},{"line":"  let of_option = function Some x -> Set x | None -> Keep","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"","counters":[]},{"line":"  let set_or_keep t x = match t with Keep -> x | Set y -> y","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"","counters":[]},{"line":"  let is_set = function Set _ -> true | _ -> false","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"  let is_keep = function Keep -> true | _ -> false","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"  let deriver inner obj =","counters":[]},{"line":"    let open Fields_derivers_zkapps.Derivers in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    iso ~map:of_option ~contramap:to_option","counters":[]},{"line":"      ((option ~js_type:Flagged_option @@ inner @@ o ()) (o ()))","counters":[{"col_start":37,"col_end":37,"count":0},{"col_start":46,"col_end":46,"count":0},{"col_start":51,"col_end":51,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"      obj","counters":[]},{"line":"","counters":[]},{"line":"  let gen gen_a =","counters":[]},{"line":"    let open Quickcheck.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":1}]},{"line":"    (* with equal probability, return a Set or a Keep *)","counters":[]},{"line":"    let%bind b = Quickcheck.Generator.bool in","counters":[]},{"line":"    if b then","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let%bind a = gen_a in","counters":[]},{"line":"      return (Set a)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    else return Keep","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"  [%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"  module Checked : sig","counters":[]},{"line":"    type 'a t","counters":[]},{"line":"","counters":[]},{"line":"    val is_keep : _ t -> Boolean.var","counters":[]},{"line":"","counters":[]},{"line":"    val is_set : _ t -> Boolean.var","counters":[]},{"line":"","counters":[]},{"line":"    val set_or_keep :","counters":[]},{"line":"      if_:(Boolean.var -> then_:'a -> else_:'a -> 'a) -> 'a t -> 'a -> 'a","counters":[]},{"line":"","counters":[]},{"line":"    val data : 'a t -> 'a","counters":[]},{"line":"","counters":[]},{"line":"    val typ :","counters":[]},{"line":"      dummy:'a -> ('a_var, 'a) Typ.t -> ('a_var t, 'a Stable.Latest.t) Typ.t","counters":[]},{"line":"","counters":[]},{"line":"    val optional_typ :","counters":[]},{"line":"         to_option:('new_value -> 'value option)","counters":[]},{"line":"      -> of_option:('value option -> 'new_value)","counters":[]},{"line":"      -> ('var, 'new_value) Typ.t","counters":[]},{"line":"      -> ('var t, 'value Stable.Latest.t) Typ.t","counters":[]},{"line":"","counters":[]},{"line":"    val map : f:('a -> 'b) -> 'a t -> 'b t","counters":[]},{"line":"","counters":[]},{"line":"    val to_input :","counters":[]},{"line":"         'a t","counters":[]},{"line":"      -> f:('a -> Field.Var.t Random_oracle_input.Chunked.t)","counters":[]},{"line":"      -> Field.Var.t Random_oracle_input.Chunked.t","counters":[]},{"line":"","counters":[]},{"line":"    val set : 'a -> 'a t","counters":[]},{"line":"","counters":[]},{"line":"    val keep : dummy:'a -> 'a t","counters":[]},{"line":"","counters":[]},{"line":"    val make_unsafe : Boolean.var -> 'a -> 'a t","counters":[]},{"line":"  end = struct","counters":[]},{"line":"    type 'a t = (Boolean.var, 'a) Flagged_option.t","counters":[]},{"line":"","counters":[]},{"line":"    let set_or_keep ~if_ ({ is_some; data } : _ t) x =","counters":[]},{"line":"      if_ is_some ~then_:data ~else_:x","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let data = Flagged_option.data","counters":[]},{"line":"","counters":[]},{"line":"    let is_set = Flagged_option.is_some","counters":[]},{"line":"","counters":[]},{"line":"    let is_keep x = Boolean.not (Flagged_option.is_some x)","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"","counters":[]},{"line":"    let map = Flagged_option.map","counters":[]},{"line":"","counters":[]},{"line":"    let typ ~dummy t =","counters":[]},{"line":"      Typ.transport","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (Flagged_option.option_typ ~default:dummy t)","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"        ~there:to_option ~back:of_option","counters":[]},{"line":"","counters":[]},{"line":"    let optional_typ (type new_value value var) :","counters":[]},{"line":"           to_option:(new_value -> value option)","counters":[]},{"line":"        -> of_option:(value option -> new_value)","counters":[]},{"line":"        -> (var, new_value) Typ.t","counters":[]},{"line":"        -> (var t, value Stable.Latest.t) Typ.t =","counters":[]},{"line":"     fun ~to_option ~of_option t ->","counters":[]},{"line":"      Typ.transport (Flagged_option.typ t)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"        ~there:(function","counters":[]},{"line":"          | Set x ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              { Flagged_option.is_some = true; data = of_option (Some x) }","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"          | Keep ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              { Flagged_option.is_some = false; data = of_option None } )","counters":[{"col_start":63,"col_end":63,"count":0}]},{"line":"        ~back:(function","counters":[]},{"line":"          | { Flagged_option.is_some = true; data = x } ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Set (Option.value_exn (to_option x))","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"          | { Flagged_option.is_some = false; data = _ } ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Keep )","counters":[]},{"line":"","counters":[]},{"line":"    let to_input (t : _ t) ~f =","counters":[]},{"line":"      Flagged_option.to_input' t ~f ~field_of_bool:(fun (b : Boolean.var) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          (b :> Field.Var.t) )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"    let make_unsafe is_keep data = { Flagged_option.is_some = is_keep; data }","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"    let set data = { Flagged_option.is_some = Boolean.true_; data }","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"","counters":[]},{"line":"    let keep ~dummy = { Flagged_option.is_some = Boolean.false_; data = dummy }","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let typ = Checked.typ","counters":[]},{"line":"","counters":[]},{"line":"  let optional_typ = Checked.optional_typ","counters":[]},{"line":"","counters":[]},{"line":"  [%%endif]","counters":[]},{"line":"","counters":[]},{"line":"  let to_input t ~dummy:default ~f =","counters":[]},{"line":"    Flagged_option.to_input ~default ~f ~field_of_bool","counters":[{"col_start":4,"col_end":4,"count":15}]},{"line":"      (Flagged_option.of_option ~default (to_option t))","counters":[{"col_start":30,"col_end":30,"count":15},{"col_start":50,"col_end":50,"count":15}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Or_ignore = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type 'a t = 'a Mina_wire_types.Mina_base.Zkapp_basic.Or_ignore.V1.t =","counters":[{"col_start":6,"col_end":6,"count":14},{"col_start":14,"col_end":14,"count":4}]},{"line":"        | Check of 'a","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":20,"col_end":20,"count":0}]},{"line":"        | Ignore","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      [@@deriving sexp, equal, compare, hash, yojson]","counters":[{"col_start":52,"col_end":52,"count":29}]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  let gen gen_a =","counters":[]},{"line":"    let open Quickcheck.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":3}]},{"line":"    (* choose constructor *)","counters":[]},{"line":"    let%bind b = Quickcheck.Generator.bool in","counters":[]},{"line":"    if b then","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let%map a = gen_a in","counters":[]},{"line":"      Check a","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    else return Ignore","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"  let to_option = function Ignore -> None | Check x -> Some x","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"  let of_option = function None -> Ignore | Some x -> Check x","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"  let deriver_base ~js_type inner obj =","counters":[]},{"line":"    let open Fields_derivers_zkapps.Derivers in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    iso ~map:of_option ~contramap:to_option","counters":[]},{"line":"      ((option ~js_type @@ inner @@ o ()) (o ()))","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"      obj","counters":[]},{"line":"","counters":[]},{"line":"  let deriver inner obj = deriver_base ~js_type:Flagged_option inner obj","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"","counters":[]},{"line":"  let deriver_interval inner obj ~range_max =","counters":[]},{"line":"    deriver_base ~js_type:(Closed_interval range_max) inner obj","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  [%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"  module Checked : sig","counters":[]},{"line":"    type 'a t","counters":[]},{"line":"","counters":[]},{"line":"    val typ :","counters":[]},{"line":"      ignore:'a -> ('a_var, 'a) Typ.t -> ('a_var t, 'a Stable.Latest.t) Typ.t","counters":[]},{"line":"","counters":[]},{"line":"    val to_input :","counters":[]},{"line":"         'a t","counters":[]},{"line":"      -> f:('a -> Field.Var.t Random_oracle_input.Chunked.t)","counters":[]},{"line":"      -> Field.Var.t Random_oracle_input.Chunked.t","counters":[]},{"line":"","counters":[]},{"line":"    val check : 'a t -> f:('a -> Boolean.var) -> Boolean.var","counters":[]},{"line":"","counters":[]},{"line":"    val map : f:('a -> 'b) -> 'a t -> 'b t","counters":[]},{"line":"","counters":[]},{"line":"    val data : 'a t -> 'a","counters":[]},{"line":"","counters":[]},{"line":"    val is_check : 'a t -> Boolean.var","counters":[]},{"line":"","counters":[]},{"line":"    val make_unsafe : Boolean.var -> 'a -> 'a t","counters":[]},{"line":"  end = struct","counters":[]},{"line":"    type 'a t = (Boolean.var, 'a) Flagged_option.t","counters":[]},{"line":"","counters":[]},{"line":"    let to_input t ~f =","counters":[]},{"line":"      Flagged_option.to_input' t ~f ~field_of_bool:(fun (b : Boolean.var) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          (b :> Field.Var.t) )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"    let check { Flagged_option.is_some; data } ~f =","counters":[]},{"line":"      Pickles.Impls.Step.Boolean.(any [ not is_some; f data ])","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"","counters":[]},{"line":"    let map = Flagged_option.map","counters":[]},{"line":"","counters":[]},{"line":"    let data = Flagged_option.data","counters":[]},{"line":"","counters":[]},{"line":"    let is_check = Flagged_option.is_some","counters":[]},{"line":"","counters":[]},{"line":"    let typ (type a_var a) ~ignore (t : (a_var, a) Typ.t) =","counters":[]},{"line":"      Typ.transport","counters":[{"col_start":6,"col_end":6,"count":19}]},{"line":"        (Flagged_option.option_typ ~default:ignore t)","counters":[{"col_start":33,"col_end":33,"count":19}]},{"line":"        ~there:to_option ~back:of_option","counters":[]},{"line":"","counters":[]},{"line":"    let make_unsafe is_ignore data =","counters":[]},{"line":"      { Flagged_option.is_some = is_ignore; data }","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let typ = Checked.typ","counters":[]},{"line":"","counters":[]},{"line":"  [%%endif]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Account_state = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type t = Empty | Non_empty | Any","counters":[{"col_start":6,"col_end":6,"count":2},{"col_start":11,"col_end":11,"count":2},{"col_start":15,"col_end":15,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"      [@@deriving sexp, equal, yojson, hash, compare, enum]","counters":[{"col_start":58,"col_end":58,"count":5}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  module Encoding = struct","counters":[]},{"line":"    type 'b t = { any : 'b; empty : 'b } [@@deriving hlist]","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"    let to_input ~field_of_bool { any; empty } =","counters":[]},{"line":"      Random_oracle_input.Chunked.packeds","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [| (field_of_bool any, 1); (field_of_bool empty, 1) |]","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let encode : t -> bool Encoding.t = function","counters":[]},{"line":"    | Empty ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { any = false; empty = true }","counters":[]},{"line":"    | Non_empty ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { any = false; empty = false }","counters":[]},{"line":"    | Any ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { any = true; empty = false }","counters":[]},{"line":"","counters":[]},{"line":"  let decode : bool Encoding.t -> t = function","counters":[]},{"line":"    | { any = false; empty = true } ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Empty","counters":[]},{"line":"    | { any = false; empty = false } ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Non_empty","counters":[]},{"line":"    | { any = true; empty = false } | { any = true; empty = true } ->","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"        Any","counters":[]},{"line":"","counters":[]},{"line":"  let to_input (x : t) = Encoding.to_input ~field_of_bool (encode x)","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"","counters":[]},{"line":"  let check (t : t) (x : [ `Empty | `Non_empty ]) =","counters":[]},{"line":"    match (t, x) with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Any, _ | Non_empty, `Non_empty | Empty, `Empty ->","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"        Ok ()","counters":[]},{"line":"    | _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Or_error.error_string \"Bad account_type\"","counters":[]},{"line":"","counters":[]},{"line":"  [%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"  module Checked = struct","counters":[]},{"line":"    open Pickles.Impls.Step","counters":[]},{"line":"","counters":[]},{"line":"    type t = Boolean.var Encoding.t","counters":[]},{"line":"","counters":[]},{"line":"    let to_input (t : t) =","counters":[]},{"line":"      Encoding.to_input t ~field_of_bool:(fun (b : Boolean.var) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          (b :> Field.t) )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"    let check (t : t) ~is_empty =","counters":[]},{"line":"      Boolean.(","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        any [ t.any; t.empty && is_empty; (not t.empty) && not is_empty ])","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let typ : (Checked.t, t) Typ.t =","counters":[]},{"line":"    let open Encoding in","counters":[]},{"line":"    Typ.of_hlistable","counters":[{"col_start":19,"col_end":19,"count":1}]},{"line":"      [ Boolean.typ; Boolean.typ ]","counters":[]},{"line":"      ~var_to_hlist:to_hlist ~var_of_hlist:of_hlist ~value_to_hlist:to_hlist","counters":[]},{"line":"      ~value_of_hlist:of_hlist","counters":[]},{"line":"    |> Typ.transport ~there:encode ~back:decode","counters":[{"col_start":19,"col_end":19,"count":1}]},{"line":"","counters":[]},{"line":"  [%%endif]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"[%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"module F = Pickles.Backend.Tick.Field","counters":[]},{"line":"","counters":[]},{"line":"[%%else]","counters":[]},{"line":"","counters":[]},{"line":"module F = Snark_params.Tick.Field","counters":[]},{"line":"","counters":[]},{"line":"[%%endif]","counters":[]},{"line":"","counters":[]},{"line":"let invalid_public_key : Public_key.Compressed.t =","counters":[]},{"line":"  { x = F.zero; is_odd = false }","counters":[]},{"line":"","counters":[]},{"line":"let%test \"invalid_public_key is invalid\" =","counters":[]},{"line":"  Option.is_none (Public_key.decompress invalid_public_key)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":58,"col_end":58,"count":1}]}]}