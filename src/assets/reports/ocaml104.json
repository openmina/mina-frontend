{"filename":"src/lib/transition_frontier/persistent_frontier/diff_buffer.ml","lines":[{"line":"(* TODO: flush on timeout interval in addition to meeting flush capacity *)","counters":[{"col_start":74,"col_end":74,"count":1}]},{"line":"open Async_kernel","counters":[]},{"line":"open Core_kernel","counters":[]},{"line":"open Frontier_base","counters":[]},{"line":"","counters":[]},{"line":"let max_latency","counters":[]},{"line":"    { Genesis_constants.Constraint_constants.block_window_duration_ms; _ } =","counters":[]},{"line":"  Block_time.Span.(","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    (block_window_duration_ms |> Int64.of_int |> Block_time.Span.of_ms)","counters":[{"col_start":44,"col_end":44,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"    * of_ms 5L)","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"module Capacity = struct","counters":[]},{"line":"  let flush = 30","counters":[]},{"line":"","counters":[]},{"line":"  let max = flush * 4","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(* TODO: lift up as Block_time utility *)","counters":[]},{"line":"module Timer = struct","counters":[]},{"line":"  open Block_time","counters":[]},{"line":"","counters":[]},{"line":"  type t =","counters":[]},{"line":"    { time_controller : Controller.t","counters":[]},{"line":"    ; f : unit -> unit","counters":[]},{"line":"    ; span : Span.t","counters":[]},{"line":"    ; mutable timeout : unit Timeout.t option","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let create ~time_controller ~f span =","counters":[]},{"line":"    { time_controller; span; f; timeout = None }","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let start t =","counters":[]},{"line":"    assert (Option.is_none t.timeout) ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":11,"col_end":11,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"    let rec run_timeout t =","counters":[]},{"line":"      t.timeout <-","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Some","counters":[]},{"line":"          (Timeout.create t.time_controller t.span ~f:(fun _ ->","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"               t.f () ; run_timeout t ) )","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"    in","counters":[]},{"line":"    run_timeout t","counters":[]},{"line":"","counters":[]},{"line":"  let stop t =","counters":[]},{"line":"    Option.iter t.timeout ~f:(fun timeout ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        Timeout.cancel t.time_controller timeout () ) ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    t.timeout <- None","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let reset t = stop t ; start t","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"type work = { diffs : Diff.Lite.E.t list }","counters":[]},{"line":"","counters":[]},{"line":"type t =","counters":[]},{"line":"  { diff_array : Diff.Lite.E.t DynArray.t","counters":[]},{"line":"  ; worker : Worker.t","counters":[]},{"line":"        (* timer unfortunately needs to be mutable to break recursion *)","counters":[]},{"line":"  ; mutable timer : Timer.t option","counters":[]},{"line":"  ; mutable flush_job : unit Deferred.t option","counters":[]},{"line":"  ; mutable closed : bool","counters":[]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"let check_for_overflow t =","counters":[]},{"line":"  if DynArray.length t.diff_array > Capacity.max then","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"    failwith \"persistence buffer overflow\"","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"let should_flush t = DynArray.length t.diff_array >= Capacity.flush","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"let flush t =","counters":[]},{"line":"  let rec flush_job t =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    let diffs = DynArray.to_list t.diff_array in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    DynArray.clear t.diff_array ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    DynArray.compact t.diff_array ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let%bind () = Worker.dispatch t.worker diffs in","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"    if should_flush t then flush_job t","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"    else (","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"      t.flush_job <- None ;","counters":[]},{"line":"      Deferred.unit )","counters":[]},{"line":"  in","counters":[]},{"line":"  assert (Option.is_none t.flush_job) ;","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"  if DynArray.length t.diff_array > 0 then t.flush_job <- Some (flush_job t)","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":43,"col_end":43,"count":0},{"col_start":72,"col_end":72,"count":0}]},{"line":"","counters":[]},{"line":"let create ~(constraint_constants : Genesis_constants.Constraint_constants.t)","counters":[]},{"line":"    ~time_controller ~worker =","counters":[]},{"line":"  let t =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    { diff_array = DynArray.create ()","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"    ; worker","counters":[]},{"line":"    ; timer = None","counters":[]},{"line":"    ; flush_job = None","counters":[]},{"line":"    ; closed = false","counters":[]},{"line":"    }","counters":[]},{"line":"  in","counters":[]},{"line":"  let timer =","counters":[]},{"line":"    Timer.create ~time_controller","counters":[]},{"line":"      ~f:(fun () -> if Option.is_none t.flush_job then flush t)","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"      (max_latency constraint_constants)","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"  in","counters":[]},{"line":"  t.timer <- Some timer ;","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  t","counters":[]},{"line":"","counters":[]},{"line":"let write t ~diffs =","counters":[]},{"line":"  if t.closed then failwith \"attempt to write to diff buffer after closed\" ;","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"  List.iter diffs ~f:(DynArray.add t.diff_array) ;","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"  if should_flush t && Option.is_none t.flush_job then flush t","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"  else check_for_overflow t","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"","counters":[]},{"line":"let close_and_finish_copy t =","counters":[]},{"line":"  ( match t.timer with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | None ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      failwith \"diff buffer timer was never initialized\"","counters":[]},{"line":"  | Some timer ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Timer.stop timer ) ;","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"  t.closed <- true ;","counters":[]},{"line":"  let%bind () = Option.value t.flush_job ~default:Deferred.unit in","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"  flush t ;","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  Option.value t.flush_job ~default:Deferred.unit","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":48,"col_end":48,"count":2}]}]}