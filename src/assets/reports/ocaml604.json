{"filename":"src/lib/pickles/composition_types/spec.ml","lines":[{"line":"module D = Digest","counters":[]},{"line":"open Core_kernel","counters":[]},{"line":"open Pickles_types","counters":[]},{"line":"open Hlist","counters":[]},{"line":"module Sc = Kimchi_backend_common.Scalar_challenge","counters":[]},{"line":"","counters":[]},{"line":"type 'f impl = (module Snarky_backendless.Snark_intf.Run with type field = 'f)","counters":[]},{"line":"","counters":[]},{"line":"module Basic = struct","counters":[]},{"line":"  type (_, _, _) t =","counters":[]},{"line":"    | Field : ('field1, 'field2, < field1 : 'field1 ; field2 : 'field2 ; .. >) t","counters":[]},{"line":"    | Bool : ('bool1, 'bool2, < bool1 : 'bool1 ; bool2 : 'bool2 ; .. >) t","counters":[]},{"line":"    | Digest","counters":[]},{"line":"        : ( 'digest1","counters":[]},{"line":"          , 'digest2","counters":[]},{"line":"          , < digest1 : 'digest1 ; digest2 : 'digest2 ; .. > )","counters":[]},{"line":"          t","counters":[]},{"line":"    | Challenge","counters":[]},{"line":"        : ( 'challenge1","counters":[]},{"line":"          , 'challenge2","counters":[]},{"line":"          , < challenge1 : 'challenge1 ; challenge2 : 'challenge2 ; .. > )","counters":[]},{"line":"          t","counters":[]},{"line":"    | Bulletproof_challenge","counters":[]},{"line":"        : ( 'bp_chal1","counters":[]},{"line":"          , 'bp_chal2","counters":[]},{"line":"          , < bulletproof_challenge1 : 'bp_chal1","counters":[]},{"line":"            ; bulletproof_challenge2 : 'bp_chal2","counters":[]},{"line":"            ; .. > )","counters":[]},{"line":"          t","counters":[]},{"line":"    | Branch_data","counters":[]},{"line":"        : ( 'branch_data1","counters":[]},{"line":"          , 'branch_data2","counters":[]},{"line":"          , < branch_data1 : 'branch_data1 ; branch_data2 : 'branch_data2 ; .. >","counters":[]},{"line":"          )","counters":[]},{"line":"          t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"open Basic","counters":[]},{"line":"","counters":[]},{"line":"type ('a, 'b, 'c) basic = ('a, 'b, 'c) Basic.t =","counters":[]},{"line":"  | Field","counters":[]},{"line":"      : ('field1, 'field2, < field1 : 'field1 ; field2 : 'field2 ; .. >) basic","counters":[]},{"line":"  | Bool : ('bool1, 'bool2, < bool1 : 'bool1 ; bool2 : 'bool2 ; .. >) basic","counters":[]},{"line":"  | Digest","counters":[]},{"line":"      : ( 'digest1","counters":[]},{"line":"        , 'digest2","counters":[]},{"line":"        , < digest1 : 'digest1 ; digest2 : 'digest2 ; .. > )","counters":[]},{"line":"        basic","counters":[]},{"line":"  | Challenge","counters":[]},{"line":"      : ( 'challenge1","counters":[]},{"line":"        , 'challenge2","counters":[]},{"line":"        , < challenge1 : 'challenge1 ; challenge2 : 'challenge2 ; .. > )","counters":[]},{"line":"        basic","counters":[]},{"line":"  | Bulletproof_challenge","counters":[]},{"line":"      : ( 'bp_chal1","counters":[]},{"line":"        , 'bp_chal2","counters":[]},{"line":"        , < bulletproof_challenge1 : 'bp_chal1","counters":[]},{"line":"          ; bulletproof_challenge2 : 'bp_chal2","counters":[]},{"line":"          ; .. > )","counters":[]},{"line":"        basic","counters":[]},{"line":"  | Branch_data","counters":[]},{"line":"      : ( 'branch_data1","counters":[]},{"line":"        , 'branch_data2","counters":[]},{"line":"        , < branch_data1 : 'branch_data1 ; branch_data2 : 'branch_data2 ; .. >","counters":[]},{"line":"        )","counters":[]},{"line":"        basic","counters":[]},{"line":"","counters":[]},{"line":"module type Bool_intf = sig","counters":[]},{"line":"  type var","counters":[]},{"line":"","counters":[]},{"line":"  val true_ : var","counters":[]},{"line":"","counters":[]},{"line":"  val false_ : var","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module rec T : sig","counters":[]},{"line":"  type (_, _, _) t =","counters":[]},{"line":"    | B : ('a, 'b, 'env) Basic.t -> ('a, 'b, 'env) t","counters":[]},{"line":"    | Scalar :","counters":[]},{"line":"        ('a, 'b, (< challenge1 : 'a ; challenge2 : 'b ; .. > as 'env)) Basic.t","counters":[]},{"line":"        -> ('a Sc.t, 'b Sc.t, 'env) t","counters":[]},{"line":"    | Vector :","counters":[]},{"line":"        ('t1, 't2, 'env) t * 'n Nat.t","counters":[]},{"line":"        -> (('t1, 'n) Vector.t, ('t2, 'n) Vector.t, 'env) t","counters":[]},{"line":"    | Array : ('t1, 't2, 'env) t * int -> ('t1 array, 't2 array, 'env) t","counters":[]},{"line":"    | Struct :","counters":[]},{"line":"        ('xs1, 'xs2, 'env) H2_1.T(T).t","counters":[]},{"line":"        -> ('xs1 Hlist.HlistId.t, 'xs2 Hlist.HlistId.t, 'env) t","counters":[]},{"line":"    | Opt :","counters":[]},{"line":"        { inner : ('a1, 'a2, (< bool1 : bool ; bool2 : 'bool ; .. > as 'env)) t","counters":[]},{"line":"        ; flag : Plonk_types.Opt.Flag.t","counters":[]},{"line":"        ; dummy1 : 'a1","counters":[]},{"line":"        ; dummy2 : 'a2","counters":[]},{"line":"        ; bool : (module Bool_intf with type var = 'bool)","counters":[]},{"line":"        }","counters":[]},{"line":"        -> ('a1 option, ('a2, 'bool) Plonk_types.Opt.t, 'env) t","counters":[]},{"line":"end =","counters":[]},{"line":"  T","counters":[]},{"line":"","counters":[]},{"line":"include T","counters":[]},{"line":"","counters":[]},{"line":"type ('scalar, 'env) pack =","counters":[]},{"line":"  { pack : 'a 'b. ('a, 'b, 'env) Basic.t -> 'b -> 'scalar array }","counters":[]},{"line":"","counters":[]},{"line":"let rec pack :","counters":[]},{"line":"    type t v env.","counters":[]},{"line":"       zero:'scalar","counters":[]},{"line":"    -> one:'scalar","counters":[]},{"line":"    -> ('scalar, env) pack","counters":[]},{"line":"    -> (t, v, env) T.t","counters":[]},{"line":"    -> v","counters":[]},{"line":"    -> 'scalar array =","counters":[]},{"line":" fun ~zero ~one p spec t ->","counters":[]},{"line":"  match spec with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | B spec ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      p.pack spec t","counters":[]},{"line":"  | Scalar chal ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let { Sc.inner = t } = t in","counters":[]},{"line":"      p.pack chal t","counters":[]},{"line":"  | Vector (spec, _) ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Array.concat_map (Vector.to_array t) ~f:(pack ~zero ~one p spec)","counters":[{"col_start":38,"col_end":38,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"  | Struct [] ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      [||]","counters":[]},{"line":"  | Struct (spec :: specs) ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let (hd :: tl) = t in","counters":[]},{"line":"      let hd = pack ~zero ~one p spec hd in","counters":[]},{"line":"      Array.append hd (pack ~zero ~one p (Struct specs) tl)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"  | Array (spec, _) ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Array.concat_map t ~f:(pack ~zero ~one p spec)","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"  | Opt { inner; flag; dummy1 = _; dummy2 } -> (","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      match t with","counters":[]},{"line":"      | None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Array.append [| zero |] (pack ~zero ~one p inner dummy2)","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"      | Some x ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Array.append [| one |] (pack ~zero ~one p inner x)","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"      | Maybe (b, x) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Array.append (p.pack Bool b) (pack ~zero ~one p inner x) )","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"","counters":[]},{"line":"type ('f, 'env) typ =","counters":[]},{"line":"  { typ :","counters":[]},{"line":"      'var 'value.","counters":[]},{"line":"         ('value, 'var, 'env) Basic.t","counters":[]},{"line":"      -> ('var, 'value, 'f) Snarky_backendless.Typ.t","counters":[]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"let rec typ :","counters":[]},{"line":"    type f var value env.","counters":[]},{"line":"       (f, env) typ","counters":[]},{"line":"    -> (value, var, env) T.t","counters":[]},{"line":"    -> (var, value, f) Snarky_backendless.Typ.t =","counters":[]},{"line":"  let open Snarky_backendless.Typ in","counters":[]},{"line":"  fun t spec ->","counters":[]},{"line":"    match spec with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | B spec ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        t.typ spec","counters":[]},{"line":"    | Scalar chal ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Sc.typ (t.typ chal)","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"    | Vector (spec, n) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Vector.typ (typ t spec) n","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"    | Array (spec, n) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        array ~length:n (typ t spec)","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"    | Struct [] ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let open Hlist.HlistId in","counters":[]},{"line":"        transport (unit ()) ~there:(fun [] -> ()) ~back:(fun () -> [])","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":46,"col_end":46,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"        |> transport_var ~there:(fun [] -> ()) ~back:(fun () -> [])","counters":[{"col_start":43,"col_end":43,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"    | Struct (spec :: specs) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let open Hlist.HlistId in","counters":[]},{"line":"        tuple2 (typ t spec) (typ t (Struct specs))","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"        |> transport","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"             ~there:(fun (x :: xs) -> (x, xs))","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"             ~back:(fun (x, xs) -> x :: xs)","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"        |> transport_var","counters":[]},{"line":"             ~there:(fun (x :: xs) -> (x, xs))","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"             ~back:(fun (x, xs) -> x :: xs)","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"    | Opt { inner; flag; dummy1; dummy2; bool = (module B) } ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let bool = typ t (B Bool) in","counters":[]},{"line":"        let open B in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        (* Always use the same \"maybe\" layout which is a boolean and then the value *)","counters":[]},{"line":"        Plonk_types.Opt.constant_layout_typ bool flag ~dummy:dummy1","counters":[]},{"line":"          ~dummy_var:dummy2 ~true_ ~false_ (typ t inner)","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"","counters":[]},{"line":"type 'env exists = T : ('t1, 't2, 'env) T.t -> 'env exists","counters":[]},{"line":"","counters":[]},{"line":"type generic_spec = { spec : 'env. 'env exists }","counters":[]},{"line":"","counters":[]},{"line":"module ETyp = struct","counters":[]},{"line":"  type ('var, 'value, 'f) t =","counters":[]},{"line":"    | T :","counters":[]},{"line":"        ('inner, 'value, 'f) Snarky_backendless.Typ.t","counters":[]},{"line":"        * ('inner -> 'var)","counters":[]},{"line":"        * ('var -> 'inner)","counters":[]},{"line":"        -> ('var, 'value, 'f) t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"type ('f, 'env) etyp =","counters":[]},{"line":"  { etyp :","counters":[]},{"line":"      'var 'value. ('value, 'var, 'env) Basic.t -> ('var, 'value, 'f) ETyp.t","counters":[]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"let rec etyp :","counters":[]},{"line":"    type f var value env.","counters":[]},{"line":"    (f, env) etyp -> (value, var, env) T.t -> (var, value, f) ETyp.t =","counters":[]},{"line":"  let open Snarky_backendless.Typ in","counters":[]},{"line":"  fun e spec ->","counters":[]},{"line":"    match spec with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | B spec ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        e.etyp spec","counters":[]},{"line":"    | Scalar chal ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let (T (typ, f, f_inv)) = e.etyp chal in","counters":[]},{"line":"        T (Sc.typ typ, Sc.map ~f, Sc.map ~f:f_inv)","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":16,"col_end":16,"count":0}]},{"line":"    | Vector (spec, n) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let (T (typ, f, f_inv)) = etyp e spec in","counters":[]},{"line":"        T (Vector.typ typ n, Vector.map ~f, Vector.map ~f:f_inv)","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":20,"col_end":20,"count":0}]},{"line":"    | Array (spec, n) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let (T (typ, f, f_inv)) = etyp e spec in","counters":[]},{"line":"        T (array ~length:n typ, Array.map ~f, Array.map ~f:f_inv)","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"    | Struct [] ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let open Hlist.HlistId in","counters":[]},{"line":"        let there [] = () in","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"        let back () = [] in","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"        T","counters":[]},{"line":"          ( transport (unit ()) ~there ~back |> transport_var ~there ~back","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"          , Fn.id","counters":[]},{"line":"          , Fn.id )","counters":[]},{"line":"    | Struct (spec :: specs) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let open Hlist.HlistId in","counters":[]},{"line":"        let (T (t1, f1, f1_inv)) = etyp e spec in","counters":[]},{"line":"        let (T (t2, f2, f2_inv)) = etyp e (Struct specs) in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        T","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ( tuple2 t1 t2","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"            |> transport","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                 ~there:(fun (x :: xs) -> (x, xs))","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"                 ~back:(fun (x, xs) -> x :: xs)","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"          , (fun (x, xs) -> f1 x :: f2 xs)","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"          , fun (x :: xs) -> (f1_inv x, f2_inv xs) )","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"    | Opt { inner; flag; dummy1; dummy2; bool = (module B) } ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let (T (bool, f_bool, f_bool')) = etyp e (B Bool) in","counters":[]},{"line":"        let (T (a, f_a, f_a')) = etyp e inner in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let opt_map ~f1 ~f2 (x : _ Plonk_types.Opt.t) : _ Plonk_types.Opt.t =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          match x with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              None","counters":[]},{"line":"          | Some x ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Some (f1 x)","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"          | Maybe (b, x) ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Maybe (f2 b, f1 x)","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"        in","counters":[]},{"line":"        let f = opt_map ~f1:f_a ~f2:f_bool in","counters":[]},{"line":"        let f' = opt_map ~f1:f_a' ~f2:f_bool' in","counters":[]},{"line":"        T","counters":[]},{"line":"          ( Plonk_types.Opt.constant_layout_typ ~dummy:dummy1","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"              ~dummy_var:(f_a' dummy2) ~true_:(f_bool' B.true_)","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"              ~false_:(f_bool' B.false_) bool flag a","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"          , f","counters":[]},{"line":"          , f' )","counters":[]},{"line":"","counters":[]},{"line":"module Common (Impl : Snarky_backendless.Snark_intf.Run) = struct","counters":[]},{"line":"  module Digest = D.Make (Impl)","counters":[]},{"line":"  module Challenge = Limb_vector.Challenge.Make (Impl)","counters":[]},{"line":"  open Impl","counters":[]},{"line":"","counters":[]},{"line":"  module Env = struct","counters":[]},{"line":"    type ('other_field, 'other_field_var, 'a) t =","counters":[]},{"line":"      < field1 : 'other_field","counters":[]},{"line":"      ; field2 : 'other_field_var","counters":[]},{"line":"      ; bool1 : bool","counters":[]},{"line":"      ; bool2 : Boolean.var","counters":[]},{"line":"      ; digest1 : Digest.Constant.t","counters":[]},{"line":"      ; digest2 : Digest.t","counters":[]},{"line":"      ; challenge1 : Challenge.Constant.t","counters":[]},{"line":"      ; challenge2 : Challenge.t","counters":[]},{"line":"      ; bulletproof_challenge1 :","counters":[]},{"line":"          Challenge.Constant.t Sc.t Bulletproof_challenge.t","counters":[]},{"line":"      ; bulletproof_challenge2 : Challenge.t Sc.t Bulletproof_challenge.t","counters":[]},{"line":"      ; branch_data1 : Branch_data.t","counters":[]},{"line":"      ; branch_data2 : Impl.field Branch_data.Checked.t","counters":[]},{"line":"      ; .. >","counters":[]},{"line":"      as","counters":[]},{"line":"      'a","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let pack_basic (type field other_field other_field_var)","counters":[]},{"line":"    ((module Impl) : field impl) =","counters":[]},{"line":"  let open Impl in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let module C = Common (Impl) in","counters":[]},{"line":"  let open C in","counters":[]},{"line":"  let pack :","counters":[]},{"line":"      type a b.","counters":[]},{"line":"         (a, b, ((other_field, other_field_var, 'e) Env.t as 'e)) Basic.t","counters":[]},{"line":"      -> b","counters":[]},{"line":"      -> [ `Field of other_field_var | `Packed_bits of Field.t * int ] array =","counters":[]},{"line":"   fun basic x ->","counters":[]},{"line":"    match basic with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Field ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [| `Field x |]","counters":[]},{"line":"    | Bool ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [| `Packed_bits ((x :> Field.t), 1) |]","counters":[]},{"line":"    | Digest ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [| `Packed_bits (x, Field.size_in_bits) |]","counters":[]},{"line":"    | Challenge ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [| `Packed_bits (x, Challenge.length) |]","counters":[]},{"line":"    | Branch_data ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [| `Packed_bits","counters":[]},{"line":"             ( Branch_data.Checked.pack (module Impl) x","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"             , Branch_data.length_in_bits )","counters":[]},{"line":"        |]","counters":[]},{"line":"    | Bulletproof_challenge ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let { Bulletproof_challenge.prechallenge = { Sc.inner = pre } } = x in","counters":[]},{"line":"        [| `Packed_bits (pre, Challenge.length) |]","counters":[]},{"line":"  in","counters":[]},{"line":"  { pack }","counters":[]},{"line":"","counters":[]},{"line":"let pack (type f) ((module Impl) as impl : f impl) t =","counters":[]},{"line":"  let open Impl in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  pack (pack_basic impl) t","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"    ~zero:(`Packed_bits (Field.zero, 1))","counters":[]},{"line":"    ~one:(`Packed_bits (Field.one, 1))","counters":[]},{"line":"","counters":[]},{"line":"let typ_basic (type field other_field other_field_var)","counters":[]},{"line":"    (module Impl : Snarky_backendless.Snark_intf.Run with type field = field)","counters":[]},{"line":"    ~assert_16_bits (field : (other_field_var, other_field) Impl.Typ.t) =","counters":[]},{"line":"  let open Impl in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let module C = Common (Impl) in","counters":[]},{"line":"  let open C in","counters":[]},{"line":"  let typ :","counters":[]},{"line":"      type a b.","counters":[]},{"line":"         (a, b, ((other_field, other_field_var, 'e) Env.t as 'e)) Basic.t","counters":[]},{"line":"      -> (b, a) Impl.Typ.t =","counters":[]},{"line":"   fun basic ->","counters":[]},{"line":"    match basic with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Field ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        field","counters":[]},{"line":"    | Bool ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Boolean.typ","counters":[]},{"line":"    | Branch_data ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Branch_data.typ (module Impl) ~assert_16_bits","counters":[]},{"line":"    | Digest ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Digest.typ","counters":[]},{"line":"    | Challenge ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Challenge.typ","counters":[]},{"line":"    | Bulletproof_challenge ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Bulletproof_challenge.typ Challenge.typ","counters":[]},{"line":"  in","counters":[]},{"line":"  { typ }","counters":[]},{"line":"","counters":[]},{"line":"let typ ~assert_16_bits impl field t =","counters":[]},{"line":"  typ (typ_basic ~assert_16_bits impl field) t","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"","counters":[]},{"line":"let packed_typ_basic (type field other_field other_field_var)","counters":[]},{"line":"    (module Impl : Snarky_backendless.Snark_intf.Run with type field = field)","counters":[]},{"line":"    (field : (other_field_var, other_field, field) ETyp.t) =","counters":[]},{"line":"  let open Impl in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let module Digest = D.Make (Impl) in","counters":[]},{"line":"  let module Challenge = Limb_vector.Challenge.Make (Impl) in","counters":[]},{"line":"  let module Env = struct","counters":[]},{"line":"    type ('other_field, 'other_field_var, 'a) t =","counters":[]},{"line":"      < field1 : 'other_field","counters":[]},{"line":"      ; field2 : 'other_field_var","counters":[]},{"line":"      ; bool1 : bool","counters":[]},{"line":"      ; bool2 : Boolean.var","counters":[]},{"line":"      ; digest1 : Digest.Constant.t","counters":[]},{"line":"      ; digest2 : Field.t","counters":[]},{"line":"      ; challenge1 : Challenge.Constant.t","counters":[]},{"line":"      ; challenge2 : (* Challenge.t *) Field.t","counters":[]},{"line":"      ; bulletproof_challenge1 :","counters":[]},{"line":"          Challenge.Constant.t Sc.t Bulletproof_challenge.t","counters":[]},{"line":"      ; bulletproof_challenge2 : Field.t Sc.t Bulletproof_challenge.t","counters":[]},{"line":"      ; branch_data1 : Branch_data.t","counters":[]},{"line":"      ; branch_data2 : Field.t","counters":[]},{"line":"      ; .. >","counters":[]},{"line":"      as","counters":[]},{"line":"      'a","counters":[]},{"line":"  end in","counters":[]},{"line":"  let etyp :","counters":[]},{"line":"      type a b.","counters":[]},{"line":"         (a, b, ((other_field, other_field_var, 'e) Env.t as 'e)) Basic.t","counters":[]},{"line":"      -> (b, a, field) ETyp.t = function","counters":[]},{"line":"    | Field ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        field","counters":[]},{"line":"    | Bool ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        T (Boolean.typ, Fn.id, Fn.id)","counters":[]},{"line":"    | Digest ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        T (Digest.typ, Fn.id, Fn.id)","counters":[]},{"line":"    | Challenge ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        T (Challenge.typ, Fn.id, Fn.id)","counters":[]},{"line":"    | Branch_data ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        T (Branch_data.packed_typ (module Impl), Fn.id, Fn.id)","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"    | Bulletproof_challenge ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let typ =","counters":[]},{"line":"          let there { Bulletproof_challenge.prechallenge = { Sc.inner = pre } }","counters":[]},{"line":"              =","counters":[]},{"line":"            pre","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          in","counters":[]},{"line":"          let back pre =","counters":[]},{"line":"            { Bulletproof_challenge.prechallenge = { Sc.inner = pre } }","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          in","counters":[]},{"line":"          Typ.transport Challenge.typ ~there ~back","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"          |> Typ.transport_var ~there ~back","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"        in","counters":[]},{"line":"        T (typ, Fn.id, Fn.id)","counters":[]},{"line":"  in","counters":[]},{"line":"  { etyp }","counters":[]},{"line":"","counters":[]},{"line":"let packed_typ impl field t = etyp (packed_typ_basic impl field) t","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":51,"col_end":51,"count":0},{"col_start":65,"col_end":65,"count":2}]}]}