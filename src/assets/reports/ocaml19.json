{"filename":"src/lib/network_pool/indexed_pool.ml","lines":[{"line":"(* See the .mli for a description of the purpose of this module. *)","counters":[{"col_start":66,"col_end":66,"count":1}]},{"line":"open Core","counters":[]},{"line":"open Mina_base","counters":[]},{"line":"open Mina_transaction","counters":[]},{"line":"open Mina_numbers","counters":[]},{"line":"open Signature_lib","counters":[]},{"line":"","counters":[]},{"line":"(* Fee increase required to replace a transaction. *)","counters":[]},{"line":"let replace_fee : Currency.Fee.t = Currency.Fee.of_int 1","counters":[{"col_start":53,"col_end":53,"count":1}]},{"line":"","counters":[]},{"line":"(* Invariants, maintained whenever a t is exposed from this module:","counters":[]},{"line":"   * Iff a command is in all_by_fee it is also in all_by_sender.","counters":[]},{"line":"   * Iff a command is in all_by_fee it is also in all_by_hash.","counters":[]},{"line":"   * Iff a command is at the head of its sender's queue it is also in","counters":[]},{"line":"     applicable_by_fee.","counters":[]},{"line":"   * Sequences in all_by_sender are ordered by nonce and \"dense\".","counters":[]},{"line":"   * Only commands with an expiration <> Global_slot.max_value is added to transactions_with_expiration.","counters":[]},{"line":"   * There are no empty sets or sequences.","counters":[]},{"line":"   * Fee indices are correct.","counters":[]},{"line":"   * Total currency required is correct.","counters":[]},{"line":"   * size = the sum of sizes of the sets in all_by_fee = the sum of the lengths","counters":[]},{"line":"     of the queues in all_by_sender","counters":[]},{"line":"*)","counters":[]},{"line":"","counters":[]},{"line":"module Config = struct","counters":[]},{"line":"  type t =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    { constraint_constants : Genesis_constants.Constraint_constants.t","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"    ; consensus_constants : Consensus.Constants.t","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"    ; time_controller : Block_time.Controller.t","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"    ; expiry_ns : Time_ns.Span.t","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          (* Discard transactions after the expiry duration has elapsed,","counters":[]},{"line":"             and do not accept transactions that cannot become includable","counters":[]},{"line":"             before the expiry duration has elapsed.","counters":[]},{"line":"             Default value as in Bitcoin ('mempoolexpiry').","counters":[]},{"line":"             TODO: Make this configurable *)","counters":[]},{"line":"    }","counters":[]},{"line":"  [@@deriving sexp_of, equal, compare]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"type t =","counters":[{"col_start":0,"col_end":0,"count":0}]},{"line":"  { applicable_by_fee :","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Transaction_hash.User_command_with_valid_signature.Set.t","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Currency.Fee_rate.Map.t","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (** Transactions valid against the current ledger, indexed by fee per","counters":[]},{"line":"            weight unit. *)","counters":[]},{"line":"  ; all_by_sender :","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ( Transaction_hash.User_command_with_valid_signature.t F_sequence.t","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"      * Currency.Amount.t )","counters":[]},{"line":"      Account_id.Map.t","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"        (** All pending transactions along with the total currency required to","counters":[]},{"line":"            execute them -- plus any currency spent from this account by","counters":[]},{"line":"            transactions from other accounts -- indexed by sender account.","counters":[]},{"line":"            Ordered by nonce inside the accounts. *)","counters":[]},{"line":"  ; all_by_fee :","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Transaction_hash.User_command_with_valid_signature.Set.t","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Currency.Fee_rate.Map.t","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"        (** All transactions in the pool indexed by fee per weight unit. *)","counters":[]},{"line":"  ; all_by_hash :","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Transaction_hash.User_command_with_valid_signature.t","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Transaction_hash.Map.t","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"  ; transactions_with_expiration :","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Transaction_hash.User_command_with_valid_signature.Set.t Global_slot.Map.t","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":63,"col_end":63,"count":0},{"col_start":79,"col_end":79,"count":0}]},{"line":"        (*Only transactions that have an expiry*)","counters":[]},{"line":"  ; entry_times : Time_ns.t Transaction_hash.Map.t","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"        (** The entry time for each transaction *)","counters":[]},{"line":"  ; all_by_entry_time : Transaction_hash.t Time_ns.Map.t","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":43,"col_end":43,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"        (** All transactions in the pool indexed by their entry time *)","counters":[]},{"line":"  ; size : int","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":11,"col_end":11,"count":0},{"col_start":13,"col_end":13,"count":0}]},{"line":"  ; config : Config.t","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  }","counters":[]},{"line":"[@@deriving sexp_of, equal, compare]","counters":[]},{"line":"","counters":[]},{"line":"let config t = t.config","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"","counters":[]},{"line":"module Command_error = struct","counters":[]},{"line":"  (* IMPORTANT! Do not change the names of these errors as to adjust the","counters":[]},{"line":"   * to_yojson output without updating Rosetta's construction API to handle the","counters":[]},{"line":"   * changes *)","counters":[]},{"line":"  type t =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    | Invalid_nonce of","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        [ `Expected of Account.Nonce.t","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"        | `Between of Account.Nonce.t * Account.Nonce.t ]","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":54,"col_end":54,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"        * Account.Nonce.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"    | Insufficient_funds of","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        [ `Balance of Currency.Amount.t ] * Currency.Amount.t","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"    | (* NOTE: don't punish for this, attackers can induce nodes to banlist","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"          each other that way! *)","counters":[]},{"line":"        Insufficient_replace_fee of","counters":[]},{"line":"        [ `Replace_fee of Currency.Fee.t ] * Currency.Fee.t","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"    | Overflow","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Bad_token","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Expired of","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        [ `Valid_until of Mina_numbers.Global_slot.t","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"        | `Timestamp_predicate of string ]","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"        * [ `Global_slot_since_genesis of Mina_numbers.Global_slot.t ]","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":42,"col_end":42,"count":0},{"col_start":67,"col_end":67,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"    | Unwanted_fee_token of Token_id.t","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"  [@@deriving sexp, to_yojson]","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"  let grounds_for_diff_rejection : t -> bool = function","counters":[]},{"line":"    | Expired _","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    | Invalid_nonce _","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    | Insufficient_funds _","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    | Insufficient_replace_fee _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        false","counters":[]},{"line":"    | Overflow | Bad_token | Unwanted_fee_token _ ->","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"        true","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(* Compute the total currency required from the sender to execute a command.","counters":[]},{"line":"   Returns None in case of overflow.","counters":[]},{"line":"*)","counters":[]},{"line":"let currency_consumed_unchecked :","counters":[]},{"line":"       constraint_constants:Genesis_constants.Constraint_constants.t","counters":[]},{"line":"    -> User_command.t","counters":[]},{"line":"    -> Currency.Amount.t option =","counters":[]},{"line":" fun ~constraint_constants:_ cmd ->","counters":[]},{"line":"  let fee_amt = Currency.Amount.of_fee @@ User_command.fee cmd in","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"  let open Currency.Amount in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let amt =","counters":[]},{"line":"    match cmd with","counters":[]},{"line":"    | Signed_command c -> (","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        match c.payload.body with","counters":[]},{"line":"        | Payment { amount; _ } ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (* The fee-payer is also the sender account, include the amount. *)","counters":[]},{"line":"            amount","counters":[]},{"line":"        | Stake_delegation _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            zero )","counters":[]},{"line":"    | Zkapp_command _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (*TODO: document- txns succeeds with source amount insufficient in the case of zkapps*)","counters":[]},{"line":"        zero","counters":[]},{"line":"  in","counters":[]},{"line":"  fee_amt + amt","counters":[]},{"line":"","counters":[]},{"line":"let currency_consumed ~constraint_constants cmd =","counters":[]},{"line":"  currency_consumed_unchecked ~constraint_constants","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    (Transaction_hash.User_command_with_valid_signature.command cmd)","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"","counters":[]},{"line":"let currency_consumed' :","counters":[]},{"line":"       constraint_constants:Genesis_constants.Constraint_constants.t","counters":[]},{"line":"    -> User_command.t","counters":[]},{"line":"    -> (Currency.Amount.t, Command_error.t) Result.t =","counters":[]},{"line":" fun ~constraint_constants cmd ->","counters":[]},{"line":"  cmd","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  |> currency_consumed_unchecked ~constraint_constants","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"  |> Result.of_option ~error:Command_error.Overflow","counters":[]},{"line":"","counters":[]},{"line":"module For_tests = struct","counters":[]},{"line":"  (* Check the invariants of the pool structure as listed in the comment above.","counters":[]},{"line":"  *)","counters":[]},{"line":"  let assert_invariants : t -> unit =","counters":[]},{"line":"   fun { applicable_by_fee","counters":[]},{"line":"       ; all_by_sender","counters":[]},{"line":"       ; all_by_fee","counters":[]},{"line":"       ; all_by_hash","counters":[]},{"line":"       ; size","counters":[]},{"line":"       ; config = { constraint_constants; _ }","counters":[]},{"line":"       ; _","counters":[]},{"line":"       } ->","counters":[]},{"line":"    let assert_all_by_fee tx =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      if","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Set.mem","counters":[]},{"line":"          (Map.find_exn all_by_fee","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"             ( Transaction_hash.User_command_with_valid_signature.command tx","counters":[{"col_start":72,"col_end":72,"count":0}]},{"line":"             |> User_command.fee_per_wu ) )","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"          tx","counters":[]},{"line":"      then ()","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"      else","counters":[]},{"line":"        failwith","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        @@ sprintf","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"             !\"Not found in all_by_fee: %{sexp: \\","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"               Transaction_hash.User_command_with_valid_signature.t }\"","counters":[]},{"line":"             tx","counters":[]},{"line":"    in","counters":[]},{"line":"    let assert_all_by_hash tx =","counters":[]},{"line":"      [%test_eq: Transaction_hash.User_command_with_valid_signature.t] tx","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"        (Map.find_exn all_by_hash","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"           (Transaction_hash.User_command_with_valid_signature.hash tx) )","counters":[{"col_start":66,"col_end":66,"count":0}]},{"line":"    in","counters":[]},{"line":"    Map.iteri applicable_by_fee ~f:(fun ~key ~data ->","counters":[]},{"line":"        Set.iter data ~f:(fun tx ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            let unchecked =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Transaction_hash.User_command_with_valid_signature.command tx","counters":[]},{"line":"            in","counters":[]},{"line":"            [%test_eq: Currency.Fee_rate.t] key","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"              (User_command.fee_per_wu unchecked) ;","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"            let tx' =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Map.find_exn all_by_sender (User_command.fee_payer unchecked)","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"              |> Tuple2.get1 |> F_sequence.head_exn","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"            in","counters":[]},{"line":"            [%test_eq: Transaction_hash.User_command_with_valid_signature.t] tx","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"              tx' ;","counters":[]},{"line":"            assert_all_by_fee tx ;","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            assert_all_by_hash tx ) ) ;","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"    Map.iteri all_by_sender","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ~f:(fun ~key:fee_payer ~data:(tx_seq, currency_reserved) ->","counters":[]},{"line":"        assert (F_sequence.length tx_seq > 0) ;","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"        let check_consistent tx =","counters":[]},{"line":"          [%test_eq: Account_id.t]","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"            ( Transaction_hash.User_command_with_valid_signature.command tx","counters":[{"col_start":71,"col_end":71,"count":0}]},{"line":"            |> User_command.fee_payer )","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"            fee_payer ;","counters":[]},{"line":"          assert_all_by_fee tx ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          assert_all_by_hash tx","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        in","counters":[]},{"line":"        let applicable, inapplicables =","counters":[]},{"line":"          Option.value_exn (F_sequence.uncons tx_seq)","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"        in","counters":[]},{"line":"        let applicable_unchecked =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Transaction_hash.User_command_with_valid_signature.command applicable","counters":[]},{"line":"        in","counters":[]},{"line":"        check_consistent applicable ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        assert (","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"          Set.mem","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"            (Map.find_exn applicable_by_fee","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"               (User_command.fee_per_wu applicable_unchecked) )","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"            applicable ) ;","counters":[]},{"line":"        let _last_nonce, currency_reserved' =","counters":[]},{"line":"          F_sequence.foldl","counters":[]},{"line":"            (fun (curr_nonce, currency_acc) tx ->","counters":[]},{"line":"              let unchecked =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Transaction_hash.User_command_with_valid_signature.command tx","counters":[]},{"line":"              in","counters":[]},{"line":"              [%test_eq: Account_nonce.t]","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"                (User_command.applicable_at_nonce unchecked)","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"                curr_nonce ;","counters":[]},{"line":"              check_consistent tx ;","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              ( User_command.expected_target_nonce unchecked","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"              , Option.value_exn","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                  Currency.Amount.(","counters":[]},{"line":"                    Option.value_exn","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                      (currency_consumed ~constraint_constants tx)","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"                    + currency_acc) ) )","counters":[]},{"line":"            ( User_command.expected_target_nonce applicable_unchecked","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"            , Option.value_exn","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                (currency_consumed ~constraint_constants applicable) )","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"            inapplicables","counters":[]},{"line":"        in","counters":[]},{"line":"        [%test_eq: Currency.Amount.t] currency_reserved currency_reserved' ) ;","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"    let check_sender_applicable fee tx =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let unchecked =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Transaction_hash.User_command_with_valid_signature.command tx","counters":[]},{"line":"      in","counters":[]},{"line":"      [%test_eq: Currency.Fee.t] fee (User_command.fee unchecked) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"      let sender_txs, _currency_reserved =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Map.find_exn all_by_sender (User_command.fee_payer unchecked)","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"      in","counters":[]},{"line":"      let applicable, _inapplicables =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Option.value_exn (F_sequence.uncons sender_txs)","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"      in","counters":[]},{"line":"      assert (","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":13,"col_end":13,"count":0}]},{"line":"        Set.mem","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"          (Map.find_exn applicable_by_fee","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"             ( applicable","counters":[]},{"line":"             |> Transaction_hash.User_command_with_valid_signature.command","counters":[{"col_start":73,"col_end":73,"count":0}]},{"line":"             |> User_command.fee_per_wu ) )","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"          applicable ) ;","counters":[]},{"line":"      let tx' =","counters":[]},{"line":"        F_sequence.find sender_txs ~f:(fun cmd ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"            let applicable_at_nonce =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              cmd |> Transaction_hash.User_command_with_valid_signature.command","counters":[{"col_start":78,"col_end":78,"count":0}]},{"line":"              |> User_command.applicable_at_nonce","counters":[]},{"line":"            in","counters":[]},{"line":"            Account_nonce.equal applicable_at_nonce","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            @@ User_command.applicable_at_nonce unchecked )","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"        |> Option.value_exn","counters":[]},{"line":"      in","counters":[]},{"line":"      [%test_eq: Transaction_hash.User_command_with_valid_signature.t] tx tx'","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"    in","counters":[]},{"line":"    Map.iteri all_by_fee ~f:(fun ~key:fee_per_wu ~data:tx_set ->","counters":[]},{"line":"        Set.iter tx_set ~f:(fun tx ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            let command =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Transaction_hash.User_command_with_valid_signature.command tx","counters":[]},{"line":"            in","counters":[]},{"line":"            let wu = User_command.weight command in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let fee =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Currency.Fee_rate.scale_exn fee_per_wu wu","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"              |> Currency.Fee_rate.to_uint64_exn |> Currency.Fee.of_uint64","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"            in","counters":[]},{"line":"            check_sender_applicable fee tx ;","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            assert_all_by_hash tx ) ) ;","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"    Map.iter all_by_hash ~f:(fun tx ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        check_sender_applicable","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (User_command.fee","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"             (Transaction_hash.User_command_with_valid_signature.command tx) )","counters":[{"col_start":71,"col_end":71,"count":0}]},{"line":"          tx ;","counters":[]},{"line":"        assert_all_by_fee tx ) ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    [%test_eq: int] (Map.length all_by_hash) size","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let empty ~constraint_constants ~consensus_constants ~time_controller ~expiry_ns","counters":[]},{"line":"    : t =","counters":[]},{"line":"  { applicable_by_fee = Currency.Fee_rate.Map.empty","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  ; all_by_sender = Account_id.Map.empty","counters":[]},{"line":"  ; all_by_fee = Currency.Fee_rate.Map.empty","counters":[]},{"line":"  ; all_by_hash = Transaction_hash.Map.empty","counters":[]},{"line":"  ; entry_times = Transaction_hash.Map.empty","counters":[]},{"line":"  ; all_by_entry_time = Time_ns.Map.empty","counters":[]},{"line":"  ; transactions_with_expiration = Global_slot.Map.empty","counters":[]},{"line":"  ; size = 0","counters":[]},{"line":"  ; config =","counters":[]},{"line":"      { constraint_constants; consensus_constants; time_controller; expiry_ns }","counters":[]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"let size : t -> int = fun t -> t.size","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"","counters":[]},{"line":"(* The least fee per weight unit of all transactions in the transaction pool *)","counters":[]},{"line":"let min_fee : t -> Currency.Fee_rate.t option =","counters":[]},{"line":" fun { all_by_fee; _ } -> Option.map ~f:Tuple2.get1 @@ Map.min_elt all_by_fee","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"","counters":[]},{"line":"let member : t -> Transaction_hash.User_command.t -> bool =","counters":[]},{"line":" fun t cmd ->","counters":[]},{"line":"  Option.is_some","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    (Map.find t.all_by_hash (Transaction_hash.User_command.hash cmd))","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"","counters":[]},{"line":"let has_commands_for_fee_payer : t -> Account_id.t -> bool =","counters":[]},{"line":" fun t account_id -> Map.mem t.all_by_sender account_id","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"","counters":[]},{"line":"let all_from_account :","counters":[]},{"line":"       t","counters":[]},{"line":"    -> Account_id.t","counters":[]},{"line":"    -> Transaction_hash.User_command_with_valid_signature.t list =","counters":[]},{"line":" fun { all_by_sender; _ } account_id ->","counters":[]},{"line":"  Option.value_map ~default:[] (Map.find all_by_sender account_id)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"    ~f:(fun (user_commands, _) -> F_sequence.to_list user_commands)","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"","counters":[]},{"line":"let get_all { all_by_hash; _ } :","counters":[]},{"line":"    Transaction_hash.User_command_with_valid_signature.t list =","counters":[]},{"line":"  Map.data all_by_hash","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let find_by_hash :","counters":[]},{"line":"       t","counters":[]},{"line":"    -> Transaction_hash.t","counters":[]},{"line":"    -> Transaction_hash.User_command_with_valid_signature.t option =","counters":[]},{"line":" fun { all_by_hash; _ } hash -> Map.find all_by_hash hash","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"","counters":[]},{"line":"let global_slot_since_genesis conf =","counters":[]},{"line":"  let current_time = Block_time.now conf.Config.time_controller in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let current_slot =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Consensus.Data.Consensus_time.(","counters":[]},{"line":"      of_time_exn ~constants:conf.consensus_constants current_time","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"      |> to_global_slot)","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"  in","counters":[]},{"line":"  match conf.constraint_constants.fork with","counters":[]},{"line":"  | Some { previous_global_slot; _ } ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Mina_numbers.Global_slot.(add previous_global_slot current_slot)","counters":[]},{"line":"  | None ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      current_slot","counters":[]},{"line":"","counters":[]},{"line":"let check_expiry t (cmd : User_command.t) =","counters":[]},{"line":"  let global_slot_since_genesis = global_slot_since_genesis t in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let valid_until = User_command.valid_until cmd in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  if Global_slot.(valid_until < global_slot_since_genesis) then","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Error","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (Command_error.Expired","counters":[]},{"line":"         ( `Valid_until valid_until","counters":[]},{"line":"         , `Global_slot_since_genesis global_slot_since_genesis ) )","counters":[]},{"line":"  else Ok ()","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"","counters":[]},{"line":"(* a cmd is in the transactions_with_expiration map only if it has an expiry*)","counters":[]},{"line":"let update_expiration_map expiration_map cmd op =","counters":[]},{"line":"  let user_cmd =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Transaction_hash.User_command_with_valid_signature.command cmd","counters":[]},{"line":"  in","counters":[]},{"line":"  let expiry = User_command.valid_until user_cmd in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  if Global_slot.(expiry <> max_value) then","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    match op with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | `Add ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Map_set.insert","counters":[]},{"line":"          (module Transaction_hash.User_command_with_valid_signature)","counters":[]},{"line":"          expiration_map expiry cmd","counters":[]},{"line":"    | `Del ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Map_set.remove_exn expiration_map expiry cmd","counters":[]},{"line":"  else expiration_map","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"","counters":[]},{"line":"let remove_from_expiration_exn expiration_map cmd =","counters":[]},{"line":"  update_expiration_map expiration_map cmd `Del","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let add_to_expiration expiration_map cmd =","counters":[]},{"line":"  update_expiration_map expiration_map cmd `Add","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"(* Remove a command from the applicable_by_fee field. This may break an","counters":[]},{"line":"   invariant. *)","counters":[]},{"line":"let remove_applicable_exn :","counters":[]},{"line":"    t -> Transaction_hash.User_command_with_valid_signature.t -> t =","counters":[]},{"line":" fun t cmd ->","counters":[]},{"line":"  let fee_per_wu =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Transaction_hash.User_command_with_valid_signature.command cmd","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"    |> User_command.fee_per_wu","counters":[]},{"line":"  in","counters":[]},{"line":"  { t with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    applicable_by_fee = Map_set.remove_exn t.applicable_by_fee fee_per_wu cmd","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"(* Remove a command from entry_times and all_by_entry_time *)","counters":[]},{"line":"let remove_entry_times (cmd_hash : Transaction_hash.t) (t : t) : t =","counters":[]},{"line":"  let entry_time = Map.find t.entry_times cmd_hash in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  match entry_time with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | Some entry_time ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      { t with","counters":[]},{"line":"        entry_times = Map.remove t.entry_times cmd_hash","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"      ; all_by_entry_time = Map.remove t.all_by_entry_time entry_time","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"      }","counters":[]},{"line":"  | None ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      failwithf \"Entry time not found for command hash %s\"","counters":[]},{"line":"        (Transaction_hash.to_base58_check cmd_hash)","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"        ()","counters":[]},{"line":"","counters":[]},{"line":"(* Reset entry_times and all_by_entry_time for a command *)","counters":[]},{"line":"let reset_entry_times (cmd_hash : Transaction_hash.t) (t : t) : t =","counters":[]},{"line":"  let entry_time = Time_ns.now () in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  { t with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    entry_times = Map.update t.entry_times cmd_hash ~f:(fun _ -> entry_time)","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"  ; all_by_entry_time =","counters":[]},{"line":"      Map.update t.all_by_entry_time entry_time ~f:(fun _ -> cmd_hash)","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"(* Remove a command from the all_by_fee and all_by_hash fields, and decrement","counters":[]},{"line":"   size. This may break an invariant. *)","counters":[]},{"line":"let remove_all_by_fee_and_hash_and_expiration_exn :","counters":[]},{"line":"    t -> Transaction_hash.User_command_with_valid_signature.t -> t =","counters":[]},{"line":" fun t cmd ->","counters":[]},{"line":"  let fee_per_wu =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Transaction_hash.User_command_with_valid_signature.command cmd","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"    |> User_command.fee_per_wu","counters":[]},{"line":"  in","counters":[]},{"line":"  let cmd_hash = Transaction_hash.User_command_with_valid_signature.hash cmd in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  { t with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    all_by_fee = Map_set.remove_exn t.all_by_fee fee_per_wu cmd","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"  ; all_by_hash = Map.remove t.all_by_hash cmd_hash","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"  ; transactions_with_expiration =","counters":[]},{"line":"      remove_from_expiration_exn t.transactions_with_expiration cmd","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"  ; size = t.size - 1","counters":[]},{"line":"  }","counters":[]},{"line":"  |> remove_entry_times cmd_hash","counters":[]},{"line":"","counters":[]},{"line":"module Sender_local_state = struct","counters":[]},{"line":"  type t0 =","counters":[]},{"line":"    { sender : Account_id.t","counters":[]},{"line":"    ; data :","counters":[]},{"line":"        ( Transaction_hash.User_command_with_valid_signature.t F_sequence.t","counters":[]},{"line":"        * Currency.Amount.t )","counters":[]},{"line":"        option","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  type t = (t0[@sexp.opaque]) [@@deriving sexp]","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"  let sender { sender; _ } = sender","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"  let to_yojson _ = `String \"<per_sender>\"","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"","counters":[]},{"line":"  let is_remove t = Option.is_none t.data","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let set_sender_local_state (t : t) ({ sender; data } : Sender_local_state.t) : t","counters":[]},{"line":"    =","counters":[]},{"line":"  { t with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    all_by_sender = Map.change t.all_by_sender sender ~f:(fun _ -> data)","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"let get_sender_local_state (t : t) sender : Sender_local_state.t =","counters":[]},{"line":"  { sender; data = Map.find t.all_by_sender sender }","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"","counters":[]},{"line":"module Update = struct","counters":[]},{"line":"  module F_seq = struct","counters":[]},{"line":"    type 'a t = 'a F_sequence.t","counters":[]},{"line":"","counters":[]},{"line":"    include","counters":[]},{"line":"      Sexpable.Of_sexpable1","counters":[]},{"line":"        (List)","counters":[]},{"line":"        (struct","counters":[]},{"line":"          type 'a t = 'a F_sequence.t","counters":[]},{"line":"","counters":[]},{"line":"          let to_sexpable = F_sequence.to_list","counters":[]},{"line":"","counters":[]},{"line":"          let of_sexpable xs =","counters":[]},{"line":"            List.fold xs ~init:F_sequence.empty ~f:F_sequence.snoc","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"        end)","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  type single =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    | Add of","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        { command : Transaction_hash.User_command_with_valid_signature.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":16,"col_end":16,"count":0}]},{"line":"        ; fee_per_wu : Currency.Fee_rate.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"        ; add_to_applicable_by_fee : bool","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"        }","counters":[]},{"line":"    | Remove_all_by_fee_and_hash_and_expiration of","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        Transaction_hash.User_command_with_valid_signature.t F_seq.t","counters":[]},{"line":"    | Remove_from_applicable_by_fee of","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        { fee_per_wu : Currency.Fee_rate.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"        ; command : Transaction_hash.User_command_with_valid_signature.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":16,"col_end":16,"count":0}]},{"line":"        }","counters":[]},{"line":"  [@@deriving sexp]","counters":[]},{"line":"","counters":[]},{"line":"  type t = single Writer_result.Tree.t (* [@sexp.opaque] *) [@@deriving sexp]","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"  let to_yojson _ = `String \"<update>\"","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"","counters":[]},{"line":"  let apply acc (u : single) =","counters":[]},{"line":"    match u with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Add { command = cmd; fee_per_wu; add_to_applicable_by_fee } ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let acc =","counters":[]},{"line":"          if add_to_applicable_by_fee then","counters":[]},{"line":"            { acc with","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              applicable_by_fee =","counters":[]},{"line":"                Map_set.insert","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                  (module Transaction_hash.User_command_with_valid_signature)","counters":[]},{"line":"                  acc.applicable_by_fee fee_per_wu cmd","counters":[]},{"line":"            }","counters":[]},{"line":"          else acc","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"        in","counters":[]},{"line":"        let cmd_hash =","counters":[]},{"line":"          Transaction_hash.User_command_with_valid_signature.hash cmd","counters":[]},{"line":"        in","counters":[]},{"line":"        ( match Transaction_hash.User_command_with_valid_signature.data cmd with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | Zkapp_command p ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let p = Zkapp_command.Valid.forget p in","counters":[]},{"line":"            let updates, proof_updates =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let init =","counters":[]},{"line":"                match","counters":[]},{"line":"                  (Account_update.of_fee_payer p.fee_payer).authorization","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"                with","counters":[]},{"line":"                | Proof _ ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    (1, 1)","counters":[]},{"line":"                | _ ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    (1, 0)","counters":[]},{"line":"              in","counters":[]},{"line":"              Zkapp_command.Call_forest.fold p.account_updates ~init","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"                ~f:(fun (count, proof_updates_count) account_update ->","counters":[]},{"line":"                  ( count + 1","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  , if","counters":[]},{"line":"                      Control.(","counters":[]},{"line":"                        Tag.equal Proof","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                          (tag (Account_update.authorization account_update)))","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"                    then proof_updates_count + 1","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                    else proof_updates_count ) )","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"            in","counters":[]},{"line":"            Mina_metrics.Counter.inc_one","counters":[]},{"line":"              Mina_metrics.Transaction_pool.zkapp_transactions_added_to_pool ;","counters":[]},{"line":"            Mina_metrics.Counter.inc","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Mina_metrics.Transaction_pool.zkapp_transaction_size","counters":[]},{"line":"              (Zkapp_command.Stable.Latest.bin_size_t p |> Float.of_int) ;","counters":[{"col_start":52,"col_end":52,"count":0},{"col_start":70,"col_end":70,"count":0}]},{"line":"            Mina_metrics.Counter.inc Mina_metrics.Transaction_pool.zkapp_updates","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (Float.of_int updates) ;","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"            Mina_metrics.Counter.inc","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"              Mina_metrics.Transaction_pool.zkapp_proof_updates","counters":[]},{"line":"              (Float.of_int proof_updates)","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"        | Signed_command _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            () ) ;","counters":[]},{"line":"        { acc with","counters":[]},{"line":"          all_by_fee =","counters":[]},{"line":"            Map_set.insert","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"              (module Transaction_hash.User_command_with_valid_signature)","counters":[]},{"line":"              acc.all_by_fee fee_per_wu cmd","counters":[]},{"line":"        ; all_by_hash = Map.set acc.all_by_hash ~key:cmd_hash ~data:cmd","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"        ; transactions_with_expiration =","counters":[]},{"line":"            add_to_expiration acc.transactions_with_expiration cmd","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"        ; size = acc.size + 1","counters":[]},{"line":"        }","counters":[]},{"line":"        |> reset_entry_times cmd_hash","counters":[]},{"line":"    | Remove_all_by_fee_and_hash_and_expiration cmds ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        F_sequence.foldl","counters":[]},{"line":"          (fun acc cmd -> remove_all_by_fee_and_hash_and_expiration_exn acc cmd)","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"          acc cmds","counters":[]},{"line":"    | Remove_from_applicable_by_fee { fee_per_wu; command } ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { acc with","counters":[]},{"line":"          applicable_by_fee =","counters":[]},{"line":"            Map_set.remove_exn acc.applicable_by_fee fee_per_wu command","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"  let apply (us : t) t = Writer_result.Tree.fold ~init:t us ~f:apply","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"  let merge (t1 : t) (t2 : t) = Writer_result.Tree.append t1 t2","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"","counters":[]},{"line":"  let empty : t = Empty","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(* Returns a sequence of commands in the pool in descending fee order *)","counters":[]},{"line":"let transactions ~logger t =","counters":[]},{"line":"  let insert_applicable applicable_by_fee txn =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    let fee =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      User_command.fee_per_wu","counters":[]},{"line":"      @@ Transaction_hash.User_command_with_valid_signature.command txn","counters":[{"col_start":66,"col_end":66,"count":0}]},{"line":"    in","counters":[]},{"line":"    Map.update applicable_by_fee fee ~f:(function","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      | Some set ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Set.add set txn","counters":[]},{"line":"      | None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Transaction_hash.User_command_with_valid_signature.Set.singleton txn )","counters":[]},{"line":"  in","counters":[]},{"line":"  Sequence.unfold","counters":[]},{"line":"    ~init:(t.applicable_by_fee, Map.map ~f:fst t.all_by_sender)","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"    ~f:(fun (applicable_by_fee, all_by_sender) ->","counters":[]},{"line":"      if Map.is_empty applicable_by_fee then (","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"        assert (Map.is_empty all_by_sender) ;","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"        None )","counters":[]},{"line":"      else","counters":[]},{"line":"        let fee, set = Map.max_elt_exn applicable_by_fee in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        assert (Set.length set > 0) ;","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"        let txn = Set.min_elt_exn set in","counters":[]},{"line":"        let applicable_by_fee' =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let set' = Set.remove set txn in","counters":[]},{"line":"          if Set.is_empty set' then Map.remove applicable_by_fee fee","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"          else Map.set applicable_by_fee ~key:fee ~data:set'","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"        in","counters":[]},{"line":"        let applicable_by_fee'', all_by_sender' =","counters":[]},{"line":"          let sender =","counters":[]},{"line":"            User_command.fee_payer","counters":[]},{"line":"            @@ Transaction_hash.User_command_with_valid_signature.command txn","counters":[{"col_start":72,"col_end":72,"count":0}]},{"line":"          in","counters":[]},{"line":"          let sender_queue = Map.find_exn all_by_sender sender in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let head_txn, sender_queue' =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Option.value_exn (F_sequence.uncons sender_queue)","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"          in","counters":[]},{"line":"          if","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Transaction_hash.equal","counters":[]},{"line":"              (Transaction_hash.User_command_with_valid_signature.hash txn)","counters":[{"col_start":69,"col_end":69,"count":0}]},{"line":"              (Transaction_hash.User_command_with_valid_signature.hash head_txn)","counters":[{"col_start":69,"col_end":69,"count":0}]},{"line":"          then","counters":[]},{"line":"            match F_sequence.uncons sender_queue' with","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            | Some (next_txn, _) ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ( insert_applicable applicable_by_fee' next_txn","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"                , Map.set all_by_sender ~key:sender ~data:sender_queue' )","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"            | None ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (applicable_by_fee', Map.remove all_by_sender sender)","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"          else (","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"            (* the sender's queue is malformed *)","counters":[]},{"line":"            [%log error]","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"              \"Transaction pool \\\"applicable_by_fee\\\" index contained \\","counters":[]},{"line":"               malformed entry for $sender ($head_applicable_by_fee != \\","counters":[]},{"line":"               $head_sender_queue); skipping transactions from $sender during \\","counters":[]},{"line":"               iteration\"","counters":[]},{"line":"              ~metadata:","counters":[]},{"line":"                [ (\"sender\", Account_id.to_yojson sender)","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"                ; ( \"head_applicable_by_fee\"","counters":[]},{"line":"                  , Transaction_hash.User_command_with_valid_signature.to_yojson","counters":[{"col_start":79,"col_end":79,"count":0}]},{"line":"                      txn )","counters":[]},{"line":"                ; ( \"head_sender_queue\"","counters":[]},{"line":"                  , Transaction_hash.User_command_with_valid_signature.to_yojson","counters":[{"col_start":79,"col_end":79,"count":0}]},{"line":"                      head_txn )","counters":[]},{"line":"                ] ;","counters":[]},{"line":"            (applicable_by_fee', Map.remove all_by_sender sender) )","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"        in","counters":[]},{"line":"        Some (txn, (applicable_by_fee'', all_by_sender')) )","counters":[]},{"line":"","counters":[]},{"line":"let run :","counters":[]},{"line":"    type a e.","counters":[]},{"line":"       sender:Account_id.t","counters":[]},{"line":"    -> t","counters":[]},{"line":"    -> (Sender_local_state.t ref -> (a, Update.single, e) Writer_result.t)","counters":[]},{"line":"    -> (a * t, e) Result.t =","counters":[]},{"line":" fun ~sender t a ->","counters":[]},{"line":"  let r = ref (get_sender_local_state t sender) in","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"  let res = Writer_result.run (a r) in","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"  Result.map res ~f:(fun (a, updates) ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      let t = set_sender_local_state t !r in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      (a, Update.apply updates t) )","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"","counters":[]},{"line":"(* Remove a given command from the pool, as well as any commands that depend on","counters":[]},{"line":"   it. Called from revalidate and remove_lowest_fee, and when replacing","counters":[]},{"line":"   transactions. *)","counters":[]},{"line":"let remove_with_dependents_exn :","counters":[]},{"line":"       constraint_constants:_","counters":[]},{"line":"    -> Transaction_hash.User_command_with_valid_signature.t","counters":[]},{"line":"    -> Sender_local_state.t ref","counters":[]},{"line":"    -> ( Transaction_hash.User_command_with_valid_signature.t Sequence.t","counters":[]},{"line":"       , Update.single","counters":[]},{"line":"       , _ )","counters":[]},{"line":"       Writer_result.t =","counters":[]},{"line":" fun ~constraint_constants (* ({ constraint_constants; _ } as t) *) cmd state ->","counters":[]},{"line":"  let unchecked =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Transaction_hash.User_command_with_valid_signature.command cmd","counters":[]},{"line":"  in","counters":[]},{"line":"  let open Writer_result.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let sender_queue, reserved_currency = Option.value_exn !state.data in","counters":[]},{"line":"  assert (not @@ F_sequence.is_empty sender_queue) ;","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":9,"col_end":9,"count":0},{"col_start":12,"col_end":12,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"  let cmd_nonce =","counters":[]},{"line":"    Transaction_hash.User_command_with_valid_signature.command cmd","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"    |> User_command.applicable_at_nonce","counters":[]},{"line":"  in","counters":[]},{"line":"  let cmd_index =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    F_sequence.findi sender_queue ~f:(fun cmd' ->","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"        let nonce =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Transaction_hash.User_command_with_valid_signature.command cmd'","counters":[{"col_start":67,"col_end":67,"count":0}]},{"line":"          |> User_command.applicable_at_nonce","counters":[]},{"line":"        in","counters":[]},{"line":"        (* we just compare nonce equality since the command we are looking for already exists in the sequence *)","counters":[]},{"line":"        Account_nonce.equal nonce cmd_nonce )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    |> Option.value_exn","counters":[]},{"line":"  in","counters":[]},{"line":"  let keep_queue, drop_queue = F_sequence.split_at sender_queue cmd_index in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  assert (not (F_sequence.is_empty drop_queue)) ;","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":9,"col_end":9,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"  let currency_to_remove =","counters":[]},{"line":"    F_sequence.foldl","counters":[]},{"line":"      (fun acc cmd' ->","counters":[]},{"line":"        Option.value_exn","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (* safe because we check for overflow when we add commands. *)","counters":[]},{"line":"          (let open Option.Let_syntax in","counters":[]},{"line":"          let%bind consumed = currency_consumed ~constraint_constants cmd' in","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"          Currency.Amount.(consumed + acc)) )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"      Currency.Amount.zero drop_queue","counters":[]},{"line":"  in","counters":[]},{"line":"  let reserved_currency' =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    (* This is safe because the currency in a subset of the commands much be <=","counters":[]},{"line":"       total currency in all the commands. *)","counters":[]},{"line":"    Option.value_exn Currency.Amount.(reserved_currency - currency_to_remove)","counters":[]},{"line":"  in","counters":[]},{"line":"  let%map () =","counters":[]},{"line":"    Writer_result.write","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"      (Update.Remove_all_by_fee_and_hash_and_expiration drop_queue)","counters":[]},{"line":"  and () =","counters":[]},{"line":"    if cmd_index = 0 then","counters":[]},{"line":"      Writer_result.write","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"        (Update.Remove_from_applicable_by_fee","counters":[]},{"line":"           { fee_per_wu = User_command.fee_per_wu unchecked; command = cmd } )","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"    else Writer_result.return ()","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"  in","counters":[]},{"line":"  state :=","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    { !state with","counters":[]},{"line":"      data =","counters":[]},{"line":"        ( if not (F_sequence.is_empty keep_queue) then","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"          Some (keep_queue, reserved_currency')","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        else (","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"          assert (Currency.Amount.(equal reserved_currency' zero)) ;","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"          None ) )","counters":[]},{"line":"    } ;","counters":[]},{"line":"  F_sequence.to_seq drop_queue","counters":[]},{"line":"","counters":[]},{"line":"let run' t cmd x =","counters":[]},{"line":"  run t","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    ~sender:","counters":[]},{"line":"      (User_command.fee_payer","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"         (Transaction_hash.User_command_with_valid_signature.command cmd) )","counters":[{"col_start":67,"col_end":67,"count":0}]},{"line":"    x","counters":[]},{"line":"","counters":[]},{"line":"let remove_with_dependents_exn' t cmd =","counters":[]},{"line":"  match","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    run' t cmd","counters":[]},{"line":"      (remove_with_dependents_exn","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"         ~constraint_constants:t.config.constraint_constants cmd )","counters":[]},{"line":"  with","counters":[]},{"line":"  | Ok x ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      x","counters":[]},{"line":"  | Error _ ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      failwith \"remove_with_dependents_exn\"","counters":[]},{"line":"","counters":[]},{"line":"(** Drop commands from the end of the queue until the total currency consumed is","counters":[]},{"line":"    <= the current balance. *)","counters":[]},{"line":"let drop_until_sufficient_balance :","counters":[]},{"line":"       constraint_constants:Genesis_constants.Constraint_constants.t","counters":[]},{"line":"    -> Transaction_hash.User_command_with_valid_signature.t F_sequence.t","counters":[]},{"line":"       * Currency.Amount.t","counters":[]},{"line":"    -> Currency.Amount.t","counters":[]},{"line":"    -> Transaction_hash.User_command_with_valid_signature.t F_sequence.t","counters":[]},{"line":"       * Currency.Amount.t","counters":[]},{"line":"       * Transaction_hash.User_command_with_valid_signature.t Sequence.t =","counters":[]},{"line":" fun ~constraint_constants (queue, currency_reserved) current_balance ->","counters":[]},{"line":"  let rec go queue' currency_reserved' dropped_so_far =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    if Currency.Amount.(currency_reserved' <= current_balance) then","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (queue', currency_reserved', dropped_so_far)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    else","counters":[]},{"line":"      let daeh, liat =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Option.value_exn","counters":[]},{"line":"          ~message:","counters":[]},{"line":"            \"couldn't drop any more transactions when trying to preserve \\","counters":[]},{"line":"             sufficient balance\"","counters":[]},{"line":"          (F_sequence.unsnoc queue')","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"      in","counters":[]},{"line":"      let consumed =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Option.value_exn (currency_consumed ~constraint_constants liat)","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"      in","counters":[]},{"line":"      go daeh","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (Option.value_exn Currency.Amount.(currency_reserved' - consumed))","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"        (Sequence.append dropped_so_far @@ Sequence.singleton liat)","counters":[{"col_start":38,"col_end":38,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"  in","counters":[]},{"line":"  go queue currency_reserved Sequence.empty","counters":[]},{"line":"","counters":[]},{"line":"(* Iterate over commands in the pool, removing them if they require too much","counters":[]},{"line":"   currency or have too low of a nonce. An argument is provided to instruct","counters":[]},{"line":"   which commands require revalidation.","counters":[]},{"line":"*)","counters":[]},{"line":"let revalidate :","counters":[]},{"line":"       t","counters":[]},{"line":"    -> logger:Logger.t","counters":[]},{"line":"    -> [ `Entire_pool | `Subset of Account_id.Set.t ]","counters":[]},{"line":"    -> (Account_id.t -> Account_nonce.t * Currency.Amount.t)","counters":[]},{"line":"    -> t * Transaction_hash.User_command_with_valid_signature.t Sequence.t =","counters":[]},{"line":" fun ({ config = { constraint_constants; _ }; _ } as t) ~logger scope f ->","counters":[]},{"line":"  let requires_revalidation =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    match scope with","counters":[]},{"line":"    | `Entire_pool ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Fn.const true","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"    | `Subset subset ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Set.mem subset","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"  in","counters":[]},{"line":"  Map.fold t.all_by_sender ~init:(t, Sequence.empty)","counters":[]},{"line":"    ~f:(fun","counters":[]},{"line":"         ~key:sender","counters":[]},{"line":"         ~data:(queue, currency_reserved)","counters":[]},{"line":"         ((t', dropped_acc) as acc)","counters":[]},{"line":"       ->","counters":[]},{"line":"      if not (requires_revalidation sender) then acc","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"      else","counters":[]},{"line":"        let current_nonce, current_balance = f sender in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        [%log debug]","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"          \"Revalidating account $account in transaction pool ($account_nonce, \\","counters":[]},{"line":"           $account_balance)\"","counters":[]},{"line":"          ~metadata:","counters":[]},{"line":"            [ ( \"account\"","counters":[]},{"line":"              , `String (Sexp.to_string @@ Account_id.sexp_of_t sender) )","counters":[{"col_start":38,"col_end":38,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"            ; (\"account_nonce\", `Int (Account_nonce.to_int current_nonce))","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"            ; ( \"account_balance\"","counters":[]},{"line":"              , `String (Currency.Amount.to_formatted_string current_balance) )","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"            ] ;","counters":[]},{"line":"        let first_cmd = F_sequence.head_exn queue in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let first_nonce =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          first_cmd","counters":[]},{"line":"          |> Transaction_hash.User_command_with_valid_signature.command","counters":[{"col_start":70,"col_end":70,"count":0}]},{"line":"          |> User_command.applicable_at_nonce","counters":[]},{"line":"        in","counters":[]},{"line":"        if Account_nonce.(current_nonce < first_nonce) then (","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"          [%log debug]","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"            \"Current account nonce precedes first nonce in queue; dropping \\","counters":[]},{"line":"             queue\" ;","counters":[]},{"line":"          let dropped, t'' = remove_with_dependents_exn' t first_cmd in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          (t'', Sequence.append dropped_acc dropped) )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"        else","counters":[]},{"line":"          (* current_nonce >= first_nonce *)","counters":[]},{"line":"          let first_applicable_nonce_index =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            F_sequence.findi queue ~f:(fun cmd' ->","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                let nonce =","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Transaction_hash.User_command_with_valid_signature.command","counters":[{"col_start":75,"col_end":75,"count":0}]},{"line":"                    cmd'","counters":[]},{"line":"                  |> User_command.applicable_at_nonce","counters":[]},{"line":"                in","counters":[]},{"line":"                Account_nonce.equal nonce current_nonce )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"            |> Option.value ~default:(F_sequence.length queue)","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"          in","counters":[]},{"line":"          [%log debug]","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"            \"Current account nonce succeeds first nonce in queue; splitting \\","counters":[]},{"line":"             queue at $index\"","counters":[]},{"line":"            ~metadata:[ (\"index\", `Int first_applicable_nonce_index) ] ;","counters":[]},{"line":"          let drop_queue, keep_queue =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            F_sequence.split_at queue first_applicable_nonce_index","counters":[]},{"line":"          in","counters":[]},{"line":"          let currency_reserved' =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            F_sequence.foldl","counters":[]},{"line":"              (fun c cmd ->","counters":[]},{"line":"                Option.value_exn","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Currency.Amount.(","counters":[]},{"line":"                    c","counters":[]},{"line":"                    - Option.value_exn","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                        (currency_consumed ~constraint_constants cmd)) )","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"              currency_reserved drop_queue","counters":[]},{"line":"          in","counters":[]},{"line":"          let keep_queue', currency_reserved'', dropped_for_balance =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            drop_until_sufficient_balance ~constraint_constants","counters":[]},{"line":"              (keep_queue, currency_reserved')","counters":[]},{"line":"              current_balance","counters":[]},{"line":"          in","counters":[]},{"line":"          let to_drop =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Sequence.append (F_sequence.to_seq drop_queue) dropped_for_balance","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"          in","counters":[]},{"line":"          match Sequence.next to_drop with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              acc","counters":[]},{"line":"          | Some (head, tail) ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let t'' =","counters":[]},{"line":"                Sequence.fold tail","counters":[]},{"line":"                  ~init:","counters":[]},{"line":"                    (remove_all_by_fee_and_hash_and_expiration_exn","counters":[{"col_start":65,"col_end":65,"count":0}]},{"line":"                       (remove_applicable_exn t' head)","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"                       head )","counters":[]},{"line":"                  ~f:remove_all_by_fee_and_hash_and_expiration_exn","counters":[]},{"line":"              in","counters":[]},{"line":"              let t''' =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                match F_sequence.uncons keep_queue' with","counters":[]},{"line":"                | None ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    { t'' with","counters":[]},{"line":"                      all_by_sender = Map.remove t''.all_by_sender sender","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"                    }","counters":[]},{"line":"                | Some (first_kept, _) ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    let first_kept_unchecked =","counters":[]},{"line":"                      Transaction_hash.User_command_with_valid_signature.command","counters":[]},{"line":"                        first_kept","counters":[]},{"line":"                    in","counters":[]},{"line":"                    { t'' with","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      all_by_sender =","counters":[]},{"line":"                        Map.set t''.all_by_sender ~key:sender","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                          ~data:(keep_queue', currency_reserved'')","counters":[]},{"line":"                    ; applicable_by_fee =","counters":[]},{"line":"                        Map_set.insert","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                          ( module Transaction_hash","counters":[]},{"line":"                                   .User_command_with_valid_signature )","counters":[]},{"line":"                          t''.applicable_by_fee","counters":[]},{"line":"                          (User_command.fee_per_wu first_kept_unchecked)","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"                          first_kept","counters":[]},{"line":"                    }","counters":[]},{"line":"              in","counters":[]},{"line":"              (t''', Sequence.append dropped_acc to_drop) )","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"let expired_by_predicate (t : t) :","counters":[]},{"line":"    Transaction_hash.User_command_with_valid_signature.t Sequence.t =","counters":[]},{"line":"  let time_now = Time_ns.now () in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let expiry_time = Time_ns.(sub time_now t.config.expiry_ns) in","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"  Map.to_sequence t.all_by_hash","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"  |> Sequence.filter_map ~f:(fun (cmd_hash, cmd) ->","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"         Transaction_hash.User_command_with_valid_signature.data cmd","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"         |> function","counters":[]},{"line":"         | User_command.Zkapp_command (ps : Zkapp_command.Valid.t) ->","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"             Some (cmd_hash, ps.zkapp_command)","counters":[]},{"line":"         | User_command.Signed_command _ ->","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"             None )","counters":[]},{"line":"  |> Sequence.filter ~f:(fun (_, ps) ->","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"         ps.account_updates","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"         |> Zkapp_command.Call_forest.exists ~f:(fun account_update ->","counters":[]},{"line":"                let predicate =","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Account_update.protocol_state_precondition account_update","counters":[]},{"line":"                in","counters":[]},{"line":"                match predicate.timestamp with","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                | Check { upper; _ } ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    Block_time.(upper < of_time_ns expiry_time)","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"                | _ ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    false ) )","counters":[]},{"line":"  |> Sequence.map ~f:fst","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"  |> Sequence.map ~f:(Map.find_exn t.all_by_hash)","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"","counters":[]},{"line":"let expired_by_age (t : t) :","counters":[]},{"line":"    Transaction_hash.User_command_with_valid_signature.t Sequence.t =","counters":[]},{"line":"  let time_now = Time_ns.now () in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let expiry_time = Time_ns.(sub time_now t.config.expiry_ns) in","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"  let expired, _, _ = Map.split t.all_by_entry_time expiry_time in","counters":[]},{"line":"  Map.to_sequence expired","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":16,"col_end":16,"count":0}]},{"line":"  |> Sequence.map ~f:(fun (_, cmd_hash) -> Map.find_exn t.all_by_hash cmd_hash)","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"","counters":[]},{"line":"let expired_by_global_slot (t : t) :","counters":[]},{"line":"    Transaction_hash.User_command_with_valid_signature.t Sequence.t =","counters":[]},{"line":"  let global_slot_since_genesis = global_slot_since_genesis t.config in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let expired, _, _ =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Map.split t.transactions_with_expiration global_slot_since_genesis","counters":[]},{"line":"  in","counters":[]},{"line":"  Map.to_sequence expired |> Sequence.map ~f:snd","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"  |> Sequence.bind ~f:Set.to_sequence","counters":[]},{"line":"","counters":[]},{"line":"let expired (t : t) :","counters":[]},{"line":"    Transaction_hash.User_command_with_valid_signature.t Sequence.t =","counters":[]},{"line":"  [ expired_by_predicate t; expired_by_age t; expired_by_global_slot t ]","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"  |> Sequence.of_list |> Sequence.concat","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"","counters":[]},{"line":"let remove_expired t :","counters":[]},{"line":"    Transaction_hash.User_command_with_valid_signature.t Sequence.t * t =","counters":[]},{"line":"  Sequence.fold (expired t) ~init:(Sequence.empty, t) ~f:(fun acc cmd ->","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"      let dropped_acc, t = acc in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      (*[cmd] would not be in [t] if it depended on an expired transaction already handled*)","counters":[]},{"line":"      if member t (Transaction_hash.User_command.of_checked cmd) then","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"        let removed, t' = remove_with_dependents_exn' t cmd in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        (Sequence.append dropped_acc removed, t')","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"      else acc )","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"","counters":[]},{"line":"let remove_lowest_fee :","counters":[]},{"line":"    t -> Transaction_hash.User_command_with_valid_signature.t Sequence.t * t =","counters":[]},{"line":" fun t ->","counters":[]},{"line":"  match Map.min_elt t.all_by_fee with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | None ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (Sequence.empty, t)","counters":[]},{"line":"  | Some (_min_fee, min_fee_set) ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      remove_with_dependents_exn' t @@ Set.min_elt_exn min_fee_set","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"","counters":[]},{"line":"let get_highest_fee :","counters":[]},{"line":"    t -> Transaction_hash.User_command_with_valid_signature.t option =","counters":[]},{"line":" fun t ->","counters":[]},{"line":"  Option.map","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    ~f:","counters":[]},{"line":"      (Fn.compose","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"         Transaction_hash.User_command_with_valid_signature.Set.min_elt_exn","counters":[]},{"line":"         Tuple2.get2 )","counters":[]},{"line":"  @@ Currency.Fee_rate.Map.max_elt t.applicable_by_fee","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"","counters":[]},{"line":"(* Add a command that came in from gossip, or return an error. We need to check","counters":[]},{"line":"   a whole bunch of conditions here and return the appropriate errors.","counters":[]},{"line":"   Conditions:","counters":[]},{"line":"   1. Command nonce must be >= account nonce.","counters":[]},{"line":"   1a. If the sender's queue is empty, command nonce must equal account nonce.","counters":[]},{"line":"   1b. If the sender's queue is non-empty, command nonce must be <= the nonce of","counters":[]},{"line":"       the last queued command + 1","counters":[]},{"line":"   2. The sum of the currency consumed by all queued commands for the sender","counters":[]},{"line":"      must be <= the sender's balance.","counters":[]},{"line":"   3. If a command is replaced, the new command must have a fee greater than the","counters":[]},{"line":"      replaced command by at least replace fee * (number of commands after the","counters":[]},{"line":"      the replaced command + 1)","counters":[]},{"line":"   4. No integer overflows are allowed.","counters":[]},{"line":"   5. protocol state predicate must be satisfiable before txs would expire","counters":[]},{"line":"      from the pool based on age","counters":[]},{"line":"   5a. timestamp predicate upper bound must be above current time.","counters":[]},{"line":"   5b. timestamp predicate lower bound must be below current time plus expiration time,","counters":[]},{"line":"       or the transaction will not become valid while in the pool","counters":[]},{"line":"   These conditions are referenced in the comments below.","counters":[]},{"line":"*)","counters":[]},{"line":"","counters":[]},{"line":"module Add_from_gossip_exn (M : Writer_result.S) = struct","counters":[]},{"line":"  let check_timestamp_predicate (expiry_ns : Time_ns.Span.t)","counters":[]},{"line":"      (user_command : User_command.t) : bool =","counters":[]},{"line":"    let expiry = Block_time.Span.of_time_ns_span expiry_ns in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let current_time = Block_time.of_time_ns @@ Time_ns.now () in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"    let expiry_time = Block_time.sub current_time expiry in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    match user_command with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | User_command.Signed_command _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        true","counters":[]},{"line":"    | User_command.Zkapp_command ps ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ps.account_updates","counters":[]},{"line":"        |> Zkapp_command.Call_forest.exists ~f:(fun account_update ->","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"               let predicate =","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                 Account_update.protocol_state_precondition account_update","counters":[]},{"line":"               in","counters":[]},{"line":"               match predicate.timestamp with","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"               | Check { lower; upper } ->","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                   (*Timestamp bounds are compared against slot start time of","counters":[]},{"line":"                     the most recent block and that could be any number of slots","counters":[]},{"line":"                     old. So give the transaction more time to be included*)","counters":[]},{"line":"                   Block_time.(upper <= expiry_time)","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                   || Block_time.(lower >= add current_time expiry)","counters":[{"col_start":45,"col_end":45,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"               | _ ->","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                   false )","counters":[]},{"line":"        |> not","counters":[]},{"line":"","counters":[]},{"line":"  let rec add_from_gossip_exn :","counters":[]},{"line":"         config:Config.t","counters":[]},{"line":"      -> Transaction_hash.User_command_with_valid_signature.t","counters":[]},{"line":"      -> Account_nonce.t","counters":[]},{"line":"      -> Currency.Amount.t","counters":[]},{"line":"      -> Sender_local_state.t ref","counters":[]},{"line":"      -> ( Transaction_hash.User_command_with_valid_signature.t","counters":[]},{"line":"           * Transaction_hash.User_command_with_valid_signature.t Sequence.t","counters":[]},{"line":"         , Update.single","counters":[]},{"line":"         , Command_error.t )","counters":[]},{"line":"         M.t =","counters":[]},{"line":"   fun ~config:({ constraint_constants; expiry_ns; _ } as config) cmd","counters":[]},{"line":"       current_nonce balance by_sender ->","counters":[]},{"line":"    let open Command_error in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let unchecked_cmd = Transaction_hash.User_command.of_checked cmd in","counters":[]},{"line":"    let open M.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let unchecked = Transaction_hash.User_command.data unchecked_cmd in","counters":[]},{"line":"    let fee = User_command.fee unchecked in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let fee_per_wu = User_command.fee_per_wu unchecked in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let cmd_applicable_at_nonce = User_command.applicable_at_nonce unchecked in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    (* Result errors indicate problems with the command, while assert failures","counters":[]},{"line":"       indicate bugs in Mina. *)","counters":[]},{"line":"    let%bind consumed =","counters":[]},{"line":"      M.of_result","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"        Result.Let_syntax.(","counters":[]},{"line":"          (* C5 *)","counters":[]},{"line":"          let%bind () =","counters":[]},{"line":"            if check_timestamp_predicate expiry_ns unchecked then Ok ()","counters":[{"col_start":66,"col_end":66,"count":0}]},{"line":"            else","counters":[]},{"line":"              Error","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (Expired","counters":[]},{"line":"                   ( `Timestamp_predicate (Time_ns.Span.to_string_hum expiry_ns)","counters":[{"col_start":68,"col_end":68,"count":0}]},{"line":"                   , `Global_slot_since_genesis","counters":[]},{"line":"                       (global_slot_since_genesis config) ) )","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%bind () = check_expiry config unchecked in","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"          let%bind consumed =","counters":[]},{"line":"            currency_consumed' ~constraint_constants unchecked","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%map () =","counters":[]},{"line":"            (* TODO: Proper exchange rate mechanism. *)","counters":[]},{"line":"            let fee_token = User_command.fee_token unchecked in","counters":[]},{"line":"            if Token_id.(equal default) fee_token then return ()","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":55,"col_end":55,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"            else Error (Unwanted_fee_token fee_token)","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"          in","counters":[]},{"line":"          consumed)","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    in","counters":[]},{"line":"    (* C4 *)","counters":[]},{"line":"    match !by_sender.data with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let%bind () =","counters":[]},{"line":"          M.of_result","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"            Result.Let_syntax.(","counters":[]},{"line":"              (* nothing queued for this sender *)","counters":[]},{"line":"              let%bind () =","counters":[]},{"line":"                Result.ok_if_true","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                  (Account_nonce.equal current_nonce cmd_applicable_at_nonce)","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                  ~error:","counters":[]},{"line":"                    (Invalid_nonce","counters":[]},{"line":"                       (`Expected current_nonce, cmd_applicable_at_nonce) )","counters":[]},{"line":"                (* C1/1a *)","counters":[]},{"line":"              in","counters":[]},{"line":"              let%map () =","counters":[]},{"line":"                Result.ok_if_true","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                  Currency.Amount.(consumed <= balance)","counters":[]},{"line":"                  ~error:(Insufficient_funds (`Balance balance, consumed))","counters":[]},{"line":"                (* C2 *)","counters":[]},{"line":"              in","counters":[]},{"line":"              ())","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"        in","counters":[]},{"line":"        let%map () =","counters":[]},{"line":"          M.write","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"            (Update.Add","counters":[]},{"line":"               { command = cmd; fee_per_wu; add_to_applicable_by_fee = true } )","counters":[]},{"line":"        in","counters":[]},{"line":"        by_sender :=","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          { !by_sender with data = Some (F_sequence.singleton cmd, consumed) } ;","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"        (cmd, Sequence.empty)","counters":[]},{"line":"    | Some (queued_cmds, reserved_currency) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        assert (not @@ F_sequence.is_empty queued_cmds) ;","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"        (* C1/C1b *)","counters":[]},{"line":"        let queue_applicable_at_nonce =","counters":[]},{"line":"          F_sequence.head_exn queued_cmds","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"          |> Transaction_hash.User_command_with_valid_signature.command","counters":[{"col_start":70,"col_end":70,"count":0}]},{"line":"          |> User_command.applicable_at_nonce","counters":[]},{"line":"        in","counters":[]},{"line":"        let queue_target_nonce =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          F_sequence.last_exn queued_cmds","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"          |> Transaction_hash.User_command_with_valid_signature.command","counters":[{"col_start":70,"col_end":70,"count":0}]},{"line":"          |> User_command.expected_target_nonce","counters":[]},{"line":"        in","counters":[]},{"line":"        if Account_nonce.equal queue_target_nonce cmd_applicable_at_nonce then (","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (* this command goes on the end *)","counters":[]},{"line":"          let%bind reserved_currency' =","counters":[]},{"line":"            M.of_result","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"              ( Currency.Amount.(consumed + reserved_currency)","counters":[]},{"line":"              |> Result.of_option ~error:Overflow )","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"            (* C4 *)","counters":[]},{"line":"          in","counters":[]},{"line":"          let%bind () =","counters":[]},{"line":"            M.of_result","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"              (Result.ok_if_true","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                 Currency.Amount.(reserved_currency' <= balance)","counters":[]},{"line":"                 ~error:","counters":[]},{"line":"                   (Insufficient_funds (`Balance balance, reserved_currency')) )","counters":[]},{"line":"            (* C2 *)","counters":[]},{"line":"          in","counters":[]},{"line":"          let new_state =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (F_sequence.snoc queued_cmds cmd, reserved_currency')","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%map () =","counters":[]},{"line":"            M.write","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"              (Update.Add","counters":[]},{"line":"                 { command = cmd; fee_per_wu; add_to_applicable_by_fee = false }","counters":[]},{"line":"              )","counters":[]},{"line":"          in","counters":[]},{"line":"          by_sender := { !by_sender with data = Some new_state } ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          (cmd, Sequence.empty) )","counters":[]},{"line":"        else if Account_nonce.equal queue_applicable_at_nonce current_nonce then (","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"          (* we're replacing a command *)","counters":[]},{"line":"          let%bind () =","counters":[]},{"line":"            Result.ok_if_true","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"              (Account_nonce.between ~low:queue_applicable_at_nonce","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                 ~high:queue_target_nonce cmd_applicable_at_nonce )","counters":[]},{"line":"              ~error:","counters":[]},{"line":"                (Invalid_nonce","counters":[]},{"line":"                   ( `Between (queue_applicable_at_nonce, queue_target_nonce)","counters":[]},{"line":"                   , cmd_applicable_at_nonce ) )","counters":[]},{"line":"            |> M.of_result","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"            (* C1/C1b *)","counters":[]},{"line":"          in","counters":[]},{"line":"          let replacement_index =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            F_sequence.findi queued_cmds ~f:(fun cmd' ->","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                let cmd_applicable_at_nonce' =","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Transaction_hash.User_command_with_valid_signature.command","counters":[{"col_start":75,"col_end":75,"count":0}]},{"line":"                    cmd'","counters":[]},{"line":"                  |> User_command.applicable_at_nonce","counters":[]},{"line":"                in","counters":[]},{"line":"                Account_nonce.compare cmd_applicable_at_nonce","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"                  cmd_applicable_at_nonce'","counters":[]},{"line":"                <= 0 )","counters":[]},{"line":"            |> Option.value_exn","counters":[]},{"line":"          in","counters":[]},{"line":"          let _keep_queue, drop_queue =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            F_sequence.split_at queued_cmds replacement_index","counters":[]},{"line":"          in","counters":[]},{"line":"          let to_drop =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            F_sequence.head_exn drop_queue","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"            |> Transaction_hash.User_command_with_valid_signature.command","counters":[]},{"line":"          in","counters":[]},{"line":"          assert (","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"            Account_nonce.compare cmd_applicable_at_nonce","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"              (User_command.applicable_at_nonce to_drop)","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"            <= 0 ) ;","counters":[]},{"line":"          (* We check the fee increase twice because we need to be sure the","counters":[]},{"line":"             subtraction is safe. *)","counters":[]},{"line":"          let%bind () =","counters":[]},{"line":"            let replace_fee = User_command.fee to_drop in","counters":[]},{"line":"            Result.ok_if_true","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"              Currency.Fee.(fee >= replace_fee)","counters":[]},{"line":"              ~error:(Insufficient_replace_fee (`Replace_fee replace_fee, fee))","counters":[]},{"line":"            |> M.of_result","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"            (* C3 *)","counters":[]},{"line":"          in","counters":[]},{"line":"          let%bind dropped =","counters":[]},{"line":"            remove_with_dependents_exn ~constraint_constants","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"              (F_sequence.head_exn drop_queue)","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"              by_sender","counters":[]},{"line":"            |> M.lift","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"          in","counters":[]},{"line":"          (* check remove_exn dropped the right things *)","counters":[]},{"line":"          [%test_eq:","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Transaction_hash.User_command_with_valid_signature.t Sequence.t]","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"            dropped","counters":[]},{"line":"            (F_sequence.to_seq drop_queue) ;","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"          (* Add the new transaction *)","counters":[]},{"line":"          let%bind cmd, _ =","counters":[]},{"line":"            let%map v, dropped' =","counters":[]},{"line":"              add_from_gossip_exn ~config cmd current_nonce balance by_sender","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"            in","counters":[]},{"line":"            (* We've already removed them, so this should always be empty. *)","counters":[]},{"line":"            assert (Sequence.is_empty dropped') ;","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"            (v, dropped)","counters":[]},{"line":"          in","counters":[]},{"line":"          let drop_head, drop_tail = Option.value_exn (Sequence.next dropped) in","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"          let increment =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Option.value_exn Currency.Fee.(fee - User_command.fee to_drop)","counters":[{"col_start":64,"col_end":64,"count":0}]},{"line":"          in","counters":[]},{"line":"          (* Re-add all of the transactions we dropped until there are none left,","counters":[]},{"line":"             or until the fees from dropped transactions exceed the fee increase","counters":[]},{"line":"             over the first transaction.","counters":[]},{"line":"          *)","counters":[]},{"line":"          let%bind increment, dropped' =","counters":[]},{"line":"            let rec go increment dropped dropped' current_nonce : _ M.t =","counters":[]},{"line":"              match (Sequence.next dropped, dropped') with","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"              | None, Some dropped' ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  return (increment, dropped')","counters":[]},{"line":"              | None, None ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  return (increment, Sequence.empty)","counters":[]},{"line":"              | Some (cmd, dropped), Some _ -> (","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  let cmd_unchecked =","counters":[]},{"line":"                    Transaction_hash.User_command_with_valid_signature.command","counters":[]},{"line":"                      cmd","counters":[]},{"line":"                  in","counters":[]},{"line":"                  let replace_fee = User_command.fee cmd_unchecked in","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  match Currency.Fee.(increment - replace_fee) with","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  | Some increment ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      go increment dropped dropped' current_nonce","counters":[]},{"line":"                  | None ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      Error","counters":[]},{"line":"                        (Insufficient_replace_fee","counters":[]},{"line":"                           (`Replace_fee replace_fee, increment) )","counters":[]},{"line":"                      |> M.of_result )","counters":[]},{"line":"              | Some (cmd, dropped'), None ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  let current_nonce = Account_nonce.succ current_nonce in","counters":[]},{"line":"                  let by_sender_pre = !by_sender in","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  M.catch","counters":[]},{"line":"                    (add_from_gossip_exn ~config cmd current_nonce balance","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"                       by_sender ) ~f:(function","counters":[]},{"line":"                    | Ok ((_v, dropped_), ups) ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        assert (Sequence.is_empty dropped_) ;","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"                        let%bind () = M.write_all ups in","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"                        go increment dropped' None current_nonce","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                    | Error _err ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        by_sender := by_sender_pre ;","counters":[]},{"line":"                        (* Re-evaluate with the same [dropped] to calculate the new","counters":[]},{"line":"                           fee increment.","counters":[]},{"line":"                        *)","counters":[]},{"line":"                        go increment dropped (Some dropped') current_nonce )","counters":[]},{"line":"            in","counters":[]},{"line":"            go increment drop_tail None current_nonce","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%map () =","counters":[]},{"line":"            Result.ok_if_true","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"              Currency.Fee.(increment >= replace_fee)","counters":[]},{"line":"              ~error:","counters":[]},{"line":"                (Insufficient_replace_fee (`Replace_fee replace_fee, increment))","counters":[]},{"line":"            |> M.of_result","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"            (* C3 *)","counters":[]},{"line":"          in","counters":[]},{"line":"          (cmd, Sequence.(append (return drop_head) dropped')) )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"        else","counters":[]},{"line":"          (*Invalid nonce or duplicate transaction got in- either way error*)","counters":[]},{"line":"          M.of_result","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (Error","counters":[]},{"line":"               (Invalid_nonce","counters":[]},{"line":"                  (`Expected queue_target_nonce, cmd_applicable_at_nonce) ) )","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Add_from_gossip_exn0 = Add_from_gossip_exn (Writer_result)","counters":[]},{"line":"","counters":[]},{"line":"let add_from_gossip_exn t cmd nonce balance =","counters":[]},{"line":"  let open Result.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%map (c, cs), t =","counters":[]},{"line":"    run' t cmd","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"      (Add_from_gossip_exn0.add_from_gossip_exn ~config:t.config cmd nonce","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"         balance )","counters":[]},{"line":"  in","counters":[]},{"line":"  (c, t, cs)","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"(** Add back the commands that were removed due to a reorg*)","counters":[]},{"line":"let add_from_backtrack :","counters":[]},{"line":"       t","counters":[]},{"line":"    -> Transaction_hash.User_command_with_valid_signature.t","counters":[]},{"line":"    -> (t, Command_error.t) Result.t =","counters":[]},{"line":" fun ({ config = { constraint_constants; _ }; _ } as t) cmd ->","counters":[]},{"line":"  let open Result.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let unchecked =","counters":[]},{"line":"    Transaction_hash.User_command_with_valid_signature.command cmd","counters":[]},{"line":"  in","counters":[]},{"line":"  let%map () = check_expiry t.config unchecked in","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"  let fee_payer = User_command.fee_payer unchecked in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let fee_per_wu = User_command.fee_per_wu unchecked in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let entry_time = Time_ns.now () in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let cmd_hash = Transaction_hash.User_command_with_valid_signature.hash cmd in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let consumed =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Option.value_exn (currency_consumed ~constraint_constants cmd)","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"  in","counters":[]},{"line":"  match Map.find t.all_by_sender fee_payer with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | None ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      { all_by_sender =","counters":[]},{"line":"          (* If the command comes from backtracking, then we know it doesn't","counters":[]},{"line":"             cause overflow, so it's OK to throw here.","counters":[]},{"line":"          *)","counters":[]},{"line":"          Map.add_exn t.all_by_sender ~key:fee_payer","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"            ~data:(F_sequence.singleton cmd, consumed)","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"      ; all_by_fee =","counters":[]},{"line":"          Map_set.insert","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"            (module Transaction_hash.User_command_with_valid_signature)","counters":[]},{"line":"            t.all_by_fee fee_per_wu cmd","counters":[]},{"line":"      ; all_by_hash = Map.set t.all_by_hash ~key:cmd_hash ~data:cmd","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"      ; applicable_by_fee =","counters":[]},{"line":"          Map_set.insert","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"            (module Transaction_hash.User_command_with_valid_signature)","counters":[]},{"line":"            t.applicable_by_fee fee_per_wu cmd","counters":[]},{"line":"      ; transactions_with_expiration =","counters":[]},{"line":"          add_to_expiration t.transactions_with_expiration cmd","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"      ; entry_times = Map.add_exn t.entry_times ~key:cmd_hash ~data:entry_time","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"      ; all_by_entry_time =","counters":[]},{"line":"          Map.add_exn t.all_by_entry_time ~key:entry_time ~data:cmd_hash","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"      ; size = t.size + 1","counters":[]},{"line":"      ; config = t.config","counters":[]},{"line":"      }","counters":[]},{"line":"  | Some (queue, currency_reserved) ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let first_queued = F_sequence.head_exn queue in","counters":[]},{"line":"      if","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        not","counters":[]},{"line":"          (Account_nonce.equal","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"             (unchecked |> User_command.expected_target_nonce)","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"             ( first_queued","counters":[]},{"line":"             |> Transaction_hash.User_command_with_valid_signature.command","counters":[{"col_start":73,"col_end":73,"count":0}]},{"line":"             |> User_command.applicable_at_nonce ) )","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"      then","counters":[]},{"line":"        failwith","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"        @@ sprintf","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"             !\"indexed pool nonces inconsistent when adding from backtrack. \\","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"               Trying to add \\","counters":[]},{"line":"               %{sexp:Transaction_hash.User_command_with_valid_signature.t} to \\","counters":[]},{"line":"               %{sexp: t}\"","counters":[]},{"line":"             cmd t ;","counters":[]},{"line":"      let t' = remove_applicable_exn t first_queued in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      { applicable_by_fee =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          Map_set.insert","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"            (module Transaction_hash.User_command_with_valid_signature)","counters":[]},{"line":"            t'.applicable_by_fee fee_per_wu cmd","counters":[]},{"line":"      ; all_by_fee =","counters":[]},{"line":"          Map_set.insert","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"            (module Transaction_hash.User_command_with_valid_signature)","counters":[]},{"line":"            t'.all_by_fee fee_per_wu cmd","counters":[]},{"line":"      ; all_by_hash =","counters":[]},{"line":"          Map.set t.all_by_hash","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"            ~key:(Transaction_hash.User_command_with_valid_signature.hash cmd)","counters":[{"col_start":72,"col_end":72,"count":0}]},{"line":"            ~data:cmd","counters":[]},{"line":"      ; all_by_sender =","counters":[]},{"line":"          Map.set t'.all_by_sender ~key:fee_payer","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"            ~data:","counters":[]},{"line":"              ( F_sequence.cons cmd queue","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"              , Option.value_exn Currency.Amount.(currency_reserved + consumed)","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"              )","counters":[]},{"line":"      ; transactions_with_expiration =","counters":[]},{"line":"          add_to_expiration t.transactions_with_expiration cmd","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"      ; entry_times = Map.add_exn t.entry_times ~key:cmd_hash ~data:entry_time","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"      ; all_by_entry_time =","counters":[]},{"line":"          Map.add_exn t.all_by_entry_time ~key:entry_time ~data:cmd_hash","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"      ; size = t.size + 1","counters":[]},{"line":"      ; config = t.config","counters":[]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"let global_slot_since_genesis t = global_slot_since_genesis t.config","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"","counters":[]},{"line":"(* Only show stdout for failed inline tests. *)","counters":[]},{"line":"open Inline_test_quiet_logs","counters":[]},{"line":"","counters":[]},{"line":"let%test_module _ =","counters":[]},{"line":"  ( module struct","counters":[]},{"line":"    open For_tests","counters":[]},{"line":"","counters":[]},{"line":"    let test_keys = Array.init 10 ~f:(fun _ -> Signature_lib.Keypair.create ())","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"","counters":[]},{"line":"    let gen_cmd ?sign_type ?nonce () =","counters":[]},{"line":"      User_command.Valid.Gen.payment_with_random_participants ~keys:test_keys","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"        ~max_amount:1000 ~fee_range:10 ?sign_type ?nonce ()","counters":[]},{"line":"      |> Quickcheck.Generator.map","counters":[]},{"line":"           ~f:Transaction_hash.User_command_with_valid_signature.create","counters":[]},{"line":"","counters":[]},{"line":"    let precomputed_values = Lazy.force Precomputed_values.for_unit_tests","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"","counters":[]},{"line":"    let constraint_constants = precomputed_values.constraint_constants","counters":[]},{"line":"","counters":[]},{"line":"    let consensus_constants = precomputed_values.consensus_constants","counters":[]},{"line":"","counters":[]},{"line":"    let logger = Logger.null ()","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"","counters":[]},{"line":"    let time_controller = Block_time.Controller.basic ~logger","counters":[]},{"line":"","counters":[]},{"line":"    let expiry_ns =","counters":[]},{"line":"      Time_ns.Span.of_hr","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"        (Float.of_int precomputed_values.genesis_constants.transaction_expiry_hr)","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"","counters":[]},{"line":"    let empty =","counters":[]},{"line":"      empty ~constraint_constants ~consensus_constants ~time_controller","counters":[]},{"line":"        ~expiry_ns","counters":[]},{"line":"","counters":[]},{"line":"    let%test_unit \"empty invariants\" = assert_invariants empty","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"singleton properties\" =","counters":[]},{"line":"      Quickcheck.test (gen_cmd ()) ~f:(fun cmd ->","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"          let pool = empty in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let add_res =","counters":[]},{"line":"            add_from_gossip_exn pool cmd Account_nonce.zero","counters":[]},{"line":"              (Currency.Amount.of_int 500)","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"          in","counters":[]},{"line":"          if","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Option.value_exn (currency_consumed ~constraint_constants cmd)","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"            |> Currency.Amount.to_int > 500","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"          then","counters":[]},{"line":"            match add_res with","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            | Error (Insufficient_funds _) ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ()","counters":[]},{"line":"            | _ ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                failwith \"should've returned insufficient_funds\"","counters":[]},{"line":"          else","counters":[]},{"line":"            match add_res with","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            | Ok (_, pool', dropped) ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                assert_invariants pool' ;","counters":[]},{"line":"                assert (Sequence.is_empty dropped) ;","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"                [%test_eq: int] (size pool') 1 ;","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"                [%test_eq:","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Transaction_hash.User_command_with_valid_signature.t option]","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"                  (get_highest_fee pool') (Some cmd) ;","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"                let dropped', pool'' = remove_lowest_fee pool' in","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                [%test_eq:","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Transaction_hash.User_command_with_valid_signature.t","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  Sequence.t] dropped' (Sequence.singleton cmd) ;","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"                [%test_eq: t] ~equal pool pool''","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"            | _ ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                failwith \"should've succeeded\" )","counters":[]},{"line":"","counters":[]},{"line":"    let%test_unit \"age-based expiry\" =","counters":[]},{"line":"      Quickcheck.test ~trials:1","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (Mina_generators.User_command_generators.zkapp_command_with_ledger ())","counters":[{"col_start":73,"col_end":73,"count":0}]},{"line":"        ~f:(fun (cmd, _, _, _) ->","counters":[]},{"line":"          let cmd =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Transaction_hash.User_command_with_valid_signature.create cmd","counters":[]},{"line":"          in","counters":[]},{"line":"          let pool =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            { empty with","counters":[]},{"line":"              config = { empty.config with expiry_ns = Time_ns.Span.of_sec 5.0 }","counters":[{"col_start":73,"col_end":73,"count":0}]},{"line":"            }","counters":[]},{"line":"          in","counters":[]},{"line":"          add_from_gossip_exn pool cmd Account_nonce.zero","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"            (Currency.Amount.of_int 3000_000_000_000_000)","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"          |> function","counters":[]},{"line":"          | Ok (_, pool', dropped) ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              assert (Sequence.is_empty dropped) ;","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"              Unix.sleep 15 ;","counters":[]},{"line":"              let dropped, _ = remove_expired pool' in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              assert (not @@ Sequence.is_empty dropped)","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"          | Error e ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              failwithf !\"Error: %{sexp: Command_error.t}\" e () )","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"sequential adds (all valid)\" =","counters":[]},{"line":"      let gen :","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          ( Mina_ledger.Ledger.init_state","counters":[]},{"line":"          * Transaction_hash.User_command_with_valid_signature.t list )","counters":[]},{"line":"          Quickcheck.Generator.t =","counters":[]},{"line":"        let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"        let%bind ledger_init = Mina_ledger.Ledger.gen_initial_ledger_state in","counters":[]},{"line":"        let%map cmds = User_command.Valid.Gen.sequence ledger_init in","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"        ( ledger_init","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        , List.map ~f:Transaction_hash.User_command_with_valid_signature.create","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"            cmds )","counters":[]},{"line":"      in","counters":[]},{"line":"      let shrinker :","counters":[]},{"line":"          ( Mina_ledger.Ledger.init_state","counters":[]},{"line":"          * Transaction_hash.User_command_with_valid_signature.t list )","counters":[]},{"line":"          Quickcheck.Shrinker.t =","counters":[]},{"line":"        Quickcheck.Shrinker.create (fun (init_state, cmds) ->","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"            Sequence.singleton","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (init_state, List.take cmds (List.length cmds - 1)) )","counters":[{"col_start":35,"col_end":35,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"      in","counters":[]},{"line":"      Quickcheck.test gen ~trials:1000","counters":[]},{"line":"        ~sexp_of:","counters":[]},{"line":"          [%sexp_of:","counters":[]},{"line":"            Mina_ledger.Ledger.init_state","counters":[]},{"line":"            * Transaction_hash.User_command_with_valid_signature.t list]","counters":[]},{"line":"        ~shrinker ~shrink_attempts:`Exhaustive ~seed:(`Deterministic \"d\")","counters":[]},{"line":"        ~sizes:(Sequence.repeat 10) ~f:(fun (ledger_init, cmds) ->","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"          let account_init_states_seq = Array.to_sequence ledger_init in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let balances = Hashtbl.create (module Public_key.Compressed) in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let nonces = Hashtbl.create (module Public_key.Compressed) in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          Sequence.iter account_init_states_seq","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ~f:(fun (kp, balance, nonce, _) ->","counters":[]},{"line":"              let compressed = Public_key.compress kp.public_key in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              Hashtbl.add_exn balances ~key:compressed ~data:balance ;","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              Hashtbl.add_exn nonces ~key:compressed ~data:nonce ) ;","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"          let pool = ref empty in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let rec go cmds_acc =","counters":[]},{"line":"            match cmds_acc with","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            | [] ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ()","counters":[]},{"line":"            | cmd :: rest -> (","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                let unchecked =","counters":[]},{"line":"                  Transaction_hash.User_command_with_valid_signature.command cmd","counters":[]},{"line":"                in","counters":[]},{"line":"                let account_id = User_command.fee_payer unchecked in","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                let pk = Account_id.public_key account_id in","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                let add_res =","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  add_from_gossip_exn !pool cmd","counters":[]},{"line":"                    (Hashtbl.find_exn nonces pk)","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"                    (Hashtbl.find_exn balances pk)","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"                in","counters":[]},{"line":"                match add_res with","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                | Ok (_, pool', dropped) ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    [%test_eq:","counters":[]},{"line":"                      Transaction_hash.User_command_with_valid_signature.t","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                      Sequence.t] dropped Sequence.empty ;","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                    assert_invariants pool' ;","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                    pool := pool' ;","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                    go rest","counters":[]},{"line":"                | Error (Invalid_nonce (`Expected want, got)) ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    failwithf","counters":[]},{"line":"                      !\"Bad nonce. Expected: %{sexp: Account.Nonce.t}. Got: \\","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                        %{sexp: Account.Nonce.t}\"","counters":[]},{"line":"                      want got ()","counters":[]},{"line":"                | Error (Invalid_nonce (`Between (low, high), got)) ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    failwithf","counters":[]},{"line":"                      !\"Bad nonce. Expected between %{sexp: Account.Nonce.t} \\","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                        and %{sexp:Account.Nonce.t}. Got: %{sexp: \\","counters":[]},{"line":"                        Account.Nonce.t}\"","counters":[]},{"line":"                      low high got ()","counters":[]},{"line":"                | Error (Insufficient_funds (`Balance bal, amt)) ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    failwithf","counters":[]},{"line":"                      !\"Insufficient funds. Balance: %{sexp: \\","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                        Currency.Amount.t}. Amount: %{sexp: Currency.Amount.t}\"","counters":[]},{"line":"                      bal amt ()","counters":[]},{"line":"                | Error (Insufficient_replace_fee (`Replace_fee rfee, fee)) ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    failwithf","counters":[]},{"line":"                      !\"Insufficient fee for replacement. Needed at least \\","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                        %{sexp: Currency.Fee.t} but got \\","counters":[]},{"line":"                        %{sexp:Currency.Fee.t}.\"","counters":[]},{"line":"                      rfee fee ()","counters":[]},{"line":"                | Error Overflow ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    failwith \"Overflow.\"","counters":[]},{"line":"                | Error Bad_token ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    failwith \"Token is incompatible with the command.\"","counters":[]},{"line":"                | Error (Unwanted_fee_token fee_token) ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    failwithf","counters":[]},{"line":"                      !\"Bad fee token. The fees are paid in token %{sexp: \\","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                        Token_id.t}, which we are not accepting fees in.\"","counters":[]},{"line":"                      fee_token ()","counters":[]},{"line":"                | Error","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    (Expired","counters":[]},{"line":"                      ( `Valid_until valid_until","counters":[]},{"line":"                      , `Global_slot_since_genesis global_slot_since_genesis )","counters":[]},{"line":"                      ) ->","counters":[]},{"line":"                    failwithf","counters":[]},{"line":"                      !\"Expired user command. Current global slot is \\","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                        %{sexp:Mina_numbers.Global_slot.t} but user command is \\","counters":[]},{"line":"                        only valid until %{sexp:Mina_numbers.Global_slot.t}\"","counters":[]},{"line":"                      global_slot_since_genesis valid_until ()","counters":[]},{"line":"                | Error","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    (Expired","counters":[]},{"line":"                      ( `Timestamp_predicate expiry_ns","counters":[]},{"line":"                      , `Global_slot_since_genesis global_slot_since_genesis )","counters":[]},{"line":"                      ) ->","counters":[]},{"line":"                    failwithf","counters":[]},{"line":"                      !\"Expired zkapp. Current global slot is \\","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                        %{sexp:Mina_numbers.Global_slot.t}. Transaction \\","counters":[]},{"line":"                        expired or will expire in the pool based on the \\","counters":[]},{"line":"                        current expiry duration of %s\"","counters":[]},{"line":"                      global_slot_since_genesis expiry_ns () )","counters":[]},{"line":"          in","counters":[]},{"line":"          go cmds )","counters":[]},{"line":"","counters":[]},{"line":"    let%test_unit \"replacement\" =","counters":[]},{"line":"      let modify_payment (c : User_command.t) ~sender ~common:fc ~body:fb =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let modified_payload : Signed_command.Payload.t =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          match c with","counters":[]},{"line":"          | Signed_command","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              { payload = { body = Payment payment_payload; common }; _ } ->","counters":[]},{"line":"              { common = fc common","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"              ; body = Signed_command.Payload.Body.Payment (fb payment_payload)","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"              }","counters":[]},{"line":"          | _ ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              failwith \"generated user command that wasn't a payment\"","counters":[]},{"line":"        in","counters":[]},{"line":"        Signed_command","counters":[]},{"line":"          (Signed_command.For_tests.fake_sign sender modified_payload)","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"        |> Transaction_hash.User_command_with_valid_signature.create","counters":[]},{"line":"      in","counters":[]},{"line":"      let gen :","counters":[]},{"line":"          ( Account_nonce.t","counters":[]},{"line":"          * Currency.Amount.t","counters":[]},{"line":"          * Transaction_hash.User_command_with_valid_signature.t list","counters":[]},{"line":"          * Transaction_hash.User_command_with_valid_signature.t )","counters":[]},{"line":"          Quickcheck.Generator.t =","counters":[]},{"line":"        let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"        let%bind sender_index = Int.gen_incl 0 9 in","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"        let sender = test_keys.(sender_index) in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let%bind init_nonce =","counters":[]},{"line":"          Quickcheck.Generator.map ~f:Account_nonce.of_int","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"          @@ Int.gen_incl 0 1000","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"        in","counters":[]},{"line":"        let init_balance = Currency.Amount.of_int 100_000_000_000_000 in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let%bind size = Quickcheck.Generator.size in","counters":[]},{"line":"        let%bind amounts =","counters":[]},{"line":"          Quickcheck.Generator.map ~f:Array.of_list","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"          @@ Quickcheck_lib.gen_division_currency init_balance (size + 1)","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"        in","counters":[]},{"line":"        let rec go current_nonce current_balance n =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          if n > 0 then","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let%bind cmd =","counters":[]},{"line":"              let key_gen =","counters":[]},{"line":"                Quickcheck.Generator.tuple2 (return sender)","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                  (Quickcheck_lib.of_array test_keys)","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"              in","counters":[]},{"line":"              Mina_generators.User_command_generators.payment ~sign_type:`Fake","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"                ~key_gen ~nonce:current_nonce ~max_amount:1 ~fee_range:0 ()","counters":[]},{"line":"            in","counters":[]},{"line":"            let cmd_currency = amounts.(n - 1) in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let%bind fee =","counters":[]},{"line":"              Currency.Amount.(gen_incl zero (min (of_int 10) cmd_currency))","counters":[{"col_start":38,"col_end":38,"count":0},{"col_start":48,"col_end":48,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"            in","counters":[]},{"line":"            let amount =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Option.value_exn Currency.Amount.(cmd_currency - fee)","counters":[]},{"line":"            in","counters":[]},{"line":"            let cmd' =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              modify_payment cmd ~sender","counters":[]},{"line":"                ~common:(fun c -> { c with fee = Currency.Amount.to_fee fee })","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":70,"col_end":70,"count":0}]},{"line":"                ~body:(fun b -> { b with amount })","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"            in","counters":[]},{"line":"            let consumed =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Option.value_exn (currency_consumed ~constraint_constants cmd')","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"            in","counters":[]},{"line":"            let%map rest =","counters":[]},{"line":"              go","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                (Account_nonce.succ current_nonce)","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"                (Option.value_exn Currency.Amount.(current_balance - consumed))","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                (n - 1)","counters":[]},{"line":"            in","counters":[]},{"line":"            cmd' :: rest","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          else return []","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"        in","counters":[]},{"line":"        let%bind setup_cmds = go init_nonce init_balance (size + 1) in","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"        let init_nonce_int = Account.Nonce.to_int init_nonce in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let%bind replaced_nonce =","counters":[]},{"line":"          Int.gen_incl init_nonce_int","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"            (init_nonce_int + List.length setup_cmds - 1)","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"        in","counters":[]},{"line":"        let%map replace_cmd_skeleton =","counters":[]},{"line":"          let key_gen =","counters":[]},{"line":"            Quickcheck.Generator.tuple2 (return sender)","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"              (Quickcheck_lib.of_array test_keys)","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"          in","counters":[]},{"line":"          Mina_generators.User_command_generators.payment ~sign_type:`Fake","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"            ~key_gen","counters":[]},{"line":"            ~nonce:(Account_nonce.of_int replaced_nonce)","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"            ~max_amount:(Currency.Amount.to_int init_balance)","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"            ~fee_range:0 ()","counters":[]},{"line":"        in","counters":[]},{"line":"        let replace_cmd =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          modify_payment replace_cmd_skeleton ~sender ~body:Fn.id","counters":[]},{"line":"            ~common:(fun c ->","counters":[]},{"line":"              { c with","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                fee =","counters":[]},{"line":"                  Currency.Fee.of_int ((10 + (5 * (size + 1))) * 1_000_000_000)","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"              } )","counters":[]},{"line":"        in","counters":[]},{"line":"        (init_nonce, init_balance, setup_cmds, replace_cmd)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      in","counters":[]},{"line":"      Quickcheck.test ~trials:20 gen","counters":[]},{"line":"        ~sexp_of:","counters":[]},{"line":"          [%sexp_of:","counters":[]},{"line":"            Account_nonce.t","counters":[]},{"line":"            * Currency.Amount.t","counters":[]},{"line":"            * Transaction_hash.User_command_with_valid_signature.t list","counters":[]},{"line":"            * Transaction_hash.User_command_with_valid_signature.t]","counters":[]},{"line":"        ~f:(fun (init_nonce, init_balance, setup_cmds, replace_cmd) ->","counters":[]},{"line":"          let t =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            List.fold_left setup_cmds ~init:empty ~f:(fun t cmd ->","counters":[]},{"line":"                match add_from_gossip_exn t cmd init_nonce init_balance with","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                | Ok (_, t', removed) ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    [%test_eq:","counters":[]},{"line":"                      Transaction_hash.User_command_with_valid_signature.t","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                      Sequence.t] removed Sequence.empty ;","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                    t'","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                | _ ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    failwith","counters":[]},{"line":"                    @@ sprintf","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                         !\"adding command %{sexp: \\","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                           Transaction_hash.User_command_with_valid_signature.t} \\","counters":[]},{"line":"                           failed\"","counters":[]},{"line":"                         cmd )","counters":[]},{"line":"          in","counters":[]},{"line":"          let replaced_idx, _ =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let replace_nonce =","counters":[]},{"line":"              replace_cmd","counters":[]},{"line":"              |> Transaction_hash.User_command_with_valid_signature.command","counters":[{"col_start":74,"col_end":74,"count":0}]},{"line":"              |> User_command.applicable_at_nonce","counters":[]},{"line":"            in","counters":[]},{"line":"            List.findi setup_cmds ~f:(fun _i cmd ->","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"                let cmd_nonce =","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  cmd","counters":[]},{"line":"                  |> Transaction_hash.User_command_with_valid_signature.command","counters":[{"col_start":78,"col_end":78,"count":0}]},{"line":"                  |> User_command.applicable_at_nonce","counters":[]},{"line":"                in","counters":[]},{"line":"                Account_nonce.compare replace_nonce cmd_nonce <= 0 )","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"            |> Option.value_exn","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"          in","counters":[]},{"line":"          let currency_consumed_pre_replace =","counters":[]},{"line":"            List.fold_left","counters":[]},{"line":"              (List.take setup_cmds (replaced_idx + 1))","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"              ~init:Currency.Amount.zero","counters":[]},{"line":"              ~f:(fun consumed_so_far cmd ->","counters":[]},{"line":"                Option.value_exn","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Option.(","counters":[]},{"line":"                    currency_consumed ~constraint_constants cmd","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"                    >>= fun consumed ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                    Currency.Amount.(consumed + consumed_so_far)) )","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"          in","counters":[]},{"line":"          assert (","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"            Currency.Amount.(currency_consumed_pre_replace <= init_balance) ) ;","counters":[]},{"line":"          let currency_consumed_post_replace =","counters":[]},{"line":"            Option.value_exn","counters":[]},{"line":"              (let open Option.Let_syntax in","counters":[]},{"line":"              let%bind replaced_currency_consumed =","counters":[]},{"line":"                currency_consumed ~constraint_constants","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"                @@ List.nth_exn setup_cmds replaced_idx","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"              in","counters":[]},{"line":"              let%bind replacer_currency_consumed =","counters":[]},{"line":"                currency_consumed ~constraint_constants replace_cmd","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"              in","counters":[]},{"line":"              let%bind a =","counters":[]},{"line":"                Currency.Amount.(","counters":[]},{"line":"                  currency_consumed_pre_replace - replaced_currency_consumed)","counters":[]},{"line":"              in","counters":[]},{"line":"              Currency.Amount.(a + replacer_currency_consumed))","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"          in","counters":[]},{"line":"          let add_res =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            add_from_gossip_exn t replace_cmd init_nonce init_balance","counters":[]},{"line":"          in","counters":[]},{"line":"          if Currency.Amount.(currency_consumed_post_replace <= init_balance)","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          then","counters":[]},{"line":"            match add_res with","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            | Ok (_, t', dropped) ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                assert (not (Sequence.is_empty dropped)) ;","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"                assert_invariants t'","counters":[]},{"line":"            | Error _ ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                failwith \"adding command failed\"","counters":[]},{"line":"          else","counters":[]},{"line":"            match add_res with","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            | Error (Insufficient_funds _) ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ()","counters":[]},{"line":"            | _ ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                failwith \"should've returned insufficient_funds\" )","counters":[]},{"line":"","counters":[]},{"line":"    let%test_unit \"remove_lowest_fee\" =","counters":[]},{"line":"      let cmds =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        gen_cmd () |> Quickcheck.random_sequence |> Fn.flip Sequence.take 4","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":47,"col_end":47,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"        |> Sequence.to_list","counters":[]},{"line":"      in","counters":[]},{"line":"      let compare cmd0 cmd1 : int =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let open Transaction_hash.User_command_with_valid_signature in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Currency.Fee_rate.compare","counters":[]},{"line":"          (User_command.fee_per_wu @@ command cmd0)","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"          (User_command.fee_per_wu @@ command cmd1)","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"      in","counters":[]},{"line":"      let cmds_sorted_by_fee_per_wu = List.sort ~compare cmds in","counters":[]},{"line":"      let cmd_lowest_fee, commands_to_keep =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ( List.hd_exn cmds_sorted_by_fee_per_wu","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"        , List.tl_exn cmds_sorted_by_fee_per_wu )","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"      in","counters":[]},{"line":"      let insert_cmd pool cmd =","counters":[]},{"line":"        add_from_gossip_exn pool cmd Account_nonce.zero","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"          (Currency.Amount.of_int (500 * 10_000_000))","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"        |> Result.ok |> Option.value_exn","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"        |> fun (_, pool, _) -> pool","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"      in","counters":[]},{"line":"      let cmd_equal =","counters":[]},{"line":"        Transaction_hash.User_command_with_valid_signature.equal","counters":[]},{"line":"      in","counters":[]},{"line":"      let removed, pool =","counters":[]},{"line":"        List.fold_left cmds ~init:empty ~f:insert_cmd |> remove_lowest_fee","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"      in","counters":[]},{"line":"      (* check that the lowest fee per wu command is returned *)","counters":[]},{"line":"      assert (Sequence.(equal cmd_equal removed @@ return cmd_lowest_fee))","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":46,"col_end":46,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"      |> fun () ->","counters":[]},{"line":"      (* check that the lowest fee per wu command is removed from","counters":[]},{"line":"         applicable_by_fee *)","counters":[]},{"line":"      pool.applicable_by_fee |> Map.data","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"      |> List.concat_map ~f:Set.to_list","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"      |> fun applicable_by_fee_cmds ->","counters":[]},{"line":"      assert (List.(equal cmd_equal applicable_by_fee_cmds commands_to_keep))","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"      |> fun () ->","counters":[]},{"line":"      (* check that the lowest fee per wu command is removed from","counters":[]},{"line":"         all_by_fee *)","counters":[]},{"line":"      pool.applicable_by_fee |> Map.data","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"      |> List.concat_map ~f:Set.to_list","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"      |> fun all_by_fee_cmds ->","counters":[]},{"line":"      assert (List.(equal cmd_equal all_by_fee_cmds commands_to_keep))","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"get_highest_fee\" =","counters":[]},{"line":"      let cmds =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        gen_cmd () |> Quickcheck.random_sequence |> Fn.flip Sequence.take 4","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":47,"col_end":47,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"        |> Sequence.to_list","counters":[]},{"line":"      in","counters":[]},{"line":"      let compare cmd0 cmd1 : int =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let open Transaction_hash.User_command_with_valid_signature in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Currency.Fee_rate.compare","counters":[]},{"line":"          (User_command.fee_per_wu @@ command cmd0)","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"          (User_command.fee_per_wu @@ command cmd1)","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"      in","counters":[]},{"line":"      let max_by_fee_per_wu = List.max_elt ~compare cmds |> Option.value_exn in","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"      let insert_cmd pool cmd =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        add_from_gossip_exn pool cmd Account_nonce.zero","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"          (Currency.Amount.of_int (500 * 10_000_000))","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"        |> Result.ok |> Option.value_exn","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"        |> fun (_, pool, _) -> pool","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"      in","counters":[]},{"line":"      let pool = List.fold_left cmds ~init:empty ~f:insert_cmd in","counters":[]},{"line":"      let cmd_equal =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Transaction_hash.User_command_with_valid_signature.equal","counters":[]},{"line":"      in","counters":[]},{"line":"      get_highest_fee pool |> Option.value_exn","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"      |> fun highest_fee -> assert (cmd_equal highest_fee max_by_fee_per_wu)","counters":[{"col_start":35,"col_end":35,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"    let dummy_state_view =","counters":[]},{"line":"      let state_body =","counters":[]},{"line":"        let consensus_constants =","counters":[]},{"line":"          let genesis_constants = Genesis_constants.for_unit_tests in","counters":[]},{"line":"          Consensus.Constants.create ~constraint_constants","counters":[]},{"line":"            ~protocol_constants:genesis_constants.protocol","counters":[]},{"line":"        in","counters":[]},{"line":"        let compile_time_genesis =","counters":[]},{"line":"          (*not using Precomputed_values.for_unit_test because of dependency cycle*)","counters":[]},{"line":"          Mina_state.Genesis_protocol_state.t","counters":[]},{"line":"            ~genesis_ledger:Genesis_ledger.(Packed.t for_unit_tests)","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"            ~genesis_epoch_data:Consensus.Genesis_epoch_data.for_unit_tests","counters":[]},{"line":"            ~genesis_body_reference:Staged_ledger_diff.genesis_body_reference","counters":[]},{"line":"            ~constraint_constants ~consensus_constants","counters":[]},{"line":"        in","counters":[]},{"line":"        compile_time_genesis.data |> Mina_state.Protocol_state.body","counters":[{"col_start":66,"col_end":66,"count":0}]},{"line":"      in","counters":[]},{"line":"      { (Mina_state.Protocol_state.Body.view state_body) with","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"        global_slot_since_genesis = Mina_numbers.Global_slot.zero","counters":[]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    let add_to_pool ~nonce ~balance pool cmd =","counters":[]},{"line":"      let _, pool', dropped =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        add_from_gossip_exn pool cmd nonce balance","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"        |> Result.map_error","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"             ~f:(Fn.compose Sexp.to_string Command_error.sexp_of_t)","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"        |> Result.ok_or_failwith","counters":[]},{"line":"      in","counters":[]},{"line":"      [%test_eq:","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Transaction_hash.User_command_with_valid_signature.t Sequence.t] dropped","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"        Sequence.empty ;","counters":[]},{"line":"      assert_invariants pool' ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      pool'","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let init_permissionless_ledger ledger account_info =","counters":[]},{"line":"      let open Currency in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let open Mina_ledger.Ledger.Ledger_inner in","counters":[]},{"line":"      List.iter account_info ~f:(fun (public_key, amount) ->","counters":[]},{"line":"          let account_id =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Account_id.create (Public_key.compress public_key) Token_id.default","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"          in","counters":[]},{"line":"          let balance = Balance.of_int @@ Amount.to_int amount in","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"          let _tag, account, location =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Or_error.ok_exn (get_or_create ledger account_id)","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"          in","counters":[]},{"line":"          set ledger location","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            { account with balance; permissions = Permissions.empty } )","counters":[]},{"line":"","counters":[]},{"line":"    let apply_to_ledger ledger cmd =","counters":[]},{"line":"      match Transaction_hash.User_command_with_valid_signature.command cmd with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | User_command.Signed_command c ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let (`If_this_is_used_it_should_have_a_comment_justifying_it v) =","counters":[]},{"line":"            Signed_command.to_valid_unsafe c","counters":[]},{"line":"          in","counters":[]},{"line":"          ignore","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ( Mina_ledger.Ledger.apply_user_command ~constraint_constants","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                ~txn_global_slot:Mina_numbers.Global_slot.zero ledger v","counters":[]},{"line":"              |> Or_error.ok_exn","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"              : Mina_transaction_logic.Transaction_applied","counters":[]},{"line":"                .Signed_command_applied","counters":[]},{"line":"                .t )","counters":[]},{"line":"      | User_command.Zkapp_command p -> (","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let applied, _ =","counters":[]},{"line":"            Mina_ledger.Ledger.apply_zkapp_command_unchecked","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"              ~constraint_constants ~state_view:dummy_state_view ledger p","counters":[]},{"line":"            |> Or_error.ok_exn","counters":[]},{"line":"          in","counters":[]},{"line":"          match With_status.status applied.command with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | Transaction_status.Applied ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              ()","counters":[]},{"line":"          | Transaction_status.Failed failure ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              failwithf","counters":[]},{"line":"                \"failed to apply zkapp_command transaction to ledger: [%s]\"","counters":[]},{"line":"                ( String.concat ~sep:\", \"","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"                @@ List.bind","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                     ~f:(List.map ~f:Transaction_status.Failure.to_string)","counters":[]},{"line":"                     failure )","counters":[]},{"line":"                () )","counters":[]},{"line":"","counters":[]},{"line":"    let commit_to_pool ledger pool cmd expected_drops =","counters":[]},{"line":"      apply_to_ledger ledger cmd ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let accounts_to_check =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Transaction_hash.User_command_with_valid_signature.command cmd","counters":[{"col_start":65,"col_end":65,"count":0}]},{"line":"        |> User_command.accounts_referenced |> Account_id.Set.of_list","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"      in","counters":[]},{"line":"      let pool, dropped =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        revalidate pool ~logger (`Subset accounts_to_check) (fun sender ->","counters":[]},{"line":"            match Mina_ledger.Ledger.location_of_account ledger sender with","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            | None ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (Account.Nonce.zero, Currency.Amount.zero)","counters":[]},{"line":"            | Some loc ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                let acc =","counters":[]},{"line":"                  Option.value_exn","counters":[]},{"line":"                    ~message:","counters":[]},{"line":"                      \"Somehow a public key has a location but no account\"","counters":[]},{"line":"                    (Mina_ledger.Ledger.get ledger loc)","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"                in","counters":[]},{"line":"                ( acc.nonce","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                , Account.liquid_balance_at_slot","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"                    ~global_slot:Mina_numbers.Global_slot.zero acc","counters":[]},{"line":"                  |> Currency.Balance.to_amount ) )","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"      in","counters":[]},{"line":"      let lower =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        List.map ~f:Transaction_hash.User_command_with_valid_signature.hash","counters":[]},{"line":"      in","counters":[]},{"line":"      [%test_eq: Transaction_hash.t list]","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"        (lower (Sequence.to_list dropped))","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"        (lower expected_drops) ;","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"      assert_invariants pool ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      pool","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let make_zkapp_command_payment ~(sender : Keypair.t) ~(receiver : Keypair.t)","counters":[]},{"line":"        ~double_increment_sender ~increment_receiver ~amount ~fee nonce_int =","counters":[]},{"line":"      let open Currency in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let nonce = Account.Nonce.of_int nonce_int in","counters":[]},{"line":"      let sender_pk = Public_key.compress sender.public_key in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let receiver_pk = Public_key.compress receiver.public_key in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let zkapp_command_wire : Zkapp_command.Stable.Latest.Wire.t =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { fee_payer =","counters":[]},{"line":"            { Account_update.Fee_payer.body =","counters":[]},{"line":"                { public_key = sender_pk; fee; nonce; valid_until = None }","counters":[]},{"line":"                (* Real signature added in below *)","counters":[]},{"line":"            ; authorization = Signature.dummy","counters":[]},{"line":"            }","counters":[]},{"line":"        ; account_updates =","counters":[]},{"line":"            Zkapp_command.Call_forest.of_account_updates","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"              ~account_update_depth:(Fn.const 0)","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"              [ { Account_update.Wire.body =","counters":[]},{"line":"                    { public_key = sender_pk","counters":[]},{"line":"                    ; update = Account_update.Update.noop","counters":[]},{"line":"                    ; token_id = Token_id.default","counters":[]},{"line":"                    ; balance_change =","counters":[]},{"line":"                        Amount.Signed.(negate @@ of_unsigned amount)","counters":[{"col_start":44,"col_end":44,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"                    ; increment_nonce = double_increment_sender","counters":[]},{"line":"                    ; events = []","counters":[]},{"line":"                    ; sequence_events = []","counters":[]},{"line":"                    ; call_data = Snark_params.Tick.Field.zero","counters":[]},{"line":"                    ; preconditions =","counters":[]},{"line":"                        { Account_update.Preconditions.network =","counters":[]},{"line":"                            Zkapp_precondition.Protocol_state.accept","counters":[]},{"line":"                        ; account =","counters":[]},{"line":"                            Account_update.Account_precondition.Nonce","counters":[]},{"line":"                              (Account.Nonce.succ nonce)","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"                        }","counters":[]},{"line":"                    ; caller = Call","counters":[]},{"line":"                    ; use_full_commitment = not double_increment_sender","counters":[]},{"line":"                    ; authorization_kind = None_given","counters":[]},{"line":"                    }","counters":[]},{"line":"                ; authorization = None_given","counters":[]},{"line":"                }","counters":[]},{"line":"              ; { Account_update.Wire.body =","counters":[]},{"line":"                    { public_key = receiver_pk","counters":[]},{"line":"                    ; update = Account_update.Update.noop","counters":[]},{"line":"                    ; token_id = Token_id.default","counters":[]},{"line":"                    ; balance_change = Amount.Signed.of_unsigned amount","counters":[{"col_start":63,"col_end":63,"count":0}]},{"line":"                    ; increment_nonce = increment_receiver","counters":[]},{"line":"                    ; events = []","counters":[]},{"line":"                    ; sequence_events = []","counters":[]},{"line":"                    ; call_data = Snark_params.Tick.Field.zero","counters":[]},{"line":"                    ; preconditions =","counters":[]},{"line":"                        { Account_update.Preconditions.network =","counters":[]},{"line":"                            Zkapp_precondition.Protocol_state.accept","counters":[]},{"line":"                        ; account = Account_update.Account_precondition.Accept","counters":[]},{"line":"                        }","counters":[]},{"line":"                    ; caller = Call","counters":[]},{"line":"                    ; use_full_commitment = not increment_receiver","counters":[]},{"line":"                    ; authorization_kind = None_given","counters":[]},{"line":"                    }","counters":[]},{"line":"                ; authorization = None_given","counters":[]},{"line":"                }","counters":[]},{"line":"              ]","counters":[]},{"line":"        ; memo = Signed_command_memo.empty","counters":[]},{"line":"        }","counters":[]},{"line":"      in","counters":[]},{"line":"      let zkapp_command = Zkapp_command.of_wire zkapp_command_wire in","counters":[]},{"line":"      (* We skip signing the commitment and updating the authorization as it is not necessary to have a valid transaction for these tests. *)","counters":[]},{"line":"      let (`If_this_is_used_it_should_have_a_comment_justifying_it cmd) =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        User_command.to_valid_unsafe (User_command.Zkapp_command zkapp_command)","counters":[]},{"line":"      in","counters":[]},{"line":"      Transaction_hash.User_command_with_valid_signature.create cmd","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"support for zkapp_command commands\" =","counters":[]},{"line":"      let open Currency in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      (* let open Mina_transaction_logic.For_tests in *)","counters":[]},{"line":"      let fee = Mina_compile_config.minimum_user_command_fee in","counters":[]},{"line":"      let amount = Amount.of_int @@ Fee.to_int fee in","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"      let balance = Option.value_exn (Amount.scale amount 100) in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"      let kp1 =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Quickcheck.random_value ~seed:(`Deterministic \"apple\") Keypair.gen","counters":[]},{"line":"      in","counters":[]},{"line":"      let kp2 =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Quickcheck.random_value ~seed:(`Deterministic \"orange\") Keypair.gen","counters":[]},{"line":"      in","counters":[]},{"line":"      let add_cmd = add_to_pool ~nonce:Account_nonce.zero ~balance in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let make_cmd =","counters":[]},{"line":"        make_zkapp_command_payment ~sender:kp1 ~receiver:kp2","counters":[]},{"line":"          ~increment_receiver:false ~amount ~fee","counters":[]},{"line":"      in","counters":[]},{"line":"      Mina_ledger.Ledger.with_ledger ~depth:4 ~f:(fun ledger ->","counters":[]},{"line":"          init_permissionless_ledger ledger","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            [ (kp1.public_key, balance); (kp2.public_key, Amount.zero) ] ;","counters":[]},{"line":"          let commit = commit_to_pool ledger in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let cmd1 = make_cmd ~double_increment_sender:false 0 in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let cmd2 = make_cmd ~double_increment_sender:false 1 in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let cmd3 = make_cmd ~double_increment_sender:false 2 in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let cmd4 = make_cmd ~double_increment_sender:false 3 in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          (* used to break the sequence *)","counters":[]},{"line":"          let cmd3' = make_cmd ~double_increment_sender:true 2 in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let pool =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            List.fold_left [ cmd1; cmd2; cmd3; cmd4 ] ~init:empty ~f:add_cmd","counters":[]},{"line":"          in","counters":[]},{"line":"          let pool = commit pool cmd1 [ cmd1 ] in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let pool = commit pool cmd2 [ cmd2 ] in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let _pool = commit pool cmd3' [ cmd3; cmd4 ] in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          () )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"nonce increment side effects from other zkapp_command are \\","counters":[]},{"line":"                   handled properly\" =","counters":[]},{"line":"      let open Currency in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let fee = Mina_compile_config.minimum_user_command_fee in","counters":[]},{"line":"      let amount = Amount.of_int @@ Fee.to_int fee in","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"      let balance = Option.value_exn (Amount.scale amount 100) in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"      let kp1 =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Quickcheck.random_value ~seed:(`Deterministic \"apple\") Keypair.gen","counters":[]},{"line":"      in","counters":[]},{"line":"      let kp2 =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Quickcheck.random_value ~seed:(`Deterministic \"orange\") Keypair.gen","counters":[]},{"line":"      in","counters":[]},{"line":"      let add_cmd = add_to_pool ~nonce:Account_nonce.zero ~balance in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let make_cmd = make_zkapp_command_payment ~amount ~fee in","counters":[]},{"line":"      Mina_ledger.Ledger.with_ledger ~depth:4 ~f:(fun ledger ->","counters":[]},{"line":"          init_permissionless_ledger ledger","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            [ (kp1.public_key, balance); (kp2.public_key, balance) ] ;","counters":[]},{"line":"          let kp1_cmd1 =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            make_cmd ~sender:kp1 ~receiver:kp2 ~double_increment_sender:false","counters":[]},{"line":"              ~increment_receiver:true 0","counters":[]},{"line":"          in","counters":[]},{"line":"          let kp2_cmd1 =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            make_cmd ~sender:kp2 ~receiver:kp1 ~double_increment_sender:false","counters":[]},{"line":"              ~increment_receiver:false 0","counters":[]},{"line":"          in","counters":[]},{"line":"          let kp2_cmd2 =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            make_cmd ~sender:kp2 ~receiver:kp1 ~double_increment_sender:false","counters":[]},{"line":"              ~increment_receiver:false 1","counters":[]},{"line":"          in","counters":[]},{"line":"          let pool =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            List.fold_left","counters":[]},{"line":"              [ kp1_cmd1; kp2_cmd1; kp2_cmd2 ]","counters":[]},{"line":"              ~init:empty ~f:add_cmd","counters":[]},{"line":"          in","counters":[]},{"line":"          let _pool =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            commit_to_pool ledger pool kp1_cmd1 [ kp2_cmd1; kp1_cmd1 ]","counters":[]},{"line":"          in","counters":[]},{"line":"          () )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"nonce invariant violations on committed transactions does \\","counters":[]},{"line":"                   not trigger a crash\" =","counters":[]},{"line":"      let open Currency in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let fee = Mina_compile_config.minimum_user_command_fee in","counters":[]},{"line":"      let amount = Amount.of_int @@ Fee.to_int fee in","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"      let balance = Option.value_exn (Amount.scale amount 100) in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"      let kp1 =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Quickcheck.random_value ~seed:(`Deterministic \"apple\") Keypair.gen","counters":[]},{"line":"      in","counters":[]},{"line":"      let kp2 =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Quickcheck.random_value ~seed:(`Deterministic \"orange\") Keypair.gen","counters":[]},{"line":"      in","counters":[]},{"line":"      let add_cmd = add_to_pool ~nonce:Account_nonce.zero ~balance in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let make_cmd =","counters":[]},{"line":"        make_zkapp_command_payment ~sender:kp1 ~receiver:kp2","counters":[]},{"line":"          ~double_increment_sender:false ~increment_receiver:false ~amount ~fee","counters":[]},{"line":"      in","counters":[]},{"line":"      Mina_ledger.Ledger.with_ledger ~depth:4 ~f:(fun ledger ->","counters":[]},{"line":"          init_permissionless_ledger ledger","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            [ (kp1.public_key, balance); (kp2.public_key, Amount.zero) ] ;","counters":[]},{"line":"          let cmd1 = make_cmd 0 in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let cmd2 = make_cmd 1 in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let pool = List.fold_left [ cmd1; cmd2 ] ~init:empty ~f:add_cmd in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          apply_to_ledger ledger cmd1 ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let _pool = commit_to_pool ledger pool cmd2 [ cmd1; cmd2 ] in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          () )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"  end )","counters":[{"col_start":6,"col_end":6,"count":1}]}]}