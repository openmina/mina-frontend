{"filename":"src/lib/syncable_ledger/syncable_ledger.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Async_kernel","counters":[]},{"line":"open Pipe_lib","counters":[]},{"line":"open Network_peer","counters":[]},{"line":"","counters":[]},{"line":"type Structured_log_events.t += Snarked_ledger_synced","counters":[]},{"line":"  [@@deriving register_event { msg = \"Snarked database sync'd. All done\" }]","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":27,"col_end":27,"count":3}]},{"line":"","counters":[]},{"line":"(** Run f recursively n times, starting with value r.","counters":[]},{"line":"    e.g. funpow 3 f r = f (f (f r)) *)","counters":[]},{"line":"let rec funpow n f r = if n > 0 then funpow (n - 1) f (f r) else r","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":55,"col_end":55,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"","counters":[]},{"line":"module Query = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type 'addr t =","counters":[{"col_start":6,"col_end":6,"count":1},{"col_start":17,"col_end":17,"count":4}]},{"line":"        | What_child_hashes of 'addr","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"            (** What are the hashes of the children of this address? *)","counters":[]},{"line":"        | What_contents of 'addr","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"            (** What accounts are at this address? addr must have depth","counters":[]},{"line":"            tree_depth - account_subtree_height *)","counters":[]},{"line":"        | Num_accounts","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            (** How many accounts are there? Used to size data structure and","counters":[]},{"line":"            figure out what part of the tree is filled in. *)","counters":[]},{"line":"      [@@deriving sexp, yojson, hash, compare]","counters":[{"col_start":45,"col_end":45,"count":3}]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Answer = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type ('hash, 'account) t =","counters":[{"col_start":6,"col_end":6,"count":1},{"col_start":29,"col_end":29,"count":5}]},{"line":"        | Child_hashes_are of 'hash * 'hash","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"            (** The requested address's children have these hashes **)","counters":[]},{"line":"        | Contents_are of 'account list","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"            (** The requested address has these accounts *)","counters":[]},{"line":"        | Num_accounts of int * 'hash","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"            (** There are this many accounts and the smallest subtree that","counters":[]},{"line":"                contains all non-empty nodes has this hash. *)","counters":[]},{"line":"      [@@deriving sexp, yojson]","counters":[{"col_start":30,"col_end":30,"count":3}]},{"line":"","counters":[]},{"line":"      let to_latest acct_to_latest = function","counters":[]},{"line":"        | Child_hashes_are (h1, h2) ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Child_hashes_are (h1, h2)","counters":[]},{"line":"        | Contents_are accts ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Contents_are (List.map ~f:acct_to_latest accts)","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"        | Num_accounts (i, h) ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Num_accounts (i, h)","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type Inputs_intf = sig","counters":[]},{"line":"  module Addr : module type of Merkle_address","counters":[]},{"line":"","counters":[]},{"line":"  module Account : sig","counters":[]},{"line":"    type t [@@deriving bin_io, sexp, yojson]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Hash : Merkle_ledger.Intf.Hash with type account := Account.t","counters":[]},{"line":"","counters":[]},{"line":"  module Root_hash : sig","counters":[]},{"line":"    type t [@@deriving equal, sexp, yojson]","counters":[]},{"line":"","counters":[]},{"line":"    val to_hash : t -> Hash.t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module MT :","counters":[]},{"line":"    Merkle_ledger.Syncable_intf.S","counters":[]},{"line":"      with type hash := Hash.t","counters":[]},{"line":"       and type root_hash := Root_hash.t","counters":[]},{"line":"       and type addr := Addr.t","counters":[]},{"line":"       and type account := Account.t","counters":[]},{"line":"","counters":[]},{"line":"  val account_subtree_height : int","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type S = sig","counters":[]},{"line":"  type 'a t [@@deriving sexp]","counters":[]},{"line":"","counters":[]},{"line":"  type merkle_tree","counters":[]},{"line":"","counters":[]},{"line":"  type merkle_path","counters":[]},{"line":"","counters":[]},{"line":"  type hash","counters":[]},{"line":"","counters":[]},{"line":"  type root_hash","counters":[]},{"line":"","counters":[]},{"line":"  type addr","counters":[]},{"line":"","counters":[]},{"line":"  type diff","counters":[]},{"line":"","counters":[]},{"line":"  type account","counters":[]},{"line":"","counters":[]},{"line":"  type index = int","counters":[]},{"line":"","counters":[]},{"line":"  type query","counters":[]},{"line":"","counters":[]},{"line":"  type answer","counters":[]},{"line":"","counters":[]},{"line":"  module Responder : sig","counters":[]},{"line":"    type t","counters":[]},{"line":"","counters":[]},{"line":"    val create :","counters":[]},{"line":"         merkle_tree","counters":[]},{"line":"      -> (query -> unit)","counters":[]},{"line":"      -> logger:Logger.t","counters":[]},{"line":"      -> trust_system:Trust_system.t","counters":[]},{"line":"      -> t","counters":[]},{"line":"","counters":[]},{"line":"    val answer_query :","counters":[]},{"line":"      t -> query Envelope.Incoming.t -> answer option Deferred.t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  val create :","counters":[]},{"line":"    merkle_tree -> logger:Logger.t -> trust_system:Trust_system.t -> 'a t","counters":[]},{"line":"","counters":[]},{"line":"  val answer_writer :","counters":[]},{"line":"       'a t","counters":[]},{"line":"    -> (root_hash * query * answer Envelope.Incoming.t) Linear_pipe.Writer.t","counters":[]},{"line":"","counters":[]},{"line":"  val query_reader : 'a t -> (root_hash * query) Linear_pipe.Reader.t","counters":[]},{"line":"","counters":[]},{"line":"  val destroy : 'a t -> unit","counters":[]},{"line":"","counters":[]},{"line":"  val new_goal :","counters":[]},{"line":"       'a t","counters":[]},{"line":"    -> root_hash","counters":[]},{"line":"    -> data:'a","counters":[]},{"line":"    -> equal:('a -> 'a -> bool)","counters":[]},{"line":"    -> [ `Repeat | `New | `Update_data ]","counters":[]},{"line":"","counters":[]},{"line":"  val peek_valid_tree : 'a t -> merkle_tree option","counters":[]},{"line":"","counters":[]},{"line":"  val valid_tree : 'a t -> (merkle_tree * 'a) Deferred.t","counters":[]},{"line":"","counters":[]},{"line":"  val wait_until_valid :","counters":[]},{"line":"       'a t","counters":[]},{"line":"    -> root_hash","counters":[]},{"line":"    -> [ `Ok of merkle_tree | `Target_changed of root_hash option * root_hash ]","counters":[]},{"line":"       Deferred.t","counters":[]},{"line":"","counters":[]},{"line":"  val fetch :","counters":[]},{"line":"       'a t","counters":[]},{"line":"    -> root_hash","counters":[]},{"line":"    -> data:'a","counters":[]},{"line":"    -> equal:('a -> 'a -> bool)","counters":[]},{"line":"    -> [ `Ok of merkle_tree | `Target_changed of root_hash option * root_hash ]","counters":[]},{"line":"       Deferred.t","counters":[]},{"line":"","counters":[]},{"line":"  val apply_or_queue_diff : 'a t -> diff -> unit","counters":[]},{"line":"","counters":[]},{"line":"  val merkle_path_at_addr : 'a t -> addr -> merkle_path Or_error.t","counters":[]},{"line":"","counters":[]},{"line":"  val get_account_at_addr : 'a t -> addr -> account Or_error.t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(*","counters":[]},{"line":"","counters":[]},{"line":"Every node of the merkle tree is always in one of three states:","counters":[]},{"line":"","counters":[]},{"line":"- Fresh.","counters":[]},{"line":"  The current contents for this node in the MT match what we","counters":[]},{"line":"  expect.","counters":[]},{"line":"- Stale","counters":[]},{"line":"  The current contents for this node in the MT do _not_ match","counters":[]},{"line":"  what we expect.","counters":[]},{"line":"- Unknown.","counters":[]},{"line":"  We don't know what to expect yet.","counters":[]},{"line":"","counters":[]},{"line":"","counters":[]},{"line":"Although every node conceptually has one of these states, and can","counters":[]},{"line":"make a transition at any time, the syncer operates only along a","counters":[]},{"line":"\"frontier\" of the tree, which consists of the deepest Stale nodes.","counters":[]},{"line":"","counters":[]},{"line":"The goal of the ledger syncer is to make the root node be fresh,","counters":[]},{"line":"starting from it being stale.","counters":[]},{"line":"","counters":[]},{"line":"The syncer usually operates exclusively on these frontier nodes","counters":[]},{"line":"and their direct children. However, the goal hash can change","counters":[]},{"line":"while the syncer is running, and at that point every non-root node","counters":[]},{"line":"conceptually becomes Unknown, and we need to restart. However, we","counters":[]},{"line":"don't need to restart completely: in practice, only small portions","counters":[]},{"line":"of the merkle tree change between goals, and we can re-use the \"Stale\"","counters":[]},{"line":"nodes we already have if the expected hash doesn't change.","counters":[]},{"line":"","counters":[]},{"line":"*)","counters":[]},{"line":"(*","counters":[]},{"line":"Note: while syncing, the underlying ledger is in an","counters":[]},{"line":"indeterminate state. We're mutating hashes at internal","counters":[]},{"line":"nodes without updating their children. In fact, we","counters":[]},{"line":"don't even set all the hashes for the internal nodes!","counters":[]},{"line":"(When we hit a height=N subtree, we don't do anything","counters":[]},{"line":"with the hashes in the bottomost N-1 internal nodes).","counters":[]},{"line":"*)","counters":[]},{"line":"","counters":[]},{"line":"module Make (Inputs : Inputs_intf) : sig","counters":[]},{"line":"  open Inputs","counters":[]},{"line":"","counters":[]},{"line":"  include","counters":[]},{"line":"    S","counters":[]},{"line":"      with type merkle_tree := MT.t","counters":[]},{"line":"       and type hash := Hash.t","counters":[]},{"line":"       and type root_hash := Root_hash.t","counters":[]},{"line":"       and type addr := Addr.t","counters":[]},{"line":"       and type merkle_path := MT.path","counters":[]},{"line":"       and type account := Account.t","counters":[]},{"line":"       and type query := Addr.t Query.t","counters":[]},{"line":"       and type answer := (Hash.t, Account.t) Answer.t","counters":[]},{"line":"end = struct","counters":[]},{"line":"  open Inputs","counters":[]},{"line":"","counters":[]},{"line":"  type diff = unit","counters":[]},{"line":"","counters":[]},{"line":"  type index = int","counters":[]},{"line":"","counters":[]},{"line":"  type answer = (Hash.t, Account.t) Answer.t","counters":[]},{"line":"","counters":[]},{"line":"  type query = Addr.t Query.t","counters":[]},{"line":"","counters":[]},{"line":"  module Responder = struct","counters":[]},{"line":"    type t =","counters":[]},{"line":"      { mt : MT.t","counters":[]},{"line":"      ; f : query -> unit","counters":[]},{"line":"      ; logger : Logger.t","counters":[]},{"line":"      ; trust_system : Trust_system.t","counters":[]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    let create :","counters":[]},{"line":"           MT.t","counters":[]},{"line":"        -> (query -> unit)","counters":[]},{"line":"        -> logger:Logger.t","counters":[]},{"line":"        -> trust_system:Trust_system.t","counters":[]},{"line":"        -> t =","counters":[]},{"line":"     fun mt f ~logger ~trust_system -> { mt; f; logger; trust_system }","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"    let answer_query :","counters":[]},{"line":"        t -> query Envelope.Incoming.t -> answer option Deferred.t =","counters":[]},{"line":"     fun { mt; f; logger; trust_system } query_envelope ->","counters":[]},{"line":"      let open Trust_system in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let ledger_depth = MT.depth mt in","counters":[]},{"line":"      let sender = Envelope.Incoming.sender query_envelope in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let query = Envelope.Incoming.data query_envelope in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      f query ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let response_or_punish =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        match query with","counters":[]},{"line":"        | What_child_hashes a -> (","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            match","counters":[]},{"line":"              let open Or_error.Let_syntax in","counters":[]},{"line":"              let%bind lchild = Addr.child ~ledger_depth a Direction.Left in","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"              let%bind rchild = Addr.child ~ledger_depth a Direction.Right in","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"              Or_error.try_with (fun () ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                  Answer.Child_hashes_are","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    ( MT.get_inner_hash_at_addr_exn mt lchild","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                    , MT.get_inner_hash_at_addr_exn mt rchild ) )","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"            with","counters":[]},{"line":"            | Ok answer ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Either.First answer","counters":[]},{"line":"            | Error e ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                let logger = Logger.create () in","counters":[]},{"line":"                [%log error]","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"                  ~metadata:[ (\"error\", Error_json.error_to_yojson e) ]","counters":[{"col_start":65,"col_end":65,"count":0}]},{"line":"                  \"When handling What_child_hashes request, the following \\","counters":[]},{"line":"                   error happended: $error\" ;","counters":[]},{"line":"                Either.Second","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  ( Actions.Violated_protocol","counters":[]},{"line":"                  , Some","counters":[]},{"line":"                      ( \"invalid address $addr in What_child_hashes request\"","counters":[]},{"line":"                      , [ (\"addr\", Addr.to_yojson a) ] ) ) )","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"        | What_contents a ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            if Addr.height ~ledger_depth a > account_subtree_height then","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"              Either.Second","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ( Actions.Violated_protocol","counters":[]},{"line":"                , Some","counters":[]},{"line":"                    ( \"requested too big of a subtree at once: $addr\"","counters":[]},{"line":"                    , [ (\"addr\", Addr.to_yojson a) ] ) )","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"            else","counters":[]},{"line":"              let addresses_and_accounts =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                List.sort ~compare:(fun (addr1, _) (addr2, _) ->","counters":[]},{"line":"                    Addr.compare addr1 addr2 )","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                @@ MT.get_all_accounts_rooted_at_exn mt a","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                (* can't actually throw *)","counters":[]},{"line":"              in","counters":[]},{"line":"              let addresses, accounts = List.unzip addresses_and_accounts in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              if List.is_empty addresses then","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (* Peer should know what portions of the tree are full from the","counters":[]},{"line":"                   Num_accounts query. *)","counters":[]},{"line":"                Either.Second","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  ( Actions.Violated_protocol","counters":[]},{"line":"                  , Some","counters":[]},{"line":"                      ( \"Requested empty subtree: $addr\"","counters":[]},{"line":"                      , [ (\"addr\", Addr.to_yojson a) ] ) )","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"              else","counters":[]},{"line":"                let first_address, rest_address =","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  (List.hd_exn addresses, List.tl_exn addresses)","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"                in","counters":[]},{"line":"                let missing_address, is_compact =","counters":[]},{"line":"                  List.fold rest_address","counters":[]},{"line":"                    ~init:(Addr.next first_address, true)","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                    ~f:(fun (expected_address, is_compact) actual_address ->","counters":[]},{"line":"                      if","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        is_compact","counters":[]},{"line":"                        && [%equal: Addr.t option] expected_address","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"                             (Some actual_address)","counters":[]},{"line":"                      then (Addr.next actual_address, true)","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"                      else (expected_address, false) )","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                in","counters":[]},{"line":"                if not is_compact then (","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"                  (* indicates our ledger is invalid somehow. *)","counters":[]},{"line":"                  [%log fatal]","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                    ~metadata:","counters":[]},{"line":"                      [ ( \"missing_address\"","counters":[]},{"line":"                        , Addr.to_yojson (Option.value_exn missing_address) )","counters":[{"col_start":39,"col_end":39,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"                      ; ( \"addresses_and_accounts\"","counters":[]},{"line":"                        , `List","counters":[]},{"line":"                            (List.map addresses_and_accounts","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"                               ~f:(fun (addr, account) ->","counters":[]},{"line":"                                 `Tuple","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"                                   [ Addr.to_yojson addr","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                                   ; Account.to_yojson account","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"                                   ] ) ) )","counters":[]},{"line":"                      ]","counters":[]},{"line":"                    \"Missing an account at address: $missing_address inside \\","counters":[]},{"line":"                     the list: $addresses_and_accounts\" ;","counters":[]},{"line":"                  assert false )","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                else Either.First (Answer.Contents_are accounts)","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"        | Num_accounts ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let len = MT.num_accounts mt in","counters":[]},{"line":"            let height = Int.ceil_log2 len in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            (* FIXME: bug when height=0 https://github.com/o1-labs/nanobit/issues/365 *)","counters":[]},{"line":"            let content_root_addr =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              funpow","counters":[]},{"line":"                (MT.depth mt - height)","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                (fun a -> Addr.child_exn ~ledger_depth a Direction.Left)","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                (Addr.root ())","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"            in","counters":[]},{"line":"            Either.First","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (Num_accounts","counters":[]},{"line":"                 (len, MT.get_inner_hash_at_addr_exn mt content_root_addr) )","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"      in","counters":[]},{"line":"      match response_or_punish with","counters":[]},{"line":"      | Either.First answer ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Deferred.return @@ Some answer","counters":[]},{"line":"      | Either.Second action ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let%map _ =","counters":[]},{"line":"            record_envelope_sender trust_system logger sender action","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"          in","counters":[]},{"line":"          None","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  type 'a t =","counters":[]},{"line":"    { mutable desired_root : Root_hash.t option","counters":[]},{"line":"    ; mutable auxiliary_data : 'a option","counters":[]},{"line":"    ; tree : MT.t","counters":[]},{"line":"    ; logger : Logger.t","counters":[]},{"line":"    ; trust_system : Trust_system.t","counters":[]},{"line":"    ; answers :","counters":[]},{"line":"        (Root_hash.t * query * answer Envelope.Incoming.t) Linear_pipe.Reader.t","counters":[]},{"line":"    ; answer_writer :","counters":[]},{"line":"        (Root_hash.t * query * answer Envelope.Incoming.t) Linear_pipe.Writer.t","counters":[]},{"line":"    ; queries : (Root_hash.t * query) Linear_pipe.Writer.t","counters":[]},{"line":"    ; query_reader : (Root_hash.t * query) Linear_pipe.Reader.t","counters":[]},{"line":"    ; waiting_parents : Hash.t Addr.Table.t","counters":[]},{"line":"          (** Addresses we are waiting for the children of, and the expected","counters":[]},{"line":"              hash of the node with the address. *)","counters":[]},{"line":"    ; waiting_content : Hash.t Addr.Table.t","counters":[]},{"line":"    ; mutable validity_listener :","counters":[]},{"line":"        [ `Ok | `Target_changed of Root_hash.t option * Root_hash.t ] Ivar.t","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let t_of_sexp _ = failwith \"t_of_sexp: not implemented\"","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"","counters":[]},{"line":"  let sexp_of_t _ = failwith \"sexp_of_t: not implemented\"","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"","counters":[]},{"line":"  let desired_root_exn { desired_root; _ } = desired_root |> Option.value_exn","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"","counters":[]},{"line":"  let destroy t =","counters":[]},{"line":"    Linear_pipe.close_read t.answers ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Linear_pipe.close_read t.query_reader","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let answer_writer t = t.answer_writer","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"","counters":[]},{"line":"  let query_reader t = t.query_reader","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"  let expect_children : 'a t -> Addr.t -> Hash.t -> unit =","counters":[]},{"line":"   fun t parent_addr expected ->","counters":[]},{"line":"    [%log' trace t.logger]","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"      ~metadata:","counters":[]},{"line":"        [ (\"parent_address\", Addr.to_yojson parent_addr)","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"        ; (\"hash\", Hash.to_yojson expected)","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"        ]","counters":[]},{"line":"      \"Expecting children parent $parent_address, expected: $hash\" ;","counters":[]},{"line":"    Addr.Table.add_exn t.waiting_parents ~key:parent_addr ~data:expected","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let expect_content : 'a t -> Addr.t -> Hash.t -> unit =","counters":[]},{"line":"   fun t addr expected ->","counters":[]},{"line":"    [%log' trace t.logger]","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"      ~metadata:","counters":[]},{"line":"        [ (\"address\", Addr.to_yojson addr); (\"hash\", Hash.to_yojson expected) ]","counters":[{"col_start":35,"col_end":35,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"      \"Expecting content addr $address, expected: $hash\" ;","counters":[]},{"line":"    Addr.Table.add_exn t.waiting_content ~key:addr ~data:expected","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  (** Given an address and the accounts below that address, fill in the tree","counters":[]},{"line":"      with them. *)","counters":[]},{"line":"  let add_content :","counters":[]},{"line":"         'a t","counters":[]},{"line":"      -> Addr.t","counters":[]},{"line":"      -> Account.t list","counters":[]},{"line":"      -> [ `Success","counters":[]},{"line":"         | `Hash_mismatch of Hash.t * Hash.t  (** expected hash, actual *) ] =","counters":[]},{"line":"   fun t addr content ->","counters":[]},{"line":"    let expected = Addr.Table.find_exn t.waiting_content addr in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    (* TODO #444 should we batch all the updates and do them at the end? *)","counters":[]},{"line":"    (* We might write the wrong data to the underlying ledger here, but if so","counters":[]},{"line":"       we'll requeue the address and it'll be overwritten. *)","counters":[]},{"line":"    MT.set_all_accounts_rooted_at_exn t.tree addr content ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Addr.Table.remove t.waiting_content addr ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let actual = MT.get_inner_hash_at_addr_exn t.tree addr in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    if Hash.equal actual expected then `Success","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"    else `Hash_mismatch (expected, actual)","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"  (** Given an address and the hashes of the children of the corresponding node,","counters":[]},{"line":"      check the children hash to the expected value. If they do, queue the","counters":[]},{"line":"      children for retrieval if the values in the underlying ledger don't match","counters":[]},{"line":"      the hashes we got from the network. *)","counters":[]},{"line":"  let add_child_hashes_to :","counters":[]},{"line":"         'a t","counters":[]},{"line":"      -> Addr.t","counters":[]},{"line":"      -> Hash.t","counters":[]},{"line":"      -> Hash.t","counters":[]},{"line":"      -> [ `Good of (Addr.t * Hash.t) list","counters":[]},{"line":"           (** The addresses and expected hashes of the now-retrievable children *)","counters":[]},{"line":"         | `Hash_mismatch of Hash.t * Hash.t","counters":[]},{"line":"           (** Hash check failed, peer lied. First parameter expected, second parameter actual. *)","counters":[]},{"line":"         ] =","counters":[]},{"line":"   fun t parent_addr lh rh ->","counters":[]},{"line":"    let ledger_depth = MT.depth t.tree in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let la, ra =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Option.value_exn ~message:\"Tried to fetch a leaf as if it was a node\"","counters":[]},{"line":"        ( Or_error.ok","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"        @@ Or_error.both","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"             (Addr.child ~ledger_depth parent_addr Direction.Left)","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"             (Addr.child ~ledger_depth parent_addr Direction.Right) )","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"    in","counters":[]},{"line":"    let expected =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Option.value_exn ~message:\"Forgot to wait for a node\"","counters":[]},{"line":"        (Addr.Table.find t.waiting_parents parent_addr)","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"    in","counters":[]},{"line":"    let merged_hash =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (* Height here is the height of the things we're merging, so one less than","counters":[]},{"line":"         the parent height. *)","counters":[]},{"line":"      Hash.merge ~height:(ledger_depth - Addr.depth parent_addr - 1) lh rh","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"    in","counters":[]},{"line":"    if Hash.equal merged_hash expected then (","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"      (* Fetch the children of a node if the hash in the underlying ledger","counters":[]},{"line":"         doesn't match what we got. *)","counters":[]},{"line":"      let should_fetch_children addr hash =","counters":[]},{"line":"        not @@ Hash.equal (MT.get_inner_hash_at_addr_exn t.tree addr) hash","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"      in","counters":[]},{"line":"      let subtrees_to_fetch =","counters":[]},{"line":"        [ (la, lh); (ra, rh) ]","counters":[]},{"line":"        |> List.filter ~f:(Tuple2.uncurry should_fetch_children)","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"      in","counters":[]},{"line":"      Addr.Table.remove t.waiting_parents parent_addr ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      `Good subtrees_to_fetch )","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    else `Hash_mismatch (expected, merged_hash)","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"  let all_done t =","counters":[]},{"line":"    if not (Root_hash.equal (MT.merkle_root t.tree) (desired_root_exn t)) then","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":42,"col_end":42,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"      failwith \"We finished syncing, but made a mistake somewhere :(\"","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    else (","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"      if Ivar.is_full t.validity_listener then","counters":[]},{"line":"        [%log' error t.logger] \"Ivar.fill bug is here GGG !\" ;","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"      Ivar.fill t.validity_listener `Ok )","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"  (** Compute the hash of an empty tree of the specified height. *)","counters":[]},{"line":"  let empty_hash_at_height h =","counters":[]},{"line":"    let rec go prev ctr =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      if ctr = h then prev else go (Hash.merge ~height:ctr prev prev) (ctr + 1)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"    in","counters":[]},{"line":"    go Hash.empty_account 0","counters":[]},{"line":"","counters":[]},{"line":"  (** Given the hash of the smallest subtree that contains all accounts, the","counters":[]},{"line":"      height of that hash in the tree and the height of the whole tree, compute","counters":[]},{"line":"      the hash of the whole tree. *)","counters":[]},{"line":"  let complete_with_empties hash start_height result_height =","counters":[]},{"line":"    let rec go cur_empty prev_hash height =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      if height = result_height then prev_hash","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"      else","counters":[]},{"line":"        let cur = Hash.merge ~height prev_hash cur_empty in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let next_empty = Hash.merge ~height cur_empty cur_empty in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        go next_empty cur (height + 1)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    in","counters":[]},{"line":"    go (empty_hash_at_height start_height) hash start_height","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"","counters":[]},{"line":"  (** Given an address and the hash of the corresponding subtree, start getting","counters":[]},{"line":"      the children.","counters":[]},{"line":"  *)","counters":[]},{"line":"  let handle_node t addr exp_hash =","counters":[]},{"line":"    if Addr.depth addr >= MT.depth t.tree - account_subtree_height then (","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":72,"col_end":72,"count":0}]},{"line":"      expect_content t addr exp_hash ;","counters":[]},{"line":"      Linear_pipe.write_without_pushback_if_open t.queries","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (desired_root_exn t, What_contents addr) )","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"    else (","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"      expect_children t addr exp_hash ;","counters":[]},{"line":"      Linear_pipe.write_without_pushback_if_open t.queries","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (desired_root_exn t, What_child_hashes addr) )","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"","counters":[]},{"line":"  (** Handle the initial Num_accounts message, starting the main syncing","counters":[]},{"line":"      process. *)","counters":[]},{"line":"  let handle_num_accounts :","counters":[]},{"line":"      'a t -> int -> Hash.t -> [ `Success | `Hash_mismatch of Hash.t * Hash.t ]","counters":[]},{"line":"      =","counters":[]},{"line":"   fun t n content_hash ->","counters":[]},{"line":"    let rh = Root_hash.to_hash (desired_root_exn t) in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"    let height = Int.ceil_log2 n in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    (* FIXME: bug when height=0 https://github.com/o1-labs/nanobit/issues/365 *)","counters":[]},{"line":"    let actual = complete_with_empties content_hash height (MT.depth t.tree) in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"    if Hash.equal actual rh then (","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"      MT.make_space_for t.tree n ;","counters":[]},{"line":"      Addr.Table.clear t.waiting_parents ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      (* We should use this information to set the empty account slots empty and","counters":[]},{"line":"         start syncing at the content root. See #1972. *)","counters":[]},{"line":"      Addr.Table.clear t.waiting_content ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      handle_node t (Addr.root ()) rh ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"      `Success )","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    else `Hash_mismatch (rh, actual)","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"  let main_loop t =","counters":[]},{"line":"    let handle_answer :","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"           Root_hash.t","counters":[]},{"line":"           * Addr.t Query.t","counters":[]},{"line":"           * (Hash.t, Account.t) Answer.t Envelope.Incoming.t","counters":[]},{"line":"        -> unit Deferred.t =","counters":[]},{"line":"     fun (root_hash, query, env) ->","counters":[]},{"line":"      (* NOTE: think about synchronization here. This is deferred now, so","counters":[]},{"line":"          the t and the underlying ledger can change while processing is","counters":[]},{"line":"          happening. *)","counters":[]},{"line":"      let already_done =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        match Ivar.peek t.validity_listener with Some `Ok -> true | _ -> false","counters":[{"col_start":49,"col_end":49,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"      in","counters":[]},{"line":"      let sender = Envelope.Incoming.sender env in","counters":[]},{"line":"      let answer = Envelope.Incoming.data env in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      [%log' trace t.logger]","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"        ~metadata:","counters":[]},{"line":"          [ (\"root_hash\", Root_hash.to_yojson root_hash)","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"          ; (\"query\", Query.to_yojson Addr.to_yojson query)","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"          ]","counters":[]},{"line":"        \"Handle answer for $root_hash\" ;","counters":[]},{"line":"      if not (Root_hash.equal root_hash (desired_root_exn t)) then (","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":56,"col_end":56,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"        [%log' trace t.logger]","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"          ~metadata:","counters":[]},{"line":"            [ (\"desired_hash\", Root_hash.to_yojson (desired_root_exn t))","counters":[{"col_start":49,"col_end":49,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"            ; (\"ignored_hash\", Root_hash.to_yojson root_hash)","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"            ]","counters":[]},{"line":"          \"My desired root was $desired_hash, so I'm ignoring $ignored_hash\" ;","counters":[]},{"line":"        Deferred.unit )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      else if already_done then (","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"        (* This can happen if we asked for hashes that turn out to be equal in","counters":[]},{"line":"           underlying ledger and the target. *)","counters":[]},{"line":"        [%log' debug t.logger]","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"          \"Got sync response when we're already finished syncing\" ;","counters":[]},{"line":"        Deferred.unit )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      else","counters":[]},{"line":"        let open Trust_system in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        (* If a peer misbehaves we still need the information we asked them for,","counters":[]},{"line":"           so requeue in that case. *)","counters":[]},{"line":"        let requeue_query () =","counters":[]},{"line":"          Linear_pipe.write_without_pushback_if_open t.queries (root_hash, query)","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        in","counters":[]},{"line":"        let credit_fulfilled_request () =","counters":[]},{"line":"          record_envelope_sender t.trust_system t.logger sender","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ( Actions.Fulfilled_request","counters":[]},{"line":"            , Some","counters":[]},{"line":"                ( \"sync ledger query $query\"","counters":[]},{"line":"                , [ (\"query\", Query.to_yojson Addr.to_yojson query) ] ) )","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"        in","counters":[]},{"line":"        let%bind _ =","counters":[]},{"line":"          match (query, answer) with","counters":[]},{"line":"          | Query.What_child_hashes addr, Answer.Child_hashes_are (lh, rh) -> (","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              match add_child_hashes_to t addr lh rh with","counters":[]},{"line":"              | `Hash_mismatch (expected, actual) ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  let%map () =","counters":[]},{"line":"                    record_envelope_sender t.trust_system t.logger sender","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"                      ( Actions.Sent_bad_hash","counters":[]},{"line":"                      , Some","counters":[]},{"line":"                          ( \"sent child hashes $lhash and $rhash for address \\","counters":[]},{"line":"                             $addr, they merge hash to $actualmerge but we \\","counters":[]},{"line":"                             expected $expectedmerge\"","counters":[]},{"line":"                          , [ (\"lhash\", Hash.to_yojson lh)","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"                            ; (\"rhash\", Hash.to_yojson rh)","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"                            ; (\"actualmerge\", Hash.to_yojson actual)","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"                            ; (\"expectedmerge\", Hash.to_yojson expected)","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"                            ] ) )","counters":[]},{"line":"                  in","counters":[]},{"line":"                  requeue_query ()","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"              | `Good children_to_verify ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  (* TODO #312: Make sure we don't write too much *)","counters":[]},{"line":"                  List.iter children_to_verify ~f:(fun (addr, hash) ->","counters":[]},{"line":"                      handle_node t addr hash ) ;","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                  credit_fulfilled_request () )","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"          | Query.What_contents addr, Answer.Contents_are leaves -> (","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              match add_content t addr leaves with","counters":[]},{"line":"              | `Success ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  credit_fulfilled_request ()","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"              | `Hash_mismatch (expected, actual) ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  let%map () =","counters":[]},{"line":"                    record_envelope_sender t.trust_system t.logger sender","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"                      ( Actions.Sent_bad_hash","counters":[]},{"line":"                      , Some","counters":[]},{"line":"                          ( \"sent accounts $accounts for address $addr, they \\","counters":[]},{"line":"                             hash to $actual but we expected $expected\"","counters":[]},{"line":"                          , [ ( \"accounts\"","counters":[]},{"line":"                              , `List (List.map ~f:Account.to_yojson leaves) )","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"                            ; (\"addr\", Addr.to_yojson addr)","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"                            ; (\"actual\", Hash.to_yojson actual)","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"                            ; (\"expected\", Hash.to_yojson expected)","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"                            ] ) )","counters":[]},{"line":"                  in","counters":[]},{"line":"                  requeue_query () )","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"          | Query.Num_accounts, Answer.Num_accounts (count, content_root) -> (","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              match handle_num_accounts t count content_root with","counters":[]},{"line":"              | `Success ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  credit_fulfilled_request ()","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"              | `Hash_mismatch (expected, actual) ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  let%map () =","counters":[]},{"line":"                    record_envelope_sender t.trust_system t.logger sender","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"                      ( Actions.Sent_bad_hash","counters":[]},{"line":"                      , Some","counters":[]},{"line":"                          ( \"Claimed num_accounts $count, content root hash \\","counters":[]},{"line":"                             $content_root_hash, that implies a root hash of \\","counters":[]},{"line":"                             $actual, we expected $expected\"","counters":[]},{"line":"                          , [ (\"count\", `Int count)","counters":[]},{"line":"                            ; (\"content_root_hash\", Hash.to_yojson content_root)","counters":[{"col_start":65,"col_end":65,"count":0}]},{"line":"                            ; (\"actual\", Hash.to_yojson actual)","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"                            ; (\"expected\", Hash.to_yojson expected)","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"                            ] ) )","counters":[]},{"line":"                  in","counters":[]},{"line":"                  requeue_query () )","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"          | query, answer ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let%map () =","counters":[]},{"line":"                record_envelope_sender t.trust_system t.logger sender","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                  ( Actions.Violated_protocol","counters":[]},{"line":"                  , Some","counters":[]},{"line":"                      ( \"Answered question we didn't ask! Query was $query \\","counters":[]},{"line":"                         answer was $answer\"","counters":[]},{"line":"                      , [ (\"query\", Query.to_yojson Addr.to_yojson query)","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                        ; ( \"answer\"","counters":[]},{"line":"                          , Answer.to_yojson Hash.to_yojson Account.to_yojson","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"                              answer )","counters":[]},{"line":"                        ] ) )","counters":[]},{"line":"              in","counters":[]},{"line":"              requeue_query ()","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"        in","counters":[]},{"line":"        if","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Root_hash.equal","counters":[]},{"line":"            (Option.value_exn t.desired_root)","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"            (MT.merkle_root t.tree)","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"        then (","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"          [%str_log' trace t.logger] Snarked_ledger_synced ;","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"          all_done t ) ;","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"        Deferred.unit","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    in","counters":[]},{"line":"    Linear_pipe.iter t.answers ~f:handle_answer","counters":[]},{"line":"","counters":[]},{"line":"  let new_goal t h ~data ~equal =","counters":[]},{"line":"    let should_skip =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      match t.desired_root with","counters":[]},{"line":"      | None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          false","counters":[]},{"line":"      | Some h' ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Root_hash.equal h h'","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"    in","counters":[]},{"line":"    if not should_skip then (","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"      Option.iter t.desired_root ~f:(fun root_hash ->","counters":[]},{"line":"          [%log' debug t.logger]","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"            ~metadata:","counters":[]},{"line":"              [ (\"old_root_hash\", Root_hash.to_yojson root_hash)","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"              ; (\"new_root_hash\", Root_hash.to_yojson h)","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"              ]","counters":[]},{"line":"            \"New_goal: changing target from $old_root_hash to $new_root_hash\" ) ;","counters":[]},{"line":"      Ivar.fill_if_empty t.validity_listener","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (`Target_changed (t.desired_root, h)) ;","counters":[]},{"line":"      t.validity_listener <- Ivar.create () ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"      t.desired_root <- Some h ;","counters":[]},{"line":"      t.auxiliary_data <- Some data ;","counters":[]},{"line":"      Linear_pipe.write_without_pushback_if_open t.queries (h, Num_accounts) ;","counters":[]},{"line":"      `New )","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    else if","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"      Option.fold t.auxiliary_data ~init:false ~f:(fun _ saved_data ->","counters":[]},{"line":"          equal data saved_data )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    then (","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"      [%log' debug t.logger] \"New_goal to same hash, not doing anything\" ;","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"      `Repeat )","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    else (","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"      t.auxiliary_data <- Some data ;","counters":[]},{"line":"      `Update_data )","counters":[]},{"line":"","counters":[]},{"line":"  let rec valid_tree t =","counters":[]},{"line":"    match%bind Ivar.read t.validity_listener with","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"    | `Ok ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        return (t.tree, Option.value_exn t.auxiliary_data)","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"    | `Target_changed _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        valid_tree t","counters":[]},{"line":"","counters":[]},{"line":"  let peek_valid_tree t =","counters":[]},{"line":"    Option.bind (Ivar.peek t.validity_listener) ~f:(function","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"      | `Ok ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Some t.tree","counters":[]},{"line":"      | `Target_changed _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          None )","counters":[]},{"line":"","counters":[]},{"line":"  let wait_until_valid t h =","counters":[]},{"line":"    if not (Root_hash.equal h (desired_root_exn t)) then","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"      return (`Target_changed (t.desired_root, h))","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    else","counters":[]},{"line":"      Deferred.map (Ivar.read t.validity_listener) ~f:(function","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"        | `Target_changed payload ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            `Target_changed payload","counters":[]},{"line":"        | `Ok ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            `Ok t.tree )","counters":[]},{"line":"","counters":[]},{"line":"  let fetch t rh ~data ~equal =","counters":[]},{"line":"    ignore (new_goal t rh ~data ~equal : [ `New | `Repeat | `Update_data ]) ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"    wait_until_valid t rh","counters":[]},{"line":"","counters":[]},{"line":"  let create mt ~logger ~trust_system =","counters":[]},{"line":"    let qr, qw = Linear_pipe.create () in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let ar, aw = Linear_pipe.create () in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let t =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      { desired_root = None","counters":[]},{"line":"      ; auxiliary_data = None","counters":[]},{"line":"      ; tree = mt","counters":[]},{"line":"      ; logger","counters":[]},{"line":"      ; trust_system","counters":[]},{"line":"      ; answers = ar","counters":[]},{"line":"      ; answer_writer = aw","counters":[]},{"line":"      ; queries = qw","counters":[]},{"line":"      ; query_reader = qr","counters":[]},{"line":"      ; waiting_parents = Addr.Table.create ()","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"      ; waiting_content = Addr.Table.create ()","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"      ; validity_listener = Ivar.create ()","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"      }","counters":[]},{"line":"    in","counters":[]},{"line":"    don't_wait_for (main_loop t) ;","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"    t","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let apply_or_queue_diff _ _ =","counters":[]},{"line":"    (* Need some interface for the diffs, not sure the layering is right here. *)","counters":[]},{"line":"    failwith \"todo\"","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let merkle_path_at_addr _ = failwith \"no\"","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"","counters":[]},{"line":"  let get_account_at_addr _ = failwith \"no\"","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}