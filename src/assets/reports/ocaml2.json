{"filename":"src/lib/pickles/composition_types/branch_data.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Pickles_types","counters":[]},{"line":"","counters":[]},{"line":"(** See documentation of the {!Mina_wire_types} library *)","counters":[]},{"line":"module Wire_types = Mina_wire_types.Pickles_composition_types.Branch_data","counters":[]},{"line":"","counters":[]},{"line":"module Make_sig (A : Wire_types.Types.S) = struct","counters":[]},{"line":"  module type S =","counters":[]},{"line":"    Branch_data_intf.S","counters":[]},{"line":"      with type Domain_log2.Stable.V1.t = A.Domain_log2.V1.t","counters":[]},{"line":"       and type Stable.V1.t = A.V1.t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make_str (A : Wire_types.Concrete) = struct","counters":[]},{"line":"  (** Data specific to a branch of a proof-system that's necessary for","counters":[]},{"line":"    finalizing the deferred-values in a wrap proof of that branch. *)","counters":[]},{"line":"","counters":[]},{"line":"  module Proofs_verified = Pickles_base.Proofs_verified","counters":[]},{"line":"","counters":[]},{"line":"  module Domain_log2 = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type t = char [@@deriving compare, sexp, yojson, hash, equal]","counters":[{"col_start":8,"col_end":8,"count":2},{"col_start":13,"col_end":13,"count":1},{"col_start":17,"col_end":17,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":68,"col_end":68,"count":5}]},{"line":"","counters":[]},{"line":"        let to_latest = Fn.id","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    let of_int_exn : int -> t = Char.of_int_exn","counters":[]},{"line":"","counters":[]},{"line":"    let of_bits_msb (bs : bool list) : t =","counters":[]},{"line":"      List.fold bs ~init:0 ~f:(fun acc b ->","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":14,"col_end":14,"count":0}]},{"line":"          let acc = acc lsl 1 in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          if b then acc + 1 else acc )","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"      |> of_int_exn","counters":[]},{"line":"","counters":[]},{"line":"    let of_field_exn (type f)","counters":[]},{"line":"        (module Impl : Snarky_backendless.Snark_intf.Run with type field = f)","counters":[]},{"line":"        (x : f) : t =","counters":[]},{"line":"      Impl.Field.Constant.unpack x","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"      |> Fn.flip List.take 8 |> List.rev |> of_bits_msb","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  (* We pack this into a single field element as follows:","counters":[]},{"line":"     First 2 bits: proofs_verified","counters":[]},{"line":"     Next 8 bits: domain_log2 *)","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type t = A.V1.t =","counters":[{"col_start":6,"col_end":6,"count":8},{"col_start":11,"col_end":11,"count":2}]},{"line":"        { proofs_verified : Proofs_verified.Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"        ; domain_log2 : Domain_log2.Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"        }","counters":[]},{"line":"      [@@deriving hlist, compare, sexp, yojson, hash, equal]","counters":[{"col_start":59,"col_end":59,"count":5}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  let length_in_bits = 10","counters":[]},{"line":"","counters":[]},{"line":"  let pack (type f)","counters":[]},{"line":"      (module Impl : Snarky_backendless.Snark_intf.Run with type field = f)","counters":[]},{"line":"      ({ proofs_verified; domain_log2 } : t) : f =","counters":[]},{"line":"    let open Impl.Field.Constant in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let double x = x + x in","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"    let times4 x = double (double x) in","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"    let domain_log2 = of_int (Char.to_int domain_log2) in","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"    (* shift domain_log2 over by 2 bits (multiply by 4) *)","counters":[]},{"line":"    times4 domain_log2","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":9,"col_end":9,"count":0}]},{"line":"    + project","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"        (Pickles_types.Vector.to_list","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"           (Proofs_verified.Prefix_mask.there proofs_verified) )","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"  let unpack (type f)","counters":[]},{"line":"      (module Impl : Snarky_backendless.Snark_intf.Run with type field = f)","counters":[]},{"line":"      (x : f) : t =","counters":[]},{"line":"    match Impl.Field.Constant.unpack x with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | x0 :: x1 :: y0 :: y1 :: y2 :: y3 :: y4 :: y5 :: y6 :: y7 :: _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { proofs_verified = Proofs_verified.Prefix_mask.back [ x0; x1 ]","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"        ; domain_log2 =","counters":[]},{"line":"            Domain_log2.of_bits_msb [ y7; y6; y5; y4; y3; y2; y1; y0 ]","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"        }","counters":[]},{"line":"    | _ ->","counters":[]},{"line":"        assert false","counters":[]},{"line":"","counters":[]},{"line":"  module Checked = struct","counters":[]},{"line":"    type 'f t =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      { proofs_verified_mask : 'f Proofs_verified.Prefix_mask.Checked.t","counters":[]},{"line":"      ; domain_log2 : 'f Snarky_backendless.Cvar.t","counters":[]},{"line":"      }","counters":[]},{"line":"    [@@deriving hlist]","counters":[]},{"line":"","counters":[]},{"line":"    let pack (type f)","counters":[]},{"line":"        (module Impl : Snarky_backendless.Snark_intf.Run with type field = f)","counters":[]},{"line":"        ({ proofs_verified_mask; domain_log2 } : f t) : Impl.Field.t =","counters":[]},{"line":"      let open Impl.Field in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let four = of_int 4 in","counters":[]},{"line":"      (four * domain_log2)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      + pack (Pickles_types.Vector.to_list proofs_verified_mask)","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let packed_typ (type f)","counters":[]},{"line":"      (module Impl : Snarky_backendless.Snark_intf.Run with type field = f) =","counters":[]},{"line":"    Impl.Typ.transport Impl.Typ.field","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ~there:(pack (module Impl))","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"      ~back:(unpack (module Impl))","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"","counters":[]},{"line":"  let typ (type f)","counters":[]},{"line":"      (module Impl : Snarky_backendless.Snark_intf.Run with type field = f)","counters":[]},{"line":"      ~(* We actually only need it to be less than 252 bits in order to pack","counters":[]},{"line":"          the whole branch_data struct safely, but it's cheapest to check that it's","counters":[]},{"line":"          under 16 bits *)","counters":[]},{"line":"      (assert_16_bits : Impl.Field.t -> unit) : (f Checked.t, t) Impl.Typ.t =","counters":[]},{"line":"    let open Impl in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let proofs_verified_mask :","counters":[]},{"line":"        (f Proofs_verified.Prefix_mask.Checked.t, Proofs_verified.t) Typ.t =","counters":[]},{"line":"      Proofs_verified.Prefix_mask.typ (module Impl)","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"    in","counters":[]},{"line":"    let domain_log2 : (Field.t, Domain_log2.t) Typ.t =","counters":[]},{"line":"      let (Typ t) =","counters":[]},{"line":"        Typ.transport Field.typ","counters":[]},{"line":"          ~there:(fun (x : char) -> Field.Constant.of_int (Char.to_int x))","counters":[{"col_start":36,"col_end":36,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"          ~back:(Domain_log2.of_field_exn (module Impl))","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"      in","counters":[]},{"line":"      let check (x : Field.t) = make_checked_ast (fun () -> assert_16_bits x) in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"      Typ { t with check }","counters":[]},{"line":"    in","counters":[]},{"line":"    Typ.of_hlistable","counters":[]},{"line":"      [ proofs_verified_mask; domain_log2 ]","counters":[]},{"line":"      ~value_of_hlist:of_hlist ~value_to_hlist:to_hlist","counters":[]},{"line":"      ~var_to_hlist:Checked.to_hlist ~var_of_hlist:Checked.of_hlist","counters":[]},{"line":"","counters":[]},{"line":"  let domain { domain_log2; _ } =","counters":[]},{"line":"    Pickles_base.Domain.Pow_2_roots_of_unity (Char.to_int domain_log2)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"include Wire_types.Make (Make_sig) (Make_str)","counters":[{"col_start":44,"col_end":44,"count":2}]}]}