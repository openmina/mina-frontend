{"filename":"src/lib/mina_base/zkapp_command.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Signature_lib","counters":[]},{"line":"","counters":[]},{"line":"let add_caller (p : Account_update.Wire.t) caller : Account_update.t =","counters":[]},{"line":"  let add_caller_body (p : Account_update.Body.Wire.t) caller :","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      Account_update.Body.t =","counters":[]},{"line":"    { public_key = p.public_key","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    ; token_id = p.token_id","counters":[]},{"line":"    ; update = p.update","counters":[]},{"line":"    ; balance_change = p.balance_change","counters":[]},{"line":"    ; increment_nonce = p.increment_nonce","counters":[]},{"line":"    ; events = p.events","counters":[]},{"line":"    ; sequence_events = p.sequence_events","counters":[]},{"line":"    ; call_data = p.call_data","counters":[]},{"line":"    ; preconditions = p.preconditions","counters":[]},{"line":"    ; use_full_commitment = p.use_full_commitment","counters":[]},{"line":"    ; caller","counters":[]},{"line":"    ; authorization_kind = p.authorization_kind","counters":[]},{"line":"    }","counters":[]},{"line":"  in","counters":[]},{"line":"  { body = add_caller_body p.body caller; authorization = p.authorization }","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"let add_caller_simple (p : Account_update.Simple.t) caller : Account_update.t =","counters":[]},{"line":"  let add_caller_body (p : Account_update.Body.Simple.t) caller :","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      Account_update.Body.t =","counters":[]},{"line":"    { public_key = p.public_key","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    ; token_id = p.token_id","counters":[]},{"line":"    ; update = p.update","counters":[]},{"line":"    ; balance_change = p.balance_change","counters":[]},{"line":"    ; increment_nonce = p.increment_nonce","counters":[]},{"line":"    ; events = p.events","counters":[]},{"line":"    ; sequence_events = p.sequence_events","counters":[]},{"line":"    ; call_data = p.call_data","counters":[]},{"line":"    ; preconditions = p.preconditions","counters":[]},{"line":"    ; use_full_commitment = p.use_full_commitment","counters":[]},{"line":"    ; caller","counters":[]},{"line":"    ; authorization_kind = p.authorization_kind","counters":[]},{"line":"    }","counters":[]},{"line":"  in","counters":[]},{"line":"  { body = add_caller_body p.body caller; authorization = p.authorization }","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"module Call_forest = struct","counters":[]},{"line":"  let empty = Outside_hash_image.t","counters":[]},{"line":"","counters":[]},{"line":"  module Tree = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type ('account_update, 'account_update_digest, 'digest) t =","counters":[{"col_start":8,"col_end":8,"count":1},{"col_start":64,"col_end":64,"count":6}]},{"line":"              ( 'account_update","counters":[]},{"line":"              , 'account_update_digest","counters":[]},{"line":"              , 'digest )","counters":[]},{"line":"              Mina_wire_types.Mina_base.Zkapp_command.Call_forest.Tree.V1.t =","counters":[]},{"line":"          { account_update : 'account_update","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"          ; account_update_digest : 'account_update_digest","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"          ; calls :","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":16,"col_end":16,"count":0}]},{"line":"              ( ('account_update, 'account_update_digest, 'digest) t","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":58,"col_end":58,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"              , 'digest )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"              With_stack_hash.Stable.V1.t","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              list","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"          }","counters":[]},{"line":"        [@@deriving sexp, compare, equal, hash, yojson]","counters":[{"col_start":54,"col_end":54,"count":3}]},{"line":"","counters":[]},{"line":"        let to_latest = Fn.id","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    let rec fold_forest (ts : (_ t, _) With_stack_hash.t list) ~f ~init =","counters":[]},{"line":"      List.fold ts ~init ~f:(fun acc { elt; stack_hash = _ } ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          fold elt ~init:acc ~f )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"    and fold { account_update; calls; account_update_digest = _ } ~f ~init =","counters":[]},{"line":"      fold_forest calls ~f ~init:(f init account_update)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"","counters":[]},{"line":"    let rec fold_forest2_exn (ts1 : (_ t, _) With_stack_hash.t list)","counters":[]},{"line":"        (ts2 : (_ t, _) With_stack_hash.t list) ~f ~init =","counters":[]},{"line":"      List.fold2_exn ts1 ts2 ~init","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ~f:(fun","counters":[]},{"line":"             acc","counters":[]},{"line":"             { elt = elt1; stack_hash = _ }","counters":[]},{"line":"             { elt = elt2; stack_hash = _ }","counters":[]},{"line":"           -> fold2_exn elt1 elt2 ~init:acc ~f )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"","counters":[]},{"line":"    and fold2_exn","counters":[]},{"line":"        { account_update = account_update1","counters":[]},{"line":"        ; calls = calls1","counters":[]},{"line":"        ; account_update_digest = _","counters":[]},{"line":"        }","counters":[]},{"line":"        { account_update = account_update2","counters":[]},{"line":"        ; calls = calls2","counters":[]},{"line":"        ; account_update_digest = _","counters":[]},{"line":"        } ~f ~init =","counters":[]},{"line":"      fold_forest2_exn calls1 calls2 ~f","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ~init:(f init account_update1 account_update2)","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"","counters":[]},{"line":"    let iter_forest2_exn ts1 ts2 ~f =","counters":[]},{"line":"      fold_forest2_exn ts1 ts2 ~init:() ~f:(fun () p1 p2 -> f p1 p2)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"","counters":[]},{"line":"    let iter2_exn ts1 ts2 ~f =","counters":[]},{"line":"      fold2_exn ts1 ts2 ~init:() ~f:(fun () p1 p2 -> f p1 p2)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"","counters":[]},{"line":"    let rec mapi_with_trees' ~i (t : _ t) ~f =","counters":[]},{"line":"      let l, calls = mapi_forest_with_trees' ~i:(i + 1) t.calls ~f in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      ( l","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      , { calls","counters":[]},{"line":"        ; account_update = f i t.account_update t","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"        ; account_update_digest = t.account_update_digest","counters":[]},{"line":"        } )","counters":[]},{"line":"","counters":[]},{"line":"    and mapi_forest_with_trees' ~i x ~f =","counters":[]},{"line":"      let rec go i acc = function","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        | [] ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (i, List.rev acc)","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"        | t :: ts ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let l, elt' = mapi_with_trees' ~i ~f (With_stack_hash.elt t) in","counters":[{"col_start":68,"col_end":68,"count":0}]},{"line":"            go l (With_stack_hash.map t ~f:(fun _ -> elt') :: acc) ts","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"      in","counters":[]},{"line":"      go i [] x","counters":[]},{"line":"","counters":[]},{"line":"    let mapi_with_trees t ~f = mapi_with_trees' ~i:0 t ~f |> snd","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"","counters":[]},{"line":"    let mapi_forest_with_trees t ~f = mapi_forest_with_trees' ~i:0 t ~f |> snd","counters":[{"col_start":38,"col_end":38,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"","counters":[]},{"line":"    let mapi' ~i t ~f =","counters":[]},{"line":"      mapi_with_trees' ~i t ~f:(fun i account_update _ -> f i account_update)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"","counters":[]},{"line":"    let mapi_forest' ~i t ~f =","counters":[]},{"line":"      mapi_forest_with_trees' ~i t ~f:(fun i account_update _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          f i account_update )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"    let rec deferred_mapi_with_trees' ~i (t : _ t) ~f =","counters":[]},{"line":"      let open Async_kernel.Deferred.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%bind l, calls =","counters":[]},{"line":"        deferred_mapi_forest_with_trees' ~i:(i + 1) t.calls ~f","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"      in","counters":[]},{"line":"      let%map account_update = f i t.account_update t in","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"      ( l","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      , { calls","counters":[]},{"line":"        ; account_update","counters":[]},{"line":"        ; account_update_digest = t.account_update_digest","counters":[]},{"line":"        } )","counters":[]},{"line":"","counters":[]},{"line":"    and deferred_mapi_forest_with_trees' ~i x ~f =","counters":[]},{"line":"      let open Async_kernel.Deferred.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let rec go i acc = function","counters":[]},{"line":"        | [] ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            return (i, List.rev acc)","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"        | t :: ts ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let%bind l, elt' =","counters":[]},{"line":"              deferred_mapi_with_trees' ~i ~f (With_stack_hash.elt t)","counters":[{"col_start":38,"col_end":38,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"            in","counters":[]},{"line":"            go l (With_stack_hash.map t ~f:(fun _ -> elt') :: acc) ts","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"      in","counters":[]},{"line":"      go i [] x","counters":[]},{"line":"","counters":[]},{"line":"    let map_forest ~f t = mapi_forest' ~i:0 ~f:(fun _ x -> f x) t |> snd","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"","counters":[]},{"line":"    let mapi_forest ~f t = mapi_forest' ~i:0 ~f t |> snd","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"","counters":[]},{"line":"    let deferred_map_forest ~f t =","counters":[]},{"line":"      let open Async_kernel.Deferred in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      deferred_mapi_forest_with_trees' ~i:0 ~f:(fun _ x -> f x) t >>| snd","counters":[{"col_start":37,"col_end":37,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"","counters":[]},{"line":"    let deferred_mapi_forest ~f t =","counters":[]},{"line":"      let open Async_kernel.Deferred in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      deferred_mapi_forest_with_trees' ~i:0 ~f t >>| snd","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"    let hash { account_update = _; calls; account_update_digest } =","counters":[]},{"line":"      let stack_hash =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        match calls with [] -> empty | e :: _ -> e.stack_hash","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"      in","counters":[]},{"line":"      Random_oracle.hash ~init:Hash_prefix_states.account_update_node","counters":[]},{"line":"        [| account_update_digest; stack_hash |]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  type ('a, 'b, 'c) tree = ('a, 'b, 'c) Tree.t","counters":[]},{"line":"","counters":[]},{"line":"  module type Digest_intf = sig","counters":[]},{"line":"    module Account_update : sig","counters":[]},{"line":"      include Digest_intf.S","counters":[]},{"line":"","counters":[]},{"line":"      module Checked : sig","counters":[]},{"line":"        include Digest_intf.S_checked","counters":[]},{"line":"","counters":[]},{"line":"        val create : Account_update.Checked.t -> t","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      include Digest_intf.S_aux with type t := t and type checked := Checked.t","counters":[]},{"line":"","counters":[]},{"line":"      val create : Account_update.t -> t","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module rec Forest : sig","counters":[]},{"line":"      include Digest_intf.S","counters":[]},{"line":"","counters":[]},{"line":"      module Checked : sig","counters":[]},{"line":"        include Digest_intf.S_checked","counters":[]},{"line":"","counters":[]},{"line":"        val cons : Tree.Checked.t -> t -> t","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      include Digest_intf.S_aux with type t := t and type checked := Checked.t","counters":[]},{"line":"","counters":[]},{"line":"      val empty : t","counters":[]},{"line":"","counters":[]},{"line":"      val cons : Tree.t -> Forest.t -> Forest.t","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    and Tree : sig","counters":[]},{"line":"      include Digest_intf.S","counters":[]},{"line":"","counters":[]},{"line":"      module Checked : sig","counters":[]},{"line":"        include Digest_intf.S_checked","counters":[]},{"line":"","counters":[]},{"line":"        val create :","counters":[]},{"line":"             account_update:Account_update.Checked.t","counters":[]},{"line":"          -> calls:Forest.Checked.t","counters":[]},{"line":"          -> Tree.Checked.t","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      include Digest_intf.S_aux with type t := t and type checked := Checked.t","counters":[]},{"line":"","counters":[]},{"line":"      val create : (_, Account_update.t, Forest.t) tree -> Tree.t","counters":[]},{"line":"    end","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Make_digest_sig","counters":[]},{"line":"      (T : Mina_wire_types.Mina_base.Zkapp_command.Digest_types.S) =","counters":[]},{"line":"  struct","counters":[]},{"line":"    module type S =","counters":[]},{"line":"      Digest_intf","counters":[]},{"line":"        with type Account_update.Stable.V1.t = T.Account_update.V1.t","counters":[]},{"line":"         and type Forest.Stable.V1.t = T.Forest.V1.t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Make_digest_str","counters":[]},{"line":"      (T : Mina_wire_types.Mina_base.Zkapp_command.Digest_concrete) :","counters":[]},{"line":"    Make_digest_sig(T).S = struct","counters":[]},{"line":"    module M = struct","counters":[]},{"line":"      open Pickles.Impls.Step.Field","counters":[]},{"line":"      module Checked = Pickles.Impls.Step.Field","counters":[]},{"line":"","counters":[]},{"line":"      let typ = typ","counters":[]},{"line":"","counters":[]},{"line":"      let constant = constant","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Account_update = struct","counters":[]},{"line":"      [%%versioned","counters":[]},{"line":"      module Stable = struct","counters":[]},{"line":"        module V1 = struct","counters":[]},{"line":"          type t = Kimchi_backend.Pasta.Basic.Fp.Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":2},{"col_start":15,"col_end":15,"count":1},{"col_start":19,"col_end":19,"count":0}]},{"line":"          [@@deriving sexp, compare, equal, hash, yojson]","counters":[{"col_start":56,"col_end":56,"count":5}]},{"line":"","counters":[]},{"line":"          let to_latest = Fn.id","counters":[]},{"line":"        end","counters":[]},{"line":"      end]","counters":[]},{"line":"","counters":[]},{"line":"      include M","counters":[]},{"line":"","counters":[]},{"line":"      module Checked = struct","counters":[]},{"line":"        include Checked","counters":[]},{"line":"","counters":[]},{"line":"        let create = Account_update.Checked.digest","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      let create : Account_update.t -> t = Account_update.digest","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Forest = struct","counters":[]},{"line":"      [%%versioned","counters":[]},{"line":"      module Stable = struct","counters":[]},{"line":"        module V1 = struct","counters":[]},{"line":"          type t = Kimchi_backend.Pasta.Basic.Fp.Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":2},{"col_start":15,"col_end":15,"count":1},{"col_start":19,"col_end":19,"count":0}]},{"line":"          [@@deriving sexp, compare, equal, hash, yojson]","counters":[{"col_start":56,"col_end":56,"count":5}]},{"line":"","counters":[]},{"line":"          let to_latest = Fn.id","counters":[]},{"line":"        end","counters":[]},{"line":"      end]","counters":[]},{"line":"","counters":[]},{"line":"      include M","counters":[]},{"line":"","counters":[]},{"line":"      module Checked = struct","counters":[]},{"line":"        include Checked","counters":[]},{"line":"","counters":[]},{"line":"        let cons hash h_tl =","counters":[]},{"line":"          Random_oracle.Checked.hash","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ~init:Hash_prefix_states.account_update_cons [| hash; h_tl |]","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      let empty = empty","counters":[]},{"line":"","counters":[]},{"line":"      let cons hash h_tl =","counters":[]},{"line":"        Random_oracle.hash ~init:Hash_prefix_states.account_update_cons","counters":[{"col_start":8,"col_end":8,"count":1}]},{"line":"          [| hash; h_tl |]","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Tree = struct","counters":[]},{"line":"      [%%versioned","counters":[]},{"line":"      module Stable = struct","counters":[]},{"line":"        module V1 = struct","counters":[]},{"line":"          type t = Kimchi_backend.Pasta.Basic.Fp.Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":2},{"col_start":15,"col_end":15,"count":1},{"col_start":19,"col_end":19,"count":0}]},{"line":"          [@@deriving sexp, compare, equal, hash, yojson]","counters":[{"col_start":56,"col_end":56,"count":5}]},{"line":"","counters":[]},{"line":"          let to_latest = Fn.id","counters":[]},{"line":"        end","counters":[]},{"line":"      end]","counters":[]},{"line":"","counters":[]},{"line":"      include M","counters":[]},{"line":"","counters":[]},{"line":"      module Checked = struct","counters":[]},{"line":"        include Checked","counters":[]},{"line":"","counters":[]},{"line":"        let create ~(account_update : Account_update.Checked.t)","counters":[]},{"line":"            ~(calls : Forest.Checked.t) =","counters":[]},{"line":"          Random_oracle.Checked.hash","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ~init:Hash_prefix_states.account_update_node","counters":[]},{"line":"            [| (account_update :> t); (calls :> t) |]","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      let create ({ account_update = _; calls; account_update_digest } : _ tree)","counters":[]},{"line":"          =","counters":[]},{"line":"        let stack_hash =","counters":[{"col_start":8,"col_end":8,"count":1}]},{"line":"          match calls with [] -> empty | e :: _ -> e.stack_hash","counters":[{"col_start":27,"col_end":27,"count":1},{"col_start":41,"col_end":41,"count":0}]},{"line":"        in","counters":[]},{"line":"        Random_oracle.hash ~init:Hash_prefix_states.account_update_node","counters":[]},{"line":"          [| account_update_digest; stack_hash |]","counters":[]},{"line":"    end","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Digest =","counters":[]},{"line":"    Mina_wire_types.Mina_base.Zkapp_command.Digest_make","counters":[]},{"line":"      (Make_digest_sig)","counters":[]},{"line":"      (Make_digest_str)","counters":[]},{"line":"","counters":[]},{"line":"  let fold = Tree.fold_forest","counters":[]},{"line":"","counters":[]},{"line":"  let iteri t ~(f : int -> 'a -> unit) : unit =","counters":[]},{"line":"    let (_ : int) = fold t ~init:0 ~f:(fun acc x -> f acc x ; acc + 1) in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":52,"col_end":52,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"    ()","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type ('account_update, 'account_update_digest, 'digest) t =","counters":[{"col_start":6,"col_end":6,"count":3},{"col_start":12,"col_end":12,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":53,"col_end":53,"count":0},{"col_start":62,"col_end":62,"count":5}]},{"line":"        ( ('account_update, 'account_update_digest, 'digest) Tree.Stable.V1.t","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":10,"col_end":10,"count":0},{"col_start":11,"col_end":11,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":52,"col_end":52,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"        , 'digest )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        With_stack_hash.Stable.V1.t","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        list","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":11,"col_end":11,"count":0}]},{"line":"      [@@deriving sexp, compare, equal, hash, yojson]","counters":[{"col_start":52,"col_end":52,"count":7}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  module Shape = struct","counters":[]},{"line":"    module I = struct","counters":[]},{"line":"      type t = int","counters":[]},{"line":"","counters":[]},{"line":"      let quickcheck_shrinker = Quickcheck.Shrinker.empty ()","counters":[{"col_start":56,"col_end":56,"count":1}]},{"line":"","counters":[]},{"line":"      let quickcheck_generator = [%quickcheck.generator: int]","counters":[]},{"line":"","counters":[]},{"line":"      let quickcheck_observer = [%quickcheck.observer: int]","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    type t = Node of (I.t * t) list [@@deriving quickcheck]","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":58,"col_end":58,"count":3}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let rec shape (t : _ t) : Shape.t =","counters":[]},{"line":"    Node (List.mapi t ~f:(fun i { elt; stack_hash = _ } -> (i, shape elt.calls)))","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":59,"col_end":59,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"","counters":[]},{"line":"  let match_up (type a b) (xs : a list) (ys : (int * b) list) : (a * b) list =","counters":[]},{"line":"    let rec go i_curr xs ys =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      match (xs, ys) with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | [], [] ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          []","counters":[]},{"line":"      | x :: xs', (i, y) :: ys' ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          if i_curr = i then (x, y) :: go (i_curr + 1) xs' ys'","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"          else if i_curr < i then go (i_curr + 1) xs' ys'","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"          else assert false","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"      | [], _ :: _ ->","counters":[]},{"line":"          assert false","counters":[]},{"line":"      | _ :: _, [] ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          []","counters":[]},{"line":"    in","counters":[]},{"line":"    go 0 xs ys","counters":[]},{"line":"","counters":[]},{"line":"  let rec mask (t : ('p, 'h1, unit) t) (Node shape : Shape.t) :","counters":[]},{"line":"      ('p, 'h1, unit) t =","counters":[]},{"line":"    List.map (match_up t shape)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"      ~f:(fun ({ With_stack_hash.elt = t_sub; stack_hash = () }, shape_sub) ->","counters":[]},{"line":"        { With_stack_hash.elt =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            { t_sub with calls = mask t_sub.calls shape_sub }","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"        ; stack_hash = ()","counters":[]},{"line":"        } )","counters":[]},{"line":"","counters":[]},{"line":"  let rec of_account_updates_map ~(f : 'p1 -> 'p2)","counters":[]},{"line":"      ~(account_update_depth : 'p1 -> int) (account_updates : 'p1 list) :","counters":[]},{"line":"      ('p2, unit, unit) t =","counters":[]},{"line":"    match account_updates with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | [] ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        []","counters":[]},{"line":"    | p :: ps ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let depth = account_update_depth p in","counters":[]},{"line":"        let children, siblings =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          List.split_while ps ~f:(fun p' -> account_update_depth p' > depth)","counters":[{"col_start":44,"col_end":44,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"        in","counters":[]},{"line":"        { With_stack_hash.elt =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            { Tree.account_update = f p","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"            ; account_update_digest = ()","counters":[]},{"line":"            ; calls = of_account_updates_map ~f ~account_update_depth children","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"            }","counters":[]},{"line":"        ; stack_hash = ()","counters":[]},{"line":"        }","counters":[]},{"line":"        :: of_account_updates_map ~f ~account_update_depth siblings","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"","counters":[]},{"line":"  let of_account_updates ~account_update_depth account_updates =","counters":[]},{"line":"    of_account_updates_map ~f:Fn.id ~account_update_depth account_updates","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let to_account_updates_map ~f (xs : _ t) =","counters":[]},{"line":"    let rec collect depth (xs : _ t) acc =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      match xs with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | [] ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          acc","counters":[]},{"line":"      | { elt = { account_update; calls; account_update_digest = _ }","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        ; stack_hash = _","counters":[]},{"line":"        }","counters":[]},{"line":"        :: xs ->","counters":[]},{"line":"          f ~depth account_update :: acc","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          |> collect (depth + 1) calls","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"          |> collect depth xs","counters":[]},{"line":"    in","counters":[]},{"line":"    List.rev (collect 0 xs [])","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"","counters":[]},{"line":"  let to_account_updates xs =","counters":[]},{"line":"    to_account_updates_map ~f:(fun ~depth:_ account_update -> account_update) xs","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"","counters":[]},{"line":"  let hd_account_update (xs : _ t) =","counters":[]},{"line":"    match xs with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | [] ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        None","counters":[]},{"line":"    | { elt = { account_update; calls = _; account_update_digest = _ }","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      ; stack_hash = _","counters":[]},{"line":"      }","counters":[]},{"line":"      :: _ ->","counters":[]},{"line":"        Some account_update","counters":[]},{"line":"","counters":[]},{"line":"  let map = Tree.map_forest","counters":[]},{"line":"","counters":[]},{"line":"  let mapi = Tree.mapi_forest","counters":[]},{"line":"","counters":[]},{"line":"  let mapi_with_trees = Tree.mapi_forest_with_trees","counters":[]},{"line":"","counters":[]},{"line":"  let deferred_mapi = Tree.deferred_mapi_forest","counters":[]},{"line":"","counters":[]},{"line":"  let%test_unit \"Account_update_or_stack.of_zkapp_command_list\" =","counters":[]},{"line":"    let zkapp_command_list_1 = [ 0; 0; 0; 0 ] in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let node i calls =","counters":[]},{"line":"      { With_stack_hash.elt =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          { Tree.calls; account_update = i; account_update_digest = () }","counters":[]},{"line":"      ; stack_hash = ()","counters":[]},{"line":"      }","counters":[]},{"line":"    in","counters":[]},{"line":"    let zkapp_command_list_1_res : (int, unit, unit) t =","counters":[]},{"line":"      let n0 = node 0 [] in","counters":[]},{"line":"      [ n0; n0; n0; n0 ]","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    in","counters":[]},{"line":"    let f_index = mapi ~f:(fun i _p -> i) in","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"    [%test_eq: (int, unit, unit) t]","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"      (of_account_updates ~account_update_depth:Fn.id zkapp_command_list_1)","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"      zkapp_command_list_1_res ;","counters":[]},{"line":"    let zkapp_command_list1_index : (int, unit, unit) t =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let n i = node i [] in","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"      [ n 0; n 1; n 2; n 3 ]","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"    in","counters":[]},{"line":"    [%test_eq: (int, unit, unit) t]","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"      ( of_account_updates ~account_update_depth:Fn.id zkapp_command_list_1","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"      |> f_index )","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"      zkapp_command_list1_index ;","counters":[]},{"line":"    [%test_eq: int list]","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"      (to_account_updates","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"         (of_account_updates ~account_update_depth:Fn.id zkapp_command_list_1) )","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"      zkapp_command_list_1 ;","counters":[]},{"line":"    let zkapp_command_list_2 = [ 0; 0; 1; 1 ] in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let zkapp_command_list_2_res =","counters":[]},{"line":"      [ node 0 []; node 0 [ node 1 []; node 1 [] ] ]","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"    in","counters":[]},{"line":"    let zkapp_command_list_2_index =","counters":[]},{"line":"      [ node 0 []; node 1 [ node 2 []; node 3 [] ] ]","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"    in","counters":[]},{"line":"    [%test_eq: (int, unit, unit) t]","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"      (of_account_updates ~account_update_depth:Fn.id zkapp_command_list_2)","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"      zkapp_command_list_2_res ;","counters":[]},{"line":"    [%test_eq: (int, unit, unit) t]","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"      ( of_account_updates ~account_update_depth:Fn.id zkapp_command_list_2","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"      |> f_index )","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"      zkapp_command_list_2_index ;","counters":[]},{"line":"    [%test_eq: int list]","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"      (to_account_updates","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"         (of_account_updates ~account_update_depth:Fn.id zkapp_command_list_2) )","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"      zkapp_command_list_2 ;","counters":[]},{"line":"    let zkapp_command_list_3 = [ 0; 0; 1; 0 ] in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let zkapp_command_list_3_res =","counters":[]},{"line":"      [ node 0 []; node 0 [ node 1 [] ]; node 0 [] ]","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"    in","counters":[]},{"line":"    let zkapp_command_list_3_index =","counters":[]},{"line":"      [ node 0 []; node 1 [ node 2 [] ]; node 3 [] ]","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"    in","counters":[]},{"line":"    [%test_eq: (int, unit, unit) t]","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"      (of_account_updates ~account_update_depth:Fn.id zkapp_command_list_3)","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"      zkapp_command_list_3_res ;","counters":[]},{"line":"    [%test_eq: (int, unit, unit) t]","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"      ( of_account_updates ~account_update_depth:Fn.id zkapp_command_list_3","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"      |> f_index )","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"      zkapp_command_list_3_index ;","counters":[]},{"line":"    [%test_eq: int list]","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"      (to_account_updates","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"         (of_account_updates ~account_update_depth:Fn.id zkapp_command_list_3) )","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"      zkapp_command_list_3 ;","counters":[]},{"line":"    let zkapp_command_list_4 = [ 0; 1; 2; 3; 2; 1; 0 ] in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let zkapp_command_list_4_res =","counters":[]},{"line":"      [ node 0 [ node 1 [ node 2 [ node 3 [] ]; node 2 [] ]; node 1 [] ]","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":51,"col_end":51,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"      ; node 0 []","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"      ]","counters":[]},{"line":"    in","counters":[]},{"line":"    let zkapp_command_list_4_index =","counters":[]},{"line":"      [ node 0 [ node 1 [ node 2 [ node 3 [] ]; node 4 [] ]; node 5 [] ]","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":51,"col_end":51,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"      ; node 6 []","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"      ]","counters":[]},{"line":"    in","counters":[]},{"line":"    [%test_eq: (int, unit, unit) t]","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"      (of_account_updates ~account_update_depth:Fn.id zkapp_command_list_4)","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"      zkapp_command_list_4_res ;","counters":[]},{"line":"    [%test_eq: (int, unit, unit) t]","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"      ( of_account_updates ~account_update_depth:Fn.id zkapp_command_list_4","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"      |> f_index )","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"      zkapp_command_list_4_index ;","counters":[]},{"line":"    [%test_eq: int list]","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"      (to_account_updates","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"         (of_account_updates ~account_update_depth:Fn.id zkapp_command_list_4) )","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"      zkapp_command_list_4","counters":[]},{"line":"","counters":[]},{"line":"  let to_zkapp_command_with_hashes_list (xs : _ t) =","counters":[]},{"line":"    let rec collect (xs : _ t) acc =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      match xs with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | [] ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          acc","counters":[]},{"line":"      | { elt = { account_update; calls; account_update_digest = _ }","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        ; stack_hash","counters":[]},{"line":"        }","counters":[]},{"line":"        :: xs ->","counters":[]},{"line":"          (account_update, stack_hash) :: acc |> collect calls |> collect xs","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"    in","counters":[]},{"line":"    List.rev (collect xs [])","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"","counters":[]},{"line":"  let hash_cons hash h_tl =","counters":[]},{"line":"    Random_oracle.hash ~init:Hash_prefix_states.account_update_cons","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      [| hash; h_tl |]","counters":[]},{"line":"","counters":[]},{"line":"  let hash = function","counters":[]},{"line":"    | [] ->","counters":[{"col_start":6,"col_end":6,"count":2}]},{"line":"        Digest.Forest.empty","counters":[]},{"line":"    | x :: _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        With_stack_hash.stack_hash x","counters":[]},{"line":"","counters":[]},{"line":"  let cons_tree tree (forest : _ t) : _ t =","counters":[]},{"line":"    { elt = tree","counters":[{"col_start":4,"col_end":4,"count":1}]},{"line":"    ; stack_hash = Digest.Forest.cons (Digest.Tree.create tree) (hash forest)","counters":[{"col_start":36,"col_end":36,"count":1},{"col_start":56,"col_end":56,"count":1},{"col_start":68,"col_end":68,"count":1}]},{"line":"    }","counters":[]},{"line":"    :: forest","counters":[]},{"line":"","counters":[]},{"line":"  let cons_aux (type p) ~(digest_account_update : p -> _) ?(calls = [])","counters":[{"col_start":68,"col_end":68,"count":1}]},{"line":"      (account_update : p) (xs : _ t) : _ t =","counters":[]},{"line":"    let account_update_digest = digest_account_update account_update in","counters":[{"col_start":4,"col_end":4,"count":1}]},{"line":"    let tree : _ Tree.t = { account_update; account_update_digest; calls } in","counters":[{"col_start":4,"col_end":4,"count":1}]},{"line":"    cons_tree tree xs","counters":[]},{"line":"","counters":[]},{"line":"  let cons ?calls (account_update : Account_update.t) xs =","counters":[]},{"line":"    cons_aux ~digest_account_update:Digest.Account_update.create ?calls","counters":[{"col_start":4,"col_end":4,"count":1}]},{"line":"      account_update xs","counters":[]},{"line":"","counters":[]},{"line":"  let rec accumulate_hashes ~hash_account_update (xs : _ t) =","counters":[]},{"line":"    let go = accumulate_hashes ~hash_account_update in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    match xs with","counters":[]},{"line":"    | [] ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        []","counters":[]},{"line":"    | { elt = { account_update; calls; account_update_digest = _ }","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      ; stack_hash = _","counters":[]},{"line":"      }","counters":[]},{"line":"      :: xs ->","counters":[]},{"line":"        let calls = go calls in","counters":[]},{"line":"        let xs = go xs in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let node =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          { Tree.account_update","counters":[]},{"line":"          ; calls","counters":[]},{"line":"          ; account_update_digest = hash_account_update account_update","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"          }","counters":[]},{"line":"        in","counters":[]},{"line":"        let node_hash = Digest.Tree.create node in","counters":[]},{"line":"        { elt = node; stack_hash = Digest.Forest.cons node_hash (hash xs) }","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":52,"col_end":52,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"        :: xs","counters":[]},{"line":"","counters":[]},{"line":"  let accumulate_hashes' (type a b) (xs : (Account_update.t, a, b) t) :","counters":[]},{"line":"      (Account_update.t, Digest.Account_update.t, Digest.Forest.t) t =","counters":[]},{"line":"    let hash_account_update (p : Account_update.t) =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Digest.Account_update.create p","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    in","counters":[]},{"line":"    accumulate_hashes ~hash_account_update xs","counters":[]},{"line":"","counters":[]},{"line":"  let accumulate_hashes_predicated xs =","counters":[]},{"line":"    accumulate_hashes ~hash_account_update:Digest.Account_update.create xs","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  (* Delegate_call means, preserve the current caller.","counters":[]},{"line":"  *)","counters":[]},{"line":"  let add_callers","counters":[]},{"line":"      (type account_update account_update_with_caller account_update_digest","counters":[]},{"line":"      digest id ) (ps : (account_update, account_update_digest, digest) t)","counters":[]},{"line":"      ~(call_type : account_update -> Account_update.Call_type.t)","counters":[]},{"line":"      ~(add_caller : account_update -> id -> account_update_with_caller)","counters":[]},{"line":"      ~(null_id : id) ~(account_update_id : account_update -> id) :","counters":[]},{"line":"      (account_update_with_caller, account_update_digest, digest) t =","counters":[]},{"line":"    let module Context = struct","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      type t = { caller : id; self : id }","counters":[]},{"line":"    end in","counters":[]},{"line":"    let open Context in","counters":[]},{"line":"    let rec go curr_context ps =","counters":[]},{"line":"      match ps with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | { With_stack_hash.elt =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            { Tree.account_update = p; account_update_digest; calls }","counters":[]},{"line":"        ; stack_hash","counters":[]},{"line":"        }","counters":[]},{"line":"        :: ps ->","counters":[]},{"line":"          let elt =","counters":[]},{"line":"            let child_context =","counters":[]},{"line":"              match call_type p with","counters":[]},{"line":"              | Delegate_call ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  curr_context","counters":[]},{"line":"              | Call ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  { caller = curr_context.self; self = account_update_id p }","counters":[{"col_start":71,"col_end":71,"count":0}]},{"line":"            in","counters":[]},{"line":"            let account_update_caller = child_context.caller in","counters":[]},{"line":"            { Tree.account_update = add_caller p account_update_caller","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"            ; account_update_digest","counters":[]},{"line":"            ; calls = go child_context calls","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"            }","counters":[]},{"line":"          in","counters":[]},{"line":"          { With_stack_hash.elt; stack_hash } :: go curr_context ps","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"      | [] ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          []","counters":[]},{"line":"    in","counters":[]},{"line":"    go { self = null_id; caller = null_id } ps","counters":[]},{"line":"","counters":[]},{"line":"  let add_callers' (type h1 h2) (ps : (Account_update.Wire.t, h1, h2) t) :","counters":[]},{"line":"      (Account_update.t, h1, h2) t =","counters":[]},{"line":"    add_callers ps","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ~call_type:(fun p -> p.body.caller)","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"      ~add_caller ~null_id:Token_id.default","counters":[]},{"line":"      ~account_update_id:(fun p ->","counters":[]},{"line":"        Account_id.(","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          derive_token_id ~owner:(create p.body.public_key p.body.token_id)) )","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"  let add_callers_simple (type h1 h2) (ps : (Account_update.Simple.t, h1, h2) t)","counters":[]},{"line":"      : (Account_update.t, h1, h2) t =","counters":[]},{"line":"    add_callers ps","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ~call_type:(fun p -> p.body.caller)","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"      ~add_caller:add_caller_simple ~null_id:Token_id.default","counters":[]},{"line":"      ~account_update_id:(fun p ->","counters":[]},{"line":"        Account_id.(","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          derive_token_id ~owner:(create p.body.public_key p.body.token_id)) )","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"  let remove_callers","counters":[]},{"line":"      (type account_update_with_caller account_update_without_sender h1 h2 h1'","counters":[]},{"line":"      h2' id ) ~(map_account_update_digest : h1 -> h1')","counters":[]},{"line":"      ~(map_stack_hash : h2 -> h2')","counters":[]},{"line":"      (ps : (account_update_with_caller, h1, h2) t)","counters":[]},{"line":"      ~(equal_id : id -> id -> bool)","counters":[]},{"line":"      ~(add_call_type :","counters":[]},{"line":"            account_update_with_caller","counters":[]},{"line":"         -> Account_update.Call_type.t","counters":[]},{"line":"         -> account_update_without_sender ) ~(null_id : id)","counters":[]},{"line":"      ~(account_update_caller : account_update_with_caller -> id) :","counters":[]},{"line":"      (account_update_without_sender, h1', h2') t =","counters":[]},{"line":"    let rec go ~top_level_account_update parent_caller ps =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let call_type_for_account_update p : Account_update.Call_type.t =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        if top_level_account_update then Call","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"        else if equal_id parent_caller (account_update_caller p) then","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"          Delegate_call","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        else Call","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"      in","counters":[]},{"line":"      match ps with","counters":[]},{"line":"      | { With_stack_hash.elt =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            { Tree.account_update = p; account_update_digest; calls }","counters":[]},{"line":"        ; stack_hash","counters":[]},{"line":"        }","counters":[]},{"line":"        :: ps ->","counters":[]},{"line":"          let ty = call_type_for_account_update p in","counters":[]},{"line":"          { With_stack_hash.elt =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              { Tree.account_update = add_call_type p ty","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"              ; account_update_digest =","counters":[]},{"line":"                  map_account_update_digest account_update_digest","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"              ; calls =","counters":[]},{"line":"                  go ~top_level_account_update:false (account_update_caller p)","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":74,"col_end":74,"count":0}]},{"line":"                    calls","counters":[]},{"line":"              }","counters":[]},{"line":"          ; stack_hash = map_stack_hash stack_hash","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"          }","counters":[]},{"line":"          :: go ~top_level_account_update parent_caller ps","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"      | [] ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          []","counters":[]},{"line":"    in","counters":[]},{"line":"    go ~top_level_account_update:true null_id ps","counters":[]},{"line":"","counters":[]},{"line":"  let%test_unit \"add_callers and remove_callers\" =","counters":[]},{"line":"    let module P = struct","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      type 'a t = { id : int; caller : 'a } [@@deriving compare, sexp]","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"    end in","counters":[]},{"line":"    let module With_call_type = struct","counters":[]},{"line":"      type tmp = (Account_update.Call_type.t P.t, unit, unit) t","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":50,"col_end":50,"count":0},{"col_start":56,"col_end":56,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"      [@@deriving compare, sexp]","counters":[]},{"line":"","counters":[]},{"line":"      type t = tmp [@@deriving compare, sexp]","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    end in","counters":[]},{"line":"    let null_id = -1 in","counters":[]},{"line":"    let module With_id = struct","counters":[]},{"line":"      type tmp = (int P.t, unit, unit) t [@@deriving compare, sexp]","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"      type t = tmp [@@deriving compare, sexp]","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    end in","counters":[]},{"line":"    let of_tree tree : _ t =","counters":[]},{"line":"      [ { With_stack_hash.elt = tree; stack_hash = () } ]","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    in","counters":[]},{"line":"    let node id caller calls =","counters":[]},{"line":"      { Tree.account_update = { P.id; caller }","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      ; account_update_digest = ()","counters":[]},{"line":"      ; calls =","counters":[]},{"line":"          List.map calls ~f:(fun elt ->","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"              { With_stack_hash.elt; stack_hash = () } )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"      }","counters":[]},{"line":"    in","counters":[]},{"line":"    let t : With_call_type.t =","counters":[]},{"line":"      let open Account_update.Call_type in","counters":[]},{"line":"      node 0 Call","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"        [ node 1 Call","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"            [ node 11 Call [ node 111 Call []; node 112 Delegate_call [] ]","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"            ; node 12 Delegate_call","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                [ node 121 Call []; node 122 Delegate_call [] ]","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"            ]","counters":[]},{"line":"        ; node 2 Delegate_call","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"            [ node 21 Delegate_call","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                [ node 211 Call []; node 212 Delegate_call [] ]","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"            ; node 22 Call [ node 221 Call []; node 222 Delegate_call [] ]","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"            ]","counters":[]},{"line":"        ]","counters":[]},{"line":"      |> of_tree","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"    in","counters":[]},{"line":"    let expected_output : With_id.t =","counters":[]},{"line":"      node 0 null_id","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"        [ node 1 0","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"            [ node 11 1 [ node 111 11 []; node 112 1 [] ]","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"            ; node 12 0 [ node 121 1 []; node 122 0 [] ]","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"            ]","counters":[]},{"line":"        ; node 2 null_id","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"            [ node 21 null_id [ node 211 0 []; node 212 null_id [] ]","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"            ; node 22 0 [ node 221 22 []; node 222 0 [] ]","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"            ]","counters":[]},{"line":"        ]","counters":[]},{"line":"      |> of_tree","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"    in","counters":[]},{"line":"    let open P in","counters":[]},{"line":"    [%test_eq: With_id.t]","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"      (add_callers t","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"         ~call_type:(fun p -> p.caller)","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"         ~add_caller:(fun p caller : int P.t -> { p with caller })","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"         ~null_id","counters":[]},{"line":"         ~account_update_id:(fun p -> p.id) )","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"      expected_output ;","counters":[]},{"line":"    [%test_eq: With_call_type.t]","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"      (remove_callers expected_output ~equal_id:Int.equal","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"         ~map_account_update_digest:Fn.id ~map_stack_hash:Fn.id","counters":[]},{"line":"         ~add_call_type:(fun p call_type -> { p with caller = call_type })","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"         ~null_id","counters":[]},{"line":"         ~account_update_caller:(fun p -> p.caller) )","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"      t","counters":[]},{"line":"","counters":[]},{"line":"  module With_hashes_and_data = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type 'data t =","counters":[{"col_start":8,"col_end":8,"count":1},{"col_start":13,"col_end":13,"count":0},{"col_start":19,"col_end":19,"count":3}]},{"line":"          ( Account_update.Stable.V1.t * 'data","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":12,"col_end":12,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"          , Digest.Account_update.Stable.V1.t","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          , Digest.Forest.Stable.V1.t )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        [@@deriving sexp, compare, equal, hash, yojson]","counters":[{"col_start":54,"col_end":54,"count":3}]},{"line":"","counters":[]},{"line":"        let to_latest = Fn.id","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    let empty = Digest.Forest.empty","counters":[]},{"line":"","counters":[]},{"line":"    let hash_account_update ((p : Account_update.t), _) =","counters":[]},{"line":"      Digest.Account_update.create p","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let accumulate_hashes xs : _ t = accumulate_hashes ~hash_account_update xs","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"    let of_zkapp_command_simple_list (xs : (Account_update.Simple.t * 'a) list)","counters":[]},{"line":"        : _ t =","counters":[]},{"line":"      of_account_updates xs","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"        ~account_update_depth:(fun ((p : Account_update.Simple.t), _) ->","counters":[]},{"line":"          p.body.call_depth )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"      |> add_callers","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"           ~call_type:(fun ((p : Account_update.Simple.t), _) -> p.body.caller)","counters":[{"col_start":65,"col_end":65,"count":0}]},{"line":"           ~add_caller:(fun (p, x) id -> (add_caller_simple p id, x))","counters":[{"col_start":41,"col_end":41,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"           ~null_id:Token_id.default","counters":[]},{"line":"           ~account_update_id:(fun ((p : Account_update.Simple.t), _) ->","counters":[]},{"line":"             Account_id.(","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"               derive_token_id ~owner:(create p.body.public_key p.body.token_id))","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"             )","counters":[]},{"line":"      |> accumulate_hashes","counters":[]},{"line":"","counters":[]},{"line":"    let of_account_updates (xs : (Account_update.Graphql_repr.t * 'a) list) :","counters":[]},{"line":"        _ t =","counters":[]},{"line":"      of_account_updates_map","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"        ~account_update_depth:(fun ((p : Account_update.Graphql_repr.t), _) ->","counters":[]},{"line":"          p.body.call_depth )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        ~f:(fun (p, x) -> (Account_update.of_graphql_repr p, x))","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"        xs","counters":[]},{"line":"      |> accumulate_hashes","counters":[]},{"line":"","counters":[]},{"line":"    let to_account_updates (x : _ t) = to_account_updates x","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"    let to_zkapp_command_with_hashes_list (x : _ t) =","counters":[]},{"line":"      to_zkapp_command_with_hashes_list x","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let account_updates_hash' xs = of_account_updates xs |> hash","counters":[{"col_start":35,"col_end":35,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"","counters":[]},{"line":"    let account_updates_hash xs =","counters":[]},{"line":"      List.map ~f:(fun x -> (x, ())) xs |> account_updates_hash'","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module With_hashes = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type t =","counters":[{"col_start":8,"col_end":8,"count":2},{"col_start":13,"col_end":13,"count":1}]},{"line":"          ( Account_update.Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":12,"col_end":12,"count":0}]},{"line":"          , Digest.Account_update.Stable.V1.t","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          , Digest.Forest.Stable.V1.t )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        [@@deriving sexp, compare, equal, hash, yojson]","counters":[{"col_start":54,"col_end":54,"count":5}]},{"line":"","counters":[]},{"line":"        let to_latest = Fn.id","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    let empty = Digest.Forest.empty","counters":[]},{"line":"","counters":[]},{"line":"    let hash_account_update (p : Account_update.t) =","counters":[]},{"line":"      Digest.Account_update.create p","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let accumulate_hashes xs : t = accumulate_hashes ~hash_account_update xs","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"    let of_zkapp_command_simple_list (xs : Account_update.Simple.t list) : t =","counters":[]},{"line":"      of_account_updates xs","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"        ~account_update_depth:(fun (p : Account_update.Simple.t) ->","counters":[]},{"line":"          p.body.call_depth )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"      |> add_callers","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"           ~call_type:(fun (p : Account_update.Simple.t) -> p.body.caller)","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"           ~add_caller:(fun p id -> add_caller_simple p id)","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"           ~null_id:Token_id.default","counters":[]},{"line":"           ~account_update_id:(fun (p : Account_update.Simple.t) ->","counters":[]},{"line":"             Account_id.(","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"               derive_token_id ~owner:(create p.body.public_key p.body.token_id))","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"             )","counters":[]},{"line":"      |> accumulate_hashes","counters":[]},{"line":"","counters":[]},{"line":"    let of_account_updates (xs : Account_update.Graphql_repr.t list) : t =","counters":[]},{"line":"      of_account_updates_map","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"        ~account_update_depth:(fun (p : Account_update.Graphql_repr.t) ->","counters":[]},{"line":"          p.body.call_depth )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        ~f:(fun p -> Account_update.of_graphql_repr p)","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"        xs","counters":[]},{"line":"      |> accumulate_hashes","counters":[]},{"line":"","counters":[]},{"line":"    let to_account_updates (x : t) = to_account_updates x","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"    let to_zkapp_command_with_hashes_list (x : t) =","counters":[]},{"line":"      to_zkapp_command_with_hashes_list x","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let account_updates_hash' xs = of_account_updates xs |> hash","counters":[{"col_start":35,"col_end":35,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"","counters":[]},{"line":"    let account_updates_hash xs =","counters":[]},{"line":"      List.map ~f:(fun x -> x) xs |> account_updates_hash'","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let is_empty : _ t -> bool = List.is_empty","counters":[]},{"line":"","counters":[]},{"line":"  let to_list (type p) (t : (p, _, _) t) : p list =","counters":[]},{"line":"    List.rev @@ fold t ~init:[] ~f:(fun acc p -> p :: acc)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"","counters":[]},{"line":"  let exists (type p) (t : (p, _, _) t) ~(f : p -> bool) : bool =","counters":[]},{"line":"    with_return (fun { return } ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        fold t ~init:() ~f:(fun () p -> if f p then return true else ()) ;","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":52,"col_end":52,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"        false )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Graphql_repr = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type t =","counters":[{"col_start":6,"col_end":6,"count":2},{"col_start":11,"col_end":11,"count":2}]},{"line":"        { fee_payer : Account_update.Fee_payer.Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"        ; account_updates : Account_update.Graphql_repr.Stable.V1.t list","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":68,"col_end":68,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"        ; memo : Signed_command_memo.Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"        }","counters":[]},{"line":"      [@@deriving sexp, compare, equal, hash, yojson]","counters":[{"col_start":52,"col_end":52,"count":5}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Simple = struct","counters":[]},{"line":"  (* For easily constructing values *)","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type t =","counters":[{"col_start":6,"col_end":6,"count":2},{"col_start":11,"col_end":11,"count":2}]},{"line":"        { fee_payer : Account_update.Fee_payer.Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"        ; account_updates : Account_update.Simple.Stable.V1.t list","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":62,"col_end":62,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"        ; memo : Signed_command_memo.Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"        }","counters":[]},{"line":"      [@@deriving sexp, compare, equal, hash, yojson]","counters":[{"col_start":52,"col_end":52,"count":5}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Digest = Call_forest.Digest","counters":[]},{"line":"","counters":[]},{"line":"module T = struct","counters":[]},{"line":"  [%%versioned_binable","counters":[]},{"line":"  module Stable = struct","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"    [@@@with_top_version_tag]","counters":[]},{"line":"","counters":[]},{"line":"    (* DO NOT DELETE VERSIONS!","counters":[]},{"line":"       so we can always get transaction hashes from old transaction ids","counters":[]},{"line":"       the version linter should be checking this","counters":[]},{"line":"","counters":[]},{"line":"       IF YOU CREATE A NEW VERSION:","counters":[]},{"line":"       update Transaction_hash.hash_of_transaction_id to handle it","counters":[]},{"line":"       add hash_zkapp_command_vn for that version","counters":[]},{"line":"    *)","counters":[]},{"line":"","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type t = Mina_wire_types.Mina_base.Zkapp_command.V1.t =","counters":[{"col_start":6,"col_end":6,"count":3},{"col_start":11,"col_end":11,"count":0}]},{"line":"        { fee_payer : Account_update.Fee_payer.Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"        ; account_updates :","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"            ( Account_update.Stable.V1.t","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":14,"col_end":14,"count":0}]},{"line":"            , Digest.Account_update.Stable.V1.t","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"            , Digest.Forest.Stable.V1.t )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"            Call_forest.Stable.V1.t","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"        ; memo : Signed_command_memo.Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"        }","counters":[]},{"line":"      [@@deriving annot, sexp, compare, equal, hash, yojson, fields]","counters":[{"col_start":67,"col_end":67,"count":12}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"      module Wire = struct","counters":[]},{"line":"        [%%versioned","counters":[]},{"line":"        module Stable = struct","counters":[]},{"line":"          module V1 = struct","counters":[]},{"line":"            type t =","counters":[{"col_start":12,"col_end":12,"count":2},{"col_start":17,"col_end":17,"count":2}]},{"line":"              { fee_payer : Account_update.Fee_payer.Stable.V1.t","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"              ; account_updates :","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"                  ( Account_update.Wire.Stable.V1.t","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":20,"col_end":20,"count":0}]},{"line":"                  , unit","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                  , unit )","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                  Call_forest.Stable.V1.t","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"              ; memo : Signed_command_memo.Stable.V1.t","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"              }","counters":[]},{"line":"            [@@deriving sexp, compare, equal, hash, yojson]","counters":[{"col_start":58,"col_end":58,"count":5}]},{"line":"","counters":[]},{"line":"            let to_latest = Fn.id","counters":[]},{"line":"          end","counters":[]},{"line":"        end]","counters":[]},{"line":"","counters":[]},{"line":"        let check (t : t) : unit =","counters":[]},{"line":"          List.iter t.account_updates ~f:(fun p ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              assert (","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                Account_update.Call_type.equal p.elt.account_update.body.caller","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"                  Call ) )","counters":[]},{"line":"","counters":[]},{"line":"        let of_graphql_repr (t : Graphql_repr.t) : t =","counters":[]},{"line":"          { fee_payer = t.fee_payer","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          ; memo = t.memo","counters":[]},{"line":"          ; account_updates =","counters":[]},{"line":"              Call_forest.of_account_updates_map t.account_updates","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"                ~f:Account_update.of_graphql_repr","counters":[]},{"line":"                ~account_update_depth:(fun (p : Account_update.Graphql_repr.t)","counters":[]},{"line":"                                      -> p.body.call_depth )","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"              |> Call_forest.remove_callers ~equal_id:Token_id.equal","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"                   ~map_account_update_digest:ignore ~map_stack_hash:ignore","counters":[]},{"line":"                   ~add_call_type:Account_update.to_wire","counters":[]},{"line":"                   ~null_id:Token_id.default ~account_update_caller:(fun p ->","counters":[]},{"line":"                     p.body.caller )","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"          }","counters":[]},{"line":"","counters":[]},{"line":"        let to_graphql_repr (t : t) : Graphql_repr.t =","counters":[]},{"line":"          { fee_payer = t.fee_payer","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          ; memo = t.memo","counters":[]},{"line":"          ; account_updates =","counters":[]},{"line":"              t.account_updates","counters":[]},{"line":"              |> Call_forest.add_callers","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"                   ~call_type:(fun (p : Account_update.Wire.t) -> p.body.caller)","counters":[{"col_start":66,"col_end":66,"count":0}]},{"line":"                   ~add_caller ~null_id:Token_id.default","counters":[]},{"line":"                   ~account_update_id:(fun (p : Account_update.Wire.t) ->","counters":[]},{"line":"                     Account_id.(","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                       derive_token_id","counters":[]},{"line":"                         ~owner:(create p.body.public_key p.body.token_id)) )","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"              |> Call_forest.to_account_updates_map","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                   ~f:(fun ~depth account_update ->","counters":[]},{"line":"                     Account_update.to_graphql_repr account_update","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                       ~call_depth:depth )","counters":[]},{"line":"          }","counters":[]},{"line":"","counters":[]},{"line":"        let gen =","counters":[]},{"line":"          let open Quickcheck.Generator in","counters":[]},{"line":"          let open Let_syntax in","counters":[]},{"line":"          let gen_call_forest =","counters":[]},{"line":"            let%map xs =","counters":[]},{"line":"              fixed_point (fun self ->","counters":[{"col_start":24,"col_end":24,"count":1}]},{"line":"                  let%bind calls_length = small_non_negative_int in","counters":[]},{"line":"                  list_with_length calls_length","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    (let%map account_update = Account_update.Wire.gen","counters":[]},{"line":"                     and calls = self in","counters":[]},{"line":"                     { With_stack_hash.stack_hash = ()","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                     ; elt =","counters":[]},{"line":"                         { Call_forest.Tree.account_update","counters":[]},{"line":"                         ; account_update_digest = ()","counters":[]},{"line":"                         ; calls","counters":[]},{"line":"                         }","counters":[]},{"line":"                     } ) )","counters":[]},{"line":"            in","counters":[]},{"line":"            (* All top level zkapp_command should be \"Call\" not \"Delegate_call\" *)","counters":[]},{"line":"            List.map xs","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              ~f:","counters":[]},{"line":"                (With_stack_hash.map","counters":[]},{"line":"                   ~f:(fun (t : (Account_update.Wire.t, _, _) Call_forest.Tree.t)","counters":[]},{"line":"                      ->","counters":[]},{"line":"                     { t with","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                       account_update =","counters":[]},{"line":"                         { t.account_update with","counters":[]},{"line":"                           body = { t.account_update.body with caller = Call }","counters":[]},{"line":"                         }","counters":[]},{"line":"                     } ) )","counters":[]},{"line":"          in","counters":[]},{"line":"          let open Quickcheck.Let_syntax in","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"          let%map fee_payer = Account_update.Fee_payer.gen","counters":[]},{"line":"          and account_updates = gen_call_forest","counters":[]},{"line":"          and memo = Signed_command_memo.gen in","counters":[]},{"line":"          { fee_payer; account_updates; memo }","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"        let shrinker : t Quickcheck.Shrinker.t =","counters":[]},{"line":"          Quickcheck.Shrinker.create (fun t ->","counters":[{"col_start":35,"col_end":35,"count":1}]},{"line":"              let shape = Call_forest.shape t.account_updates in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              Sequence.map","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (Quickcheck.Shrinker.shrink","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"                   Call_forest.Shape.quickcheck_shrinker shape )","counters":[]},{"line":"                ~f:(fun shape' ->","counters":[]},{"line":"                  { t with","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    account_updates = Call_forest.mask t.account_updates shape'","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"                  } ) )","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      let of_wire (w : Wire.t) : t =","counters":[]},{"line":"        { fee_payer = w.fee_payer","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        ; memo = w.memo","counters":[]},{"line":"        ; account_updates =","counters":[]},{"line":"            w.account_updates","counters":[]},{"line":"            |> Call_forest.add_callers","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                 ~call_type:(fun (p : Account_update.Wire.t) -> p.body.caller)","counters":[{"col_start":64,"col_end":64,"count":0}]},{"line":"                 ~add_caller ~null_id:Token_id.default","counters":[]},{"line":"                 ~account_update_id:(fun (p : Account_update.Wire.t) ->","counters":[]},{"line":"                   Account_id.(","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"                     derive_token_id","counters":[]},{"line":"                       ~owner:(create p.body.public_key p.body.token_id)) )","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"            |> Call_forest.accumulate_hashes","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"                 ~hash_account_update:(fun (p : Account_update.t) ->","counters":[]},{"line":"                   Digest.Account_update.create p )","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"      let to_wire (t : t) : Wire.t =","counters":[]},{"line":"        { fee_payer = t.fee_payer","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        ; memo = t.memo","counters":[]},{"line":"        ; account_updates =","counters":[]},{"line":"            Call_forest.remove_callers ~equal_id:Token_id.equal","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"              ~map_account_update_digest:ignore ~map_stack_hash:ignore","counters":[]},{"line":"              ~add_call_type:Account_update.to_wire ~null_id:Token_id.default","counters":[]},{"line":"              ~account_update_caller:(fun p -> p.body.caller)","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"              t.account_updates","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"      include","counters":[]},{"line":"        Binable.Of_binable_without_uuid","counters":[]},{"line":"          (Wire.Stable.V1)","counters":[]},{"line":"          (struct","counters":[]},{"line":"            type nonrec t = t","counters":[]},{"line":"","counters":[]},{"line":"            let of_binable t = Wire.check t ; of_wire t","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"","counters":[]},{"line":"            let to_binable = to_wire","counters":[]},{"line":"          end)","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"include T","counters":[]},{"line":"","counters":[]},{"line":"[%%define_locally Stable.Latest.(of_wire, to_wire)]","counters":[]},{"line":"","counters":[]},{"line":"let of_simple (w : Simple.t) : t =","counters":[]},{"line":"  { fee_payer = w.fee_payer","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  ; memo = w.memo","counters":[]},{"line":"  ; account_updates =","counters":[]},{"line":"      Call_forest.of_account_updates w.account_updates","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"        ~account_update_depth:(fun (p : Account_update.Simple.t) ->","counters":[]},{"line":"          p.body.call_depth )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"      |> Call_forest.add_callers","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"           ~call_type:(fun (p : Account_update.Simple.t) -> p.body.caller)","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"           ~add_caller:add_caller_simple ~null_id:Token_id.default","counters":[]},{"line":"           ~account_update_id:(fun (p : Account_update.Simple.t) ->","counters":[]},{"line":"             Account_id.(","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"               derive_token_id ~owner:(create p.body.public_key p.body.token_id))","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"             )","counters":[]},{"line":"      |> Call_forest.accumulate_hashes","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"           ~hash_account_update:(fun (p : Account_update.t) ->","counters":[]},{"line":"             Digest.Account_update.create p )","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"let to_simple (t : t) : Simple.t =","counters":[]},{"line":"  { fee_payer = t.fee_payer","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  ; memo = t.memo","counters":[]},{"line":"  ; account_updates =","counters":[]},{"line":"      Call_forest.remove_callers ~equal_id:Token_id.equal","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"        ~map_account_update_digest:ignore ~map_stack_hash:ignore","counters":[]},{"line":"        ~add_call_type:(fun { body = b; authorization } call_type ->","counters":[]},{"line":"          { Account_update.Simple.authorization","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          ; body =","counters":[]},{"line":"              { public_key = b.public_key","counters":[]},{"line":"              ; token_id = b.token_id","counters":[]},{"line":"              ; update = b.update","counters":[]},{"line":"              ; balance_change = b.balance_change","counters":[]},{"line":"              ; increment_nonce = b.increment_nonce","counters":[]},{"line":"              ; events = b.events","counters":[]},{"line":"              ; sequence_events = b.sequence_events","counters":[]},{"line":"              ; call_data = b.call_data","counters":[]},{"line":"              ; preconditions = b.preconditions","counters":[]},{"line":"              ; use_full_commitment = b.use_full_commitment","counters":[]},{"line":"              ; caller = call_type","counters":[]},{"line":"              ; call_depth = 0","counters":[]},{"line":"              ; authorization_kind = b.authorization_kind","counters":[]},{"line":"              }","counters":[]},{"line":"          } )","counters":[]},{"line":"        ~null_id:Token_id.default","counters":[]},{"line":"        ~account_update_caller:(fun (p : Account_update.t) -> p.body.caller)","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"        t.account_updates","counters":[]},{"line":"      |> Call_forest.to_account_updates_map","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"           ~f:(fun ~depth (p : Account_update.Simple.t) ->","counters":[]},{"line":"             { p with body = { p.body with call_depth = depth } } )","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"let%test_unit \"wire embedded in t\" =","counters":[]},{"line":"  let module Wire = Stable.Latest.Wire in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  Quickcheck.test ~trials:10 ~shrinker:Wire.shrinker Wire.gen ~f:(fun w ->","counters":[]},{"line":"      [%test_eq: Wire.t] (to_wire (of_wire w)) w )","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"","counters":[]},{"line":"let%test_unit \"wire embedded in graphql\" =","counters":[]},{"line":"  let module Wire = Stable.Latest.Wire in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  Quickcheck.test ~shrinker:Wire.shrinker Wire.gen ~f:(fun w ->","counters":[]},{"line":"      [%test_eq: Wire.t] (Wire.of_graphql_repr (Wire.to_graphql_repr w)) w )","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"","counters":[]},{"line":"let zkapp_command (t : t) : _ Call_forest.t =","counters":[]},{"line":"  let p = t.fee_payer in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let body = Account_update.Body.of_fee_payer p.body in","counters":[]},{"line":"  let fee_payer : Account_update.t =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    let p = t.fee_payer in","counters":[]},{"line":"    { authorization = Control.Signature p.authorization; body }","counters":[]},{"line":"  in","counters":[]},{"line":"  Call_forest.cons fee_payer t.account_updates","counters":[]},{"line":"","counters":[]},{"line":"let fee (t : t) : Currency.Fee.t = t.fee_payer.body.fee","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"let fee_payer_account_update ({ fee_payer; _ } : t) = fee_payer","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"","counters":[]},{"line":"let applicable_at_nonce (t : t) : Account.Nonce.t =","counters":[]},{"line":"  (fee_payer_account_update t).body.nonce","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"","counters":[]},{"line":"let target_nonce_on_success (t : t) : Account.Nonce.t =","counters":[]},{"line":"  let base_nonce = Account.Nonce.succ (applicable_at_nonce t) in","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"  let fee_payer_pubkey = t.fee_payer.body.public_key in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let fee_payer_account_update_increments =","counters":[]},{"line":"    List.count (Call_forest.to_list t.account_updates) ~f:(fun p ->","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"        Public_key.Compressed.equal p.body.public_key fee_payer_pubkey","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"        && p.body.increment_nonce )","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"  in","counters":[]},{"line":"  Account.Nonce.add base_nonce","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    (Account.Nonce.of_int fee_payer_account_update_increments)","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"","counters":[]},{"line":"let nonce_increments (t : t) : int Public_key.Compressed.Map.t =","counters":[]},{"line":"  let base_increments =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Public_key.Compressed.Map.of_alist_exn [ (t.fee_payer.body.public_key, 1) ]","counters":[]},{"line":"  in","counters":[]},{"line":"  List.fold_left (Call_forest.to_list t.account_updates) ~init:base_increments","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"    ~f:(fun incr_map account_update ->","counters":[]},{"line":"      if account_update.body.increment_nonce then","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Map.update incr_map account_update.body.public_key","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ~f:(Option.value_map ~default:1 ~f:(( + ) 1))","counters":[]},{"line":"      else incr_map )","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"","counters":[]},{"line":"let fee_token (_t : t) = Token_id.default","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"let fee_payer (t : t) =","counters":[]},{"line":"  Account_id.create t.fee_payer.body.public_key (fee_token t)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"","counters":[]},{"line":"let account_updates_list (t : t) : Account_update.t list =","counters":[]},{"line":"  Call_forest.fold t.account_updates ~init:[] ~f:(Fn.flip List.cons) |> List.rev","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"","counters":[]},{"line":"let zkapp_command_list (t : t) : Account_update.t list =","counters":[]},{"line":"  Call_forest.fold t.account_updates","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"    ~init:[ Account_update.of_fee_payer (fee_payer_account_update t) ]","counters":[{"col_start":38,"col_end":38,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"    ~f:(Fn.flip List.cons)","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"  |> List.rev","counters":[]},{"line":"","counters":[]},{"line":"let fee_excess (t : t) =","counters":[]},{"line":"  Fee_excess.of_single (fee_token t, Currency.Fee.Signed.of_unsigned (fee t))","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":67,"col_end":67,"count":0},{"col_start":72,"col_end":72,"count":0}]},{"line":"","counters":[]},{"line":"let accounts_accessed (t : t) (status : Transaction_status.t) =","counters":[]},{"line":"  match status with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | Applied ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Call_forest.fold t.account_updates","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"        ~init:[ fee_payer t ]","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"        ~f:(fun acc p -> Account_update.account_id p :: acc)","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"      |> List.rev |> List.stable_dedup","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"  | Failed _ ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      [ fee_payer t ]","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"","counters":[]},{"line":"let accounts_referenced (t : t) = accounts_accessed t Applied","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"","counters":[]},{"line":"let fee_payer_pk (t : t) = t.fee_payer.body.public_key","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"","counters":[]},{"line":"let value_if b ~then_ ~else_ = if b then then_ else else_","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"","counters":[]},{"line":"module Virtual = struct","counters":[]},{"line":"  module Bool = struct","counters":[]},{"line":"    type t = bool","counters":[]},{"line":"","counters":[]},{"line":"    let true_ = true","counters":[]},{"line":"","counters":[]},{"line":"    let assert_ _ = ()","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"","counters":[]},{"line":"    let equal = Bool.equal","counters":[]},{"line":"","counters":[]},{"line":"    let not = not","counters":[]},{"line":"","counters":[]},{"line":"    let ( || ) = ( || )","counters":[]},{"line":"","counters":[]},{"line":"    let ( && ) = ( && )","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Unit = struct","counters":[]},{"line":"    type t = unit","counters":[]},{"line":"","counters":[]},{"line":"    let if_ = value_if","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Ledger = Unit","counters":[]},{"line":"  module Account = Unit","counters":[]},{"line":"","counters":[]},{"line":"  module Amount = struct","counters":[]},{"line":"    open Currency.Amount","counters":[]},{"line":"","counters":[]},{"line":"    type nonrec t = t","counters":[]},{"line":"","counters":[]},{"line":"    let if_ = value_if","counters":[]},{"line":"","counters":[]},{"line":"    module Signed = Signed","counters":[]},{"line":"","counters":[]},{"line":"    let zero = zero","counters":[]},{"line":"","counters":[]},{"line":"    let ( - ) (x1 : t) (x2 : t) : Signed.t =","counters":[]},{"line":"      Option.value_exn Signed.(of_unsigned x1 + negate (of_unsigned x2))","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":53,"col_end":53,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"","counters":[]},{"line":"    let ( + ) (x1 : t) (x2 : t) : t = Option.value_exn (add x1 x2)","counters":[{"col_start":38,"col_end":38,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"","counters":[]},{"line":"    let add_signed (x1 : t) (x2 : Signed.t) : t =","counters":[]},{"line":"      let y = Option.value_exn Signed.(of_unsigned x1 + x2) in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"      match y.sgn with Pos -> y.magnitude | Neg -> failwith \"add_signed\"","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Token_id = struct","counters":[]},{"line":"    include Token_id","counters":[]},{"line":"","counters":[]},{"line":"    let if_ = value_if","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Zkapp_command = struct","counters":[]},{"line":"    type t = Account_update.t list","counters":[]},{"line":"","counters":[]},{"line":"    let if_ = value_if","counters":[]},{"line":"","counters":[]},{"line":"    type account_update = Account_update.t","counters":[]},{"line":"","counters":[]},{"line":"    let empty = []","counters":[]},{"line":"","counters":[]},{"line":"    let is_empty = List.is_empty","counters":[]},{"line":"","counters":[]},{"line":"    let pop (t : t) = match t with [] -> failwith \"pop\" | p :: t -> (p, t)","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Verifiable = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type t =","counters":[{"col_start":6,"col_end":6,"count":2},{"col_start":11,"col_end":11,"count":2}]},{"line":"        { fee_payer : Account_update.Fee_payer.Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"        ; account_updates :","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"            ( Side_loaded_verification_key.Stable.V2.t","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":14,"col_end":14,"count":0}]},{"line":"            , Zkapp_basic.F.Stable.V1.t )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"            With_hash.Stable.V1.t","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"            option","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            Call_forest.With_hashes_and_data.Stable.V1.t","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"        ; memo : Signed_command_memo.Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"        }","counters":[]},{"line":"      [@@deriving sexp, compare, equal, hash, yojson]","counters":[{"col_start":52,"col_end":52,"count":5}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let of_verifiable (t : Verifiable.t) : t =","counters":[]},{"line":"  { fee_payer = t.fee_payer","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  ; account_updates = Call_forest.map t.account_updates ~f:fst","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"  ; memo = t.memo","counters":[]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"module Transaction_commitment = struct","counters":[]},{"line":"  module Stable = Kimchi_backend.Pasta.Basic.Fp.Stable","counters":[]},{"line":"","counters":[]},{"line":"  type t = (Stable.Latest.t[@deriving sexp])","counters":[]},{"line":"","counters":[]},{"line":"  let sexp_of_t = Stable.Latest.sexp_of_t","counters":[]},{"line":"","counters":[]},{"line":"  let t_of_sexp = Stable.Latest.t_of_sexp","counters":[]},{"line":"","counters":[]},{"line":"  let empty = Outside_hash_image.t","counters":[]},{"line":"","counters":[]},{"line":"  let typ = Snark_params.Tick.Field.typ","counters":[]},{"line":"","counters":[]},{"line":"  let create ~(account_updates_hash : Digest.Forest.t) : t =","counters":[]},{"line":"    (account_updates_hash :> t)","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let create_complete (t : t) ~memo_hash","counters":[]},{"line":"      ~(fee_payer_hash : Digest.Account_update.t) =","counters":[]},{"line":"    Random_oracle.hash ~init:Hash_prefix.account_update_cons","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      [| memo_hash; (fee_payer_hash :> t); t |]","counters":[]},{"line":"","counters":[]},{"line":"  module Checked = struct","counters":[]},{"line":"    type t = Pickles.Impls.Step.Field.t","counters":[]},{"line":"","counters":[]},{"line":"    let create ~(account_updates_hash : Digest.Forest.Checked.t) =","counters":[]},{"line":"      (account_updates_hash :> t)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let create_complete (t : t) ~memo_hash","counters":[]},{"line":"        ~(fee_payer_hash : Digest.Account_update.Checked.t) =","counters":[]},{"line":"      Random_oracle.Checked.hash ~init:Hash_prefix.account_update_cons","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [| memo_hash; (fee_payer_hash :> t); t |]","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let account_updates_hash (t : t) = Call_forest.hash t.account_updates","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"let commitment (t : t) : Transaction_commitment.t =","counters":[]},{"line":"  Transaction_commitment.create ~account_updates_hash:(account_updates_hash t)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":74,"col_end":74,"count":0}]},{"line":"","counters":[]},{"line":"(** This module defines weights for each component of a `Zkapp_command.t` element. *)","counters":[]},{"line":"module Weight = struct","counters":[]},{"line":"  let account_update : Account_update.t -> int = fun _ -> 1","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"","counters":[]},{"line":"  let fee_payer (_fp : Account_update.Fee_payer.t) : int = 1","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"","counters":[]},{"line":"  let account_updates : (Account_update.t, _, _) Call_forest.t -> int =","counters":[]},{"line":"    Call_forest.fold ~init:0 ~f:(fun acc p -> acc + account_update p)","counters":[{"col_start":46,"col_end":46,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"","counters":[]},{"line":"  let memo : Signed_command_memo.t -> int = fun _ -> 0","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let weight (zkapp_command : t) : int =","counters":[]},{"line":"  let { fee_payer; account_updates; memo } = zkapp_command in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  List.sum","counters":[]},{"line":"    (module Int)","counters":[]},{"line":"    ~f:Fn.id","counters":[]},{"line":"    [ Weight.fee_payer fee_payer","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"    ; Weight.account_updates account_updates","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"    ; Weight.memo memo","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"    ]","counters":[]},{"line":"","counters":[]},{"line":"module type Valid_intf = sig","counters":[]},{"line":"  module Verification_key_hash : sig","counters":[]},{"line":"    [%%versioned:","counters":[]},{"line":"    module Stable : sig","counters":[]},{"line":"      module V1 : sig","counters":[]},{"line":"        type t = Zkapp_basic.F.Stable.V1.t","counters":[]},{"line":"        [@@deriving sexp, compare, equal, hash, yojson]","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  [%%versioned:","counters":[]},{"line":"  module Stable : sig","counters":[]},{"line":"    module V1 : sig","counters":[]},{"line":"      type t = private","counters":[]},{"line":"        { zkapp_command : T.Stable.V1.t","counters":[]},{"line":"        ; verification_keys :","counters":[]},{"line":"            (Account_id.Stable.V2.t * Verification_key_hash.Stable.V1.t) list","counters":[]},{"line":"        }","counters":[]},{"line":"      [@@deriving sexp, compare, equal, hash, yojson]","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  val to_valid_unsafe :","counters":[]},{"line":"    T.t -> [> `If_this_is_used_it_should_have_a_comment_justifying_it of t ]","counters":[]},{"line":"","counters":[]},{"line":"  val to_valid :","counters":[]},{"line":"       T.t","counters":[]},{"line":"    -> ledger:'a","counters":[]},{"line":"    -> get:('a -> 'b -> Account.t option)","counters":[]},{"line":"    -> location_of_account:('a -> Account_id.t -> 'b option)","counters":[]},{"line":"    -> t option","counters":[]},{"line":"","counters":[]},{"line":"  val of_verifiable : Verifiable.t -> t option","counters":[]},{"line":"","counters":[]},{"line":"  val forget : t -> T.t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Valid :","counters":[]},{"line":"  Valid_intf","counters":[]},{"line":"    with type Stable.V1.t = Mina_wire_types.Mina_base.Zkapp_command.Valid.V1.t =","counters":[]},{"line":"struct","counters":[]},{"line":"  module S = Stable","counters":[]},{"line":"","counters":[]},{"line":"  module Verification_key_hash = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type t = Zkapp_basic.F.Stable.V1.t","counters":[{"col_start":8,"col_end":8,"count":2},{"col_start":13,"col_end":13,"count":1},{"col_start":17,"col_end":17,"count":0}]},{"line":"        [@@deriving sexp, compare, equal, hash, yojson]","counters":[{"col_start":54,"col_end":54,"count":5}]},{"line":"","counters":[]},{"line":"        let to_latest = Fn.id","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type t = Mina_wire_types.Mina_base.Zkapp_command.Valid.V1.t =","counters":[{"col_start":6,"col_end":6,"count":2},{"col_start":11,"col_end":11,"count":2}]},{"line":"        { zkapp_command : S.V1.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"        ; verification_keys :","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"            (Account_id.Stable.V2.t * Verification_key_hash.Stable.V1.t) list","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":70,"col_end":70,"count":0},{"col_start":76,"col_end":76,"count":0}]},{"line":"        }","counters":[]},{"line":"      [@@deriving sexp, compare, equal, hash, yojson]","counters":[{"col_start":52,"col_end":52,"count":5}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  let create ~verification_keys zkapp_command : t =","counters":[]},{"line":"    { zkapp_command; verification_keys }","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let of_verifiable (t : Verifiable.t) : t option =","counters":[]},{"line":"    let open Option.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let tbl = Account_id.Table.create () in","counters":[]},{"line":"    let%map () =","counters":[]},{"line":"      Call_forest.fold t.account_updates ~init:(Some ())","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"        ~f:(fun acc (p, vk_opt) ->","counters":[]},{"line":"          let%bind _ok = acc in","counters":[]},{"line":"          let account_id = Account_update.account_id p in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let%bind () =","counters":[]},{"line":"            match (p.authorization, p.body.authorization_kind) with","counters":[]},{"line":"            | None_given, None_given | Proof _, Proof | Signature _, Signature","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"              ->","counters":[]},{"line":"                Some ()","counters":[]},{"line":"            | _ ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                None","counters":[]},{"line":"          in","counters":[]},{"line":"          if Control.(Tag.equal Tag.Proof (Control.tag p.authorization)) then","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"            let%map { With_hash.hash; _ } = vk_opt in","counters":[]},{"line":"            Account_id.Table.update tbl account_id ~f:(fun _ -> hash)","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"          else acc )","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"    in","counters":[]},{"line":"    { zkapp_command = of_verifiable t","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"    ; verification_keys = Account_id.Table.to_alist tbl","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let to_valid_unsafe (t : T.t) :","counters":[]},{"line":"      [> `If_this_is_used_it_should_have_a_comment_justifying_it of t ] =","counters":[]},{"line":"    `If_this_is_used_it_should_have_a_comment_justifying_it","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (create t ~verification_keys:[])","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"","counters":[]},{"line":"  let forget (t : t) : T.t = t.zkapp_command","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"  let to_valid (t : T.t) ~ledger ~get ~location_of_account : t option =","counters":[]},{"line":"    let open Option.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let find_vk account_id =","counters":[]},{"line":"      let%bind location = location_of_account ledger account_id in","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"      let%bind (account : Account.t) = get ledger location in","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"      let%bind zkapp = account.zkapp in","counters":[]},{"line":"      zkapp.verification_key","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    in","counters":[]},{"line":"    let tbl = Account_id.Table.create () in","counters":[]},{"line":"    let%map () =","counters":[]},{"line":"      Call_forest.fold t.account_updates ~init:(Some ()) ~f:(fun acc p ->","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"          let%bind _ok = acc in","counters":[]},{"line":"          let account_id = Account_update.account_id p in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          if Control.(Tag.equal Tag.Proof (Control.tag p.authorization)) then","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"            Option.map (find_vk account_id) ~f:(fun vk ->","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"                Account_id.Table.update tbl account_id ~f:(fun _ ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                    With_hash.hash vk ) )","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"          else acc )","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"    in","counters":[]},{"line":"    create ~verification_keys:(Account_id.Table.to_alist tbl) t","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"[%%define_locally Stable.Latest.(of_yojson, to_yojson)]","counters":[]},{"line":"","counters":[]},{"line":"(* so transaction ids have a version tag *)","counters":[]},{"line":"include Codable.Make_base64 (Stable.Latest.With_top_version_tag)","counters":[]},{"line":"","counters":[]},{"line":"type account_updates =","counters":[]},{"line":"  (Account_update.t, Digest.Account_update.t, Digest.Forest.t) Call_forest.t","counters":[]},{"line":"","counters":[]},{"line":"let account_updates_deriver obj =","counters":[]},{"line":"  let of_zkapp_command_with_depth (ps : Account_update.Graphql_repr.t list) :","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      account_updates =","counters":[]},{"line":"    Call_forest.of_account_updates ps","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"      ~account_update_depth:(fun (p : Account_update.Graphql_repr.t) ->","counters":[]},{"line":"        p.body.call_depth )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    |> Call_forest.map ~f:Account_update.of_graphql_repr","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"    |> Call_forest.accumulate_hashes'","counters":[]},{"line":"  and to_zkapp_command_with_depth (ps : account_updates) :","counters":[]},{"line":"      Account_update.Graphql_repr.t list =","counters":[]},{"line":"    ps","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    |> Call_forest.to_account_updates_map ~f:(fun ~depth p ->","counters":[]},{"line":"           Account_update.to_graphql_repr ~call_depth:depth p )","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"  in","counters":[]},{"line":"  let open Fields_derivers_zkapps.Derivers in","counters":[]},{"line":"  let inner = (list @@ Account_update.Graphql_repr.deriver @@ o ()) @@ o () in","counters":[{"col_start":57,"col_end":57,"count":0},{"col_start":62,"col_end":62,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"  iso ~map:of_zkapp_command_with_depth ~contramap:to_zkapp_command_with_depth","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    inner obj","counters":[]},{"line":"","counters":[]},{"line":"let deriver obj =","counters":[]},{"line":"  let open Fields_derivers_zkapps.Derivers in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let ( !. ) = ( !. ) ~t_fields_annots in","counters":[]},{"line":"  Fields.make_creator obj","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"    ~fee_payer:!.Account_update.Fee_payer.deriver","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"    ~account_updates:!.account_updates_deriver","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"    ~memo:!.Signed_command_memo.deriver","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"  |> finish \"ZkappCommand\" ~t_toplevel_annots","counters":[]},{"line":"","counters":[]},{"line":"let arg_typ () = Fields_derivers_zkapps.(arg_typ (deriver @@ Derivers.o ()))","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":56,"col_end":56,"count":0},{"col_start":70,"col_end":70,"count":0}]},{"line":"","counters":[]},{"line":"let typ () = Fields_derivers_zkapps.(typ (deriver @@ Derivers.o ()))","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":48,"col_end":48,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"","counters":[]},{"line":"let to_json x = Fields_derivers_zkapps.(to_json (deriver @@ Derivers.o ())) x","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":46,"col_end":46,"count":0},{"col_start":55,"col_end":55,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"","counters":[]},{"line":"let of_json x = Fields_derivers_zkapps.(of_json (deriver @@ Derivers.o ())) x","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":46,"col_end":46,"count":0},{"col_start":55,"col_end":55,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"","counters":[]},{"line":"let account_updates_of_json x =","counters":[]},{"line":"  Fields_derivers_zkapps.(","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    of_json","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"      ((list @@ Account_update.Graphql_repr.deriver @@ o ()) @@ derivers ()))","counters":[{"col_start":50,"col_end":50,"count":0},{"col_start":55,"col_end":55,"count":0},{"col_start":59,"col_end":59,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"    x","counters":[]},{"line":"","counters":[]},{"line":"let zkapp_command_to_json x =","counters":[]},{"line":"  Fields_derivers_zkapps.(to_json (deriver @@ derivers ())) x","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"","counters":[]},{"line":"let arg_query_string x =","counters":[]},{"line":"  Fields_derivers_zkapps.Test.Loop.json_to_string_gql @@ to_json x","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"","counters":[]},{"line":"let dummy =","counters":[]},{"line":"  let account_update : Account_update.t =","counters":[]},{"line":"    { body = Account_update.Body.dummy","counters":[]},{"line":"    ; authorization = Control.dummy_of_tag Signature","counters":[{"col_start":41,"col_end":41,"count":1}]},{"line":"    }","counters":[]},{"line":"  in","counters":[]},{"line":"  let fee_payer : Account_update.Fee_payer.t =","counters":[]},{"line":"    { body = Account_update.Body.Fee_payer.dummy","counters":[]},{"line":"    ; authorization = Signature.dummy","counters":[]},{"line":"    }","counters":[]},{"line":"  in","counters":[]},{"line":"  { fee_payer","counters":[]},{"line":"  ; account_updates = Call_forest.cons account_update []","counters":[{"col_start":37,"col_end":37,"count":1}]},{"line":"  ; memo = Signed_command_memo.empty","counters":[]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"module Make_update_group (Input : sig","counters":[]},{"line":"  type global_state","counters":[]},{"line":"","counters":[]},{"line":"  type local_state","counters":[]},{"line":"","counters":[]},{"line":"  type spec","counters":[]},{"line":"","counters":[]},{"line":"  val zkapp_segment_of_controls : Control.t list -> spec","counters":[]},{"line":"end) : sig","counters":[]},{"line":"  module Zkapp_command_intermediate_state : sig","counters":[]},{"line":"    type state = { global : Input.global_state; local : Input.local_state }","counters":[]},{"line":"","counters":[]},{"line":"    type t =","counters":[]},{"line":"      { kind : [ `Same | `New | `Two_new ]","counters":[]},{"line":"      ; spec : Input.spec","counters":[]},{"line":"      ; state_before : state","counters":[]},{"line":"      ; state_after : state","counters":[]},{"line":"      }","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  val group_by_zkapp_command_rev :","counters":[]},{"line":"       Account_update.t list list","counters":[]},{"line":"    -> (Input.global_state * Input.local_state) list list","counters":[]},{"line":"    -> Zkapp_command_intermediate_state.t list","counters":[]},{"line":"end = struct","counters":[]},{"line":"  open Input","counters":[]},{"line":"","counters":[]},{"line":"  module Zkapp_command_intermediate_state = struct","counters":[]},{"line":"    type state = { global : global_state; local : local_state }","counters":[]},{"line":"","counters":[]},{"line":"    type t =","counters":[]},{"line":"      { kind : [ `Same | `New | `Two_new ]","counters":[]},{"line":"      ; spec : spec","counters":[]},{"line":"      ; state_before : state","counters":[]},{"line":"      ; state_after : state","counters":[]},{"line":"      }","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  (** [group_by_zkapp_command_rev zkapp_commands stmtss] identifies before/after pairs of","counters":[]},{"line":"    statements, corresponding to zkapp_command in [zkapp_commands] which minimize the","counters":[]},{"line":"    number of snark proofs needed to prove all of the zkapp_command.","counters":[]},{"line":"","counters":[]},{"line":"    This function is intended to take the zkapp_command from multiple transactions as","counters":[]},{"line":"    its input, which may be converted from a [Zkapp_command.t list] using","counters":[]},{"line":"    [List.map ~f:Zkapp_command.zkapp_command]. The [stmtss] argument should be a list of","counters":[]},{"line":"    the same length, with 1 more state than the number of zkapp_command for each","counters":[]},{"line":"    transaction.","counters":[]},{"line":"","counters":[]},{"line":"    For example, two transactions made up of zkapp_command [[p1; p2; p3]] and","counters":[]},{"line":"    [[p4; p5]] should have the statements [[[s0; s1; s2; s3]; [s3; s4; s5]]],","counters":[]},{"line":"    where each [s_n] is the state after applying [p_n] on top of [s_{n-1}], and","counters":[]},{"line":"    where [s0] is the initial state before any of the transactions have been","counters":[]},{"line":"    applied.","counters":[]},{"line":"","counters":[]},{"line":"    Each pair is also identified with one of [`Same], [`New], or [`Two_new],","counters":[]},{"line":"    indicating that the next one ([`New]) or next two ([`Two_new]) [Zkapp_command.t]s","counters":[]},{"line":"    will need to be passed as part of the snark witness while applying that","counters":[]},{"line":"    pair.","counters":[]},{"line":"*)","counters":[]},{"line":"  let group_by_zkapp_command_rev (zkapp_commands : Account_update.t list list)","counters":[]},{"line":"      (stmtss : (global_state * local_state) list list) :","counters":[]},{"line":"      Zkapp_command_intermediate_state.t list =","counters":[]},{"line":"    let intermediate_state ~kind ~spec ~before ~after =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      { Zkapp_command_intermediate_state.kind","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      ; spec","counters":[]},{"line":"      ; state_before = { global = fst before; local = snd before }","counters":[{"col_start":36,"col_end":36,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"      ; state_after = { global = fst after; local = snd after }","counters":[{"col_start":35,"col_end":35,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"      }","counters":[]},{"line":"    in","counters":[]},{"line":"    let rec group_by_zkapp_command_rev","counters":[]},{"line":"        (zkapp_commands : Account_update.t list list) stmtss acc =","counters":[]},{"line":"      match (zkapp_commands, stmtss) with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | ([] | [ [] ]), [ _ ] ->","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":9,"col_end":9,"count":0},{"col_start":14,"col_end":14,"count":0}]},{"line":"          (* We've associated statements with all given zkapp_command. *)","counters":[]},{"line":"          acc","counters":[]},{"line":"      | [ [ { authorization = a1; _ } ] ], [ [ before; after ] ] ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (* There are no later zkapp_command to pair this one with. Prove it on its","counters":[]},{"line":"             own.","counters":[]},{"line":"          *)","counters":[]},{"line":"          intermediate_state ~kind:`Same","counters":[]},{"line":"            ~spec:(zkapp_segment_of_controls [ a1 ])","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"            ~before ~after","counters":[]},{"line":"          :: acc","counters":[]},{"line":"      | [ []; [ { authorization = a1; _ } ] ], [ [ _ ]; [ before; after ] ] ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (* This account_update is part of a new transaction, and there are no later","counters":[]},{"line":"             zkapp_command to pair it with. Prove it on its own.","counters":[]},{"line":"          *)","counters":[]},{"line":"          intermediate_state ~kind:`New","counters":[]},{"line":"            ~spec:(zkapp_segment_of_controls [ a1 ])","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"            ~before ~after","counters":[]},{"line":"          :: acc","counters":[]},{"line":"      | ( ({ authorization = Proof _ as a1; _ } :: zkapp_command)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          :: zkapp_commands","counters":[]},{"line":"        , (before :: (after :: _ as stmts)) :: stmtss ) ->","counters":[]},{"line":"          (* This account_update contains a proof, don't pair it with other zkapp_command. *)","counters":[]},{"line":"          group_by_zkapp_command_rev","counters":[]},{"line":"            (zkapp_command :: zkapp_commands)","counters":[]},{"line":"            (stmts :: stmtss)","counters":[]},{"line":"            ( intermediate_state ~kind:`Same","counters":[]},{"line":"                ~spec:(zkapp_segment_of_controls [ a1 ])","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"                ~before ~after","counters":[]},{"line":"            :: acc )","counters":[]},{"line":"      | ( []","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          :: ({ authorization = Proof _ as a1; _ } :: zkapp_command)","counters":[]},{"line":"             :: zkapp_commands","counters":[]},{"line":"        , [ _ ] :: (before :: (after :: _ as stmts)) :: stmtss ) ->","counters":[]},{"line":"          (* This account_update is part of a new transaction, and contains a proof, don't","counters":[]},{"line":"             pair it with other zkapp_command.","counters":[]},{"line":"          *)","counters":[]},{"line":"          group_by_zkapp_command_rev","counters":[]},{"line":"            (zkapp_command :: zkapp_commands)","counters":[]},{"line":"            (stmts :: stmtss)","counters":[]},{"line":"            ( intermediate_state ~kind:`New","counters":[]},{"line":"                ~spec:(zkapp_segment_of_controls [ a1 ])","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"                ~before ~after","counters":[]},{"line":"            :: acc )","counters":[]},{"line":"      | ( ({ authorization = a1; _ }","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          :: ({ authorization = Proof _; _ } :: _ as zkapp_command) )","counters":[]},{"line":"          :: zkapp_commands","counters":[]},{"line":"        , (before :: (after :: _ as stmts)) :: stmtss ) ->","counters":[]},{"line":"          (* The next account_update contains a proof, don't pair it with this account_update. *)","counters":[]},{"line":"          group_by_zkapp_command_rev","counters":[]},{"line":"            (zkapp_command :: zkapp_commands)","counters":[]},{"line":"            (stmts :: stmtss)","counters":[]},{"line":"            ( intermediate_state ~kind:`Same","counters":[]},{"line":"                ~spec:(zkapp_segment_of_controls [ a1 ])","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"                ~before ~after","counters":[]},{"line":"            :: acc )","counters":[]},{"line":"      | ( ({ authorization = a1; _ } :: ([] as zkapp_command))","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          :: (({ authorization = Proof _; _ } :: _) :: _ as zkapp_commands)","counters":[]},{"line":"        , (before :: (after :: _ as stmts)) :: stmtss ) ->","counters":[]},{"line":"          (* The next account_update is in the next transaction and contains a proof,","counters":[]},{"line":"             don't pair it with this account_update.","counters":[]},{"line":"          *)","counters":[]},{"line":"          group_by_zkapp_command_rev","counters":[]},{"line":"            (zkapp_command :: zkapp_commands)","counters":[]},{"line":"            (stmts :: stmtss)","counters":[]},{"line":"            ( intermediate_state ~kind:`Same","counters":[]},{"line":"                ~spec:(zkapp_segment_of_controls [ a1 ])","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"                ~before ~after","counters":[]},{"line":"            :: acc )","counters":[]},{"line":"      | ( ({ authorization = (Signature _ | None_given) as a1; _ }","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"          :: { authorization = (Signature _ | None_given) as a2; _ }","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"             :: zkapp_command )","counters":[]},{"line":"          :: zkapp_commands","counters":[]},{"line":"        , (before :: _ :: (after :: _ as stmts)) :: stmtss ) ->","counters":[]},{"line":"          (* The next two zkapp_command do not contain proofs, and are within the same","counters":[]},{"line":"             transaction. Pair them.","counters":[]},{"line":"             Ok to get \"use_full_commitment\" of [a1] because neither of them","counters":[]},{"line":"             contain a proof.","counters":[]},{"line":"          *)","counters":[]},{"line":"          group_by_zkapp_command_rev","counters":[]},{"line":"            (zkapp_command :: zkapp_commands)","counters":[]},{"line":"            (stmts :: stmtss)","counters":[]},{"line":"            ( intermediate_state ~kind:`Same","counters":[]},{"line":"                ~spec:(zkapp_segment_of_controls [ a1; a2 ])","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"                ~before ~after","counters":[]},{"line":"            :: acc )","counters":[]},{"line":"      | ( []","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          :: ({ authorization = a1; _ }","counters":[]},{"line":"             :: ({ authorization = Proof _; _ } :: _ as zkapp_command) )","counters":[]},{"line":"             :: zkapp_commands","counters":[]},{"line":"        , [ _ ] :: (before :: (after :: _ as stmts)) :: stmtss ) ->","counters":[]},{"line":"          (* This account_update is in the next transaction, and the next account_update contains a","counters":[]},{"line":"             proof, don't pair it with this account_update.","counters":[]},{"line":"          *)","counters":[]},{"line":"          group_by_zkapp_command_rev","counters":[]},{"line":"            (zkapp_command :: zkapp_commands)","counters":[]},{"line":"            (stmts :: stmtss)","counters":[]},{"line":"            ( intermediate_state ~kind:`New","counters":[]},{"line":"                ~spec:(zkapp_segment_of_controls [ a1 ])","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"                ~before ~after","counters":[]},{"line":"            :: acc )","counters":[]},{"line":"      | ( []","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          :: ({ authorization = (Signature _ | None_given) as a1; _ }","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"             :: { authorization = (Signature _ | None_given) as a2; _ }","counters":[{"col_start":35,"col_end":35,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"                :: zkapp_command )","counters":[]},{"line":"             :: zkapp_commands","counters":[]},{"line":"        , [ _ ] :: (before :: _ :: (after :: _ as stmts)) :: stmtss ) ->","counters":[]},{"line":"          (* The next two zkapp_command do not contain proofs, and are within the same","counters":[]},{"line":"             new transaction. Pair them.","counters":[]},{"line":"             Ok to get \"use_full_commitment\" of [a1] because neither of them","counters":[]},{"line":"             contain a proof.","counters":[]},{"line":"          *)","counters":[]},{"line":"          group_by_zkapp_command_rev","counters":[]},{"line":"            (zkapp_command :: zkapp_commands)","counters":[]},{"line":"            (stmts :: stmtss)","counters":[]},{"line":"            ( intermediate_state ~kind:`New","counters":[]},{"line":"                ~spec:(zkapp_segment_of_controls [ a1; a2 ])","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"                ~before ~after","counters":[]},{"line":"            :: acc )","counters":[]},{"line":"      | ( [ { authorization = (Signature _ | None_given) as a1; _ } ]","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"          :: ({ authorization = (Signature _ | None_given) as a2; _ }","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"             :: zkapp_command )","counters":[]},{"line":"             :: zkapp_commands","counters":[]},{"line":"        , (before :: _after1) :: (_before2 :: (after :: _ as stmts)) :: stmtss )","counters":[]},{"line":"        ->","counters":[]},{"line":"          (* The next two zkapp_command do not contain proofs, and the second is within","counters":[]},{"line":"             a new transaction. Pair them.","counters":[]},{"line":"             Ok to get \"use_full_commitment\" of [a1] because neither of them","counters":[]},{"line":"             contain a proof.","counters":[]},{"line":"          *)","counters":[]},{"line":"          group_by_zkapp_command_rev","counters":[]},{"line":"            (zkapp_command :: zkapp_commands)","counters":[]},{"line":"            (stmts :: stmtss)","counters":[]},{"line":"            ( intermediate_state ~kind:`New","counters":[]},{"line":"                ~spec:(zkapp_segment_of_controls [ a1; a2 ])","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"                ~before ~after","counters":[]},{"line":"            :: acc )","counters":[]},{"line":"      | ( []","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          :: ({ authorization = a1; _ } :: zkapp_command)","counters":[]},{"line":"             :: (({ authorization = Proof _; _ } :: _) :: _ as zkapp_commands)","counters":[]},{"line":"        , [ _ ] :: (before :: ([ after ] as stmts)) :: (_ :: _ as stmtss) ) ->","counters":[]},{"line":"          (* The next transaction contains a proof, and this account_update is in a new","counters":[]},{"line":"             transaction, don't pair it with the next account_update.","counters":[]},{"line":"          *)","counters":[]},{"line":"          group_by_zkapp_command_rev","counters":[]},{"line":"            (zkapp_command :: zkapp_commands)","counters":[]},{"line":"            (stmts :: stmtss)","counters":[]},{"line":"            ( intermediate_state ~kind:`New","counters":[]},{"line":"                ~spec:(zkapp_segment_of_controls [ a1 ])","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"                ~before ~after","counters":[]},{"line":"            :: acc )","counters":[]},{"line":"      | ( []","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          :: [ { authorization = (Signature _ | None_given) as a1; _ } ]","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"             :: ({ authorization = (Signature _ | None_given) as a2; _ }","counters":[{"col_start":36,"col_end":36,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"                :: zkapp_command )","counters":[]},{"line":"                :: zkapp_commands","counters":[]},{"line":"        , [ _ ]","counters":[]},{"line":"          :: [ before; _after1 ]","counters":[]},{"line":"             :: (_before2 :: (after :: _ as stmts)) :: stmtss ) ->","counters":[]},{"line":"          (* The next two zkapp_command do not contain proofs, the first is within a","counters":[]},{"line":"             new transaction, and the second is within another new transaction.","counters":[]},{"line":"             Pair them.","counters":[]},{"line":"             Ok to get \"use_full_commitment\" of [a1] because neither of them","counters":[]},{"line":"             contain a proof.","counters":[]},{"line":"          *)","counters":[]},{"line":"          group_by_zkapp_command_rev","counters":[]},{"line":"            (zkapp_command :: zkapp_commands)","counters":[]},{"line":"            (stmts :: stmtss)","counters":[]},{"line":"            ( intermediate_state ~kind:`Two_new","counters":[]},{"line":"                ~spec:(zkapp_segment_of_controls [ a1; a2 ])","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"                ~before ~after","counters":[]},{"line":"            :: acc )","counters":[]},{"line":"      | [ [ { authorization = a1; _ } ] ], (before :: after :: _) :: _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (* This account_update is the final account_update given. Prove it on its own. *)","counters":[]},{"line":"          intermediate_state ~kind:`Same","counters":[]},{"line":"            ~spec:(zkapp_segment_of_controls [ a1 ])","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"            ~before ~after","counters":[]},{"line":"          :: acc","counters":[]},{"line":"      | ( [] :: [ { authorization = a1; _ } ] :: [] :: _","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        , [ _ ] :: (before :: after :: _) :: _ ) ->","counters":[]},{"line":"          (* This account_update is the final account_update given, in a new transaction. Prove it","counters":[]},{"line":"             on its own.","counters":[]},{"line":"          *)","counters":[]},{"line":"          intermediate_state ~kind:`New","counters":[]},{"line":"            ~spec:(zkapp_segment_of_controls [ a1 ])","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"            ~before ~after","counters":[]},{"line":"          :: acc","counters":[]},{"line":"      | _, [] ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          failwith \"group_by_zkapp_command_rev: No statements remaining\"","counters":[]},{"line":"      | ([] | [ [] ]), _ ->","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":9,"col_end":9,"count":0},{"col_start":14,"col_end":14,"count":0}]},{"line":"          failwith \"group_by_zkapp_command_rev: Unmatched statements remaining\"","counters":[]},{"line":"      | [] :: _, [] :: _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          failwith","counters":[]},{"line":"            \"group_by_zkapp_command_rev: No final statement for current \\","counters":[]},{"line":"             transaction\"","counters":[]},{"line":"      | [] :: _, (_ :: _ :: _) :: _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          failwith","counters":[]},{"line":"            \"group_by_zkapp_command_rev: Unmatched statements for current \\","counters":[]},{"line":"             transaction\"","counters":[]},{"line":"      | [] :: [ _ ] :: _, [ _ ] :: (_ :: _ :: _ :: _) :: _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          failwith","counters":[]},{"line":"            \"group_by_zkapp_command_rev: Unmatched statements for next \\","counters":[]},{"line":"             transaction\"","counters":[]},{"line":"      | [ []; [ _ ] ], [ _ ] :: [ _; _ ] :: _ :: _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          failwith","counters":[]},{"line":"            \"group_by_zkapp_command_rev: Unmatched statements after next \\","counters":[]},{"line":"             transaction\"","counters":[]},{"line":"      | (_ :: _) :: _, ([] | [ _ ]) :: _ | (_ :: _ :: _) :: _, [ _; _ ] :: _ ->","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"          failwith","counters":[]},{"line":"            \"group_by_zkapp_command_rev: Too few statements remaining for the \\","counters":[]},{"line":"             current transaction\"","counters":[]},{"line":"      | ([] | [ _ ]) :: [] :: _, _ ->","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":9,"col_end":9,"count":0},{"col_start":14,"col_end":14,"count":0}]},{"line":"          failwith","counters":[]},{"line":"            \"group_by_zkapp_command_rev: The next transaction has no \\","counters":[]},{"line":"             zkapp_command\"","counters":[]},{"line":"      | [] :: (_ :: _) :: _, _ :: ([] | [ _ ]) :: _","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"      | [] :: (_ :: _ :: _) :: _, _ :: [ _; _ ] :: _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          failwith","counters":[]},{"line":"            \"group_by_zkapp_command_rev: Too few statements remaining for the \\","counters":[]},{"line":"             next transaction\"","counters":[]},{"line":"      | [ _ ] :: (_ :: _) :: _, _ :: ([] | [ _ ]) :: _ ->","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"          failwith","counters":[]},{"line":"            \"group_by_zkapp_command_rev: Too few statements remaining for the \\","counters":[]},{"line":"             next transaction\"","counters":[]},{"line":"      | [] :: [ _ ] :: (_ :: _) :: _, _ :: _ :: ([] | [ _ ]) :: _ ->","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":49,"col_end":49,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"          failwith","counters":[]},{"line":"            \"group_by_zkapp_command_rev: Too few statements remaining for the \\","counters":[]},{"line":"             transaction after next\"","counters":[]},{"line":"      | ([] | [ _ ]) :: (_ :: _) :: _, [ _ ] ->","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":9,"col_end":9,"count":0},{"col_start":14,"col_end":14,"count":0}]},{"line":"          failwith","counters":[]},{"line":"            \"group_by_zkapp_command_rev: No statements given for the next \\","counters":[]},{"line":"             transaction\"","counters":[]},{"line":"      | [] :: [ _ ] :: (_ :: _) :: _, [ _; _ :: _ :: _ ] ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          failwith","counters":[]},{"line":"            \"group_by_zkapp_command_rev: No statements given for transaction \\","counters":[]},{"line":"             after next\"","counters":[]},{"line":"    in","counters":[]},{"line":"    group_by_zkapp_command_rev zkapp_commands stmtss []","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(*Transaction_snark.Zkapp_command_segment.Basic.t*)","counters":[]},{"line":"type possible_segments = Proved | Signed_single | Signed_pair","counters":[]},{"line":"","counters":[]},{"line":"module Update_group = Make_update_group (struct","counters":[]},{"line":"  type local_state = unit","counters":[]},{"line":"","counters":[]},{"line":"  type global_state = unit","counters":[]},{"line":"","counters":[]},{"line":"  type spec = possible_segments","counters":[]},{"line":"","counters":[]},{"line":"  let zkapp_segment_of_controls controls : spec =","counters":[]},{"line":"    match controls with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | [ Control.Proof _ ] ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Proved","counters":[]},{"line":"    | [ (Control.Signature _ | Control.None_given) ] ->","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":9,"col_end":9,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"        Signed_single","counters":[]},{"line":"    | [ Control.(Signature _ | None_given); Control.(Signature _ | None_given) ]","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":53,"col_end":53,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"      ->","counters":[]},{"line":"        Signed_pair","counters":[]},{"line":"    | _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        failwith \"zkapp_segment_of_controls: Unsupported combination\"","counters":[]},{"line":"end)","counters":[]},{"line":"","counters":[]},{"line":"(* Zkapp_command transactions are filtered using this predicate","counters":[]},{"line":"   - when adding to the transaction pool","counters":[]},{"line":"   - in incoming blocks","counters":[]},{"line":"*)","counters":[]},{"line":"let valid_size ~(genesis_constants : Genesis_constants.t) (t : t) :","counters":[]},{"line":"    unit Or_error.t =","counters":[]},{"line":"  let events_elements events =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    List.fold events ~init:0 ~f:(fun acc event -> acc + Array.length event)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":50,"col_end":50,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"  in","counters":[]},{"line":"  let all_updates, num_event_elements, num_sequence_event_elements =","counters":[]},{"line":"    Call_forest.fold t.account_updates","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"      ~init:([ Account_update.of_fee_payer (fee_payer_account_update t) ], 0, 0)","counters":[{"col_start":41,"col_end":41,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"      ~f:(fun (acc, num_event_elements, num_sequence_event_elements)","counters":[]},{"line":"              (account_update : Account_update.t) ->","counters":[]},{"line":"        let account_update_evs_elements =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          events_elements account_update.body.events","counters":[]},{"line":"        in","counters":[]},{"line":"        let account_update_seq_evs_elements =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          events_elements account_update.body.sequence_events","counters":[]},{"line":"        in","counters":[]},{"line":"        ( account_update :: acc","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        , num_event_elements + account_update_evs_elements","counters":[]},{"line":"        , num_sequence_event_elements + account_update_seq_evs_elements ) )","counters":[]},{"line":"    |> fun (updates, ev, sev) -> (List.rev updates, ev, sev)","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"  in","counters":[]},{"line":"  let groups =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Update_group.group_by_zkapp_command_rev ([] :: [ all_updates ])","counters":[]},{"line":"      ( [ ((), ()) ]","counters":[]},{"line":"      :: [ ((), ()) :: List.map all_updates ~f:(fun _ -> ((), ())) ] )","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"  in","counters":[]},{"line":"  let proof_segments, signed_singles, signed_pairs =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    List.fold ~init:(0, 0, 0) groups","counters":[]},{"line":"      ~f:(fun (proof_segments, signed_singles, signed_pairs) { spec; _ } ->","counters":[]},{"line":"        match spec with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | Proved ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (proof_segments + 1, signed_singles, signed_pairs)","counters":[]},{"line":"        | Signed_single ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (proof_segments, signed_singles + 1, signed_pairs)","counters":[]},{"line":"        | Signed_pair ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (proof_segments, signed_singles, signed_pairs + 1) )","counters":[]},{"line":"  in","counters":[]},{"line":"  let proof_cost = genesis_constants.zkapp_proof_update_cost in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let signed_pair_cost = genesis_constants.zkapp_signed_pair_update_cost in","counters":[]},{"line":"  let signed_single_cost = genesis_constants.zkapp_signed_single_update_cost in","counters":[]},{"line":"  let cost_limit = genesis_constants.zkapp_transaction_cost_limit in","counters":[]},{"line":"  let max_event_elements = genesis_constants.max_event_elements in","counters":[]},{"line":"  let max_sequence_event_elements =","counters":[]},{"line":"    genesis_constants.max_sequence_event_elements","counters":[]},{"line":"  in","counters":[]},{"line":"  (*10.26*np + 10.08*n2 + 9.14*n1 < 69.45*)","counters":[]},{"line":"  let zkapp_cost_within_limit =","counters":[]},{"line":"    Float.(","counters":[]},{"line":"      (proof_cost * of_int proof_segments)","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"      + (signed_pair_cost * of_int signed_pairs)","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"      + (signed_single_cost * of_int signed_singles)","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"      < cost_limit)","counters":[]},{"line":"  in","counters":[]},{"line":"  let valid_event_elements = num_event_elements <= max_event_elements in","counters":[]},{"line":"  let valid_sequence_event_elements =","counters":[]},{"line":"    num_sequence_event_elements <= max_sequence_event_elements","counters":[]},{"line":"  in","counters":[]},{"line":"  if","counters":[]},{"line":"    zkapp_cost_within_limit && valid_event_elements","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"    && valid_sequence_event_elements","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"  then Ok ()","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"  else","counters":[]},{"line":"    let proof_zkapp_command_err =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      if zkapp_cost_within_limit then None","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"      else Some (sprintf \"zkapp transaction too expensive\")","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"    in","counters":[]},{"line":"    let events_err =","counters":[]},{"line":"      if valid_event_elements then None","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"      else","counters":[]},{"line":"        Some","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (sprintf \"too many event elements (%d, max allowed is %d)\"","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"             num_event_elements max_event_elements )","counters":[]},{"line":"    in","counters":[]},{"line":"    let sequence_events_err =","counters":[]},{"line":"      if valid_sequence_event_elements then None","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"      else","counters":[]},{"line":"        Some","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (sprintf \"too many sequence event elements (%d, max allowed is %d)\"","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"             num_sequence_event_elements max_sequence_event_elements )","counters":[]},{"line":"    in","counters":[]},{"line":"    let err_msg =","counters":[]},{"line":"      List.filter","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"        [ proof_zkapp_command_err; events_err; sequence_events_err ]","counters":[]},{"line":"        ~f:Option.is_some","counters":[]},{"line":"      |> List.map ~f:(fun opt -> Option.value_exn opt)","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"      |> String.concat ~sep:\"; \"","counters":[]},{"line":"    in","counters":[]},{"line":"    Error (Error.of_string err_msg)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"let inner_query =","counters":[]},{"line":"  lazy","counters":[]},{"line":"    (Option.value_exn ~message:\"Invariant: All projectable derivers are Some\"","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"       Fields_derivers_zkapps.(inner_query (deriver @@ Derivers.o ())) )","counters":[{"col_start":41,"col_end":41,"count":0},{"col_start":50,"col_end":50,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"","counters":[]},{"line":"let%test_module \"Test\" =","counters":[]},{"line":"  ( module struct","counters":[]},{"line":"    module Fd = Fields_derivers_zkapps.Derivers","counters":[]},{"line":"","counters":[]},{"line":"    let full = deriver @@ Fd.o ()","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"json roundtrip dummy\" =","counters":[]},{"line":"      [%test_eq: t] dummy (dummy |> Fd.to_json full |> Fd.of_json full)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"full circuit\" =","counters":[]},{"line":"      Run_in_thread.block_on_async_exn","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      @@ fun () -> Fields_derivers_zkapps.Test.Loop.run full dummy","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"","counters":[]},{"line":"    let%test \"latest zkApp version\" =","counters":[]},{"line":"      (* if this test fails, update `Transaction_hash.hash_of_transaction_id`","counters":[]},{"line":"         for latest version, then update this test","counters":[]},{"line":"      *)","counters":[]},{"line":"      Stable.Latest.version = 1","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  end )","counters":[{"col_start":6,"col_end":6,"count":1}]}]}