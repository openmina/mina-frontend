{"filename":"src/lib/network_pool/snark_pool_diff.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Async_kernel","counters":[]},{"line":"module Work = Transaction_snark_work.Statement","counters":[]},{"line":"module Ledger_proof = Ledger_proof","counters":[]},{"line":"module Work_info = Transaction_snark_work.Info","counters":[]},{"line":"open Network_peer","counters":[]},{"line":"","counters":[]},{"line":"module Rejected = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    [@@@no_toplevel_latest_type]","counters":[]},{"line":"","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type t = unit [@@deriving sexp, yojson]","counters":[{"col_start":6,"col_end":6,"count":2},{"col_start":11,"col_end":11,"count":1},{"col_start":15,"col_end":15,"count":0},{"col_start":44,"col_end":44,"count":5}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  type t = Stable.Latest.t [@@deriving sexp, yojson]","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":11,"col_end":11,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make","counters":[]},{"line":"    (Transition_frontier : T)","counters":[]},{"line":"    (Pool : Intf.Snark_resource_pool_intf","counters":[]},{"line":"              with type transition_frontier := Transition_frontier.t) :","counters":[]},{"line":"  Intf.Snark_pool_diff_intf with type resource_pool := Pool.t = struct","counters":[]},{"line":"  type t = Mina_wire_types.Network_pool.Snark_pool.Diff_versioned.V2.t =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    | Add_solved_work of Work.t * Ledger_proof.t One_or_two.t Priced_proof.t","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":49,"col_end":49,"count":0},{"col_start":75,"col_end":75,"count":0}]},{"line":"    | Empty","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  [@@deriving compare, sexp, to_yojson, hash]","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"  type verified = t [@@deriving compare, sexp, to_yojson]","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"","counters":[]},{"line":"  type rejected = Rejected.t [@@deriving sexp, yojson]","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"","counters":[]},{"line":"  let reject_overloaded_diff _ = ()","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"","counters":[]},{"line":"  type compact =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    { work : Work.t","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"    ; fee : Currency.Fee.t","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":12,"col_end":12,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"    ; prover : Signature_lib.Public_key.Compressed.t","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"    }","counters":[]},{"line":"  [@@deriving yojson, hash]","counters":[]},{"line":"","counters":[]},{"line":"  let to_compact = function","counters":[]},{"line":"    | Add_solved_work (work, { proof = _; fee = { fee; prover } }) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Some { work; fee; prover }","counters":[]},{"line":"    | Empty ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        None","counters":[]},{"line":"","counters":[]},{"line":"  let compact_json t = to_compact t |> Option.map ~f:compact_to_yojson","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"","counters":[]},{"line":"  let empty = Empty","counters":[]},{"line":"","counters":[]},{"line":"  (* snark pool diffs are not bundled, so size is always 1 *)","counters":[]},{"line":"  let size _ = 1","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"","counters":[]},{"line":"  let score = function","counters":[]},{"line":"    | Add_solved_work (_w, p) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        One_or_two.length p.proof","counters":[]},{"line":"    | Empty ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        1","counters":[]},{"line":"","counters":[]},{"line":"  let max_per_15_seconds = 20","counters":[]},{"line":"","counters":[]},{"line":"  let summary = function","counters":[]},{"line":"    | Add_solved_work (work, { proof = _; fee }) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Printf.sprintf","counters":[]},{"line":"          !\"Snark_pool_diff for work %s added with fee-prover %s\"","counters":[]},{"line":"          (Yojson.Safe.to_string @@ Work.compact_json work)","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"          (Yojson.Safe.to_string @@ Mina_base.Fee_with_prover.to_yojson fee)","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":70,"col_end":70,"count":0}]},{"line":"    | Empty ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        \"empty Snark_pool_diff\"","counters":[]},{"line":"","counters":[]},{"line":"  let is_empty _ = false","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"","counters":[]},{"line":"  let of_result","counters":[]},{"line":"      (res :","counters":[]},{"line":"        ( (_, _) Snark_work_lib.Work.Single.Spec.t Snark_work_lib.Work.Spec.t","counters":[]},{"line":"        , Ledger_proof.t )","counters":[]},{"line":"        Snark_work_lib.Work.Result.t ) =","counters":[]},{"line":"    Add_solved_work","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ( One_or_two.map res.spec.instances","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"          ~f:Snark_work_lib.Work.Single.Spec.statement","counters":[]},{"line":"      , { proof = res.proofs","counters":[]},{"line":"        ; fee = { fee = res.spec.fee; prover = res.prover }","counters":[]},{"line":"        } )","counters":[]},{"line":"","counters":[]},{"line":"  let has_lower_fee pool work ~fee ~sender =","counters":[]},{"line":"    let reject_and_log_if_local reason =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      [%log' trace (Pool.get_logger pool)]","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"        \"Rejecting snark work $work from $sender: $reason\"","counters":[]},{"line":"        ~metadata:","counters":[]},{"line":"          [ (\"work\", Work.compact_json work)","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"          ; (\"sender\", Envelope.Sender.to_yojson sender)","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"          ; (\"reason\", `String reason)","counters":[]},{"line":"          ] ;","counters":[]},{"line":"      Or_error.error_string reason","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    in","counters":[]},{"line":"    match Pool.request_proof pool work with","counters":[]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Ok ()","counters":[]},{"line":"    | Some { fee = { fee = prev; _ }; _ } -> (","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        match Currency.Fee.compare fee prev with","counters":[]},{"line":"        | -1 ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Ok ()","counters":[]},{"line":"        | 0 ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            reject_and_log_if_local \"fee equal to cheapest work we have\"","counters":[]},{"line":"        | 1 ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            reject_and_log_if_local \"fee higher than cheapest work we have\"","counters":[]},{"line":"        | _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            failwith \"compare didn't return -1, 0, or 1!\" )","counters":[]},{"line":"","counters":[]},{"line":"  let verify pool ({ data; sender; _ } as t : t Envelope.Incoming.t) =","counters":[]},{"line":"    match data with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Empty ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Deferred.Or_error.error_string \"cannot verify empty snark pool diff\"","counters":[]},{"line":"    | Add_solved_work (work, ({ Priced_proof.fee; _ } as p)) -> (","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let is_local = match sender with Local -> true | _ -> false in","counters":[{"col_start":41,"col_end":41,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"        let verify () =","counters":[]},{"line":"          if%map Pool.verify_and_act pool ~work:(work, p) ~sender then","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"            Or_error.return t","counters":[]},{"line":"          else Or_error.error_string \"failed to verify snark pool diff\"","counters":[]},{"line":"        in","counters":[]},{"line":"        (*reject higher priced gossiped proofs*)","counters":[]},{"line":"        if is_local then verify ()","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"        else","counters":[]},{"line":"          match has_lower_fee pool work ~fee:fee.fee ~sender with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | Ok () ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              verify ()","counters":[]},{"line":"          | Error e ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Deferred.return (Error e) )","counters":[]},{"line":"","counters":[]},{"line":"  (* This is called after verification has occurred.*)","counters":[]},{"line":"  let unsafe_apply (pool : Pool.t) (t : t Envelope.Incoming.t) =","counters":[]},{"line":"    let { Envelope.Incoming.data = diff; sender; _ } = t in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    match diff with","counters":[]},{"line":"    | Empty ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Deferred.return","counters":[]},{"line":"          (Error (`Other (Error.of_string \"cannot apply empty snark pool diff\")))","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"    | Add_solved_work (work, { Priced_proof.proof; fee }) -> (","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let is_local = match sender with Local -> true | _ -> false in","counters":[{"col_start":41,"col_end":41,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"        let to_or_error = function","counters":[]},{"line":"          | `Statement_not_referenced ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Error (`Other (Error.of_string \"statement not referenced\"))","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"          | `Added ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Ok (diff, ())","counters":[]},{"line":"        in","counters":[]},{"line":"        match has_lower_fee pool work ~fee:fee.fee ~sender with","counters":[]},{"line":"        | Ok () ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let%map.Deferred.Result accepted, rejected =","counters":[]},{"line":"              Pool.add_snark ~is_local pool ~work ~proof ~fee >>| to_or_error","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"            in","counters":[]},{"line":"            (`Accept, accepted, rejected)","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"        | Error e ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Deferred.return","counters":[]},{"line":"              ( if is_local then Error (`Locally_generated (diff, ()))","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"              else Error (`Other e) ) )","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"","counters":[]},{"line":"  type Structured_log_events.t +=","counters":[]},{"line":"    | Snark_work_received of { work : compact; sender : Envelope.Sender.t }","counters":[{"col_start":38,"col_end":38,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":56,"col_end":56,"count":0},{"col_start":72,"col_end":72,"count":0}]},{"line":"    [@@deriving","counters":[]},{"line":"      register_event { msg = \"Received Snark-pool diff $work from $sender\" }]","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":19,"col_end":19,"count":3}]},{"line":"","counters":[]},{"line":"  let update_metrics envelope valid_cb gossip_heard_logger_option =","counters":[]},{"line":"    Mina_metrics.(Counter.inc_one Network.gossip_messages_received) ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"    Mina_metrics.(Gauge.inc_one Network.snark_pool_diff_received) ;","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"    let diff = Envelope.Incoming.data envelope in","counters":[]},{"line":"    Option.iter gossip_heard_logger_option ~f:(fun logger ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        Option.iter (to_compact diff) ~f:(fun work ->","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"            [%str_log debug]","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"              (Snark_work_received","counters":[]},{"line":"                 { work; sender = Envelope.Incoming.sender envelope } ) ) ) ;","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"    Mina_metrics.(Counter.inc_one Network.Snark_work.received) ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"    Mina_net2.Validation_callback.set_message_type valid_cb `Snark_work","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":1}]}]}