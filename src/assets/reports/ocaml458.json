{"filename":"src/lib/non_zero_curve_point/non_zero_curve_point.ml","lines":[{"line":"[%%import \"/src/config.mlh\"]","counters":[]},{"line":"","counters":[{"col_start":0,"col_end":0,"count":1}]},{"line":"open Core_kernel","counters":[]},{"line":"open Snark_params.Tick","counters":[]},{"line":"","counters":[]},{"line":"[%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"let parity y = Bigint.(test_bit (of_field y) 0)","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"[%%else]","counters":[]},{"line":"","counters":[]},{"line":"let parity y = Field.parity y","counters":[]},{"line":"","counters":[]},{"line":"[%%endif]","counters":[]},{"line":"","counters":[]},{"line":"let gen_uncompressed =","counters":[]},{"line":"  Quickcheck.Generator.filter_map Field.gen_uniform ~f:(fun x ->","counters":[{"col_start":32,"col_end":32,"count":1}]},{"line":"      let open Option.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%map y = Inner_curve.find_y x in","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"      (x, y) )","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"module Compressed = struct","counters":[]},{"line":"  open Compressed_poly","counters":[]},{"line":"","counters":[]},{"line":"  module Arg = struct","counters":[]},{"line":"    (* module with same type t as Stable below, to build functor argument *)","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"      module V1 = struct","counters":[]},{"line":"        [@@@with_all_version_tags]","counters":[]},{"line":"","counters":[]},{"line":"        type t = ((Field.t[@version_asserted]), bool) Poly.Stable.V1.t","counters":[{"col_start":8,"col_end":8,"count":4},{"col_start":13,"col_end":13,"count":2},{"col_start":69,"col_end":69,"count":15}]},{"line":"","counters":[]},{"line":"        let to_latest = Fn.id","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let compress (x, y) = { Poly.x; is_odd = parity y }","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"    module V1 = struct","counters":[]},{"line":"      [@@@with_all_version_tags]","counters":[]},{"line":"","counters":[]},{"line":"      module T = struct","counters":[{"col_start":6,"col_end":6,"count":4}]},{"line":"        type t = ((Field.t[@version_asserted]), bool) Poly.Stable.V1.t","counters":[{"col_start":8,"col_end":8,"count":1787},{"col_start":13,"col_end":13,"count":2},{"col_start":19,"col_end":19,"count":0},{"col_start":48,"col_end":48,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"        [@@deriving equal, compare, hash]","counters":[]},{"line":"","counters":[]},{"line":"        let to_latest = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"        module M = struct","counters":[]},{"line":"          (* for compatibility with legacy Base58Check serialization *)","counters":[]},{"line":"          include Arg.Stable.V1.With_all_version_tags","counters":[]},{"line":"","counters":[]},{"line":"          let description = \"Non zero curve point compressed\"","counters":[]},{"line":"","counters":[]},{"line":"          let version_byte =","counters":[]},{"line":"            Base58_check.Version_bytes.non_zero_curve_point_compressed","counters":[]},{"line":"        end","counters":[]},{"line":"","counters":[]},{"line":"        module Base58 = Codable.Make_base58_check (M)","counters":[]},{"line":"        include Base58","counters":[]},{"line":"","counters":[]},{"line":"        (* sexp representation is a Base58Check string, like the yojson representation *)","counters":[]},{"line":"        let sexp_of_t t = to_base58_check t |> Sexp.of_string","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"","counters":[]},{"line":"        let t_of_sexp sexp = Sexp.to_string sexp |> of_base58_check_exn","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"      end","counters":[{"col_start":8,"col_end":8,"count":15}]},{"line":"","counters":[]},{"line":"      include T","counters":[]},{"line":"      include Hashable.Make_binable (T)","counters":[]},{"line":"","counters":[]},{"line":"      let gen =","counters":[]},{"line":"        let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"        let%map uncompressed = gen_uncompressed in","counters":[]},{"line":"        compress uncompressed","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    end","counters":[]},{"line":"  end]","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  module Poly = Poly","counters":[]},{"line":"  include Comparable.Make_binable (Stable.Latest)","counters":[]},{"line":"  include Hashable.Make_binable (Stable.Latest)","counters":[]},{"line":"  include Stable.Latest.Base58","counters":[]},{"line":"","counters":[]},{"line":"  let to_string = to_base58_check","counters":[]},{"line":"","counters":[]},{"line":"  [%%define_locally Stable.Latest.(sexp_of_t, t_of_sexp, gen)]","counters":[]},{"line":"","counters":[]},{"line":"  let compress (x, y) = { Poly.x; is_odd = parity y }","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"","counters":[]},{"line":"  let empty = Poly.{ x = Field.zero; is_odd = false }","counters":[]},{"line":"","counters":[]},{"line":"  let to_input { Poly.x; is_odd } =","counters":[]},{"line":"    { Random_oracle.Input.Chunked.field_elements = [| x |]","counters":[{"col_start":4,"col_end":4,"count":20}]},{"line":"    ; packeds = [| (Field.project [ is_odd ], 1) |]","counters":[{"col_start":32,"col_end":32,"count":20}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let to_input_legacy { Poly.x; is_odd } =","counters":[]},{"line":"    { Random_oracle.Input.Legacy.field_elements = [| x |]","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    ; bitstrings = [| [ is_odd ] |]","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  [%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"  (* snarky-dependent *)","counters":[]},{"line":"","counters":[]},{"line":"  type var = (Field.Var.t, Boolean.var) Poly.t","counters":[]},{"line":"","counters":[]},{"line":"  let typ : (var, t) Typ.t =","counters":[]},{"line":"    Typ.of_hlistable [ Field.typ; Boolean.typ ] ~var_to_hlist:Poly.to_hlist","counters":[{"col_start":19,"col_end":19,"count":1}]},{"line":"      ~var_of_hlist:Poly.of_hlist ~value_to_hlist:Poly.to_hlist","counters":[]},{"line":"      ~value_of_hlist:Poly.of_hlist","counters":[]},{"line":"","counters":[]},{"line":"  let var_of_t ({ x; is_odd } : t) : var =","counters":[]},{"line":"    { x = Field.Var.constant x; is_odd = Boolean.var_of_value is_odd }","counters":[{"col_start":4,"col_end":4,"count":1},{"col_start":27,"col_end":27,"count":1},{"col_start":60,"col_end":60,"count":1}]},{"line":"","counters":[]},{"line":"  let assert_equal (t1 : var) (t2 : var) =","counters":[]},{"line":"    let%map () = Field.Checked.Assert.equal t1.x t2.x","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"    and () = Boolean.Assert.(t1.is_odd = t2.is_odd) in","counters":[]},{"line":"    ()","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  module Checked = struct","counters":[]},{"line":"    let equal t1 t2 =","counters":[]},{"line":"      let%bind x_eq = Field.Checked.equal t1.Poly.x t2.Poly.x in","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"      let%bind odd_eq = Boolean.equal t1.is_odd t2.is_odd in","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"      Boolean.(x_eq && odd_eq)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"    let to_input ({ x; is_odd } : var) =","counters":[]},{"line":"      { Random_oracle.Input.Chunked.field_elements = [| x |]","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      ; packeds = [| ((is_odd :> Field.Var.t), 1) |]","counters":[]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    let to_input_legacy = to_input_legacy","counters":[]},{"line":"","counters":[]},{"line":"    let if_ cond ~then_:t1 ~else_:t2 =","counters":[]},{"line":"      let%map x = Field.Checked.if_ cond ~then_:t1.Poly.x ~else_:t2.Poly.x","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"      and is_odd = Boolean.if_ cond ~then_:t1.is_odd ~else_:t2.is_odd in","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"      Poly.{ x; is_odd }","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    module Assert = struct","counters":[]},{"line":"      let equal t1 t2 =","counters":[]},{"line":"        let%map () = Field.Checked.Assert.equal t1.Poly.x t2.Poly.x","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"        and () = Boolean.Assert.(t1.is_odd = t2.is_odd) in","counters":[]},{"line":"        ()","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    end","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  (* end snarky-dependent *)","counters":[]},{"line":"  [%%endif]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Uncompressed = struct","counters":[]},{"line":"  let decompress ({ x; is_odd } : Compressed.t) =","counters":[]},{"line":"    Option.map (Inner_curve.find_y x) ~f:(fun y ->","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"        let y_parity = parity y in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let y = if Bool.(is_odd = y_parity) then y else Field.negate y in","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":49,"col_end":49,"count":0},{"col_start":56,"col_end":56,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"        (x, y) )","counters":[]},{"line":"","counters":[]},{"line":"  let decompress_exn t =","counters":[]},{"line":"    match decompress t with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Some d ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        d","counters":[]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        failwith","counters":[]},{"line":"          (sprintf \"Compressed public key %s could not be decompressed\"","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"             (Yojson.Safe.to_string @@ Compressed.to_yojson t) )","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"","counters":[]},{"line":"  let of_base58_check_decompress_exn pk_str =","counters":[]},{"line":"    let pk = Compressed.of_base58_check_exn pk_str in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    decompress_exn pk |> ignore ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"    pk","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let compress = Compressed.compress","counters":[]},{"line":"","counters":[]},{"line":"  [%%versioned_binable","counters":[]},{"line":"  module Stable = struct","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"    module V1 = struct","counters":[]},{"line":"      [@@@with_all_version_tags]","counters":[]},{"line":"","counters":[]},{"line":"      type t = Field.t * Field.t [@@deriving compare, equal, hash]","counters":[{"col_start":6,"col_end":6,"count":2},{"col_start":15,"col_end":15,"count":0},{"col_start":65,"col_end":65,"count":7}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"      include","counters":[]},{"line":"        Binable.Of_binable_without_uuid","counters":[]},{"line":"          (Compressed.Stable.V1)","counters":[]},{"line":"          (struct","counters":[]},{"line":"            type nonrec t = t","counters":[]},{"line":"","counters":[]},{"line":"            let of_binable = decompress_exn","counters":[]},{"line":"","counters":[]},{"line":"            let to_binable = compress","counters":[]},{"line":"          end)","counters":[]},{"line":"","counters":[]},{"line":"      let gen : t Quickcheck.Generator.t = gen_uncompressed","counters":[]},{"line":"","counters":[]},{"line":"      let of_bigstring bs =","counters":[]},{"line":"        let open Or_error.Let_syntax in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let%map elem, _ = Bigstring.read_bin_prot bs bin_reader_t in","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"        elem","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      let to_bigstring elem =","counters":[]},{"line":"        let bs =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Bigstring.create (bin_size_t elem + Bin_prot.Utils.size_header_length)","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"        in","counters":[]},{"line":"        let _ = Bigstring.write_bin_prot bs bin_writer_t elem in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        bs","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      (* We reuse the Base58check-based yojson (de)serialization from the","counters":[]},{"line":"         compressed representation. *)","counters":[]},{"line":"","counters":[]},{"line":"      let of_yojson json =","counters":[]},{"line":"        let open Result in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Compressed.of_yojson json","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"        >>= fun compressed ->","counters":[]},{"line":"        Result.of_option ~error:\"couldn't decompress, curve point invalid\"","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (decompress compressed)","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"","counters":[]},{"line":"      let to_yojson t = Compressed.to_yojson @@ compress t","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"","counters":[]},{"line":"      (* as for yojson, use the Base58check-based sexps from the compressed representation *)","counters":[]},{"line":"      let sexp_of_t t = Compressed.sexp_of_t @@ compress t","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"","counters":[]},{"line":"      let t_of_sexp sexp =","counters":[]},{"line":"        Option.value_exn (decompress @@ Compressed.t_of_sexp sexp)","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"    end","counters":[]},{"line":"  end]","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  (* so we can make sets of public keys *)","counters":[]},{"line":"  include Comparable.Make_binable (Stable.Latest)","counters":[]},{"line":"","counters":[]},{"line":"  [%%define_locally","counters":[]},{"line":"  Stable.Latest.","counters":[]},{"line":"    (of_bigstring, to_bigstring, sexp_of_t, t_of_sexp, to_yojson, of_yojson)]","counters":[]},{"line":"","counters":[]},{"line":"  let gen : t Quickcheck.Generator.t = gen_uncompressed","counters":[]},{"line":"","counters":[]},{"line":"  let ( = ) = equal","counters":[]},{"line":"","counters":[]},{"line":"  let of_inner_curve_exn = Inner_curve.to_affine_exn","counters":[]},{"line":"","counters":[]},{"line":"  let to_inner_curve = Inner_curve.of_affine","counters":[]},{"line":"","counters":[]},{"line":"  let%test_unit \"point-compression: decompress . compress = id\" =","counters":[]},{"line":"    Quickcheck.test gen ~f:(fun pk ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        assert (equal (decompress_exn (compress pk)) pk) )","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"","counters":[]},{"line":"  [%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"  (* snarky-dependent *)","counters":[]},{"line":"","counters":[]},{"line":"  type var = Field.Var.t * Field.Var.t","counters":[]},{"line":"","counters":[]},{"line":"  let assert_equal var1 var2 =","counters":[]},{"line":"    let open Field.Checked.Assert in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let v1_f1, v1_f2 = var1 in","counters":[]},{"line":"    let v2_f1, v2_f2 = var2 in","counters":[]},{"line":"    let%bind () = equal v1_f1 v2_f1 in","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"    let%map () = equal v1_f2 v2_f2 in","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"    ()","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let var_of_t (x, y) = (Field.Var.constant x, Field.Var.constant y)","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":42,"col_end":42,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"","counters":[]},{"line":"  let typ : (var, t) Typ.t = Typ.(field * field)","counters":[]},{"line":"","counters":[]},{"line":"  let parity_var y =","counters":[]},{"line":"    let%map bs = Field.Checked.unpack_full y in","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"    List.hd_exn (Bitstring_lib.Bitstring.Lsb_first.to_list bs)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"","counters":[]},{"line":"  let decompress_var ({ x; is_odd } as c : Compressed.var) =","counters":[]},{"line":"    let open Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let%bind y =","counters":[]},{"line":"      exists Typ.field","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"        ~compute:","counters":[]},{"line":"          As_prover.(","counters":[]},{"line":"            map (read Compressed.typ c) ~f:(fun c -> snd (decompress_exn c)))","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":53,"col_end":53,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"    in","counters":[]},{"line":"    let%map () = Inner_curve.Checked.Assert.on_curve (x, y)","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"    and () = parity_var y >>= Boolean.Assert.(( = ) is_odd) in","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"    (x, y)","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let%snarkydef_ compress_var ((x, y) : var) : Compressed.var Checked.t =","counters":[]},{"line":"    let open Compressed_poly in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let%map is_odd = parity_var y in","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"    { Poly.x; is_odd }","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  (* end snarky-dependent *)","counters":[]},{"line":"  [%%endif]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"include Uncompressed","counters":[{"col_start":19,"col_end":19,"count":1}]}]}