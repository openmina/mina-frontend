{"filename":"src/lib/pickles_base/side_loaded_verification_key.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Pickles_types","counters":[]},{"line":"","counters":[]},{"line":"let bits ~len n = List.init len ~f:(fun i -> (n lsr i) land 1 = 1)","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"","counters":[]},{"line":"let max_log2_degree = 32","counters":[]},{"line":"","counters":[]},{"line":"module Width : sig","counters":[]},{"line":"  [%%versioned:","counters":[]},{"line":"  module Stable : sig","counters":[]},{"line":"    module V1 : sig","counters":[]},{"line":"      type t [@@deriving sexp, equal, compare, hash, yojson]","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  val of_int_exn : int -> t","counters":[]},{"line":"","counters":[]},{"line":"  val to_int : t -> int","counters":[]},{"line":"","counters":[]},{"line":"  val to_bits : t -> bool list","counters":[]},{"line":"","counters":[]},{"line":"  val zero : t","counters":[]},{"line":"","counters":[]},{"line":"  module Max = Nat.N2","counters":[]},{"line":"","counters":[]},{"line":"  module Max_vector : Vector.With_version(Max).S","counters":[]},{"line":"","counters":[]},{"line":"  module Max_at_most : sig","counters":[]},{"line":"    [%%versioned:","counters":[]},{"line":"    module Stable : sig","counters":[]},{"line":"      module V1 : sig","counters":[]},{"line":"        type 'a t = ('a, Max.n) At_most.t","counters":[]},{"line":"        [@@deriving compare, sexp, yojson, hash, equal]","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Length : Nat.Add.Intf_transparent","counters":[]},{"line":"end = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type t = char [@@deriving sexp, equal, compare, hash, yojson]","counters":[{"col_start":6,"col_end":6,"count":2},{"col_start":11,"col_end":11,"count":1},{"col_start":15,"col_end":15,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":66,"col_end":66,"count":5}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  let zero = Char.of_int_exn 0","counters":[{"col_start":27,"col_end":27,"count":1}]},{"line":"","counters":[]},{"line":"  module Max = Nat.N2","counters":[]},{"line":"","counters":[]},{"line":"  (* Think about versioning here! These vector types *will* change","counters":[]},{"line":"     serialization if the numbers above change, and so will require a new","counters":[]},{"line":"     version number. Thus, it's important that these are modules with new","counters":[]},{"line":"     versioned types, and not just module aliases to the corresponding vector","counters":[]},{"line":"     implementation.","counters":[]},{"line":"  *)","counters":[]},{"line":"  module Max_vector = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      [@@@no_toplevel_latest_type]","counters":[]},{"line":"","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type 'a t = 'a Vector.Vector_2.Stable.V1.t","counters":[{"col_start":8,"col_end":8,"count":1},{"col_start":16,"col_end":16,"count":3},{"col_start":20,"col_end":20,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"        [@@deriving compare, yojson, sexp, hash, equal]","counters":[{"col_start":54,"col_end":54,"count":3}]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    type 'a t = 'a Vector.Vector_2.t","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"    [@@deriving compare, yojson, sexp, hash, equal]","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"","counters":[]},{"line":"    let map = Vector.map","counters":[]},{"line":"","counters":[]},{"line":"    let of_list_exn = Vector.Vector_2.of_list_exn","counters":[]},{"line":"","counters":[]},{"line":"    let to_list = Vector.to_list","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Max_at_most = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      [@@@no_toplevel_latest_type]","counters":[]},{"line":"","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type 'a t = 'a At_most.At_most_2.Stable.V1.t","counters":[{"col_start":8,"col_end":8,"count":2},{"col_start":16,"col_end":16,"count":3},{"col_start":20,"col_end":20,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"        [@@deriving compare, yojson, sexp, hash, equal]","counters":[{"col_start":54,"col_end":54,"count":5}]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    type 'a t = 'a At_most.At_most_2.t","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"    [@@deriving compare, yojson, sexp, hash, equal]","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Length = Nat.N4","counters":[]},{"line":"","counters":[]},{"line":"  let to_int = Char.to_int","counters":[]},{"line":"","counters":[]},{"line":"  let to_bits = Fn.compose (bits ~len:(Nat.to_int Length.n)) to_int","counters":[{"col_start":25,"col_end":25,"count":1},{"col_start":48,"col_end":48,"count":1}]},{"line":"","counters":[]},{"line":"  let of_int_exn : int -> t =","counters":[]},{"line":"    let m = Nat.to_int Max.n in","counters":[]},{"line":"    fun n ->","counters":[{"col_start":4,"col_end":4,"count":1}]},{"line":"      assert (n <= m) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":13,"col_end":13,"count":0}]},{"line":"      Char.of_int_exn n","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Max_branches = struct","counters":[]},{"line":"  include Nat.N8","counters":[]},{"line":"  module Log2 = Nat.N3","counters":[]},{"line":"","counters":[]},{"line":"  let%test \"check max_branches\" = Nat.to_int n = 1 lsl Nat.to_int Log2.n","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":43,"col_end":43,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(* TODO: remove since it looks very much like the Domains module in the same directory *)","counters":[]},{"line":"module Domains = struct","counters":[]},{"line":"  [@@@warning \"-40-42\"]","counters":[]},{"line":"","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type 'a t = { h : 'a }","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":14,"col_end":14,"count":4},{"col_start":20,"col_end":20,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"      [@@deriving sexp, equal, compare, hash, yojson, hlist, fields]","counters":[{"col_start":67,"col_end":67,"count":1}]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Repr = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V2 = struct","counters":[]},{"line":"      type 'g t =","counters":[{"col_start":6,"col_end":6,"count":1},{"col_start":14,"col_end":14,"count":4}]},{"line":"        { max_proofs_verified : Proofs_verified.Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"        ; wrap_index : 'g Plonk_verification_key_evals.Stable.V2.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"        }","counters":[]},{"line":"      [@@deriving sexp, equal, compare, yojson]","counters":[{"col_start":46,"col_end":46,"count":3}]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Poly = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V2 = struct","counters":[]},{"line":"      type ('g, 'proofs_verified, 'vk) t =","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":39,"col_end":39,"count":6}]},{"line":"            ( 'g","counters":[]},{"line":"            , 'proofs_verified","counters":[]},{"line":"            , 'vk )","counters":[]},{"line":"            Mina_wire_types.Pickles_base.Side_loaded_verification_key.Poly.V2.t =","counters":[]},{"line":"        { max_proofs_verified : 'proofs_verified","counters":[]},{"line":"        ; wrap_index : 'g Plonk_verification_key_evals.Stable.V2.t","counters":[]},{"line":"        ; wrap_vk : 'vk option","counters":[]},{"line":"        }","counters":[]},{"line":"      [@@deriving hash]","counters":[{"col_start":22,"col_end":22,"count":1}]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let index_to_field_elements (k : 'a Plonk_verification_key_evals.t) ~g =","counters":[]},{"line":"  let Plonk_verification_key_evals.","counters":[{"col_start":2,"col_end":2,"count":1}]},{"line":"        { sigma_comm","counters":[]},{"line":"        ; coefficients_comm","counters":[]},{"line":"        ; generic_comm","counters":[]},{"line":"        ; psm_comm","counters":[]},{"line":"        ; complete_add_comm","counters":[]},{"line":"        ; mul_comm","counters":[]},{"line":"        ; emul_comm","counters":[]},{"line":"        ; endomul_scalar_comm","counters":[]},{"line":"        } =","counters":[]},{"line":"    k","counters":[]},{"line":"  in","counters":[]},{"line":"  List.map","counters":[{"col_start":9,"col_end":9,"count":1}]},{"line":"    ( Vector.to_list sigma_comm","counters":[{"col_start":19,"col_end":19,"count":1}]},{"line":"    @ Vector.to_list coefficients_comm","counters":[{"col_start":19,"col_end":19,"count":1}]},{"line":"    @ [ generic_comm","counters":[]},{"line":"      ; psm_comm","counters":[]},{"line":"      ; complete_add_comm","counters":[]},{"line":"      ; mul_comm","counters":[]},{"line":"      ; emul_comm","counters":[]},{"line":"      ; endomul_scalar_comm","counters":[]},{"line":"      ] )","counters":[]},{"line":"    ~f:g","counters":[]},{"line":"  |> Array.concat","counters":[]},{"line":"","counters":[]},{"line":"let wrap_index_to_input (type gs f) (g : gs -> f array) t =","counters":[]},{"line":"  Random_oracle_input.Chunked.field_elements (index_to_field_elements t ~g)","counters":[{"col_start":2,"col_end":2,"count":1},{"col_start":68,"col_end":68,"count":1}]},{"line":"","counters":[]},{"line":"let to_input (type a) ~(field_of_int : int -> a) :","counters":[]},{"line":"    (a * a, _, _) Poly.t -> a Random_oracle_input.Chunked.t =","counters":[]},{"line":"  let open Random_oracle_input.Chunked in","counters":[{"col_start":2,"col_end":2,"count":1}]},{"line":"  fun Poly.{ max_proofs_verified; wrap_index; wrap_vk = _ } :","counters":[]},{"line":"      _ Random_oracle_input.Chunked.t ->","counters":[]},{"line":"    List.reduce_exn ~f:append","counters":[{"col_start":4,"col_end":4,"count":1}]},{"line":"      [ Proofs_verified.One_hot.to_input ~zero:(field_of_int 0)","counters":[{"col_start":39,"col_end":39,"count":1},{"col_start":59,"col_end":59,"count":1}]},{"line":"          ~one:(field_of_int 1) max_proofs_verified","counters":[{"col_start":27,"col_end":27,"count":1}]},{"line":"      ; wrap_index_to_input","counters":[{"col_start":26,"col_end":26,"count":1}]},{"line":"          (Fn.compose Array.of_list (fun (x, y) -> [ x; y ]))","counters":[{"col_start":20,"col_end":20,"count":1},{"col_start":51,"col_end":51,"count":28}]},{"line":"          wrap_index","counters":[]},{"line":"      ]","counters":[{"col_start":6,"col_end":6,"count":2}]}]}