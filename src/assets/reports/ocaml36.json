{"filename":"src/lib/quickcheck_lib/quickcheck_lib.ml","lines":[{"line":"(* quickcheck_lib.ml *)","counters":[]},{"line":"","counters":[{"col_start":0,"col_end":0,"count":1}]},{"line":"open Core_kernel","counters":[]},{"line":"open Quickcheck.Generator","counters":[]},{"line":"open Quickcheck.Let_syntax","counters":[]},{"line":"","counters":[]},{"line":"let of_array array = Quickcheck.Generator.of_list @@ Array.to_list array","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"","counters":[]},{"line":"let rec map_gens ls ~f =","counters":[]},{"line":"  match ls with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | [] ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      return []","counters":[]},{"line":"  | h :: t ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let%bind h' = f h in","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"      let%map t' = map_gens t ~f in","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"      h' :: t'","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"let replicate_gen g n = map_gens (List.init n ~f:Fn.id) ~f:(Fn.const g)","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":42,"col_end":42,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"","counters":[]},{"line":"let init_gen ~f n =","counters":[]},{"line":"  let rec go : 'a list -> int -> 'a list Quickcheck.Generator.t =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"   fun xs n' ->","counters":[]},{"line":"    if n' < n then f n' >>= fun x -> go (x :: xs) (n' + 1)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"    else return @@ List.rev xs","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"  in","counters":[]},{"line":"  go [] 0","counters":[]},{"line":"","counters":[]},{"line":"let init_gen_array ~f n = map ~f:Array.of_list @@ init_gen ~f n","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"","counters":[]},{"line":"let gen_pair g =","counters":[]},{"line":"  let%map a = g and b = g in","counters":[]},{"line":"  (a, b)","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let shuffle_arr_inplace arr =","counters":[]},{"line":"  (* Fisher-Yates shuffle, you need fast swaps for decent performance, so we","counters":[]},{"line":"     want an array if we're not getting unnecessarily fancy. *)","counters":[]},{"line":"  let rec go n =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    if n < Array.length arr then (","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"      let%bind swap_idx = Int.gen_uniform_incl n (Array.length arr - 1) in","counters":[{"col_start":45,"col_end":45,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"      Array.swap arr n swap_idx ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      go (n + 1) )","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    else return arr","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"  in","counters":[]},{"line":"  go 0","counters":[]},{"line":"","counters":[]},{"line":"let shuffle_arr arr = shuffle_arr_inplace @@ Array.copy arr","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"","counters":[]},{"line":"let shuffle list =","counters":[]},{"line":"  Array.of_list list |> shuffle_arr_inplace |> map ~f:Array.to_list","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"","counters":[]},{"line":"(* Generate a list with a Dirichlet distribution, used for coming up with random","counters":[]},{"line":"   splits of a quantity. Symmetric Dirichlet distribution with alpha = 1.","counters":[]},{"line":"*)","counters":[]},{"line":"let gen_symm_dirichlet : int -> float list Quickcheck.Generator.t =","counters":[]},{"line":" fun n ->","counters":[]},{"line":"  let open Quickcheck.Generator.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%map gammas =","counters":[]},{"line":"    map_gens","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"      (List.init n ~f:(Fn.const ()))","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"      ~f:(fun _ ->","counters":[]},{"line":"        let open Quickcheck.Generator.Let_syntax in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        (* technically this should be (0, 1] and not (0, 1) but I expect it","counters":[]},{"line":"           doesn't matter for our purposes. *)","counters":[]},{"line":"        let%map uniform = Float.gen_uniform_excl 0. 1. in","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"        Float.log uniform )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"  in","counters":[]},{"line":"  let sum = List.fold gammas ~init:0. ~f:(fun x y -> x +. y) in","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"  List.map gammas ~f:(fun gamma -> gamma /. sum)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"module type Int_s = sig","counters":[]},{"line":"  type t","counters":[]},{"line":"","counters":[]},{"line":"  val zero : t","counters":[]},{"line":"","counters":[]},{"line":"  val ( + ) : t -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"  val ( - ) : t -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"  val ( > ) : t -> t -> bool","counters":[]},{"line":"","counters":[]},{"line":"  val of_int : int -> t","counters":[]},{"line":"","counters":[]},{"line":"  val to_int : t -> int","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let gen_division_generic (type t) (module M : Int_s with type t = t) (n : t)","counters":[]},{"line":"    (k : int) : M.t list Quickcheck.Generator.t =","counters":[]},{"line":"  if k = 0 then Quickcheck.Generator.return []","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":16,"col_end":16,"count":0}]},{"line":"  else","counters":[]},{"line":"    let open Quickcheck.Generator.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    (* Using a symmetric Dirichlet distribution with concentration parameter 1","counters":[]},{"line":"       defined above gives a distribution with uniform probability density over","counters":[]},{"line":"       all possible splits of the quantity. See the Wikipedia article for some","counters":[]},{"line":"       more detail: https://en.wikipedia.org/wiki/Dirichlet_distribution,","counters":[]},{"line":"       particularly the sections about the flat Dirichlet distribution and","counters":[]},{"line":"       string cutting.","counters":[]},{"line":"    *)","counters":[]},{"line":"    let%bind dirichlet = gen_symm_dirichlet k in","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"    let n_float = Float.of_int @@ M.to_int n in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"    let float_to_mt : float -> t =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"     fun fl ->","counters":[]},{"line":"      match Float.iround_down fl with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Some int ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          M.of_int int","counters":[]},{"line":"      | None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          failwith \"gen_division_generic: out of range\"","counters":[]},{"line":"    in","counters":[]},{"line":"    let res = List.map dirichlet ~f:(fun x -> float_to_mt @@ (x *. n_float)) in","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"    let total = List.fold res ~f:M.( + ) ~init:M.zero in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    return","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ( match res with","counters":[]},{"line":"      | [] ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          failwith","counters":[]},{"line":"            \"empty result list in gen_symm_dirichlet, this should be \\","counters":[]},{"line":"             impossible. \"","counters":[]},{"line":"      | head :: rest ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (* Going through floating point land may have caused some rounding error. We","counters":[]},{"line":"             tack it onto the first result so that the sum of the output is equal to n.","counters":[]},{"line":"          *)","counters":[]},{"line":"          if M.( > ) n total then M.(head + (n - total)) :: rest","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"          else M.(head - (total - n)) :: rest )","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"","counters":[]},{"line":"let gen_division = gen_division_generic (module Int)","counters":[{"col_start":38,"col_end":38,"count":1}]},{"line":"","counters":[]},{"line":"let gen_division_currency =","counters":[]},{"line":"  gen_division_generic","counters":[{"col_start":21,"col_end":21,"count":1}]},{"line":"    ( module struct","counters":[]},{"line":"      include Currency.Amount","counters":[]},{"line":"","counters":[]},{"line":"      let ( + ) a b = Option.value_exn (a + b)","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"      let ( - ) a b = Option.value_exn (a - b)","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"    end )","counters":[]},{"line":"","counters":[]},{"line":"let imperative_fixed_point root ~f =","counters":[]},{"line":"  let%map f' = fixed_point f in","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"  f' root","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let gen_imperative_rose_tree ?(p = 0.75) (root_gen : 'a t)","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"    (node_gen : ('a -> 'a) t) =","counters":[]},{"line":"  let%bind root = root_gen in","counters":[]},{"line":"  imperative_fixed_point root ~f:(fun self ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      match%bind size with","counters":[]},{"line":"      | 0 ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          return (fun parent -> Rose_tree.T (parent, []))","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"      | n ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let%bind fork_count = geometric ~p 1 >>| Int.max n in","counters":[{"col_start":40,"col_end":40,"count":0},{"col_start":49,"col_end":49,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"          let%bind fork_sizes = gen_division n fork_count in","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"          let positive_fork_sizes =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            List.filter fork_sizes ~f:(fun s -> s > 0)","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%map forks =","counters":[]},{"line":"            map_gens positive_fork_sizes ~f:(fun s ->","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"                tuple2 node_gen (with_size ~size:(s - 1) self) )","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"          in","counters":[]},{"line":"          fun parent ->","counters":[]},{"line":"            Rose_tree.T","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (parent, List.map forks ~f:(fun (this, f) -> f (this parent))) )","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":59,"col_end":59,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"","counters":[]},{"line":"let gen_imperative_ktree ?(p = 0.75) (root_gen : 'a t) (node_gen : ('a -> 'a) t)","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"    =","counters":[]},{"line":"  let%bind root = root_gen in","counters":[]},{"line":"  imperative_fixed_point root ~f:(fun self ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      match%bind size with","counters":[]},{"line":"      | 0 ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          return (fun _ -> [])","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"      (* this case is optional but more effecient *)","counters":[]},{"line":"      | 1 ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let%map this = node_gen in","counters":[]},{"line":"          fun parent -> [ this parent ]","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"      | n ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let%bind this = node_gen in","counters":[]},{"line":"          let%bind fork_count = geometric ~p 1 >>| Int.max n in","counters":[{"col_start":40,"col_end":40,"count":0},{"col_start":49,"col_end":49,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"          let%bind fork_sizes = gen_division (n - 1) fork_count in","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"          let%map forks =","counters":[]},{"line":"            map_gens fork_sizes ~f:(fun s -> with_size ~size:s self)","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"          in","counters":[]},{"line":"          fun parent ->","counters":[]},{"line":"            let x = this parent in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            x :: List.bind forks ~f:(fun f -> f x) )","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"","counters":[]},{"line":"let gen_imperative_list (root_gen : 'a t) (node_gen : ('a -> 'a) t) =","counters":[]},{"line":"  let%bind root = root_gen in","counters":[]},{"line":"  imperative_fixed_point root ~f:(fun self ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      match%bind size with","counters":[]},{"line":"      | 0 ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          return (fun _ -> [])","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"      | n ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let%bind this = node_gen in","counters":[]},{"line":"          let%map f = with_size ~size:(n - 1) self in","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"          fun parent -> parent :: f (this parent) )","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"let%test_module \"Quickcheck lib tests\" =","counters":[]},{"line":"  ( module struct","counters":[]},{"line":"    let%test_unit \"gen_imperative_list\" =","counters":[]},{"line":"      let increment = ( + ) 2 in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let root = 1 in","counters":[]},{"line":"      let root_gen = return root in","counters":[]},{"line":"      let gen =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Int.gen_incl 2 100","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"        >>= fun size ->","counters":[]},{"line":"        Quickcheck.Generator.with_size ~size","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (gen_imperative_list root_gen (return increment))","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"      in","counters":[]},{"line":"      Quickcheck.test gen ~f:(fun list ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          match list with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | [] ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              failwith \"We assume that our list has at least one element\"","counters":[]},{"line":"          | x :: xs ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              assert (x = root) ;","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"              let result =","counters":[]},{"line":"                List.fold_result xs ~init:x ~f:(fun elem next_elem ->","counters":[]},{"line":"                    if next_elem = increment elem then Result.return next_elem","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":43,"col_end":43,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"                    else","counters":[]},{"line":"                      Or_error.errorf","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        !\"elements do not add up correctly %d %d\"","counters":[]},{"line":"                        elem next_elem )","counters":[]},{"line":"              in","counters":[]},{"line":"              assert (Result.is_ok result) )","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"  end )","counters":[{"col_start":6,"col_end":6,"count":1}]}]}