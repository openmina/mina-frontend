{"filename":"src/lib/snark_bits/bits.ml","lines":[{"line":"(* bits.ml *)","counters":[]},{"line":"","counters":[]},{"line":"[%%import \"/src/config.mlh\"]","counters":[]},{"line":"","counters":[{"col_start":0,"col_end":0,"count":1}]},{"line":"open Core_kernel","counters":[]},{"line":"open Fold_lib","counters":[]},{"line":"open Bitstring_lib","counters":[]},{"line":"","counters":[]},{"line":"(* Someday: Make more efficient by giving Field.unpack a length argument in","counters":[]},{"line":"   camlsnark *)","counters":[]},{"line":"let unpack_field unpack ~bit_length x = List.take (unpack x) bit_length","counters":[{"col_start":40,"col_end":40,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"","counters":[]},{"line":"let bits_per_char = 8","counters":[]},{"line":"","counters":[]},{"line":"let pad (type a) ~length ~default (bs : a Bitstring.Lsb_first.t) =","counters":[]},{"line":"  let bs = (bs :> a list) in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let padding = length - List.length bs in","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"  assert (padding >= 0) ;","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"  bs @ List.init padding ~f:(fun _ -> default)","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"","counters":[]},{"line":"module Vector = struct","counters":[]},{"line":"  module type Basic = sig","counters":[]},{"line":"    type t","counters":[]},{"line":"","counters":[]},{"line":"    val length : int","counters":[]},{"line":"","counters":[]},{"line":"    val get : t -> int -> bool","counters":[]},{"line":"","counters":[]},{"line":"    val set : t -> int -> bool -> t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module type S = sig","counters":[]},{"line":"    include Basic","counters":[]},{"line":"","counters":[]},{"line":"    val empty : t","counters":[]},{"line":"","counters":[]},{"line":"    val set : t -> int -> bool -> t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module UInt64 : S with type t = Unsigned.UInt64.t = struct","counters":[]},{"line":"    open Unsigned.UInt64.Infix","counters":[]},{"line":"    include Unsigned.UInt64","counters":[]},{"line":"","counters":[]},{"line":"    let length = 64","counters":[]},{"line":"","counters":[]},{"line":"    let empty = zero","counters":[]},{"line":"","counters":[]},{"line":"    let get t i = equal ((t lsr i) land one) one","counters":[{"col_start":18,"col_end":18,"count":768}]},{"line":"","counters":[]},{"line":"    let set t i b = if b then t lor (one lsl i) else t land lognot (one lsl i)","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":53,"col_end":53,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module UInt32 : S with type t = Unsigned.UInt32.t = struct","counters":[]},{"line":"    open Unsigned.UInt32.Infix","counters":[]},{"line":"    include Unsigned.UInt32","counters":[]},{"line":"","counters":[]},{"line":"    let length = 32","counters":[]},{"line":"","counters":[]},{"line":"    let empty = zero","counters":[]},{"line":"","counters":[]},{"line":"    let get t i = equal ((t lsr i) land one) one","counters":[{"col_start":18,"col_end":18,"count":3360}]},{"line":"","counters":[]},{"line":"    let set t i b = if b then t lor (one lsl i) else t land lognot (one lsl i)","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":53,"col_end":53,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Make (V : S) : Bits_intf.Convertible_bits with type t = V.t = struct","counters":[]},{"line":"    type t = V.t","counters":[]},{"line":"","counters":[]},{"line":"    let fold t =","counters":[]},{"line":"      { Fold.fold =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          (fun ~init ~f ->","counters":[]},{"line":"            let rec go acc i =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              if i = V.length then acc else go (f acc (V.get t i)) (i + 1)","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":48,"col_end":48,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"            in","counters":[]},{"line":"            go init 0 )","counters":[]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    let iter t ~f =","counters":[]},{"line":"      for i = 0 to V.length - 1 do","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        f (V.get t i)","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"      done","counters":[]},{"line":"","counters":[]},{"line":"    let to_bits t = List.init V.length ~f:(V.get t)","counters":[{"col_start":20,"col_end":20,"count":162},{"col_start":47,"col_end":47,"count":162}]},{"line":"","counters":[]},{"line":"    let of_bits bools =","counters":[]},{"line":"      List.foldi bools ~init:V.empty ~f:(fun i t bool -> V.set t i bool)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"","counters":[]},{"line":"    let size_in_bits = V.length","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module UInt64 : Bits_intf.Convertible_bits with type t := Unsigned.UInt64.t =","counters":[]},{"line":"  Vector.Make (Vector.UInt64)","counters":[]},{"line":"","counters":[]},{"line":"module UInt32 : Bits_intf.Convertible_bits with type t := Unsigned.UInt32.t =","counters":[]},{"line":"  Vector.Make (Vector.UInt32)","counters":[]},{"line":"","counters":[]},{"line":"[%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"module type Big_int_intf = sig","counters":[]},{"line":"  include Snarky_backendless.Bigint_intf.S","counters":[]},{"line":"","counters":[]},{"line":"  val to_field : t -> field","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make_field0","counters":[]},{"line":"    (Field : Snarky_backendless.Field_intf.S)","counters":[]},{"line":"    (Bigint : Big_int_intf with type field := Field.t) (M : sig","counters":[]},{"line":"      val bit_length : int","counters":[]},{"line":"    end) : Bits_intf.S with type t = Field.t = struct","counters":[]},{"line":"  open M","counters":[]},{"line":"","counters":[]},{"line":"  type t = Field.t","counters":[]},{"line":"","counters":[]},{"line":"  let fold t =","counters":[]},{"line":"    { Fold.fold =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        (fun ~init ~f ->","counters":[]},{"line":"          let n = Bigint.of_field t in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let rec go acc i =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            if i = bit_length then acc","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"            else go (f acc (Bigint.test_bit n i)) (i + 1)","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"          in","counters":[]},{"line":"          go init 0 )","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let iter t ~f =","counters":[]},{"line":"    let n = Bigint.of_field t in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    for i = 0 to bit_length - 1 do","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      f (Bigint.test_bit n i)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"    done","counters":[]},{"line":"","counters":[]},{"line":"  let to_bits t =","counters":[]},{"line":"    let n = Bigint.of_field t in","counters":[{"col_start":4,"col_end":4,"count":1}]},{"line":"    let rec go acc i =","counters":[{"col_start":4,"col_end":4,"count":1}]},{"line":"      if i < 0 then acc else go (Bigint.test_bit n i :: acc) (i - 1)","counters":[{"col_start":6,"col_end":6,"count":256},{"col_start":20,"col_end":20,"count":1},{"col_start":29,"col_end":29,"count":255},{"col_start":47,"col_end":47,"count":255}]},{"line":"    in","counters":[]},{"line":"    go [] (bit_length - 1)","counters":[]},{"line":"","counters":[]},{"line":"  let size_in_bits = bit_length","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make_field","counters":[]},{"line":"    (Field : Snarky_backendless.Field_intf.S)","counters":[]},{"line":"    (Bigint : Big_int_intf with type field := Field.t) :","counters":[]},{"line":"  Bits_intf.S with type t = Field.t =","counters":[]},{"line":"  Make_field0 (Field) (Bigint)","counters":[]},{"line":"    (struct","counters":[]},{"line":"      let bit_length = Field.size_in_bits","counters":[]},{"line":"    end)","counters":[]},{"line":"","counters":[]},{"line":"module Small","counters":[]},{"line":"    (Field : Snarky_backendless.Field_intf.S)","counters":[]},{"line":"    (Bigint : Big_int_intf with type field := Field.t) (M : sig","counters":[]},{"line":"      val bit_length : int","counters":[]},{"line":"    end) : Bits_intf.S with type t = Field.t = struct","counters":[]},{"line":"  let () = assert (M.bit_length < Field.size_in_bits)","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"","counters":[]},{"line":"  include Make_field0 (Field) (Bigint) (M)","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Snarkable = struct","counters":[]},{"line":"  module Small_bit_vector","counters":[]},{"line":"      (Impl : Snarky_backendless.Snark_intf.S) (V : sig","counters":[]},{"line":"        type t","counters":[]},{"line":"","counters":[]},{"line":"        val empty : t","counters":[]},{"line":"","counters":[]},{"line":"        val length : int","counters":[]},{"line":"","counters":[]},{"line":"        val get : t -> int -> bool","counters":[]},{"line":"","counters":[]},{"line":"        val set : t -> int -> bool -> t","counters":[]},{"line":"      end) :","counters":[]},{"line":"    Bits_intf.Snarkable.Small","counters":[]},{"line":"      with type ('a, 'b) typ := ('a, 'b) Impl.Typ.t","counters":[]},{"line":"       and type 'a checked := 'a Impl.Checked.t","counters":[]},{"line":"       and type boolean_var := Impl.Boolean.var","counters":[]},{"line":"       and type field_var := Impl.Field.Var.t","counters":[]},{"line":"       and type Packed.var = Impl.Field.Var.t","counters":[]},{"line":"       and type Packed.value = V.t","counters":[]},{"line":"       and type Unpacked.var = Impl.Boolean.var list","counters":[]},{"line":"       and type Unpacked.value = V.t","counters":[]},{"line":"       and type comparison_result := Impl.Field.Checked.comparison_result =","counters":[]},{"line":"  struct","counters":[]},{"line":"    open Impl","counters":[]},{"line":"","counters":[]},{"line":"    let bit_length = V.length","counters":[]},{"line":"","counters":[]},{"line":"    let () = assert (bit_length < Field.size_in_bits)","counters":[{"col_start":20,"col_end":20,"count":2}]},{"line":"","counters":[]},{"line":"    let size_in_bits = bit_length","counters":[]},{"line":"","counters":[]},{"line":"    let init ~f =","counters":[]},{"line":"      let rec go acc i =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        if i = V.length then acc else go (V.set acc i (f i)) (i + 1)","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":46,"col_end":46,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"      in","counters":[]},{"line":"      go V.empty 0","counters":[]},{"line":"","counters":[]},{"line":"    module Packed = struct","counters":[]},{"line":"      type var = Field.Var.t","counters":[]},{"line":"","counters":[]},{"line":"      type value = V.t","counters":[]},{"line":"","counters":[]},{"line":"      let typ : (var, value) Typ.t =","counters":[]},{"line":"        Field.typ","counters":[]},{"line":"        |> Typ.transport","counters":[{"col_start":23,"col_end":23,"count":2}]},{"line":"             ~there:(fun t ->","counters":[]},{"line":"               let rec go two_to_the_i i acc =","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                 if i = V.length then acc","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"                 else","counters":[]},{"line":"                   let acc =","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"                     if V.get t i then Field.add two_to_the_i acc else acc","counters":[{"col_start":39,"col_end":39,"count":0},{"col_start":47,"col_end":47,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"                   in","counters":[]},{"line":"                   go (Field.add two_to_the_i two_to_the_i) (i + 1) acc","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"               in","counters":[]},{"line":"               go Field.one 0 Field.zero )","counters":[]},{"line":"             ~back:(fun t ->","counters":[]},{"line":"               let n = Bigint.of_field t in","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"               init ~f:(fun i -> Bigint.test_bit n i) )","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"","counters":[]},{"line":"      let size_in_bits = size_in_bits","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    let v_to_list n v =","counters":[]},{"line":"      List.init n ~f:(fun i -> if i < V.length then V.get v i else false)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":52,"col_end":52,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"","counters":[]},{"line":"    let v_of_list vs =","counters":[]},{"line":"      List.foldi vs ~init:V.empty ~f:(fun i acc b ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          if i < V.length then V.set acc i b else acc )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"","counters":[]},{"line":"    let pack_var = Field.Var.project","counters":[]},{"line":"","counters":[]},{"line":"    let pack_value = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"    module Unpacked = struct","counters":[]},{"line":"      type var = Boolean.var list","counters":[]},{"line":"","counters":[]},{"line":"      type value = V.t","counters":[]},{"line":"","counters":[]},{"line":"      let typ : (var, value) Typ.t =","counters":[]},{"line":"        Typ.transport","counters":[{"col_start":20,"col_end":20,"count":2}]},{"line":"          (Typ.list ~length:V.length Boolean.typ)","counters":[{"col_start":18,"col_end":18,"count":2}]},{"line":"          ~there:(v_to_list V.length) ~back:v_of_list","counters":[{"col_start":26,"col_end":26,"count":2}]},{"line":"","counters":[]},{"line":"      let var_to_bits = Bitstring.Lsb_first.of_list","counters":[]},{"line":"","counters":[]},{"line":"      let var_of_bits = pad ~length:V.length ~default:Boolean.false_","counters":[]},{"line":"","counters":[]},{"line":"      let var_to_triples (bs : var) =","counters":[]},{"line":"        Bitstring_lib.Bitstring.pad_to_triple_list ~default:Boolean.false_ bs","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      let var_of_value v =","counters":[]},{"line":"        List.init V.length ~f:(fun i -> Boolean.var_of_value (V.get v i))","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"","counters":[]},{"line":"      let size_in_bits = size_in_bits","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    let unpack_var x = Impl.Field.Checked.unpack x ~length:bit_length","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"    let var_of_field = unpack_var","counters":[]},{"line":"","counters":[]},{"line":"    let var_of_field_unsafe = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"    let unpack_value (x : Packed.value) : Unpacked.value = x","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"","counters":[]},{"line":"    let compare_var x y =","counters":[]},{"line":"      Impl.Field.Checked.compare ~bit_length:V.length (pack_var x) (pack_var y)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":62,"col_end":62,"count":0},{"col_start":75,"col_end":75,"count":0}]},{"line":"","counters":[]},{"line":"    let%snarkydef_ increment_if_var bs (b : Boolean.var) =","counters":[]},{"line":"      let open Impl in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let v = Field.Var.pack bs in","counters":[]},{"line":"      let v' = Field.Var.add v (b :> Field.Var.t) in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Field.Checked.unpack v' ~length:V.length","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let%snarkydef_ increment_var bs =","counters":[]},{"line":"      let open Impl in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let v = Field.Var.pack bs in","counters":[]},{"line":"      let v' = Field.Var.add v (Field.Var.constant Field.one) in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"      Field.Checked.unpack v' ~length:V.length","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let%snarkydef_ equal_var (n : Unpacked.var) (n' : Unpacked.var) =","counters":[]},{"line":"      Field.Checked.equal (pack_var n) (pack_var n')","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"","counters":[]},{"line":"    let%snarkydef_ assert_equal_var (n : Unpacked.var) (n' : Unpacked.var) =","counters":[]},{"line":"      Field.Checked.Assert.equal (pack_var n) (pack_var n')","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"","counters":[]},{"line":"    let if_ (cond : Boolean.var) ~(then_ : Unpacked.var) ~(else_ : Unpacked.var)","counters":[]},{"line":"        : Unpacked.var Checked.t =","counters":[]},{"line":"      match","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        List.map2 then_ else_ ~f:(fun then_ else_ ->","counters":[]},{"line":"            Boolean.if_ cond ~then_ ~else_ )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"      with","counters":[]},{"line":"      | Ok result ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Checked.List.all result","counters":[]},{"line":"      | Unequal_lengths ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          failwith \"Bits.if_: unpacked bit lengths were unequal\"","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module UInt64 (Impl : Snarky_backendless.Snark_intf.S) =","counters":[]},{"line":"    Small_bit_vector (Impl) (Vector.UInt64)","counters":[]},{"line":"  module UInt32 (Impl : Snarky_backendless.Snark_intf.S) =","counters":[]},{"line":"    Small_bit_vector (Impl) (Vector.UInt32)","counters":[]},{"line":"","counters":[]},{"line":"  module Field_backed","counters":[]},{"line":"      (Impl : Snarky_backendless.Snark_intf.S) (M : sig","counters":[]},{"line":"        val bit_length : int","counters":[]},{"line":"      end) =","counters":[]},{"line":"  struct","counters":[]},{"line":"    open Impl","counters":[]},{"line":"    include M","counters":[]},{"line":"","counters":[]},{"line":"    let size_in_bits = bit_length","counters":[]},{"line":"","counters":[]},{"line":"    module Packed = struct","counters":[]},{"line":"      type var = Field.Var.t","counters":[]},{"line":"","counters":[]},{"line":"      type value = Field.t","counters":[]},{"line":"","counters":[]},{"line":"      let typ = Typ.field","counters":[]},{"line":"","counters":[]},{"line":"      let assert_equal = Field.Checked.Assert.equal","counters":[]},{"line":"","counters":[]},{"line":"      let size_in_bits = size_in_bits","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Unpacked = struct","counters":[]},{"line":"      type var = Boolean.var list","counters":[]},{"line":"","counters":[]},{"line":"      type value = Field.t","counters":[]},{"line":"","counters":[]},{"line":"      let typ : (var, value) Typ.t =","counters":[]},{"line":"        Typ.transport","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"          (Typ.list ~length:bit_length Boolean.typ)","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"          ~there:(unpack_field Field.unpack ~bit_length)","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"          ~back:Field.project","counters":[]},{"line":"","counters":[]},{"line":"      let var_to_bits = Bitstring_lib.Bitstring.Lsb_first.of_list","counters":[]},{"line":"","counters":[]},{"line":"      let var_of_bits = pad ~length:bit_length ~default:Boolean.false_","counters":[]},{"line":"","counters":[]},{"line":"      let var_to_triples (bs : var) =","counters":[]},{"line":"        Bitstring_lib.Bitstring.pad_to_triple_list ~default:Boolean.false_ bs","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      let var_of_value v =","counters":[]},{"line":"        unpack_field Field.unpack ~bit_length v","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        |> List.map ~f:Boolean.var_of_value","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"","counters":[]},{"line":"      let size_in_bits = size_in_bits","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    let project_value = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"    let project_var = Field.Var.project","counters":[]},{"line":"","counters":[]},{"line":"    let choose_preimage_var : Packed.var -> Unpacked.var Checked.t =","counters":[]},{"line":"      Field.Checked.choose_preimage_var ~length:bit_length","counters":[]},{"line":"","counters":[]},{"line":"    let unpack_value = Fn.id","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Field (Impl : Snarky_backendless.Snark_intf.S) :","counters":[]},{"line":"    Bits_intf.Snarkable.Lossy","counters":[]},{"line":"      with type ('a, 'b) typ := ('a, 'b) Impl.Typ.t","counters":[]},{"line":"       and type 'a checked := 'a Impl.Checked.t","counters":[]},{"line":"       and type boolean_var := Impl.Boolean.var","counters":[]},{"line":"       and type Packed.var = Impl.Field.Var.t","counters":[]},{"line":"       and type Packed.value = Impl.Field.t","counters":[]},{"line":"       and type Unpacked.var = Impl.Boolean.var list","counters":[]},{"line":"       and type Unpacked.value = Impl.Field.t =","counters":[]},{"line":"    Field_backed","counters":[]},{"line":"      (Impl)","counters":[]},{"line":"      (struct","counters":[]},{"line":"        let bit_length = Impl.Field.size_in_bits","counters":[]},{"line":"      end)","counters":[]},{"line":"","counters":[]},{"line":"  module Small","counters":[]},{"line":"      (Impl : Snarky_backendless.Snark_intf.S) (M : sig","counters":[]},{"line":"        val bit_length : int","counters":[]},{"line":"      end) :","counters":[]},{"line":"    Bits_intf.Snarkable.Faithful","counters":[]},{"line":"      with type ('a, 'b) typ := ('a, 'b) Impl.Typ.t","counters":[]},{"line":"       and type 'a checked := 'a Impl.Checked.t","counters":[]},{"line":"       and type boolean_var := Impl.Boolean.var","counters":[]},{"line":"       and type Packed.var = Impl.Field.Var.t","counters":[]},{"line":"       and type Packed.value = Impl.Field.t","counters":[]},{"line":"       and type Unpacked.var = Impl.Boolean.var list","counters":[]},{"line":"       and type Unpacked.value = Impl.Field.t = struct","counters":[]},{"line":"    let () = assert (M.bit_length < Impl.Field.size_in_bits)","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"","counters":[]},{"line":"    include Field_backed (Impl) (M)","counters":[]},{"line":"","counters":[]},{"line":"    let pack_var bs =","counters":[]},{"line":"      assert (Mina_stdlib.List.Length.Compare.(bs = M.bit_length)) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":13,"col_end":13,"count":0}]},{"line":"      project_var bs","counters":[]},{"line":"","counters":[]},{"line":"    let pack_value = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"    let unpack_var = Impl.Field.Checked.unpack ~length:M.bit_length","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make_unpacked","counters":[]},{"line":"    (Impl : Snarky_backendless.Snark_intf.S) (M : sig","counters":[]},{"line":"      val bit_length : int","counters":[]},{"line":"    end) =","counters":[]},{"line":"struct","counters":[]},{"line":"  open Impl","counters":[]},{"line":"","counters":[]},{"line":"  module T = struct","counters":[]},{"line":"    type var = Boolean.var list","counters":[]},{"line":"","counters":[]},{"line":"    type value = Boolean.value list","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  include T","counters":[]},{"line":"","counters":[]},{"line":"  let typ : (var, value) Typ.t = Typ.list ~length:M.bit_length Boolean.typ","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":1}]},{"line":"","counters":[]},{"line":"[%%endif]","counters":[]}]}