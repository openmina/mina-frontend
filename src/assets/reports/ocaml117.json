{"filename":"src/lib/snark_worker/functor.ml","lines":[{"line":"open Core","counters":[]},{"line":"open Async","counters":[]},{"line":"","counters":[]},{"line":"module Time_span_with_json = struct","counters":[]},{"line":"  type t = Time.Span.t","counters":[]},{"line":"","counters":[]},{"line":"  let to_yojson total = `String (Time.Span.to_string_hum total)","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"","counters":[]},{"line":"  let of_yojson = function","counters":[]},{"line":"    | `String time ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Ok (Time.Span.of_string time)","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"    | _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Error \"Snark_worker.Functor: Could not parse timespan\"","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(*FIX: register_event fails when adding base types to the constructors*)","counters":[]},{"line":"module String_with_json = struct","counters":[]},{"line":"  type t = string","counters":[]},{"line":"","counters":[]},{"line":"  let to_yojson s = `String s","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"","counters":[]},{"line":"  let of_yojson = function","counters":[]},{"line":"    | `String s ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Ok s","counters":[]},{"line":"    | _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Error \"Snark_worker.Functor: Could not parse string\"","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Int_with_json = struct","counters":[]},{"line":"  type t = int","counters":[]},{"line":"","counters":[]},{"line":"  let to_yojson s = `Int s","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"","counters":[]},{"line":"  let of_yojson = function","counters":[]},{"line":"    | `Int s ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Ok s","counters":[]},{"line":"    | _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Error \"Snark_worker.Functor: Could not parse int\"","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"type Structured_log_events.t +=","counters":[]},{"line":"  | Merge_snark_generated of { time : Time_span_with_json.t }","counters":[{"col_start":38,"col_end":38,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"  [@@deriving register_event { msg = \"Merge SNARK generated in $time\" }]","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":27,"col_end":27,"count":3}]},{"line":"","counters":[]},{"line":"type Structured_log_events.t +=","counters":[]},{"line":"  | Base_snark_generated of","counters":[]},{"line":"      { time : Time_span_with_json.t","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"      ; transaction_type : String_with_json.t","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"      ; zkapp_command_count : Int_with_json.t","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"      ; proof_zkapp_command_count : Int_with_json.t","counters":[{"col_start":36,"col_end":36,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"      }","counters":[]},{"line":"  [@@deriving","counters":[]},{"line":"    register_event","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":17,"col_end":17,"count":3}]},{"line":"      { msg =","counters":[]},{"line":"          \"Base SNARK generated in $time for $transaction_type transaction \\","counters":[]},{"line":"           with $zkapp_command_count zkapp_command and \\","counters":[]},{"line":"           $proof_zkapp_command_count proof zkapp_command\"","counters":[]},{"line":"      }]","counters":[]},{"line":"","counters":[]},{"line":"module Make (Inputs : Intf.Inputs_intf) :","counters":[]},{"line":"  Intf.S0 with type ledger_proof := Inputs.Ledger_proof.t = struct","counters":[]},{"line":"  open Inputs","counters":[]},{"line":"  module Rpcs = Rpcs.Make (Inputs)","counters":[]},{"line":"","counters":[]},{"line":"  module Work = struct","counters":[]},{"line":"    open Snark_work_lib","counters":[]},{"line":"","counters":[]},{"line":"    module Single = struct","counters":[]},{"line":"      module Spec = struct","counters":[]},{"line":"        type t = (Transaction_witness.t, Ledger_proof.t) Work.Single.Spec.t","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"        [@@deriving sexp, to_yojson]","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"        let transaction t =","counters":[]},{"line":"          Option.map (Work.Single.Spec.witness t) ~f:(fun w ->","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"              w.Transaction_witness.transaction )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"","counters":[]},{"line":"        let _statement = Work.Single.Spec.statement","counters":[]},{"line":"      end","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Spec = struct","counters":[]},{"line":"      type t = Single.Spec.t Work.Spec.t [@@deriving sexp, to_yojson]","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"","counters":[]},{"line":"      let _instances = Work.Spec.instances","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Result = struct","counters":[]},{"line":"      type t = (Spec.t, Ledger_proof.t) Work.Result.t","counters":[]},{"line":"","counters":[]},{"line":"      let transactions (t : t) =","counters":[]},{"line":"        One_or_two.map t.spec.instances ~f:(fun i -> Single.Spec.transaction i)","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"    end","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let perform (s : Worker_state.t) public_key","counters":[]},{"line":"      ({ instances; fee } as spec : Work.Spec.t) =","counters":[]},{"line":"    One_or_two.Deferred_result.map instances ~f:(fun w ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        let open Deferred.Or_error.Let_syntax in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let%map proof, time =","counters":[]},{"line":"          perform_single s","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"            ~message:(Mina_base.Sok_message.create ~fee ~prover:public_key)","counters":[]},{"line":"            w","counters":[]},{"line":"        in","counters":[]},{"line":"        ( proof","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        , (time, match w with Transition _ -> `Transition | Merge _ -> `Merge)","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"        ) )","counters":[]},{"line":"    |> Deferred.Or_error.map ~f:(function","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"         | `One (proof1, metrics1) ->","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"             { Snark_work_lib.Work.Result.proofs = `One proof1","counters":[]},{"line":"             ; metrics = `One metrics1","counters":[]},{"line":"             ; spec","counters":[]},{"line":"             ; prover = public_key","counters":[]},{"line":"             }","counters":[]},{"line":"         | `Two ((proof1, metrics1), (proof2, metrics2)) ->","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"             { Snark_work_lib.Work.Result.proofs = `Two (proof1, proof2)","counters":[]},{"line":"             ; metrics = `Two (metrics1, metrics2)","counters":[]},{"line":"             ; spec","counters":[]},{"line":"             ; prover = public_key","counters":[]},{"line":"             } )","counters":[]},{"line":"","counters":[]},{"line":"  let dispatch rpc shutdown_on_disconnect query address =","counters":[]},{"line":"    let%map res =","counters":[]},{"line":"      Rpc.Connection.with_client","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"        ~handshake_timeout:","counters":[]},{"line":"          (Time.Span.of_sec Mina_compile_config.rpc_handshake_timeout_sec)","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"        ~heartbeat_config:","counters":[]},{"line":"          (Rpc.Connection.Heartbeat_config.create","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"             ~timeout:","counters":[]},{"line":"               (Time_ns.Span.of_sec","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"                  Mina_compile_config.rpc_heartbeat_timeout_sec )","counters":[]},{"line":"             ~send_every:","counters":[]},{"line":"               (Time_ns.Span.of_sec","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"                  Mina_compile_config.rpc_heartbeat_send_every_sec )","counters":[]},{"line":"             () )","counters":[]},{"line":"        (Tcp.Where_to_connect.of_host_and_port address)","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"        (fun conn -> Rpc.Rpc.dispatch rpc conn query)","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"    in","counters":[]},{"line":"    match res with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Error exn ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        if shutdown_on_disconnect then","counters":[]},{"line":"          failwithf","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            !\"Shutting down. Error using the RPC call, %s,: %s\"","counters":[]},{"line":"            (Rpc.Rpc.name rpc) (Exn.to_string_mach exn) ()","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"        else","counters":[]},{"line":"          Error","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ( Error.createf","counters":[]},{"line":"                !\"Error using the RPC call, %s: %s\"","counters":[]},{"line":"                (Rpc.Rpc.name rpc)","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"            @@ Exn.to_string_mach exn )","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"    | Ok res ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        res","counters":[]},{"line":"","counters":[]},{"line":"  let emit_proof_metrics metrics instances logger =","counters":[]},{"line":"    One_or_two.iter (One_or_two.zip_exn metrics instances)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"      ~f:(fun ((time, tag), single) ->","counters":[]},{"line":"        match tag with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | `Merge ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Mina_metrics.(","counters":[]},{"line":"              Cryptography.Snark_work_histogram.observe","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"                Cryptography.snark_work_merge_time_sec (Time.Span.to_sec time)) ;","counters":[{"col_start":71,"col_end":71,"count":0}]},{"line":"            [%str_log info] (Merge_snark_generated { time })","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"        | `Transition ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let ( _transaction_type","counters":[]},{"line":"                , _zkapp_command_count","counters":[]},{"line":"                , _proof_zkapp_command_count ) =","counters":[]},{"line":"              (*should be Some in the case of `Transition*)","counters":[]},{"line":"              match Option.value_exn single with","counters":[]},{"line":"              | Mina_transaction.Transaction.Command","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  (Mina_base.User_command.Zkapp_command zkapp_command) ->","counters":[]},{"line":"                  let init =","counters":[]},{"line":"                    match","counters":[]},{"line":"                      (Mina_base.Account_update.of_fee_payer","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"                         zkapp_command.Mina_base.Zkapp_command.fee_payer )","counters":[]},{"line":"                        .authorization","counters":[]},{"line":"                    with","counters":[]},{"line":"                    | Proof _ ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        (1, 1)","counters":[]},{"line":"                    | _ ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        (1, 0)","counters":[]},{"line":"                  in","counters":[]},{"line":"                  let c, p =","counters":[]},{"line":"                    Mina_base.Zkapp_command.Call_forest.fold","counters":[]},{"line":"                      zkapp_command.account_updates ~init","counters":[]},{"line":"                      ~f:(fun (count, proof_updates_count) account_update ->","counters":[]},{"line":"                        ( count + 1","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                        , if","counters":[]},{"line":"                            Mina_base.Control.(","counters":[]},{"line":"                              Tag.equal Proof","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"                                (tag","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                                   (Mina_base.Account_update.authorization","counters":[{"col_start":73,"col_end":73,"count":0}]},{"line":"                                      account_update ) ))","counters":[]},{"line":"                          then proof_updates_count + 1","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                          else proof_updates_count ) )","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                  in","counters":[]},{"line":"                  Mina_metrics.(","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    Cryptography.(","counters":[]},{"line":"                      Counter.inc snark_work_zkapp_base_time_sec","counters":[]},{"line":"                        (Time.Span.to_sec time) ;","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"                      Counter.inc_one snark_work_zkapp_base_submissions ;","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                      Counter.inc zkapp_transaction_length (Float.of_int c) ;","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"                      Counter.inc zkapp_proof_updates (Float.of_int p))) ;","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"                  (\"zkapp_command\", c, p)","counters":[]},{"line":"              | Command (Signed_command _) ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Mina_metrics.(","counters":[]},{"line":"                    Counter.inc Cryptography.snark_work_base_time_sec","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                      (Time.Span.to_sec time)) ;","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"                  (\"signed command\", 1, 0)","counters":[]},{"line":"              | Coinbase _ ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Mina_metrics.(","counters":[]},{"line":"                    Counter.inc Cryptography.snark_work_base_time_sec","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                      (Time.Span.to_sec time)) ;","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"                  (\"coinbase\", 1, 0)","counters":[]},{"line":"              | Fee_transfer _ ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Mina_metrics.(","counters":[]},{"line":"                    Counter.inc Cryptography.snark_work_base_time_sec","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                      (Time.Span.to_sec time)) ;","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"                  (\"fee_transfer\", 1, 0)","counters":[]},{"line":"            in","counters":[]},{"line":"            ()","counters":[]},{"line":"        (* [%str_log info]","counters":[]},{"line":"         *   (Base_snark_generated","counters":[]},{"line":"         *      { time","counters":[]},{"line":"         *      ; transaction_type","counters":[]},{"line":"         *      ; zkapp_command_count","counters":[]},{"line":"         *      ; proof_zkapp_command_count","counters":[]},{"line":"         *   } ) *) )","counters":[]},{"line":"","counters":[]},{"line":"  let main","counters":[]},{"line":"      (module Rpcs_versioned : Intf.Rpcs_versioned_S","counters":[]},{"line":"        with type Work.ledger_proof = Inputs.Ledger_proof.t ) ~logger","counters":[]},{"line":"      ~proof_level daemon_address shutdown_on_disconnect =","counters":[]},{"line":"    let constraint_constants =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (* TODO: Make this configurable. *)","counters":[]},{"line":"      Genesis_constants.Constraint_constants.compiled","counters":[]},{"line":"    in","counters":[]},{"line":"    let%bind state =","counters":[]},{"line":"      Worker_state.create ~constraint_constants ~proof_level ()","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"    in","counters":[]},{"line":"    let wait ?(sec = 0.5) () = after (Time.Span.of_sec sec) in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"    (* retry interval with jitter *)","counters":[]},{"line":"    let retry_pause sec = Random.float_range (sec -. 2.0) (sec +. 2.0) in","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"    let log_and_retry label error sec k =","counters":[]},{"line":"      let error_str = Error.to_string_hum error in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      (* HACK: the bind before the call to go () produces an evergrowing","counters":[]},{"line":"           backtrace history which takes forever to print and fills our disks.","counters":[]},{"line":"           If the string becomes too long, chop off the first 10 lines and include","counters":[]},{"line":"           only that *)","counters":[]},{"line":"      ( if String.length error_str < 4096 then","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"        [%log error] !\"Error %s: %{sexp:Error.t}\" label error","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"      else","counters":[]},{"line":"        let lines = String.split ~on:'\\n' error_str in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        [%log error] !\"Error %s: %s\" label","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"          (String.concat ~sep:\"\\\\n\" (List.take lines 10)) ) ;","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"      let%bind () = wait ~sec () in","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"      (* FIXME: Use a backoff algo here *)","counters":[]},{"line":"      k ()","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    in","counters":[]},{"line":"    let rec go () =","counters":[]},{"line":"      let%bind daemon_address =","counters":[]},{"line":"        (* let%bind cwd = Sys.getcwd () in","counters":[]},{"line":"         * [%log debug]","counters":[]},{"line":"         *   !\"Snark worker working directory $dir\"","counters":[]},{"line":"         *   ~metadata:[ (\"dir\", `String cwd) ] ; *)","counters":[]},{"line":"        let path = \"snark_coordinator\" in","counters":[]},{"line":"        match%bind Sys.file_exists path with","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"        | `Yes -> (","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let%map s = Reader.file_contents path in","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"            try Host_and_port.of_string (String.strip s)","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"            with _ -> daemon_address )","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"        | `No | `Unknown ->","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":16,"col_end":16,"count":0}]},{"line":"            return daemon_address","counters":[]},{"line":"      in","counters":[]},{"line":"      (* [%log debug]","counters":[]},{"line":"       *   !\"Snark worker using daemon $addr\"","counters":[]},{"line":"       *   ~metadata:[ (\"addr\", `String (Host_and_port.to_string daemon_address)) ] ; *)","counters":[]},{"line":"      match%bind","counters":[]},{"line":"        dispatch Rpcs_versioned.Get_work.Latest.rpc shutdown_on_disconnect ()","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"          daemon_address","counters":[]},{"line":"      with","counters":[]},{"line":"      | Error e ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          log_and_retry \"getting work\" e (retry_pause 10.) go","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"      | Ok None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let random_delay =","counters":[]},{"line":"            Worker_state.worker_wait_time","counters":[]},{"line":"            +. (0.5 *. Random.float Worker_state.worker_wait_time)","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"          in","counters":[]},{"line":"          (* No work to be done -- quietly take a brief nap *)","counters":[]},{"line":"          [%log info] \"No jobs available. Napping for $time seconds\"","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"            ~metadata:[ (\"time\", `Float random_delay) ] ;","counters":[]},{"line":"          let%bind () = wait ~sec:random_delay () in","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"          go ()","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"      | Ok (Some (work, public_key)) -> (","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (* [%log info]","counters":[]},{"line":"           *   \"SNARK work $work_ids received from $address. Starting proof \\","counters":[]},{"line":"           *    generation\"","counters":[]},{"line":"           *   ~metadata:","counters":[]},{"line":"           *     [ (\"address\", `String (Host_and_port.to_string daemon_address))","counters":[]},{"line":"           *     ; ( \"work_ids\"","counters":[]},{"line":"           *       , Transaction_snark_work.Statement.compact_json","counters":[]},{"line":"           *           (One_or_two.map (Work.Spec.instances work)","counters":[]},{"line":"           *              ~f:Work.Single.Spec.statement ) )","counters":[]},{"line":"           *     ] ; *)","counters":[]},{"line":"          let%bind () = wait () in","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"          (* Pause to wait for stdout to flush *)","counters":[]},{"line":"          match%bind perform state public_key work with","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"          | Error e ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let%bind () =","counters":[]},{"line":"                match%map","counters":[]},{"line":"                  dispatch Rpcs_versioned.Failed_to_generate_snark.Latest.rpc","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                    shutdown_on_disconnect (work, public_key) daemon_address","counters":[]},{"line":"                with","counters":[]},{"line":"                | Error e ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    [%log error]","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                      \"Couldn't inform the daemon about the snark work failure\"","counters":[]},{"line":"                      ~metadata:[ (\"error\", Error_json.error_to_yojson e) ]","counters":[{"col_start":69,"col_end":69,"count":0}]},{"line":"                | Ok () ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    ()","counters":[]},{"line":"              in","counters":[]},{"line":"              log_and_retry \"performing work\" e (retry_pause 10.) go","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"          | Ok result ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              emit_proof_metrics result.metrics","counters":[]},{"line":"                (Work.Result.transactions result)","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"                logger ;","counters":[]},{"line":"              (* [%log info] \"Submitted completed SNARK work $work_ids to $address\"","counters":[]},{"line":"               *   ~metadata:","counters":[]},{"line":"               *     [ (\"address\", `String (Host_and_port.to_string daemon_address))","counters":[]},{"line":"               *     ; ( \"work_ids\"","counters":[]},{"line":"               *       , Transaction_snark_work.Statement.compact_json","counters":[]},{"line":"               *           (One_or_two.map (Work.Spec.instances work)","counters":[]},{"line":"               *              ~f:Work.Single.Spec.statement ) )","counters":[]},{"line":"               *     ] ; *)","counters":[]},{"line":"              let rec submit_work () =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                match%bind","counters":[]},{"line":"                  dispatch Rpcs_versioned.Submit_work.Latest.rpc","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                    shutdown_on_disconnect result daemon_address","counters":[]},{"line":"                with","counters":[]},{"line":"                | Error e ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    log_and_retry \"submitting work\" e (retry_pause 10.)","counters":[{"col_start":65,"col_end":65,"count":0}]},{"line":"                      submit_work","counters":[]},{"line":"                | Ok () ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    go ()","counters":[]},{"line":"              in","counters":[]},{"line":"              submit_work () )","counters":[]},{"line":"    in","counters":[]},{"line":"    go ()","counters":[]},{"line":"","counters":[]},{"line":"  let command_from_rpcs","counters":[]},{"line":"      (module Rpcs_versioned : Intf.Rpcs_versioned_S","counters":[]},{"line":"        with type Work.ledger_proof = Inputs.Ledger_proof.t ) =","counters":[]},{"line":"    Command.async ~summary:\"Snark worker\"","counters":[{"col_start":4,"col_end":4,"count":1}]},{"line":"      (let open Command.Let_syntax in","counters":[]},{"line":"      let%map_open daemon_port =","counters":[]},{"line":"        flag \"--daemon-address\" ~aliases:[ \"daemon-address\" ]","counters":[{"col_start":11,"col_end":11,"count":1}]},{"line":"          (required (Arg_type.create Host_and_port.of_string))","counters":[{"col_start":18,"col_end":18,"count":1},{"col_start":35,"col_end":35,"count":1}]},{"line":"          ~doc:\"HOST-AND-PORT address daemon is listening on\"","counters":[]},{"line":"      and proof_level =","counters":[]},{"line":"        flag \"--proof-level\" ~aliases:[ \"proof-level\" ]","counters":[{"col_start":11,"col_end":11,"count":1}]},{"line":"          (optional (Arg_type.create Genesis_constants.Proof_level.of_string))","counters":[{"col_start":18,"col_end":18,"count":1},{"col_start":35,"col_end":35,"count":1}]},{"line":"          ~doc:\"full|check|none\"","counters":[]},{"line":"      and shutdown_on_disconnect =","counters":[]},{"line":"        flag \"--shutdown-on-disconnect\"","counters":[{"col_start":11,"col_end":11,"count":1}]},{"line":"          ~aliases:[ \"shutdown-on-disconnect\" ]","counters":[]},{"line":"          (optional bool)","counters":[{"col_start":18,"col_end":18,"count":1}]},{"line":"          ~doc:","counters":[]},{"line":"            \"true|false Shutdown when disconnected from daemon (default:true)\"","counters":[]},{"line":"      and conf_dir = Cli_lib.Flag.conf_dir in","counters":[]},{"line":"      fun () ->","counters":[]},{"line":"        let logger =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Logger.create () ~metadata:[ (\"process\", `String \"Snark Worker\") ]","counters":[]},{"line":"        in","counters":[]},{"line":"        Option.value_map ~default:() conf_dir ~f:(fun conf_dir ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            let logrotate_max_size = 1024 * 10 in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let logrotate_num_rotate = 1 in","counters":[]},{"line":"            Logger.Consumer_registry.register ~id:Logger.Logger_id.snark_worker","counters":[]},{"line":"              ~processor:(Logger.Processor.raw ())","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"              ~transport:","counters":[]},{"line":"                (Logger_file_system.dumb_logrotate ~directory:conf_dir","counters":[]},{"line":"                   ~log_filename:\"mina-snark-worker.log\"","counters":[]},{"line":"                   ~max_size:logrotate_max_size ~num_rotate:logrotate_num_rotate ) ) ;","counters":[]},{"line":"        Signal.handle [ Signal.term ] ~f:(fun _signal ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            [%log info]","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"              !\"Received signal to terminate. Aborting snark worker process\" ;","counters":[]},{"line":"            Core.exit 0 ) ;","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"        let proof_level =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Option.value ~default:Genesis_constants.Proof_level.compiled","counters":[]},{"line":"            proof_level","counters":[]},{"line":"        in","counters":[]},{"line":"        main","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (module Rpcs_versioned)","counters":[]},{"line":"          ~logger ~proof_level daemon_port","counters":[]},{"line":"          (Option.value ~default:true shutdown_on_disconnect))","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"  let arguments ~proof_level ~daemon_address ~shutdown_on_disconnect =","counters":[]},{"line":"    [ \"-daemon-address\"","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    ; Host_and_port.to_string daemon_address","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"    ; \"-proof-level\"","counters":[]},{"line":"    ; Genesis_constants.Proof_level.to_string proof_level","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"    ; \"-shutdown-on-disconnect\"","counters":[]},{"line":"    ; Bool.to_string shutdown_on_disconnect","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"    ]","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":1}]}]}