{"filename":"src/lib/genesis_ledger_helper/genesis_ledger_helper.ml","lines":[{"line":"open Core","counters":[]},{"line":"open Async","counters":[]},{"line":"open Signature_lib","counters":[]},{"line":"open Mina_base","counters":[]},{"line":"include Genesis_ledger_helper_lib","counters":[]},{"line":"","counters":[]},{"line":"type exn += Genesis_state_initialization_error","counters":[]},{"line":"","counters":[]},{"line":"let s3_bucket_prefix =","counters":[]},{"line":"  \"https://s3-us-west-2.amazonaws.com/snark-keys.o1test.net\"","counters":[]},{"line":"","counters":[]},{"line":"module Tar = struct","counters":[]},{"line":"  let create ~root ~directory ~file () =","counters":[]},{"line":"    match%map","counters":[]},{"line":"      Process.run ~prog:\"tar\"","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"        ~args:","counters":[]},{"line":"          [ (* Change directory to [root]. *)","counters":[]},{"line":"            \"-C\"","counters":[]},{"line":"          ; root","counters":[]},{"line":"          ; (* Create gzipped tar file [file]. *)","counters":[]},{"line":"            \"-czf\"","counters":[]},{"line":"          ; file","counters":[]},{"line":"          ; (* Add [directory] to tar file. *)","counters":[]},{"line":"            directory","counters":[]},{"line":"          ]","counters":[]},{"line":"        ()","counters":[]},{"line":"    with","counters":[]},{"line":"    | Ok _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Ok ()","counters":[]},{"line":"    | Error err ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Error (Error.tag err ~tag:\"Error generating tar file\")","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"  let extract ~root ~file () =","counters":[]},{"line":"    match%map","counters":[]},{"line":"      Process.run ~prog:\"tar\"","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"        ~args:","counters":[]},{"line":"          [ (* Change directory to [root]. *)","counters":[]},{"line":"            \"-C\"","counters":[]},{"line":"          ; root","counters":[]},{"line":"          ; (* Extract gzipped tar file [file]. *)","counters":[]},{"line":"            \"-xzf\"","counters":[]},{"line":"          ; file","counters":[]},{"line":"          ]","counters":[]},{"line":"        ()","counters":[]},{"line":"    with","counters":[]},{"line":"    | Ok _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Ok ()","counters":[]},{"line":"    | Error err ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Error (Error.tag err ~tag:\"Error extracting tar file\")","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let file_exists ?follow_symlinks filename =","counters":[]},{"line":"  match%map Sys.file_exists ?follow_symlinks filename with","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"  | `Yes ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      true","counters":[]},{"line":"  | _ ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      false","counters":[]},{"line":"","counters":[]},{"line":"module Ledger = struct","counters":[]},{"line":"  let hash_filename hash ~ledger_name_prefix =","counters":[]},{"line":"    let str =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (* Consider the serialization of accounts as well as the hash. In","counters":[]},{"line":"         particular, adding fields that are","counters":[]},{"line":"         * hashed as a bit string","counters":[]},{"line":"         * default to an all-zero bit representation","counters":[]},{"line":"         may result in the same hash, but the accounts in the ledger will not","counters":[]},{"line":"         match the account record format.","counters":[]},{"line":"      *)","counters":[]},{"line":"      hash","counters":[]},{"line":"      ^ Bin_prot.Writer.to_string Mina_base.Account.Stable.Latest.bin_writer_t","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"          Mina_base.Account.empty","counters":[]},{"line":"    in","counters":[]},{"line":"    ledger_name_prefix ^ \"_\"","counters":[]},{"line":"    ^ Blake2.to_hex (Blake2.digest_string str)","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"    ^ \".tar.gz\"","counters":[]},{"line":"","counters":[]},{"line":"  let named_filename","counters":[]},{"line":"      ~(constraint_constants : Genesis_constants.Constraint_constants.t)","counters":[]},{"line":"      ~num_accounts ~balances ~ledger_name_prefix ?other_data name =","counters":[]},{"line":"    let str =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      String.concat","counters":[]},{"line":"        [ Int.to_string constraint_constants.ledger_depth","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"        ; Int.to_string (Option.value ~default:0 num_accounts)","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"        ; List.to_string balances ~f:(fun (i, balance) ->","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"              sprintf \"%i %s\" i (Currency.Balance.to_string balance) )","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"        ; (* Distinguish ledgers when the hash function is different. *)","counters":[]},{"line":"          Snark_params.Tick.Field.to_string Mina_base.Account.empty_digest","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"        ; (* Distinguish ledgers when the account record layout has changed. *)","counters":[]},{"line":"          Bin_prot.Writer.to_string Mina_base.Account.Stable.Latest.bin_writer_t","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"            Mina_base.Account.empty","counters":[]},{"line":"        ]","counters":[]},{"line":"    in","counters":[]},{"line":"    let str =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      match other_data with None -> str | Some other_data -> str ^ other_data","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"    in","counters":[]},{"line":"    ledger_name_prefix ^ \"_\" ^ name ^ \"_\"","counters":[]},{"line":"    ^ Blake2.(to_hex (digest_string str))","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"    ^ \".tar.gz\"","counters":[]},{"line":"","counters":[]},{"line":"  let accounts_hash accounts =","counters":[]},{"line":"    Runtime_config.Accounts.to_yojson accounts","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"    |> Yojson.Safe.to_string |> Blake2.digest_string |> Blake2.to_hex","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"","counters":[]},{"line":"  let find_tar ~logger ~genesis_dir ~constraint_constants ~ledger_name_prefix","counters":[]},{"line":"      (config : Runtime_config.Ledger.t) =","counters":[]},{"line":"    let search_paths = Cache_dir.possible_paths \"\" @ [ genesis_dir ] in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"    let file_exists filename path =","counters":[]},{"line":"      let filename = path ^/ filename in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      if%map file_exists ~follow_symlinks:true filename then (","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"        [%log trace] \"Found $ledger file at $path\"","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"          ~metadata:","counters":[]},{"line":"            [ (\"ledger\", `String ledger_name_prefix)","counters":[]},{"line":"            ; (\"path\", `String filename)","counters":[]},{"line":"            ] ;","counters":[]},{"line":"        Some filename )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      else (","counters":[]},{"line":"        [%log trace] \"Ledger file $path does not exist\"","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"          ~metadata:[ (\"path\", `String filename) ] ;","counters":[]},{"line":"        None )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    in","counters":[]},{"line":"    let load_from_s3 filename =","counters":[]},{"line":"      let s3_path = s3_bucket_prefix ^/ filename in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let local_path = Cache_dir.s3_install_path ^/ filename in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      match%bind Cache_dir.load_from_s3 [ s3_path ] [ local_path ] ~logger with","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"      | Ok () ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          file_exists filename Cache_dir.s3_install_path","counters":[]},{"line":"      | Error _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          [%log trace] \"Could not download $ledger from $uri\"","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"            ~metadata:","counters":[]},{"line":"              [ (\"ledger\", `String ledger_name_prefix)","counters":[]},{"line":"              ; (\"uri\", `String s3_path)","counters":[]},{"line":"              ] ;","counters":[]},{"line":"          return None","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    in","counters":[]},{"line":"    let%bind hash_filename =","counters":[]},{"line":"      match config.hash with","counters":[]},{"line":"      | Some hash -> (","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let hash_filename = hash_filename hash ~ledger_name_prefix in","counters":[]},{"line":"          let%bind tar_path =","counters":[]},{"line":"            Deferred.List.find_map ~f:(file_exists hash_filename) search_paths","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"          in","counters":[]},{"line":"          match tar_path with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | Some _ ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              return tar_path","counters":[]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              load_from_s3 hash_filename )","counters":[]},{"line":"      | None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          return None","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"    in","counters":[]},{"line":"    let search_local_and_s3 ?other_data name =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let named_filename =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        named_filename ~constraint_constants ~num_accounts:config.num_accounts","counters":[]},{"line":"          ~balances:config.balances ~ledger_name_prefix ?other_data name","counters":[]},{"line":"      in","counters":[]},{"line":"      match%bind","counters":[]},{"line":"        Deferred.List.find_map ~f:(file_exists named_filename) search_paths","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"      with","counters":[]},{"line":"      | Some path ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          return (Some path)","counters":[]},{"line":"      | None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          load_from_s3 named_filename","counters":[]},{"line":"    in","counters":[]},{"line":"    match hash_filename with","counters":[]},{"line":"    | Some filename ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        return (Some filename)","counters":[]},{"line":"    | None -> (","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        match (config.base, config.name) with","counters":[]},{"line":"        | Named name, _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let named_filename =","counters":[]},{"line":"              named_filename ~constraint_constants","counters":[]},{"line":"                ~num_accounts:config.num_accounts ~balances:config.balances","counters":[]},{"line":"                ~ledger_name_prefix name","counters":[]},{"line":"            in","counters":[]},{"line":"            Deferred.List.find_map ~f:(file_exists named_filename) search_paths","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"        | Accounts accounts, _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            search_local_and_s3 ~other_data:(accounts_hash accounts) \"accounts\"","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"        | Hash hash, None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            assert ([%equal: string option] (Some hash) config.hash) ;","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"            return None","counters":[]},{"line":"        | _, Some name ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            search_local_and_s3 name )","counters":[]},{"line":"","counters":[]},{"line":"  let load_from_tar ?(genesis_dir = Cache_dir.autogen_path) ~logger","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"      ~(constraint_constants : Genesis_constants.Constraint_constants.t)","counters":[]},{"line":"      ?accounts ~ledger_name_prefix filename =","counters":[]},{"line":"    [%log trace] \"Loading $ledger from $path\"","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"      ~metadata:","counters":[]},{"line":"        [ (\"ledger\", `String ledger_name_prefix); (\"path\", `String filename) ] ;","counters":[]},{"line":"    let dirname = Uuid.to_string (Uuid_unix.create ()) in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"    (* Unpack the ledger in the autogen directory, since we know that we have","counters":[]},{"line":"       write permissions there.","counters":[]},{"line":"    *)","counters":[]},{"line":"    let dirname = genesis_dir ^/ dirname in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let%bind () = Unix.mkdir ~p:() dirname in","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"    let open Deferred.Or_error.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let%map () = Tar.extract ~root:dirname ~file:filename () in","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"    let (packed : Genesis_ledger.Packed.t) =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      match accounts with","counters":[]},{"line":"      | Some accounts ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ( module Genesis_ledger.Make (struct","counters":[]},{"line":"            let accounts = accounts","counters":[]},{"line":"","counters":[]},{"line":"            let directory = `Path dirname","counters":[]},{"line":"","counters":[]},{"line":"            let depth = constraint_constants.ledger_depth","counters":[]},{"line":"          end) )","counters":[]},{"line":"      | None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ( module Genesis_ledger.Of_ledger (struct","counters":[]},{"line":"            let t =","counters":[]},{"line":"              lazy","counters":[]},{"line":"                (Mina_ledger.Ledger.create ~directory_name:dirname","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                   ~depth:constraint_constants.ledger_depth () )","counters":[]},{"line":"","counters":[]},{"line":"            let depth = constraint_constants.ledger_depth","counters":[]},{"line":"          end) )","counters":[]},{"line":"    in","counters":[]},{"line":"    packed","counters":[]},{"line":"","counters":[]},{"line":"  let generate_tar ~genesis_dir ~logger ~ledger_name_prefix ledger =","counters":[]},{"line":"    Mina_ledger.Ledger.commit ledger ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let dirname = Option.value_exn (Mina_ledger.Ledger.get_directory ledger) in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"    let root_hash =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      State_hash.to_base58_check @@ Mina_ledger.Ledger.merkle_root ledger","counters":[{"col_start":65,"col_end":65,"count":0}]},{"line":"    in","counters":[]},{"line":"    let%bind () = Unix.mkdir ~p:() genesis_dir in","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"    let tar_path = genesis_dir ^/ hash_filename root_hash ~ledger_name_prefix in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"    [%log trace]","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"      \"Creating $ledger tar file for $root_hash at $path from database at $dir\"","counters":[]},{"line":"      ~metadata:","counters":[]},{"line":"        [ (\"ledger\", `String ledger_name_prefix)","counters":[]},{"line":"        ; (\"root_hash\", `String root_hash)","counters":[]},{"line":"        ; (\"path\", `String tar_path)","counters":[]},{"line":"        ; (\"dir\", `String dirname)","counters":[]},{"line":"        ] ;","counters":[]},{"line":"    let open Deferred.Or_error.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let%map () = Tar.create ~root:dirname ~file:tar_path ~directory:\".\" () in","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"    tar_path","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let padded_accounts_from_runtime_config_opt ~logger ~proof_level","counters":[]},{"line":"      ~ledger_name_prefix (config : Runtime_config.Ledger.t) =","counters":[]},{"line":"    let add_genesis_winner_account accounts =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (* We allow configurations to explicitly override adding the genesis","counters":[]},{"line":"         winner, so that we can guarantee a certain ledger layout for","counters":[]},{"line":"         integration tests.","counters":[]},{"line":"         If the configuration does not include this setting, we add the","counters":[]},{"line":"         genesis winner when we have [proof_level = Full] so that we can","counters":[]},{"line":"         create a genesis proof. For all other proof levels, we do not add","counters":[]},{"line":"         the winner.","counters":[]},{"line":"      *)","counters":[]},{"line":"      let add_genesis_winner_account =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        match config.add_genesis_winner with","counters":[]},{"line":"        | Some add_genesis_winner ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            add_genesis_winner","counters":[]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Genesis_constants.Proof_level.equal Full proof_level","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"      in","counters":[]},{"line":"      if add_genesis_winner_account then","counters":[]},{"line":"        let pk, _ = Mina_state.Consensus_state_hooks.genesis_winner in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        match accounts with","counters":[]},{"line":"        | (_, account) :: _","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          when Public_key.Compressed.equal (Account.public_key account) pk ->","counters":[{"col_start":41,"col_end":41,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"            accounts","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"        | _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ( None","counters":[]},{"line":"            , Account.create","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                (Account_id.create pk Token_id.default)","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"                (Currency.Balance.of_int 1000) )","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"            :: accounts","counters":[]},{"line":"      else accounts","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"    in","counters":[]},{"line":"    let accounts_opt =","counters":[]},{"line":"      match config.base with","counters":[]},{"line":"      | Hash _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          None","counters":[]},{"line":"      | Accounts accounts ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Some (lazy (add_genesis_winner_account (Accounts.to_full accounts)))","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"      | Named name -> (","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          match Genesis_ledger.fetch_ledger name with","counters":[]},{"line":"          | Some (module M) ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              [%log trace] \"Found $ledger with name $ledger_name\"","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                ~metadata:","counters":[]},{"line":"                  [ (\"ledger\", `String ledger_name_prefix)","counters":[]},{"line":"                  ; (\"ledger_name\", `String name)","counters":[]},{"line":"                  ] ;","counters":[]},{"line":"              Some (Lazy.map ~f:add_genesis_winner_account M.accounts)","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              [%log trace]","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                \"Could not find a built-in $ledger named $ledger_name\"","counters":[]},{"line":"                ~metadata:","counters":[]},{"line":"                  [ (\"ledger\", `String ledger_name_prefix)","counters":[]},{"line":"                  ; (\"ledger_name\", `String name)","counters":[]},{"line":"                  ] ;","counters":[]},{"line":"              None )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"    in","counters":[]},{"line":"    let padded_accounts_with_balances_opt =","counters":[]},{"line":"      Option.map accounts_opt","counters":[]},{"line":"        ~f:","counters":[]},{"line":"          (Lazy.map","counters":[]},{"line":"             ~f:(Accounts.pad_with_rev_balances (List.rev config.balances)) )","counters":[{"col_start":46,"col_end":46,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"    in","counters":[]},{"line":"    Option.map padded_accounts_with_balances_opt","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ~f:","counters":[]},{"line":"        (Lazy.map","counters":[]},{"line":"           ~f:(Accounts.pad_to (Option.value ~default:0 config.num_accounts)) )","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"","counters":[]},{"line":"  let packed_genesis_ledger_of_accounts ~depth accounts :","counters":[]},{"line":"      Genesis_ledger.Packed.t =","counters":[]},{"line":"    ( module Genesis_ledger.Make (struct","counters":[{"col_start":4,"col_end":4,"count":2}]},{"line":"      let accounts = accounts","counters":[]},{"line":"","counters":[]},{"line":"      let directory = `New","counters":[]},{"line":"","counters":[]},{"line":"      let depth = depth","counters":[]},{"line":"    end) )","counters":[]},{"line":"","counters":[]},{"line":"  let load ~proof_level ~genesis_dir ~logger ~constraint_constants","counters":[]},{"line":"      ?(ledger_name_prefix = \"genesis_ledger\") (config : Runtime_config.Ledger.t)","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"      =","counters":[]},{"line":"    Monitor.try_with_join_or_error ~here:[%here] (fun () ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        let padded_accounts_opt =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          padded_accounts_from_runtime_config_opt ~logger ~proof_level","counters":[]},{"line":"            ~ledger_name_prefix config","counters":[]},{"line":"        in","counters":[]},{"line":"        let open Deferred.Let_syntax in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let%bind tar_path =","counters":[]},{"line":"          find_tar ~logger ~genesis_dir ~constraint_constants","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"            ~ledger_name_prefix config","counters":[]},{"line":"        in","counters":[]},{"line":"        match tar_path with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | Some tar_path -> (","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            match%map","counters":[]},{"line":"              load_from_tar ~genesis_dir ~logger ~constraint_constants","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                ?accounts:padded_accounts_opt ~ledger_name_prefix tar_path","counters":[]},{"line":"            with","counters":[]},{"line":"            | Ok ledger ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Ok (ledger, config, tar_path)","counters":[]},{"line":"            | Error err ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                [%log error] \"Could not load ledger from $path: $error\"","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                  ~metadata:","counters":[]},{"line":"                    [ (\"path\", `String tar_path)","counters":[]},{"line":"                    ; (\"error\", Error_json.error_to_yojson err)","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"                    ] ;","counters":[]},{"line":"                Error err )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"        | None -> (","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            match padded_accounts_opt with","counters":[]},{"line":"            | None -> (","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                match config.base with","counters":[]},{"line":"                | Accounts _ ->","counters":[]},{"line":"                    assert false","counters":[]},{"line":"                | Hash hash ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    [%log error]","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                      \"Could not find or generate a $ledger for $root_hash\"","counters":[]},{"line":"                      ~metadata:","counters":[]},{"line":"                        [ (\"ledger\", `String ledger_name_prefix)","counters":[]},{"line":"                        ; (\"root_hash\", `String hash)","counters":[]},{"line":"                        ] ;","counters":[]},{"line":"                    Deferred.Or_error.errorf","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      \"Could not find a ledger tar file for hash '%s'\" hash","counters":[]},{"line":"                | Named ledger_name ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    let ledger_filename =","counters":[]},{"line":"                      named_filename ~constraint_constants","counters":[]},{"line":"                        ~num_accounts:config.num_accounts","counters":[]},{"line":"                        ~balances:config.balances ~ledger_name_prefix","counters":[]},{"line":"                        ledger_name","counters":[]},{"line":"                    in","counters":[]},{"line":"                    [%log error]","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"                      \"Bad config $config: $ledger named $ledger_name is not \\","counters":[]},{"line":"                       built in, and no ledger file was found at \\","counters":[]},{"line":"                       $ledger_filename\"","counters":[]},{"line":"                      ~metadata:","counters":[]},{"line":"                        [ (\"ledger\", `String ledger_name_prefix)","counters":[]},{"line":"                        ; (\"config\", Runtime_config.Ledger.to_yojson config)","counters":[{"col_start":67,"col_end":67,"count":0}]},{"line":"                        ; (\"ledger_name\", `String ledger_name)","counters":[]},{"line":"                        ; (\"ledger_filename\", `String ledger_filename)","counters":[]},{"line":"                        ] ;","counters":[]},{"line":"                    Deferred.Or_error.errorf \"ledger '%s' not found\" ledger_name","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                )","counters":[]},{"line":"            | Some accounts -> (","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                let packed =","counters":[]},{"line":"                  packed_genesis_ledger_of_accounts","counters":[]},{"line":"                    ~depth:constraint_constants.ledger_depth accounts","counters":[]},{"line":"                in","counters":[]},{"line":"                let ledger = Lazy.force (Genesis_ledger.Packed.t packed) in","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"                let%bind tar_path =","counters":[]},{"line":"                  generate_tar ~genesis_dir ~logger ~ledger_name_prefix ledger","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                in","counters":[]},{"line":"                let config =","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  { config with","counters":[]},{"line":"                    hash =","counters":[]},{"line":"                      Some","counters":[]},{"line":"                        ( State_hash.to_base58_check","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                        @@ Mina_ledger.Ledger.merkle_root ledger )","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"                  }","counters":[]},{"line":"                in","counters":[]},{"line":"                let name, other_data =","counters":[]},{"line":"                  match (config.base, config.name) with","counters":[]},{"line":"                  | Named name, _ ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      (Some name, None)","counters":[]},{"line":"                  | Accounts accounts, _ ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      (Some \"accounts\", Some (accounts_hash accounts))","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"                  | Hash _, None ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      (None, None)","counters":[]},{"line":"                  | _, Some name ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      (Some name, None)","counters":[]},{"line":"                in","counters":[]},{"line":"                match (tar_path, name) with","counters":[]},{"line":"                | Ok tar_path, Some name ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    let link_name =","counters":[]},{"line":"                      genesis_dir","counters":[]},{"line":"                      ^/ named_filename ~constraint_constants","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"                           ~num_accounts:config.num_accounts","counters":[]},{"line":"                           ~balances:config.balances ~ledger_name_prefix","counters":[]},{"line":"                           ?other_data name","counters":[]},{"line":"                    in","counters":[]},{"line":"                    (* Delete the file if it already exists. *)","counters":[]},{"line":"                    let%bind () =","counters":[]},{"line":"                      Deferred.Or_error.try_with ~here:[%here] (fun () ->","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"                          Sys.remove link_name )","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                      |> Deferred.ignore_m","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"                    in","counters":[]},{"line":"                    (* Add a symlink from the named path to the hash path. *)","counters":[]},{"line":"                    let%map () = Unix.symlink ~target:tar_path ~link_name in","counters":[]},{"line":"                    [%log trace]","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"                      \"Linking ledger file $tar_path to $named_tar_path\"","counters":[]},{"line":"                      ~metadata:","counters":[]},{"line":"                        [ (\"tar_path\", `String tar_path)","counters":[]},{"line":"                        ; (\"named_tar_path\", `String link_name)","counters":[]},{"line":"                        ] ;","counters":[]},{"line":"                    Ok (packed, config, link_name)","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                | Ok tar_path, None ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    return (Ok (packed, config, tar_path))","counters":[]},{"line":"                | Error err, _ ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    let root_hash =","counters":[]},{"line":"                      State_hash.to_base58_check","counters":[]},{"line":"                      @@ Mina_ledger.Ledger.merkle_root ledger","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"                    in","counters":[]},{"line":"                    let tar_path =","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      genesis_dir ^/ hash_filename root_hash ~ledger_name_prefix","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"                    in","counters":[]},{"line":"                    [%log error]","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"                      \"Could not generate a $ledger file at $path: $error\"","counters":[]},{"line":"                      ~metadata:","counters":[]},{"line":"                        [ (\"ledger\", `String ledger_name_prefix)","counters":[]},{"line":"                        ; (\"path\", `String tar_path)","counters":[]},{"line":"                        ; (\"error\", Error_json.error_to_yojson err)","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"                        ] ;","counters":[]},{"line":"                    return (Error err) ) ) )","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Epoch_data = struct","counters":[]},{"line":"  let load ~proof_level ~genesis_dir ~logger ~constraint_constants","counters":[]},{"line":"      (config : Runtime_config.Epoch_data.t option) =","counters":[]},{"line":"    let open Deferred.Or_error.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    match config with","counters":[]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Deferred.Or_error.return (None, None)","counters":[]},{"line":"    | Some config ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let ledger_name_prefix = \"epoch_ledger\" in","counters":[]},{"line":"        let load_ledger ledger =","counters":[]},{"line":"          Ledger.load ~proof_level ~genesis_dir ~logger ~constraint_constants","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ~ledger_name_prefix ledger","counters":[]},{"line":"        in","counters":[]},{"line":"        let%bind staking, config' =","counters":[]},{"line":"          let%map staking_ledger, config', ledger_file =","counters":[]},{"line":"            load_ledger config.staking.ledger","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"          in","counters":[]},{"line":"          [%log trace] \"Loaded staking epoch ledger from $ledger_file\"","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"            ~metadata:[ (\"ledger_file\", `String ledger_file) ] ;","counters":[]},{"line":"          ( { Consensus.Genesis_epoch_data.Data.ledger =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"                Genesis_ledger.Packed.t staking_ledger","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"            ; seed = Epoch_seed.of_base58_check_exn config.staking.seed","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"            }","counters":[]},{"line":"          , { config.staking with ledger = config' } )","counters":[]},{"line":"        in","counters":[]},{"line":"        let%map next, config'' =","counters":[]},{"line":"          match config.next with","counters":[]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              [%log trace]","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                \"Configured next epoch ledger to be the same as the staking \\","counters":[]},{"line":"                 epoch ledger\" ;","counters":[]},{"line":"              Deferred.Or_error.return (None, None)","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"          | Some { ledger; seed } ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let%map next_ledger, config'', ledger_file = load_ledger ledger in","counters":[{"col_start":69,"col_end":69,"count":0}]},{"line":"              [%log trace] \"Loaded next epoch ledger from $ledger_file\"","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"                ~metadata:[ (\"ledger_file\", `String ledger_file) ] ;","counters":[]},{"line":"              ( Some","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                  { Consensus.Genesis_epoch_data.Data.ledger =","counters":[]},{"line":"                      Genesis_ledger.Packed.t next_ledger","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"                  ; seed = Epoch_seed.of_base58_check_exn seed","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"                  }","counters":[]},{"line":"              , Some { Runtime_config.Epoch_data.Data.ledger = config''; seed }","counters":[]},{"line":"              )","counters":[]},{"line":"        in","counters":[]},{"line":"        ( Some { Consensus.Genesis_epoch_data.staking; next }","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        , Some { Runtime_config.Epoch_data.staking = config'; next = config'' }","counters":[]},{"line":"        )","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(* This hash encodes the data that determines a genesis proof:","counters":[]},{"line":"   1. The blockchain snark constraint system","counters":[]},{"line":"   2. The genesis protocol state (including the genesis ledger)","counters":[]},{"line":"","counters":[]},{"line":"   It is used to determine whether we should make a new genesis proof, or use the","counters":[]},{"line":"   one generated at compile-time.","counters":[]},{"line":"*)","counters":[]},{"line":"module Base_hash : sig","counters":[]},{"line":"  type t [@@deriving equal, yojson]","counters":[]},{"line":"","counters":[]},{"line":"  val create : id:Pickles.Verification_key.Id.t -> state_hash:State_hash.t -> t","counters":[]},{"line":"","counters":[]},{"line":"  val to_string : t -> string","counters":[]},{"line":"end = struct","counters":[]},{"line":"  type t = string [@@deriving equal, yojson]","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":11,"col_end":11,"count":0}]},{"line":"","counters":[]},{"line":"  let to_string = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"  let create ~id ~state_hash =","counters":[]},{"line":"    Pickles.Verification_key.Id.to_string id","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"    |> ( ^ ) (State_hash.to_base58_check state_hash)","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"    |> Blake2.digest_string |> Blake2.to_hex","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Genesis_proof = struct","counters":[]},{"line":"  let filename ~base_hash = \"genesis_proof_\" ^ Base_hash.to_string base_hash","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"","counters":[]},{"line":"  let find_file ~logger ~base_hash ~genesis_dir =","counters":[]},{"line":"    let search_paths = genesis_dir :: Cache_dir.possible_paths \"\" in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"    let file_exists filename path =","counters":[]},{"line":"      let filename = path ^/ filename in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      if%map file_exists ~follow_symlinks:true filename then (","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"        [%log info] \"Found genesis proof file at $path\"","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"          ~metadata:[ (\"path\", `String filename) ] ;","counters":[]},{"line":"        Some filename )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      else (","counters":[]},{"line":"        [%log info] \"Genesis proof file $path does not exist\"","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"          ~metadata:[ (\"path\", `String filename) ] ;","counters":[]},{"line":"        None )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    in","counters":[]},{"line":"    let filename = filename ~base_hash in","counters":[]},{"line":"    match%bind","counters":[]},{"line":"      Deferred.List.find_map ~f:(file_exists filename) search_paths","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"    with","counters":[]},{"line":"    | Some filename ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        return (Some filename)","counters":[]},{"line":"    | None -> (","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let s3_path = s3_bucket_prefix ^/ filename in","counters":[]},{"line":"        let local_path = Cache_dir.s3_install_path ^/ filename in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        match%bind","counters":[]},{"line":"          Cache_dir.load_from_s3 [ s3_path ] [ local_path ] ~logger","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"        with","counters":[]},{"line":"        | Ok () ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            file_exists filename Cache_dir.s3_install_path","counters":[]},{"line":"        | Error e ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            [%log info] \"Could not download genesis proof file from $uri\"","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"              ~metadata:","counters":[]},{"line":"                [ (\"uri\", `String s3_path)","counters":[]},{"line":"                ; (\"error\", Error_json.error_to_yojson e)","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"                ] ;","counters":[]},{"line":"            return None )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"","counters":[]},{"line":"  let generate_inputs ~runtime_config ~proof_level ~ledger ~genesis_epoch_data","counters":[]},{"line":"      ~constraint_constants ~blockchain_proof_system_id","counters":[]},{"line":"      ~(genesis_constants : Genesis_constants.t) =","counters":[]},{"line":"    let consensus_constants =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Consensus.Constants.create ~constraint_constants","counters":[]},{"line":"        ~protocol_constants:genesis_constants.protocol","counters":[]},{"line":"    in","counters":[]},{"line":"    let open Staged_ledger_diff in","counters":[]},{"line":"    let protocol_state_with_hashes =","counters":[]},{"line":"      Mina_state.Genesis_protocol_state.t","counters":[]},{"line":"        ~genesis_ledger:(Genesis_ledger.Packed.t ledger)","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"        ~genesis_epoch_data ~constraint_constants ~consensus_constants","counters":[]},{"line":"        ~genesis_body_reference","counters":[]},{"line":"    in","counters":[]},{"line":"    { Genesis_proof.Inputs.runtime_config","counters":[]},{"line":"    ; constraint_constants","counters":[]},{"line":"    ; proof_level","counters":[]},{"line":"    ; blockchain_proof_system_id","counters":[]},{"line":"    ; genesis_ledger = ledger","counters":[]},{"line":"    ; genesis_epoch_data","counters":[]},{"line":"    ; consensus_constants","counters":[]},{"line":"    ; protocol_state_with_hashes","counters":[]},{"line":"    ; constraint_system_digests = None","counters":[]},{"line":"    ; genesis_constants","counters":[]},{"line":"    ; genesis_body_reference","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let generate (inputs : Genesis_proof.Inputs.t) =","counters":[]},{"line":"    match inputs.proof_level with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Genesis_constants.Proof_level.Full ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Deferred.return","counters":[]},{"line":"        @@ Genesis_proof.create_values_no_proof","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"             { genesis_ledger = inputs.genesis_ledger","counters":[]},{"line":"             ; genesis_epoch_data = inputs.genesis_epoch_data","counters":[]},{"line":"             ; runtime_config = inputs.runtime_config","counters":[]},{"line":"             ; proof_level = inputs.proof_level","counters":[]},{"line":"             ; blockchain_proof_system_id = None","counters":[]},{"line":"             ; constraint_system_digests = None","counters":[]},{"line":"             ; protocol_state_with_hashes = inputs.protocol_state_with_hashes","counters":[]},{"line":"             ; genesis_constants = inputs.genesis_constants","counters":[]},{"line":"             ; consensus_constants = inputs.consensus_constants","counters":[]},{"line":"             ; constraint_constants = inputs.constraint_constants","counters":[]},{"line":"             ; genesis_body_reference = inputs.genesis_body_reference","counters":[]},{"line":"             }","counters":[]},{"line":"    | _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Deferred.return (Genesis_proof.create_values_no_proof inputs)","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"","counters":[]},{"line":"  let store ~filename proof =","counters":[]},{"line":"    (* TODO: Use [Writer.write_bin_prot]. *)","counters":[]},{"line":"    Monitor.try_with_or_error ~here:[%here] ~extract_exn:true (fun () ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        let%bind wr = Writer.open_file filename in","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"        Writer.write wr (Proof.Stable.V2.sexp_of_t proof |> Sexp.to_string) ;","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":49,"col_end":49,"count":0},{"col_start":73,"col_end":73,"count":0}]},{"line":"        Writer.close wr )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"  let load filename =","counters":[]},{"line":"    (* TODO: Use [Reader.load_bin_prot]. *)","counters":[]},{"line":"    Monitor.try_with_or_error ~here:[%here] ~extract_exn:true (fun () ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        Reader.file_contents filename","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"        >>| Sexp.of_string >>| Proof.Stable.V2.t_of_sexp )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"  let id_to_json x =","counters":[]},{"line":"    `String (Sexp.to_string (Pickles.Verification_key.Id.sexp_of_t x))","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"","counters":[]},{"line":"  let load_or_generate ~genesis_dir ~logger (inputs : Genesis_proof.Inputs.t) =","counters":[]},{"line":"    let proof_needed =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      match inputs.proof_level with Full -> true | _ -> false","counters":[{"col_start":36,"col_end":36,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"    in","counters":[]},{"line":"    let b, id =","counters":[]},{"line":"      match (inputs.blockchain_proof_system_id, inputs.proof_level) with","counters":[]},{"line":"      | Some id, _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (None, id)","counters":[]},{"line":"      | None, Full ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let ((_, (module B)) as b) =","counters":[]},{"line":"            Genesis_proof.blockchain_snark_state inputs","counters":[]},{"line":"          in","counters":[]},{"line":"          (Some b, Lazy.force B.Proof.id)","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"      | _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (None, Pickles.Verification_key.Id.dummy ())","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"    in","counters":[]},{"line":"    let base_hash =","counters":[]},{"line":"      Base_hash.create ~id","counters":[]},{"line":"        ~state_hash:","counters":[]},{"line":"          (State_hash.With_state_hashes.state_hash","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"             inputs.protocol_state_with_hashes )","counters":[]},{"line":"    in","counters":[]},{"line":"    let use_precomputed_values base_hash =","counters":[]},{"line":"      match Precomputed_values.compiled with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Some _ when not proof_needed ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          true","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"      | Some compiled -> (","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let compiled = Lazy.force compiled in","counters":[]},{"line":"          match compiled.proof_data with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | Some proof_data ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let compiled_base_hash =","counters":[]},{"line":"                Base_hash.create ~id:proof_data.blockchain_proof_system_id","counters":[]},{"line":"                  ~state_hash:","counters":[]},{"line":"                    (State_hash.With_state_hashes.state_hash","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"                       compiled.protocol_state_with_hashes )","counters":[]},{"line":"              in","counters":[]},{"line":"              Base_hash.equal base_hash compiled_base_hash","counters":[]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              false )","counters":[]},{"line":"      | None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          false","counters":[]},{"line":"    in","counters":[]},{"line":"    let%bind found_proof =","counters":[]},{"line":"      match%bind find_file ~logger ~base_hash ~genesis_dir with","counters":[]},{"line":"      | Some file -> (","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          match%map load file with","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"          | Ok genesis_proof ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let b =","counters":[]},{"line":"                lazy","counters":[]},{"line":"                  ( match b with","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  | Some b ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      b","counters":[]},{"line":"                  | None ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      Genesis_proof.blockchain_snark_state inputs )","counters":[]},{"line":"              in","counters":[]},{"line":"              let constraint_system_digests =","counters":[]},{"line":"                match inputs.constraint_system_digests with","counters":[]},{"line":"                | Some digests ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    lazy digests","counters":[]},{"line":"                | None ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    lazy","counters":[]},{"line":"                      (let (module T), (module B) = Lazy.force b in","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                       Lazy.force @@ Genesis_proof.digests (module T) (module B)","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"                      )","counters":[]},{"line":"              in","counters":[]},{"line":"              let blockchain_proof_system_id =","counters":[]},{"line":"                match inputs.blockchain_proof_system_id with","counters":[]},{"line":"                | Some id ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    id","counters":[]},{"line":"                | None ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    let _, (module B) = Lazy.force b in","counters":[]},{"line":"                    Lazy.force B.Proof.id","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"              in","counters":[]},{"line":"              Some","counters":[]},{"line":"                ( { Genesis_proof.runtime_config = inputs.runtime_config","counters":[]},{"line":"                  ; constraint_constants = inputs.constraint_constants","counters":[]},{"line":"                  ; proof_level = inputs.proof_level","counters":[]},{"line":"                  ; genesis_constants = inputs.genesis_constants","counters":[]},{"line":"                  ; genesis_ledger = inputs.genesis_ledger","counters":[]},{"line":"                  ; genesis_epoch_data = inputs.genesis_epoch_data","counters":[]},{"line":"                  ; consensus_constants = inputs.consensus_constants","counters":[]},{"line":"                  ; protocol_state_with_hashes =","counters":[]},{"line":"                      inputs.protocol_state_with_hashes","counters":[]},{"line":"                  ; constraint_system_digests","counters":[]},{"line":"                  ; proof_data =","counters":[]},{"line":"                      Some { blockchain_proof_system_id; genesis_proof }","counters":[]},{"line":"                  ; genesis_body_reference = inputs.genesis_body_reference","counters":[]},{"line":"                  }","counters":[]},{"line":"                , file )","counters":[]},{"line":"          | Error err ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              [%log error] \"Could not load genesis proof from $path: $error\"","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                ~metadata:","counters":[]},{"line":"                  [ (\"path\", `String file)","counters":[]},{"line":"                  ; (\"error\", Error_json.error_to_yojson err)","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"                  ] ;","counters":[]},{"line":"              None )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"      | None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          return None","counters":[]},{"line":"    in","counters":[]},{"line":"    match found_proof with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Some found_proof ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        return (Ok found_proof)","counters":[]},{"line":"    | None when use_precomputed_values base_hash ->","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"        let compiled =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Lazy.force (Option.value_exn Precomputed_values.compiled)","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"        in","counters":[]},{"line":"        let proof_data = Option.value_exn compiled.proof_data in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let compiled_base_hash =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Base_hash.create ~id:proof_data.blockchain_proof_system_id","counters":[]},{"line":"            ~state_hash:","counters":[]},{"line":"              (State_hash.With_state_hashes.state_hash","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"                 compiled.protocol_state_with_hashes )","counters":[]},{"line":"        in","counters":[]},{"line":"        [%log info]","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"          \"Base hash $computed_hash matches compile-time $compiled_hash, using \\","counters":[]},{"line":"           precomputed genesis proof\"","counters":[]},{"line":"          ~metadata:","counters":[]},{"line":"            [ (\"computed_hash\", Base_hash.to_yojson base_hash)","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"            ; (\"compiled_hash\", Base_hash.to_yojson compiled_base_hash)","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"            ] ;","counters":[]},{"line":"        let filename = genesis_dir ^/ filename ~base_hash in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let values =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          { Genesis_proof.runtime_config = inputs.runtime_config","counters":[]},{"line":"          ; constraint_constants = inputs.constraint_constants","counters":[]},{"line":"          ; proof_level = inputs.proof_level","counters":[]},{"line":"          ; genesis_constants = inputs.genesis_constants","counters":[]},{"line":"          ; genesis_ledger = inputs.genesis_ledger","counters":[]},{"line":"          ; genesis_epoch_data = inputs.genesis_epoch_data","counters":[]},{"line":"          ; consensus_constants = inputs.consensus_constants","counters":[]},{"line":"          ; protocol_state_with_hashes = inputs.protocol_state_with_hashes","counters":[]},{"line":"          ; constraint_system_digests = compiled.constraint_system_digests","counters":[]},{"line":"          ; proof_data = Some proof_data","counters":[]},{"line":"          ; genesis_body_reference = inputs.genesis_body_reference","counters":[]},{"line":"          }","counters":[]},{"line":"        in","counters":[]},{"line":"        let%map () =","counters":[]},{"line":"          match%map store ~filename proof_data.genesis_proof with","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"          | Ok () ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              [%log info] \"Compile-time genesis proof written to $path\"","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                ~metadata:[ (\"path\", `String filename) ]","counters":[]},{"line":"          | Error err ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              [%log warn]","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                \"Compile-time genesis proof could not be written to $path: \\","counters":[]},{"line":"                 $error\"","counters":[]},{"line":"                ~metadata:","counters":[]},{"line":"                  [ (\"path\", `String filename)","counters":[]},{"line":"                  ; (\"error\", Error_json.error_to_yojson err)","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"                  ]","counters":[]},{"line":"        in","counters":[]},{"line":"        Ok (values, filename)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [%log info]","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"          \"No genesis proof file was found for $base_hash, generating a new \\","counters":[]},{"line":"           genesis proof\"","counters":[]},{"line":"          ~metadata:[ (\"base_hash\", Base_hash.to_yojson base_hash) ] ;","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"        let%bind values = generate inputs in","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"        let filename = genesis_dir ^/ filename ~base_hash in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let%map () =","counters":[]},{"line":"          match values.proof_data with","counters":[]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              return ()","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"          | Some proof_data -> (","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              match%map store ~filename proof_data.genesis_proof with","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"              | Ok () ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  [%log info] \"New genesis proof written to $path\"","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                    ~metadata:[ (\"path\", `String filename) ]","counters":[]},{"line":"              | Error err ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  [%log warn]","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                    \"Genesis proof could not be written to $path: $error\"","counters":[]},{"line":"                    ~metadata:","counters":[]},{"line":"                      [ (\"path\", `String filename)","counters":[]},{"line":"                      ; (\"error\", Error_json.error_to_yojson err)","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"                      ] )","counters":[]},{"line":"        in","counters":[]},{"line":"        Ok (values, filename)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"  let create_values_no_proof = Genesis_proof.create_values_no_proof","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let load_config_json filename =","counters":[]},{"line":"  Monitor.try_with_or_error ~here:[%here] (fun () ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      let%map json = Reader.file_contents filename in","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"      Yojson.Safe.from_string json )","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"let load_config_file filename =","counters":[]},{"line":"  let open Deferred.Or_error.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  Monitor.try_with_join_or_error ~here:[%here] (fun () ->","counters":[]},{"line":"      let%map json = load_config_json filename in","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"      match Runtime_config.of_yojson json with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Ok config ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Ok config","counters":[]},{"line":"      | Error err ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Or_error.error_string err )","counters":[]},{"line":"","counters":[]},{"line":"let inputs_from_config_file ?(genesis_dir = Cache_dir.autogen_path) ~logger","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"    ~proof_level (config : Runtime_config.t) =","counters":[]},{"line":"  let ledger_name_json =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    match","counters":[]},{"line":"      let open Option.Let_syntax in","counters":[]},{"line":"      let%bind ledger = config.ledger in","counters":[]},{"line":"      ledger.name","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    with","counters":[]},{"line":"    | Some name ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        `String name","counters":[]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        `Null","counters":[]},{"line":"  in","counters":[]},{"line":"  [%log info] \"Initializing with runtime configuration. Ledger name: $name\"","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"    ~metadata:","counters":[]},{"line":"      [ (\"name\", ledger_name_json)","counters":[]},{"line":"      ; (\"config\", Runtime_config.to_yojson config)","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"      ] ;","counters":[]},{"line":"  let open Deferred.Or_error.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let genesis_constants = Genesis_constants.compiled in","counters":[]},{"line":"  let proof_level =","counters":[]},{"line":"    List.find_map_exn ~f:Fn.id","counters":[]},{"line":"      [ proof_level","counters":[]},{"line":"      ; Option.Let_syntax.(","counters":[]},{"line":"          let%bind proof = config.proof in","counters":[]},{"line":"          match%map proof.level with","counters":[]},{"line":"          | Full ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Genesis_constants.Proof_level.Full","counters":[]},{"line":"          | Check ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Check","counters":[]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              None)","counters":[]},{"line":"      ; Some Genesis_constants.Proof_level.compiled","counters":[]},{"line":"      ]","counters":[]},{"line":"  in","counters":[]},{"line":"  let constraint_constants, blockchain_proof_system_id =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    match config.proof with","counters":[]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [%log info] \"Using the compiled constraint constants\" ;","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"        ( Genesis_constants.Constraint_constants.compiled","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        , Some (Pickles.Verification_key.Id.dummy ()) )","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"    | Some config ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [%log info] \"Using the constraint constants from the configuration file\" ;","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"        let blockchain_proof_system_id =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (* We pass [None] here, which will force the constraint systems to be","counters":[]},{"line":"             set up and their hashes evaluated before we can calculate the","counters":[]},{"line":"             genesis proof's filename.","counters":[]},{"line":"             This adds no overhead if we are generating a genesis proof, since","counters":[]},{"line":"             we will do these evaluations anyway to load the blockchain proving","counters":[]},{"line":"             key. Otherwise, this will in a slight slowdown.","counters":[]},{"line":"          *)","counters":[]},{"line":"          None","counters":[]},{"line":"        in","counters":[]},{"line":"        ( make_constraint_constants","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"            ~default:Genesis_constants.Constraint_constants.compiled config","counters":[]},{"line":"        , blockchain_proof_system_id )","counters":[]},{"line":"  in","counters":[]},{"line":"  let%bind () =","counters":[]},{"line":"    match (proof_level, Genesis_constants.Proof_level.compiled) with","counters":[]},{"line":"    | _, Full | (Check | None), _ ->","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"        return ()","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"    | Full, ((Check | None) as compiled) ->","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":14,"col_end":14,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"        let str = Genesis_constants.Proof_level.to_string in","counters":[]},{"line":"        [%log fatal]","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"          \"Proof level $proof_level is not compatible with compile-time proof \\","counters":[]},{"line":"           level $compiled_proof_level\"","counters":[]},{"line":"          ~metadata:","counters":[]},{"line":"            [ (\"proof_level\", `String (str proof_level))","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"            ; (\"compiled_proof_level\", `String (str compiled))","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"            ] ;","counters":[]},{"line":"        Deferred.Or_error.errorf","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"          \"Proof level %s is not compatible with compile-time proof level %s\"","counters":[]},{"line":"          (str proof_level) (str compiled)","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%bind genesis_ledger, ledger_config, ledger_file =","counters":[]},{"line":"    Ledger.load ~proof_level ~genesis_dir ~logger ~constraint_constants","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"      (Option.value config.ledger","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"         ~default:","counters":[]},{"line":"           { base = Named Mina_compile_config.genesis_ledger","counters":[]},{"line":"           ; num_accounts = None","counters":[]},{"line":"           ; balances = []","counters":[]},{"line":"           ; hash = None","counters":[]},{"line":"           ; name = None","counters":[]},{"line":"           ; add_genesis_winner = None","counters":[]},{"line":"           } )","counters":[]},{"line":"  in","counters":[]},{"line":"  [%log info] \"Loaded genesis ledger from $ledger_file\"","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":12,"col_end":12,"count":0}]},{"line":"    ~metadata:[ (\"ledger_file\", `String ledger_file) ] ;","counters":[]},{"line":"  let%bind genesis_epoch_data, genesis_epoch_data_config =","counters":[]},{"line":"    Epoch_data.load ~proof_level ~genesis_dir ~logger ~constraint_constants","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"      config.epoch_data","counters":[]},{"line":"  in","counters":[]},{"line":"  let config =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    { config with","counters":[]},{"line":"      ledger = Option.map config.ledger ~f:(fun _ -> ledger_config)","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"    ; epoch_data = genesis_epoch_data_config","counters":[]},{"line":"    }","counters":[]},{"line":"  in","counters":[]},{"line":"  let%map genesis_constants =","counters":[]},{"line":"    Deferred.return","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"    @@ make_genesis_constants ~logger ~default:genesis_constants config","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"  in","counters":[]},{"line":"  let proof_inputs =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Genesis_proof.generate_inputs ~runtime_config:config ~proof_level","counters":[]},{"line":"      ~ledger:genesis_ledger ~constraint_constants ~genesis_constants","counters":[]},{"line":"      ~blockchain_proof_system_id ~genesis_epoch_data","counters":[]},{"line":"  in","counters":[]},{"line":"  (proof_inputs, config)","counters":[]},{"line":"","counters":[]},{"line":"let init_from_inputs ?(genesis_dir = Cache_dir.autogen_path) ~logger","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"    proof_inputs =","counters":[]},{"line":"  let open Deferred.Or_error.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%map values, proof_file =","counters":[]},{"line":"    Genesis_proof.load_or_generate ~genesis_dir ~logger proof_inputs","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"  in","counters":[]},{"line":"  if Option.is_some values.proof_data then","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    [%log info] \"Loaded genesis proof from $proof_file\"","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":14,"col_end":14,"count":0}]},{"line":"      ~metadata:[ (\"proof_file\", `String proof_file) ] ;","counters":[]},{"line":"  values","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let init_from_config_file ?genesis_dir ~logger ~proof_level","counters":[]},{"line":"    (config : Runtime_config.t) :","counters":[]},{"line":"    (Precomputed_values.t * Runtime_config.t) Deferred.Or_error.t =","counters":[]},{"line":"  let open Deferred.Or_error.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%map inputs, config =","counters":[]},{"line":"    inputs_from_config_file ?genesis_dir ~logger ~proof_level config","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"  in","counters":[]},{"line":"  let values = Genesis_proof.create_values_no_proof inputs in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  (values, config)","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let upgrade_old_config ~logger filename json =","counters":[]},{"line":"  match json with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | `Assoc fields ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (* Fields previously part of daemon.json *)","counters":[]},{"line":"      let old_fields =","counters":[]},{"line":"        [ \"client_port\"","counters":[]},{"line":"        ; \"libp2p-port\"","counters":[]},{"line":"        ; \"rest-port\"","counters":[]},{"line":"        ; \"block-producer-key\"","counters":[]},{"line":"        ; \"block-producer-pubkey\"","counters":[]},{"line":"        ; \"block-producer-password\"","counters":[]},{"line":"        ; \"coinbase-receiver\"","counters":[]},{"line":"        ; \"run-snark-worker\"","counters":[]},{"line":"        ; \"snark-worker-fee\"","counters":[]},{"line":"        ; \"peers\"","counters":[]},{"line":"        ; \"work-selection\"","counters":[]},{"line":"        ; \"work-reassignment-wait\"","counters":[]},{"line":"        ; \"log-received-blocks\"","counters":[]},{"line":"        ; \"log-txn-pool-gossip\"","counters":[]},{"line":"        ; \"log-snark-work-gossip\"","counters":[]},{"line":"        ; \"log-block-creation\"","counters":[]},{"line":"        ]","counters":[]},{"line":"      in","counters":[]},{"line":"      let found_daemon = ref false in","counters":[]},{"line":"      let old_fields, remaining_fields =","counters":[]},{"line":"        List.partition_tf fields ~f:(fun (key, _) ->","counters":[]},{"line":"            if String.equal key \"daemon\" then (","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"              found_daemon := true ;","counters":[]},{"line":"              false )","counters":[]},{"line":"            else List.mem ~equal:String.equal old_fields key )","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"      in","counters":[]},{"line":"      if List.is_empty old_fields then return json","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"      else if !found_daemon then (","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"        (* This file has already been upgraded, or was written for the new","counters":[]},{"line":"           format. Do not accept old-style fields.","counters":[]},{"line":"        *)","counters":[]},{"line":"        [%log warn]","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"          \"Ignoring old-format values $values from the config file $filename. \\","counters":[]},{"line":"           These flags are now fields in the 'daemon' object of the config \\","counters":[]},{"line":"           file.\"","counters":[]},{"line":"          ~metadata:","counters":[]},{"line":"            [ (\"values\", `Assoc old_fields); (\"filename\", `String filename) ] ;","counters":[]},{"line":"        return (`Assoc remaining_fields) )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      else (","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"        (* This file was written for the old format. Upgrade it. *)","counters":[]},{"line":"        [%log warn]","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"          \"Automatically upgrading the config file $filename. The values \\","counters":[]},{"line":"           $values have been moved to the 'daemon' object.\"","counters":[]},{"line":"          ~metadata:","counters":[]},{"line":"            [ (\"filename\", `String filename); (\"values\", `Assoc old_fields) ] ;","counters":[]},{"line":"        let upgraded_json =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          `Assoc ((\"daemon\", `Assoc old_fields) :: remaining_fields)","counters":[]},{"line":"        in","counters":[]},{"line":"        let%map () =","counters":[]},{"line":"          Deferred.Or_error.try_with ~here:[%here] (fun () ->","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"              Writer.with_file filename ~f:(fun w ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                  Deferred.return","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  @@ Writer.write w (Yojson.Safe.pretty_to_string upgraded_json) ) )","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"          |> Deferred.ignore_m","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"        in","counters":[]},{"line":"        upgraded_json )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"  | _ ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (* This error will get handled properly elsewhere, do nothing here. *)","counters":[]},{"line":"      return json","counters":[]},{"line":"","counters":[]},{"line":"let%test_module \"Account config test\" =","counters":[]},{"line":"  ( module struct","counters":[]},{"line":"    let%test_unit \"Runtime config <=> Account\" =","counters":[]},{"line":"      let module Ledger = (val Genesis_ledger.for_unit_tests) in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let accounts = Lazy.force Ledger.accounts in","counters":[]},{"line":"      List.iter accounts ~f:(fun (sk, acc) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          let acc_config = Accounts.Single.of_account acc sk in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let acc' =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Accounts.Single.to_account_with_pk acc_config |> Or_error.ok_exn","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"          in","counters":[]},{"line":"          [%test_eq: Account.t] acc acc' )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"  end )","counters":[{"col_start":6,"col_end":6,"count":2}]}]}