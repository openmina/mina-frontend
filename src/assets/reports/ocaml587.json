{"filename":"src/lib/merkle_ledger/graphviz.ml","lines":[{"line":"open Core","counters":[]},{"line":"open Async","counters":[]},{"line":"","counters":[]},{"line":"(** Visualizable_ledger shows a subgraph of a merkle_ledger using Graphviz *)","counters":[]},{"line":"module type S = sig","counters":[]},{"line":"  type addr","counters":[]},{"line":"","counters":[]},{"line":"  type ledger","counters":[]},{"line":"","counters":[]},{"line":"  type t","counters":[]},{"line":"","counters":[]},{"line":"  (* Visualize will enumerate through all edges of a subtree with a","counters":[]},{"line":"     initial_address. It will then interpret all of the edges and nodes into an","counters":[]},{"line":"     intermediate form that will be easy to write into a dot file *)","counters":[]},{"line":"  val visualize : ledger -> initial_address:addr -> t","counters":[]},{"line":"","counters":[]},{"line":"  (* Write will transform the intermediate form generate by visualize and save","counters":[]},{"line":"     the results into a dot file *)","counters":[]},{"line":"  val write : path:string -> name:string -> t -> unit Deferred.t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type Inputs_intf = sig","counters":[]},{"line":"  module Key : Intf.Key","counters":[]},{"line":"","counters":[]},{"line":"  module Token_id : Intf.Token_id","counters":[]},{"line":"","counters":[]},{"line":"  module Account_id :","counters":[]},{"line":"    Intf.Account_id with type key := Key.t and type token_id := Token_id.t","counters":[]},{"line":"","counters":[]},{"line":"  module Balance : Intf.Balance","counters":[]},{"line":"","counters":[]},{"line":"  module Account :","counters":[]},{"line":"    Intf.Account","counters":[]},{"line":"      with type account_id := Account_id.t","counters":[]},{"line":"       and type balance := Balance.t","counters":[]},{"line":"","counters":[]},{"line":"  module Hash : Intf.Hash with type account := Account.t","counters":[]},{"line":"","counters":[]},{"line":"  module Location : Location_intf.S","counters":[]},{"line":"","counters":[]},{"line":"  module Ledger :","counters":[]},{"line":"    Base_ledger_intf.S","counters":[]},{"line":"      with module Addr = Location.Addr","counters":[]},{"line":"       and module Location = Location","counters":[]},{"line":"       and type account_id := Account_id.t","counters":[]},{"line":"       and type account_id_set := Account_id.Set.t","counters":[]},{"line":"       and type hash := Hash.t","counters":[]},{"line":"       and type root_hash := Hash.t","counters":[]},{"line":"       and type account := Account.t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make (Inputs : Inputs_intf) :","counters":[]},{"line":"  S with type addr := Inputs.Location.Addr.t and type ledger := Inputs.Ledger.t =","counters":[]},{"line":"struct","counters":[]},{"line":"  open Inputs","counters":[]},{"line":"","counters":[]},{"line":"  module Account = struct","counters":[]},{"line":"    include Account","counters":[]},{"line":"    include Comparator.Make (Account)","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  type ('source, 'target) edge = { source : 'source; target : 'target }","counters":[]},{"line":"","counters":[]},{"line":"  type target =","counters":[]},{"line":"    | Hash of Hash.t","counters":[]},{"line":"    | Empty_hash","counters":[]},{"line":"    | Account of Account.t","counters":[]},{"line":"    | Empty_account","counters":[]},{"line":"","counters":[]},{"line":"  type merkle_tree_edge = (Hash.t, target) edge","counters":[]},{"line":"","counters":[]},{"line":"  type pretty_format_account = { public_key : string; balance : int }","counters":[]},{"line":"","counters":[]},{"line":"  type pretty_target =","counters":[]},{"line":"    | Pretty_hash of string","counters":[]},{"line":"    | Pretty_account of pretty_format_account","counters":[]},{"line":"    | Pretty_empty_hash of int","counters":[]},{"line":"    | Pretty_empty_account of int","counters":[]},{"line":"","counters":[]},{"line":"  type t = (string, pretty_target) edge list","counters":[]},{"line":"","counters":[]},{"line":"  let string_of_hash = Visualization.display_short_sexp (module Hash)","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"","counters":[]},{"line":"  module Addr = Location.Addr","counters":[]},{"line":"","counters":[]},{"line":"  let string_of_account_id account =","counters":[]},{"line":"    account |> Account.identifier","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"    |> Visualization.display_short_sexp (module Account_id)","counters":[]},{"line":"","counters":[]},{"line":"  let empty_hash =","counters":[]},{"line":"    Empty_hashes.extensible_cache (module Hash) ~init_hash:Hash.empty_account","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"","counters":[]},{"line":"  let visualize t ~(initial_address : Ledger.Addr.t) =","counters":[]},{"line":"    let ledger_depth = Inputs.Ledger.depth t in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let rec bfs ~(edges : merkle_tree_edge list) ~accounts jobs =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      match Queue.dequeue jobs with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          List.rev edges","counters":[]},{"line":"      | Some address ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let parent_address = Addr.parent_exn address in","counters":[]},{"line":"          let parent_hash =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Ledger.get_inner_hash_at_addr_exn t parent_address","counters":[]},{"line":"          in","counters":[]},{"line":"          if Addr.is_leaf ~ledger_depth address then","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            match Ledger.get t (Location.Account address) with","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            | Some new_account ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (* let public_key = Account.public_key new_account in","counters":[]},{"line":"                   let location = Ledger.location_of_account t public_key |> Option.value_exn in","counters":[]},{"line":"                   let queried_account = Ledger.get t location |> Option.value_exn in","counters":[]},{"line":"                   assert (Account.equal queried_account new_account); *)","counters":[]},{"line":"                assert (not @@ Set.mem accounts new_account) ;","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"                let new_accounts = Set.add accounts new_account in","counters":[]},{"line":"                bfs","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  ~edges:","counters":[]},{"line":"                    ( { source = parent_hash; target = Account new_account }","counters":[]},{"line":"                    :: edges )","counters":[]},{"line":"                  ~accounts:new_accounts jobs","counters":[]},{"line":"            | None ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                bfs","counters":[]},{"line":"                  ~edges:","counters":[]},{"line":"                    ({ source = parent_hash; target = Empty_account } :: edges)","counters":[]},{"line":"                  ~accounts jobs","counters":[]},{"line":"          else","counters":[]},{"line":"            let current_hash = Ledger.get_inner_hash_at_addr_exn t address in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let target : target =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              if","counters":[]},{"line":"                not","counters":[]},{"line":"                @@ Hash_set.mem","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                     ( List.init ~f:empty_hash ledger_depth","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                     |> Hash.Hash_set.of_list )","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"                     current_hash","counters":[]},{"line":"              then (","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"                Queue.enqueue jobs","counters":[]},{"line":"                  (Addr.child_exn ~ledger_depth address Direction.Left) ;","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                Queue.enqueue jobs","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  (Addr.child_exn ~ledger_depth address Direction.Right) ;","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                Hash current_hash )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"              else Empty_hash","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"            in","counters":[]},{"line":"            bfs","counters":[]},{"line":"              ~edges:({ source = parent_hash; target } :: edges)","counters":[]},{"line":"              ~accounts jobs","counters":[]},{"line":"    in","counters":[]},{"line":"    let edges =","counters":[]},{"line":"      bfs ~edges:[]","counters":[]},{"line":"        ~accounts:(Set.empty (module Account))","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"        (Queue.of_list","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"           [ Addr.child_exn ~ledger_depth initial_address Direction.Left","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"           ; Addr.child_exn ~ledger_depth initial_address Direction.Right","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"           ] )","counters":[]},{"line":"    in","counters":[]},{"line":"    let edges =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      List.folding_map edges ~init:(0, 0)","counters":[]},{"line":"        ~f:(fun (empty_account_counter, empty_hash_counter) { source; target }","counters":[]},{"line":"           ->","counters":[]},{"line":"          let source = string_of_hash source in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          match target with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | Hash target_hash ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              ( (empty_account_counter, empty_hash_counter)","counters":[]},{"line":"              , { source; target = Pretty_hash (string_of_hash target_hash) } )","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"          | Account account ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let string_key = string_of_account_id account in","counters":[]},{"line":"              let pretty_account =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                { public_key = string_key","counters":[]},{"line":"                ; balance = Account.balance account |> Balance.to_int","counters":[{"col_start":42,"col_end":42,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"                }","counters":[]},{"line":"              in","counters":[]},{"line":"              ( (empty_account_counter, empty_hash_counter)","counters":[]},{"line":"              , { source; target = Pretty_account pretty_account } )","counters":[]},{"line":"          | Empty_hash ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let new_empty_hash_counter = empty_hash_counter + 1 in","counters":[]},{"line":"              ( (empty_account_counter, new_empty_hash_counter)","counters":[]},{"line":"              , { source; target = Pretty_empty_hash new_empty_hash_counter } )","counters":[]},{"line":"          | Empty_account ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let new_empty_account_counter = empty_account_counter + 1 in","counters":[]},{"line":"              ( (new_empty_account_counter, empty_hash_counter)","counters":[]},{"line":"              , { source","counters":[]},{"line":"                ; target = Pretty_empty_account new_empty_account_counter","counters":[]},{"line":"                } ) )","counters":[]},{"line":"    in","counters":[]},{"line":"    edges","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  module Dot_writer = struct","counters":[]},{"line":"    let wrapper ~name body = sprintf \"digraph %s { \\n %s\\n}\" name body","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"    let write_empty_entry ~id source count =","counters":[]},{"line":"      let empty_hash_id = sprintf \"EMPTY_%s_%d\" id count in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      [ sprintf \"\\\"%s\\\" -> \\\"%s\\\" \" source empty_hash_id","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":14,"col_end":14,"count":0}]},{"line":"      ; sprintf \"\\\"%s\\\" [shape=point]\" empty_hash_id","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"      ]","counters":[]},{"line":"","counters":[]},{"line":"    let write ~path ~name edges =","counters":[]},{"line":"      let body =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        List.map edges ~f:(fun { source; target } ->","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"            match target with","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            | Pretty_hash hash ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                [ sprintf \"\\\"%s\\\" -> \\\"%s\\\" \" source hash ]","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"            | Pretty_account { public_key; balance } ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                [ sprintf \"\\\"%s\\\" -> \\\"%s\\\" \" source public_key","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                ; sprintf \"\\\"%s\\\" [shape=record,label=\\\"{%s|%d}\\\"]\" public_key","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                    public_key balance","counters":[]},{"line":"                ]","counters":[]},{"line":"            | Pretty_empty_hash count ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                write_empty_entry ~id:\"HASH\" source count","counters":[]},{"line":"            | Pretty_empty_account count ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                write_empty_entry ~id:\"ACCOUNT\" source count )","counters":[]},{"line":"        |> List.concat |> String.concat ~sep:\"\\n\"","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"      in","counters":[]},{"line":"      let code = wrapper ~name body in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Writer.save path ~contents:code","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let write = Dot_writer.write","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}