{"filename":"src/lib/staged_ledger/pre_diff_info.ml","lines":[{"line":"open Core","counters":[]},{"line":"open Mina_base","counters":[]},{"line":"open Mina_transaction","counters":[]},{"line":"open Signature_lib","counters":[]},{"line":"","counters":[]},{"line":"module type S = sig","counters":[]},{"line":"  module Error : sig","counters":[]},{"line":"    type t =","counters":[]},{"line":"      | Verification_failed of Verifier.Failure.t","counters":[]},{"line":"      | Coinbase_error of string","counters":[]},{"line":"      | Insufficient_fee of Currency.Fee.t * Currency.Fee.t","counters":[]},{"line":"      | Internal_command_status_mismatch","counters":[]},{"line":"      | Unexpected of Error.t","counters":[]},{"line":"    [@@deriving sexp]","counters":[]},{"line":"","counters":[]},{"line":"    val to_string : t -> string","counters":[]},{"line":"","counters":[]},{"line":"    val to_error : t -> Error.t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  val get_unchecked :","counters":[]},{"line":"       constraint_constants:Genesis_constants.Constraint_constants.t","counters":[]},{"line":"    -> coinbase_receiver:Public_key.Compressed.t","counters":[]},{"line":"    -> supercharge_coinbase:bool","counters":[]},{"line":"    -> Staged_ledger_diff.With_valid_signatures_and_proofs.t","counters":[]},{"line":"    -> ( Transaction.Valid.t With_status.t list","counters":[]},{"line":"         * Transaction_snark_work.t list","counters":[]},{"line":"         * int","counters":[]},{"line":"         * Currency.Amount.t list","counters":[]},{"line":"       , Error.t )","counters":[]},{"line":"       result","counters":[]},{"line":"","counters":[]},{"line":"  val get_transactions :","counters":[]},{"line":"       constraint_constants:Genesis_constants.Constraint_constants.t","counters":[]},{"line":"    -> coinbase_receiver:Public_key.Compressed.t","counters":[]},{"line":"    -> supercharge_coinbase:bool","counters":[]},{"line":"    -> Staged_ledger_diff.t","counters":[]},{"line":"    -> (Transaction.t With_status.t list, Error.t) result","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Error = struct","counters":[]},{"line":"  type t =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    | Verification_failed of Verifier.Failure.t","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Coinbase_error of string","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Insufficient_fee of Currency.Fee.t * Currency.Fee.t","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Internal_command_status_mismatch","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Unexpected of Error.t","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  [@@deriving sexp]","counters":[]},{"line":"","counters":[]},{"line":"  let to_string = function","counters":[]},{"line":"    | Verification_failed t ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Format.asprintf !\"Failed to verify: %{sexp: Verifier.Failure.t} \\n\" t","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"    | Coinbase_error err ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Format.asprintf !\"Coinbase error: %s \\n\" err","counters":[]},{"line":"    | Insufficient_fee (f1, f2) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Format.asprintf","counters":[]},{"line":"          !\"Transaction fees %{sexp: Currency.Fee.t} does not suffice proof \\","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"            fees %{sexp: Currency.Fee.t} \\n\"","counters":[]},{"line":"          f1 f2","counters":[]},{"line":"    | Internal_command_status_mismatch ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        \"Internal command statuses did not match\"","counters":[]},{"line":"    | Unexpected e ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Error.to_string_hum e","counters":[]},{"line":"","counters":[]},{"line":"  let to_error = Fn.compose Error.of_string to_string","counters":[{"col_start":26,"col_end":26,"count":1}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"type 't t =","counters":[]},{"line":"  { transactions : 't With_status.t list","counters":[]},{"line":"  ; work : Transaction_snark_work.t list","counters":[]},{"line":"  ; commands_count : int","counters":[]},{"line":"  ; coinbases : Currency.Amount.t list","counters":[]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"(*A Coinbase is a single transaction that accommodates the coinbase amount","counters":[]},{"line":"    and a fee transfer for the work required to add the coinbase. It also","counters":[]},{"line":"    contains the state body hash corresponding to a particular protocol state.","counters":[]},{"line":"    Unlike a transaction, a coinbase (including the fee transfer) just requires one slot","counters":[]},{"line":"    in the jobs queue.","counters":[]},{"line":"","counters":[]},{"line":"    The minimum number of slots required to add a single transaction is three (at","counters":[]},{"line":"    worst case number of provers: when each pair of proofs is from a different","counters":[]},{"line":"    prover). One slot for the transaction and two slots for fee transfers.","counters":[]},{"line":"","counters":[]},{"line":"    When the diff is split into two prediffs (why? refer to #687) and if after","counters":[]},{"line":"    adding transactions, the first prediff has two slots remaining which cannot","counters":[]},{"line":"    not accommodate transactions, then those slots are filled by splitting the","counters":[]},{"line":"    coinbase into two parts.","counters":[]},{"line":"","counters":[]},{"line":"    If it has one slot, then we simply add one coinbase. It is also possible that","counters":[]},{"line":"    the first prediff may have no slots left after adding transactions (for","counters":[]},{"line":"    example, when there are three slots and maximum number of provers), in which case,","counters":[]},{"line":"    we simply add one coinbase as part of the second prediff.","counters":[]},{"line":"*)","counters":[]},{"line":"let create_coinbase","counters":[]},{"line":"    ~(constraint_constants : Genesis_constants.Constraint_constants.t)","counters":[]},{"line":"    coinbase_parts ~(receiver : Public_key.Compressed.t) ~coinbase_amount =","counters":[]},{"line":"  let open Result.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let coinbase_or_error = function","counters":[]},{"line":"    | Ok x ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Ok x","counters":[]},{"line":"    | Error e ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Error (Error.Coinbase_error (Core.Error.to_string_hum e))","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"  in","counters":[]},{"line":"  let underflow_err a1 a2 =","counters":[]},{"line":"    Option.value_map","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ~default:","counters":[]},{"line":"        (Error","counters":[]},{"line":"           (Error.Coinbase_error","counters":[]},{"line":"              (sprintf","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                 !\"underflow when splitting coinbase: Minuend: %{sexp: \\","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                   Currency.Amount.t} Subtrahend: %{sexp: Currency.Amount.t} \\n\"","counters":[]},{"line":"                 a1 a2 ) ) )","counters":[]},{"line":"      (Currency.Amount.sub a1 a2)","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"      ~f:(fun x -> Ok x)","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"  in","counters":[]},{"line":"  let two_parts amt ft1 (ft2 : Coinbase.Fee_transfer.t option) =","counters":[]},{"line":"    let%bind rem_coinbase = underflow_err coinbase_amount amt in","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"    let%bind _ =","counters":[]},{"line":"      underflow_err rem_coinbase","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"        (Option.value_map ~default:Currency.Amount.zero ft2","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"           ~f:(fun { fee; _ } -> Currency.Amount.of_fee fee) )","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"    in","counters":[]},{"line":"    let%bind cb1 =","counters":[]},{"line":"      coinbase_or_error","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"        (Coinbase.create ~amount:amt ~receiver ~fee_transfer:ft1)","counters":[]},{"line":"    in","counters":[]},{"line":"    let%map cb2 =","counters":[]},{"line":"      Coinbase.create ~amount:rem_coinbase ~receiver ~fee_transfer:ft2","counters":[]},{"line":"      |> coinbase_or_error","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"    in","counters":[]},{"line":"    [ cb1; cb2 ]","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  in","counters":[]},{"line":"  match coinbase_parts with","counters":[]},{"line":"  | `Zero ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      return []","counters":[]},{"line":"  | `One x ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let%map cb =","counters":[]},{"line":"        Coinbase.create ~amount:coinbase_amount ~receiver ~fee_transfer:x","counters":[]},{"line":"        |> coinbase_or_error","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"      in","counters":[]},{"line":"      [ cb ]","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  | `Two None ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      two_parts","counters":[]},{"line":"        (Currency.Amount.of_fee constraint_constants.account_creation_fee)","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"        None None","counters":[]},{"line":"  | `Two (Some (({ Coinbase.Fee_transfer.fee; _ } as ft1), ft2)) ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let%bind amount =","counters":[]},{"line":"        let%map fee =","counters":[]},{"line":"          Currency.Fee.add constraint_constants.account_creation_fee fee","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"          |> Option.value_map","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"               ~default:","counters":[]},{"line":"                 (Error","counters":[]},{"line":"                    (Error.Coinbase_error","counters":[]},{"line":"                       (sprintf","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                          !\"Overflow when trying to add account_creation_fee \\","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                            %{sexp: Currency.Fee.t} to a fee transfer %{sexp: \\","counters":[]},{"line":"                            Currency.Fee.t}\"","counters":[]},{"line":"                          constraint_constants.account_creation_fee fee ) ) )","counters":[]},{"line":"               ~f:(fun v -> Ok v)","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"        in","counters":[]},{"line":"        Currency.Amount.of_fee fee","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      in","counters":[]},{"line":"      two_parts amount (Some ft1) ft2","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"let sum_fees xs ~f =","counters":[]},{"line":"  with_return (fun { return } ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      Ok","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (List.fold ~init:Currency.Fee.zero xs ~f:(fun acc x ->","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"             match Currency.Fee.add acc (f x) with","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"             | None ->","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                 return (Or_error.error_string \"Fee overflow\")","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"             | Some res ->","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                 res ) ) )","counters":[]},{"line":"","counters":[]},{"line":"let to_staged_ledger_or_error =","counters":[]},{"line":"  Result.map_error ~f:(fun error -> Error.Unexpected error)","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"","counters":[]},{"line":"let fee_remainder (type c) (commands : c With_status.t list) completed_works","counters":[]},{"line":"    coinbase_fee ~forget =","counters":[]},{"line":"  let open Result.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%bind budget =","counters":[]},{"line":"    sum_fees commands ~f:(fun { data = t; _ } -> User_command.fee (forget t))","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":49,"col_end":49,"count":0},{"col_start":72,"col_end":72,"count":0}]},{"line":"    |> to_staged_ledger_or_error","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%bind work_fee =","counters":[]},{"line":"    sum_fees completed_works ~f:(fun { Transaction_snark_work.fee; _ } -> fee)","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":74,"col_end":74,"count":0}]},{"line":"    |> to_staged_ledger_or_error","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"  in","counters":[]},{"line":"  let total_work_fee =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Option.value ~default:Currency.Fee.zero","counters":[]},{"line":"      (Currency.Fee.sub work_fee coinbase_fee)","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"  in","counters":[]},{"line":"  Option.value_map","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    ~default:(Error (Error.Insufficient_fee (budget, total_work_fee)))","counters":[]},{"line":"    ~f:(fun x -> Ok x)","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"    (Currency.Fee.sub budget total_work_fee)","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"","counters":[]},{"line":"let create_fee_transfers completed_works delta public_key coinbase_fts =","counters":[]},{"line":"  let open Result.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let singles =","counters":[]},{"line":"    (if Currency.Fee.(equal zero delta) then [] else [ (public_key, delta) ])","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"    @ List.filter_map completed_works","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"        ~f:(fun { Transaction_snark_work.fee; prover; _ } ->","counters":[]},{"line":"          if Currency.Fee.equal fee Currency.Fee.zero then None","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"          else Some (prover, fee) )","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%bind singles_map =","counters":[]},{"line":"    Or_error.try_with (fun () ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"        Public_key.Compressed.Map.of_alist_reduce singles ~f:(fun f1 f2 ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            Option.value_exn (Currency.Fee.add f1 f2) ) )","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"    |> to_staged_ledger_or_error","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"  in","counters":[]},{"line":"  (* deduct the coinbase work fee from the singles_map. It is already part of the coinbase *)","counters":[]},{"line":"  Or_error.try_with (fun () ->","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"      List.fold coinbase_fts ~init:singles_map","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":14,"col_end":14,"count":0}]},{"line":"        ~f:(fun accum { Coinbase.Fee_transfer.receiver_pk; fee = cb_fee } ->","counters":[]},{"line":"          match Public_key.Compressed.Map.find accum receiver_pk with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              accum","counters":[]},{"line":"          | Some fee ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let new_fee = Option.value_exn (Currency.Fee.sub fee cb_fee) in","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"              if Currency.Fee.(new_fee > Currency.Fee.zero) then","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Public_key.Compressed.Map.update accum receiver_pk ~f:(fun _ ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                    new_fee )","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"              else Public_key.Compressed.Map.remove accum receiver_pk )","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"      (* TODO: This creates a weird incentive to have a small public_key *)","counters":[]},{"line":"      |> Map.to_alist ~key_order:`Increasing","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"      |> List.map ~f:(fun (receiver_pk, fee) ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"             Fee_transfer.Single.create ~receiver_pk ~fee","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"               ~fee_token:Token_id.default )","counters":[]},{"line":"      |> One_or_two.group_list","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"      |> List.map ~f:Fee_transfer.of_singles","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"      |> Or_error.all )","counters":[]},{"line":"  |> Or_error.join |> to_staged_ledger_or_error","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"","counters":[]},{"line":"module Transaction_data = struct","counters":[]},{"line":"  type 'a t =","counters":[]},{"line":"    { commands : 'a With_status.t list","counters":[]},{"line":"    ; coinbases : Coinbase.t list","counters":[]},{"line":"    ; fee_transfers : Fee_transfer.t list","counters":[]},{"line":"    }","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let get_transaction_data (type c) ~constraint_constants coinbase_parts ~receiver","counters":[]},{"line":"    ~coinbase_amount commands completed_works ~(forget : c -> _) =","counters":[]},{"line":"  let open Result.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%bind coinbases =","counters":[]},{"line":"    O1trace.sync_thread \"create_coinbase\" (fun () ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"        create_coinbase ~constraint_constants coinbase_parts ~receiver","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ~coinbase_amount )","counters":[]},{"line":"  in","counters":[]},{"line":"  let coinbase_fts =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    List.concat_map coinbases ~f:(fun cb -> Option.to_list cb.fee_transfer)","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"  in","counters":[]},{"line":"  let coinbase_work_fees =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    sum_fees ~f:Coinbase.Fee_transfer.fee coinbase_fts |> Or_error.ok_exn","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"  in","counters":[]},{"line":"  let txn_works_others =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    List.filter completed_works ~f:(fun { Transaction_snark_work.prover; _ } ->","counters":[]},{"line":"        not (Public_key.Compressed.equal receiver prover) )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%bind delta =","counters":[]},{"line":"    fee_remainder commands txn_works_others coinbase_work_fees ~forget","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%map fee_transfers =","counters":[]},{"line":"    create_fee_transfers txn_works_others delta receiver coinbase_fts","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"  in","counters":[]},{"line":"  { Transaction_data.commands; coinbases; fee_transfers }","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let get_individual_info (type c) ~constraint_constants coinbase_parts ~receiver","counters":[]},{"line":"    ~coinbase_amount commands completed_works ~(forget : c -> _)","counters":[]},{"line":"    ~internal_command_statuses =","counters":[]},{"line":"  let open Result.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%bind { Transaction_data.commands","counters":[]},{"line":"           ; coinbases = coinbase_parts","counters":[]},{"line":"           ; fee_transfers","counters":[]},{"line":"           } =","counters":[]},{"line":"    get_transaction_data ~constraint_constants coinbase_parts ~receiver","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"      ~coinbase_amount commands completed_works ~forget","counters":[]},{"line":"  in","counters":[]},{"line":"  let internal_commands =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    List.map coinbase_parts ~f:(fun t -> Transaction.Coinbase t)","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"    @ List.map fee_transfers ~f:(fun t -> Transaction.Fee_transfer t)","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%map internal_commands_with_statuses =","counters":[]},{"line":"    Or_error.try_with (fun () ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"        List.map2_exn internal_commands internal_command_statuses","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ~f:(fun cmd status ->","counters":[]},{"line":"            match cmd with","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            | Transaction.Coinbase _ | Transaction.Fee_transfer _ ->","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"                { With_status.data = cmd; status }","counters":[]},{"line":"            | _ ->","counters":[]},{"line":"                (* Caught by [try_with] above, it doesn't matter what we throw. *)","counters":[]},{"line":"                assert false ) )","counters":[]},{"line":"    |> Result.map_error ~f:(fun _ -> Error.Internal_command_status_mismatch)","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"  in","counters":[]},{"line":"  let transactions =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    List.map commands ~f:(With_status.map ~f:(fun t -> Transaction.Command t))","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"    @ internal_commands_with_statuses","counters":[]},{"line":"  in","counters":[]},{"line":"  { transactions","counters":[]},{"line":"  ; work = completed_works","counters":[]},{"line":"  ; commands_count = List.length commands","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"  ; coinbases =","counters":[]},{"line":"      List.map coinbase_parts ~f:(fun Coinbase.{ amount; _ } -> amount)","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"let generate_statuses (type c) ~constraint_constants coinbase_parts ~receiver","counters":[]},{"line":"    ~coinbase_amount commands completed_works ~(forget : c -> _)","counters":[]},{"line":"    ~generate_status =","counters":[]},{"line":"  let open Result.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%bind { Transaction_data.commands; coinbases; fee_transfers } =","counters":[]},{"line":"    get_transaction_data ~constraint_constants coinbase_parts ~receiver","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"      ~coinbase_amount commands completed_works ~forget","counters":[]},{"line":"  in","counters":[]},{"line":"  let%bind transactions =","counters":[]},{"line":"    Or_error.try_with (fun () ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"        List.map commands ~f:(fun cmd ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            { With_status.data = cmd.With_status.data","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            ; status =","counters":[]},{"line":"                Or_error.ok_exn","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                  (generate_status (Transaction.Command (forget cmd.data)))","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"            } ) )","counters":[]},{"line":"    |> Result.map_error ~f:(fun err -> Error.Unexpected err)","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"  in","counters":[]},{"line":"  (*Order of application is user-commands, coinbase, fee transfers. See [get_individual_info]*)","counters":[]},{"line":"  let internal_commands =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    List.map coinbases ~f:(fun t -> Transaction.Coinbase t)","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"    @ List.map fee_transfers ~f:(fun t -> Transaction.Fee_transfer t)","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%map internal_command_statuses =","counters":[]},{"line":"    Or_error.try_with (fun () ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"        List.map internal_commands ~f:(fun cmd ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            Or_error.ok_exn (generate_status cmd) ) )","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"    |> Result.map_error ~f:(fun err -> Error.Unexpected err)","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"  in","counters":[]},{"line":"  (transactions, internal_command_statuses)","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"open Staged_ledger_diff","counters":[]},{"line":"","counters":[]},{"line":"let check_coinbase (diff : _ Pre_diff_two.t * _ Pre_diff_one.t option) =","counters":[]},{"line":"  match","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    ( (fst diff).coinbase","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"    , Option.value_map ~default:At_most_one.Zero (snd diff) ~f:(fun d ->","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"          d.coinbase ) )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"  with","counters":[]},{"line":"  | Zero, Zero | Zero, One _ | One _, Zero | Two _, Zero ->","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"      Ok ()","counters":[]},{"line":"  | x, y ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Error","counters":[]},{"line":"        (Error.Coinbase_error","counters":[]},{"line":"           (sprintf","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"              !\"Invalid coinbase value in staged ledger prediffs \\","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                %{sexp:Coinbase.Fee_transfer.t At_most_two.t} and \\","counters":[]},{"line":"                %{sexp:Coinbase.Fee_transfer.t At_most_one.t}\"","counters":[]},{"line":"              x y ) )","counters":[]},{"line":"","counters":[]},{"line":"let compute_statuses (type c)","counters":[]},{"line":"    ~(constraint_constants : Genesis_constants.Constraint_constants.t) ~diff","counters":[]},{"line":"    ~coinbase_receiver ~coinbase_amount ~generate_status ~(forget : c -> _) =","counters":[]},{"line":"  let open Result.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let get_statuses_pre_diff_with_at_most_two","counters":[]},{"line":"      (t1 : (_, c With_status.t) Pre_diff_two.t) =","counters":[]},{"line":"    let coinbase_parts =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      match t1.coinbase with Zero -> `Zero | One x -> `One x | Two x -> `Two x","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"    in","counters":[]},{"line":"    let%map commands, internal_command_statuses =","counters":[]},{"line":"      generate_statuses ~constraint_constants ~generate_status coinbase_parts","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"        ~receiver:coinbase_receiver t1.commands t1.completed_works","counters":[]},{"line":"        ~coinbase_amount ~forget","counters":[]},{"line":"    in","counters":[]},{"line":"    ( { commands","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      ; completed_works = t1.completed_works","counters":[]},{"line":"      ; coinbase = t1.coinbase","counters":[]},{"line":"      ; internal_command_statuses","counters":[]},{"line":"      }","counters":[]},{"line":"      : _ Pre_diff_two.t )","counters":[]},{"line":"  in","counters":[]},{"line":"  let get_statuses_pre_diff_with_at_most_one","counters":[]},{"line":"      (t2 : (_, c With_status.t) Pre_diff_one.t) =","counters":[]},{"line":"    let coinbase_added =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      match t2.coinbase with Zero -> `Zero | One x -> `One x","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"    in","counters":[]},{"line":"    let%map commands, internal_command_statuses =","counters":[]},{"line":"      generate_statuses ~constraint_constants ~generate_status coinbase_added","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"        ~receiver:coinbase_receiver t2.commands t2.completed_works","counters":[]},{"line":"        ~coinbase_amount ~forget","counters":[]},{"line":"    in","counters":[]},{"line":"    Some","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ( { commands","counters":[]},{"line":"        ; completed_works = t2.completed_works","counters":[]},{"line":"        ; coinbase = t2.coinbase","counters":[]},{"line":"        ; internal_command_statuses","counters":[]},{"line":"        }","counters":[]},{"line":"        : _ Pre_diff_one.t )","counters":[]},{"line":"  in","counters":[]},{"line":"  let%bind p1 = get_statuses_pre_diff_with_at_most_two (fst diff) in","counters":[{"col_start":53,"col_end":53,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"  let%map p2 =","counters":[]},{"line":"    Option.value_map ~f:get_statuses_pre_diff_with_at_most_one (snd diff)","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"      ~default:(Ok None)","counters":[]},{"line":"  in","counters":[]},{"line":"  (p1, p2)","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let get' (type c)","counters":[]},{"line":"    ~(constraint_constants : Genesis_constants.Constraint_constants.t) ~diff","counters":[]},{"line":"    ~coinbase_receiver ~coinbase_amount ~(forget : c -> _) =","counters":[]},{"line":"  let open Result.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%bind coinbase_amount =","counters":[]},{"line":"    Option.value_map coinbase_amount","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"      ~default:","counters":[]},{"line":"        (Error","counters":[]},{"line":"           (Error.Coinbase_error","counters":[]},{"line":"              (sprintf","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                 !\"Overflow when calculating coinbase amount: Supercharged \\","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                   coinbase factor (%d) x coinbase amount (%{sexp: \\","counters":[]},{"line":"                   Currency.Amount.t})\"","counters":[]},{"line":"                 constraint_constants.supercharged_coinbase_factor","counters":[]},{"line":"                 constraint_constants.coinbase_amount ) ) )","counters":[]},{"line":"      ~f:(fun x -> Ok x)","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"  in","counters":[]},{"line":"  let apply_pre_diff_with_at_most_two (t1 : (_, c With_status.t) Pre_diff_two.t)","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      =","counters":[]},{"line":"    let coinbase_parts =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      match t1.coinbase with Zero -> `Zero | One x -> `One x | Two x -> `Two x","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"    in","counters":[]},{"line":"    get_individual_info coinbase_parts ~receiver:coinbase_receiver t1.commands","counters":[]},{"line":"      t1.completed_works ~coinbase_amount ~forget","counters":[]},{"line":"      ~internal_command_statuses:t1.internal_command_statuses","counters":[]},{"line":"  in","counters":[]},{"line":"  let apply_pre_diff_with_at_most_one (t2 : (_, c With_status.t) Pre_diff_one.t)","counters":[]},{"line":"      =","counters":[]},{"line":"    let coinbase_added =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      match t2.coinbase with Zero -> `Zero | One x -> `One x","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"    in","counters":[]},{"line":"    get_individual_info coinbase_added ~receiver:coinbase_receiver t2.commands","counters":[]},{"line":"      t2.completed_works ~coinbase_amount ~forget","counters":[]},{"line":"      ~internal_command_statuses:t2.internal_command_statuses","counters":[]},{"line":"  in","counters":[]},{"line":"  let%bind () = check_coinbase diff in","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"  let%bind p1 =","counters":[]},{"line":"    apply_pre_diff_with_at_most_two ~constraint_constants (fst diff)","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%map p2 =","counters":[]},{"line":"    Option.value_map","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"      ~f:(fun d -> apply_pre_diff_with_at_most_one ~constraint_constants d)","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"      (snd diff)","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"      ~default:","counters":[]},{"line":"        (Ok { transactions = []; work = []; commands_count = 0; coinbases = [] })","counters":[]},{"line":"  in","counters":[]},{"line":"  ( p1.transactions @ p2.transactions","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  , p1.work @ p2.work","counters":[]},{"line":"  , p1.commands_count + p2.commands_count","counters":[]},{"line":"  , p1.coinbases @ p2.coinbases )","counters":[]},{"line":"","counters":[]},{"line":"(* TODO: This is important *)","counters":[]},{"line":"let get ~check ~constraint_constants ~coinbase_receiver ~supercharge_coinbase t","counters":[]},{"line":"    =","counters":[]},{"line":"  let open Async in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  match%map validate_commands t ~check with","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"  | Error e ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Error (Error.Unexpected e)","counters":[]},{"line":"  | Ok (Error e) ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Error (Error.Verification_failed e)","counters":[]},{"line":"  | Ok (Ok diff) ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      get' ~constraint_constants ~forget:User_command.forget_check","counters":[]},{"line":"        ~diff:diff.diff ~coinbase_receiver","counters":[]},{"line":"        ~coinbase_amount:","counters":[]},{"line":"          (Staged_ledger_diff.With_valid_signatures.coinbase","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"             ~constraint_constants ~supercharge_coinbase diff )","counters":[]},{"line":"","counters":[]},{"line":"let get_unchecked ~constraint_constants ~coinbase_receiver ~supercharge_coinbase","counters":[]},{"line":"    (t : With_valid_signatures_and_proofs.t) =","counters":[]},{"line":"  let t = forget_proof_checks t in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  get' ~constraint_constants ~diff:t.diff ~coinbase_receiver","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    ~forget:User_command.forget_check","counters":[]},{"line":"    ~coinbase_amount:","counters":[]},{"line":"      (Staged_ledger_diff.With_valid_signatures.coinbase ~constraint_constants","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"         ~supercharge_coinbase t )","counters":[]},{"line":"","counters":[]},{"line":"let get_transactions ~constraint_constants ~coinbase_receiver","counters":[]},{"line":"    ~supercharge_coinbase (sl_diff : t) =","counters":[]},{"line":"  let open Result.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%map transactions, _, _, _ =","counters":[]},{"line":"    get' ~constraint_constants ~diff:sl_diff.diff ~coinbase_receiver","counters":[]},{"line":"      ~forget:Fn.id","counters":[]},{"line":"      ~coinbase_amount:","counters":[]},{"line":"        (Staged_ledger_diff.coinbase ~constraint_constants ~supercharge_coinbase","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"           sl_diff )","counters":[]},{"line":"  in","counters":[]},{"line":"  transactions","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":13,"col_end":13,"count":1}]}]}