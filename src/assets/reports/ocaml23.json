{"filename":"src/lib/prover/prover.ml","lines":[{"line":"open Core","counters":[]},{"line":"open Async","counters":[]},{"line":"open Mina_base","counters":[]},{"line":"open Mina_state","counters":[]},{"line":"open Mina_block","counters":[]},{"line":"open Blockchain_snark","counters":[]},{"line":"","counters":[]},{"line":"module type S = Intf.S","counters":[]},{"line":"","counters":[]},{"line":"module Extend_blockchain_input = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    [@@@no_toplevel_latest_type]","counters":[]},{"line":"","counters":[]},{"line":"    module V2 = struct","counters":[]},{"line":"      type t =","counters":[{"col_start":6,"col_end":6,"count":2},{"col_start":11,"col_end":11,"count":2}]},{"line":"        { chain : Blockchain.Stable.V2.t","counters":[]},{"line":"        ; next_state : Protocol_state.Value.Stable.V2.t","counters":[]},{"line":"        ; block : Snark_transition.Value.Stable.V2.t","counters":[]},{"line":"        ; ledger_proof : Ledger_proof.Stable.V2.t option","counters":[]},{"line":"        ; prover_state : Consensus.Data.Prover_state.Stable.V2.t","counters":[]},{"line":"        ; pending_coinbase : Pending_coinbase_witness.Stable.V2.t","counters":[]},{"line":"        }","counters":[{"col_start":8,"col_end":8,"count":5}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  type t = Stable.Latest.t =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    { chain : Blockchain.t","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":10,"col_end":10,"count":0}]},{"line":"    ; next_state : Protocol_state.Value.t","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"    ; block : Snark_transition.Value.t","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":10,"col_end":10,"count":0}]},{"line":"    ; ledger_proof : Ledger_proof.t option","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"    ; prover_state : Consensus.Data.Prover_state.t","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"    ; pending_coinbase : Pending_coinbase_witness.t","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"    }","counters":[]},{"line":"  [@@deriving sexp]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Consensus_mechanism = Consensus","counters":[]},{"line":"module Blockchain = Blockchain","counters":[]},{"line":"","counters":[]},{"line":"module Worker_state = struct","counters":[]},{"line":"  module type S = sig","counters":[]},{"line":"    val extend_blockchain :","counters":[]},{"line":"         Blockchain.t","counters":[]},{"line":"      -> Protocol_state.Value.t","counters":[]},{"line":"      -> Snark_transition.value","counters":[]},{"line":"      -> Ledger_proof.t option","counters":[]},{"line":"      -> Consensus.Data.Prover_state.t","counters":[]},{"line":"      -> Pending_coinbase_witness.t","counters":[]},{"line":"      -> Blockchain.t Async.Deferred.Or_error.t","counters":[]},{"line":"","counters":[]},{"line":"    val verify : Protocol_state.Value.t -> Proof.t -> bool Deferred.t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  (* bin_io required by rpc_parallel *)","counters":[]},{"line":"  type init_arg =","counters":[{"col_start":2,"col_end":2,"count":1},{"col_start":14,"col_end":14,"count":2}]},{"line":"    { conf_dir : string","counters":[]},{"line":"    ; logger : Logger.Stable.Latest.t","counters":[]},{"line":"    ; proof_level : Genesis_constants.Proof_level.t","counters":[]},{"line":"    ; constraint_constants : Genesis_constants.Constraint_constants.t","counters":[]},{"line":"    }","counters":[]},{"line":"  [@@deriving bin_io_unversioned]","counters":[{"col_start":32,"col_end":32,"count":4}]},{"line":"","counters":[]},{"line":"  type t = (module S)","counters":[]},{"line":"","counters":[]},{"line":"  let ledger_proof_opt (chain : Blockchain.t) next_state = function","counters":[]},{"line":"    | Some t ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Ledger_proof.","counters":[]},{"line":"          ({ (statement t) with sok_digest = sok_digest t }, underlying_proof t)","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":54,"col_end":54,"count":0},{"col_start":76,"col_end":76,"count":0}]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let bs = Protocol_state.blockchain_state in","counters":[]},{"line":"        let reg x =","counters":[]},{"line":"          { (bs x).Blockchain_state.Poly.registers with","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":14,"col_end":14,"count":0}]},{"line":"            pending_coinbase_stack = Pending_coinbase.Stack.empty","counters":[]},{"line":"          }","counters":[]},{"line":"        in","counters":[]},{"line":"        let chain_state = Blockchain_snark.Blockchain.state chain in","counters":[]},{"line":"        ( { source = reg chain_state","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"          ; target = reg next_state","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"          ; supply_increase = Currency.Amount.Signed.zero","counters":[]},{"line":"          ; fee_excess = Fee_excess.zero","counters":[]},{"line":"          ; sok_digest = Sok_message.Digest.default","counters":[]},{"line":"          }","counters":[]},{"line":"        , Proof.transaction_dummy )","counters":[]},{"line":"","counters":[]},{"line":"  let create { logger; proof_level; constraint_constants; _ } : t Deferred.t =","counters":[]},{"line":"    Deferred.return","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (let m =","counters":[]},{"line":"         match proof_level with","counters":[]},{"line":"         | Genesis_constants.Proof_level.Full ->","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"             ( module struct","counters":[]},{"line":"               module T = Transaction_snark.Make (struct","counters":[]},{"line":"                 let constraint_constants = constraint_constants","counters":[]},{"line":"","counters":[]},{"line":"                 let proof_level = proof_level","counters":[]},{"line":"               end)","counters":[]},{"line":"","counters":[]},{"line":"               module B = Blockchain_snark.Blockchain_snark_state.Make (struct","counters":[]},{"line":"                 let tag = T.tag","counters":[]},{"line":"","counters":[]},{"line":"                 let constraint_constants = constraint_constants","counters":[]},{"line":"","counters":[]},{"line":"                 let proof_level = proof_level","counters":[]},{"line":"               end)","counters":[]},{"line":"","counters":[]},{"line":"               let (_ : Pickles.Dirty.t) =","counters":[]},{"line":"                 Pickles.Cache_handle.generate_or_load B.cache_handle","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"","counters":[]},{"line":"               let extend_blockchain (chain : Blockchain.t)","counters":[]},{"line":"                   (next_state : Protocol_state.Value.t)","counters":[]},{"line":"                   (block : Snark_transition.value) (t : Ledger_proof.t option)","counters":[]},{"line":"                   state_for_handler pending_coinbase =","counters":[]},{"line":"                 let%map.Async.Deferred res =","counters":[]},{"line":"                   Deferred.Or_error.try_with ~here:[%here] (fun () ->","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"                       let txn_snark_statement, txn_snark_proof =","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                         ledger_proof_opt chain next_state t","counters":[]},{"line":"                       in","counters":[]},{"line":"                       let%map.Async.Deferred (), (), proof =","counters":[]},{"line":"                         B.step","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                           ~handler:","counters":[]},{"line":"                             (Consensus.Data.Prover_state.handler","counters":[{"col_start":64,"col_end":64,"count":0}]},{"line":"                                ~constraint_constants state_for_handler","counters":[]},{"line":"                                ~pending_coinbase )","counters":[]},{"line":"                           { transition = block","counters":[]},{"line":"                           ; prev_state =","counters":[]},{"line":"                               Blockchain_snark.Blockchain.state chain","counters":[{"col_start":63,"col_end":63,"count":0}]},{"line":"                           ; prev_state_proof =","counters":[]},{"line":"                               Blockchain_snark.Blockchain.proof chain","counters":[{"col_start":63,"col_end":63,"count":0}]},{"line":"                           ; txn_snark = txn_snark_statement","counters":[]},{"line":"                           ; txn_snark_proof","counters":[]},{"line":"                           }","counters":[]},{"line":"                           next_state","counters":[]},{"line":"                       in","counters":[]},{"line":"                       Blockchain_snark.Blockchain.create ~state:next_state","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                         ~proof )","counters":[]},{"line":"                 in","counters":[]},{"line":"                 Or_error.iter_error res ~f:(fun e ->","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                     [%log error]","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"                       ~metadata:[ (\"error\", Error_json.error_to_yojson e) ]","counters":[{"col_start":70,"col_end":70,"count":0}]},{"line":"                       \"Prover threw an error while extending block: $error\" ) ;","counters":[]},{"line":"                 res","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"","counters":[]},{"line":"               let verify state proof = B.Proof.verify [ (state, proof) ]","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"             end : S )","counters":[]},{"line":"         | Check ->","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"             ( module struct","counters":[]},{"line":"               module Transaction_snark = Transaction_snark","counters":[]},{"line":"","counters":[]},{"line":"               let extend_blockchain (chain : Blockchain.t)","counters":[]},{"line":"                   (next_state : Protocol_state.Value.t)","counters":[]},{"line":"                   (block : Snark_transition.value) (t : Ledger_proof.t option)","counters":[]},{"line":"                   state_for_handler pending_coinbase =","counters":[]},{"line":"                 let t, _proof = ledger_proof_opt chain next_state t in","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                 let res =","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                   Blockchain_snark.Blockchain_snark_state.check ~proof_level","counters":[{"col_start":63,"col_end":63,"count":0}]},{"line":"                     ~constraint_constants","counters":[]},{"line":"                     { transition = block","counters":[]},{"line":"                     ; prev_state = Blockchain_snark.Blockchain.state chain","counters":[{"col_start":68,"col_end":68,"count":0}]},{"line":"                     ; prev_state_proof = Mina_base.Proof.blockchain_dummy","counters":[]},{"line":"                     ; txn_snark = t","counters":[]},{"line":"                     ; txn_snark_proof = Mina_base.Proof.transaction_dummy","counters":[]},{"line":"                     }","counters":[]},{"line":"                     ~handler:","counters":[]},{"line":"                       (Consensus.Data.Prover_state.handler state_for_handler","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"                          ~constraint_constants ~pending_coinbase )","counters":[]},{"line":"                     next_state","counters":[]},{"line":"                   |> Or_error.map ~f:(fun () ->","counters":[]},{"line":"                          Blockchain_snark.Blockchain.create ~state:next_state","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            ~proof:Mina_base.Proof.blockchain_dummy )","counters":[]},{"line":"                 in","counters":[]},{"line":"                 Or_error.iter_error res ~f:(fun e ->","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                     [%log error]","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"                       ~metadata:[ (\"error\", Error_json.error_to_yojson e) ]","counters":[{"col_start":70,"col_end":70,"count":0}]},{"line":"                       \"Prover threw an error while extending block: $error\" ) ;","counters":[]},{"line":"                 Async.Deferred.return res","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"","counters":[]},{"line":"               let verify _state _proof = Deferred.return true","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"             end : S )","counters":[]},{"line":"         | None ->","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"             ( module struct","counters":[]},{"line":"               module Transaction_snark = Transaction_snark","counters":[]},{"line":"","counters":[]},{"line":"               let extend_blockchain _chain next_state _block _ledger_proof","counters":[]},{"line":"                   _state_for_handler _pending_coinbase =","counters":[]},{"line":"                 Deferred.return","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                 @@ Ok","counters":[]},{"line":"                      (Blockchain_snark.Blockchain.create","counters":[]},{"line":"                         ~proof:Mina_base.Proof.blockchain_dummy","counters":[]},{"line":"                         ~state:next_state )","counters":[]},{"line":"","counters":[]},{"line":"               let verify _ _ = Deferred.return true","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"             end : S )","counters":[]},{"line":"       in","counters":[]},{"line":"       Memory_stats.log_memory_stats logger ~process:\"prover\" ;","counters":[]},{"line":"       m )","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"","counters":[]},{"line":"  let get = Fn.id","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Functions = struct","counters":[]},{"line":"  type ('i, 'o) t =","counters":[]},{"line":"    'i Bin_prot.Type_class.t","counters":[]},{"line":"    * 'o Bin_prot.Type_class.t","counters":[]},{"line":"    * (Worker_state.t -> 'i -> 'o Deferred.t)","counters":[]},{"line":"","counters":[]},{"line":"  let create input output f : ('i, 'o) t = (input, output, f)","counters":[{"col_start":43,"col_end":43,"count":3}]},{"line":"","counters":[]},{"line":"  let initialized =","counters":[]},{"line":"    create bin_unit [%bin_type_class: [ `Initialized ]] (fun w () ->","counters":[{"col_start":9,"col_end":9,"count":1}]},{"line":"        let (module W) = Worker_state.get w in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Deferred.return `Initialized )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"  let extend_blockchain =","counters":[]},{"line":"    create Extend_blockchain_input.Stable.Latest.bin_t","counters":[{"col_start":9,"col_end":9,"count":1}]},{"line":"      [%bin_type_class: Blockchain.Stable.Latest.t Or_error.t]","counters":[]},{"line":"      (fun","counters":[]},{"line":"        w","counters":[]},{"line":"        { chain","counters":[]},{"line":"        ; next_state","counters":[]},{"line":"        ; ledger_proof","counters":[]},{"line":"        ; block","counters":[]},{"line":"        ; prover_state","counters":[]},{"line":"        ; pending_coinbase","counters":[]},{"line":"        }","counters":[]},{"line":"      ->","counters":[]},{"line":"        let (module W) = Worker_state.get w in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        W.extend_blockchain chain next_state block ledger_proof prover_state","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          pending_coinbase )","counters":[]},{"line":"","counters":[]},{"line":"  let verify_blockchain =","counters":[]},{"line":"    create Blockchain.Stable.Latest.bin_t bin_bool (fun w chain ->","counters":[{"col_start":9,"col_end":9,"count":1}]},{"line":"        let (module W) = Worker_state.get w in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        W.verify","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (Blockchain_snark.Blockchain.state chain)","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"          (Blockchain_snark.Blockchain.proof chain) )","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Worker = struct","counters":[]},{"line":"  module T = struct","counters":[]},{"line":"    module F = Rpc_parallel.Function","counters":[]},{"line":"","counters":[]},{"line":"    type 'w functions =","counters":[]},{"line":"      { initialized : ('w, unit, [ `Initialized ]) F.t","counters":[]},{"line":"      ; extend_blockchain :","counters":[]},{"line":"          ('w, Extend_blockchain_input.t, Blockchain.t Or_error.t) F.t","counters":[]},{"line":"      ; verify_blockchain : ('w, Blockchain.t, bool) F.t","counters":[]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    module Worker_state = Worker_state","counters":[]},{"line":"","counters":[]},{"line":"    module Connection_state = struct","counters":[]},{"line":"      (* bin_io required by rpc_parallel *)","counters":[]},{"line":"      type init_arg = unit [@@deriving bin_io_unversioned]","counters":[{"col_start":6,"col_end":6,"count":1},{"col_start":18,"col_end":18,"count":1},{"col_start":57,"col_end":57,"count":4}]},{"line":"","counters":[]},{"line":"      type t = unit","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Functions","counters":[]},{"line":"        (C : Rpc_parallel.Creator","counters":[]},{"line":"               with type worker_state := Worker_state.t","counters":[]},{"line":"                and type connection_state := Connection_state.t) =","counters":[]},{"line":"    struct","counters":[]},{"line":"      let functions =","counters":[]},{"line":"        let f (i, o, f) =","counters":[]},{"line":"          C.create_rpc","counters":[{"col_start":10,"col_end":10,"count":3}]},{"line":"            ~f:(fun ~worker_state ~conn_state:_ i -> f worker_state i)","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"            ~bin_input:i ~bin_output:o ()","counters":[]},{"line":"        in","counters":[]},{"line":"        let open Functions in","counters":[]},{"line":"        { initialized = f initialized","counters":[{"col_start":24,"col_end":24,"count":1}]},{"line":"        ; extend_blockchain = f extend_blockchain","counters":[{"col_start":30,"col_end":30,"count":1}]},{"line":"        ; verify_blockchain = f verify_blockchain","counters":[{"col_start":30,"col_end":30,"count":1}]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"      let init_worker_state","counters":[]},{"line":"          Worker_state.{ conf_dir; logger; proof_level; constraint_constants } =","counters":[]},{"line":"        let max_size = 256 * 1024 * 512 in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let num_rotate = 1 in","counters":[]},{"line":"        Logger.Consumer_registry.register ~id:\"default\"","counters":[]},{"line":"          ~processor:(Logger.Processor.raw ())","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"          ~transport:","counters":[]},{"line":"            (Logger_file_system.dumb_logrotate ~directory:conf_dir","counters":[]},{"line":"               ~log_filename:\"mina-prover.log\" ~max_size ~num_rotate ) ;","counters":[]},{"line":"        [%log info] \"Prover started\" ;","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"        Worker_state.create","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          { conf_dir; logger; proof_level; constraint_constants }","counters":[]},{"line":"","counters":[]},{"line":"      let init_connection_state ~connection:_ ~worker_state:_ () = Deferred.unit","counters":[{"col_start":67,"col_end":67,"count":0}]},{"line":"    end","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  include Rpc_parallel.Make (T)","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"type t =","counters":[]},{"line":"  { connection : Worker.Connection.t; process : Process.t; logger : Logger.t }","counters":[]},{"line":"","counters":[]},{"line":"let create ~logger ~pids ~conf_dir ~proof_level ~constraint_constants =","counters":[]},{"line":"  [%log info] \"Starting a new prover process\" ;","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":12,"col_end":12,"count":0}]},{"line":"  let on_failure err =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    [%log error] \"Prover process failed with error $err\"","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"      ~metadata:[ (\"err\", Error_json.error_to_yojson err) ] ;","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"    Error.raise err","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%map connection, process =","counters":[]},{"line":"    (* HACK: Need to make connection_timeout long since creating a prover can take a long time*)","counters":[]},{"line":"    Worker.spawn_in_foreground_exn ~connection_timeout:(Time.Span.of_min 1.)","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"      ~on_failure ~shutdown_on:Connection_closed ~connection_state_init_arg:()","counters":[]},{"line":"      { conf_dir; logger; proof_level; constraint_constants }","counters":[]},{"line":"  in","counters":[]},{"line":"  [%log info]","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":12,"col_end":12,"count":0}]},{"line":"    \"Daemon started process of kind $process_kind with pid $prover_pid\"","counters":[]},{"line":"    ~metadata:","counters":[]},{"line":"      [ (\"prover_pid\", `Int (Process.pid process |> Pid.to_int))","counters":[{"col_start":39,"col_end":39,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"      ; ( \"process_kind\"","counters":[]},{"line":"        , `String Child_processes.Termination.(show_process_kind Prover) )","counters":[{"col_start":63,"col_end":63,"count":0}]},{"line":"      ] ;","counters":[]},{"line":"  Child_processes.Termination.register_process pids process","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Child_processes.Termination.Prover ;","counters":[]},{"line":"  let exit_or_signal =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Child_processes.Termination.wait_safe ~logger process ~module_:__MODULE__","counters":[]},{"line":"      ~location:__LOC__ ~here:[%here]","counters":[]},{"line":"  in","counters":[]},{"line":"  don't_wait_for","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    ( match%bind exit_or_signal with","counters":[]},{"line":"    | Ok (Ok ()) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [%log fatal] \"Unexpected prover termination, terminating daemon\" ;","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"        Async.exit 1","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    | Ok (Error (`Exit_non_zero n)) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [%log fatal]","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"          \"Prover terminated with nonzero exit code, terminating daemon\"","counters":[]},{"line":"          ~metadata:[ (\"exit_code\", `Int n) ] ;","counters":[]},{"line":"        Async.exit 1","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    | Ok (Error (`Signal signal)) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let signal_str = Signal.to_string signal in","counters":[]},{"line":"        [%log fatal] \"Prover terminated due to signal, terminating daemon\"","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"          ~metadata:[ (\"signal\", `String signal_str) ] ;","counters":[]},{"line":"        Async.exit 1","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    | Error err ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let err_str = Error.to_string_hum err in","counters":[]},{"line":"        [%log fatal] \"Error waiting on prover process, terminating daemon\"","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"          ~metadata:[ (\"error\", `String err_str) ] ;","counters":[]},{"line":"        Async.exit 1 ) ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"  don't_wait_for","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  @@ Pipe.iter","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"       (Process.stdout process |> Reader.pipe)","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"       ~f:(fun stdout ->","counters":[]},{"line":"         return","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"         @@ [%log debug] \"Prover stdout: $stdout\"","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"              ~metadata:[ (\"stdout\", `String stdout) ] ) ;","counters":[]},{"line":"  don't_wait_for","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  @@ Pipe.iter","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"       (Process.stderr process |> Reader.pipe)","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"       ~f:(fun stderr ->","counters":[]},{"line":"         return","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"         @@ [%log error] \"Prover stderr: $stderr\"","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"              ~metadata:[ (\"stderr\", `String stderr) ] ) ;","counters":[]},{"line":"  { connection; process; logger }","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let initialized { connection; _ } =","counters":[]},{"line":"  Worker.Connection.run connection ~f:Worker.functions.initialized ~arg:()","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let prove_from_input_sexp { connection; logger; _ } sexp =","counters":[]},{"line":"  let input = Extend_blockchain_input.t_of_sexp sexp in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  match%map","counters":[]},{"line":"    Worker.Connection.run connection ~f:Worker.functions.extend_blockchain","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"      ~arg:input","counters":[]},{"line":"    >>| Or_error.join","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  with","counters":[]},{"line":"  | Ok _ ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      [%log info] \"prover succeeded :)\" ;","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"      true","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  | Error e ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      [%log error] \"prover errored :(\"","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"        ~metadata:[ (\"error\", Error_json.error_to_yojson e) ] ;","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"      false","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"let extend_blockchain { connection; logger; _ } chain next_state block","counters":[]},{"line":"    ledger_proof prover_state pending_coinbase =","counters":[]},{"line":"  let input =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    { Extend_blockchain_input.chain","counters":[]},{"line":"    ; next_state","counters":[]},{"line":"    ; block","counters":[]},{"line":"    ; ledger_proof","counters":[]},{"line":"    ; prover_state","counters":[]},{"line":"    ; pending_coinbase","counters":[]},{"line":"    }","counters":[]},{"line":"  in","counters":[]},{"line":"  match%map","counters":[]},{"line":"    Worker.Connection.run connection ~f:Worker.functions.extend_blockchain","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"      ~arg:input","counters":[]},{"line":"    >>| Or_error.join","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  with","counters":[]},{"line":"  | Ok x ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Ok x","counters":[]},{"line":"  | Error e ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      [%log error]","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"        ~metadata:","counters":[]},{"line":"          [ ( \"input-sexp\"","counters":[]},{"line":"            , `String (Sexp.to_string (Extend_blockchain_input.sexp_of_t input))","counters":[{"col_start":36,"col_end":36,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"            )","counters":[]},{"line":"          ; ( \"input-bin-io\"","counters":[]},{"line":"            , `String","counters":[]},{"line":"                (Base64.encode_exn","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"                   (Binable.to_string","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"                      (module Extend_blockchain_input.Stable.Latest)","counters":[]},{"line":"                      input ) ) )","counters":[]},{"line":"          ; (\"error\", Error_json.error_to_yojson e)","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"          ]","counters":[]},{"line":"        \"Prover failed: $error\" ;","counters":[]},{"line":"      Error e","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"let prove t ~prev_state ~prev_state_proof ~next_state","counters":[]},{"line":"    (transition : Internal_transition.t) pending_coinbase =","counters":[]},{"line":"  let open Deferred.Or_error.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let start_time = Core.Time.now () in","counters":[]},{"line":"  let%map chain =","counters":[]},{"line":"    extend_blockchain t","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"      (Blockchain.create ~proof:prev_state_proof ~state:prev_state)","counters":[]},{"line":"      next_state","counters":[]},{"line":"      (Internal_transition.snark_transition transition)","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"      (Internal_transition.ledger_proof transition)","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"      (Internal_transition.prover_state transition)","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"      pending_coinbase","counters":[]},{"line":"  in","counters":[]},{"line":"  Mina_metrics.(","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Gauge.set Cryptography.blockchain_proving_time_ms","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"      (Core.Time.Span.to_ms @@ Core.Time.diff (Core.Time.now ()) start_time)) ;","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"  Blockchain_snark.Blockchain.proof chain","counters":[]},{"line":"","counters":[]},{"line":"let create_genesis_block t (genesis_inputs : Genesis_proof.Inputs.t) =","counters":[]},{"line":"  let start_time = Core.Time.now () in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let genesis_ledger = Genesis_ledger.Packed.t genesis_inputs.genesis_ledger in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let constraint_constants = genesis_inputs.constraint_constants in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let consensus_constants = genesis_inputs.consensus_constants in","counters":[]},{"line":"  let prev_state =","counters":[]},{"line":"    let open Staged_ledger_diff in","counters":[]},{"line":"    Protocol_state.negative_one ~genesis_ledger","counters":[]},{"line":"      ~genesis_epoch_data:genesis_inputs.genesis_epoch_data","counters":[]},{"line":"      ~constraint_constants ~consensus_constants ~genesis_body_reference","counters":[]},{"line":"  in","counters":[]},{"line":"  let genesis_epoch_ledger =","counters":[]},{"line":"    match genesis_inputs.genesis_epoch_data with","counters":[]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        genesis_ledger","counters":[]},{"line":"    | Some data ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        data.staking.ledger","counters":[]},{"line":"  in","counters":[]},{"line":"  let open Pickles_types in","counters":[]},{"line":"  let blockchain_dummy =","counters":[]},{"line":"    Pickles.Proof.dummy Nat.N2.n Nat.N2.n Nat.N2.n ~domain_log2:16","counters":[]},{"line":"  in","counters":[]},{"line":"  let snark_transition =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    let open Staged_ledger_diff in","counters":[]},{"line":"    Snark_transition.genesis ~constraint_constants ~consensus_constants","counters":[]},{"line":"      ~genesis_ledger ~genesis_body_reference","counters":[]},{"line":"  in","counters":[]},{"line":"  let pending_coinbase =","counters":[]},{"line":"    { Mina_base.Pending_coinbase_witness.pending_coinbases =","counters":[]},{"line":"        Mina_base.Pending_coinbase.create","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"          ~depth:constraint_constants.pending_coinbase_depth ()","counters":[]},{"line":"        |> Or_error.ok_exn","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"    ; is_new_stack = true","counters":[]},{"line":"    }","counters":[]},{"line":"  in","counters":[]},{"line":"  let prover_state : Consensus_mechanism.Data.Prover_state.t =","counters":[]},{"line":"    Consensus.Data.Prover_state.genesis_data ~genesis_epoch_ledger","counters":[]},{"line":"  in","counters":[]},{"line":"  let%map chain =","counters":[]},{"line":"    extend_blockchain t","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"      (Blockchain.create ~proof:blockchain_dummy ~state:prev_state)","counters":[]},{"line":"      genesis_inputs.protocol_state_with_hashes.data snark_transition None","counters":[]},{"line":"      prover_state pending_coinbase","counters":[]},{"line":"  in","counters":[]},{"line":"  Mina_metrics.(","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Gauge.set Cryptography.blockchain_proving_time_ms","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"      (Core.Time.Span.to_ms @@ Core.Time.diff (Core.Time.now ()) start_time)) ;","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"  chain","counters":[{"col_start":6,"col_end":6,"count":2}]}]}