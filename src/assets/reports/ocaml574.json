{"filename":"src/lib/protocol_version/protocol_version.ml","lines":[{"line":"(* protocol_version.ml -- use semantic versioning *)","counters":[]},{"line":"","counters":[]},{"line":"open Core_kernel","counters":[]},{"line":"module Wire_types = Mina_wire_types.Protocol_version","counters":[]},{"line":"","counters":[]},{"line":"module Make_sig (A : Wire_types.Types.S) = struct","counters":[]},{"line":"  module type S = Protocol_version_intf.Full with type Stable.V1.t = A.V1.t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make_str (A : Wire_types.Concrete) = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type t = A.V1.t = { major : int; minor : int; patch : int }","counters":[{"col_start":6,"col_end":6,"count":2},{"col_start":11,"col_end":11,"count":2},{"col_start":26,"col_end":26,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":43,"col_end":43,"count":0},{"col_start":47,"col_end":47,"count":0},{"col_start":49,"col_end":49,"count":0},{"col_start":52,"col_end":52,"count":0},{"col_start":56,"col_end":56,"count":0},{"col_start":60,"col_end":60,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"      [@@deriving compare, sexp, yojson, fields]","counters":[{"col_start":47,"col_end":47,"count":5}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  let (current_protocol_version : t option ref) = ref None","counters":[]},{"line":"","counters":[]},{"line":"  let (proposed_protocol_version_opt : t option ref) = ref None","counters":[]},{"line":"","counters":[]},{"line":"  let set_current t = current_protocol_version := Some t","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"  let set_proposed_opt t_opt = proposed_protocol_version_opt := t_opt","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"","counters":[]},{"line":"  (* we set current protocol version on daemon startup, so we should not see errors","counters":[]},{"line":"     due to current_protocol_version = None in get_current and create_exn","counters":[]},{"line":"  *)","counters":[]},{"line":"  let get_current () = Option.value_exn !current_protocol_version","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"  let get_proposed_opt () = !proposed_protocol_version_opt","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"","counters":[]},{"line":"  let create_exn ~major ~minor ~patch =","counters":[]},{"line":"    if major < 0 || minor < 0 || patch < 0 then","counters":[{"col_start":4,"col_end":4,"count":1},{"col_start":15,"col_end":15,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"      failwith","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        \"Protocol_version.create: major, minor, and patch must be nonnegative\" ;","counters":[]},{"line":"    { major; minor; patch }","counters":[{"col_start":4,"col_end":4,"count":1}]},{"line":"","counters":[]},{"line":"  let create_opt ~major ~minor ~patch =","counters":[]},{"line":"    try Some (create_exn ~major ~minor ~patch) with _ -> None","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"","counters":[]},{"line":"  let zero = create_exn ~major:0 ~minor:0 ~patch:0","counters":[]},{"line":"","counters":[]},{"line":"  let compatible_with_daemon current_protocol_version =","counters":[]},{"line":"    Int.equal current_protocol_version.major (get_current ()).major","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"","counters":[]},{"line":"  let to_string t = sprintf \"%u.%u.%u\" t.major t.minor t.patch","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"","counters":[]},{"line":"  let is_digit_string s =","counters":[]},{"line":"    String.fold s ~init:true ~f:(fun accum c -> accum && Char.is_digit c)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":48,"col_end":48,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"","counters":[]},{"line":"  let of_string_exn s =","counters":[]},{"line":"    match String.split s ~on:'.' with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | [ major; minor; patch ] ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        if","counters":[]},{"line":"          not","counters":[]},{"line":"            ( is_digit_string major && is_digit_string minor","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"            && is_digit_string patch )","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"        then","counters":[]},{"line":"          failwith","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            \"Protocol_version.of_string_exn: unexpected nondigits in input\" ;","counters":[]},{"line":"        { major = Int.of_string major","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"        ; minor = Int.of_string minor","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"        ; patch = Int.of_string patch","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"        }","counters":[]},{"line":"    | _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        failwith","counters":[]},{"line":"          \"Protocol_version.of_string_exn: expected string of form nn.nn.nn\"","counters":[]},{"line":"","counters":[]},{"line":"  let of_string_opt s = try Some (of_string_exn s) with _ -> None","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":46,"col_end":46,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"","counters":[]},{"line":"  (* when an external transition is deserialized, might contain","counters":[]},{"line":"     negative numbers","counters":[]},{"line":"  *)","counters":[]},{"line":"  let is_valid t = t.major >= 0 && t.minor >= 0 && t.patch >= 0","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"include Wire_types.Make (Make_sig) (Make_str)","counters":[]}]}