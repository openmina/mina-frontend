{"filename":"src/lib/mina_base/pending_coinbase.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Mina_base_import","counters":[]},{"line":"open Snarky_backendless","counters":[]},{"line":"open Snark_params","counters":[]},{"line":"open Snark_params.Tick","counters":[]},{"line":"open Let_syntax","counters":[]},{"line":"open Currency","counters":[]},{"line":"","counters":[]},{"line":"(* A pending coinbase is basically a Merkle tree of \"stacks\", each of which contains two hashes. The first hash","counters":[]},{"line":"   is computed from the components in the coinbase via a \"push\" operation. The second hash, a protocol","counters":[]},{"line":"   state hash, is computed from the state *body* hash in the coinbase.","counters":[]},{"line":"   The \"add_coinbase\" operation takes a coinbase, retrieves the latest stack, or creates a new one, and does","counters":[]},{"line":"   a push.","counters":[]},{"line":"","counters":[]},{"line":"   A pending coinbase also contains a stack id, used to determine the chronology of stacks, so we can know","counters":[]},{"line":"   which is the oldest, and which is the newest stack.","counters":[]},{"line":"","counters":[]},{"line":"   The name \"stack\" here is a misnomer: see issue #3226","counters":[]},{"line":"*)","counters":[]},{"line":"module Wire_types = Mina_wire_types.Mina_base.Pending_coinbase","counters":[]},{"line":"","counters":[]},{"line":"module Make_sig (A : Wire_types.Types.S) = struct","counters":[]},{"line":"  module type S =","counters":[]},{"line":"    Pending_coinbase_intf.S","counters":[]},{"line":"      with type State_stack.Stable.V1.t = A.State_stack.V1.t","counters":[]},{"line":"       and type Stack_versioned.Stable.V1.t = A.Stack_versioned.V1.t","counters":[]},{"line":"       and type Hash.t = A.Hash_builder.V1.t","counters":[]},{"line":"       and type Hash_versioned.Stable.V1.t = A.Hash_versioned.V1.t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make_str (A : Wire_types.Concrete) = struct","counters":[]},{"line":"  module Coinbase_data = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type t = Public_key.Compressed.Stable.V1.t * Amount.Stable.V1.t","counters":[{"col_start":8,"col_end":8,"count":2},{"col_start":13,"col_end":13,"count":1},{"col_start":17,"col_end":17,"count":0},{"col_start":49,"col_end":49,"count":0},{"col_start":53,"col_end":53,"count":0},{"col_start":70,"col_end":70,"count":0}]},{"line":"        [@@deriving sexp, to_yojson]","counters":[{"col_start":35,"col_end":35,"count":5}]},{"line":"","counters":[]},{"line":"        let to_latest = Fn.id","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    let of_coinbase (cb : Coinbase.t) : t = (cb.receiver, cb.amount)","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"    type var = Public_key.Compressed.var * Amount.var","counters":[]},{"line":"","counters":[]},{"line":"    let var_of_t ((public_key, amount) : t) =","counters":[]},{"line":"      (Public_key.Compressed.var_of_t public_key, Amount.var_of_t amount)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"","counters":[]},{"line":"    let to_input (pk, amount) =","counters":[]},{"line":"      let open Random_oracle.Input.Chunked in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      List.reduce_exn ~f:append","counters":[]},{"line":"        [ Public_key.Compressed.to_input pk; Amount.to_input amount ]","counters":[{"col_start":39,"col_end":39,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"","counters":[]},{"line":"    module Checked = struct","counters":[]},{"line":"      let to_input (public_key, amount) =","counters":[]},{"line":"        let open Random_oracle.Input.Chunked in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        List.reduce_exn ~f:append","counters":[]},{"line":"          [ Public_key.Compressed.Checked.to_input public_key","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"          ; Amount.var_to_input amount","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"          ]","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    let typ : (var, t) Typ.t =","counters":[]},{"line":"      let of_hlist","counters":[]},{"line":"            : 'public_key 'amount.","counters":[]},{"line":"                 (unit, 'public_key -> 'amount -> unit) H_list.t","counters":[]},{"line":"              -> 'public_key * 'amount =","counters":[]},{"line":"        let open H_list in","counters":[]},{"line":"        fun [ public_key; amount ] -> (public_key, amount)","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"      in","counters":[]},{"line":"      let to_hlist (public_key, amount) = H_list.[ public_key; amount ] in","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"      Typ.of_hlistable","counters":[{"col_start":21,"col_end":21,"count":1}]},{"line":"        [ Public_key.Compressed.typ; Amount.typ ]","counters":[]},{"line":"        ~var_to_hlist:to_hlist ~var_of_hlist:of_hlist ~value_to_hlist:to_hlist","counters":[]},{"line":"        ~value_of_hlist:of_hlist","counters":[]},{"line":"","counters":[]},{"line":"    let empty = (Public_key.Compressed.empty, Amount.zero)","counters":[]},{"line":"","counters":[]},{"line":"    let genesis = empty","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Stack_id : sig","counters":[]},{"line":"    (* using %%versioned here results in unused definitions *)","counters":[]},{"line":"    module Stable : sig","counters":[]},{"line":"      module V1 : sig","counters":[]},{"line":"        type t [@@deriving bin_io, sexp, to_yojson, compare, version]","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      module Latest = V1","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    type t = Stable.Latest.t [@@deriving sexp, compare, equal, yojson]","counters":[]},{"line":"","counters":[]},{"line":"    val of_int : int -> t","counters":[]},{"line":"","counters":[]},{"line":"    val to_int : t -> int","counters":[]},{"line":"","counters":[]},{"line":"    val zero : t","counters":[]},{"line":"","counters":[]},{"line":"    val incr_by_one : t -> t Or_error.t","counters":[]},{"line":"","counters":[]},{"line":"    val to_string : t -> string","counters":[]},{"line":"","counters":[]},{"line":"    val ( > ) : t -> t -> bool","counters":[]},{"line":"  end = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type t = int [@@deriving sexp, yojson, compare]","counters":[{"col_start":8,"col_end":8,"count":2},{"col_start":13,"col_end":13,"count":1},{"col_start":17,"col_end":17,"count":0},{"col_start":54,"col_end":54,"count":5}]},{"line":"","counters":[]},{"line":"        let to_latest = Fn.id","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    [%%define_locally Int.(( > ), to_string, zero, to_int, of_int, equal)]","counters":[]},{"line":"","counters":[]},{"line":"    let incr_by_one t1 =","counters":[]},{"line":"      let t2 = t1 + 1 in","counters":[{"col_start":6,"col_end":6,"count":64}]},{"line":"      if t2 < t1 then Or_error.error_string \"Stack_id overflow\" else Ok t2","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":69,"col_end":69,"count":64}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module type Data_hash_intf = sig","counters":[]},{"line":"    type t = private Field.t [@@deriving sexp, compare, equal, yojson, hash]","counters":[]},{"line":"","counters":[]},{"line":"    type var","counters":[]},{"line":"","counters":[]},{"line":"    val var_of_t : t -> var","counters":[]},{"line":"","counters":[]},{"line":"    val typ : (var, t) Typ.t","counters":[]},{"line":"","counters":[]},{"line":"    val var_to_hash_packed : var -> Field.Var.t","counters":[]},{"line":"","counters":[]},{"line":"    val equal_var : var -> var -> Boolean.var Tick.Checked.t","counters":[]},{"line":"","counters":[]},{"line":"    val to_bytes : t -> string","counters":[]},{"line":"","counters":[]},{"line":"    val to_bits : t -> bool list","counters":[]},{"line":"","counters":[]},{"line":"    val to_base58_check : t -> string","counters":[]},{"line":"","counters":[]},{"line":"    val of_base58_check_exn : string -> t","counters":[]},{"line":"","counters":[]},{"line":"    val gen : t Quickcheck.Generator.t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  (* a coinbase stack has two components, data and a state_hash","counters":[]},{"line":"     we create modules for each component","counters":[]},{"line":"  *)","counters":[]},{"line":"","counters":[]},{"line":"  module Coinbase_stack = struct","counters":[]},{"line":"    include Data_hash.Make_full_size (struct","counters":[]},{"line":"      let description = \"Coinbase stack data\"","counters":[]},{"line":"","counters":[]},{"line":"      let version_byte = Base58_check.Version_bytes.coinbase_stack_data","counters":[]},{"line":"    end)","counters":[]},{"line":"","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      [@@@no_toplevel_latest_type]","counters":[]},{"line":"","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        module T = struct","counters":[{"col_start":8,"col_end":8,"count":2}]},{"line":"          type t = (Field.t[@version_asserted]) [@@deriving sexp, compare, hash]","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":15,"col_end":15,"count":1}]},{"line":"        end","counters":[{"col_start":10,"col_end":10,"count":5}]},{"line":"","counters":[]},{"line":"        include T","counters":[]},{"line":"","counters":[]},{"line":"        let to_latest = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"        [%%define_from_scope to_yojson, of_yojson]","counters":[]},{"line":"","counters":[]},{"line":"        include Comparable.Make (T)","counters":[]},{"line":"        include Hashable.Make_binable (T)","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    type _unused = unit constraint t = Stable.Latest.t","counters":[]},{"line":"","counters":[]},{"line":"    let push (h : t) cb =","counters":[]},{"line":"      let coinbase = Coinbase_data.of_coinbase cb in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let open Random_oracle in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      hash ~init:Hash_prefix.coinbase_stack","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"        (pack_input","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"           (Input.Chunked.append (Coinbase_data.to_input coinbase) (to_input h)) )","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":55,"col_end":55,"count":0},{"col_start":75,"col_end":75,"count":0}]},{"line":"      |> of_hash","counters":[]},{"line":"","counters":[]},{"line":"    let empty = Random_oracle.salt \"CoinbaseStack\" |> Random_oracle.digest","counters":[{"col_start":33,"col_end":33,"count":1},{"col_start":73,"col_end":73,"count":1}]},{"line":"","counters":[]},{"line":"    module Checked = struct","counters":[]},{"line":"      type t = var","counters":[]},{"line":"","counters":[]},{"line":"      let push (h : t) (cb : Coinbase_data.var) =","counters":[]},{"line":"        let open Random_oracle.Checked in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        make_checked (fun () ->","counters":[]},{"line":"            hash ~init:Hash_prefix.coinbase_stack","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"              (pack_input","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                 (Random_oracle.Input.Chunked.append","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                    (Coinbase_data.Checked.to_input cb)","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                    (var_to_input h) ) )","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"            |> var_of_hash_packed )","counters":[]},{"line":"","counters":[]},{"line":"      let check_merge (_, t1) (s2, _) = equal_var t1 s2","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"      let if_ = if_","counters":[]},{"line":"    end","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Stack_hash = struct","counters":[]},{"line":"    include Data_hash.Make_full_size (struct","counters":[]},{"line":"      let description = \"Coinbase stack hash\"","counters":[]},{"line":"","counters":[]},{"line":"      let version_byte = Base58_check.Version_bytes.coinbase_stack_hash","counters":[]},{"line":"    end)","counters":[]},{"line":"","counters":[]},{"line":"    (* Data hash versioned boilerplate below *)","counters":[]},{"line":"","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      [@@@no_toplevel_latest_type]","counters":[]},{"line":"","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        module T = struct","counters":[{"col_start":8,"col_end":8,"count":2}]},{"line":"          type t = (Field.t[@version_asserted]) [@@deriving sexp, compare, hash]","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":15,"col_end":15,"count":1}]},{"line":"        end","counters":[{"col_start":10,"col_end":10,"count":5}]},{"line":"","counters":[]},{"line":"        include T","counters":[]},{"line":"","counters":[]},{"line":"        let to_latest = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"        [%%define_from_scope to_yojson, of_yojson]","counters":[]},{"line":"","counters":[]},{"line":"        include Comparable.Make (T)","counters":[]},{"line":"        include Hashable.Make_binable (T)","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    type _unused = unit constraint t = Stable.Latest.t","counters":[]},{"line":"","counters":[]},{"line":"    let dummy = of_hash Outside_hash_image.t","counters":[{"col_start":22,"col_end":22,"count":1}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  (*Stack of protocol state body hashes*)","counters":[]},{"line":"  module State_stack = struct","counters":[]},{"line":"    module Poly = struct","counters":[]},{"line":"      [%%versioned","counters":[]},{"line":"      module Stable = struct","counters":[]},{"line":"        module V1 = struct","counters":[]},{"line":"          type 'stack_hash t = 'stack_hash A.State_stack.Poly.V1.t =","counters":[{"col_start":10,"col_end":10,"count":1},{"col_start":27,"col_end":27,"count":4}]},{"line":"            { init : 'stack_hash; curr : 'stack_hash }","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"          [@@deriving sexp, compare, hash, yojson, equal, hlist]","counters":[{"col_start":63,"col_end":63,"count":3}]},{"line":"        end","counters":[]},{"line":"      end]","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type t = Stack_hash.Stable.V1.t Poly.Stable.V1.t","counters":[{"col_start":8,"col_end":8,"count":2},{"col_start":13,"col_end":13,"count":1},{"col_start":17,"col_end":17,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"        [@@deriving sexp, compare, hash, equal, yojson]","counters":[{"col_start":54,"col_end":54,"count":5}]},{"line":"","counters":[]},{"line":"        let to_latest = Fn.id","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    type var = Stack_hash.var Poly.t","counters":[]},{"line":"","counters":[]},{"line":"    let gen : t Quickcheck.Generator.t =","counters":[]},{"line":"      let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"      let%map init, curr =","counters":[]},{"line":"        Quickcheck.Generator.tuple2 Stack_hash.gen Stack_hash.gen","counters":[{"col_start":34,"col_end":34,"count":1}]},{"line":"      in","counters":[]},{"line":"      { Poly.init; curr }","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let to_input (t : t) =","counters":[]},{"line":"      Random_oracle.Input.Chunked.append","counters":[{"col_start":6,"col_end":6,"count":97}]},{"line":"        (Stack_hash.to_input t.init)","counters":[{"col_start":27,"col_end":27,"count":97}]},{"line":"        (Stack_hash.to_input t.curr)","counters":[{"col_start":27,"col_end":27,"count":97}]},{"line":"","counters":[]},{"line":"    let var_to_input (t : var) =","counters":[]},{"line":"      Random_oracle.Input.Chunked.append","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (Stack_hash.var_to_input t.init)","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"        (Stack_hash.var_to_input t.curr)","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"","counters":[]},{"line":"    let var_of_t (t : t) =","counters":[]},{"line":"      { Poly.init = Stack_hash.var_of_t t.init","counters":[{"col_start":6,"col_end":6,"count":1},{"col_start":38,"col_end":38,"count":1}]},{"line":"      ; curr = Stack_hash.var_of_t t.curr","counters":[{"col_start":33,"col_end":33,"count":1}]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    let typ : (var, t) Typ.t =","counters":[]},{"line":"      Snark_params.Tick.Typ.of_hlistable","counters":[{"col_start":39,"col_end":39,"count":1}]},{"line":"        [ Stack_hash.typ; Stack_hash.typ ]","counters":[]},{"line":"        ~var_to_hlist:Poly.to_hlist ~var_of_hlist:Poly.of_hlist","counters":[]},{"line":"        ~value_to_hlist:Poly.to_hlist ~value_of_hlist:Poly.of_hlist","counters":[]},{"line":"","counters":[]},{"line":"    let to_bits (t : t) = Stack_hash.to_bits t.init @ Stack_hash.to_bits t.curr","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":43,"col_end":43,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"","counters":[]},{"line":"    let to_bytes (t : t) =","counters":[]},{"line":"      Stack_hash.to_bytes t.init ^ Stack_hash.to_bytes t.curr","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"","counters":[]},{"line":"    let equal_var (v1 : var) (v2 : var) =","counters":[]},{"line":"      let open Tick.Checked.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%bind b1 = Stack_hash.equal_var v1.init v2.init in","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"      let%bind b2 = Stack_hash.equal_var v1.curr v2.curr in","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"      Boolean.(b1 && b2)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"","counters":[]},{"line":"    let if_ (cond : Tick0.Boolean.var) ~(then_ : var) ~(else_ : var) :","counters":[]},{"line":"        var Tick0.Checked.t =","counters":[]},{"line":"      let%bind init = Stack_hash.if_ cond ~then_:then_.init ~else_:else_.init in","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"      let%map curr = Stack_hash.if_ cond ~then_:then_.curr ~else_:else_.curr in","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"      { Poly.init; curr }","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let push (t : t) (state_body_hash : State_body_hash.t) : t =","counters":[]},{"line":"      (* this is the same computation for combining state hashes and state body hashes as","counters":[]},{"line":"         `Protocol_state.hash_abstract', not available here because it would create","counters":[]},{"line":"         a module dependency cycle","counters":[]},{"line":"      *)","counters":[]},{"line":"      { t with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        curr =","counters":[]},{"line":"          Random_oracle.hash ~init:Hash_prefix.protocol_state","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"            [| (t.curr :> Field.t); (state_body_hash :> Field.t) |]","counters":[]},{"line":"          |> Stack_hash.of_hash","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    let empty : t = { Poly.init = Stack_hash.dummy; curr = Stack_hash.dummy }","counters":[]},{"line":"","counters":[]},{"line":"    let create ~init = { Poly.init; curr = init }","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"    module Checked = struct","counters":[]},{"line":"      type t = var","counters":[]},{"line":"","counters":[]},{"line":"      let push (t : t) (state_body_hash : State_body_hash.var) =","counters":[]},{"line":"        make_checked (fun () ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            let curr =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Random_oracle.Checked.hash ~init:Hash_prefix.protocol_state","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"                [| Stack_hash.var_to_hash_packed t.curr","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"                 ; State_body_hash.var_to_hash_packed state_body_hash","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"                |]","counters":[]},{"line":"              |> Stack_hash.var_of_hash_packed","counters":[]},{"line":"            in","counters":[]},{"line":"            { t with curr } )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"","counters":[]},{"line":"      let check_merge (s1, t1) (s2, t2) =","counters":[]},{"line":"        (*state stacks are updated for every transaction in transaction snark but","counters":[]},{"line":"          only once for every blockchain snark. Therefore, source stacks (and","counters":[]},{"line":"          target stacks) will be equal for transactions in the same block*)","counters":[]},{"line":"        let%bind eq_src = equal_var s1 s2","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"        and eq_target = equal_var t1 t2","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"        and correct_transition = equal_var t1 s2 in","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"        let%bind same_update = Boolean.(eq_src &&& eq_target) in","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"        Boolean.any [ same_update; correct_transition ]","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    end","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  (* Pending coinbase hash *)","counters":[]},{"line":"  module Hash_builder = struct","counters":[]},{"line":"    include Data_hash.Make_full_size (struct","counters":[]},{"line":"      let description = \"Pending coinbase hash builder\"","counters":[]},{"line":"","counters":[]},{"line":"      let version_byte = Base58_check.Version_bytes.receipt_chain_hash","counters":[]},{"line":"    end)","counters":[]},{"line":"","counters":[]},{"line":"    (* Data hash versioned boilerplate below *)","counters":[]},{"line":"","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      [@@@no_toplevel_latest_type]","counters":[]},{"line":"","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        module T = struct","counters":[{"col_start":8,"col_end":8,"count":2}]},{"line":"          type t = (Field.t[@version_asserted]) [@@deriving sexp, compare, hash]","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":15,"col_end":15,"count":1}]},{"line":"        end","counters":[{"col_start":10,"col_end":10,"count":5}]},{"line":"","counters":[]},{"line":"        include T","counters":[]},{"line":"","counters":[]},{"line":"        let to_latest = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"        [%%define_from_scope to_yojson, of_yojson]","counters":[]},{"line":"","counters":[]},{"line":"        include Comparable.Make (T)","counters":[]},{"line":"        include Hashable.Make_binable (T)","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    type _unused = unit constraint t = Stable.Latest.t","counters":[]},{"line":"","counters":[]},{"line":"    let merge ~height (h1 : t) (h2 : t) =","counters":[]},{"line":"      Random_oracle.hash","counters":[{"col_start":6,"col_end":6,"count":64},{"col_start":23,"col_end":23,"count":64}]},{"line":"        ~init:(Hash_prefix.coinbase_merkle_tree height)","counters":[{"col_start":46,"col_end":46,"count":64}]},{"line":"        [| (h1 :> field); (h2 :> field) |]","counters":[]},{"line":"      |> of_hash","counters":[]},{"line":"","counters":[]},{"line":"    let empty_hash =","counters":[]},{"line":"      Random_oracle.(digest (salt \"PendingCoinbaseMerkleTree\")) |> of_hash","counters":[{"col_start":26,"col_end":26,"count":1},{"col_start":32,"col_end":32,"count":1},{"col_start":73,"col_end":73,"count":1}]},{"line":"","counters":[]},{"line":"    let of_digest = Fn.compose Fn.id of_hash","counters":[{"col_start":29,"col_end":29,"count":1}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Update = struct","counters":[]},{"line":"    module Action = struct","counters":[]},{"line":"      [%%versioned","counters":[]},{"line":"      module Stable = struct","counters":[]},{"line":"        module V1 = struct","counters":[]},{"line":"          type t =","counters":[{"col_start":10,"col_end":10,"count":2},{"col_start":15,"col_end":15,"count":2}]},{"line":"            | Update_none","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            | Update_one","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            | Update_two_coinbase_in_first","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            | Update_two_coinbase_in_second","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          [@@deriving equal, sexp, to_yojson]","counters":[{"col_start":44,"col_end":44,"count":5}]},{"line":"","counters":[]},{"line":"          let to_latest = Fn.id","counters":[]},{"line":"        end","counters":[]},{"line":"      end]","counters":[]},{"line":"","counters":[]},{"line":"      type var = Boolean.var * Boolean.var","counters":[]},{"line":"","counters":[]},{"line":"      let to_bits = function","counters":[]},{"line":"        | Update_none ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (false, false)","counters":[]},{"line":"        | Update_one ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (true, false)","counters":[]},{"line":"        | Update_two_coinbase_in_first ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (false, true)","counters":[]},{"line":"        | Update_two_coinbase_in_second ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (true, true)","counters":[]},{"line":"","counters":[]},{"line":"      let of_bits = function","counters":[]},{"line":"        | false, false ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Update_none","counters":[]},{"line":"        | true, false ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Update_one","counters":[]},{"line":"        | false, true ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Update_two_coinbase_in_first","counters":[]},{"line":"        | true, true ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Update_two_coinbase_in_second","counters":[]},{"line":"","counters":[]},{"line":"      let var_of_t t =","counters":[]},{"line":"        let x, y = to_bits t in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Boolean.(var_of_value x, var_of_value y)","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"      let typ =","counters":[]},{"line":"        Typ.transport","counters":[{"col_start":20,"col_end":20,"count":1}]},{"line":"          Typ.(Boolean.typ * Boolean.typ)","counters":[]},{"line":"          ~there:to_bits ~back:of_bits","counters":[]},{"line":"","counters":[]},{"line":"      module Checked = struct","counters":[]},{"line":"        let no_update (b0, b1) = Boolean.((not b0) &&& not b1)","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"","counters":[]},{"line":"        let update_two_stacks_coinbase_in_first (b0, b1) =","counters":[]},{"line":"          Boolean.((not b0) &&& b1)","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"        let update_two_stacks_coinbase_in_second (b0, b1) = Boolean.(b0 &&& b1)","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"      end","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Poly = struct","counters":[]},{"line":"      [%%versioned","counters":[]},{"line":"      module Stable = struct","counters":[]},{"line":"        module V1 = struct","counters":[]},{"line":"          type ('action, 'coinbase_amount) t =","counters":[{"col_start":10,"col_end":10,"count":1},{"col_start":43,"col_end":43,"count":5}]},{"line":"            { action : 'action; coinbase_amount : 'coinbase_amount }","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":46,"col_end":46,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"          [@@deriving sexp, to_yojson, hlist]","counters":[{"col_start":44,"col_end":44,"count":3}]},{"line":"        end","counters":[]},{"line":"      end]","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type t = (Action.Stable.V1.t, Amount.Stable.V1.t) Poly.Stable.V1.t","counters":[{"col_start":8,"col_end":8,"count":2},{"col_start":13,"col_end":13,"count":1},{"col_start":17,"col_end":17,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"        [@@deriving sexp, to_yojson]","counters":[{"col_start":35,"col_end":35,"count":5}]},{"line":"","counters":[]},{"line":"        let to_latest = Fn.id","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    [%%define_locally Poly.(to_hlist, of_hlist)]","counters":[]},{"line":"","counters":[]},{"line":"    type var = (Action.var, Amount.var) Poly.t","counters":[]},{"line":"","counters":[]},{"line":"    let typ =","counters":[]},{"line":"      let open Snark_params.Tick.Typ in","counters":[]},{"line":"      of_hlistable ~var_to_hlist:to_hlist ~var_of_hlist:of_hlist","counters":[{"col_start":17,"col_end":17,"count":1}]},{"line":"        ~value_to_hlist:to_hlist ~value_of_hlist:of_hlist","counters":[]},{"line":"        [ Action.typ; Amount.typ ]","counters":[]},{"line":"","counters":[]},{"line":"    let genesis : t =","counters":[]},{"line":"      { coinbase_amount = Currency.Amount.zero; action = Action.Update_none }","counters":[]},{"line":"","counters":[]},{"line":"    let var_of_t (t : t) : var =","counters":[]},{"line":"      { action = Action.var_of_t t.action","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"      ; coinbase_amount = Amount.var_of_t t.coinbase_amount","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"      }","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  (* Sparse_ledger.Make is applied more than once in the code, so","counters":[]},{"line":"     it can't make assumptions about the internal structure of its module","counters":[]},{"line":"     arguments. Therefore, for modules with a bin_io type passed to the functor,","counters":[]},{"line":"     that type cannot be in a version module hierarchy. We build the required","counters":[]},{"line":"     modules for Hash and Stack.","counters":[]},{"line":"  *)","counters":[]},{"line":"","counters":[]},{"line":"  module Stack_versioned = struct","counters":[]},{"line":"    module Poly = struct","counters":[]},{"line":"      [%%versioned","counters":[]},{"line":"      module Stable = struct","counters":[]},{"line":"        module V1 = struct","counters":[]},{"line":"          type ('data_stack, 'state_stack) t =","counters":[{"col_start":10,"col_end":10,"count":1},{"col_start":43,"col_end":43,"count":5}]},{"line":"                ('data_stack, 'state_stack) A.Stack_versioned.Poly.V1.t =","counters":[]},{"line":"            { data : 'data_stack; state : 'state_stack }","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"          [@@deriving yojson, hash, sexp, equal, compare]","counters":[{"col_start":56,"col_end":56,"count":3}]},{"line":"        end","counters":[]},{"line":"      end]","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type t =","counters":[{"col_start":8,"col_end":8,"count":2},{"col_start":13,"col_end":13,"count":1}]},{"line":"          (Coinbase_stack.Stable.V1.t, State_stack.Stable.V1.t) Poly.Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":11,"col_end":11,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"        [@@deriving equal, yojson, hash, sexp, compare]","counters":[{"col_start":54,"col_end":54,"count":5}]},{"line":"","counters":[]},{"line":"        let to_latest = Fn.id","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Hash_versioned = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type t = Hash_builder.Stable.V1.t","counters":[{"col_start":8,"col_end":8,"count":2},{"col_start":13,"col_end":13,"count":1},{"col_start":17,"col_end":17,"count":0}]},{"line":"        [@@deriving equal, compare, sexp, yojson, hash]","counters":[{"col_start":54,"col_end":54,"count":5}]},{"line":"","counters":[]},{"line":"        let to_latest = Fn.id","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Merkle_tree_versioned = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V2 = struct","counters":[]},{"line":"        type t =","counters":[{"col_start":8,"col_end":8,"count":2},{"col_start":13,"col_end":13,"count":1}]},{"line":"          ( Hash_versioned.Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":12,"col_end":12,"count":0}]},{"line":"          , Stack_id.Stable.V1.t","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          , Stack_versioned.Stable.V1.t )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          Sparse_ledger_lib.Sparse_ledger.T.Stable.V2.t","counters":[]},{"line":"        [@@deriving sexp, to_yojson]","counters":[{"col_start":35,"col_end":35,"count":5}]},{"line":"","counters":[]},{"line":"        let to_latest = Fn.id","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    type _unused = unit","counters":[]},{"line":"      constraint","counters":[]},{"line":"        t =","counters":[]},{"line":"        ( Hash_versioned.t","counters":[]},{"line":"        , Stack_id.t","counters":[]},{"line":"        , Stack_versioned.t )","counters":[]},{"line":"        Sparse_ledger_lib.Sparse_ledger.T.t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module T = struct","counters":[]},{"line":"    (* Total number of stacks *)","counters":[]},{"line":"    let max_coinbase_stack_count ~depth = Int.pow 2 depth","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"","counters":[]},{"line":"    let chain if_ b ~then_ ~else_ =","counters":[]},{"line":"      let%bind then_ = then_ and else_ = else_ in","counters":[]},{"line":"      if_ b ~then_ ~else_","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    (*pair of coinbase and state stacks*)","counters":[]},{"line":"    module Stack = struct","counters":[]},{"line":"      module Poly = struct","counters":[]},{"line":"        type ('data_stack, 'state_stack) t =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"              ('data_stack, 'state_stack) Stack_versioned.Poly.t =","counters":[]},{"line":"          { data : 'data_stack; state : 'state_stack }","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"        [@@deriving yojson, hash, sexp, compare, hlist]","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      type t = Stack_versioned.t [@@deriving yojson, equal, compare, sexp, hash]","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"","counters":[]},{"line":"      type _unused = unit","counters":[]},{"line":"        constraint t = (Coinbase_stack.t, State_stack.t) Poly.t","counters":[]},{"line":"","counters":[]},{"line":"      type var = (Coinbase_stack.var, State_stack.var) Poly.t","counters":[]},{"line":"","counters":[]},{"line":"      let to_input ({ data; state } : t) =","counters":[]},{"line":"        Random_oracle.Input.Chunked.append","counters":[{"col_start":8,"col_end":8,"count":97}]},{"line":"          (Coinbase_stack.to_input data)","counters":[{"col_start":33,"col_end":33,"count":97}]},{"line":"          (State_stack.to_input state)","counters":[{"col_start":30,"col_end":30,"count":97}]},{"line":"","counters":[]},{"line":"      let data_hash t =","counters":[]},{"line":"        Random_oracle.(","counters":[{"col_start":8,"col_end":8,"count":97}]},{"line":"          hash ~init:Hash_prefix_states.coinbase_stack (pack_input (to_input t)))","counters":[{"col_start":13,"col_end":13,"count":97},{"col_start":65,"col_end":65,"count":97},{"col_start":75,"col_end":75,"count":97}]},{"line":"        |> Hash_builder.of_digest","counters":[]},{"line":"","counters":[]},{"line":"      let var_to_input ({ data; state } : var) =","counters":[]},{"line":"        Random_oracle.Input.Chunked.append","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (Coinbase_stack.var_to_input data)","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"          (State_stack.var_to_input state)","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"","counters":[]},{"line":"      let hash_var (t : var) =","counters":[]},{"line":"        make_checked (fun () ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            Random_oracle.Checked.(","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              hash ~init:Hash_prefix_states.coinbase_stack","counters":[]},{"line":"                (pack_input (var_to_input t))) )","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"      let var_of_t t =","counters":[]},{"line":"        { Poly.data = Coinbase_stack.var_of_t t.Poly.data","counters":[{"col_start":8,"col_end":8,"count":1},{"col_start":44,"col_end":44,"count":1}]},{"line":"        ; state = State_stack.var_of_t t.state","counters":[{"col_start":37,"col_end":37,"count":1}]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"      let gen =","counters":[]},{"line":"        let open Base_quickcheck.Generator.Let_syntax in","counters":[]},{"line":"        let%bind data = Coinbase_stack.gen in","counters":[]},{"line":"        let%map state = State_stack.gen in","counters":[]},{"line":"        { Poly.data; state }","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      let typ : (var, t) Typ.t =","counters":[]},{"line":"        Snark_params.Tick.Typ.of_hlistable","counters":[{"col_start":41,"col_end":41,"count":1}]},{"line":"          [ Coinbase_stack.typ; State_stack.typ ]","counters":[]},{"line":"          ~var_to_hlist:Poly.to_hlist ~var_of_hlist:Poly.of_hlist","counters":[]},{"line":"          ~value_to_hlist:Poly.to_hlist ~value_of_hlist:Poly.of_hlist","counters":[]},{"line":"","counters":[]},{"line":"      let num_pad_bits =","counters":[]},{"line":"        let len = List.length Coinbase_stack.(to_bits empty) in","counters":[{"col_start":52,"col_end":52,"count":1}]},{"line":"        (3 - (len mod 3)) mod 3","counters":[{"col_start":8,"col_end":8,"count":1}]},{"line":"","counters":[]},{"line":"      (* pad to match the triple representation *)","counters":[]},{"line":"      let pad_bits = List.init num_pad_bits ~f:(fun _ -> false)","counters":[{"col_start":29,"col_end":29,"count":1},{"col_start":57,"col_end":57,"count":0}]},{"line":"","counters":[]},{"line":"      let to_bits t =","counters":[]},{"line":"        Coinbase_stack.to_bits t.Poly.data","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"        @ pad_bits","counters":[]},{"line":"        @ State_stack.to_bits t.Poly.state","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"","counters":[]},{"line":"      let to_bytes t =","counters":[]},{"line":"        Coinbase_stack.to_bytes t.Poly.data ^ State_stack.to_bytes t.Poly.state","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"","counters":[]},{"line":"      let equal_var var1 var2 =","counters":[]},{"line":"        let open Tick.Checked.Let_syntax in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let%bind b1 = Coinbase_stack.equal_var var1.Poly.data var2.Poly.data in","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"        let%bind b2 = State_stack.equal_var var1.Poly.state var2.Poly.state in","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"        let open Tick0.Boolean in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        b1 &&& b2","counters":[]},{"line":"","counters":[]},{"line":"      let empty =","counters":[]},{"line":"        { Poly.data = Coinbase_stack.empty; state = State_stack.empty }","counters":[]},{"line":"","counters":[]},{"line":"      let create_with (t : t) =","counters":[]},{"line":"        { empty with state = State_stack.create ~init:t.state.curr }","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      let equal_state_hash t1 t2 = State_stack.equal t1.Poly.state t2.Poly.state","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"      let equal_data t1 t2 = Coinbase_stack.equal t1.Poly.data t2.Poly.data","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"      let connected ?(prev : t option = None) ~first ~second () =","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"        let coinbase_stack_connected =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (*same as old stack or second could be a new stack with empty data*)","counters":[]},{"line":"          equal_data first second","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"          || Coinbase_stack.(equal empty second.Poly.data)","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"        in","counters":[]},{"line":"        let state_stack_connected =","counters":[]},{"line":"          (*1. same as old stack or","counters":[]},{"line":"            2. new stack initialized with the stack state of last block. Not possible to know this unless we track all the stack states because they are updated once per block (init=curr)","counters":[]},{"line":"            3. [second] could be a new stack initialized with the latest state of [first] or","counters":[]},{"line":"            4. [second] starts from the previous state of [first]. This is not available in either [first] or [second] *)","counters":[]},{"line":"          equal_state_hash first second","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"          || Stack_hash.equal second.state.init second.state.curr","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"          || Stack_hash.equal first.state.curr second.state.curr","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"          || Option.value_map prev ~default:true ~f:(fun prev ->","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                 Stack_hash.equal prev.state.curr second.state.curr )","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"        in","counters":[]},{"line":"        coinbase_stack_connected && state_stack_connected","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"","counters":[]},{"line":"      let push_coinbase (cb : Coinbase.t) t =","counters":[]},{"line":"        let data = Coinbase_stack.push t.Poly.data cb in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        { t with data }","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      let push_state (state_body_hash : State_body_hash.t) (t : t) =","counters":[]},{"line":"        { t with state = State_stack.push t.state state_body_hash }","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"      let if_ (cond : Tick0.Boolean.var) ~(then_ : var) ~(else_ : var) :","counters":[]},{"line":"          var Tick0.Checked.t =","counters":[]},{"line":"        let%bind data =","counters":[]},{"line":"          Coinbase_stack.Checked.if_ cond ~then_:then_.data ~else_:else_.data","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"        in","counters":[]},{"line":"        let%map state =","counters":[]},{"line":"          State_stack.if_ cond ~then_:then_.state ~else_:else_.state","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"        in","counters":[]},{"line":"        { Poly.data; state }","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      module Checked = struct","counters":[]},{"line":"        type t = var","counters":[]},{"line":"","counters":[]},{"line":"        let push_coinbase (coinbase : Coinbase_data.var) (t : t) :","counters":[]},{"line":"            t Tick0.Checked.t =","counters":[]},{"line":"          let%map data = Coinbase_stack.Checked.push t.data coinbase in","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"          { t with data }","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"        let push_state (state_body_hash : State_body_hash.var) (t : t) =","counters":[]},{"line":"          let%map state = State_stack.Checked.push t.state state_body_hash in","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"          { t with state }","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"        let check_merge ~transition1:((s, t) : t * t)","counters":[]},{"line":"            ~transition2:((s', t') : t * t) : Boolean.var Tick0.Checked.t =","counters":[]},{"line":"          let%bind valid_coinbase_stacks =","counters":[]},{"line":"            Coinbase_stack.Checked.check_merge (s.data, t.data)","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"              (s'.data, t'.data)","counters":[]},{"line":"          in","counters":[]},{"line":"          let%bind valid_state_stacks =","counters":[]},{"line":"            State_stack.Checked.check_merge (s.state, t.state)","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"              (s'.state, t'.state)","counters":[]},{"line":"          in","counters":[]},{"line":"          Boolean.(valid_coinbase_stacks && valid_state_stacks)","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"        let empty = var_of_t empty","counters":[{"col_start":27,"col_end":27,"count":1}]},{"line":"","counters":[]},{"line":"        let create_with (t : var) =","counters":[]},{"line":"          { empty with state = State_stack.create ~init:t.state.init }","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"        let if_ = if_","counters":[]},{"line":"      end","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Hash = struct","counters":[]},{"line":"      type t = Hash_builder.t [@@deriving equal, compare, sexp, yojson, hash]","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"","counters":[]},{"line":"      type _unused = unit constraint t = Hash_versioned.t","counters":[]},{"line":"","counters":[]},{"line":"      type var = Hash_builder.var","counters":[]},{"line":"","counters":[]},{"line":"      [%%define_locally","counters":[]},{"line":"      Hash_builder.","counters":[]},{"line":"        ( of_digest","counters":[]},{"line":"        , merge","counters":[]},{"line":"        , empty_hash","counters":[]},{"line":"        , gen","counters":[]},{"line":"        , to_bits","counters":[]},{"line":"        , to_bytes","counters":[]},{"line":"        , equal_var","counters":[]},{"line":"        , var_of_t","counters":[]},{"line":"        , var_of_hash_packed","counters":[]},{"line":"        , var_to_hash_packed","counters":[]},{"line":"        , to_base58_check","counters":[]},{"line":"        , of_base58_check_exn","counters":[]},{"line":"        , typ )]","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Merkle_tree = struct","counters":[]},{"line":"      type t = Merkle_tree_versioned.t [@@deriving sexp, to_yojson]","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"","counters":[]},{"line":"      type _unused = unit","counters":[]},{"line":"        constraint","counters":[]},{"line":"          t =","counters":[]},{"line":"          (Hash.t, Stack_id.t, Stack.t) Sparse_ledger_lib.Sparse_ledger.T.t","counters":[]},{"line":"","counters":[]},{"line":"      module M = Sparse_ledger_lib.Sparse_ledger.Make (Hash) (Stack_id) (Stack)","counters":[]},{"line":"","counters":[]},{"line":"      [%%define_locally","counters":[]},{"line":"      M.","counters":[]},{"line":"        ( of_hash","counters":[]},{"line":"        , get_exn","counters":[]},{"line":"        , path_exn","counters":[]},{"line":"        , set_exn","counters":[]},{"line":"        , find_index_exn","counters":[]},{"line":"        , add_path","counters":[]},{"line":"        , merkle_root )]","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Checked = struct","counters":[]},{"line":"      type var = Hash.var","counters":[]},{"line":"","counters":[]},{"line":"      module Merkle_tree =","counters":[]},{"line":"        Snarky_backendless.Merkle_tree.Checked","counters":[]},{"line":"          (Tick)","counters":[]},{"line":"          (struct","counters":[]},{"line":"            type value = Field.t","counters":[]},{"line":"","counters":[]},{"line":"            type var = Field.Var.t","counters":[]},{"line":"","counters":[]},{"line":"            let typ = Field.typ","counters":[]},{"line":"","counters":[]},{"line":"            let merge ~height h1 h2 =","counters":[]},{"line":"              Tick.make_checked (fun () ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                  Random_oracle.Checked.hash","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    ~init:(Hash_prefix.coinbase_merkle_tree height)","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"                    [| h1; h2 |] )","counters":[]},{"line":"","counters":[]},{"line":"            let assert_equal h1 h2 = Field.Checked.Assert.equal h1 h2","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"            let if_ = Field.Checked.if_","counters":[]},{"line":"          end)","counters":[]},{"line":"          (struct","counters":[]},{"line":"            include Stack","counters":[]},{"line":"","counters":[]},{"line":"            type value = t [@@deriving sexp]","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"","counters":[]},{"line":"            let hash var = hash_var var","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"          end)","counters":[]},{"line":"","counters":[]},{"line":"      module Path = Merkle_tree.Path","counters":[]},{"line":"","counters":[]},{"line":"      type path = Path.value","counters":[]},{"line":"","counters":[]},{"line":"      module Address = struct","counters":[]},{"line":"        include Merkle_tree.Address","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      type _ Request.t +=","counters":[]},{"line":"        | Coinbase_stack_path : Address.value -> path Request.t","counters":[]},{"line":"        | Get_coinbase_stack : Address.value -> (Stack.t * path) Request.t","counters":[]},{"line":"        | Set_coinbase_stack : Address.value * Stack.t -> unit Request.t","counters":[]},{"line":"        | Set_oldest_coinbase_stack : Address.value * Stack.t -> unit Request.t","counters":[]},{"line":"        | Find_index_of_newest_stacks :","counters":[]},{"line":"            Update.Action.t","counters":[]},{"line":"            -> (Address.value * Address.value) Request.t","counters":[]},{"line":"        | Find_index_of_oldest_stack : Address.value Request.t","counters":[]},{"line":"        | Get_previous_stack : State_stack.t Request.t","counters":[]},{"line":"","counters":[]},{"line":"      let reraise_merkle_requests (With { request; respond }) =","counters":[]},{"line":"        match request with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | Merkle_tree.Get_path addr ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            respond (Delegate (Coinbase_stack_path addr))","counters":[]},{"line":"        | Merkle_tree.Set (addr, stack) ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            respond (Delegate (Set_coinbase_stack (addr, stack)))","counters":[]},{"line":"        | Merkle_tree.Get_element addr ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            respond (Delegate (Get_coinbase_stack addr))","counters":[]},{"line":"        | _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            unhandled","counters":[]},{"line":"","counters":[]},{"line":"      let get ~depth t addr =","counters":[]},{"line":"        handle","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (fun () -> Merkle_tree.get_req ~depth (Hash.var_to_hash_packed t) addr)","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"          reraise_merkle_requests","counters":[]},{"line":"","counters":[]},{"line":"      let%snarkydef_ add_coinbase","counters":[]},{"line":"          ~(constraint_constants : Genesis_constants.Constraint_constants.t) t","counters":[]},{"line":"          ({ action; coinbase_amount = amount } : Update.var) ~coinbase_receiver","counters":[]},{"line":"          ~supercharge_coinbase state_body_hash =","counters":[]},{"line":"        let depth = constraint_constants.pending_coinbase_depth in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let%bind addr1, addr2 =","counters":[]},{"line":"          request_witness","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"            Typ.(Address.typ ~depth * Address.typ ~depth)","counters":[]},{"line":"            As_prover.(","counters":[]},{"line":"              map (read Update.Action.typ action) ~f:(fun act ->","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"                  Find_index_of_newest_stacks act ))","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"        in","counters":[]},{"line":"        let equal_to_zero x = Amount.(equal_var x (var_of_t zero)) in","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"        let%bind no_update = Update.Action.Checked.no_update action in","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"        let update_state_stack (stack : Stack.var) =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (*get previous stack to carry-forward the stack of state body hashes*)","counters":[]},{"line":"          let%bind previous_state_stack =","counters":[]},{"line":"            request_witness State_stack.typ","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"              As_prover.(map (return ()) ~f:(fun () -> Get_previous_stack))","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"          in","counters":[]},{"line":"          let stack_initialized = { stack with state = previous_state_stack } in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let%bind stack_with_state_hash =","counters":[]},{"line":"            Stack.Checked.push_state state_body_hash stack_initialized","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"          in","counters":[]},{"line":"          (*Always update the state body hash unless there are no transactions in this block*)","counters":[]},{"line":"          Stack.Checked.if_ no_update ~then_:stack ~else_:stack_with_state_hash","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        in","counters":[]},{"line":"        let update_stack1 stack =","counters":[]},{"line":"          let%bind stack = update_state_stack stack in","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"          let%bind total_coinbase_amount =","counters":[]},{"line":"            let coinbase_amount =","counters":[]},{"line":"              Currency.Amount.var_of_t constraint_constants.coinbase_amount","counters":[]},{"line":"            in","counters":[]},{"line":"            let supercharged_coinbase =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let amt =","counters":[]},{"line":"                Option.value_exn","counters":[]},{"line":"                  (Currency.Amount.scale constraint_constants.coinbase_amount","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"                     constraint_constants.supercharged_coinbase_factor )","counters":[]},{"line":"              in","counters":[]},{"line":"              Currency.Amount.var_of_t amt","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"            in","counters":[]},{"line":"            Currency.Amount.Checked.if_ supercharge_coinbase","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"              ~then_:supercharged_coinbase ~else_:coinbase_amount","counters":[]},{"line":"          in","counters":[]},{"line":"          let%bind rem_amount =","counters":[]},{"line":"            Currency.Amount.Checked.sub total_coinbase_amount amount","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%bind no_coinbase_in_this_stack =","counters":[]},{"line":"            Update.Action.Checked.update_two_stacks_coinbase_in_second action","counters":[{"col_start":69,"col_end":69,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%bind amount1_equal_to_zero = equal_to_zero amount in","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"          let%bind amount2_equal_to_zero = equal_to_zero rem_amount in","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"          (*if no update then coinbase amount has to be zero*)","counters":[]},{"line":"          let%bind () =","counters":[]},{"line":"            with_label __LOC__ (fun () ->","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                let%bind check =","counters":[]},{"line":"                  Boolean.equal no_update amount1_equal_to_zero","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                in","counters":[]},{"line":"                Boolean.Assert.is_true check )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%bind no_coinbase =","counters":[]},{"line":"            Boolean.(no_update ||| no_coinbase_in_this_stack)","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"          in","counters":[]},{"line":"          (* TODO: Optimize here since we are pushing twice to the same stack *)","counters":[]},{"line":"          let%bind stack_with_amount1 =","counters":[]},{"line":"            Stack.Checked.push_coinbase (coinbase_receiver, amount) stack","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%bind stack_with_amount2 =","counters":[]},{"line":"            Stack.Checked.push_coinbase","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"              (coinbase_receiver, rem_amount)","counters":[]},{"line":"              stack_with_amount1","counters":[]},{"line":"          in","counters":[]},{"line":"          chain Stack.if_ no_coinbase ~then_:(return stack)","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"            ~else_:","counters":[]},{"line":"              (Stack.if_ amount2_equal_to_zero ~then_:stack_with_amount1","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                 ~else_:stack_with_amount2 )","counters":[]},{"line":"        in","counters":[]},{"line":"        (*This is for the second stack for when transactions in a block occupy","counters":[]},{"line":"          two trees of the scan state; the second tree will carry-forward the state","counters":[]},{"line":"          stack from the previous block, push the new state, and may or may not have a coinbase*)","counters":[]},{"line":"        let update_stack2 (init_stack : Stack.var) (stack0 : Stack.var) =","counters":[]},{"line":"          let%bind add_coinbase =","counters":[]},{"line":"            Update.Action.Checked.update_two_stacks_coinbase_in_second action","counters":[{"col_start":69,"col_end":69,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%bind update_state =","counters":[]},{"line":"            let%bind update_second_stack =","counters":[]},{"line":"              Update.Action.Checked.update_two_stacks_coinbase_in_first action","counters":[{"col_start":70,"col_end":70,"count":0}]},{"line":"            in","counters":[]},{"line":"            Boolean.(update_second_stack ||| add_coinbase)","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%bind stack =","counters":[]},{"line":"            let%bind stack_with_state =","counters":[]},{"line":"              Stack.Checked.push_state state_body_hash","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                { stack0 with","counters":[]},{"line":"                  state =","counters":[]},{"line":"                    State_stack.create ~init:init_stack.Stack.Poly.state.curr","counters":[]},{"line":"                }","counters":[]},{"line":"            in","counters":[]},{"line":"            Stack.if_ update_state ~then_:stack_with_state ~else_:stack0","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%bind stack_with_coinbase =","counters":[]},{"line":"            Stack.Checked.push_coinbase (coinbase_receiver, amount) stack","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"          in","counters":[]},{"line":"          Stack.if_ add_coinbase ~then_:stack_with_coinbase ~else_:stack","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        in","counters":[]},{"line":"        (*update the first stack*)","counters":[]},{"line":"        let%bind root', `Old prev, `New _updated_stack1 =","counters":[]},{"line":"          handle","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"            (fun () ->","counters":[]},{"line":"              Merkle_tree.fetch_and_update_req ~depth","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (Hash.var_to_hash_packed t)","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"                addr1 ~f:update_stack1 )","counters":[]},{"line":"            reraise_merkle_requests","counters":[]},{"line":"        in","counters":[]},{"line":"        (*update the second stack*)","counters":[]},{"line":"        let%map root, _, _ =","counters":[]},{"line":"          handle","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"            (fun () ->","counters":[]},{"line":"              Merkle_tree.fetch_and_update_req ~depth root' addr2","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ~f:(update_stack2 prev) )","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"            reraise_merkle_requests","counters":[]},{"line":"        in","counters":[]},{"line":"        Hash.var_of_hash_packed root","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      let%snarkydef_ pop_coinbases","counters":[]},{"line":"          ~(constraint_constants : Genesis_constants.Constraint_constants.t) t","counters":[]},{"line":"          ~proof_emitted =","counters":[]},{"line":"        let depth = constraint_constants.pending_coinbase_depth in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let%bind addr =","counters":[]},{"line":"          request_witness (Address.typ ~depth)","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"            As_prover.(map (return ()) ~f:(fun _ -> Find_index_of_oldest_stack))","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"        in","counters":[]},{"line":"        let%bind prev, prev_path =","counters":[]},{"line":"          request_witness","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"            Typ.(Stack.typ * Path.typ ~depth)","counters":[]},{"line":"            As_prover.(","counters":[]},{"line":"              map","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                (read (Address.typ ~depth) addr)","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                ~f:(fun a -> Get_coinbase_stack a))","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"        in","counters":[]},{"line":"        let stack_hash = Stack.hash_var in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let%bind prev_entry_hash = stack_hash prev in","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"        let%bind () =","counters":[]},{"line":"          Merkle_tree.implied_root prev_entry_hash addr prev_path","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"          >>= Field.Checked.Assert.equal (Hash.var_to_hash_packed t)","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"        in","counters":[]},{"line":"        let%bind next =","counters":[]},{"line":"          Stack.if_ proof_emitted ~then_:Stack.Checked.empty ~else_:prev","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"        in","counters":[]},{"line":"        let%bind next_entry_hash = stack_hash next in","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"        let%bind () =","counters":[]},{"line":"          perform","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"            (let open As_prover in","counters":[]},{"line":"            let open Let_syntax in","counters":[]},{"line":"            let%map addr = read (Address.typ ~depth) addr","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"            and next = read Stack.typ next in","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"            Set_oldest_coinbase_stack (addr, next))","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"        in","counters":[]},{"line":"        let%map new_root =","counters":[]},{"line":"          Merkle_tree.implied_root next_entry_hash addr prev_path","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"        in","counters":[]},{"line":"        (Hash.var_of_hash_packed new_root, prev)","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Poly = struct","counters":[]},{"line":"      type ('tree, 'stack_id) t = ('tree, 'stack_id) A.Poly.t =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { tree : 'tree; pos_list : 'stack_id list; new_pos : 'stack_id }","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":48,"col_end":48,"count":0},{"col_start":51,"col_end":51,"count":0},{"col_start":57,"col_end":57,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"      [@@deriving sexp, to_yojson]","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    type t = (Merkle_tree.t, Stack_id.t) Poly.t [@@deriving sexp, to_yojson]","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":14,"col_end":14,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":75,"col_end":75,"count":0}]},{"line":"","counters":[]},{"line":"    let init_hash = Stack.data_hash Stack.empty","counters":[{"col_start":34,"col_end":34,"count":1}]},{"line":"","counters":[]},{"line":"    let hash_at_level =","counters":[]},{"line":"      let cached = ref [| init_hash |] in","counters":[]},{"line":"      fun i ->","counters":[]},{"line":"        let len = Array.length !cached in","counters":[{"col_start":8,"col_end":8,"count":260}]},{"line":"        ( if i >= len then","counters":[{"col_start":8,"col_end":8,"count":260}]},{"line":"          let cur_hash = ref (Array.last !cached) in","counters":[{"col_start":10,"col_end":10,"count":1},{"col_start":39,"col_end":39,"count":1}]},{"line":"          cached :=","counters":[]},{"line":"            Array.append !cached","counters":[{"col_start":23,"col_end":23,"count":1}]},{"line":"              (Array.init","counters":[{"col_start":24,"col_end":24,"count":1}]},{"line":"                 (i + 1 - len)","counters":[]},{"line":"                 ~f:(fun i ->","counters":[]},{"line":"                   cur_hash :=","counters":[{"col_start":19,"col_end":19,"count":4}]},{"line":"                     Hash.merge ~height:(i + len - 1) !cur_hash !cur_hash ;","counters":[{"col_start":30,"col_end":30,"count":4}]},{"line":"                   !cur_hash ) ) ) ;","counters":[]},{"line":"        !cached.(i)","counters":[{"col_start":8,"col_end":8,"count":260}]},{"line":"","counters":[]},{"line":"    let create_exn' ~depth () =","counters":[]},{"line":"      let rec create_path height path key =","counters":[{"col_start":6,"col_end":6,"count":4}]},{"line":"        if height < 0 then path","counters":[{"col_start":8,"col_end":8,"count":320},{"col_start":27,"col_end":27,"count":64}]},{"line":"        else","counters":[]},{"line":"          let hash = hash_at_level height in","counters":[{"col_start":10,"col_end":10,"count":256}]},{"line":"          create_path (height - 1)","counters":[{"col_start":10,"col_end":10,"count":256}]},{"line":"            ((if key mod 2 = 0 then `Left hash else `Right hash) :: path)","counters":[{"col_start":36,"col_end":36,"count":128},{"col_start":52,"col_end":52,"count":128}]},{"line":"            (key / 2)","counters":[]},{"line":"      in","counters":[]},{"line":"      let rec make_tree t key =","counters":[]},{"line":"        if Stack_id.( > ) key (Stack_id.of_int @@ (Int.pow 2 depth - 1)) then t","counters":[{"col_start":8,"col_end":8,"count":68},{"col_start":45,"col_end":45,"count":68},{"col_start":57,"col_end":57,"count":68},{"col_start":78,"col_end":78,"count":4}]},{"line":"        else","counters":[]},{"line":"          let path = create_path (depth - 1) [] (Stack_id.to_int key) in","counters":[{"col_start":10,"col_end":10,"count":64},{"col_start":63,"col_end":63,"count":64}]},{"line":"          make_tree","counters":[{"col_start":10,"col_end":10,"count":64}]},{"line":"            (Merkle_tree.add_path t path key Stack.empty)","counters":[{"col_start":32,"col_end":32,"count":64}]},{"line":"            (Or_error.ok_exn (Stack_id.incr_by_one key))","counters":[{"col_start":27,"col_end":27,"count":64},{"col_start":49,"col_end":49,"count":64}]},{"line":"      in","counters":[]},{"line":"      let root_hash = hash_at_level depth in","counters":[]},{"line":"      { Poly.tree =","counters":[{"col_start":6,"col_end":6,"count":4}]},{"line":"          make_tree (Merkle_tree.of_hash ~depth root_hash) Stack_id.zero","counters":[{"col_start":18,"col_end":18,"count":4},{"col_start":39,"col_end":39,"count":4}]},{"line":"      ; pos_list = []","counters":[]},{"line":"      ; new_pos = Stack_id.zero","counters":[]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    [%%define_locally Or_error.(try_with)]","counters":[]},{"line":"","counters":[]},{"line":"    let create ~depth () = try_with (fun () -> create_exn' ~depth ())","counters":[{"col_start":27,"col_end":27,"count":4},{"col_start":47,"col_end":47,"count":4}]},{"line":"","counters":[]},{"line":"    let merkle_root (t : t) = Merkle_tree.merkle_root t.tree","counters":[{"col_start":30,"col_end":30,"count":4}]},{"line":"","counters":[]},{"line":"    let get_stack (t : t) index =","counters":[]},{"line":"      try_with (fun () -> Merkle_tree.get_exn t.tree index)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"","counters":[]},{"line":"    let path (t : t) index =","counters":[]},{"line":"      try_with (fun () -> Merkle_tree.path_exn t.tree index)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"","counters":[]},{"line":"    let find_index (t : t) key =","counters":[]},{"line":"      try_with (fun () -> Merkle_tree.find_index_exn t.tree key)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"","counters":[]},{"line":"    let next_index ~depth (t : t) =","counters":[]},{"line":"      if","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Stack_id.equal t.new_pos","counters":[]},{"line":"          (Stack_id.of_int (max_coinbase_stack_count ~depth - 1))","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"      then Ok Stack_id.zero","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"      else Stack_id.incr_by_one t.new_pos","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"","counters":[]},{"line":"    let next_stack_id ~depth t ~is_new_stack =","counters":[]},{"line":"      if is_new_stack then next_index ~depth t else Ok t.new_pos","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"","counters":[]},{"line":"    let incr_index ~depth (t : t) ~is_new_stack =","counters":[]},{"line":"      let open Or_error.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      if is_new_stack then","counters":[]},{"line":"        let%map new_pos = next_index ~depth t in","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"        { t with pos_list = t.new_pos :: t.pos_list; new_pos }","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      else Ok t","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"","counters":[]},{"line":"    let set_stack ~depth (t : t) index stack ~is_new_stack =","counters":[]},{"line":"      let open Or_error.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%bind tree =","counters":[]},{"line":"        try_with (fun () -> Merkle_tree.set_exn t.tree index stack)","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"      in","counters":[]},{"line":"      incr_index ~depth { t with tree } ~is_new_stack","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let latest_stack_id (t : t) ~is_new_stack =","counters":[]},{"line":"      if is_new_stack then t.new_pos","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"      else match List.hd t.pos_list with Some x -> x | None -> Stack_id.zero","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"","counters":[]},{"line":"    let curr_stack_id (t : t) = List.hd t.pos_list","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"","counters":[]},{"line":"    let current_stack t =","counters":[]},{"line":"      let prev_stack_id =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Option.value ~default:Stack_id.zero (curr_stack_id t)","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"      in","counters":[]},{"line":"      Or_error.try_with (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          let index = Merkle_tree.find_index_exn t.tree prev_stack_id in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          Merkle_tree.get_exn t.tree index )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"    let latest_stack (t : t) ~is_new_stack =","counters":[]},{"line":"      let open Or_error.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let key = latest_stack_id t ~is_new_stack in","counters":[]},{"line":"      let%bind res =","counters":[]},{"line":"        Or_error.try_with (fun () ->","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"            let index = Merkle_tree.find_index_exn t.tree key in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            Merkle_tree.get_exn t.tree index )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"      in","counters":[]},{"line":"      if is_new_stack then","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let%map prev_stack = current_stack t in","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"        { res with state = State_stack.create ~init:prev_stack.state.curr }","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      else Ok res","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"","counters":[]},{"line":"    let oldest_stack_id (t : t) = List.last t.pos_list","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"","counters":[]},{"line":"    let remove_oldest_stack_id t =","counters":[]},{"line":"      match List.rev t with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | [] ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Or_error.error_string \"No coinbase stack-with-state-hash to pop\"","counters":[]},{"line":"      | x :: xs ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Ok (x, List.rev xs)","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"","counters":[]},{"line":"    let oldest_stack t =","counters":[]},{"line":"      let open Or_error.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let key = Option.value ~default:Stack_id.zero (oldest_stack_id t) in","counters":[{"col_start":67,"col_end":67,"count":0}]},{"line":"      let%bind index = find_index t key in","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"      get_stack t index","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let update_stack' ~depth t ~(f : Stack.t -> Stack.t) ~is_new_stack =","counters":[]},{"line":"      let open Or_error.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let key = latest_stack_id t ~is_new_stack in","counters":[]},{"line":"      let%bind stack_index = find_index t key in","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"      let%bind stack_before = get_stack t stack_index in","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"      let stack_after = f stack_before in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      (* state hash in \"after\" stack becomes previous state hash at top level *)","counters":[]},{"line":"      set_stack ~depth t stack_index stack_after ~is_new_stack","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let add_coinbase ~depth t ~coinbase ~is_new_stack =","counters":[]},{"line":"      update_stack' ~depth t ~f:(Stack.push_coinbase coinbase) ~is_new_stack","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"","counters":[]},{"line":"    let add_state ~depth t state_body_hash ~is_new_stack =","counters":[]},{"line":"      update_stack' ~depth t ~f:(Stack.push_state state_body_hash) ~is_new_stack","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"","counters":[]},{"line":"    let update_coinbase_stack ~depth (t : t) stack ~is_new_stack =","counters":[]},{"line":"      update_stack' ~depth t ~f:(fun _ -> stack) ~is_new_stack","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"","counters":[]},{"line":"    let remove_coinbase_stack ~depth (t : t) =","counters":[]},{"line":"      let open Or_error.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%bind oldest_stack, remaining = remove_oldest_stack_id t.pos_list in","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"      let%bind stack_index = find_index t oldest_stack in","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"      let%bind stack = get_stack t stack_index in","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"      let%map t' =","counters":[]},{"line":"        set_stack ~depth t stack_index Stack.empty ~is_new_stack:false","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"      in","counters":[]},{"line":"      (stack, { t' with pos_list = remaining })","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let hash_extra ({ pos_list; new_pos; _ } : t) =","counters":[]},{"line":"      let h = Digestif.SHA256.init () in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let h =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Digestif.SHA256.feed_string h","counters":[]},{"line":"          (List.fold pos_list ~init:\"\" ~f:(fun s a -> s ^ Stack_id.to_string a))","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":54,"col_end":54,"count":0},{"col_start":75,"col_end":75,"count":0}]},{"line":"      in","counters":[]},{"line":"      let h = Digestif.SHA256.feed_string h (Stack_id.to_string new_pos) in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"      Digestif.SHA256.(get h |> to_raw_string)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"    let handler ~depth (t : t) ~is_new_stack =","counters":[]},{"line":"      let pending_coinbase = ref t in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let coinbase_stack_path_exn idx =","counters":[]},{"line":"        List.map","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (path !pending_coinbase idx |> Or_error.ok_exn)","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"          ~f:(function `Left h -> h | `Right h -> h)","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"      in","counters":[]},{"line":"      stage (fun (With { request; respond }) ->","counters":[]},{"line":"          match request with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | Checked.Coinbase_stack_path idx ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let path =","counters":[]},{"line":"                (coinbase_stack_path_exn idx :> Random_oracle.Digest.t list)","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"              in","counters":[]},{"line":"              respond (Provide path)","counters":[]},{"line":"          | Checked.Find_index_of_oldest_stack ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let stack_id =","counters":[]},{"line":"                Option.value ~default:Stack_id.zero","counters":[]},{"line":"                  (oldest_stack_id !pending_coinbase)","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"              in","counters":[]},{"line":"              let index =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                find_index !pending_coinbase stack_id |> Or_error.ok_exn","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"              in","counters":[]},{"line":"              respond (Provide index)","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"          | Checked.Find_index_of_newest_stacks _action ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let index1 =","counters":[]},{"line":"                let stack_id =","counters":[]},{"line":"                  latest_stack_id !pending_coinbase ~is_new_stack","counters":[]},{"line":"                in","counters":[]},{"line":"                find_index !pending_coinbase stack_id |> Or_error.ok_exn","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"              in","counters":[]},{"line":"              let index2 =","counters":[]},{"line":"                let stack_id =","counters":[]},{"line":"                  match","counters":[]},{"line":"                    next_stack_id ~depth !pending_coinbase ~is_new_stack","counters":[]},{"line":"                  with","counters":[]},{"line":"                  | Ok id ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      id","counters":[]},{"line":"                  | _ ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      Stack_id.zero","counters":[]},{"line":"                in","counters":[]},{"line":"                find_index !pending_coinbase stack_id |> Or_error.ok_exn","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"              in","counters":[]},{"line":"              respond @@ Provide (index1, index2)","counters":[]},{"line":"          | Checked.Get_coinbase_stack idx ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let elt = get_stack !pending_coinbase idx |> Or_error.ok_exn in","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"              let path =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (coinbase_stack_path_exn idx :> Random_oracle.Digest.t list)","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"              in","counters":[]},{"line":"              respond (Provide (elt, path))","counters":[]},{"line":"          | Checked.Set_coinbase_stack (idx, stack) ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              pending_coinbase :=","counters":[]},{"line":"                set_stack ~depth !pending_coinbase idx stack ~is_new_stack","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                |> Or_error.ok_exn ;","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"              respond (Provide ())","counters":[]},{"line":"          | Checked.Set_oldest_coinbase_stack (idx, stack) ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              pending_coinbase :=","counters":[]},{"line":"                set_stack ~depth !pending_coinbase idx stack ~is_new_stack:false","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                |> Or_error.ok_exn ;","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"              respond (Provide ())","counters":[]},{"line":"          | Checked.Get_previous_stack ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let prev_state =","counters":[]},{"line":"                if is_new_stack then","counters":[]},{"line":"                  let stack =","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    current_stack !pending_coinbase |> Or_error.ok_exn","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                  in","counters":[]},{"line":"                  { State_stack.Poly.init = stack.state.curr","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  ; curr = stack.state.curr","counters":[]},{"line":"                  }","counters":[]},{"line":"                else","counters":[]},{"line":"                  let stack =","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    latest_stack !pending_coinbase ~is_new_stack","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                    |> Or_error.ok_exn","counters":[]},{"line":"                  in","counters":[]},{"line":"                  stack.state","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"              in","counters":[]},{"line":"              respond (Provide prev_state)","counters":[]},{"line":"          | _ ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              unhandled )","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  include T","counters":[]},{"line":"","counters":[]},{"line":"  module Poly_versioned = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type ('tree, 'stack_id) t = ('tree, 'stack_id) T.Poly.t =","counters":[{"col_start":8,"col_end":8,"count":1},{"col_start":32,"col_end":32,"count":5}]},{"line":"          { tree : 'tree; pos_list : 'stack_id list; new_pos : 'stack_id }","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":50,"col_end":50,"count":0},{"col_start":53,"col_end":53,"count":0},{"col_start":59,"col_end":59,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"        [@@deriving sexp, to_yojson]","counters":[{"col_start":35,"col_end":35,"count":3}]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    [@@@no_toplevel_latest_type]","counters":[]},{"line":"","counters":[]},{"line":"    module V2 = struct","counters":[]},{"line":"      type t =","counters":[{"col_start":6,"col_end":6,"count":2},{"col_start":11,"col_end":11,"count":1}]},{"line":"        ( Merkle_tree_versioned.Stable.V2.t","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":10,"col_end":10,"count":0}]},{"line":"        , Stack_id.Stable.V1.t )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        Poly_versioned.Stable.V1.t","counters":[]},{"line":"      [@@deriving sexp, to_yojson]","counters":[{"col_start":33,"col_end":33,"count":5}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"      type _unused = unit constraint t = T.t","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  type _unused = unit constraint Stable.Latest.t = t","counters":[]},{"line":"","counters":[]},{"line":"  let%test_unit \"add stack + remove stack = initial tree \" =","counters":[]},{"line":"    let constraint_constants =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Genesis_constants.Constraint_constants.for_unit_tests","counters":[]},{"line":"    in","counters":[]},{"line":"    let depth = constraint_constants.pending_coinbase_depth in","counters":[]},{"line":"    let coinbases_gen =","counters":[]},{"line":"      Quickcheck.Generator.list_non_empty","counters":[]},{"line":"        (Coinbase.Gen.gen ~constraint_constants)","counters":[]},{"line":"    in","counters":[]},{"line":"    let pending_coinbases = ref (create ~depth () |> Or_error.ok_exn) in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"    Quickcheck.test coinbases_gen ~trials:50 ~f:(fun cbs ->","counters":[]},{"line":"        Run_in_thread.block_on_async_exn (fun () ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            let is_new_stack = ref true in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let init = merkle_root !pending_coinbases in","counters":[]},{"line":"            let after_adding =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              List.fold cbs ~init:!pending_coinbases","counters":[]},{"line":"                ~f:(fun acc (coinbase, _) ->","counters":[]},{"line":"                  let t =","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    add_coinbase ~depth acc ~coinbase","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                      ~is_new_stack:!is_new_stack","counters":[]},{"line":"                    |> Or_error.ok_exn","counters":[]},{"line":"                  in","counters":[]},{"line":"                  is_new_stack := false ;","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  t )","counters":[]},{"line":"            in","counters":[]},{"line":"            let _, after_del =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              remove_coinbase_stack ~depth after_adding |> Or_error.ok_exn","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"            in","counters":[]},{"line":"            pending_coinbases := after_del ;","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            assert (Hash.equal (merkle_root after_del) init) ;","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"            Async_kernel.Deferred.return () ) )","counters":[]},{"line":"","counters":[]},{"line":"  module type Pending_coinbase_intf = sig","counters":[]},{"line":"    type t [@@deriving sexp]","counters":[]},{"line":"","counters":[]},{"line":"    val add_coinbase :","counters":[]},{"line":"      depth:int -> t -> coinbase:Coinbase.t -> is_new_stack:bool -> t Or_error.t","counters":[]},{"line":"","counters":[]},{"line":"    val add_state :","counters":[]},{"line":"      depth:int -> t -> State_body_hash.t -> is_new_stack:bool -> t Or_error.t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let add_coinbase_with_zero_checks (type t)","counters":[]},{"line":"      (module T : Pending_coinbase_intf with type t = t) (t : t)","counters":[]},{"line":"      ~(constraint_constants : Genesis_constants.Constraint_constants.t)","counters":[]},{"line":"      ~coinbase ~supercharged_coinbase ~state_body_hash ~is_new_stack =","counters":[]},{"line":"    let depth = constraint_constants.pending_coinbase_depth in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    if Amount.equal coinbase.Coinbase.amount Amount.zero then t","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"    else","counters":[]},{"line":"      let max_coinbase_amount =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        if supercharged_coinbase then","counters":[]},{"line":"          Option.value_exn","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"            (Currency.Amount.scale constraint_constants.coinbase_amount","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"               constraint_constants.supercharged_coinbase_factor )","counters":[]},{"line":"        else constraint_constants.coinbase_amount","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"      in","counters":[]},{"line":"      let coinbase' =","counters":[]},{"line":"        Coinbase.create","counters":[]},{"line":"          ~amount:","counters":[]},{"line":"            (Option.value_exn (Amount.sub max_coinbase_amount coinbase.amount))","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"          ~receiver:coinbase.receiver ~fee_transfer:None","counters":[]},{"line":"        |> Or_error.ok_exn","counters":[]},{"line":"      in","counters":[]},{"line":"      let t_with_state =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        T.add_state ~depth t state_body_hash ~is_new_stack |> Or_error.ok_exn","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"      in","counters":[]},{"line":"      (*add coinbase to the same stack*)","counters":[]},{"line":"      let interim_tree =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        T.add_coinbase ~depth t_with_state ~coinbase ~is_new_stack:false","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"        |> Or_error.ok_exn","counters":[]},{"line":"      in","counters":[]},{"line":"      if Amount.equal coinbase'.amount Amount.zero then interim_tree","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"      else","counters":[]},{"line":"        T.add_coinbase ~depth interim_tree ~coinbase:coinbase'","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"          ~is_new_stack:false","counters":[]},{"line":"        |> Or_error.ok_exn","counters":[]},{"line":"","counters":[]},{"line":"  let%test_unit \"Checked_stack = Unchecked_stack\" =","counters":[]},{"line":"    let open Quickcheck in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let constraint_constants =","counters":[]},{"line":"      Genesis_constants.Constraint_constants.for_unit_tests","counters":[]},{"line":"    in","counters":[]},{"line":"    test ~trials:20","counters":[]},{"line":"      (Generator.tuple2 Stack.gen (Coinbase.Gen.gen ~constraint_constants))","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"      ~f:(fun (base, (cb, _supercharged_coinbase)) ->","counters":[]},{"line":"        let coinbase_data = Coinbase_data.of_coinbase cb in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let unchecked = Stack.push_coinbase cb base in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let checked =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let comp =","counters":[]},{"line":"            let open Snark_params.Tick in","counters":[]},{"line":"            let cb_var = Coinbase_data.(var_of_t coinbase_data) in","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"            let%map res =","counters":[]},{"line":"              Stack.Checked.push_coinbase cb_var (Stack.var_of_t base)","counters":[{"col_start":40,"col_end":40,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"            in","counters":[]},{"line":"            As_prover.read Stack.typ res","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          in","counters":[]},{"line":"          Or_error.ok_exn (run_and_check comp)","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"        in","counters":[]},{"line":"        assert (Stack.equal unchecked checked) )","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"","counters":[]},{"line":"  let%test_unit \"Checked_tree = Unchecked_tree\" =","counters":[]},{"line":"    let open Quickcheck in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let constraint_constants =","counters":[]},{"line":"      Genesis_constants.Constraint_constants.for_unit_tests","counters":[]},{"line":"    in","counters":[]},{"line":"    let depth = constraint_constants.pending_coinbase_depth in","counters":[]},{"line":"    let pending_coinbases = create ~depth () |> Or_error.ok_exn in","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"    test ~trials:20","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (Generator.tuple2","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"         (Coinbase.Gen.gen ~constraint_constants)","counters":[]},{"line":"         State_body_hash.gen )","counters":[]},{"line":"      ~f:(fun ( (coinbase, `Supercharged_coinbase supercharged_coinbase)","counters":[]},{"line":"              , state_body_hash ) ->","counters":[]},{"line":"        let amount = coinbase.amount in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let is_new_stack, action =","counters":[]},{"line":"          Currency.Amount.(","counters":[]},{"line":"            if equal coinbase.amount zero then (true, Update.Action.Update_none)","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"            else (true, Update_one))","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"        in","counters":[]},{"line":"        let unchecked =","counters":[]},{"line":"          add_coinbase_with_zero_checks ~constraint_constants","counters":[]},{"line":"            (module T)","counters":[]},{"line":"            pending_coinbases ~coinbase ~is_new_stack ~state_body_hash","counters":[]},{"line":"            ~supercharged_coinbase","counters":[]},{"line":"        in","counters":[]},{"line":"        (* inside the `open' below, Checked means something else, so define this function *)","counters":[]},{"line":"        let f_add_coinbase = Checked.add_coinbase ~constraint_constants in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let checked_merkle_root =","counters":[]},{"line":"          let comp =","counters":[]},{"line":"            let open Snark_params.Tick in","counters":[]},{"line":"            let amount_var = Amount.var_of_t amount in","counters":[]},{"line":"            let action_var = Update.Action.var_of_t action in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let coinbase_receiver_var =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Public_key.Compressed.var_of_t coinbase.receiver","counters":[]},{"line":"            in","counters":[]},{"line":"            let supercharge_coinbase_var =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Boolean.var_of_value supercharged_coinbase","counters":[]},{"line":"            in","counters":[]},{"line":"            let state_body_hash_var =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              State_body_hash.var_of_t state_body_hash","counters":[]},{"line":"            in","counters":[]},{"line":"            let%map result =","counters":[]},{"line":"              handle","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"                (fun () ->","counters":[]},{"line":"                  f_add_coinbase","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    (Hash.var_of_t (merkle_root pending_coinbases))","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"                    { Update.Poly.action = action_var","counters":[]},{"line":"                    ; coinbase_amount = amount_var","counters":[]},{"line":"                    }","counters":[]},{"line":"                    ~coinbase_receiver:coinbase_receiver_var","counters":[]},{"line":"                    ~supercharge_coinbase:supercharge_coinbase_var","counters":[]},{"line":"                    state_body_hash_var )","counters":[]},{"line":"                (unstage (handler ~depth pending_coinbases ~is_new_stack))","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"            in","counters":[]},{"line":"            As_prover.read Hash.typ result","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          in","counters":[]},{"line":"          Or_error.ok_exn (run_and_check comp)","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"        in","counters":[]},{"line":"        assert (Hash.equal (merkle_root unchecked) checked_merkle_root) )","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"","counters":[]},{"line":"  let%test_unit \"Checked_tree = Unchecked_tree after pop\" =","counters":[]},{"line":"    let open Quickcheck in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let constraint_constants =","counters":[]},{"line":"      Genesis_constants.Constraint_constants.for_unit_tests","counters":[]},{"line":"    in","counters":[]},{"line":"    let depth = constraint_constants.pending_coinbase_depth in","counters":[]},{"line":"    test ~trials:20","counters":[]},{"line":"      (Generator.tuple2","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"         (Coinbase.Gen.gen ~constraint_constants)","counters":[]},{"line":"         State_body_hash.gen )","counters":[]},{"line":"      ~f:(fun ( (coinbase, `Supercharged_coinbase supercharged_coinbase)","counters":[]},{"line":"              , state_body_hash ) ->","counters":[]},{"line":"        let pending_coinbases = create ~depth () |> Or_error.ok_exn in","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"        let amount = coinbase.amount in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let action =","counters":[]},{"line":"          Currency.Amount.(","counters":[]},{"line":"            if equal coinbase.amount zero then Update.Action.Update_none","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"            else Update_one)","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"        in","counters":[]},{"line":"        let unchecked =","counters":[]},{"line":"          add_coinbase_with_zero_checks ~constraint_constants","counters":[]},{"line":"            (module T)","counters":[]},{"line":"            pending_coinbases ~coinbase ~is_new_stack:true ~state_body_hash","counters":[]},{"line":"            ~supercharged_coinbase","counters":[]},{"line":"        in","counters":[]},{"line":"        (* inside the `open' below, Checked means something else, so define these functions *)","counters":[]},{"line":"        let f_add_coinbase = Checked.add_coinbase ~constraint_constants in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let f_pop_coinbase = Checked.pop_coinbases ~constraint_constants in","counters":[]},{"line":"        let checked_merkle_root =","counters":[]},{"line":"          let comp =","counters":[]},{"line":"            let open Snark_params.Tick in","counters":[]},{"line":"            let amount_var = Amount.var_of_t amount in","counters":[]},{"line":"            let action_var = Update.Action.(var_of_t action) in","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"            let coinbase_receiver_var =","counters":[]},{"line":"              Public_key.Compressed.var_of_t coinbase.receiver","counters":[]},{"line":"            in","counters":[]},{"line":"            let supercharge_coinbase_var =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Boolean.var_of_value supercharged_coinbase","counters":[]},{"line":"            in","counters":[]},{"line":"            let state_body_hash_var =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              State_body_hash.var_of_t state_body_hash","counters":[]},{"line":"            in","counters":[]},{"line":"            let%map result =","counters":[]},{"line":"              handle","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"                (fun () ->","counters":[]},{"line":"                  f_add_coinbase","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    (Hash.var_of_t (merkle_root pending_coinbases))","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"                    { Update.Poly.action = action_var","counters":[]},{"line":"                    ; coinbase_amount = amount_var","counters":[]},{"line":"                    }","counters":[]},{"line":"                    ~coinbase_receiver:coinbase_receiver_var","counters":[]},{"line":"                    ~supercharge_coinbase:supercharge_coinbase_var","counters":[]},{"line":"                    state_body_hash_var )","counters":[]},{"line":"                (unstage (handler ~depth pending_coinbases ~is_new_stack:true))","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"            in","counters":[]},{"line":"            As_prover.read Hash.typ result","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          in","counters":[]},{"line":"          Or_error.ok_exn (run_and_check comp)","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"        in","counters":[]},{"line":"        assert (Hash.equal (merkle_root unchecked) checked_merkle_root) ;","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"        (*deleting the coinbase stack we just created. therefore if there was no update then don't try to delete*)","counters":[]},{"line":"        let proof_emitted = not Update.Action.(equal action Update_none) in","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"        let unchecked_after_pop =","counters":[]},{"line":"          if proof_emitted then","counters":[]},{"line":"            remove_coinbase_stack ~depth unchecked |> Or_error.ok_exn |> snd","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":68,"col_end":68,"count":0},{"col_start":73,"col_end":73,"count":0},{"col_start":75,"col_end":75,"count":0}]},{"line":"          else unchecked","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"        in","counters":[]},{"line":"        let checked_merkle_root_after_pop =","counters":[]},{"line":"          let comp =","counters":[]},{"line":"            let open Snark_params.Tick in","counters":[]},{"line":"            let%map current, _previous =","counters":[]},{"line":"              handle","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"                (fun () ->","counters":[]},{"line":"                  f_pop_coinbase ~proof_emitted:Boolean.true_","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    (Hash.var_of_t checked_merkle_root) )","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"                (unstage (handler ~depth unchecked ~is_new_stack:false))","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"            in","counters":[]},{"line":"            As_prover.read Hash.typ current","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          in","counters":[]},{"line":"          Or_error.ok_exn (run_and_check comp)","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"        in","counters":[]},{"line":"        assert (","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"          Hash.equal","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"            (merkle_root unchecked_after_pop)","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"            checked_merkle_root_after_pop ) )","counters":[]},{"line":"","counters":[]},{"line":"  let%test_unit \"push and pop multiple stacks\" =","counters":[]},{"line":"    let open Quickcheck in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let module Pending_coinbase = T in","counters":[]},{"line":"    let constraint_constants =","counters":[]},{"line":"      { Genesis_constants.Constraint_constants.for_unit_tests with","counters":[]},{"line":"        pending_coinbase_depth = 3","counters":[]},{"line":"      }","counters":[]},{"line":"    in","counters":[]},{"line":"    let depth = constraint_constants.pending_coinbase_depth in","counters":[]},{"line":"    let t_of_coinbases t = function","counters":[]},{"line":"      | [] ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let t' =","counters":[]},{"line":"            Pending_coinbase.incr_index ~depth t ~is_new_stack:true","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"            |> Or_error.ok_exn","counters":[]},{"line":"          in","counters":[]},{"line":"          (Pending_coinbase.Stack.empty, t')","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"      | ((initial_coinbase, _supercharged_coinbase), state_body_hash)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        :: coinbases ->","counters":[]},{"line":"          let t' =","counters":[]},{"line":"            Pending_coinbase.add_state ~depth t state_body_hash","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"              ~is_new_stack:true","counters":[]},{"line":"            |> Or_error.ok_exn","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"            |> Pending_coinbase.add_coinbase ~depth ~coinbase:initial_coinbase","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"                 ~is_new_stack:false","counters":[]},{"line":"            |> Or_error.ok_exn","counters":[]},{"line":"          in","counters":[]},{"line":"          let updated =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            List.fold coinbases ~init:t'","counters":[]},{"line":"              ~f:(fun","counters":[]},{"line":"                   pending_coinbases","counters":[]},{"line":"                   ( (coinbase, `Supercharged_coinbase supercharged_coinbase)","counters":[]},{"line":"                   , state_body_hash )","counters":[]},{"line":"                 ->","counters":[]},{"line":"                add_coinbase_with_zero_checks ~constraint_constants","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  (module Pending_coinbase)","counters":[]},{"line":"                  pending_coinbases ~coinbase ~is_new_stack:false","counters":[]},{"line":"                  ~state_body_hash ~supercharged_coinbase )","counters":[]},{"line":"          in","counters":[]},{"line":"          let new_stack =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Or_error.ok_exn","counters":[]},{"line":"            @@ Pending_coinbase.latest_stack updated ~is_new_stack:false","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"          in","counters":[]},{"line":"          (new_stack, updated)","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    in","counters":[]},{"line":"    (* Create pending coinbase stacks from coinbase lists and add it to the pending coinbase merkle tree *)","counters":[]},{"line":"    let add coinbase_lists pending_coinbases =","counters":[]},{"line":"      List.fold ~init:([], pending_coinbases) coinbase_lists","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ~f:(fun (stacks, pc) coinbases ->","counters":[]},{"line":"          let new_stack, pc = t_of_coinbases pc coinbases in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          (new_stack :: stacks, pc) )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    in","counters":[]},{"line":"    (* remove the oldest stack and check if that's the expected one *)","counters":[]},{"line":"    let remove_check t expected_stack =","counters":[]},{"line":"      let popped_stack, updated_pending_coinbases =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Pending_coinbase.remove_coinbase_stack ~depth t |> Or_error.ok_exn","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"      in","counters":[]},{"line":"      assert (Pending_coinbase.Stack.equal_data popped_stack expected_stack) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"      updated_pending_coinbases","counters":[]},{"line":"    in","counters":[]},{"line":"    let add_remove_check coinbase_lists =","counters":[]},{"line":"      let max_coinbase_stack_count =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Pending_coinbase.max_coinbase_stack_count ~depth","counters":[]},{"line":"      in","counters":[]},{"line":"      let pending_coinbases = Pending_coinbase.create_exn' ~depth () in","counters":[]},{"line":"      let rec go coinbase_lists pc =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        if List.is_empty coinbase_lists then ()","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"        else","counters":[]},{"line":"          let coinbase_lists' =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            List.take coinbase_lists max_coinbase_stack_count","counters":[]},{"line":"          in","counters":[]},{"line":"          let added_stacks, pending_coinbases_updated =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            add coinbase_lists' pc","counters":[]},{"line":"          in","counters":[]},{"line":"          let pending_coinbases' =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            List.fold ~init:pending_coinbases_updated (List.rev added_stacks)","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"              ~f:(fun pc expected_stack -> remove_check pc expected_stack)","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"          in","counters":[]},{"line":"          let remaining_lists =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            List.drop coinbase_lists max_coinbase_stack_count","counters":[]},{"line":"          in","counters":[]},{"line":"          go remaining_lists pending_coinbases'","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"      in","counters":[]},{"line":"      go coinbase_lists pending_coinbases","counters":[]},{"line":"    in","counters":[]},{"line":"    let coinbase_lists_gen =","counters":[]},{"line":"      Quickcheck.Generator.(","counters":[]},{"line":"        list","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"          (list","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"             (Generator.tuple2","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                (Coinbase.Gen.gen ~constraint_constants)","counters":[]},{"line":"                State_body_hash.gen ) ))","counters":[]},{"line":"    in","counters":[]},{"line":"    test ~trials:100 coinbase_lists_gen ~f:add_remove_check","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"include Wire_types.Make (Make_sig) (Make_str)","counters":[{"col_start":44,"col_end":44,"count":1}]}]}