{"filename":"src/lib/mina_generators/zkapp_command_generators.ml","lines":[{"line":"(* zkapp_command_generators -- Quickcheck generators for zkApp transactions *)","counters":[]},{"line":"","counters":[]},{"line":"open Core_kernel","counters":[]},{"line":"open Mina_base","counters":[]},{"line":"module Ledger = Mina_ledger.Ledger","counters":[]},{"line":"","counters":[]},{"line":"type failure =","counters":[]},{"line":"  | Invalid_account_precondition","counters":[]},{"line":"  | Invalid_protocol_state_precondition","counters":[]},{"line":"  | Update_not_permitted of","counters":[]},{"line":"      [ `Delegate","counters":[]},{"line":"      | `App_state","counters":[]},{"line":"      | `Voting_for","counters":[]},{"line":"      | `Verification_key","counters":[]},{"line":"      | `Zkapp_uri","counters":[]},{"line":"      | `Token_symbol","counters":[]},{"line":"      | `Send","counters":[]},{"line":"      | `Receive ]","counters":[]},{"line":"","counters":[]},{"line":"type role =","counters":[]},{"line":"  [ `Fee_payer | `New_account | `Ordinary_participant | `New_token_account ]","counters":[]},{"line":"","counters":[]},{"line":"let gen_account_precondition_from_account ?failure ~first_use_of_account account","counters":[]},{"line":"    =","counters":[]},{"line":"  let open Quickcheck.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let { Account.Poly.balance; nonce; delegate; receipt_chain_hash; zkapp; _ } =","counters":[]},{"line":"    account","counters":[]},{"line":"  in","counters":[]},{"line":"  (* choose constructor *)","counters":[]},{"line":"  let%bind b = Quickcheck.Generator.bool in","counters":[]},{"line":"  if b then","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    (* Full *)","counters":[]},{"line":"    let open Zkapp_basic in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let%bind (predicate_account : Zkapp_precondition.Account.t) =","counters":[]},{"line":"      let%bind balance =","counters":[]},{"line":"        let%bind balance_change_int = Int.gen_uniform_incl 1 10_000_000 in","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"        let balance_change = Currency.Amount.of_int balance_change_int in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let lower =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          match Currency.Balance.sub_amount balance balance_change with","counters":[]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Currency.Balance.zero","counters":[]},{"line":"          | Some bal ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              bal","counters":[]},{"line":"        in","counters":[]},{"line":"        let upper =","counters":[]},{"line":"          match Currency.Balance.add_amount balance balance_change with","counters":[]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Currency.Balance.max_int","counters":[]},{"line":"          | Some bal ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              bal","counters":[]},{"line":"        in","counters":[]},{"line":"        Or_ignore.gen","counters":[]},{"line":"          (return { Zkapp_precondition.Closed_interval.lower; upper })","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"      in","counters":[]},{"line":"      let%bind nonce =","counters":[]},{"line":"        let%bind nonce_change_int = Int.gen_uniform_incl 1 100 in","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"        let nonce_change = Account.Nonce.of_int nonce_change_int in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let lower =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          match Account.Nonce.sub nonce nonce_change with","counters":[]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Account.Nonce.zero","counters":[]},{"line":"          | Some nonce ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              nonce","counters":[]},{"line":"        in","counters":[]},{"line":"        let upper =","counters":[]},{"line":"          (* Nonce.add doesn't check for overflow, so check here *)","counters":[]},{"line":"          match Account.Nonce.(sub max_value) nonce_change with","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (* unreachable *)","counters":[]},{"line":"              failwith","counters":[]},{"line":"                \"gen_account_precondition_from: nonce subtraction failed \\","counters":[]},{"line":"                 unexpectedly\"","counters":[]},{"line":"          | Some n ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              if Account.Nonce.( < ) n nonce then Account.Nonce.max_value","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"              else Account.Nonce.add nonce nonce_change","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"        in","counters":[]},{"line":"        Or_ignore.gen","counters":[]},{"line":"          (return { Zkapp_precondition.Closed_interval.lower; upper })","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"      in","counters":[]},{"line":"      let receipt_chain_hash =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        if first_use_of_account then Or_ignore.Check receipt_chain_hash","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"        else Or_ignore.Ignore","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"      in","counters":[]},{"line":"      let%bind delegate =","counters":[]},{"line":"        match delegate with","counters":[]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            return Or_ignore.Ignore","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"        | Some pk ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Or_ignore.gen (return pk)","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"      in","counters":[]},{"line":"      let%bind state, sequence_state, proved_state, is_new =","counters":[]},{"line":"        match zkapp with","counters":[]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let len = Pickles_types.Nat.to_int Zkapp_state.Max_state_size.n in","counters":[]},{"line":"            (* won't raise, correct length given *)","counters":[]},{"line":"            let state =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Zkapp_state.V.of_list_exn","counters":[]},{"line":"                (List.init len ~f:(fun _ -> Or_ignore.Ignore))","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"            in","counters":[]},{"line":"            let sequence_state = Or_ignore.Ignore in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let proved_state = Or_ignore.Ignore in","counters":[]},{"line":"            let is_new = Or_ignore.Ignore in","counters":[]},{"line":"            return (state, sequence_state, proved_state, is_new)","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"        | Some { Zkapp_account.app_state; sequence_state; proved_state; _ } ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let state =","counters":[]},{"line":"              Zkapp_state.V.map app_state ~f:(fun field ->","counters":[]},{"line":"                  Quickcheck.random_value (Or_ignore.gen (return field)) )","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":55,"col_end":55,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"            in","counters":[]},{"line":"            let%bind sequence_state =","counters":[]},{"line":"              (* choose a value from account sequence state *)","counters":[]},{"line":"              let fields =","counters":[]},{"line":"                Pickles_types.Vector.Vector_5.to_list sequence_state","counters":[]},{"line":"              in","counters":[]},{"line":"              let%bind ndx = Int.gen_uniform_incl 0 (List.length fields - 1) in","counters":[{"col_start":48,"col_end":48,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"              return (Or_ignore.Check (List.nth_exn fields ndx))","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"            in","counters":[]},{"line":"            let proved_state = Or_ignore.Check proved_state in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let is_new =","counters":[]},{"line":"              (* when we apply the generated Zkapp_command.t, the account is always in the ledger","counters":[]},{"line":"              *)","counters":[]},{"line":"              Or_ignore.Check false","counters":[]},{"line":"            in","counters":[]},{"line":"            return (state, sequence_state, proved_state, is_new)","counters":[]},{"line":"      in","counters":[]},{"line":"      return","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { Zkapp_precondition.Account.balance","counters":[]},{"line":"        ; nonce","counters":[]},{"line":"        ; receipt_chain_hash","counters":[]},{"line":"        ; delegate","counters":[]},{"line":"        ; state","counters":[]},{"line":"        ; sequence_state","counters":[]},{"line":"        ; proved_state","counters":[]},{"line":"        ; is_new","counters":[]},{"line":"        }","counters":[]},{"line":"    in","counters":[]},{"line":"    match failure with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Some Invalid_account_precondition ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let module Tamperable = struct","counters":[]},{"line":"          type t =","counters":[]},{"line":"            | Balance","counters":[]},{"line":"            | Nonce","counters":[]},{"line":"            | Receipt_chain_hash","counters":[]},{"line":"            | Delegate","counters":[]},{"line":"            | State","counters":[]},{"line":"            | Sequence_state","counters":[]},{"line":"            | Proved_state","counters":[]},{"line":"        end in","counters":[]},{"line":"        let%bind faulty_predicate_account =","counters":[]},{"line":"          (* tamper with account using randomly chosen item *)","counters":[]},{"line":"          let tamperable : Tamperable.t list =","counters":[]},{"line":"            [ Balance","counters":[]},{"line":"            ; Nonce","counters":[]},{"line":"            ; Receipt_chain_hash","counters":[]},{"line":"            ; Delegate","counters":[]},{"line":"            ; State","counters":[]},{"line":"            ; Sequence_state","counters":[]},{"line":"            ; Proved_state","counters":[]},{"line":"            ]","counters":[]},{"line":"          in","counters":[]},{"line":"          match%bind Quickcheck.Generator.of_list tamperable with","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"          | Balance ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let new_balance =","counters":[]},{"line":"                if Currency.Balance.equal balance Currency.Balance.zero then","counters":[]},{"line":"                  Currency.Balance.max_int","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                else Currency.Balance.zero","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"              in","counters":[]},{"line":"              let balance =","counters":[]},{"line":"                Or_ignore.Check","counters":[]},{"line":"                  { Zkapp_precondition.Closed_interval.lower = new_balance","counters":[]},{"line":"                  ; upper = new_balance","counters":[]},{"line":"                  }","counters":[]},{"line":"              in","counters":[]},{"line":"              return { predicate_account with balance }","counters":[]},{"line":"          | Nonce ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let new_nonce =","counters":[]},{"line":"                if Account.Nonce.equal nonce Account.Nonce.zero then","counters":[]},{"line":"                  Account.Nonce.max_value","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                else Account.Nonce.zero","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"              in","counters":[]},{"line":"              let%bind nonce =","counters":[]},{"line":"                Zkapp_precondition.Numeric.gen (return new_nonce)","counters":[{"col_start":45,"col_end":45,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"                  Account.Nonce.compare","counters":[]},{"line":"              in","counters":[]},{"line":"              return { predicate_account with nonce }","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"          | Receipt_chain_hash ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let%bind new_receipt_chain_hash = Receipt.Chain_hash.gen in","counters":[]},{"line":"              let%bind receipt_chain_hash =","counters":[]},{"line":"                Or_ignore.gen (return new_receipt_chain_hash)","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"              in","counters":[]},{"line":"              return { predicate_account with receipt_chain_hash }","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"          | Delegate ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let%bind delegate =","counters":[]},{"line":"                Or_ignore.gen Signature_lib.Public_key.Compressed.gen","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"              in","counters":[]},{"line":"              return { predicate_account with delegate }","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"          | State ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let fields =","counters":[]},{"line":"                Zkapp_state.V.to_list predicate_account.state |> Array.of_list","counters":[{"col_start":65,"col_end":65,"count":0}]},{"line":"              in","counters":[]},{"line":"              let%bind ndx = Int.gen_incl 0 (Array.length fields - 1) in","counters":[{"col_start":40,"col_end":40,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"              let%bind field = Snark_params.Tick.Field.gen in","counters":[]},{"line":"              fields.(ndx) <- Or_ignore.Check field ;","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              let state = Zkapp_state.V.of_list_exn (Array.to_list fields) in","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"              return { predicate_account with state }","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"          | Sequence_state ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let%bind field = Snark_params.Tick.Field.gen in","counters":[]},{"line":"              let sequence_state = Or_ignore.Check field in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              return { predicate_account with sequence_state }","counters":[]},{"line":"          | Proved_state ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let%bind proved_state =","counters":[]},{"line":"                match predicate_account.proved_state with","counters":[]},{"line":"                | Check b ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    return (Or_ignore.Check (not b))","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                | Ignore ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    return (Or_ignore.Check true)","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"              in","counters":[]},{"line":"              return { predicate_account with proved_state }","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"        in","counters":[]},{"line":"        return","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (Account_update.Account_precondition.Full faulty_predicate_account)","counters":[]},{"line":"    | _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        return (Account_update.Account_precondition.Full predicate_account)","counters":[]},{"line":"  else","counters":[]},{"line":"    (* Nonce *)","counters":[]},{"line":"    let { Account.Poly.nonce; _ } = account in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    match failure with","counters":[]},{"line":"    | Some Invalid_account_precondition ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        return","counters":[]},{"line":"          (Account_update.Account_precondition.Nonce (Account.Nonce.succ nonce))","counters":[{"col_start":71,"col_end":71,"count":0}]},{"line":"    | _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        return (Account_update.Account_precondition.Nonce nonce)","counters":[]},{"line":"","counters":[]},{"line":"let gen_fee (account : Account.t) =","counters":[]},{"line":"  let balance = account.balance in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let lo_fee = Mina_compile_config.minimum_user_command_fee in","counters":[]},{"line":"  let hi_fee =","counters":[]},{"line":"    Option.value_exn","counters":[]},{"line":"      Currency.Fee.(scale Mina_compile_config.minimum_user_command_fee 2)","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"  in","counters":[]},{"line":"  assert (","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":9,"col_end":9,"count":0}]},{"line":"    Currency.(","counters":[]},{"line":"      Fee.(hi_fee <= (Balance.to_amount balance |> Currency.Amount.to_fee))) ) ;","counters":[{"col_start":51,"col_end":51,"count":0},{"col_start":72,"col_end":72,"count":0}]},{"line":"  Currency.Fee.gen_incl lo_fee hi_fee","counters":[]},{"line":"","counters":[]},{"line":"(*Fee payer balance change is Neg*)","counters":[]},{"line":"let fee_to_amt fee =","counters":[]},{"line":"  Currency.Amount.(Signed.of_unsigned (of_fee fee) |> Signed.negate)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"","counters":[]},{"line":"let gen_balance_change ?permissions_auth (account : Account.t) ?failure","counters":[]},{"line":"    ~new_account =","counters":[]},{"line":"  let open Quickcheck.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%bind sgn =","counters":[]},{"line":"    if new_account then return Sgn.Pos","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"    else","counters":[]},{"line":"      match (failure, permissions_auth) with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Some (Update_not_permitted `Send), _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          return Sgn.Neg","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"      | Some (Update_not_permitted `Receive), _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          return Sgn.Pos","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"      | _, Some auth -> (","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          match auth with","counters":[]},{"line":"          | Control.Tag.None_given ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              return Sgn.Pos","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"          | _ ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Quickcheck.Generator.of_list [ Sgn.Pos; Neg ] )","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"      | _, None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Quickcheck.Generator.of_list [ Sgn.Pos; Neg ]","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"  in","counters":[]},{"line":"  (* if negative, magnitude constrained to balance in account","counters":[]},{"line":"     the effective balance is what's in the account state table,","counters":[]},{"line":"  *)","counters":[]},{"line":"  let effective_balance = account.balance in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let small_balance_change =","counters":[]},{"line":"    (*make small transfers to allow generating large number of zkapp_command without an overflow*)","counters":[]},{"line":"    let open Currency in","counters":[]},{"line":"    if","counters":[]},{"line":"      Balance.(effective_balance < of_formatted_string \"1.0\") && not new_account","counters":[{"col_start":53,"col_end":53,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"    then failwith \"account has low balance\"","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"    else Balance.of_formatted_string \"0.000001\"","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%map (magnitude : Currency.Amount.t) =","counters":[]},{"line":"    if new_account then","counters":[]},{"line":"      Currency.Amount.gen_incl","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"        (Currency.Amount.of_formatted_string \"50.0\")","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"        (Currency.Amount.of_formatted_string \"100.0\")","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"    else","counters":[]},{"line":"      Currency.Amount.gen_incl Currency.Amount.zero","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"        (Currency.Balance.to_amount small_balance_change)","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"  in","counters":[]},{"line":"  match sgn with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | Pos ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ({ magnitude; sgn = Sgn.Pos } : Currency.Amount.Signed.t)","counters":[]},{"line":"  | Neg ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ({ magnitude; sgn = Sgn.Neg } : Currency.Amount.Signed.t)","counters":[]},{"line":"","counters":[]},{"line":"let gen_use_full_commitment ~increment_nonce ~account_precondition","counters":[]},{"line":"    ~authorization () : bool Base_quickcheck.Generator.t =","counters":[]},{"line":"  (* check conditions to avoid replays*)","counters":[]},{"line":"  let incr_nonce_and_constrains_nonce =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    increment_nonce","counters":[]},{"line":"    && Zkapp_precondition.Numeric.is_constant","counters":[{"col_start":7,"col_end":7,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"         Zkapp_precondition.Numeric.Tc.nonce","counters":[]},{"line":"         (Account_update.Account_precondition.to_full account_precondition)","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"           .Zkapp_precondition.Account.nonce","counters":[]},{"line":"  in","counters":[]},{"line":"  let does_not_use_a_signature =","counters":[]},{"line":"    Control.(not (Tag.equal (tag authorization) Tag.Signature))","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"  in","counters":[]},{"line":"  if incr_nonce_and_constrains_nonce || does_not_use_a_signature then","counters":[{"col_start":35,"col_end":35,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"    Bool.quickcheck_generator","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  else Quickcheck.Generator.return true","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"","counters":[]},{"line":"let closed_interval_exact value =","counters":[]},{"line":"  Zkapp_precondition.Closed_interval.{ lower = value; upper = value }","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let gen_epoch_data_predicate","counters":[]},{"line":"    (epoch_data :","counters":[]},{"line":"      ( ( Frozen_ledger_hash.Stable.V1.t","counters":[]},{"line":"        , Currency.Amount.Stable.V1.t )","counters":[]},{"line":"        Epoch_ledger.Poly.Stable.V1.t","counters":[]},{"line":"      , Epoch_seed.Stable.V1.t","counters":[]},{"line":"      , State_hash.Stable.V1.t","counters":[]},{"line":"      , State_hash.Stable.V1.t","counters":[]},{"line":"      , Mina_numbers.Length.Stable.V1.t )","counters":[]},{"line":"      Zkapp_precondition.Protocol_state.Epoch_data.Poly.t ) :","counters":[]},{"line":"    Zkapp_precondition.Protocol_state.Epoch_data.t Base_quickcheck.Generator.t =","counters":[]},{"line":"  let open Quickcheck.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%bind ledger =","counters":[]},{"line":"    let%bind hash =","counters":[]},{"line":"      Zkapp_basic.Or_ignore.gen @@ return epoch_data.ledger.hash","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"    in","counters":[]},{"line":"    let%map total_currency =","counters":[]},{"line":"      closed_interval_exact epoch_data.ledger.total_currency","counters":[]},{"line":"      |> return |> Zkapp_basic.Or_ignore.gen","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"    in","counters":[]},{"line":"    { Epoch_ledger.Poly.hash; total_currency }","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%bind seed = Zkapp_basic.Or_ignore.gen @@ return epoch_data.seed in","counters":[{"col_start":42,"col_end":42,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"  let%bind start_checkpoint =","counters":[]},{"line":"    Zkapp_basic.Or_ignore.gen @@ return epoch_data.start_checkpoint","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%bind lock_checkpoint =","counters":[]},{"line":"    Zkapp_basic.Or_ignore.gen @@ return epoch_data.lock_checkpoint","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%map epoch_length =","counters":[]},{"line":"    let open Mina_numbers in","counters":[]},{"line":"    let%bind epsilon1 = Length.gen_incl (Length.of_int 0) (Length.of_int 10) in","counters":[{"col_start":38,"col_end":38,"count":0},{"col_start":53,"col_end":53,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"    let%bind epsilon2 = Length.gen_incl (Length.of_int 0) (Length.of_int 10) in","counters":[{"col_start":38,"col_end":38,"count":0},{"col_start":53,"col_end":53,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"    Zkapp_precondition.Closed_interval.","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      { lower =","counters":[]},{"line":"          Length.sub epoch_data.epoch_length epsilon1","counters":[]},{"line":"          |> Option.value ~default:Length.zero","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"      ; upper = Length.add epoch_data.epoch_length epsilon2","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"      }","counters":[]},{"line":"    |> return |> Zkapp_basic.Or_ignore.gen","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"  in","counters":[]},{"line":"  { Epoch_data.Poly.ledger","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  ; seed","counters":[]},{"line":"  ; start_checkpoint","counters":[]},{"line":"  ; lock_checkpoint","counters":[]},{"line":"  ; epoch_length","counters":[]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"let gen_protocol_state_precondition","counters":[]},{"line":"    (psv : Zkapp_precondition.Protocol_state.View.t) :","counters":[]},{"line":"    Zkapp_precondition.Protocol_state.t Base_quickcheck.Generator.t =","counters":[]},{"line":"  let open Quickcheck.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let open Zkapp_precondition.Closed_interval in","counters":[]},{"line":"  let%bind snarked_ledger_hash =","counters":[]},{"line":"    Zkapp_basic.Or_ignore.gen @@ return psv.snarked_ledger_hash","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%bind timestamp =","counters":[]},{"line":"    let%bind epsilon1 =","counters":[]},{"line":"      Int64.gen_incl 0L 60_000_000L >>| Block_time.Span.of_ms","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"    in","counters":[]},{"line":"    let%bind epsilon2 =","counters":[]},{"line":"      Int64.gen_incl 0L 60_000_000L >>| Block_time.Span.of_ms","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"    in","counters":[]},{"line":"    { lower = Block_time.sub psv.timestamp epsilon1","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"    ; upper = Block_time.add psv.timestamp epsilon2","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"    }","counters":[]},{"line":"    |> return |> Zkapp_basic.Or_ignore.gen","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%bind blockchain_length =","counters":[]},{"line":"    let open Mina_numbers in","counters":[]},{"line":"    let%bind epsilon1 = Length.gen_incl (Length.of_int 0) (Length.of_int 10) in","counters":[{"col_start":38,"col_end":38,"count":0},{"col_start":53,"col_end":53,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"    let%bind epsilon2 = Length.gen_incl (Length.of_int 0) (Length.of_int 10) in","counters":[{"col_start":38,"col_end":38,"count":0},{"col_start":53,"col_end":53,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"    { lower =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        Length.sub psv.blockchain_length epsilon1","counters":[]},{"line":"        |> Option.value ~default:Length.zero","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"    ; upper = Length.add psv.blockchain_length epsilon2","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"    }","counters":[]},{"line":"    |> return |> Zkapp_basic.Or_ignore.gen","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%bind min_window_density =","counters":[]},{"line":"    let open Mina_numbers in","counters":[]},{"line":"    let%bind epsilon1 = Length.gen_incl (Length.of_int 0) (Length.of_int 10) in","counters":[{"col_start":38,"col_end":38,"count":0},{"col_start":53,"col_end":53,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"    let%bind epsilon2 = Length.gen_incl (Length.of_int 0) (Length.of_int 10) in","counters":[{"col_start":38,"col_end":38,"count":0},{"col_start":53,"col_end":53,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"    { lower =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        Length.sub psv.min_window_density epsilon1","counters":[]},{"line":"        |> Option.value ~default:Length.zero","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"    ; upper = Length.add psv.min_window_density epsilon2","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"    }","counters":[]},{"line":"    |> return |> Zkapp_basic.Or_ignore.gen","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%bind total_currency =","counters":[]},{"line":"    let open Currency in","counters":[]},{"line":"    let%bind epsilon1 =","counters":[]},{"line":"      Amount.gen_incl (Amount.of_int 0) (Amount.of_int 1_000_000_000)","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"    in","counters":[]},{"line":"    let%bind epsilon2 =","counters":[]},{"line":"      Amount.gen_incl (Amount.of_int 0) (Amount.of_int 1_000_000_000)","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"    in","counters":[]},{"line":"    { lower =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        Amount.sub psv.total_currency epsilon1","counters":[]},{"line":"        |> Option.value ~default:Amount.zero","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"    ; upper =","counters":[]},{"line":"        Amount.add psv.total_currency epsilon2","counters":[]},{"line":"        |> Option.value ~default:psv.total_currency","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"    }","counters":[]},{"line":"    |> return |> Zkapp_basic.Or_ignore.gen","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%bind global_slot_since_hard_fork =","counters":[]},{"line":"    let open Mina_numbers in","counters":[]},{"line":"    let%bind epsilon1 =","counters":[]},{"line":"      Global_slot.gen_incl (Global_slot.of_int 0) (Global_slot.of_int 10)","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"    in","counters":[]},{"line":"    let%bind epsilon2 =","counters":[]},{"line":"      Global_slot.gen_incl (Global_slot.of_int 0) (Global_slot.of_int 10)","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"    in","counters":[]},{"line":"    { lower =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        Global_slot.sub psv.global_slot_since_hard_fork epsilon1","counters":[]},{"line":"        |> Option.value ~default:Global_slot.zero","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"    ; upper = Global_slot.add psv.global_slot_since_hard_fork epsilon2","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"    }","counters":[]},{"line":"    |> return |> Zkapp_basic.Or_ignore.gen","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%bind global_slot_since_genesis =","counters":[]},{"line":"    let open Mina_numbers in","counters":[]},{"line":"    let%bind epsilon1 =","counters":[]},{"line":"      Global_slot.gen_incl (Global_slot.of_int 0) (Global_slot.of_int 10)","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"    in","counters":[]},{"line":"    let%bind epsilon2 =","counters":[]},{"line":"      Global_slot.gen_incl (Global_slot.of_int 0) (Global_slot.of_int 10)","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"    in","counters":[]},{"line":"    { lower =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        Global_slot.sub psv.global_slot_since_genesis epsilon1","counters":[]},{"line":"        |> Option.value ~default:Global_slot.zero","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"    ; upper = Global_slot.add psv.global_slot_since_genesis epsilon2","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"    }","counters":[]},{"line":"    |> return |> Zkapp_basic.Or_ignore.gen","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%bind staking_epoch_data =","counters":[]},{"line":"    gen_epoch_data_predicate psv.staking_epoch_data","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%map next_epoch_data = gen_epoch_data_predicate psv.next_epoch_data in","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"  { Zkapp_precondition.Protocol_state.Poly.snarked_ledger_hash","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  ; timestamp","counters":[]},{"line":"  ; blockchain_length","counters":[]},{"line":"  ; min_window_density","counters":[]},{"line":"  ; last_vrf_output = ()","counters":[]},{"line":"  ; total_currency","counters":[]},{"line":"  ; global_slot_since_hard_fork","counters":[]},{"line":"  ; global_slot_since_genesis","counters":[]},{"line":"  ; staking_epoch_data","counters":[]},{"line":"  ; next_epoch_data","counters":[]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"let gen_invalid_protocol_state_precondition","counters":[]},{"line":"    (psv : Zkapp_precondition.Protocol_state.View.t) :","counters":[]},{"line":"    Zkapp_precondition.Protocol_state.t Base_quickcheck.Generator.t =","counters":[]},{"line":"  let module Tamperable = struct","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    type t =","counters":[]},{"line":"      | Timestamp","counters":[]},{"line":"      | Blockchain_length","counters":[]},{"line":"      | Min_window_density","counters":[]},{"line":"      | Total_currency","counters":[]},{"line":"      | Global_slot_since_hard_fork","counters":[]},{"line":"      | Global_slot_since_genesis","counters":[]},{"line":"  end in","counters":[]},{"line":"  let open Quickcheck.Let_syntax in","counters":[]},{"line":"  let open Zkapp_precondition.Closed_interval in","counters":[]},{"line":"  let protocol_state_precondition = Zkapp_precondition.Protocol_state.accept in","counters":[]},{"line":"  let%bind lower = Bool.quickcheck_generator in","counters":[]},{"line":"  match%bind","counters":[]},{"line":"    Quickcheck.Generator.of_list","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"      ( [ Timestamp","counters":[]},{"line":"        ; Blockchain_length","counters":[]},{"line":"        ; Min_window_density","counters":[]},{"line":"        ; Total_currency","counters":[]},{"line":"        ; Global_slot_since_hard_fork","counters":[]},{"line":"        ; Global_slot_since_genesis","counters":[]},{"line":"        ]","counters":[]},{"line":"        : Tamperable.t list )","counters":[]},{"line":"  with","counters":[]},{"line":"  | Timestamp ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let%map timestamp =","counters":[]},{"line":"        let%map epsilon =","counters":[]},{"line":"          Int64.gen_incl 1_000_000L 60_000_000L >>| Block_time.Span.of_ms","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"        in","counters":[]},{"line":"        if lower || Block_time.(psv.timestamp > add zero epsilon) then","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":50,"col_end":50,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"          { lower = Block_time.zero","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          ; upper = Block_time.sub psv.timestamp epsilon","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"          }","counters":[]},{"line":"        else","counters":[]},{"line":"          { lower = Block_time.add psv.timestamp epsilon","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"          ; upper = Block_time.max_value","counters":[]},{"line":"          }","counters":[]},{"line":"      in","counters":[]},{"line":"      { protocol_state_precondition with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        timestamp = Zkapp_basic.Or_ignore.Check timestamp","counters":[]},{"line":"      }","counters":[]},{"line":"  | Blockchain_length ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let open Mina_numbers in","counters":[]},{"line":"      let%map blockchain_length =","counters":[]},{"line":"        let%map epsilon = Length.(gen_incl (of_int 1) (of_int 10)) in","counters":[{"col_start":41,"col_end":41,"count":0},{"col_start":49,"col_end":49,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"        if lower || Length.(psv.blockchain_length > epsilon) then","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"          { lower = Length.zero","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          ; upper =","counters":[]},{"line":"              Length.sub psv.blockchain_length epsilon","counters":[]},{"line":"              |> Option.value ~default:Length.zero","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"          }","counters":[]},{"line":"        else","counters":[]},{"line":"          { lower = Length.add psv.blockchain_length epsilon","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"          ; upper = Length.max_value","counters":[]},{"line":"          }","counters":[]},{"line":"      in","counters":[]},{"line":"      { protocol_state_precondition with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        blockchain_length = Zkapp_basic.Or_ignore.Check blockchain_length","counters":[]},{"line":"      }","counters":[]},{"line":"  | Min_window_density ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let open Mina_numbers in","counters":[]},{"line":"      let%map min_window_density =","counters":[]},{"line":"        let%map epsilon = Length.(gen_incl (of_int 1) (of_int 10)) in","counters":[{"col_start":41,"col_end":41,"count":0},{"col_start":49,"col_end":49,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"        if lower || Length.(psv.min_window_density > epsilon) then","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"          { lower = Length.zero","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          ; upper =","counters":[]},{"line":"              Length.sub psv.min_window_density epsilon","counters":[]},{"line":"              |> Option.value ~default:Length.zero","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"          }","counters":[]},{"line":"        else","counters":[]},{"line":"          { lower = Length.add psv.blockchain_length epsilon","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"          ; upper = Length.max_value","counters":[]},{"line":"          }","counters":[]},{"line":"      in","counters":[]},{"line":"      { protocol_state_precondition with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        min_window_density = Zkapp_basic.Or_ignore.Check min_window_density","counters":[]},{"line":"      }","counters":[]},{"line":"  | Total_currency ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let open Currency in","counters":[]},{"line":"      let%map total_currency =","counters":[]},{"line":"        let%map epsilon =","counters":[]},{"line":"          Amount.(gen_incl (of_int 1_000) (of_int 1_000_000_000))","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"        in","counters":[]},{"line":"        if lower || Amount.(psv.total_currency > epsilon) then","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"          { lower = Amount.zero","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          ; upper =","counters":[]},{"line":"              Amount.sub psv.total_currency epsilon","counters":[]},{"line":"              |> Option.value ~default:Amount.zero","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"          }","counters":[]},{"line":"        else","counters":[]},{"line":"          { lower =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              Amount.add psv.total_currency epsilon","counters":[]},{"line":"              |> Option.value ~default:Amount.max_int","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"          ; upper = Amount.max_int","counters":[]},{"line":"          }","counters":[]},{"line":"      in","counters":[]},{"line":"      { protocol_state_precondition with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        total_currency = Zkapp_basic.Or_ignore.Check total_currency","counters":[]},{"line":"      }","counters":[]},{"line":"  | Global_slot_since_hard_fork ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let open Mina_numbers in","counters":[]},{"line":"      let%map global_slot_since_hard_fork =","counters":[]},{"line":"        let%map epsilon = Global_slot.(gen_incl (of_int 1) (of_int 10)) in","counters":[{"col_start":46,"col_end":46,"count":0},{"col_start":54,"col_end":54,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"        if lower || Global_slot.(psv.global_slot_since_hard_fork > epsilon) then","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":74,"col_end":74,"count":0}]},{"line":"          { lower = Global_slot.zero","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          ; upper =","counters":[]},{"line":"              Global_slot.sub psv.global_slot_since_hard_fork epsilon","counters":[]},{"line":"              |> Option.value ~default:Global_slot.zero","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"          }","counters":[]},{"line":"        else","counters":[]},{"line":"          { lower = Global_slot.add psv.global_slot_since_hard_fork epsilon","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"          ; upper = Global_slot.max_value","counters":[]},{"line":"          }","counters":[]},{"line":"      in","counters":[]},{"line":"      { protocol_state_precondition with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        global_slot_since_hard_fork =","counters":[]},{"line":"          Zkapp_basic.Or_ignore.Check global_slot_since_hard_fork","counters":[]},{"line":"      }","counters":[]},{"line":"  | Global_slot_since_genesis ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let open Mina_numbers in","counters":[]},{"line":"      let%map global_slot_since_genesis =","counters":[]},{"line":"        let%map epsilon = Global_slot.(gen_incl (of_int 1) (of_int 10)) in","counters":[{"col_start":46,"col_end":46,"count":0},{"col_start":54,"col_end":54,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"        if lower || Global_slot.(psv.global_slot_since_genesis > epsilon) then","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":72,"col_end":72,"count":0}]},{"line":"          { lower = Global_slot.zero","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          ; upper =","counters":[]},{"line":"              Global_slot.sub psv.global_slot_since_genesis epsilon","counters":[]},{"line":"              |> Option.value ~default:Global_slot.zero","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"          }","counters":[]},{"line":"        else","counters":[]},{"line":"          { lower = Global_slot.add psv.global_slot_since_genesis epsilon","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"          ; upper = Global_slot.max_value","counters":[]},{"line":"          }","counters":[]},{"line":"      in","counters":[]},{"line":"      { protocol_state_precondition with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        global_slot_since_genesis =","counters":[]},{"line":"          Zkapp_basic.Or_ignore.Check global_slot_since_genesis","counters":[]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"module Account_update_body_components = struct","counters":[]},{"line":"  type ( 'pk","counters":[]},{"line":"       , 'update","counters":[]},{"line":"       , 'token_id","counters":[]},{"line":"       , 'amount","counters":[]},{"line":"       , 'events","counters":[]},{"line":"       , 'call_data","counters":[]},{"line":"       , 'int","counters":[]},{"line":"       , 'bool","counters":[]},{"line":"       , 'protocol_state_precondition","counters":[]},{"line":"       , 'account_precondition","counters":[]},{"line":"       , 'caller","counters":[]},{"line":"       , 'authorization_kind )","counters":[]},{"line":"       t =","counters":[]},{"line":"    { public_key : 'pk","counters":[]},{"line":"    ; update : 'update","counters":[]},{"line":"    ; token_id : 'token_id","counters":[]},{"line":"    ; balance_change : 'amount","counters":[]},{"line":"    ; increment_nonce : 'bool","counters":[]},{"line":"    ; events : 'events","counters":[]},{"line":"    ; sequence_events : 'events","counters":[]},{"line":"    ; call_data : 'call_data","counters":[]},{"line":"    ; call_depth : 'int","counters":[]},{"line":"    ; protocol_state_precondition : 'protocol_state_precondition","counters":[]},{"line":"    ; account_precondition : 'account_precondition","counters":[]},{"line":"    ; use_full_commitment : 'bool","counters":[]},{"line":"    ; caller : 'caller","counters":[]},{"line":"    ; authorization_kind : 'authorization_kind","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let to_fee_payer t : Account_update.Body.Fee_payer.t =","counters":[]},{"line":"    { public_key = t.public_key","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    ; fee = t.balance_change","counters":[]},{"line":"    ; valid_until =","counters":[]},{"line":"        ( match","counters":[]},{"line":"            t.protocol_state_precondition","counters":[]},{"line":"              .Zkapp_precondition.Protocol_state.Poly.global_slot_since_genesis","counters":[]},{"line":"          with","counters":[]},{"line":"        | Zkapp_basic.Or_ignore.Ignore ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            None","counters":[]},{"line":"        | Zkapp_basic.Or_ignore.Check","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            { Zkapp_precondition.Closed_interval.upper; _ } ->","counters":[]},{"line":"            Some upper )","counters":[]},{"line":"    ; nonce = t.account_precondition","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let to_typical_account_update t : Account_update.Body.Simple.t =","counters":[]},{"line":"    { public_key = t.public_key","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    ; update = t.update","counters":[]},{"line":"    ; token_id = t.token_id","counters":[]},{"line":"    ; balance_change = t.balance_change","counters":[]},{"line":"    ; increment_nonce = t.increment_nonce","counters":[]},{"line":"    ; events = t.events","counters":[]},{"line":"    ; sequence_events = t.sequence_events","counters":[]},{"line":"    ; call_data = t.call_data","counters":[]},{"line":"    ; call_depth = t.call_depth","counters":[]},{"line":"    ; preconditions =","counters":[]},{"line":"        { Account_update.Preconditions.network = t.protocol_state_precondition","counters":[]},{"line":"        ; account = t.account_precondition","counters":[]},{"line":"        }","counters":[]},{"line":"    ; use_full_commitment = t.use_full_commitment","counters":[]},{"line":"    ; caller = t.caller","counters":[]},{"line":"    ; authorization_kind = t.authorization_kind","counters":[]},{"line":"    }","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(* The type `a` is associated with the `delta` field, which is an unsigned fee","counters":[]},{"line":"   for the fee payer, and a signed amount for other zkapp_command.","counters":[]},{"line":"   The type `b` is associated with the `use_full_commitment` field, which is","counters":[]},{"line":"   `unit` for the fee payer, and `bool` for other zkapp_command.","counters":[]},{"line":"   The type `c` is associated with the `token_id` field, which is `unit` for the","counters":[]},{"line":"   fee payer, and `Token_id.t` for other zkapp_command.","counters":[]},{"line":"   The type `d` is associated with the `account_precondition` field, which is","counters":[]},{"line":"   a nonce for the fee payer, and `Account_precondition.t` for other zkapp_command","counters":[]},{"line":"*)","counters":[]},{"line":"let gen_account_update_body_components (type a b c d) ?(update = None)","counters":[{"col_start":65,"col_end":65,"count":0}]},{"line":"    ?account_id ?token_id ?caller ?account_ids_seen ~account_state_tbl ?vk","counters":[]},{"line":"    ?failure ?(new_account = false) ?(zkapp_account = false)","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"    ?(is_fee_payer = false) ?available_public_keys ?permissions_auth","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"    ?(required_balance_change : a option) ?protocol_state_view","counters":[]},{"line":"    ~zkapp_account_ids","counters":[]},{"line":"    ~(gen_balance_change : Account.t -> a Quickcheck.Generator.t)","counters":[]},{"line":"    ~(gen_use_full_commitment :","counters":[]},{"line":"          account_precondition:Account_update.Account_precondition.t","counters":[]},{"line":"       -> b Quickcheck.Generator.t )","counters":[]},{"line":"    ~(f_balance_change : a -> Currency.Amount.Signed.t)","counters":[]},{"line":"    ~(increment_nonce : b * bool) ~(f_token_id : Token_id.t -> c)","counters":[]},{"line":"    ~(f_account_precondition :","counters":[]},{"line":"       first_use_of_account:bool -> Account.t -> d Quickcheck.Generator.t )","counters":[]},{"line":"    ~(f_account_update_account_precondition :","counters":[]},{"line":"       d -> Account_update.Account_precondition.t ) ~authorization_tag () :","counters":[]},{"line":"    (_, _, _, a, _, _, _, b, _, d, _, _) Account_update_body_components.t","counters":[]},{"line":"    Quickcheck.Generator.t =","counters":[]},{"line":"  let open Quickcheck.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  (* fee payers have to be in the ledger *)","counters":[]},{"line":"  assert (not (is_fee_payer && new_account)) ;","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"  let token_account = match token_id with None -> false | Some _ -> true in","counters":[{"col_start":42,"col_end":42,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"  let%bind update =","counters":[]},{"line":"    match update with","counters":[]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Account_update.Update.gen ?permissions_auth ?vk ~zkapp_account","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"          ~token_account ()","counters":[]},{"line":"    | Some update ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        return update","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"  in","counters":[]},{"line":"  (* account_update_increment_nonce for fee payer is unit and increment_nonce is true *)","counters":[]},{"line":"  let account_update_increment_nonce, increment_nonce = increment_nonce in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let verification_key =","counters":[]},{"line":"    Option.value vk","counters":[]},{"line":"      ~default:","counters":[]},{"line":"        With_hash.","counters":[]},{"line":"          { data = Pickles.Side_loaded.Verification_key.dummy","counters":[]},{"line":"          ; hash = Zkapp_account.dummy_vk_hash ()","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"          }","counters":[]},{"line":"  in","counters":[]},{"line":"  let%bind account =","counters":[]},{"line":"    if new_account then (","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"      if Option.is_some account_id then","counters":[]},{"line":"        failwith","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          \"gen_account_update_body: new account_update is true, but an account \\","counters":[]},{"line":"           id, presumably from an existing account, was supplied\" ;","counters":[]},{"line":"      match available_public_keys with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          failwith","counters":[]},{"line":"            \"gen_account_update_body: new_account is true, but \\","counters":[]},{"line":"             available_public_keys not provided\"","counters":[]},{"line":"      | Some available_pks ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let available_pk =","counters":[]},{"line":"            match","counters":[]},{"line":"              Signature_lib.Public_key.Compressed.Table.choose available_pks","counters":[]},{"line":"            with","counters":[]},{"line":"            | None ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                failwith \"gen_account_update_body: no available public keys\"","counters":[]},{"line":"            | Some (pk, ()) ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                pk","counters":[]},{"line":"          in","counters":[]},{"line":"          (* available public key no longer available *)","counters":[]},{"line":"          Signature_lib.Public_key.Compressed.Table.remove available_pks","counters":[]},{"line":"            available_pk ;","counters":[]},{"line":"          let account_id =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            match token_id with","counters":[]},{"line":"            | Some custom_token_id ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Account_id.create available_pk custom_token_id","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"            | None ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Account_id.create available_pk Token_id.default","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"          in","counters":[]},{"line":"          let account_with_pk =","counters":[]},{"line":"            Account.create account_id (Currency.Balance.of_int 0)","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"          in","counters":[]},{"line":"          let account =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            if zkapp_account then","counters":[]},{"line":"              { account_with_pk with","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                zkapp =","counters":[]},{"line":"                  Some","counters":[]},{"line":"                    { Zkapp_account.default with","counters":[]},{"line":"                      verification_key = Some verification_key","counters":[]},{"line":"                    }","counters":[]},{"line":"              }","counters":[]},{"line":"            else account_with_pk","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"          in","counters":[]},{"line":"          return account )","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"    else","counters":[]},{"line":"      match account_id with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          if zkapp_account then","counters":[]},{"line":"            let%map zkapp_account_id =","counters":[]},{"line":"              Quickcheck.Generator.of_list zkapp_account_ids","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"            in","counters":[]},{"line":"            match Account_id.Table.find account_state_tbl zkapp_account_id with","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            | None ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                failwith \"gen_account_update_body: fail to find zkapp account\"","counters":[]},{"line":"            | Some (_, `Fee_payer)","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"            | Some (_, `New_account)","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"            | Some (_, `New_token_account) ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                failwith","counters":[]},{"line":"                  \"gen_account_update_body: all zkapp accounts were new \\","counters":[]},{"line":"                   accounts or used as fee_payer accounts\"","counters":[]},{"line":"            | Some (acct, `Ordinary_participant) ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                acct","counters":[]},{"line":"          else","counters":[]},{"line":"            let accts =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Account_id.Table.filteri account_state_tbl","counters":[]},{"line":"                ~f:(fun ~key:_ ~data:(_, role) ->","counters":[]},{"line":"                  match (authorization_tag, role) with","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  | _, `Fee_payer ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      false","counters":[]},{"line":"                  | Control.Tag.Proof, `New_account ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      false","counters":[]},{"line":"                  | _, `New_token_account ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      false","counters":[]},{"line":"                  | _, `New_account ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      (* `required_balance_change` is only for balancing account_update. Newly created account","counters":[]},{"line":"                         should not be used in balancing account_update *)","counters":[]},{"line":"                      Option.is_none required_balance_change","counters":[]},{"line":"                  | _, `Ordinary_participant ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      true )","counters":[]},{"line":"              |> Account_id.Table.data","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"            in","counters":[]},{"line":"            Quickcheck.Generator.of_list accts >>| fst","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"      | Some account_id ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (*get the latest state of the account*)","counters":[]},{"line":"          let acct =","counters":[]},{"line":"            Account_id.Table.find_exn account_state_tbl account_id |> fst","counters":[{"col_start":70,"col_end":70,"count":0}]},{"line":"          in","counters":[]},{"line":"          if zkapp_account && Option.is_none acct.zkapp then","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"            failwith","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              \"gen_account_update_body: provided account has no zkapp field\" ;","counters":[]},{"line":"          return acct","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"  in","counters":[]},{"line":"  let public_key = account.public_key in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let token_id = account.token_id in","counters":[]},{"line":"  let%bind balance_change =","counters":[]},{"line":"    match required_balance_change with","counters":[]},{"line":"    | Some bal_change ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        return bal_change","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        gen_balance_change account","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"  in","counters":[]},{"line":"  let field_array_list_gen ~max_array_len ~max_list_len =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    let array_gen =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let%bind array_len = Int.gen_uniform_incl 0 max_array_len in","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"      let%map fields =","counters":[]},{"line":"        Quickcheck.Generator.list_with_length array_len","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"          Snark_params.Tick.Field.gen","counters":[]},{"line":"      in","counters":[]},{"line":"      Array.of_list fields","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    in","counters":[]},{"line":"    let%bind list_len = Int.gen_uniform_incl 0 max_list_len in","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"    Quickcheck.Generator.list_with_length list_len array_gen","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%bind events = field_array_list_gen ~max_array_len:2 ~max_list_len:1 in","counters":[]},{"line":"  let%bind sequence_events =","counters":[]},{"line":"    field_array_list_gen ~max_array_len:2 ~max_list_len:1","counters":[]},{"line":"  in","counters":[]},{"line":"  let%bind call_data = Snark_params.Tick.Field.gen in","counters":[]},{"line":"  let first_use_of_account =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    let account_id = Account_id.create public_key token_id in","counters":[]},{"line":"    match account_ids_seen with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (* fee payer *)","counters":[]},{"line":"        true","counters":[]},{"line":"    | Some hash_set ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (* other account_updates *)","counters":[]},{"line":"        not @@ Hash_set.mem hash_set account_id","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%bind account_precondition =","counters":[]},{"line":"    f_account_precondition ~first_use_of_account account","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"  in","counters":[]},{"line":"  (* update the depth when generating `account_updates` in Zkapp_command.t *)","counters":[]},{"line":"  let call_depth = 0 in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%bind use_full_commitment =","counters":[]},{"line":"    let full_account_precondition =","counters":[]},{"line":"      f_account_update_account_precondition account_precondition","counters":[]},{"line":"    in","counters":[]},{"line":"    gen_use_full_commitment ~account_precondition:full_account_precondition","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%map protocol_state_precondition =","counters":[]},{"line":"    Option.value_map protocol_state_view","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"      ~f:","counters":[]},{"line":"        ( match failure with","counters":[]},{"line":"        | Some Invalid_protocol_state_precondition ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            gen_invalid_protocol_state_precondition","counters":[]},{"line":"        | _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            gen_protocol_state_precondition )","counters":[]},{"line":"      ~default:(return Zkapp_precondition.Protocol_state.accept)","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"  and caller =","counters":[]},{"line":"    match caller with","counters":[]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Account_update.Call_type.quickcheck_generator","counters":[]},{"line":"    | Some caller ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        return caller","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"  in","counters":[]},{"line":"  let token_id = f_token_id token_id in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let authorization_kind =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    match authorization_tag with","counters":[]},{"line":"    | Control.Tag.None_given ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Account_update.Authorization_kind.None_given","counters":[]},{"line":"    | Signature ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Signature","counters":[]},{"line":"    | Proof ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Proof","counters":[]},{"line":"  in","counters":[]},{"line":"  (* update account state table with all the changes*)","counters":[]},{"line":"  (let add_balance_and_balance_change balance","counters":[]},{"line":"       (balance_change : (Currency.Amount.t, Sgn.t) Currency.Signed_poly.t) =","counters":[]},{"line":"     match balance_change.sgn with","counters":[{"col_start":5,"col_end":5,"count":0}]},{"line":"     | Pos -> (","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"         match Currency.Balance.add_amount balance balance_change.magnitude with","counters":[]},{"line":"         | Some bal ->","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"             bal","counters":[]},{"line":"         | None ->","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"             failwith \"add_balance_and_balance_change: overflow for sum\" )","counters":[]},{"line":"     | Neg -> (","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"         match Currency.Balance.sub_amount balance balance_change.magnitude with","counters":[]},{"line":"         | Some bal ->","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"             bal","counters":[]},{"line":"         | None ->","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"             failwith \"add_balance_and_balance_change: underflow for difference\"","counters":[]},{"line":"         )","counters":[]},{"line":"   in","counters":[]},{"line":"   let balance_change = f_balance_change balance_change in","counters":[]},{"line":"   let nonce_incr n = if increment_nonce then Account.Nonce.succ n else n in","counters":[{"col_start":3,"col_end":3,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":46,"col_end":46,"count":0},{"col_start":72,"col_end":72,"count":0}]},{"line":"   let value_to_be_updated (type a) (c : a Zkapp_basic.Set_or_keep.t)","counters":[]},{"line":"       ~(default : a) : a =","counters":[]},{"line":"     match c with Zkapp_basic.Set_or_keep.Set x -> x | Keep -> default","counters":[{"col_start":5,"col_end":5,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"   in","counters":[]},{"line":"   let delegate (account : Account.t) =","counters":[]},{"line":"     if is_fee_payer then account.delegate","counters":[{"col_start":5,"col_end":5,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"     else","counters":[]},{"line":"       Option.map","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"         ~f:(fun delegate ->","counters":[]},{"line":"           value_to_be_updated update.delegate ~default:delegate )","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"         account.delegate","counters":[]},{"line":"   in","counters":[]},{"line":"   let zkapp (account : Account.t) =","counters":[]},{"line":"     if is_fee_payer then account.zkapp","counters":[{"col_start":5,"col_end":5,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"     else","counters":[]},{"line":"       match account.zkapp with","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"       | None ->","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"           None","counters":[]},{"line":"       | Some zk ->","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"           let app_state =","counters":[]},{"line":"             let account_app_state = zk.app_state in","counters":[]},{"line":"             List.zip_exn","counters":[]},{"line":"               (Zkapp_state.V.to_list update.app_state)","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"               (Zkapp_state.V.to_list account_app_state)","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"             |> List.map ~f:(fun (to_be_updated, current) ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                    value_to_be_updated to_be_updated ~default:current )","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"             |> Zkapp_state.V.of_list_exn","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"           in","counters":[]},{"line":"           let sequence_state =","counters":[]},{"line":"             let last_sequence_slot = zk.last_sequence_slot in","counters":[]},{"line":"             let txn_global_slot =","counters":[]},{"line":"               Option.value_map protocol_state_view ~default:last_sequence_slot","counters":[]},{"line":"                 ~f:(fun ps ->","counters":[]},{"line":"                   ps","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"                     .Zkapp_precondition.Protocol_state.Poly","counters":[]},{"line":"                      .global_slot_since_genesis )","counters":[]},{"line":"             in","counters":[]},{"line":"             let sequence_state, _last_sequence_slot =","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"               Mina_ledger.Ledger.update_sequence_state zk.sequence_state","counters":[]},{"line":"                 sequence_events ~txn_global_slot ~last_sequence_slot","counters":[]},{"line":"             in","counters":[]},{"line":"             sequence_state","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"           in","counters":[]},{"line":"           let proved_state =","counters":[]},{"line":"             let keeping_app_state =","counters":[]},{"line":"               List.for_all ~f:Fn.id","counters":[]},{"line":"                 (List.map ~f:Zkapp_basic.Set_or_keep.is_keep","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                    (Pickles_types.Vector.to_list update.app_state) )","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"             in","counters":[]},{"line":"             let changing_entire_app_state =","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"               List.for_all ~f:Fn.id","counters":[]},{"line":"                 (List.map ~f:Zkapp_basic.Set_or_keep.is_set","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                    (Pickles_types.Vector.to_list update.app_state) )","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"             in","counters":[]},{"line":"             let proof_verifies = Control.Tag.(equal Proof authorization_tag) in","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"             if keeping_app_state then zk.proved_state","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"             else if proof_verifies then","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"               if changing_entire_app_state then true else zk.proved_state","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":49,"col_end":49,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"             else false","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"           in","counters":[]},{"line":"           Some { zk with app_state; sequence_state; proved_state }","counters":[]},{"line":"   in","counters":[]},{"line":"   Account_id.Table.update account_state_tbl (Account.identifier account)","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"     ~f:(function","counters":[]},{"line":"     | None ->","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"         (* new entry in table *)","counters":[]},{"line":"         ( { account with","counters":[]},{"line":"             balance =","counters":[]},{"line":"               add_balance_and_balance_change account.balance balance_change","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"           ; nonce = nonce_incr account.nonce","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"           ; delegate = delegate account","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"           ; zkapp = zkapp account","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"           }","counters":[]},{"line":"         , if token_account then `New_token_account else `New_account )","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"     | Some (updated_account, role) ->","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"         (* update entry in table *)","counters":[]},{"line":"         ( { updated_account with","counters":[]},{"line":"             balance =","counters":[]},{"line":"               add_balance_and_balance_change updated_account.balance","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"                 balance_change","counters":[]},{"line":"           ; nonce = nonce_incr updated_account.nonce","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"           ; delegate = delegate updated_account","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"           ; zkapp = zkapp updated_account","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"           }","counters":[]},{"line":"         , role ) ) ) ;","counters":[]},{"line":"  { Account_update_body_components.public_key","counters":[]},{"line":"  ; update =","counters":[]},{"line":"      ( if new_account then","counters":[]},{"line":"        { update with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          verification_key = Zkapp_basic.Set_or_keep.Set verification_key","counters":[]},{"line":"        }","counters":[]},{"line":"      else update )","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"  ; token_id","counters":[]},{"line":"  ; balance_change","counters":[]},{"line":"  ; increment_nonce = account_update_increment_nonce","counters":[]},{"line":"  ; events","counters":[]},{"line":"  ; sequence_events","counters":[]},{"line":"  ; call_data","counters":[]},{"line":"  ; call_depth","counters":[]},{"line":"  ; protocol_state_precondition","counters":[]},{"line":"  ; account_precondition","counters":[]},{"line":"  ; use_full_commitment","counters":[]},{"line":"  ; caller","counters":[]},{"line":"  ; authorization_kind","counters":[]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"let gen_account_update_from ?(update = None) ?failure ?(new_account = false)","counters":[{"col_start":39,"col_end":39,"count":0},{"col_start":70,"col_end":70,"count":0}]},{"line":"    ?(zkapp_account = false) ?account_id ?token_id ?caller ?permissions_auth","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"    ?required_balance_change ~zkapp_account_ids ~authorization ~account_ids_seen","counters":[]},{"line":"    ~available_public_keys ~account_state_tbl ?protocol_state_view ?vk () =","counters":[]},{"line":"  let open Quickcheck.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let increment_nonce =","counters":[]},{"line":"    (* permissions_auth is used to generate updated permissions consistent with a contemplated authorization;","counters":[]},{"line":"       allow incrementing the nonce only if we know the authorization will be Signature","counters":[]},{"line":"    *)","counters":[]},{"line":"    match permissions_auth with","counters":[]},{"line":"    | Some tag -> (","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        match tag with","counters":[]},{"line":"        | Control.Tag.Signature ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            true","counters":[]},{"line":"        | Proof | None_given ->","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"            false )","counters":[]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        false","counters":[]},{"line":"  in","counters":[]},{"line":"  let%bind body_components =","counters":[]},{"line":"    gen_account_update_body_components ~update ?failure ~new_account","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"      ~zkapp_account","counters":[]},{"line":"      ~increment_nonce:(increment_nonce, increment_nonce)","counters":[]},{"line":"      ?permissions_auth ?account_id ?token_id ?caller ?protocol_state_view ?vk","counters":[]},{"line":"      ~zkapp_account_ids ~account_ids_seen ~available_public_keys","counters":[]},{"line":"      ?required_balance_change ~account_state_tbl","counters":[]},{"line":"      ~gen_balance_change:","counters":[]},{"line":"        (gen_balance_change ?permissions_auth ~new_account ?failure)","counters":[]},{"line":"      ~f_balance_change:Fn.id () ~f_token_id:Fn.id","counters":[]},{"line":"      ~f_account_precondition:(fun ~first_use_of_account acct ->","counters":[]},{"line":"        gen_account_precondition_from_account ~first_use_of_account acct )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      ~f_account_update_account_precondition:Fn.id","counters":[]},{"line":"      ~gen_use_full_commitment:(fun ~account_precondition ->","counters":[]},{"line":"        gen_use_full_commitment ~increment_nonce ~account_precondition","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ~authorization () )","counters":[]},{"line":"      ~authorization_tag:(Control.tag authorization)","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"  in","counters":[]},{"line":"  let body =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Account_update_body_components.to_typical_account_update body_components","counters":[]},{"line":"  in","counters":[]},{"line":"  let account_id = Account_id.create body.public_key body.token_id in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  Hash_set.add account_ids_seen account_id ;","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  return { Account_update.Simple.body; authorization }","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"(* takes an account id, if we want to sign this data *)","counters":[]},{"line":"let gen_account_update_body_fee_payer ?failure ?permissions_auth ~account_id ?vk","counters":[]},{"line":"    ?protocol_state_view ~account_state_tbl () :","counters":[]},{"line":"    Account_update.Body.Fee_payer.t Quickcheck.Generator.t =","counters":[]},{"line":"  let open Quickcheck.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let account_precondition_gen (account : Account.t) =","counters":[]},{"line":"    Quickcheck.Generator.return account.nonce","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%map body_components =","counters":[]},{"line":"    gen_account_update_body_components ?failure ?permissions_auth ~account_id","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"      ~account_state_tbl ?vk ~zkapp_account_ids:[] ~is_fee_payer:true","counters":[]},{"line":"      ~increment_nonce:((), true) ~gen_balance_change:gen_fee","counters":[]},{"line":"      ~f_balance_change:fee_to_amt","counters":[]},{"line":"      ~f_token_id:(fun token_id ->","counters":[]},{"line":"        (* make sure the fee payer's token id is the default,","counters":[]},{"line":"           which is represented by the unit value in the body","counters":[]},{"line":"        *)","counters":[]},{"line":"        assert (Token_id.equal token_id Token_id.default) ;","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"        () )","counters":[]},{"line":"      ~f_account_precondition:(fun ~first_use_of_account:_ acct ->","counters":[]},{"line":"        account_precondition_gen acct )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      ~f_account_update_account_precondition:(fun nonce -> Nonce nonce)","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"      ~gen_use_full_commitment:(fun ~account_precondition:_ -> return ())","counters":[{"col_start":63,"col_end":63,"count":0}]},{"line":"      ?protocol_state_view ~authorization_tag:Control.Tag.Signature ()","counters":[]},{"line":"  in","counters":[]},{"line":"  Account_update_body_components.to_fee_payer body_components","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let gen_fee_payer ?failure ?permissions_auth ~account_id ?protocol_state_view","counters":[]},{"line":"    ?vk ~account_state_tbl () :","counters":[]},{"line":"    Account_update.Fee_payer.t Quickcheck.Generator.t =","counters":[]},{"line":"  let open Quickcheck.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%map body =","counters":[]},{"line":"    gen_account_update_body_fee_payer ?failure ?permissions_auth ~account_id ?vk","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"      ?protocol_state_view ~account_state_tbl ()","counters":[]},{"line":"  in","counters":[]},{"line":"  (* real signature to be added when this data inserted into a Zkapp_command.t *)","counters":[]},{"line":"  let authorization = Signature.dummy in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  ({ body; authorization } : Account_update.Fee_payer.t)","counters":[]},{"line":"","counters":[]},{"line":"(* keep max_account_updates small, so zkApp integration tests don't need lots","counters":[]},{"line":"   of block producers","counters":[]},{"line":"","counters":[]},{"line":"   because the other zkapp_command are split into a permissions-setter","counters":[]},{"line":"   and another account_update, the actual number of other zkapp_command is","counters":[]},{"line":"   twice this value, plus one, for the \"balancing\" account_update","counters":[]},{"line":"","counters":[]},{"line":"   when we have separate transaction accounts in integration tests","counters":[]},{"line":"   this number can be increased","counters":[]},{"line":"*)","counters":[]},{"line":"let max_account_updates = 2","counters":[]},{"line":"","counters":[]},{"line":"let max_token_updates = 2","counters":[]},{"line":"","counters":[]},{"line":"let gen_zkapp_command_from ?failure ?(max_account_updates = max_account_updates)","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"    ?(max_token_updates = max_token_updates)","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"    ~(fee_payer_keypair : Signature_lib.Keypair.t)","counters":[]},{"line":"    ~(keymap :","counters":[]},{"line":"       Signature_lib.Private_key.t Signature_lib.Public_key.Compressed.Map.t )","counters":[]},{"line":"    ?account_state_tbl ~ledger ?protocol_state_view ?vk () =","counters":[]},{"line":"  let open Quickcheck.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let fee_payer_pk =","counters":[]},{"line":"    Signature_lib.Public_key.compress fee_payer_keypair.public_key","counters":[]},{"line":"  in","counters":[]},{"line":"  let fee_payer_acct_id = Account_id.create fee_payer_pk Token_id.default in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let ledger_accounts = Ledger.to_list ledger in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  (* table of public keys to accounts, updated when generating each account_update","counters":[]},{"line":"","counters":[]},{"line":"     a Map would be more principled, but threading that map through the code","counters":[]},{"line":"     adds complexity","counters":[]},{"line":"  *)","counters":[]},{"line":"  let account_state_tbl =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Option.value account_state_tbl ~default:(Account_id.Table.create ())","counters":[{"col_start":67,"col_end":67,"count":0}]},{"line":"  in","counters":[]},{"line":"  (* make sure all ledger keys are in the keymap *)","counters":[]},{"line":"  List.iter ledger_accounts ~f:(fun acct ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      let acct_id = Account.identifier acct in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let pk = Account_id.public_key acct_id in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      (*Initialize account states*)","counters":[]},{"line":"      Account_id.Table.update account_state_tbl acct_id ~f:(function","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            if Account_id.equal acct_id fee_payer_acct_id then (acct, `Fee_payer)","counters":[{"col_start":63,"col_end":63,"count":0}]},{"line":"            else (acct, `Ordinary_participant)","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"        | Some a ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            a ) ;","counters":[]},{"line":"      if Option.is_none (Signature_lib.Public_key.Compressed.Map.find keymap pk)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"      then","counters":[]},{"line":"        failwithf","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          \"gen_zkapp_command_from: public key %s is in ledger, but not keymap\"","counters":[]},{"line":"          (Signature_lib.Public_key.Compressed.to_base58_check pk)","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"          () ) ;","counters":[]},{"line":"  (* table of public keys not in the ledger, to be used for new zkapp_command","counters":[]},{"line":"     we have the corresponding private keys, so we can create signatures for those new zkapp_command","counters":[]},{"line":"  *)","counters":[]},{"line":"  let ledger_account_list =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Account_id.Set.union_list","counters":[]},{"line":"      [ Ledger.accounts ledger","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"      ; Account_id.Set.of_hashtbl_keys account_state_tbl","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"      ]","counters":[]},{"line":"    |> Account_id.Set.to_list","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"  in","counters":[]},{"line":"  let ledger_pk_list =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    List.map ledger_account_list ~f:(fun account_id ->","counters":[]},{"line":"        Account_id.public_key account_id )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"  in","counters":[]},{"line":"  let ledger_pk_set =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Signature_lib.Public_key.Compressed.Set.of_list ledger_pk_list","counters":[]},{"line":"  in","counters":[]},{"line":"  let available_public_keys =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    let tbl = Signature_lib.Public_key.Compressed.Table.create () in","counters":[]},{"line":"    Signature_lib.Public_key.Compressed.Map.iter_keys keymap ~f:(fun pk ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        if not (Signature_lib.Public_key.Compressed.Set.mem ledger_pk_set pk)","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"        then","counters":[]},{"line":"          Signature_lib.Public_key.Compressed.Table.add_exn tbl ~key:pk ~data:() ) ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    tbl","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  in","counters":[]},{"line":"  (* account ids seen, to generate receipt chain hash precondition only if","counters":[]},{"line":"     a account_update with a given account id has not been encountered before","counters":[]},{"line":"  *)","counters":[]},{"line":"  let account_ids_seen = Account_id.Hash_set.create () in","counters":[]},{"line":"  let%bind fee_payer =","counters":[]},{"line":"    gen_fee_payer ?failure ~permissions_auth:Control.Tag.Signature","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"      ~account_id:fee_payer_acct_id ?vk ~account_state_tbl ()","counters":[]},{"line":"  in","counters":[]},{"line":"  let zkapp_account_ids =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Account_id.Table.filteri account_state_tbl ~f:(fun ~key:_ ~data:(a, role) ->","counters":[]},{"line":"        match role with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | `Fee_payer | `New_account | `New_token_account ->","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"            false","counters":[]},{"line":"        | `Ordinary_participant ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Option.is_some a.zkapp )","counters":[]},{"line":"    |> Account_id.Table.keys","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"  in","counters":[]},{"line":"  Hash_set.add account_ids_seen fee_payer_acct_id ;","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let mk_forest ps =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    List.map ps ~f:(fun p -> { With_stack_hash.elt = p; stack_hash = () })","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"  in","counters":[]},{"line":"  let mk_node p calls =","counters":[]},{"line":"    { Zkapp_command.Call_forest.Tree.account_update = p","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    ; account_update_digest = ()","counters":[]},{"line":"    ; calls = mk_forest calls","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"    }","counters":[]},{"line":"  in","counters":[]},{"line":"  let gen_zkapp_command_with_dynamic_balance ~new_account num_zkapp_command =","counters":[]},{"line":"    let rec go acc n =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let open Zkapp_basic in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let open Permissions in","counters":[]},{"line":"      if n <= 0 then return (List.rev acc)","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"      else","counters":[]},{"line":"        (* choose a random authorization","counters":[]},{"line":"","counters":[]},{"line":"           first Account_update.t updates the permissions, using the Signature authorization,","counters":[]},{"line":"            according the random authorization","counters":[]},{"line":"","counters":[]},{"line":"           second Account_update.t uses the random authorization","counters":[]},{"line":"        *)","counters":[]},{"line":"        let%bind permissions_auth, update =","counters":[]},{"line":"          match failure with","counters":[]},{"line":"          | Some (Update_not_permitted update_type) ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let%bind is_proof = Bool.quickcheck_generator in","counters":[]},{"line":"              let auth_tag =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                if is_proof then Control.Tag.Proof else Control.Tag.Signature","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"              in","counters":[]},{"line":"              let%map perm = Permissions.gen ~auth_tag in","counters":[]},{"line":"              let update =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                match update_type with","counters":[]},{"line":"                | `Delegate ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    { Account_update.Update.dummy with","counters":[]},{"line":"                      permissions =","counters":[]},{"line":"                        Set_or_keep.Set","counters":[]},{"line":"                          { perm with","counters":[]},{"line":"                            set_delegate = Auth_required.from ~auth_tag","counters":[]},{"line":"                          }","counters":[]},{"line":"                    }","counters":[]},{"line":"                | `App_state ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    { Account_update.Update.dummy with","counters":[]},{"line":"                      permissions =","counters":[]},{"line":"                        Set_or_keep.Set","counters":[]},{"line":"                          { perm with","counters":[]},{"line":"                            edit_state = Auth_required.from ~auth_tag","counters":[]},{"line":"                          }","counters":[]},{"line":"                    }","counters":[]},{"line":"                | `Verification_key ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    { Account_update.Update.dummy with","counters":[]},{"line":"                      permissions =","counters":[]},{"line":"                        Set_or_keep.Set","counters":[]},{"line":"                          { perm with","counters":[]},{"line":"                            set_verification_key = Auth_required.from ~auth_tag","counters":[]},{"line":"                          }","counters":[]},{"line":"                    }","counters":[]},{"line":"                | `Zkapp_uri ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    { Account_update.Update.dummy with","counters":[]},{"line":"                      permissions =","counters":[]},{"line":"                        Set_or_keep.Set","counters":[]},{"line":"                          { perm with","counters":[]},{"line":"                            set_zkapp_uri = Auth_required.from ~auth_tag","counters":[]},{"line":"                          }","counters":[]},{"line":"                    }","counters":[]},{"line":"                | `Token_symbol ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    { Account_update.Update.dummy with","counters":[]},{"line":"                      permissions =","counters":[]},{"line":"                        Set_or_keep.Set","counters":[]},{"line":"                          { perm with","counters":[]},{"line":"                            set_token_symbol = Auth_required.from ~auth_tag","counters":[]},{"line":"                          }","counters":[]},{"line":"                    }","counters":[]},{"line":"                | `Voting_for ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    { Account_update.Update.dummy with","counters":[]},{"line":"                      permissions =","counters":[]},{"line":"                        Set_or_keep.Set","counters":[]},{"line":"                          { perm with","counters":[]},{"line":"                            set_voting_for = Auth_required.from ~auth_tag","counters":[]},{"line":"                          }","counters":[]},{"line":"                    }","counters":[]},{"line":"                | `Send ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    { Account_update.Update.dummy with","counters":[]},{"line":"                      permissions =","counters":[]},{"line":"                        Set_or_keep.Set","counters":[]},{"line":"                          { perm with send = Auth_required.from ~auth_tag }","counters":[]},{"line":"                    }","counters":[]},{"line":"                | `Receive ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    { Account_update.Update.dummy with","counters":[]},{"line":"                      permissions =","counters":[]},{"line":"                        Set_or_keep.Set","counters":[]},{"line":"                          { perm with receive = Auth_required.from ~auth_tag }","counters":[]},{"line":"                    }","counters":[]},{"line":"              in","counters":[]},{"line":"              (auth_tag, Some update)","counters":[]},{"line":"          | _ ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let%map tag =","counters":[]},{"line":"                if new_account then","counters":[]},{"line":"                  Quickcheck.Generator.of_list","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"                    [ Control.Tag.Signature; None_given ]","counters":[]},{"line":"                else Control.Tag.gen","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"              in","counters":[]},{"line":"              (tag, None)","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"        in","counters":[]},{"line":"        let zkapp_account =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          match permissions_auth with","counters":[]},{"line":"          | Proof ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              true","counters":[]},{"line":"          | Signature | None_given ->","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"              false","counters":[]},{"line":"        in","counters":[]},{"line":"        let%bind account_update0 =","counters":[]},{"line":"          (* Signature authorization to start *)","counters":[]},{"line":"          let authorization = Control.Signature Signature.dummy in","counters":[]},{"line":"          gen_account_update_from ~zkapp_account_ids ~account_ids_seen ~update","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"            ?failure ~authorization ~new_account ~permissions_auth","counters":[]},{"line":"            ~zkapp_account ~available_public_keys ~account_state_tbl","counters":[]},{"line":"            ?protocol_state_view ?vk ()","counters":[]},{"line":"        in","counters":[]},{"line":"        let%bind account_update =","counters":[]},{"line":"          (* authorization according to chosen permissions auth *)","counters":[]},{"line":"          let%bind authorization, update =","counters":[]},{"line":"            match failure with","counters":[]},{"line":"            | Some (Update_not_permitted update_type) ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                let auth =","counters":[]},{"line":"                  match permissions_auth with","counters":[]},{"line":"                  | Proof ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      Control.(dummy_of_tag Signature)","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"                  | Signature ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      Control.(dummy_of_tag Proof)","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"                  | _ ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      Control.(dummy_of_tag None_given)","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"                in","counters":[]},{"line":"                let%bind update =","counters":[]},{"line":"                  match update_type with","counters":[]},{"line":"                  | `Delegate ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      let%map delegate =","counters":[]},{"line":"                        Signature_lib.Public_key.Compressed.gen","counters":[]},{"line":"                      in","counters":[]},{"line":"                      { Account_update.Update.dummy with","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        delegate = Set_or_keep.Set delegate","counters":[]},{"line":"                      }","counters":[]},{"line":"                  | `App_state ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      let%map app_state =","counters":[]},{"line":"                        let%map fields =","counters":[]},{"line":"                          let field_gen =","counters":[]},{"line":"                            Snark_params.Tick.Field.gen","counters":[]},{"line":"                            >>| fun x -> Set_or_keep.Set x","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"                          in","counters":[]},{"line":"                          Quickcheck.Generator.list_with_length 8 field_gen","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"                        in","counters":[]},{"line":"                        Zkapp_state.V.of_list_exn fields","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                      in","counters":[]},{"line":"                      { Account_update.Update.dummy with app_state }","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                  | `Verification_key ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      let data = Pickles.Side_loaded.Verification_key.dummy in","counters":[]},{"line":"                      let hash = Zkapp_account.digest_vk data in","counters":[]},{"line":"                      let verification_key =","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        Set_or_keep.Set { With_hash.data; hash }","counters":[]},{"line":"                      in","counters":[]},{"line":"                      return","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                        { Account_update.Update.dummy with verification_key }","counters":[]},{"line":"                  | `Zkapp_uri ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      let zkapp_uri = Set_or_keep.Set \"https://o1labs.org\" in","counters":[]},{"line":"                      return { Account_update.Update.dummy with zkapp_uri }","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                  | `Token_symbol ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      let token_symbol = Set_or_keep.Set \"CODA\" in","counters":[]},{"line":"                      return { Account_update.Update.dummy with token_symbol }","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                  | `Voting_for ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      let%map field = Snark_params.Tick.Field.gen in","counters":[]},{"line":"                      let voting_for = Set_or_keep.Set field in","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                      { Account_update.Update.dummy with voting_for }","counters":[]},{"line":"                  | `Send | `Receive ->","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"                      return Account_update.Update.dummy","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                in","counters":[]},{"line":"                let%map new_perm =","counters":[]},{"line":"                  Permissions.gen ~auth_tag:Control.Tag.Signature","counters":[]},{"line":"                in","counters":[]},{"line":"                ( auth","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                , Some { update with permissions = Set_or_keep.Set new_perm } )","counters":[]},{"line":"            | _ ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                return (Control.dummy_of_tag permissions_auth, None)","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"          in","counters":[]},{"line":"          let account_id =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Account_id.create account_update0.body.public_key","counters":[]},{"line":"              account_update0.body.token_id","counters":[]},{"line":"          in","counters":[]},{"line":"          let permissions_auth = Control.Tag.Signature in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          gen_account_update_from ~update ?failure ~zkapp_account_ids","counters":[]},{"line":"            ~account_ids_seen ~account_id ~authorization ~permissions_auth","counters":[]},{"line":"            ~zkapp_account ~available_public_keys ~account_state_tbl","counters":[]},{"line":"            ?protocol_state_view ?vk ()","counters":[]},{"line":"        in","counters":[]},{"line":"        (* this list will be reversed, so `account_update0` will execute before `account_update` *)","counters":[]},{"line":"        go","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (mk_node account_update [] :: mk_node account_update0 [] :: acc)","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"          (n - 1)","counters":[]},{"line":"    in","counters":[]},{"line":"    go [] num_zkapp_command","counters":[]},{"line":"  in","counters":[]},{"line":"  (* at least 1 account_update *)","counters":[]},{"line":"  let%bind num_zkapp_command = Int.gen_uniform_incl 1 max_account_updates in","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"  let%bind num_new_accounts = Int.gen_uniform_incl 0 num_zkapp_command in","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"  let num_old_zkapp_command = num_zkapp_command - num_new_accounts in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%bind old_zkapp_command =","counters":[]},{"line":"    gen_zkapp_command_with_dynamic_balance ~new_account:false","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"      num_old_zkapp_command","counters":[]},{"line":"  in","counters":[]},{"line":"  let%bind new_zkapp_command =","counters":[]},{"line":"    gen_zkapp_command_with_dynamic_balance ~new_account:true num_new_accounts","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"  in","counters":[]},{"line":"  let account_updates0 = old_zkapp_command @ new_zkapp_command in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let balance_change_sum =","counters":[]},{"line":"    List.fold account_updates0","counters":[]},{"line":"      ~init:","counters":[]},{"line":"        ( if num_new_accounts = 0 then Currency.Amount.Signed.zero","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"        else","counters":[]},{"line":"          Currency.Amount.(","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Signed.of_unsigned","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"              ( scale","counters":[]},{"line":"                  (of_fee","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                     Genesis_constants.Constraint_constants.compiled","counters":[]},{"line":"                       .account_creation_fee )","counters":[]},{"line":"                  num_new_accounts","counters":[]},{"line":"              |> Option.value_exn )) )","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"      ~f:(fun acc node ->","counters":[]},{"line":"        match","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Currency.Amount.Signed.add acc node.account_update.body.balance_change","counters":[]},{"line":"        with","counters":[]},{"line":"        | Some sum ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            sum","counters":[]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            failwith \"Overflow adding other zkapp_command balances\" )","counters":[]},{"line":"  in","counters":[]},{"line":"","counters":[]},{"line":"  (* modify the balancing account_update with balance change to yield a zero sum","counters":[]},{"line":"","counters":[]},{"line":"     balancing account_update is created immediately after the fee payer","counters":[]},{"line":"     account_update is created. This is because the preconditions generation","counters":[]},{"line":"     is sensitive to the order of account_update generation.","counters":[]},{"line":"  *)","counters":[]},{"line":"  let balance_change = Currency.Amount.Signed.negate balance_change_sum in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%bind balancing_account_update =","counters":[]},{"line":"    let authorization = Control.Signature Signature.dummy in","counters":[]},{"line":"    gen_account_update_from ?failure ~permissions_auth:Control.Tag.Signature","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"      ~zkapp_account_ids ~account_ids_seen ~authorization ~new_account:false","counters":[]},{"line":"      ~available_public_keys ~account_state_tbl","counters":[]},{"line":"      ~required_balance_change:balance_change ?protocol_state_view ?vk ()","counters":[]},{"line":"  in","counters":[]},{"line":"  let gen_zkapp_command_with_token_accounts ~num_zkapp_command =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    let authorization = Control.Signature Signature.dummy in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let permissions_auth = Control.Tag.Signature in","counters":[]},{"line":"    let caller = Account_update.Call_type.Call in","counters":[]},{"line":"    let rec gen_tree acc n =","counters":[]},{"line":"      if n <= 0 then return (List.rev acc)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"      else","counters":[]},{"line":"        let%bind parent =","counters":[]},{"line":"          let required_balance_change =","counters":[]},{"line":"            Currency.Amount.(","counters":[]},{"line":"              Signed.negate","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                (Signed.of_unsigned","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"                   (of_fee","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                      Genesis_constants.Constraint_constants.compiled","counters":[]},{"line":"                        .account_creation_fee ) ))","counters":[]},{"line":"          in","counters":[]},{"line":"          gen_account_update_from ~zkapp_account_ids ~account_ids_seen","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"            ~authorization ~permissions_auth ~available_public_keys ~caller","counters":[]},{"line":"            ~account_state_tbl ~required_balance_change ?protocol_state_view ?vk","counters":[]},{"line":"            ()","counters":[]},{"line":"        in","counters":[]},{"line":"        let token_id =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Account_id.derive_token_id","counters":[]},{"line":"            ~owner:","counters":[]},{"line":"              (Account_id.create parent.body.public_key parent.body.token_id)","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"        in","counters":[]},{"line":"        let%bind child =","counters":[]},{"line":"          gen_account_update_from ~zkapp_account_ids ~account_ids_seen","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"            ~new_account:true ~token_id ~caller ~authorization ~permissions_auth","counters":[]},{"line":"            ~available_public_keys ~account_state_tbl ?protocol_state_view ?vk","counters":[]},{"line":"            ()","counters":[]},{"line":"        in","counters":[]},{"line":"        gen_tree (mk_node parent [ mk_node child [] ] :: acc) (n - 1)","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"    in","counters":[]},{"line":"    gen_tree [] num_zkapp_command","counters":[]},{"line":"  in","counters":[]},{"line":"  let%bind num_new_token_zkapp_command =","counters":[]},{"line":"    Int.gen_uniform_incl 0 max_token_updates","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%bind new_token_zkapp_command =","counters":[]},{"line":"    gen_zkapp_command_with_token_accounts","counters":[]},{"line":"      ~num_zkapp_command:num_new_token_zkapp_command","counters":[]},{"line":"  in","counters":[]},{"line":"  let account_updates =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    account_updates0","counters":[]},{"line":"    @ [ mk_node balancing_account_update [] ]","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"    @ new_token_zkapp_command","counters":[]},{"line":"    |> mk_forest","counters":[]},{"line":"  in","counters":[]},{"line":"  let%map memo = Signed_command_memo.gen in","counters":[]},{"line":"  let zkapp_command_dummy_authorizations : Zkapp_command.t =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    { fee_payer","counters":[]},{"line":"    ; account_updates =","counters":[]},{"line":"        account_updates |> Zkapp_command.Call_forest.add_callers_simple","counters":[]},{"line":"        |> Zkapp_command.Call_forest.accumulate_hashes_predicated","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"    ; memo","counters":[]},{"line":"    }","counters":[]},{"line":"  in","counters":[]},{"line":"  (* update receipt chain hashes in accounts table *)","counters":[]},{"line":"  let receipt_elt =","counters":[]},{"line":"    let _txn_commitment, full_txn_commitment =","counters":[]},{"line":"      (* also computed in replace_authorizations, but easier just to re-compute here *)","counters":[]},{"line":"      Zkapp_command_builder.get_transaction_commitments","counters":[]},{"line":"        zkapp_command_dummy_authorizations","counters":[]},{"line":"    in","counters":[]},{"line":"    Receipt.Zkapp_command_elt.Zkapp_command_commitment full_txn_commitment","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  in","counters":[]},{"line":"  Account_id.Table.update account_state_tbl fee_payer_acct_id ~f:(function","counters":[]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        failwith \"Expected fee payer account id to be in table\"","counters":[]},{"line":"    | Some (account, _) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let receipt_chain_hash =","counters":[]},{"line":"          Receipt.Chain_hash.cons_zkapp_command_commitment","counters":[]},{"line":"            Mina_numbers.Index.zero receipt_elt","counters":[]},{"line":"            account.Account.Poly.receipt_chain_hash","counters":[]},{"line":"        in","counters":[]},{"line":"        ({ account with receipt_chain_hash }, `Fee_payer) ) ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"  let account_updates =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Zkapp_command.Call_forest.to_account_updates","counters":[]},{"line":"      zkapp_command_dummy_authorizations.account_updates","counters":[]},{"line":"  in","counters":[]},{"line":"  List.iteri account_updates ~f:(fun ndx account_update ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      (* update receipt chain hash only for signature, proof authorizations *)","counters":[]},{"line":"      match Account_update.authorization account_update with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Control.Proof _ | Control.Signature _ ->","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"          let acct_id = Account_update.account_id account_update in","counters":[]},{"line":"          Account_id.Table.update account_state_tbl acct_id ~f:(function","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            | None ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                failwith","counters":[]},{"line":"                  \"Expected other account_update account id to be in table\"","counters":[]},{"line":"            | Some (account, role) ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                let receipt_chain_hash =","counters":[]},{"line":"                  let account_update_index =","counters":[]},{"line":"                    Mina_numbers.Index.of_int (ndx + 1)","counters":[]},{"line":"                  in","counters":[]},{"line":"                  Receipt.Chain_hash.cons_zkapp_command_commitment","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"                    account_update_index receipt_elt","counters":[]},{"line":"                    account.Account.Poly.receipt_chain_hash","counters":[]},{"line":"                in","counters":[]},{"line":"                ({ account with receipt_chain_hash }, role) )","counters":[]},{"line":"      | Control.None_given ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          () ) ;","counters":[]},{"line":"  zkapp_command_dummy_authorizations","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let gen_list_of_zkapp_command_from ?failure ?max_account_updates","counters":[]},{"line":"    ?max_token_updates ~(fee_payer_keypairs : Signature_lib.Keypair.t list)","counters":[]},{"line":"    ~keymap ?account_state_tbl ~ledger ?protocol_state_view ?vk ?length () =","counters":[]},{"line":"  (* Since when generating multiple zkapp_command the fee payer's nonce should only","counters":[]},{"line":"     be incremented as the `Fee_payer` role, this is why we pre-computed the","counters":[]},{"line":"     `account_state_tbl` here.","counters":[]},{"line":"  *)","counters":[]},{"line":"  let account_state_tbl =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    match account_state_tbl with","counters":[]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let tbl = Account_id.Table.create () in","counters":[]},{"line":"        let accounts = Ledger.to_list ledger in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        List.iter accounts ~f:(fun acct ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            let acct_id = Account.identifier acct in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            Account_id.Table.update tbl acct_id ~f:(function","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              | None ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  (acct, `Ordinary_participant)","counters":[]},{"line":"              | Some a ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  a ) ) ;","counters":[]},{"line":"        List.iter fee_payer_keypairs ~f:(fun fee_payer_keypair ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            let acct_id =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Account_id.create","counters":[]},{"line":"                (Signature_lib.Public_key.compress fee_payer_keypair.public_key)","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"                Token_id.default","counters":[]},{"line":"            in","counters":[]},{"line":"            Account_id.Table.update tbl acct_id ~f:(function","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              | None ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  failwith \"fee_payer not in ledger\"","counters":[]},{"line":"              | Some (a, _) ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  (a, `Fee_payer) ) ) ;","counters":[]},{"line":"        tbl","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    | Some tbl ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        tbl","counters":[]},{"line":"  in","counters":[]},{"line":"  let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"  let%bind length =","counters":[]},{"line":"    match length with None -> Int.gen_uniform_incl 1 10 | Some n -> return n","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":49,"col_end":49,"count":0},{"col_start":58,"col_end":58,"count":0},{"col_start":73,"col_end":73,"count":0}]},{"line":"  in","counters":[]},{"line":"  let rec go n acc =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    if n > 0 then","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let%bind fee_payer_keypair =","counters":[]},{"line":"        Quickcheck.Generator.of_list fee_payer_keypairs","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"      in","counters":[]},{"line":"      let%bind new_zkapp_command =","counters":[]},{"line":"        gen_zkapp_command_from ?failure ?max_account_updates ?max_token_updates","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"          ~fee_payer_keypair ~keymap ~account_state_tbl ~ledger","counters":[]},{"line":"          ?protocol_state_view ?vk ()","counters":[]},{"line":"      in","counters":[]},{"line":"      go (n - 1) (new_zkapp_command :: acc)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    else return (List.rev acc)","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"  in","counters":[]},{"line":"  go length []","counters":[]}]}