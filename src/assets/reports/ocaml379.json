{"filename":"src/lib/transition_frontier/full_catchup_tree.ml","lines":[{"line":"open Core","counters":[]},{"line":"open Async","counters":[]},{"line":"open Cache_lib","counters":[]},{"line":"open Mina_base","counters":[]},{"line":"open Network_peer","counters":[]},{"line":"open Mina_numbers","counters":[]},{"line":"","counters":[]},{"line":"module Attempt_history = struct","counters":[]},{"line":"  module Attempt = struct","counters":[]},{"line":"    type reason = [ `Download | `Initial_validate | `Verify | `Build_breadcrumb ]","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"    [@@deriving yojson]","counters":[]},{"line":"","counters":[]},{"line":"    type t = { failure_reason : reason } [@@deriving yojson]","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  type t = Attempt.t Peer.Map.t","counters":[]},{"line":"","counters":[]},{"line":"  let to_yojson (t : t) =","counters":[]},{"line":"    `Assoc","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (List.map (Map.to_alist t) ~f:(fun (peer, a) ->","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"           (Peer.to_multiaddr_string peer, Attempt.to_yojson a) ) )","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"","counters":[]},{"line":"  let empty : t = Peer.Map.empty","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"open Frontier_base","counters":[]},{"line":"","counters":[]},{"line":"module Downloader_job = struct","counters":[]},{"line":"  type t =","counters":[]},{"line":"    ( State_hash.t * Length.t","counters":[]},{"line":"    , Attempt_history.Attempt.t","counters":[]},{"line":"    , Mina_block.t )","counters":[]},{"line":"    Downloader.Job.t","counters":[]},{"line":"","counters":[]},{"line":"  let to_yojson (t : t) : Yojson.Safe.t =","counters":[]},{"line":"    let h, l = t.key in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    `Assoc","counters":[]},{"line":"      [ (\"hash\", State_hash.to_yojson h)","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"      ; (\"length\", Length.to_yojson l)","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"      ; (\"attempts\", Attempt_history.to_yojson t.attempts)","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"      ]","counters":[]},{"line":"","counters":[]},{"line":"  let result (t : t) = Ivar.read t.res","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Node = struct","counters":[]},{"line":"  module State = struct","counters":[]},{"line":"    type t =","counters":[]},{"line":"      | Finished","counters":[]},{"line":"      | Failed","counters":[]},{"line":"      | To_download of Downloader_job.t","counters":[]},{"line":"      | To_initial_validate of Mina_block.t Envelope.Incoming.t","counters":[]},{"line":"      | To_verify of","counters":[]},{"line":"          ( ( Mina_block.initial_valid_block Envelope.Incoming.t","counters":[]},{"line":"            , State_hash.t )","counters":[]},{"line":"            Cached.t","counters":[]},{"line":"          * Mina_net2.Validation_callback.t option )","counters":[]},{"line":"      | Wait_for_parent of","counters":[]},{"line":"          ( ( Mina_block.almost_valid_block Envelope.Incoming.t","counters":[]},{"line":"            , State_hash.t )","counters":[]},{"line":"            Cached.t","counters":[]},{"line":"          * Mina_net2.Validation_callback.t option )","counters":[]},{"line":"      | To_build_breadcrumb of","counters":[]},{"line":"          ( [ `Parent of State_hash.t ]","counters":[]},{"line":"          * ( Mina_block.almost_valid_block Envelope.Incoming.t","counters":[]},{"line":"            , State_hash.t )","counters":[]},{"line":"            Cached.t","counters":[]},{"line":"          * Mina_net2.Validation_callback.t option )","counters":[]},{"line":"      (* TODO: Name this to Initial_root *)","counters":[]},{"line":"      | Root of Breadcrumb.t Ivar.t","counters":[]},{"line":"","counters":[]},{"line":"    module Enum = struct","counters":[]},{"line":"      module T = struct","counters":[]},{"line":"        type t =","counters":[{"col_start":8,"col_end":8,"count":1},{"col_start":13,"col_end":13,"count":2}]},{"line":"          | Finished","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | Failed","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | To_download","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | To_initial_validate","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | To_verify","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | Wait_for_parent","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | To_build_breadcrumb","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | Root","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        [@@deriving sexp, hash, equal, compare, yojson, bin_io_unversioned]","counters":[{"col_start":74,"col_end":74,"count":4}]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      include T","counters":[]},{"line":"      include Hashable.Make (T)","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    let enum : t -> Enum.t = function","counters":[]},{"line":"      | To_download _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          To_download","counters":[]},{"line":"      | To_initial_validate _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          To_initial_validate","counters":[]},{"line":"      | To_verify _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          To_verify","counters":[]},{"line":"      | Wait_for_parent _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Wait_for_parent","counters":[]},{"line":"      | To_build_breadcrumb _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          To_build_breadcrumb","counters":[]},{"line":"      | Root _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Root","counters":[]},{"line":"      | Finished ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Finished","counters":[]},{"line":"      | Failed ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Failed","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  type t =","counters":[]},{"line":"    { mutable state : State.t","counters":[]},{"line":"    ; mutable attempts : Attempt_history.t","counters":[]},{"line":"    ; state_hash : State_hash.t","counters":[]},{"line":"    ; blockchain_length : Length.t","counters":[]},{"line":"    ; parent : State_hash.t","counters":[]},{"line":"    ; result : ([ `Added_to_frontier ], Attempt_history.t) Result.t Ivar.t","counters":[]},{"line":"    }","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let add_state states (node : Node.t) =","counters":[]},{"line":"  Hashtbl.update states (Node.State.enum node.state) ~f:(function","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        State_hash.Set.singleton node.state_hash","counters":[]},{"line":"    | Some hashes ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        State_hash.Set.add hashes node.state_hash )","counters":[]},{"line":"","counters":[]},{"line":"let remove_state states (node : Node.t) =","counters":[]},{"line":"  Hashtbl.update states (Node.State.enum node.state) ~f:(function","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        State_hash.Set.empty","counters":[]},{"line":"    | Some hashes ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        State_hash.Set.remove hashes node.state_hash )","counters":[]},{"line":"","counters":[]},{"line":"(* Invariant: The length of the path from each best tip to its oldest","counters":[]},{"line":"   ancestor is at most k *)","counters":[]},{"line":"type t =","counters":[]},{"line":"  { nodes : Node.t State_hash.Table.t","counters":[]},{"line":"  ; states : State_hash.Set.t Node.State.Enum.Table.t","counters":[]},{"line":"  ; logger : Logger.t","counters":[]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"(* mutable root: Node.t ; *)","counters":[]},{"line":"(*     ; mutable target: State_hash.t Envelope.Incoming.t (* So that we know who to punish if the process fails *) *)","counters":[]},{"line":"","counters":[]},{"line":"let tear_down { nodes; states; _ } =","counters":[]},{"line":"  Hashtbl.iter nodes ~f:(fun x ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      match x.state with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Root _ | Failed | Finished ->","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"          ()","counters":[]},{"line":"      | Wait_for_parent _","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      | To_download _","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      | To_initial_validate _","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      | To_verify _","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      | To_build_breadcrumb _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Ivar.fill_if_empty x.result (Error x.attempts) ) ;","counters":[]},{"line":"  Hashtbl.clear nodes ;","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  Hashtbl.clear states","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let set_state t (node : Node.t) s =","counters":[]},{"line":"  remove_state t.states node ;","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  node.state <- s ;","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  add_state t.states node","counters":[]},{"line":"","counters":[]},{"line":"let finish t (node : Node.t) b =","counters":[]},{"line":"  let s, r =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    if Result.is_error b then (Node.State.Failed, Error node.attempts)","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"    else (Finished, Ok `Added_to_frontier)","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"  in","counters":[]},{"line":"  set_state t node s ;","counters":[]},{"line":"  Ivar.fill_if_empty node.result r","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let to_yojson =","counters":[]},{"line":"  let module T = struct","counters":[]},{"line":"    type t = (Node.State.Enum.t * (int * State_hash.t list)) list","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":14,"col_end":14,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":57,"col_end":57,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"    [@@deriving to_yojson]","counters":[]},{"line":"  end in","counters":[]},{"line":"  fun (t : t) ->","counters":[]},{"line":"    T.to_yojson","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    @@ List.map (Hashtbl.to_alist t.states) ~f:(fun (state, hashes) ->","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"           (state, (State_hash.Set.length hashes, State_hash.Set.to_list hashes)) )","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"","counters":[]},{"line":"type job_states =","counters":[{"col_start":0,"col_end":0,"count":0}]},{"line":"  { finished : int","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"  ; failed : int","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"  ; to_download : int","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":20,"col_end":20,"count":0}]},{"line":"  ; to_initial_validate : int","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"  ; wait_for_parent : int","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"  ; to_verify : int","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"  ; to_build_breadcrumb : int","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"  }","counters":[]},{"line":"[@@deriving to_yojson]","counters":[]},{"line":"","counters":[]},{"line":"let to_node_status_report (t : t) =","counters":[]},{"line":"  let init =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    { finished = 0","counters":[]},{"line":"    ; failed = 0","counters":[]},{"line":"    ; to_download = 0","counters":[]},{"line":"    ; to_initial_validate = 0","counters":[]},{"line":"    ; to_verify = 0","counters":[]},{"line":"    ; wait_for_parent = 0","counters":[]},{"line":"    ; to_build_breadcrumb = 0","counters":[]},{"line":"    }","counters":[]},{"line":"  in","counters":[]},{"line":"  Hashtbl.fold t.states ~init ~f:(fun ~key ~data acc ->","counters":[]},{"line":"      let n = Set.length data in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      match key with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Finished ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          { acc with finished = n }","counters":[]},{"line":"      | Failed ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          { acc with failed = n }","counters":[]},{"line":"      | To_download ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          { acc with to_download = n }","counters":[]},{"line":"      | To_initial_validate ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          { acc with to_initial_validate = n }","counters":[]},{"line":"      | To_verify ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          { acc with to_verify = n }","counters":[]},{"line":"      | Wait_for_parent ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          { acc with wait_for_parent = n }","counters":[]},{"line":"      | To_build_breadcrumb ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          { acc with to_build_breadcrumb = n }","counters":[]},{"line":"      | Root ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          acc )","counters":[]},{"line":"","counters":[]},{"line":"let max_catchup_chain_length (t : t) =","counters":[]},{"line":"  (* Find the longest directed path *)","counters":[]},{"line":"  let lengths = State_hash.Table.create () in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let rec longest_starting_at (node : Node.t) =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    match Hashtbl.find lengths node.state_hash with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Some n ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        n","counters":[]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let n =","counters":[]},{"line":"          match node.state with","counters":[]},{"line":"          | Root _ | Finished ->","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"              0","counters":[]},{"line":"          | Failed","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          | Wait_for_parent _","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          | To_download _","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          | To_initial_validate _","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          | To_verify _","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          | To_build_breadcrumb _ -> (","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              match Hashtbl.find t.nodes node.parent with","counters":[]},{"line":"              | None ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  1","counters":[]},{"line":"              | Some parent ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  1 + longest_starting_at parent )","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"        in","counters":[]},{"line":"        Hashtbl.set lengths ~key:node.state_hash ~data:n ;","counters":[]},{"line":"        n","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"  in","counters":[]},{"line":"  Hashtbl.fold t.nodes ~init:0 ~f:(fun ~key:_ ~data acc ->","counters":[]},{"line":"      Int.max acc (longest_starting_at data) )","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"let create_node_full t b : unit =","counters":[]},{"line":"  let h = Breadcrumb.state_hash b in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let node : Node.t =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    { state = Finished","counters":[]},{"line":"    ; state_hash = h","counters":[]},{"line":"    ; blockchain_length =","counters":[]},{"line":"        Consensus.Data.Consensus_state.blockchain_length","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"        @@ Breadcrumb.consensus_state b","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"    ; attempts = Attempt_history.empty","counters":[]},{"line":"    ; parent = Breadcrumb.parent_hash b","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"    ; result = Ivar.create_full (Ok `Added_to_frontier)","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"    }","counters":[]},{"line":"  in","counters":[]},{"line":"  add_state t.states node ;","counters":[]},{"line":"  Hashtbl.add_exn t.nodes ~key:h ~data:node","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let breadcrumb_added (t : t) b =","counters":[]},{"line":"  let h = Breadcrumb.state_hash b in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  match Hashtbl.find t.nodes h with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | None ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      create_node_full t b","counters":[]},{"line":"  | Some node -> (","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Ivar.fill_if_empty node.result (Ok `Added_to_frontier) ;","counters":[]},{"line":"      match node.state with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Root _ | Failed | Finished ->","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"          ()","counters":[]},{"line":"      | To_download _","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      (* TODO: Cancel download job somehow.. maybe wait on the ivar? *)","counters":[]},{"line":"      | Wait_for_parent _","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      | To_initial_validate _","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      | To_verify _","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      | To_build_breadcrumb _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          set_state t node Finished )","counters":[]},{"line":"","counters":[]},{"line":"let remove_node' t (node : Node.t) =","counters":[]},{"line":"  Hashtbl.remove t.nodes node.state_hash ;","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  remove_state t.states node ;","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  Ivar.fill_if_empty node.result (Error node.attempts) ;","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  match node.state with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | Root _ | Failed | Finished ->","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"      ()","counters":[]},{"line":"  | Wait_for_parent _ ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (* cache invalidation for this case is handled explicitly in the super catchup fstm *)","counters":[]},{"line":"      ()","counters":[]},{"line":"  | To_download _job ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (* TODO: Cancel job somehow *)","counters":[]},{"line":"      ()","counters":[]},{"line":"  | To_initial_validate _ ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ()","counters":[]},{"line":"  | To_verify (c, vc) ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Option.value_map ~default:ignore","counters":[]},{"line":"        ~f:Mina_net2.Validation_callback.fire_if_not_already_fired vc `Ignore ;","counters":[]},{"line":"      ignore","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ( Cached.invalidate_with_failure c","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"          : Mina_block.initial_valid_block Envelope.Incoming.t )","counters":[]},{"line":"  | To_build_breadcrumb (_parent, c, vc) ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Option.value_map ~default:ignore","counters":[]},{"line":"        ~f:Mina_net2.Validation_callback.fire_if_not_already_fired vc `Ignore ;","counters":[]},{"line":"      ignore","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ( Cached.invalidate_with_failure c","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"          : Mina_block.almost_valid_block Envelope.Incoming.t )","counters":[]},{"line":"","counters":[]},{"line":"let remove_node t h =","counters":[]},{"line":"  match Hashtbl.find t.nodes h with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | None ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ()","counters":[]},{"line":"  | Some node ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      remove_node' t node","counters":[]},{"line":"","counters":[]},{"line":"let prune t ~root_hash =","counters":[]},{"line":"  let cache = State_hash.Table.create () in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let rec reachable_from_root (node : Node.t) =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Hashtbl.find_or_add cache node.state_hash ~default:(fun () ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        if State_hash.equal node.state_hash root_hash then true","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"        else","counters":[]},{"line":"          match Hashtbl.find t.nodes node.parent with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              false","counters":[]},{"line":"          | Some parent ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              reachable_from_root parent )","counters":[]},{"line":"  in","counters":[]},{"line":"  let to_remove =","counters":[]},{"line":"    Hashtbl.fold t.nodes ~init:[] ~f:(fun ~key:_ ~data acc ->","counters":[]},{"line":"        if reachable_from_root data then acc else data :: acc )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"  in","counters":[]},{"line":"  List.iter to_remove ~f:(remove_node' t)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"let apply_diffs (t : t) (ds : Diff.Full.E.t list) =","counters":[]},{"line":"  List.iter ds ~f:(function","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    | E (New_node (Full b)) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        breadcrumb_added t b","counters":[]},{"line":"    | E (Root_transitioned { new_root; garbage = Full hs; _ }) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        List.iter (Diff.Node_list.to_lite hs) ~f:(remove_node t) ;","counters":[{"col_start":40,"col_end":40,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"        let h = (Root_data.Limited.hashes new_root).state_hash in","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"        if Hashtbl.mem t.nodes h then prune t ~root_hash:h","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"        else (","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"          [%log' debug t.logger]","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"            ~metadata:","counters":[]},{"line":"              [ (\"hash\", State_hash.to_yojson h); (\"tree\", to_yojson t) ]","counters":[{"col_start":44,"col_end":44,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"            \"catchup $tree invariant broken: new root $hash not present. Diffs \\","counters":[]},{"line":"             may have been applied out of order. This may lead to a memory \\","counters":[]},{"line":"             leak\" ;","counters":[]},{"line":"          () )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    | E (Best_tip_changed _) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        () )","counters":[]},{"line":"","counters":[]},{"line":"let create ~root =","counters":[]},{"line":"  let t =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    { states = Node.State.Enum.Table.create ()","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"    ; nodes = State_hash.Table.create ()","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"    ; logger = Logger.create ()","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"    }","counters":[]},{"line":"  in","counters":[]},{"line":"  create_node_full t root ; t","counters":[{"col_start":28,"col_end":28,"count":2}]}]}