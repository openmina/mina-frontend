{"filename":"src/lib/graphql_wrapper/graphql_wrapper.ml","lines":[{"line":"(**","counters":[]},{"line":"   This file provides a wrapper around an ocaml-graphql-server [Schema] module,","counters":[]},{"line":"   in order to build [to_json] functions for query [fields].","counters":[]},{"line":"   These can later be used to serialize queries.","counters":[]},{"line":"","counters":[]},{"line":"   - The [Arg.scalar] function has a new [~to_json] argument that is","counters":[]},{"line":"   morally the inverse of [coerce].  The most common case where these","counters":[]},{"line":"   functions are not inverse of one another is when the [coerce] function can fail","counters":[]},{"line":"   during parsing and return a [result] type, but it does not make","counters":[]},{"line":"   sense for the [to_json] function to take a result type as input.","counters":[]},{"line":"","counters":[]},{"line":"   - The [Arg.obj] function has a new [~split] argument, which is also morally the inverse of coerce:","counters":[]},{"line":"     while the [coerce] function for [obj] arguments builds an ocaml value from the fields of the objects,","counters":[]},{"line":"   the [split] describes how to split an ocaml value into these fields.","counters":[]},{"line":"","counters":[]},{"line":"    The [split] argument is used as such:","counters":[]},{"line":"          {[","counters":[]},{"line":"          let add_payment_reciept_input =","counters":[]},{"line":"              obj \"AddPaymentReceiptInput\"","counters":[]},{"line":"              ~coerce:(fun payment added_time -> { payment; added_time })","counters":[]},{"line":"              ~split:(fun f (t : t) -> f t.payment t.added_time)","counters":[]},{"line":"              ~fields:[...]","counters":[]},{"line":"          ]}","counters":[]},{"line":"","counters":[]},{"line":"    The [to_json] function from the [add_payment_reciept_input] can then be used as such :","counters":[]},{"line":"    {[let input_as_json = add_payment_reciept_input.to_json","counters":[]},{"line":"                          {payment = \"...\"; added_time = \"...\"}]}","counters":[]},{"line":" *)","counters":[]},{"line":"","counters":[]},{"line":"module Make (Schema : Graphql_intf.Schema) = struct","counters":[]},{"line":"  (** wrapper around the [enum_value] type *)","counters":[]},{"line":"  type 'a enum_value =","counters":[]},{"line":"    { as_string : string; value : 'a; enum_value : 'a Schema.enum_value }","counters":[]},{"line":"","counters":[]},{"line":"  (** wrapper around the [enum_value] function *)","counters":[]},{"line":"  let enum_value ?doc ?deprecated as_string ~value =","counters":[]},{"line":"    { as_string","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    ; value","counters":[]},{"line":"    ; enum_value = Schema.enum_value ?doc ?deprecated as_string ~value","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  module Arg = struct","counters":[]},{"line":"    (** wrapper around the [Arg.arg_typ] type *)","counters":[]},{"line":"    type ('obj_arg, 'a) arg_typ =","counters":[]},{"line":"      { arg_typ : 'obj_arg Schema.Arg.arg_typ; to_json : 'a -> Yojson.Basic.t }","counters":[]},{"line":"","counters":[]},{"line":"    (** wrapper around the [Arg.arg] type *)","counters":[]},{"line":"    type ('obj_arg, 'a) arg =","counters":[]},{"line":"      | Arg :","counters":[]},{"line":"          { name : string; doc : string option; typ : ('obj_arg, 'a) arg_typ }","counters":[]},{"line":"          -> ('obj_arg, 'a) arg","counters":[]},{"line":"      | DefaultArg :","counters":[]},{"line":"          { name : string","counters":[]},{"line":"          ; doc : string option","counters":[]},{"line":"          ; typ : ('obj_arg option, 'a) arg_typ","counters":[]},{"line":"          ; default : 'obj_arg","counters":[]},{"line":"          }","counters":[]},{"line":"          -> ('obj_arg, 'a) arg","counters":[]},{"line":"","counters":[]},{"line":"    (**","counters":[]},{"line":"       Wrapper around the [Arg.arg_list] type.","counters":[]},{"line":"","counters":[]},{"line":"       The ocaml-graphql-server library uses this gadt type for lists of","counters":[]},{"line":"       arguments used with [fields] and [obj] argument types.","counters":[]},{"line":"","counters":[]},{"line":"       This enables to the correct types for the [coerce] and [resolve] functions,","counters":[]},{"line":"       in the ['args] parameter below.","counters":[]},{"line":"","counters":[]},{"line":"       We wrap around this and do the same thing to build the types of the [to_json] functions.","counters":[]},{"line":"     *)","counters":[]},{"line":"","counters":[]},{"line":"    type (_, _, _, _, _) args =","counters":[]},{"line":"      | [] : ('ctx, 'out, 'out, string * Yojson.Basic.t, Yojson.Basic.t) args","counters":[]},{"line":"      | ( :: ) :","counters":[]},{"line":"          ('a, 'input) arg","counters":[]},{"line":"          * ('ctx, 'out, 'args, 'field_to_json, 'obj_to_json) args","counters":[]},{"line":"          -> ( 'ctx","counters":[]},{"line":"             , 'out","counters":[]},{"line":"             , 'a -> 'args","counters":[]},{"line":"             , 'input -> 'field_to_json","counters":[]},{"line":"             , 'input -> 'obj_to_json )","counters":[]},{"line":"             args","counters":[]},{"line":"","counters":[]},{"line":"    (** [field_to_json] builds the serializer function for a field, based on the list of its arguments.*)","counters":[]},{"line":"    let rec field_to_json :","counters":[]},{"line":"        type ctx out arg field_to_json obj_to_json.","counters":[]},{"line":"           string","counters":[]},{"line":"        -> (ctx, out, arg, field_to_json, obj_to_json) args","counters":[]},{"line":"        -> (string * Yojson.Basic.t) list","counters":[]},{"line":"        -> field_to_json =","counters":[]},{"line":"     fun field_name l acc ->","counters":[]},{"line":"      match l with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | [] ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (field_name, `Assoc acc)","counters":[]},{"line":"      | Arg { typ; name; _ } :: t ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          fun x -> field_to_json field_name t ((name, typ.to_json x) :: acc)","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"      | DefaultArg { typ; name; _ } :: t ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          fun x -> field_to_json field_name t ((name, typ.to_json x) :: acc)","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"","counters":[]},{"line":"    (** [arg_obj_to_json] builds the serializer function for an obj argument, based on the list of its fields.*)","counters":[]},{"line":"    let rec arg_obj_to_json :","counters":[]},{"line":"        type ctx out arg field_to_json obj_to_json.","counters":[]},{"line":"           (ctx, out, arg, field_to_json, obj_to_json) args","counters":[]},{"line":"        -> (string * Yojson.Basic.t) list","counters":[]},{"line":"        -> obj_to_json =","counters":[]},{"line":"     fun l acc ->","counters":[]},{"line":"      match l with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | [] ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          `Assoc acc","counters":[]},{"line":"      | Arg { name; typ; _ } :: t ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          fun x -> arg_obj_to_json t ((name, typ.to_json x) :: acc)","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"      | DefaultArg { name; typ; _ } :: t ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          fun x -> arg_obj_to_json t ((name, typ.to_json x) :: acc)","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"","counters":[]},{"line":"    (** extracts the wrapped [Arg.arg_list] to pass to ocaml-graphql-server functions *)","counters":[]},{"line":"    let rec to_ocaml_graphql_server_args :","counters":[]},{"line":"        type ctx out args_server field_to_json obj_to_json.","counters":[]},{"line":"           (ctx, out, args_server, field_to_json, obj_to_json) args","counters":[]},{"line":"        -> (out, args_server) Schema.Arg.arg_list = function","counters":[]},{"line":"      | [] ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Schema.Arg.[]","counters":[]},{"line":"      | Arg { name; doc; typ } :: t ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let graphql_arg = Schema.Arg.arg ?doc name ~typ:typ.arg_typ in","counters":[]},{"line":"          Schema.Arg.(graphql_arg :: to_ocaml_graphql_server_args t)","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"      | DefaultArg { name; doc; typ; default } :: t ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let graphql_arg =","counters":[]},{"line":"            Schema.Arg.arg' ?doc name ~typ:typ.arg_typ ~default","counters":[]},{"line":"          in","counters":[]},{"line":"          Schema.Arg.(graphql_arg :: to_ocaml_graphql_server_args t)","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"","counters":[]},{"line":"    let int =","counters":[]},{"line":"      { arg_typ = Schema.Arg.int","counters":[]},{"line":"      ; to_json = Json.json_of_option (fun i -> `Int i)","counters":[{"col_start":36,"col_end":36,"count":1},{"col_start":48,"col_end":48,"count":0}]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    let scalar ?doc name ~coerce ~to_json =","counters":[]},{"line":"      { arg_typ = Schema.Arg.scalar ?doc name ~coerce","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"      ; to_json = Json.json_of_option to_json","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    let string =","counters":[]},{"line":"      { arg_typ = Schema.Arg.string","counters":[]},{"line":"      ; to_json = Json.json_of_option (function s -> `String s)","counters":[{"col_start":36,"col_end":36,"count":1},{"col_start":48,"col_end":48,"count":0}]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    let float =","counters":[]},{"line":"      { arg_typ = Schema.Arg.float","counters":[]},{"line":"      ; to_json = Json.json_of_option (function f -> `Float f)","counters":[{"col_start":36,"col_end":36,"count":1},{"col_start":48,"col_end":48,"count":0}]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    let bool =","counters":[]},{"line":"      { arg_typ = Schema.Arg.bool","counters":[]},{"line":"      ; to_json = Json.json_of_option (function f -> `Bool f)","counters":[{"col_start":36,"col_end":36,"count":1},{"col_start":48,"col_end":48,"count":0}]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    let guid =","counters":[]},{"line":"      { arg_typ = Schema.Arg.guid","counters":[]},{"line":"      ; to_json = Json.json_of_option (function s -> `String s)","counters":[{"col_start":36,"col_end":36,"count":1},{"col_start":48,"col_end":48,"count":0}]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    let obj ?doc name ~fields ~coerce ~split =","counters":[]},{"line":"      let build_obj_json = arg_obj_to_json fields [] in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let gql_server_fields = to_ocaml_graphql_server_args fields in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let arg_typ =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Schema.Arg.obj name ?doc ~fields:gql_server_fields ~coerce","counters":[]},{"line":"      in","counters":[]},{"line":"      { arg_typ; to_json = Json.json_of_option @@ split build_obj_json }","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"","counters":[]},{"line":"    let non_null (arg_typ : _ arg_typ) =","counters":[]},{"line":"      { arg_typ = Schema.Arg.non_null arg_typ.arg_typ","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"      ; to_json = (function x -> arg_typ.to_json (Some x))","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    let list (arg_typ : _ arg_typ) =","counters":[]},{"line":"      { arg_typ = Schema.Arg.list arg_typ.arg_typ","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"      ; to_json =","counters":[]},{"line":"          Json.json_of_option (function l -> `List (List.map arg_typ.to_json l))","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    (** wrapper around the enum arg_typ.","counters":[]},{"line":"        For this type, the [to_json] function can be infered from the list of enum_value.*)","counters":[]},{"line":"    let enum ?doc name ~(values : _ enum_value list) =","counters":[]},{"line":"      let rec to_string (values : _ enum_value list) v =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        match values with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | { as_string; value; _ } :: _ when value = v ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            as_string","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"        | _ :: q ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            to_string q v","counters":[]},{"line":"        | _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            failwith","counters":[]},{"line":"            @@ Format.asprintf","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                 \"Could not convert GraphQL query argument to string for enum \\","counters":[]},{"line":"                  type <%s>. Was this argument declared via an enum_value ?\"","counters":[]},{"line":"                 name","counters":[]},{"line":"      in","counters":[]},{"line":"      let ocaml_graphql_server_values =","counters":[]},{"line":"        List.map (function { enum_value; _ } -> enum_value) values","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"      in","counters":[]},{"line":"      { arg_typ = Schema.Arg.enum ?doc name ~values:ocaml_graphql_server_values","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"      ; to_json = Json.json_of_option (fun v -> `String (to_string values v))","counters":[{"col_start":36,"col_end":36,"count":0},{"col_start":48,"col_end":48,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    let arg ?doc name ~typ = Arg { name; typ; doc }","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"    let arg' ?doc name ~typ ~default = DefaultArg { name; typ; doc; default }","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Fields = struct","counters":[]},{"line":"    (** a record contraining the ocaml-graphql-server [field], its [name]","counters":[]},{"line":"        and a [to_string] function to be used when serializing a query *)","counters":[]},{"line":"    type ('ctx, 'src, 'args_to_json, 'out, 'subquery) field =","counters":[]},{"line":"      { field : ('ctx, 'src) Schema.field","counters":[]},{"line":"      ; to_json : 'args_to_json","counters":[]},{"line":"      ; name : string","counters":[]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    (** wrapper around the [field] typ *)","counters":[]},{"line":"    let field ?doc ?deprecated name ~typ ~(args : (_, 'out, _, _, _) Arg.args)","counters":[]},{"line":"        ~resolve : (_, _, _, 'out, _) field =","counters":[]},{"line":"      let to_json = Arg.field_to_json name args [] in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let args = Arg.to_ocaml_graphql_server_args args in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let field = Schema.field ?doc ?deprecated name ~args ~typ ~resolve in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      { name; field; to_json }","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    (** wrapper around the [io_field] typ*)","counters":[]},{"line":"    let io_field ?doc ?deprecated name ~typ","counters":[]},{"line":"        ~(args : (_, 'out, _, _, _) Arg.args) ~resolve :","counters":[]},{"line":"        (_, _, _, 'out, _) field =","counters":[]},{"line":"      let to_json = Arg.field_to_json name args [] in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let args = Arg.to_ocaml_graphql_server_args args in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let field = Schema.io_field ?doc ?deprecated name ~args ~typ ~resolve in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      { name; field; to_json }","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Abstract_fields = struct","counters":[]},{"line":"    type ('ctx, 'src, 'args_to_json, 'out, 'subquery) abstract_field =","counters":[]},{"line":"      { field : Schema.abstract_field; to_json : 'args_to_json; name : string }","counters":[]},{"line":"","counters":[]},{"line":"    (** wrapper around the [abstract_field] typ*)","counters":[]},{"line":"    let abstract_field ?doc ?deprecated name ~typ","counters":[]},{"line":"        ~(args : (_, 'out, _, _, _) Arg.args) :","counters":[]},{"line":"        (_, _, _, 'out, _) abstract_field =","counters":[]},{"line":"      let to_json = Arg.field_to_json name args [] in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let args = Arg.to_ocaml_graphql_server_args args in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let field = Schema.abstract_field ?doc ?deprecated name ~typ ~args in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      { name; field; to_json }","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Subscription_fields = struct","counters":[]},{"line":"    (** A record contraining the ocaml-graphql-server [subscription_fields], its [name]","counters":[]},{"line":"        and a [to_json] function to be used when serializing a query *)","counters":[]},{"line":"    type ('ctx, 'src, 'args_to_json, 'out, 'subquery) subscription_field =","counters":[]},{"line":"      { field : 'ctx Schema.subscription_field","counters":[]},{"line":"      ; to_json : 'args_to_json","counters":[]},{"line":"      ; name : string","counters":[]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    (** wrapper around the [subscription_field] typ*)","counters":[]},{"line":"    let subscription_field ?doc ?deprecated name ~typ","counters":[]},{"line":"        ~(args : (_, 'out, _, _, _) Arg.args) ~resolve :","counters":[]},{"line":"        (_, _, _, 'out, _) subscription_field =","counters":[]},{"line":"      let to_json = Arg.field_to_json name args [] in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let args = Arg.to_ocaml_graphql_server_args args in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let field =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Schema.subscription_field ?doc ?deprecated name ~args ~typ ~resolve","counters":[]},{"line":"      in","counters":[]},{"line":"      { name; field; to_json }","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let field ?doc ?deprecated name ~typ ~args ~resolve =","counters":[]},{"line":"    (Fields.field ?doc ?deprecated name ~typ ~args ~resolve).field","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":16,"col_end":16,"count":0}]},{"line":"","counters":[]},{"line":"  let io_field ?doc ?deprecated name ~typ ~args ~resolve =","counters":[]},{"line":"    (Fields.io_field ?doc ?deprecated name ~typ ~args ~resolve).field","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"","counters":[]},{"line":"  let subscription_field ?doc ?deprecated name ~typ ~args ~resolve =","counters":[]},{"line":"    (Subscription_fields.subscription_field ?doc ?deprecated name ~typ ~args","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"       ~resolve )","counters":[]},{"line":"      .field","counters":[]},{"line":"","counters":[]},{"line":"  let abstract_field ?doc ?deprecated name ~typ ~args =","counters":[]},{"line":"    (Abstract_fields.abstract_field ?doc ?deprecated name ~typ ~args).field","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"","counters":[]},{"line":"  let enum ?doc name ~values =","counters":[]},{"line":"    Schema.enum ?doc name","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ~values:(List.map (function v -> v.enum_value) values)","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"","counters":[]},{"line":"  (** The [Propagated] module contains the parts of the Schema we do not modify *)","counters":[]},{"line":"  module Propagated = struct","counters":[]},{"line":"    let obj = Schema.obj","counters":[]},{"line":"","counters":[]},{"line":"    let schema = Schema.schema","counters":[]},{"line":"","counters":[]},{"line":"    let interface = Schema.interface","counters":[]},{"line":"","counters":[]},{"line":"    let non_null = Schema.non_null","counters":[]},{"line":"","counters":[]},{"line":"    let string = Schema.string","counters":[]},{"line":"","counters":[]},{"line":"    let list = Schema.list","counters":[]},{"line":"","counters":[]},{"line":"    let bool = Schema.bool","counters":[]},{"line":"","counters":[]},{"line":"    let int = Schema.int","counters":[]},{"line":"","counters":[]},{"line":"    type ('a, 'b) typ = ('a, 'b) Schema.typ","counters":[]},{"line":"","counters":[]},{"line":"    let scalar = Schema.scalar","counters":[]},{"line":"","counters":[]},{"line":"    type ('a, 'b) abstract_value = ('a, 'b) Schema.abstract_value","counters":[]},{"line":"","counters":[]},{"line":"    let guid = Schema.guid","counters":[]},{"line":"","counters":[]},{"line":"    let add_type = Schema.add_type","counters":[]},{"line":"","counters":[]},{"line":"    let float = Schema.float","counters":[]},{"line":"","counters":[]},{"line":"    type 'ctx resolve_info = 'ctx Schema.resolve_info =","counters":[]},{"line":"      { ctx : 'ctx","counters":[]},{"line":"      ; field : Graphql_parser.field","counters":[]},{"line":"      ; fragments : Schema.fragment_map","counters":[]},{"line":"      ; variables : Schema.variable_map","counters":[]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    type 'a schema = 'a Schema.schema","counters":[]},{"line":"","counters":[]},{"line":"    type ('a, 'b) field = ('a, 'b) Schema.field","counters":[]},{"line":"","counters":[]},{"line":"    type 'a subscription_field = 'a Schema.subscription_field","counters":[]},{"line":"","counters":[]},{"line":"    type deprecated = Schema.deprecated","counters":[]},{"line":"","counters":[]},{"line":"    type variable_map = Schema.variable_map","counters":[]},{"line":"","counters":[]},{"line":"    type fragment_map = Schema.fragment_map","counters":[]},{"line":"","counters":[]},{"line":"    let execute = Schema.execute","counters":[]},{"line":"","counters":[]},{"line":"    type 'a response = 'a Schema.response","counters":[]},{"line":"","counters":[]},{"line":"    type variables = (string * Graphql_parser.const_value) list","counters":[]},{"line":"","counters":[]},{"line":"    type abstract_field = Schema.abstract_field","counters":[]},{"line":"","counters":[]},{"line":"    let union = Schema.union","counters":[]},{"line":"","counters":[]},{"line":"    type ('a, 'b) abstract_typ = ('a, 'b) Schema.abstract_typ","counters":[]},{"line":"","counters":[]},{"line":"    module StringMap = Schema.StringMap","counters":[]},{"line":"    module Io = Schema.Io","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  include Propagated","counters":[]},{"line":"end","counters":[]}]}