{"filename":"src/lib/crypto/kimchi_backend/common/poly_comm.ml","lines":[{"line":"open Intf","counters":[]},{"line":"open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"module type Inputs_intf = sig","counters":[]},{"line":"  module Base_field : sig","counters":[]},{"line":"    type t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Curve : sig","counters":[]},{"line":"    module Affine : sig","counters":[]},{"line":"      type t = Base_field.t * Base_field.t","counters":[]},{"line":"","counters":[]},{"line":"      module Backend : sig","counters":[]},{"line":"        type t = Base_field.t Kimchi_types.or_infinity","counters":[]},{"line":"","counters":[]},{"line":"        val zero : unit -> t","counters":[]},{"line":"","counters":[]},{"line":"        val create : Base_field.t -> Base_field.t -> t","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      val of_backend :","counters":[]},{"line":"        Backend.t -> (Base_field.t * Base_field.t) Pickles_types.Or_infinity.t","counters":[]},{"line":"    end","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Backend : sig","counters":[]},{"line":"    type t","counters":[]},{"line":"","counters":[]},{"line":"    val make :","counters":[]},{"line":"      Curve.Affine.Backend.t array -> Curve.Affine.Backend.t option -> t","counters":[]},{"line":"","counters":[]},{"line":"    val shifted : t -> Curve.Affine.Backend.t option","counters":[]},{"line":"","counters":[]},{"line":"    val unshifted : t -> Curve.Affine.Backend.t array","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"type 'a t =","counters":[]},{"line":"  [ `With_degree_bound of","counters":[]},{"line":"    ('a * 'a) Pickles_types.Or_infinity.t","counters":[]},{"line":"    Pickles_types.Plonk_types.Poly_comm.With_degree_bound.t","counters":[]},{"line":"  | `Without_degree_bound of","counters":[]},{"line":"    ('a * 'a) Pickles_types.Plonk_types.Poly_comm.Without_degree_bound.t ]","counters":[]},{"line":"","counters":[]},{"line":"module Make (Inputs : Inputs_intf) = struct","counters":[]},{"line":"  open Inputs","counters":[]},{"line":"  module Backend = Backend","counters":[]},{"line":"","counters":[]},{"line":"  type nonrec t = Base_field.t t","counters":[]},{"line":"","counters":[]},{"line":"  module G_affine = Curve.Affine.Backend","counters":[]},{"line":"","counters":[]},{"line":"  let g (a, b) = G_affine.create a b","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"","counters":[]},{"line":"  let g_vec arr = Array.map ~f:g arr","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"","counters":[]},{"line":"  let or_infinity_to_backend :","counters":[]},{"line":"      ('a * 'a) Pickles_types.Or_infinity.t -> 'a Kimchi_types.or_infinity =","counters":[]},{"line":"    function","counters":[]},{"line":"    | Infinity ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Infinity","counters":[]},{"line":"    | Finite (x, y) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Finite (x, y)","counters":[]},{"line":"","counters":[]},{"line":"  let or_infinity_of_backend :","counters":[]},{"line":"      'a Kimchi_types.or_infinity -> ('a * 'a) Pickles_types.Or_infinity.t =","counters":[]},{"line":"    function","counters":[]},{"line":"    | Infinity ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Infinity","counters":[]},{"line":"    | Finite (x, y) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Finite (x, y)","counters":[]},{"line":"","counters":[]},{"line":"  let with_degree_bound_to_backend","counters":[]},{"line":"      (commitment :","counters":[]},{"line":"        (Base_field.t * Base_field.t) Pickles_types.Or_infinity.t","counters":[]},{"line":"        Pickles_types.Plonk_types.Poly_comm.With_degree_bound.t ) : Backend.t =","counters":[]},{"line":"    Backend.make","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (Array.map ~f:or_infinity_to_backend commitment.unshifted)","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"      (Some (or_infinity_to_backend commitment.shifted))","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"","counters":[]},{"line":"  let without_degree_bound_to_backend","counters":[]},{"line":"      (commitment :","counters":[]},{"line":"        (Base_field.t * Base_field.t)","counters":[]},{"line":"        Pickles_types.Plonk_types.Poly_comm.Without_degree_bound.t ) : Backend.t","counters":[]},{"line":"      =","counters":[]},{"line":"    Backend.make","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (Array.map ~f:(fun x -> Kimchi_types.Finite (fst x, snd x)) commitment)","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":53,"col_end":53,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"      None","counters":[]},{"line":"","counters":[]},{"line":"  let to_backend (t : t) : Backend.t =","counters":[]},{"line":"    match t with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | `With_degree_bound t ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        with_degree_bound_to_backend t","counters":[]},{"line":"    | `Without_degree_bound t ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        without_degree_bound_to_backend t","counters":[]},{"line":"","counters":[]},{"line":"  let of_backend' (t : Backend.t) =","counters":[]},{"line":"    ( Backend.unshifted t","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"    , Option.map (Backend.shifted t) ~f:Curve.Affine.of_backend )","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"","counters":[]},{"line":"  let of_backend_with_degree_bound (t : Backend.t) : t =","counters":[]},{"line":"    let open Pickles_types.Plonk_types.Poly_comm in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    match Backend.shifted t with","counters":[]},{"line":"    | None ->","counters":[]},{"line":"        assert false","counters":[]},{"line":"    | Some shifted ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let shifted = or_infinity_of_backend shifted in","counters":[]},{"line":"        let unshifted =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Backend.unshifted t |> Array.map ~f:or_infinity_of_backend","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"        in","counters":[]},{"line":"        `With_degree_bound { unshifted; shifted }","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"  (*","counters":[]},{"line":"     type 'a t =","counters":[]},{"line":"       [ `With_degree_bound of","counters":[]},{"line":"         ('a * 'a) Pickles_types.Or_infinity.t","counters":[]},{"line":"         Pickles_types.Plonk_types.Poly_comm.With_degree_bound.t","counters":[]},{"line":"       | `Without_degree_bound of","counters":[]},{"line":"         ('a * 'a) Pickles_types.Plonk_types.Poly_comm.Without_degree_bound.t","counters":[]},{"line":"       ]","counters":[]},{"line":"  *)","counters":[]},{"line":"","counters":[]},{"line":"  let of_backend_without_degree_bound (t : Backend.t) =","counters":[]},{"line":"    let open Pickles_types.Plonk_types.Poly_comm in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let unshifted = Backend.unshifted t in","counters":[]},{"line":"    match Backend.shifted t with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        `Without_degree_bound","counters":[]},{"line":"          (Array.map unshifted ~f:(function","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"            | Infinity ->","counters":[]},{"line":"                assert false","counters":[]},{"line":"            | Finite (x, y) ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (x, y) ) )","counters":[]},{"line":"    | _ ->","counters":[]},{"line":"        assert false","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}