{"filename":"src/lib/sync_handler/sync_handler.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Async","counters":[]},{"line":"open Mina_base","counters":[]},{"line":"module Ledger = Mina_ledger.Ledger","counters":[]},{"line":"module Sync_ledger = Mina_ledger.Sync_ledger","counters":[]},{"line":"open Frontier_base","counters":[]},{"line":"open Network_peer","counters":[]},{"line":"","counters":[]},{"line":"module type CONTEXT = sig","counters":[]},{"line":"  val logger : Logger.t","counters":[]},{"line":"","counters":[]},{"line":"  val precomputed_values : Precomputed_values.t","counters":[]},{"line":"","counters":[]},{"line":"  val constraint_constants : Genesis_constants.Constraint_constants.t","counters":[]},{"line":"","counters":[]},{"line":"  val consensus_constants : Consensus.Constants.t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type Inputs_intf = sig","counters":[]},{"line":"  module Transition_frontier : module type of Transition_frontier","counters":[]},{"line":"","counters":[]},{"line":"  module Best_tip_prover :","counters":[]},{"line":"    Mina_intf.Best_tip_prover_intf","counters":[]},{"line":"      with type transition_frontier := Transition_frontier.t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make (Inputs : Inputs_intf) :","counters":[]},{"line":"  Mina_intf.Sync_handler_intf","counters":[]},{"line":"    with type transition_frontier := Inputs.Transition_frontier.t = struct","counters":[]},{"line":"  open Inputs","counters":[]},{"line":"","counters":[]},{"line":"  let find_in_root_history frontier state_hash =","counters":[]},{"line":"    let open Transition_frontier.Extensions in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let root_history =","counters":[]},{"line":"      get_extension (Transition_frontier.extensions frontier) Root_history","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"    in","counters":[]},{"line":"    Root_history.lookup root_history state_hash","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let protocol_states_in_root_history frontier state_hash =","counters":[]},{"line":"    let open Transition_frontier.Extensions in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let root_history =","counters":[]},{"line":"      get_extension (Transition_frontier.extensions frontier) Root_history","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"    in","counters":[]},{"line":"    Root_history.protocol_states_for_scan_state root_history state_hash","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let get_ledger_by_hash ~frontier ledger_hash =","counters":[]},{"line":"    let root_ledger =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Ledger.Any_ledger.cast_database_to_mask (module Ledger.Db)","counters":[]},{"line":"      @@ Transition_frontier.root_snarked_ledger frontier","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"    in","counters":[]},{"line":"    let staking_epoch_ledger =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Transition_frontier.consensus_local_state frontier","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"      |> Consensus.Data.Local_state.staking_epoch_ledger","counters":[]},{"line":"    in","counters":[]},{"line":"    let next_epoch_ledger =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Transition_frontier.consensus_local_state frontier","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"      |> Consensus.Data.Local_state.next_epoch_ledger","counters":[]},{"line":"    in","counters":[]},{"line":"    if","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Ledger_hash.equal ledger_hash","counters":[]},{"line":"        (Ledger.Any_ledger.M.merkle_root root_ledger)","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"    then Some root_ledger","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"    else if","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"      Ledger_hash.equal ledger_hash","counters":[]},{"line":"        (Consensus.Data.Local_state.Snapshot.Ledger_snapshot.merkle_root","counters":[{"col_start":71,"col_end":71,"count":0}]},{"line":"           staking_epoch_ledger )","counters":[]},{"line":"    then","counters":[]},{"line":"      match staking_epoch_ledger with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Consensus.Data.Local_state.Snapshot.Ledger_snapshot.Genesis_epoch_ledger","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          _ ->","counters":[]},{"line":"          None","counters":[]},{"line":"      | Ledger_db ledger ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Some","counters":[]},{"line":"            (Ledger.Any_ledger.cast_database_to_mask (module Ledger.Db) ledger)","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"    else if","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"      Ledger_hash.equal ledger_hash","counters":[]},{"line":"        (Consensus.Data.Local_state.Snapshot.Ledger_snapshot.merkle_root","counters":[{"col_start":71,"col_end":71,"count":0}]},{"line":"           next_epoch_ledger )","counters":[]},{"line":"    then","counters":[]},{"line":"      match next_epoch_ledger with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Consensus.Data.Local_state.Snapshot.Ledger_snapshot.Genesis_epoch_ledger","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          _ ->","counters":[]},{"line":"          None","counters":[]},{"line":"      | Ledger_db ledger ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Some","counters":[]},{"line":"            (Ledger.Any_ledger.cast_database_to_mask (module Ledger.Db) ledger)","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"    else None","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"  let answer_query :","counters":[]},{"line":"         frontier:Inputs.Transition_frontier.t","counters":[]},{"line":"      -> Ledger_hash.t","counters":[]},{"line":"      -> Sync_ledger.Query.t Envelope.Incoming.t","counters":[]},{"line":"      -> logger:Logger.t","counters":[]},{"line":"      -> trust_system:Trust_system.t","counters":[]},{"line":"      -> Sync_ledger.Answer.t Option.t Deferred.t =","counters":[]},{"line":"   fun ~frontier hash query ~logger ~trust_system ->","counters":[]},{"line":"    match get_ledger_by_hash ~frontier hash with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        return None","counters":[]},{"line":"    | Some ledger ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let responder =","counters":[]},{"line":"          Sync_ledger.Any_ledger.Responder.create ledger ignore ~logger","counters":[]},{"line":"            ~trust_system","counters":[]},{"line":"        in","counters":[]},{"line":"        Sync_ledger.Any_ledger.Responder.answer_query responder query","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"  let get_staged_ledger_aux_and_pending_coinbases_at_hash ~frontier state_hash =","counters":[]},{"line":"    let open Option.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let protocol_states scan_state =","counters":[]},{"line":"      Staged_ledger.Scan_state.required_state_hashes scan_state","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"      |> State_hash.Set.to_list","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"      |> List.fold_until ~init:(Some [])","counters":[]},{"line":"           ~f:(fun acc hash ->","counters":[]},{"line":"             match","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"               Option.map2","counters":[]},{"line":"                 (Transition_frontier.find_protocol_state frontier hash)","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"                 acc ~f:List.cons","counters":[]},{"line":"             with","counters":[]},{"line":"             | None ->","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                 Stop None","counters":[]},{"line":"             | Some acc' ->","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                 Continue (Some acc') )","counters":[]},{"line":"           ~finish:Fn.id","counters":[]},{"line":"    in","counters":[]},{"line":"    match","counters":[]},{"line":"      let%bind breadcrumb = Transition_frontier.find frontier state_hash in","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"      let staged_ledger =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Transition_frontier.Breadcrumb.staged_ledger breadcrumb","counters":[]},{"line":"      in","counters":[]},{"line":"      let scan_state = Staged_ledger.scan_state staged_ledger in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let merkle_root =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Staged_ledger.hash staged_ledger |> Staged_ledger_hash.ledger_hash","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"      in","counters":[]},{"line":"      let%map scan_state_protocol_states = protocol_states scan_state in","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"      let pending_coinbase =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Staged_ledger.pending_coinbase_collection staged_ledger","counters":[]},{"line":"      in","counters":[]},{"line":"      (scan_state, merkle_root, pending_coinbase, scan_state_protocol_states)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    with","counters":[]},{"line":"    | Some res ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Some res","counters":[]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let open Root_data.Historical in","counters":[]},{"line":"        let%bind root = find_in_root_history frontier state_hash in","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"        let%map scan_state_protocol_states =","counters":[]},{"line":"          protocol_states_in_root_history frontier state_hash","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"        in","counters":[]},{"line":"        ( scan_state root","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"        , staged_ledger_target_ledger_hash root","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"        , pending_coinbase root","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"        , scan_state_protocol_states )","counters":[]},{"line":"","counters":[]},{"line":"  let get_transition_chain ~frontier hashes =","counters":[]},{"line":"    let open Option.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let%bind () =","counters":[]},{"line":"      let requested = List.length hashes in","counters":[]},{"line":"      if requested <= Transition_frontier.max_catchup_chunk_length then Some ()","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":72,"col_end":72,"count":0}]},{"line":"      else (","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"        [%log' trace (Logger.create ())]","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"          ~metadata:[ (\"n\", `Int requested) ]","counters":[]},{"line":"          \"get_transition_chain requested $n > %d hashes\"","counters":[]},{"line":"          Transition_frontier.max_catchup_chunk_length ;","counters":[]},{"line":"        None )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    in","counters":[]},{"line":"    let get hash =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let%map validated_transition =","counters":[]},{"line":"        Option.merge","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"          Transition_frontier.(","counters":[]},{"line":"            find frontier hash >>| Breadcrumb.validated_transition)","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"          ( find_in_root_history frontier hash","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"          >>| Root_data.Historical.transition )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          ~f:Fn.const","counters":[]},{"line":"      in","counters":[]},{"line":"      With_hash.data @@ Mina_block.Validated.forget validated_transition","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"    in","counters":[]},{"line":"    match Transition_frontier.catchup_tree frontier with","counters":[]},{"line":"    | Full _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (* Super catchup *)","counters":[]},{"line":"        Option.return @@ List.filter_map hashes ~f:get","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"    | Hash _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (* Normal catchup *)","counters":[]},{"line":"        Option.all @@ List.map hashes ~f:get","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"  let best_tip_path ~frontier =","counters":[]},{"line":"    let rec go acc b =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let acc = Breadcrumb.state_hash b :: acc in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"      match Transition_frontier.find frontier (Breadcrumb.parent_hash b) with","counters":[{"col_start":68,"col_end":68,"count":0}]},{"line":"      | None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          acc","counters":[]},{"line":"      | Some b' ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          go acc b'","counters":[]},{"line":"    in","counters":[]},{"line":"    go [] (Transition_frontier.best_tip frontier)","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"","counters":[]},{"line":"  module Root = struct","counters":[]},{"line":"    let prove ~context:(module Context : CONTEXT) ~frontier seen_consensus_state","counters":[]},{"line":"        =","counters":[]},{"line":"      let module Context = struct","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        include Context","counters":[]},{"line":"","counters":[]},{"line":"        let logger =","counters":[]},{"line":"          Logger.extend logger [ (\"selection_context\", `String \"Root.prove\") ]","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"      end in","counters":[]},{"line":"      let open Option.Let_syntax in","counters":[]},{"line":"      let%bind best_tip_with_witness =","counters":[]},{"line":"        Best_tip_prover.prove ~context:(module Context) frontier","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"      in","counters":[]},{"line":"      let is_tip_better =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Consensus.Hooks.equal_select_status","counters":[]},{"line":"          (Consensus.Hooks.select","counters":[]},{"line":"             ~context:(module Context)","counters":[]},{"line":"             ~existing:","counters":[]},{"line":"               (With_hash.map ~f:Mina_block.consensus_state","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                  best_tip_with_witness.data )","counters":[]},{"line":"             ~candidate:seen_consensus_state )","counters":[]},{"line":"          `Keep","counters":[]},{"line":"      in","counters":[]},{"line":"      let%map () = Option.some_if is_tip_better () in","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"      { best_tip_with_witness with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        data = With_hash.data best_tip_with_witness.data","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    let verify ~context:(module Context : CONTEXT) ~verifier ~genesis_constants","counters":[]},{"line":"        observed_state peer_root =","counters":[]},{"line":"      let module Context = struct","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        include Context","counters":[]},{"line":"","counters":[]},{"line":"        let logger =","counters":[]},{"line":"          Logger.extend logger [ (\"selection_context\", `String \"Root.verify\") ]","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"      end in","counters":[]},{"line":"      let open Context in","counters":[]},{"line":"      let open Deferred.Result.Let_syntax in","counters":[]},{"line":"      let%bind ( (`Root _, `Best_tip (best_tip_transition, _)) as","counters":[]},{"line":"               verified_witness ) =","counters":[]},{"line":"        Best_tip_prover.verify ~verifier ~genesis_constants ~precomputed_values","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"          peer_root","counters":[]},{"line":"      in","counters":[]},{"line":"      let is_before_best_tip candidate =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Consensus.Hooks.equal_select_status","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (Consensus.Hooks.select","counters":[]},{"line":"             ~context:(module Context)","counters":[]},{"line":"             ~existing:","counters":[]},{"line":"               (With_hash.map ~f:Mina_block.consensus_state best_tip_transition)","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"             ~candidate )","counters":[]},{"line":"          `Keep","counters":[]},{"line":"      in","counters":[]},{"line":"      let%map () =","counters":[]},{"line":"        Deferred.return","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"          (Result.ok_if_true","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"             (is_before_best_tip observed_state)","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"             ~error:","counters":[]},{"line":"               (Error.createf","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                  !\"Peer lied about it's best tip %{sexp:State_hash.t}\"","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"                  (State_hash.With_state_hashes.state_hash best_tip_transition) ) )","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"      in","counters":[]},{"line":"      verified_witness","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"include Make (struct","counters":[]},{"line":"  module Transition_frontier = Transition_frontier","counters":[]},{"line":"  module Best_tip_prover = Best_tip_prover","counters":[]},{"line":"end)","counters":[{"col_start":3,"col_end":3,"count":2}]},{"line":"","counters":[]},{"line":"(* TODO: port these tests *)","counters":[]},{"line":"(*","counters":[]},{"line":"let%test_module \"Sync_handler\" =","counters":[]},{"line":"  ( module struct","counters":[]},{"line":"    let logger = Logger.null ()","counters":[]},{"line":"","counters":[]},{"line":"    let hb_logger = Logger.create ()","counters":[]},{"line":"","counters":[]},{"line":"    let pids = Child_processes.Termination.create_pid_table ()","counters":[]},{"line":"","counters":[]},{"line":"    let trust_system = Trust_system.null ()","counters":[]},{"line":"","counters":[]},{"line":"    let f_with_verifier ~f ~logger ~pids =","counters":[]},{"line":"      let%map verifier = Verifier.create ~logger ~pids in","counters":[]},{"line":"      f ~logger ~verifier","counters":[]},{"line":"","counters":[]},{"line":"    let%test \"sync with ledgers from another peer via glue_sync_ledger\" =","counters":[]},{"line":"      Backtrace.elide := false ;","counters":[]},{"line":"      Printexc.record_backtrace true ;","counters":[]},{"line":"      heartbeat_flag := true ;","counters":[]},{"line":"      Ledger.with_ephemeral_ledger ~f:(fun dest_ledger ->","counters":[]},{"line":"          Thread_safe.block_on_async_exn (fun () ->","counters":[]},{"line":"              print_heartbeat hb_logger |> don't_wait_for ;","counters":[]},{"line":"              let%bind frontier =","counters":[]},{"line":"                create_root_frontier ~logger ~pids Test_genesis_ledger.accounts","counters":[]},{"line":"              in","counters":[]},{"line":"              let source_ledger =","counters":[]},{"line":"                Transition_frontier.For_tests.root_snarked_ledger frontier","counters":[]},{"line":"                |> Ledger.of_database","counters":[]},{"line":"              in","counters":[]},{"line":"              let desired_root = Ledger.merkle_root source_ledger in","counters":[]},{"line":"              let sync_ledger =","counters":[]},{"line":"                Sync_ledger.Mask.create dest_ledger ~logger ~trust_system","counters":[]},{"line":"              in","counters":[]},{"line":"              let query_reader = Sync_ledger.Mask.query_reader sync_ledger in","counters":[]},{"line":"              let answer_writer = Sync_ledger.Mask.answer_writer sync_ledger in","counters":[]},{"line":"              let peer =","counters":[]},{"line":"                Network_peer.Peer.create Unix.Inet_addr.localhost","counters":[]},{"line":"                  ~discovery_port:0 ~communication_port:1","counters":[]},{"line":"              in","counters":[]},{"line":"              let network =","counters":[]},{"line":"                Network.create_stub ~logger","counters":[]},{"line":"                  ~ip_table:","counters":[]},{"line":"                    (Hashtbl.of_alist_exn","counters":[]},{"line":"                       (module Unix.Inet_addr)","counters":[]},{"line":"                       [(peer.host, frontier)])","counters":[]},{"line":"                  ~peers:(Hash_set.of_list (module Network_peer.Peer) [peer])","counters":[]},{"line":"              in","counters":[]},{"line":"              Network.glue_sync_ledger network query_reader answer_writer ;","counters":[]},{"line":"              match%map","counters":[]},{"line":"                Sync_ledger.Mask.fetch sync_ledger desired_root ~data:()","counters":[]},{"line":"                  ~equal:(fun () () -> true)","counters":[]},{"line":"              with","counters":[]},{"line":"              | `Ok synced_ledger ->","counters":[]},{"line":"                  heartbeat_flag := false ;","counters":[]},{"line":"                  Ledger_hash.equal","counters":[]},{"line":"                    (Ledger.merkle_root dest_ledger)","counters":[]},{"line":"                    (Ledger.merkle_root source_ledger)","counters":[]},{"line":"                  && Ledger_hash.equal","counters":[]},{"line":"                       (Ledger.merkle_root synced_ledger)","counters":[]},{"line":"                       (Ledger.merkle_root source_ledger)","counters":[]},{"line":"              | `Target_changed _ ->","counters":[]},{"line":"                  heartbeat_flag := false ;","counters":[]},{"line":"                  failwith \"target of sync_ledger should not change\" ) )","counters":[]},{"line":"","counters":[]},{"line":"    let to_external_transition breadcrumb =","counters":[]},{"line":"      Transition_frontier.Breadcrumb.validated_transition breadcrumb","counters":[]},{"line":"      |> Mina_block.Validated.forget","counters":[]},{"line":"","counters":[]},{"line":"    let%test \"a node should be able to give a valid proof of their root\" =","counters":[]},{"line":"      heartbeat_flag := true ;","counters":[]},{"line":"      let max_length = 4 in","counters":[]},{"line":"      (* Generating this many breadcrumbs will ernsure the transition_frontier to be full  *)","counters":[]},{"line":"      let num_breadcrumbs = max_length + 2 in","counters":[]},{"line":"      Thread_safe.block_on_async_exn (fun () ->","counters":[]},{"line":"          print_heartbeat hb_logger |> don't_wait_for ;","counters":[]},{"line":"          let%bind frontier =","counters":[]},{"line":"            create_root_frontier ~logger ~pids Test_genesis_ledger.accounts","counters":[]},{"line":"          in","counters":[]},{"line":"          let%bind () =","counters":[]},{"line":"            build_frontier_randomly frontier","counters":[]},{"line":"              ~gen_root_breadcrumb_builder:","counters":[]},{"line":"                (gen_linear_breadcrumbs ~logger ~pids ~trust_system","counters":[]},{"line":"                   ~size:num_breadcrumbs","counters":[]},{"line":"                   ~accounts_with_secret_keys:Test_genesis_ledger.accounts)","counters":[]},{"line":"          in","counters":[]},{"line":"          let seen_transition =","counters":[]},{"line":"            Transition_frontier.(","counters":[]},{"line":"              all_breadcrumbs frontier |> List.permute |> List.hd_exn","counters":[]},{"line":"              |> Breadcrumb.validated_transition)","counters":[]},{"line":"          in","counters":[]},{"line":"          let observed_state =","counters":[]},{"line":"            Mina_block.Validated.protocol_state seen_transition","counters":[]},{"line":"            |> Protocol_state.consensus_state","counters":[]},{"line":"          in","counters":[]},{"line":"          let root_with_proof =","counters":[]},{"line":"            Option.value_exn ~message:\"Could not produce an ancestor proof\"","counters":[]},{"line":"              (Sync_handler.Root.prove ~logger ~frontier observed_state)","counters":[]},{"line":"          in","counters":[]},{"line":"          let%bind verify =","counters":[]},{"line":"            f_with_verifier ~f:Sync_handler.Root.verify ~logger ~pids","counters":[]},{"line":"          in","counters":[]},{"line":"          let%map `Root (root_transition, _), `Best_tip (best_tip_transition, _)","counters":[]},{"line":"              =","counters":[]},{"line":"            verify observed_state root_with_proof |> Deferred.Or_error.ok_exn","counters":[]},{"line":"          in","counters":[]},{"line":"          heartbeat_flag := false ;","counters":[]},{"line":"          Mina_block.(","counters":[]},{"line":"            equal","counters":[]},{"line":"              (With_hash.data root_transition)","counters":[]},{"line":"              (to_external_transition (Transition_frontier.root frontier))","counters":[]},{"line":"            && equal","counters":[]},{"line":"                 (With_hash.data best_tip_transition)","counters":[]},{"line":"                 (to_external_transition","counters":[]},{"line":"                    (Transition_frontier.best_tip frontier))) )","counters":[]},{"line":"  end )","counters":[]},{"line":"*)","counters":[]}]}