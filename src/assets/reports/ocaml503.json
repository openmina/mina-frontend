{"filename":"src/lib/network_pool/writer_result.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"module Tree = struct","counters":[]},{"line":"  type 'a t = Empty | Leaf of 'a | Node of 'a t * 'a t [@@deriving sexp]","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":14,"col_end":14,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"","counters":[]},{"line":"  let to_list (t : 'a t) : 'a list =","counters":[]},{"line":"    let rec go acc t =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      match t with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Empty ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          acc","counters":[]},{"line":"      | Leaf x ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          x :: acc","counters":[]},{"line":"      | Node (l, r) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          go (go acc l) r","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"    in","counters":[]},{"line":"    List.rev (go [] t)","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"","counters":[]},{"line":"  let fold t ~init ~f =","counters":[]},{"line":"    let rec go acc t =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      match t with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Empty ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          acc","counters":[]},{"line":"      | Leaf x ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          f acc x","counters":[]},{"line":"      | Node (l, r) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          go (go acc l) r","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"    in","counters":[]},{"line":"    go init t","counters":[]},{"line":"","counters":[]},{"line":"  let return x = Leaf x","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"","counters":[]},{"line":"  let append t1 t2 =","counters":[]},{"line":"    match t1 with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Empty ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        t2","counters":[]},{"line":"    | _ -> (","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        match t2 with Empty -> t1 | _ -> Node (t1, t2) )","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"type ('a, 'x, 'e) t0 = ('a * 'x Tree.t, 'e) Result.t","counters":[]},{"line":"","counters":[]},{"line":"module type S = sig","counters":[]},{"line":"  include Monad.S3","counters":[]},{"line":"","counters":[]},{"line":"  val of_result : ('a, 'e) Result.t -> ('a, 'x, 'e) t","counters":[]},{"line":"","counters":[]},{"line":"  val write : 'x -> (unit, 'x, 'e) t","counters":[]},{"line":"","counters":[]},{"line":"  val write_all : 'x Tree.t -> (unit, 'x, 'e) t","counters":[]},{"line":"","counters":[]},{"line":"  val lift : ('a, 'x, 'e) t0 -> ('a, 'x, 'e) t","counters":[]},{"line":"","counters":[]},{"line":"  val catch :","counters":[]},{"line":"    ('a, 'x, 'e) t -> f:(('a, 'x, 'e) t0 -> ('b, 'x, 'e) t) -> ('b, 'x, 'e) t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module T = struct","counters":[]},{"line":"  type ('a, 'x, 'e) t = ('a * 'x Tree.t, 'e) Result.t","counters":[]},{"line":"","counters":[]},{"line":"  let map (type a b x e) (t : (a, x, e) t) ~(f : a -> b) : (b, x, e) t =","counters":[]},{"line":"    Result.map t ~f:(fun (x, w) -> (f x, w))","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"","counters":[]},{"line":"  let return (type a x e) (x : a) : (a, x, e) t = Ok (x, Empty)","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"","counters":[]},{"line":"  let map = `Custom map","counters":[]},{"line":"","counters":[]},{"line":"  let bind (type a b x e) (t : (a, x, e) t) ~(f : a -> (b, x, e) t) :","counters":[]},{"line":"      (b, x, e) t =","counters":[]},{"line":"    Result.bind t ~f:(fun (a, w1) ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        Result.map (f a) ~f:(fun (b, w2) -> (b, Tree.append w1 w2)) )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"include T","counters":[]},{"line":"include Monad.Make3 (T)","counters":[]},{"line":"","counters":[]},{"line":"let catch (type a b x e) (t : (a, x, e) t) ~(f : (a, x, e) t0 -> (b, x, e) t) :","counters":[]},{"line":"    (b, x, e) t =","counters":[]},{"line":"  f t","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let lift = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"let write (type x e) (x : x) : (unit, x, e) t = Ok ((), Leaf x)","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"","counters":[]},{"line":"let write_all (type x e) (x : x Tree.t) : (unit, x, e) t = Ok ((), x)","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"","counters":[]},{"line":"let run (t : ('a, 'x, 'e) t) : ('a * 'x Tree.t, 'e) Result.t = t","counters":[{"col_start":63,"col_end":63,"count":0}]},{"line":"","counters":[]},{"line":"let of_result (type a e) (t : (a, e) Result.t) : (a, _, e) t =","counters":[]},{"line":"  Result.map t ~f:(fun x -> (x, Tree.Empty))","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"","counters":[]},{"line":"module Deferred = struct","counters":[]},{"line":"  module T = struct","counters":[]},{"line":"    (* We special case undeferred values for efficiency. It is not semantically","counters":[]},{"line":"       necessary (i.e., we could get away with just using","counters":[]},{"line":"","counters":[]},{"line":"       ('a * 'x Tree.t, 'e) Async.Deferred.Result.t","counters":[]},{"line":"","counters":[]},{"line":"       if we didn't care about efficiency.","counters":[]},{"line":"    *)","counters":[]},{"line":"    type ('a, 'x, 'e) t =","counters":[]},{"line":"      | Undeferred of ('a * 'x Tree.t, 'e) Result.t","counters":[]},{"line":"      | Deferred of ('a * 'x Tree.t, 'e) Async.Deferred.Result.t","counters":[]},{"line":"","counters":[]},{"line":"    let map (type a b x e) (t : (a, x, e) t) ~(f : a -> b) : (b, x, e) t =","counters":[]},{"line":"      match t with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Undeferred t ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Undeferred (map t ~f)","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"      | Deferred t ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Deferred (Async.Deferred.map t ~f:(map ~f))","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"    let return (type a x e) (x : a) : (a, x, e) t = Undeferred (return x)","counters":[{"col_start":52,"col_end":52,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"","counters":[]},{"line":"    let map = `Custom map","counters":[]},{"line":"","counters":[]},{"line":"    let bind (type a b x e) (t : (a, x, e) t) ~(f : a -> (b, x, e) t) :","counters":[]},{"line":"        (b, x, e) t =","counters":[]},{"line":"      let g w1 (b, w2) = (b, Tree.append w1 w2) in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"      match t with","counters":[]},{"line":"      | Undeferred (Error e) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Undeferred (Error e)","counters":[]},{"line":"      | Undeferred (Ok (a, w1)) -> (","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          match f a with","counters":[]},{"line":"          | Undeferred rb ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Undeferred (Result.map rb ~f:(g w1))","counters":[{"col_start":35,"col_end":35,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"          | Deferred drb ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Deferred (Async.Deferred.Result.map drb ~f:(g w1)) )","counters":[{"col_start":48,"col_end":48,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"      | Deferred d ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let open Async in","counters":[]},{"line":"          let open Deferred.Result.Let_syntax in","counters":[]},{"line":"          Deferred","counters":[]},{"line":"            (let%bind a, w1 = d in","counters":[]},{"line":"             match f a with","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"             | Undeferred rb ->","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                 Deferred.return (Result.map rb ~f:(g w1))","counters":[{"col_start":43,"col_end":43,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"             | Deferred drb ->","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                 Deferred.Result.map drb ~f:(g w1) )","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"","counters":[]},{"line":"    let lift (type a x e) (t : (a, x, e) T.t) : (a, x, e) t = Undeferred t","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  include T","counters":[]},{"line":"  include Monad.Make3 (T)","counters":[]},{"line":"","counters":[]},{"line":"  let catch (type a b x e) (t : (a, x, e) t) ~(f : (a, x, e) t0 -> (b, x, e) t)","counters":[]},{"line":"      : (b, x, e) t =","counters":[]},{"line":"    match t with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Undeferred t ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        f t","counters":[]},{"line":"    | Deferred t ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Deferred","counters":[]},{"line":"          (Async.Deferred.bind t ~f:(fun t ->","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"               match f t with Undeferred t -> Async.return t | Deferred t -> t )","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"          )","counters":[]},{"line":"","counters":[]},{"line":"  let write x = lift (write x)","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"","counters":[]},{"line":"  let write_all x = lift (write_all x)","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"","counters":[]},{"line":"  let of_result (type a e) (t : (a, e) Result.t) : (a, _, e) t =","counters":[]},{"line":"    lift (of_result t)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"","counters":[]},{"line":"  let run (t : ('a, 'x, 'e) t) : ('a * 'x Tree.t, 'e) Async.Deferred.Result.t =","counters":[]},{"line":"    match t with Undeferred t -> Async.Deferred.return t | Deferred t -> t","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":1}]}]}