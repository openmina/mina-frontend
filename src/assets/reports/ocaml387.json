{"filename":"src/lib/mina_wire_types/currency.ml","lines":[{"line":"open Utils","counters":[]},{"line":"","counters":[]},{"line":"(** We first define a [Types] module, with the expected final signature of this","counters":[]},{"line":"    module (hidden types should be hidden here) *)","counters":[]},{"line":"module Types = struct","counters":[]},{"line":"  module type S = sig","counters":[]},{"line":"    module Fee : V1S0","counters":[]},{"line":"","counters":[]},{"line":"    module Amount : V1S0","counters":[]},{"line":"","counters":[]},{"line":"    module Balance : V1S0","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(** We define a module type [Concrete], where we replace hidden types in","counters":[]},{"line":"    {!Types.S} by their actual definition. This module will not be exported. *)","counters":[]},{"line":"module type Concrete =","counters":[]},{"line":"  Types.S","counters":[]},{"line":"    with type Fee.V1.t = Unsigned.UInt64.t","counters":[]},{"line":"     and type Amount.V1.t = Unsigned.UInt64.t","counters":[]},{"line":"     and type Balance.V1.t = Unsigned.UInt64.t","counters":[]},{"line":"","counters":[]},{"line":"(** Then we define the actual module [M] with its type definitions. It must be","counters":[]},{"line":"    compatible with {!Concrete} *)","counters":[]},{"line":"module M = struct","counters":[]},{"line":"  module Fee = struct","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type t = Unsigned.UInt64.t","counters":[]},{"line":"    end","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Amount = struct","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type t = Unsigned.UInt64.t","counters":[]},{"line":"    end","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Balance = struct","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type t = Amount.V1.t","counters":[]},{"line":"    end","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(** [Local_sig] is the type of functors which receive a {!Types.S} module and","counters":[]},{"line":"    return a complete module signature (with operations etc.) based on these","counters":[]},{"line":"    types. It will be expected to be given by the implementation module. *)","counters":[]},{"line":"module type Local_sig = Signature(Types).S","counters":[]},{"line":"","counters":[]},{"line":"(** To make a full module, the implementation module will have to use [Make] and","counters":[]},{"line":"    provide: (i) a {!Local_sig} functor to know the final signature of the","counters":[]},{"line":"    module and (ii) a functor which takes the concrete types defined here and","counters":[]},{"line":"    make the actual full module, adding type equalities where needed. *)","counters":[]},{"line":"module Make","counters":[]},{"line":"    (Signature : Local_sig) (F : functor (A : Concrete) -> Signature(A).S) =","counters":[]},{"line":"  F (M)","counters":[]},{"line":"","counters":[]},{"line":"(** Finally, we include our module to make the types available to everyone (they","counters":[]},{"line":"    will be hidden in the MLI *)","counters":[]},{"line":"include M","counters":[]}]}