{"filename":"src/lib/merkle_ledger/location.ml","lines":[{"line":"open Core","counters":[]},{"line":"open Unsigned","counters":[]},{"line":"","counters":[]},{"line":"(* add functions to library module Bigstring so we can derive hash for the type t below *)","counters":[]},{"line":"module Bigstring = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type t = Core_kernel.Bigstring.Stable.V1.t [@@deriving sexp, compare]","counters":[{"col_start":6,"col_end":6,"count":2},{"col_start":11,"col_end":11,"count":1},{"col_start":74,"col_end":74,"count":5}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"      let equal = Bigstring.equal","counters":[]},{"line":"","counters":[]},{"line":"      let hash t = Bigstring.to_string t |> String.hash","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"      let hash_fold_t hash_state t =","counters":[]},{"line":"        String.hash_fold_t hash_state (Bigstring.to_string t)","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  [%%define_locally","counters":[]},{"line":"  Bigstring.(get, length, equal, create, to_string, set, blit, sub)]","counters":[]},{"line":"","counters":[]},{"line":"  include Hashable.Make (Stable.Latest)","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module T = struct","counters":[]},{"line":"  (* Locations are a bitstring prefixed by a byte. In the case of accounts, the prefix","counters":[]},{"line":"   * byte is 0xfe. In the case of a hash node in the merkle tree, the prefix is between","counters":[]},{"line":"   * 1 and N (where N is the height of the root of the merkle tree, with 1 representing","counters":[]},{"line":"   * the leafs of the tree, and N representing the root of the merkle tree. For account","counters":[]},{"line":"   * and node locations, the bitstring represents the path in the tree where that node exists.","counters":[]},{"line":"   * For all other locations (generic locations), the prefix is 0xff. Generic locations can contain","counters":[]},{"line":"   * any bitstring.","counters":[]},{"line":"   *)","counters":[]},{"line":"","counters":[]},{"line":"  module Addr = Merkle_address","counters":[]},{"line":"","counters":[]},{"line":"  module Prefix = struct","counters":[]},{"line":"    let generic = UInt8.of_int 0xff","counters":[{"col_start":29,"col_end":29,"count":1}]},{"line":"","counters":[]},{"line":"    let account = UInt8.of_int 0xfe","counters":[{"col_start":29,"col_end":29,"count":1}]},{"line":"","counters":[]},{"line":"    let hash ~ledger_depth depth = UInt8.of_int (ledger_depth - depth)","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  type t = Generic of Bigstring.t | Account of Addr.t | Hash of Addr.t","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":11,"col_end":11,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"  [@@deriving hash, sexp, compare]","counters":[]},{"line":"","counters":[]},{"line":"  let is_generic = function Generic _ -> true | _ -> false","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"","counters":[]},{"line":"  let is_account = function Account _ -> true | _ -> false","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"","counters":[]},{"line":"  let is_hash = function Hash _ -> true | _ -> false","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"","counters":[]},{"line":"  let height ~ledger_depth : t -> int = function","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"    | Generic _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        raise (Invalid_argument \"height: generic location has no height\")","counters":[]},{"line":"    | Account _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        0","counters":[]},{"line":"    | Hash path ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Addr.height ~ledger_depth path","counters":[]},{"line":"","counters":[]},{"line":"  let root_hash : t = Hash (Addr.root ())","counters":[{"col_start":36,"col_end":36,"count":1}]},{"line":"","counters":[]},{"line":"  let last_direction path =","counters":[]},{"line":"    Direction.of_bool (Addr.get path (Addr.depth path - 1) <> 0)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"","counters":[]},{"line":"  let build_generic (data : Bigstring.t) : t = Generic data","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"","counters":[]},{"line":"  let parse ~ledger_depth (str : Bigstring.t) : (t, unit) Result.t =","counters":[]},{"line":"    let prefix = Bigstring.get str 0 |> Char.to_int |> UInt8.of_int in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"    let data = Bigstring.sub str ~pos:1 ~len:(Bigstring.length str - 1) in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"    if UInt8.equal prefix Prefix.generic then Result.return (Generic data)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"    else","counters":[]},{"line":"      let path = Addr.of_byte_string (Bigstring.to_string data) in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"      let slice_path = Addr.slice path 0 in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      if UInt8.equal prefix Prefix.account then","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Result.return (Account (slice_path ledger_depth))","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"      else if UInt8.to_int prefix <= ledger_depth then","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"        Result.return (Hash (slice_path (ledger_depth - UInt8.to_int prefix)))","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"      else Result.fail ()","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"","counters":[]},{"line":"  let prefix_bigstring prefix src =","counters":[]},{"line":"    let src_len = Bigstring.length src in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let dst = Bigstring.create (src_len + 1) in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Bigstring.set dst 0 (Char.of_int_exn (UInt8.to_int prefix)) ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"    Bigstring.blit ~src ~src_pos:0 ~dst ~dst_pos:1 ~len:src_len ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    dst","counters":[]},{"line":"","counters":[]},{"line":"  let to_path_exn = function","counters":[]},{"line":"    | Account path | Hash path ->","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"        path","counters":[]},{"line":"    | Generic _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        raise (Invalid_argument \"to_path_exn: generic does not have a path\")","counters":[]},{"line":"","counters":[]},{"line":"  let serialize ~ledger_depth = function","counters":[]},{"line":"    | Generic data ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        prefix_bigstring Prefix.generic data","counters":[]},{"line":"    | Account path ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        assert (Addr.depth path = ledger_depth) ;","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"        prefix_bigstring Prefix.account (Addr.serialize ~ledger_depth path)","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"    | Hash path ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        assert (Addr.depth path <= ledger_depth) ;","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"        prefix_bigstring","counters":[]},{"line":"          (Prefix.hash ~ledger_depth (Addr.depth path))","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"          (Addr.serialize ~ledger_depth path)","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"","counters":[]},{"line":"  let parent : t -> t = function","counters":[]},{"line":"    | Generic _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        raise (Invalid_argument \"parent: generic locations have no parent\")","counters":[]},{"line":"    | Account _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        raise (Invalid_argument \"parent: account locations have no parent\")","counters":[]},{"line":"    | Hash path ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        assert (Addr.depth path > 0) ;","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"        Hash (Addr.parent_exn path)","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"","counters":[]},{"line":"  let next : t -> t Option.t = function","counters":[]},{"line":"    | Generic _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        raise (Invalid_argument \"next: generic locations have no next location\")","counters":[]},{"line":"    | Account path ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Addr.next path |> Option.map ~f:(fun next -> Account next)","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"    | Hash path ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Addr.next path |> Option.map ~f:(fun next -> Hash next)","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"","counters":[]},{"line":"  let prev : t -> t Option.t = function","counters":[]},{"line":"    | Generic _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        raise (Invalid_argument \"prev: generic locations have no prev location\")","counters":[]},{"line":"    | Account path ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Addr.prev path |> Option.map ~f:(fun prev -> Account prev)","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"    | Hash path ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Addr.prev path |> Option.map ~f:(fun prev -> Hash prev)","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"","counters":[]},{"line":"  let sibling : t -> t = function","counters":[]},{"line":"    | Generic _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        raise (Invalid_argument \"sibling: generic locations have no sibling\")","counters":[]},{"line":"    | Account path ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Account (Addr.sibling path)","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"    | Hash path ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Hash (Addr.sibling path)","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"  let order_siblings (location : t) (base : 'a) (sibling : 'a) : 'a * 'a =","counters":[]},{"line":"    match last_direction (to_path_exn location) with","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"    | Left ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (base, sibling)","counters":[]},{"line":"    | Right ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (sibling, base)","counters":[]},{"line":"","counters":[]},{"line":"  type location = t [@@deriving sexp, compare]","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"  include Comparable.Make (struct","counters":[]},{"line":"    type t = location [@@deriving sexp, compare]","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  end)","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}