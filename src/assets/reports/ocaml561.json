{"filename":"src/lib/key_value_database/key_value_database.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"module Monad = struct","counters":[]},{"line":"  module type S = sig","counters":[]},{"line":"    type 'a t","counters":[]},{"line":"","counters":[]},{"line":"    include Monad.S with type 'a t := 'a t","counters":[]},{"line":"","counters":[]},{"line":"    module Result : sig","counters":[]},{"line":"      val lift : 'value t -> ('value, 'err) Result.t t","counters":[]},{"line":"","counters":[]},{"line":"      type nonrec ('value, 'err) t = ('value, 'err) Result.t t","counters":[]},{"line":"","counters":[]},{"line":"      include Monad.S2 with type ('value, 'err) t := ('value, 'err) t","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Option : sig","counters":[]},{"line":"      type nonrec 'a t = 'a option t","counters":[]},{"line":"","counters":[]},{"line":"      include Monad.S with type 'a t := 'a t","counters":[]},{"line":"    end","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Ident = struct","counters":[]},{"line":"    include Monad.Ident","counters":[]},{"line":"","counters":[]},{"line":"    module Result = struct","counters":[]},{"line":"      let lift = Result.return","counters":[]},{"line":"","counters":[]},{"line":"      include Result","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Option = Option","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Intf = struct","counters":[]},{"line":"  module type S = sig","counters":[]},{"line":"    type t","counters":[]},{"line":"","counters":[]},{"line":"    type key","counters":[]},{"line":"","counters":[]},{"line":"    type value","counters":[]},{"line":"","counters":[]},{"line":"    type config","counters":[]},{"line":"","counters":[]},{"line":"    module M : Monad.S","counters":[]},{"line":"","counters":[]},{"line":"    val create : config -> t","counters":[]},{"line":"","counters":[]},{"line":"    val close : t -> unit","counters":[]},{"line":"","counters":[]},{"line":"    val get : t -> key:key -> value option M.t","counters":[]},{"line":"","counters":[]},{"line":"    val get_batch : t -> keys:key list -> value option list M.t","counters":[]},{"line":"","counters":[]},{"line":"    val set : t -> key:key -> data:value -> unit M.t","counters":[]},{"line":"","counters":[]},{"line":"    val remove : t -> key:key -> unit M.t","counters":[]},{"line":"","counters":[]},{"line":"    val set_batch :","counters":[]},{"line":"      t -> ?remove_keys:key list -> update_pairs:(key * value) list -> unit M.t","counters":[]},{"line":"","counters":[]},{"line":"    val to_alist : t -> (key * value) list M.t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module type Ident = S with module M := Monad.Ident","counters":[]},{"line":"","counters":[]},{"line":"  module type Mock = sig","counters":[]},{"line":"    include Ident","counters":[]},{"line":"","counters":[]},{"line":"    val random_key : t -> key option","counters":[]},{"line":"","counters":[]},{"line":"    val to_sexp :","counters":[]},{"line":"      t -> key_sexp:(key -> Sexp.t) -> value_sexp:(value -> Sexp.t) -> Sexp.t","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make_mock","counters":[]},{"line":"    (Key : Hashable.S) (Value : sig","counters":[]},{"line":"      type t","counters":[]},{"line":"    end) :","counters":[]},{"line":"  Intf.Mock","counters":[]},{"line":"    with type t = Value.t Key.Table.t","counters":[]},{"line":"     and type key := Key.t","counters":[]},{"line":"     and type value := Value.t","counters":[]},{"line":"     and type config := unit = struct","counters":[]},{"line":"  type t = Value.t Key.Table.t","counters":[]},{"line":"","counters":[]},{"line":"  let to_sexp t ~key_sexp ~value_sexp =","counters":[]},{"line":"    Key.Table.to_alist t","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"    |> List.map ~f:(fun (key, value) ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"           [%sexp_of: Sexp.t * Sexp.t] (key_sexp key, value_sexp value) )","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":47,"col_end":47,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"    |> [%sexp_of: Sexp.t list]","counters":[]},{"line":"","counters":[]},{"line":"  let create _ = Key.Table.create ()","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"","counters":[]},{"line":"  let get t ~key = Key.Table.find t key","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"","counters":[]},{"line":"  let get_batch t ~keys = List.map keys ~f:(Key.Table.find t)","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"","counters":[]},{"line":"  let set = Key.Table.set","counters":[]},{"line":"","counters":[]},{"line":"  let remove t ~key = Key.Table.remove t key","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"  let close _ = ()","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"","counters":[]},{"line":"  let random_key t =","counters":[]},{"line":"    let keys = Key.Table.keys t in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    List.random_element keys","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let set_batch t ?(remove_keys = []) ~update_pairs =","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"    List.iter update_pairs ~f:(fun (key, data) -> set t ~key ~data) ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"    List.iter remove_keys ~f:(fun key -> remove t ~key)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"","counters":[]},{"line":"  let to_alist = Key.Table.to_alist","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}