{"filename":"src/staged_ledger/sparse_ledger.rs","lines":[{"line":"use std::{","counters":[]},{"line":"    collections::{BTreeMap, HashMap, VecDeque},","counters":[]},{"line":"    fmt::Write,","counters":[]},{"line":"};","counters":[]},{"line":"","counters":[]},{"line":"use ark_ff::Zero;","counters":[]},{"line":"use mina_hasher::Fp;","counters":[]},{"line":"use mina_signer::CompressedPubKey;","counters":[]},{"line":"","counters":[]},{"line":"use crate::{","counters":[]},{"line":"    scan_state::{conv::to_ledger_hash, currency::Slot, transaction_logic::AccountState},","counters":[]},{"line":"    Account, AccountId, AccountIndex, Address, AddressIterator, BaseLedger, Direction,","counters":[]},{"line":"    HashesMatrix, Mask, MerklePath, TreeVersion, V2,","counters":[]},{"line":"};","counters":[]},{"line":"","counters":[]},{"line":"#[derive(Clone, Debug, PartialEq)]","counters":[{"col_start":9,"col_end":14,"count":0},{"col_start":16,"col_end":21,"count":0}]},{"line":"pub struct SparseLedger<K: Eq + std::hash::Hash, V> {","counters":[]},{"line":"    values: BTreeMap<AccountIndex, V>,","counters":[]},{"line":"    indexes: HashMap<K, Address>,","counters":[]},{"line":"    /// Mirror OCaml, where the index is ordered, and can have duplicates","counters":[]},{"line":"    indexes_list: VecDeque<K>,","counters":[]},{"line":"    hashes_matrix: HashesMatrix,","counters":[]},{"line":"    depth: usize,","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl SparseLedger<AccountId, Account> {","counters":[]},{"line":"    pub fn create(depth: usize, root_hash: Fp) -> Self {","counters":[{"col_start":4,"col_end":56,"count":0}]},{"line":"        let mut hashes_matrix = HashesMatrix::new(depth);","counters":[{"col_start":0,"col_end":57,"count":0}]},{"line":"        hashes_matrix.set(&Address::root(), root_hash);","counters":[{"col_start":0,"col_end":55,"count":0}]},{"line":"","counters":[]},{"line":"        Self {","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"            values: BTreeMap::new(),","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"            indexes: HashMap::new(),","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"            indexes_list: VecDeque::new(),","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"            depth,","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"            hashes_matrix,","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn of_ledger_subset_exn(oledger: Mask, keys: &[AccountId]) -> Self {","counters":[{"col_start":4,"col_end":76,"count":0}]},{"line":"        use crate::GetOrCreated::{Added, Existed};","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"","counters":[]},{"line":"        let mut ledger = oledger.copy();","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"        let mut sparse = Self::create(","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"            ledger.depth() as usize,","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"            BaseLedger::merkle_root(&mut ledger),","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"        );","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        for key in keys {","counters":[{"col_start":12,"col_end":15,"count":0},{"col_start":19,"col_end":23,"count":0}]},{"line":"            match BaseLedger::location_of_account(&ledger, key) {","counters":[{"col_start":18,"col_end":63,"count":0}]},{"line":"                Some(addr) => {","counters":[{"col_start":21,"col_end":31,"count":0}]},{"line":"                    let account = BaseLedger::get(&ledger, addr.clone()).unwrap();","counters":[{"col_start":0,"col_end":82,"count":0}]},{"line":"                    let merkle_path = ledger.merkle_path(addr);","counters":[{"col_start":0,"col_end":63,"count":0}]},{"line":"                    sparse.add_path(&merkle_path, key.clone(), account);","counters":[{"col_start":0,"col_end":72,"count":0}]},{"line":"                }","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"                None => {","counters":[{"col_start":24,"col_end":25,"count":0}]},{"line":"                    let addr = match ledger","counters":[{"col_start":0,"col_end":28,"count":0},{"col_start":37,"col_end":43,"count":0}]},{"line":"                        .get_or_create_account(key.clone(), Account::empty())","counters":[{"col_start":0,"col_end":77,"count":0}]},{"line":"                        .unwrap()","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"                    {","counters":[]},{"line":"                        Added(addr) => addr,","counters":[{"col_start":30,"col_end":43,"count":0}]},{"line":"                        Existed(_) => panic!(\"create_empty for a key already present\"),","counters":[{"col_start":38,"col_end":86,"count":0}]},{"line":"                    };","counters":[]},{"line":"","counters":[]},{"line":"                    let merkle_path = ledger.merkle_path(addr);","counters":[{"col_start":24,"col_end":63,"count":0}]},{"line":"                    sparse.add_path(&merkle_path, key.clone(), Account::empty());","counters":[{"col_start":0,"col_end":80,"count":0}]},{"line":"                }","counters":[]},{"line":"            }","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        assert_eq!(BaseLedger::merkle_root(&mut ledger), sparse.merkle_root());","counters":[{"col_start":8,"col_end":78,"count":0}]},{"line":"","counters":[]},{"line":"        sparse","counters":[{"col_start":8,"col_end":14,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn get_or_initialize_exn(","counters":[{"col_start":4,"col_end":29,"count":0}]},{"line":"        &self,","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"        account_id: &AccountId,","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"        addr: &Address,","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"    ) -> (AccountState, Account) {","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"        let mut account = self.get_exn(addr).clone();","counters":[{"col_start":0,"col_end":53,"count":0}]},{"line":"","counters":[]},{"line":"        if account.public_key == CompressedPubKey::empty() {","counters":[{"col_start":0,"col_end":58,"count":0}]},{"line":"            let public_key = account_id.public_key.clone();","counters":[{"col_start":16,"col_end":59,"count":0}]},{"line":"            let token_id = account_id.token_id.clone();","counters":[{"col_start":0,"col_end":54,"count":0}]},{"line":"","counters":[]},{"line":"            // Only allow delegation if this account is for the default token.","counters":[]},{"line":"            let delegate = if token_id.is_default() {","counters":[{"col_start":16,"col_end":24,"count":0},{"col_start":30,"col_end":51,"count":0}]},{"line":"                Some(public_key.clone())","counters":[{"col_start":16,"col_end":40,"count":0}]},{"line":"            } else {","counters":[]},{"line":"                None","counters":[{"col_start":16,"col_end":20,"count":0}]},{"line":"            };","counters":[]},{"line":"","counters":[]},{"line":"            account.delegate = delegate;","counters":[{"col_start":12,"col_end":40,"count":0}]},{"line":"            account.public_key = public_key;","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"            account.token_id = token_id;","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"            (AccountState::Added, account)","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"        } else {","counters":[]},{"line":"            (AccountState::Existed, account)","counters":[{"col_start":12,"col_end":44,"count":0}]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn has_locked_tokens_exn(&self, global_slot: Slot, account_id: AccountId) -> bool {","counters":[{"col_start":4,"col_end":91,"count":0}]},{"line":"        let addr = self.find_index_exn(account_id.clone());","counters":[{"col_start":0,"col_end":59,"count":0}]},{"line":"        let (_, account) = self.get_or_initialize_exn(&account_id, &addr);","counters":[{"col_start":0,"col_end":74,"count":0}]},{"line":"        account.has_locked_tokens(global_slot)","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn iteri<F>(&self, fun: F)","counters":[]},{"line":"    where","counters":[]},{"line":"        F: Fn(Address, &Account),","counters":[]},{"line":"    {","counters":[]},{"line":"        let addr = |index: &AccountIndex| Address::from_index(index.clone(), self.depth);","counters":[]},{"line":"","counters":[]},{"line":"        for (index, value) in &self.values {","counters":[]},{"line":"            fun(addr(index), value);","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    pub fn add_path(","counters":[{"col_start":4,"col_end":20,"count":0}]},{"line":"        &mut self,","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"        merkle_path: &[MerklePath],","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"        account_id: AccountId,","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"        account: Account,","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"    ) {","counters":[{"col_start":0,"col_end":7,"count":0}]},{"line":"        assert_eq!(self.depth, merkle_path.len());","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"","counters":[]},{"line":"        let mut set_hash = |addr: Address, hash: &Fp| {","counters":[{"col_start":12,"col_end":24,"count":0}]},{"line":"            if let Some(prev_hash) = self.hashes_matrix.get(&addr) {","counters":[{"col_start":24,"col_end":33,"count":0},{"col_start":37,"col_end":66,"count":0}]},{"line":"                assert_eq!(prev_hash, hash);","counters":[{"col_start":16,"col_end":43,"count":0}]},{"line":"                return;","counters":[{"col_start":16,"col_end":22,"count":0}]},{"line":"            };","counters":[{"col_start":13,"col_end":14,"count":0}]},{"line":"","counters":[]},{"line":"            self.hashes_matrix.set(&addr, *hash);","counters":[{"col_start":0,"col_end":48,"count":0}]},{"line":"        };","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        let mut addr = Address::root();","counters":[{"col_start":12,"col_end":38,"count":0}]},{"line":"","counters":[]},{"line":"        // Go until the account address","counters":[]},{"line":"        for path in merkle_path.iter().rev() {","counters":[{"col_start":12,"col_end":16,"count":0},{"col_start":20,"col_end":44,"count":0}]},{"line":"            addr = match path {","counters":[{"col_start":25,"col_end":29,"count":0}]},{"line":"                MerklePath::Left(right) => {","counters":[{"col_start":33,"col_end":44,"count":0}]},{"line":"                    set_hash(addr.child_right(), right);","counters":[{"col_start":0,"col_end":56,"count":0}]},{"line":"                    addr.child_left()","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"                }","counters":[]},{"line":"                MerklePath::Right(left) => {","counters":[{"col_start":34,"col_end":44,"count":0}]},{"line":"                    set_hash(addr.child_left(), left);","counters":[{"col_start":0,"col_end":54,"count":0}]},{"line":"                    addr.child_right()","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"                }","counters":[]},{"line":"            }","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        let account_addr = addr.clone();","counters":[{"col_start":12,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"        let mut current = account.hash();","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"        let mut param = String::with_capacity(16);","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"","counters":[]},{"line":"        // Go back from the account to root, to compute missing hashes","counters":[]},{"line":"        for (depth, path) in merkle_path.iter().enumerate() {","counters":[{"col_start":13,"col_end":24,"count":0},{"col_start":29,"col_end":59,"count":0}]},{"line":"            set_hash(addr.clone(), &current);","counters":[{"col_start":12,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"            let hashes = match path {","counters":[{"col_start":16,"col_end":22,"count":0},{"col_start":31,"col_end":35,"count":0}]},{"line":"                MerklePath::Left(right) => [current, *right],","counters":[{"col_start":33,"col_end":60,"count":0}]},{"line":"                MerklePath::Right(left) => [*left, current],","counters":[{"col_start":34,"col_end":59,"count":0}]},{"line":"            };","counters":[]},{"line":"","counters":[]},{"line":"            param.clear();","counters":[{"col_start":12,"col_end":26,"count":0}]},{"line":"            write!(&mut param, \"MinaMklTree{:03}\", depth).unwrap();","counters":[{"col_start":0,"col_end":67,"count":0}]},{"line":"","counters":[]},{"line":"            current = crate::hash::hash_with_kimchi(param.as_str(), &hashes);","counters":[{"col_start":0,"col_end":77,"count":0}]},{"line":"","counters":[]},{"line":"            addr = addr.parent().unwrap();","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        assert!(addr.is_root());","counters":[{"col_start":8,"col_end":31,"count":0}]},{"line":"        set_hash(addr, &current);","counters":[{"col_start":8,"col_end":33,"count":0}]},{"line":"","counters":[]},{"line":"        let index = account_addr.to_index();","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"        self.indexes","counters":[{"col_start":0,"col_end":20,"count":0}]},{"line":"            .entry(account_id.clone())","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"            .or_insert(account_addr);","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"        self.indexes_list.push_front(account_id);","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"        self.values.insert(index, account);","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn get_index(&self, account_id: &AccountId) -> Option<&Address> {","counters":[{"col_start":4,"col_end":69,"count":0}]},{"line":"        self.indexes.get(account_id)","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn get(&self, addr: &Address) -> Option<&Account> {","counters":[{"col_start":4,"col_end":55,"count":0}]},{"line":"        assert_eq!(addr.length(), self.depth);","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"","counters":[]},{"line":"        let index = addr.to_index();","counters":[{"col_start":12,"col_end":36,"count":0}]},{"line":"        self.values.get(&index)","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn get_exn(&self, addr: &Address) -> &Account {","counters":[{"col_start":4,"col_end":55,"count":0}]},{"line":"        self.get(addr).unwrap()","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn set_exn(&mut self, addr: Address, value: Account) {","counters":[{"col_start":4,"col_end":62,"count":0}]},{"line":"        assert_eq!(addr.length(), self.depth);","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"","counters":[]},{"line":"        let index = addr.to_index();","counters":[{"col_start":12,"col_end":36,"count":0}]},{"line":"        self.values.insert(index, value);","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"","counters":[]},{"line":"        self.hashes_matrix.invalidate_hashes(addr.to_index());","counters":[{"col_start":0,"col_end":62,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn find_index_exn(&self, key: AccountId) -> Address {","counters":[{"col_start":4,"col_end":61,"count":0}]},{"line":"        self.get_index(&key).cloned().unwrap()","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn path_exn(&mut self, addr: Address) -> Vec<MerklePath> {","counters":[{"col_start":4,"col_end":66,"count":0}]},{"line":"        let mut merkle_path = Vec::with_capacity(addr.length());","counters":[{"col_start":0,"col_end":64,"count":0}]},{"line":"        let mut path_to_addr = addr.into_iter();","counters":[{"col_start":0,"col_end":48,"count":0}]},{"line":"        let root = Address::root();","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"        self.emulate_tree_to_get_path(root, &mut path_to_addr, &mut merkle_path);","counters":[{"col_start":0,"col_end":81,"count":0}]},{"line":"","counters":[]},{"line":"        merkle_path","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn get_value_hash(&mut self, addr: Address) -> Fp {","counters":[]},{"line":"        if let Some(hash) = self.hashes_matrix.get(&addr) {","counters":[{"col_start":20,"col_end":24,"count":0},{"col_start":28,"col_end":57,"count":0}]},{"line":"            return *hash;","counters":[{"col_start":19,"col_end":24,"count":0}]},{"line":"        }","counters":[{"col_start":9,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"        let hash = match self.get(&addr) {","counters":[{"col_start":12,"col_end":16,"count":0},{"col_start":25,"col_end":40,"count":0}]},{"line":"            Some(value) => V2::hash_leaf(value),","counters":[{"col_start":17,"col_end":47,"count":0}]},{"line":"            None => V2::empty_hash_at_depth(0),","counters":[{"col_start":20,"col_end":46,"count":0}]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        self.hashes_matrix.set(&addr, hash);","counters":[{"col_start":8,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"        hash","counters":[{"col_start":0,"col_end":12,"count":0}]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn get_node_hash(&mut self, addr: &Address, left: Fp, right: Fp) -> Fp {","counters":[]},{"line":"        if let Some(hash) = self.hashes_matrix.get(addr) {","counters":[{"col_start":20,"col_end":24,"count":0},{"col_start":28,"col_end":56,"count":0}]},{"line":"            return *hash;","counters":[{"col_start":19,"col_end":24,"count":0}]},{"line":"        };","counters":[{"col_start":9,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"        let depth_in_tree = self.depth - addr.length();","counters":[{"col_start":0,"col_end":55,"count":0}]},{"line":"","counters":[]},{"line":"        let hash = V2::hash_node(depth_in_tree - 1, left, right);","counters":[{"col_start":0,"col_end":65,"count":0}]},{"line":"        self.hashes_matrix.set(addr, hash);","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"        hash","counters":[{"col_start":0,"col_end":12,"count":0}]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn emulate_tree_to_get_path(","counters":[{"col_start":4,"col_end":32,"count":0}]},{"line":"        &mut self,","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"        addr: Address,","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"        path: &mut AddressIterator,","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"        merkle_path: &mut Vec<MerklePath>,","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"    ) -> Fp {","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        if addr.length() == self.depth {","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"            return self.get_value_hash(addr);","counters":[{"col_start":19,"col_end":44,"count":0}]},{"line":"        }","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        let next_direction = path.next();","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"        // We go until the end of the path","counters":[]},{"line":"        if let Some(direction) = next_direction.as_ref() {","counters":[{"col_start":20,"col_end":29,"count":0},{"col_start":33,"col_end":56,"count":0},{"col_start":57,"col_end":58,"count":0}]},{"line":"            let child = match direction {","counters":[{"col_start":0,"col_end":21,"count":0},{"col_start":30,"col_end":39,"count":0}]},{"line":"                Direction::Left => addr.child_left(),","counters":[{"col_start":35,"col_end":52,"count":0}]},{"line":"                Direction::Right => addr.child_right(),","counters":[{"col_start":36,"col_end":54,"count":0}]},{"line":"            };","counters":[]},{"line":"            self.emulate_tree_to_get_path(child, path, merkle_path);","counters":[{"col_start":12,"col_end":67,"count":0}]},{"line":"        };","counters":[{"col_start":9,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"        let mut get_child_hash = |addr: Address| match self.hashes_matrix.get(&addr) {","counters":[{"col_start":12,"col_end":33,"count":0},{"col_start":49,"col_end":84,"count":0}]},{"line":"            Some(hash) => *hash,","counters":[{"col_start":17,"col_end":31,"count":0}]},{"line":"            None => {","counters":[]},{"line":"                if let Some(hash) = self.hashes_matrix.get(&addr) {","counters":[{"col_start":28,"col_end":32,"count":0},{"col_start":36,"col_end":65,"count":0}]},{"line":"                    *hash","counters":[{"col_start":20,"col_end":25,"count":0}]},{"line":"                } else {","counters":[]},{"line":"                    self.emulate_tree_to_get_path(addr, path, merkle_path)","counters":[{"col_start":20,"col_end":74,"count":0}]},{"line":"                }","counters":[]},{"line":"            }","counters":[]},{"line":"        };","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        let left = get_child_hash(addr.child_left());","counters":[{"col_start":12,"col_end":53,"count":0}]},{"line":"        let right = get_child_hash(addr.child_right());","counters":[{"col_start":0,"col_end":54,"count":0}]},{"line":"","counters":[]},{"line":"        if let Some(direction) = next_direction {","counters":[{"col_start":20,"col_end":29,"count":0},{"col_start":33,"col_end":47,"count":0},{"col_start":48,"col_end":49,"count":0}]},{"line":"            let hash = match direction {","counters":[{"col_start":0,"col_end":20,"count":0},{"col_start":29,"col_end":38,"count":0}]},{"line":"                Direction::Left => MerklePath::Left(right),","counters":[{"col_start":35,"col_end":58,"count":0}]},{"line":"                Direction::Right => MerklePath::Right(left),","counters":[{"col_start":36,"col_end":59,"count":0}]},{"line":"            };","counters":[]},{"line":"            merkle_path.push(hash);","counters":[{"col_start":12,"col_end":34,"count":0}]},{"line":"        };","counters":[{"col_start":9,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"        self.get_node_hash(&addr, left, right)","counters":[{"col_start":8,"col_end":46,"count":0}]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn merkle_root(&mut self) -> Fp {","counters":[{"col_start":4,"col_end":41,"count":0}]},{"line":"        let root = Address::root();","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"","counters":[]},{"line":"        if let Some(hash) = self.hashes_matrix.get(&root) {","counters":[{"col_start":20,"col_end":24,"count":0},{"col_start":28,"col_end":57,"count":0}]},{"line":"            return *hash;","counters":[{"col_start":19,"col_end":24,"count":0}]},{"line":"        };","counters":[{"col_start":9,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"        self.emulate_tree_merkle_root(root)","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn emulate_tree_merkle_root(&mut self, addr: Address) -> Fp {","counters":[{"col_start":4,"col_end":69,"count":0}]},{"line":"        let current_depth = self.depth - addr.length();","counters":[{"col_start":0,"col_end":55,"count":0}]},{"line":"","counters":[]},{"line":"        if current_depth == 0 {","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"            return self.get_value_hash(addr);","counters":[{"col_start":19,"col_end":44,"count":0}]},{"line":"        }","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        let mut get_child_hash = |addr: Address| {","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"            if let Some(hash) = self.hashes_matrix.get(&addr) {","counters":[{"col_start":24,"col_end":28,"count":0},{"col_start":32,"col_end":61,"count":0}]},{"line":"                *hash","counters":[{"col_start":16,"col_end":21,"count":0}]},{"line":"            } else {","counters":[]},{"line":"                self.emulate_tree_merkle_root(addr)","counters":[{"col_start":16,"col_end":51,"count":0}]},{"line":"            }","counters":[]},{"line":"        };","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        let left_hash = get_child_hash(addr.child_left());","counters":[{"col_start":12,"col_end":58,"count":0}]},{"line":"        let right_hash = get_child_hash(addr.child_right());","counters":[{"col_start":0,"col_end":60,"count":0}]},{"line":"","counters":[]},{"line":"        self.get_node_hash(&addr, left_hash, right_hash)","counters":[{"col_start":0,"col_end":56,"count":0}]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn location_of_account_impl(&self, account_id: &AccountId) -> Option<Address> {","counters":[]},{"line":"        self.get_index(account_id).cloned()","counters":[]},{"line":"    }","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl From<&SparseLedger<AccountId, Account>>","counters":[]},{"line":"    for mina_p2p_messages::v2::MinaBaseSparseLedgerBaseStableV2","counters":[]},{"line":"{","counters":[]},{"line":"    fn from(value: &SparseLedger<AccountId, Account>) -> Self {","counters":[{"col_start":4,"col_end":63,"count":0}]},{"line":"        use mina_p2p_messages::v2::MinaBaseAccountBinableArgStableV2;","counters":[{"col_start":0,"col_end":69,"count":0}]},{"line":"        use mina_p2p_messages::v2::MinaBaseAccountIdStableV2;","counters":[{"col_start":0,"col_end":61,"count":0}]},{"line":"        use mina_p2p_messages::v2::MinaBaseSparseLedgerBaseStableV2Tree;","counters":[{"col_start":0,"col_end":72,"count":0}]},{"line":"","counters":[]},{"line":"        assert!(value.hashes_matrix.get(&Address::root()).is_some());","counters":[{"col_start":0,"col_end":68,"count":0}]},{"line":"","counters":[]},{"line":"        let indexes: Vec<_> = value","counters":[{"col_start":12,"col_end":35,"count":0}]},{"line":"            .indexes_list","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"            .iter()","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"            .map(|id| {","counters":[{"col_start":0,"col_end":17,"count":0},{"col_start":22,"col_end":23,"count":0}]},{"line":"                let addr = value.indexes.get(id).unwrap();","counters":[{"col_start":0,"col_end":58,"count":0}]},{"line":"","counters":[]},{"line":"                let index = addr.to_index();","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"                let index: u32 = index.as_u64().try_into().unwrap();","counters":[{"col_start":0,"col_end":68,"count":0}]},{"line":"                let index: mina_p2p_messages::number::Int32 = (index as i32).into();","counters":[{"col_start":0,"col_end":84,"count":0}]},{"line":"","counters":[]},{"line":"                let id: MinaBaseAccountIdStableV2 = id.clone().into();","counters":[{"col_start":0,"col_end":70,"count":0}]},{"line":"","counters":[]},{"line":"                (id, index)","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"            })","counters":[{"col_start":0,"col_end":13,"count":0},{"col_start":13,"col_end":14,"count":0}]},{"line":"            .collect();","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"        fn build_tree(","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"            addr: Address,","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"            matrix: &HashesMatrix,","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"            ledger_depth: usize,","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"            values: &BTreeMap<AccountIndex, Account>,","counters":[{"col_start":0,"col_end":53,"count":0}]},{"line":"        ) -> MinaBaseSparseLedgerBaseStableV2Tree {","counters":[{"col_start":0,"col_end":51,"count":0}]},{"line":"            if addr.length() == ledger_depth {","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"                let account_index = addr.to_index();","counters":[{"col_start":0,"col_end":52,"count":0}]},{"line":"","counters":[]},{"line":"                return match values.get(&account_index).cloned() {","counters":[{"col_start":0,"col_end":66,"count":0}]},{"line":"                    Some(account) => {","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"                        let account: MinaBaseAccountBinableArgStableV2 = account.into();","counters":[{"col_start":0,"col_end":88,"count":0}]},{"line":"                        MinaBaseSparseLedgerBaseStableV2Tree::Account(Box::new(account))","counters":[{"col_start":0,"col_end":88,"count":0}]},{"line":"                    }","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"                    None => {","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"                        let hash = matrix.get(&addr).unwrap();","counters":[{"col_start":0,"col_end":62,"count":0}]},{"line":"                        MinaBaseSparseLedgerBaseStableV2Tree::Hash(to_ledger_hash(hash))","counters":[{"col_start":0,"col_end":88,"count":0}]},{"line":"                    }","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"                };","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"            }","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":0,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"            let child_left = addr.child_left();","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"            let child_right = addr.child_right();","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"","counters":[]},{"line":"            let is_left = matrix.get(&child_left).is_some();","counters":[{"col_start":0,"col_end":60,"count":0}]},{"line":"            let is_right = matrix.get(&child_right).is_some();","counters":[{"col_start":0,"col_end":62,"count":0}]},{"line":"","counters":[]},{"line":"            if is_left && is_right {","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"                let hash = matrix.get(&addr).unwrap();","counters":[{"col_start":0,"col_end":54,"count":0}]},{"line":"                let left_node = build_tree(child_left, matrix, ledger_depth, values);","counters":[{"col_start":0,"col_end":85,"count":0}]},{"line":"                let right_node = build_tree(child_right, matrix, ledger_depth, values);","counters":[{"col_start":0,"col_end":87,"count":0}]},{"line":"","counters":[]},{"line":"                MinaBaseSparseLedgerBaseStableV2Tree::Node(","counters":[{"col_start":0,"col_end":59,"count":0}]},{"line":"                    to_ledger_hash(hash),","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"                    Box::new(left_node),","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"                    Box::new(right_node),","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"                )","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"            } else {","counters":[{"col_start":0,"col_end":20,"count":0}]},{"line":"                assert!(!is_left && !is_right);","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"                let hash = matrix.get(&addr).unwrap();","counters":[{"col_start":0,"col_end":54,"count":0}]},{"line":"                MinaBaseSparseLedgerBaseStableV2Tree::Hash(to_ledger_hash(hash))","counters":[{"col_start":0,"col_end":80,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        let tree = build_tree(","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"            Address::root(),","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"            &value.hashes_matrix,","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"            value.depth,","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"            &value.values,","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"        );","counters":[{"col_start":0,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"        let depth: u32 = value.depth.try_into().unwrap();","counters":[{"col_start":0,"col_end":57,"count":0}]},{"line":"","counters":[]},{"line":"        Self {","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"            indexes,","counters":[{"col_start":0,"col_end":20,"count":0}]},{"line":"            depth: (depth as i32).into(),","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"            tree,","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl From<&mina_p2p_messages::v2::MinaBaseSparseLedgerBaseStableV2>","counters":[]},{"line":"    for SparseLedger<AccountId, Account>","counters":[]},{"line":"{","counters":[]},{"line":"    fn from(value: &mina_p2p_messages::v2::MinaBaseSparseLedgerBaseStableV2) -> Self {","counters":[{"col_start":4,"col_end":86,"count":0}]},{"line":"        use mina_p2p_messages::v2::MinaBaseSparseLedgerBaseStableV2Tree;","counters":[{"col_start":0,"col_end":72,"count":0}]},{"line":"        use mina_p2p_messages::v2::MinaBaseSparseLedgerBaseStableV2Tree::{Account, Hash, Node};","counters":[{"col_start":0,"col_end":95,"count":0}]},{"line":"","counters":[]},{"line":"        fn build_matrix(","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"            matrix: &mut HashesMatrix,","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"            addr: Address,","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"            node: &MinaBaseSparseLedgerBaseStableV2Tree,","counters":[{"col_start":0,"col_end":56,"count":0}]},{"line":"            values: &mut BTreeMap<AccountIndex, crate::Account>,","counters":[{"col_start":0,"col_end":64,"count":0}]},{"line":"        ) {","counters":[{"col_start":0,"col_end":11,"count":0}]},{"line":"            match node {","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"                Account(account) => {","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"                    // TODO: Don't clone the account here","counters":[{"col_start":0,"col_end":57,"count":0}]},{"line":"                    let account: crate::Account = (**account).clone().into();","counters":[{"col_start":0,"col_end":77,"count":0}]},{"line":"                    matrix.set(&addr, account.hash());","counters":[{"col_start":0,"col_end":54,"count":0}]},{"line":"                    values.insert(addr.to_index(), account);","counters":[{"col_start":0,"col_end":60,"count":0}]},{"line":"                }","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"                Hash(hash) => {","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"                    matrix.set(&addr, hash.to_field());","counters":[{"col_start":0,"col_end":55,"count":0}]},{"line":"                }","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"                Node(hash, left, right) => {","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"                    matrix.set(&addr, hash.to_field());","counters":[{"col_start":0,"col_end":55,"count":0}]},{"line":"                    build_matrix(matrix, addr.child_left(), left, values);","counters":[{"col_start":0,"col_end":74,"count":0}]},{"line":"                    build_matrix(matrix, addr.child_right(), right, values);","counters":[{"col_start":0,"col_end":76,"count":0}]},{"line":"                }","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        let depth = value.depth.as_u32() as usize;","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"        let mut indexes = HashMap::with_capacity(value.indexes.len());","counters":[{"col_start":0,"col_end":70,"count":0}]},{"line":"        let mut indexes_list = VecDeque::with_capacity(value.indexes.len());","counters":[{"col_start":0,"col_end":76,"count":0}]},{"line":"        let mut hashes_matrix = HashesMatrix::new(depth);","counters":[{"col_start":0,"col_end":57,"count":0}]},{"line":"        let mut values = BTreeMap::new();","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"        for (account_id, account_index) in value.indexes.iter() {","counters":[{"col_start":13,"col_end":38,"count":0},{"col_start":57,"col_end":63,"count":0},{"col_start":64,"col_end":65,"count":0}]},{"line":"            let account_id: AccountId = account_id.into();","counters":[{"col_start":0,"col_end":58,"count":0}]},{"line":"            let account_index = AccountIndex::from(account_index.as_u32() as usize);","counters":[{"col_start":0,"col_end":84,"count":0}]},{"line":"","counters":[]},{"line":"            let addr = Address::from_index(account_index.clone(), depth);","counters":[{"col_start":0,"col_end":73,"count":0}]},{"line":"","counters":[]},{"line":"            indexes.insert(account_id.clone(), addr);","counters":[{"col_start":0,"col_end":53,"count":0}]},{"line":"            indexes_list.push_back(account_id);","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        build_matrix(","counters":[{"col_start":8,"col_end":21,"count":0}]},{"line":"            &mut hashes_matrix,","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"            Address::root(),","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"            &value.tree,","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"            &mut values,","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"        );","counters":[{"col_start":0,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"        Self {","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"            values,","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"            indexes,","counters":[{"col_start":0,"col_end":20,"count":0}]},{"line":"            hashes_matrix,","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"            depth,","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"            indexes_list,","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"/// Trait used in transaction logic, on the ledger witness (`SparseLedger`), or on mask","counters":[]},{"line":"///","counters":[]},{"line":"/// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/mina_base/ledger_intf.ml","counters":[]},{"line":"/// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/mina_base/sparse_ledger_base.ml","counters":[]},{"line":"pub trait LedgerIntf {","counters":[]},{"line":"    type Location: Clone + std::fmt::Debug;","counters":[]},{"line":"","counters":[]},{"line":"    fn get(&self, addr: &Self::Location) -> Option<Account>;","counters":[]},{"line":"    fn location_of_account(&self, account_id: &AccountId) -> Option<Self::Location>;","counters":[]},{"line":"    fn set(&mut self, addr: &Self::Location, account: Account);","counters":[]},{"line":"    fn get_or_create(","counters":[]},{"line":"        &mut self,","counters":[]},{"line":"        account_id: &AccountId,","counters":[]},{"line":"    ) -> Result<(AccountState, Account, Self::Location), String>;","counters":[]},{"line":"    fn create_new_account(&mut self, account_id: AccountId, account: Account) -> Result<(), ()>;","counters":[]},{"line":"    fn remove_accounts_exn(&mut self, account_ids: &[AccountId]);","counters":[]},{"line":"    fn merkle_root(&mut self) -> Fp;","counters":[]},{"line":"    fn empty(depth: usize) -> Self;","counters":[]},{"line":"    fn create_masked(&self) -> Self;","counters":[]},{"line":"    fn apply_mask(&mut self, mask: Self);","counters":[]},{"line":"","counters":[]},{"line":"    /// Returns all account locations in this ledger (and its parents if any)","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// The result is sorted","counters":[]},{"line":"    fn account_locations(&self) -> Vec<Self::Location>;","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl LedgerIntf for SparseLedger<AccountId, Account> {","counters":[]},{"line":"    type Location = Address;","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/mina_base/sparse_ledger_base.ml#L58","counters":[]},{"line":"    fn get(&self, addr: &Self::Location) -> Option<Account> {","counters":[{"col_start":4,"col_end":60,"count":0}]},{"line":"        let account = self.get(addr)?;","counters":[{"col_start":12,"col_end":19,"count":0},{"col_start":22,"col_end":36,"count":0},{"col_start":36,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"        if account.public_key == CompressedPubKey::empty() {","counters":[{"col_start":11,"col_end":58,"count":0}]},{"line":"            None","counters":[{"col_start":12,"col_end":16,"count":0}]},{"line":"        } else {","counters":[]},{"line":"            Some(account.clone())","counters":[{"col_start":12,"col_end":33,"count":0}]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/mina_base/sparse_ledger_base.ml#L66","counters":[]},{"line":"    fn location_of_account(&self, account_id: &AccountId) -> Option<Self::Location> {","counters":[{"col_start":4,"col_end":84,"count":0}]},{"line":"        let addr = self.get_index(account_id)?;","counters":[{"col_start":12,"col_end":16,"count":0},{"col_start":19,"col_end":45,"count":0},{"col_start":45,"col_end":46,"count":0}]},{"line":"        let account = self.get(addr)?;","counters":[{"col_start":12,"col_end":19,"count":0},{"col_start":22,"col_end":36,"count":0},{"col_start":36,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"        if account.public_key == CompressedPubKey::empty() {","counters":[{"col_start":11,"col_end":58,"count":0}]},{"line":"            None","counters":[{"col_start":12,"col_end":16,"count":0}]},{"line":"        } else {","counters":[]},{"line":"            Some(addr.clone())","counters":[{"col_start":12,"col_end":30,"count":0}]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/mina_base/sparse_ledger_base.ml#L75","counters":[]},{"line":"    fn set(&mut self, addr: &Self::Location, account: Account) {","counters":[{"col_start":4,"col_end":64,"count":0}]},{"line":"        self.set_exn(addr.clone(), account);","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/mina_base/sparse_ledger_base.ml#L96","counters":[]},{"line":"    fn get_or_create(","counters":[{"col_start":4,"col_end":21,"count":0}]},{"line":"        &mut self,","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"        account_id: &AccountId,","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"    ) -> Result<(AccountState, Account, Self::Location), String> {","counters":[{"col_start":0,"col_end":65,"count":0}]},{"line":"        let addr = self","counters":[{"col_start":12,"col_end":16,"count":0},{"col_start":19,"col_end":23,"count":0}]},{"line":"            .get_index(account_id)","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"            .ok_or_else(|| \"failed\".to_string())?;","counters":[{"col_start":0,"col_end":24,"count":0},{"col_start":27,"col_end":47,"count":0},{"col_start":47,"col_end":48,"count":0},{"col_start":48,"col_end":49,"count":0}]},{"line":"        let account = self.get(addr).ok_or_else(|| \"failed\".to_string())?;","counters":[{"col_start":12,"col_end":19,"count":0},{"col_start":22,"col_end":48,"count":0},{"col_start":51,"col_end":71,"count":0},{"col_start":71,"col_end":72,"count":0},{"col_start":72,"col_end":73,"count":0}]},{"line":"","counters":[]},{"line":"        let addr = addr.clone();","counters":[{"col_start":12,"col_end":32,"count":0}]},{"line":"        if account.public_key == CompressedPubKey::empty() {","counters":[{"col_start":0,"col_end":58,"count":0}]},{"line":"            let public_key = account_id.public_key.clone();","counters":[{"col_start":16,"col_end":59,"count":0}]},{"line":"            let mut account = account.clone();","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"","counters":[]},{"line":"            account.delegate = Some(public_key.clone());","counters":[{"col_start":0,"col_end":56,"count":0}]},{"line":"            account.public_key = public_key;","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"            account.token_id = account_id.token_id.clone();","counters":[{"col_start":0,"col_end":59,"count":0}]},{"line":"","counters":[]},{"line":"            self.set(&addr, account.clone());","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"            Ok((AccountState::Added, account, addr))","counters":[{"col_start":0,"col_end":52,"count":0}]},{"line":"        } else {","counters":[]},{"line":"            Ok((AccountState::Existed, account.clone(), addr))","counters":[{"col_start":12,"col_end":62,"count":0}]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/mina_base/sparse_ledger_base.ml#L109","counters":[]},{"line":"    fn create_new_account(&mut self, account_id: AccountId, to_set: Account) -> Result<(), ()> {","counters":[{"col_start":4,"col_end":95,"count":0}]},{"line":"        let addr = self.get_index(&account_id).ok_or(())?;","counters":[{"col_start":12,"col_end":16,"count":0},{"col_start":19,"col_end":56,"count":0},{"col_start":56,"col_end":57,"count":0}]},{"line":"        let account = self.get(addr).ok_or(())?;","counters":[{"col_start":12,"col_end":19,"count":0},{"col_start":22,"col_end":46,"count":0},{"col_start":46,"col_end":47,"count":0}]},{"line":"","counters":[]},{"line":"        if account.public_key == CompressedPubKey::empty() {","counters":[{"col_start":11,"col_end":58,"count":0},{"col_start":59,"col_end":60,"count":0}]},{"line":"            let addr = addr.clone();","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"            self.set(&addr, to_set);","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0},{"col_start":9,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"        Ok(())","counters":[{"col_start":8,"col_end":14,"count":0}]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/mina_base/sparse_ledger_base.ml#L112","counters":[]},{"line":"    fn remove_accounts_exn(&mut self, _account_ids: &[AccountId]) {","counters":[{"col_start":4,"col_end":67,"count":0}]},{"line":"        unimplemented!(\"remove_accounts_exn: not implemented\")","counters":[{"col_start":0,"col_end":62,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/mina_base/sparse_ledger_base.ml#L115","counters":[]},{"line":"    fn merkle_root(&mut self) -> Fp {","counters":[{"col_start":4,"col_end":37,"count":0}]},{"line":"        self.merkle_root()","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/mina_base/sparse_ledger_base.ml#L142","counters":[]},{"line":"    fn empty(depth: usize) -> Self {","counters":[{"col_start":4,"col_end":36,"count":0}]},{"line":"        Self::create(depth, Fp::zero())","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn create_masked(&self) -> Self {","counters":[{"col_start":4,"col_end":37,"count":0}]},{"line":"        todo!()","counters":[{"col_start":0,"col_end":15,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn apply_mask(&mut self, _mask: Self) {","counters":[{"col_start":4,"col_end":43,"count":0}]},{"line":"        todo!()","counters":[{"col_start":0,"col_end":15,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn account_locations(&self) -> Vec<Self::Location> {","counters":[{"col_start":4,"col_end":56,"count":0}]},{"line":"        let mut addrs: Vec<Address> = self.indexes.values().cloned().collect();","counters":[{"col_start":0,"col_end":79,"count":0}]},{"line":"","counters":[]},{"line":"        addrs.sort_by_key(Address::to_index);","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"","counters":[]},{"line":"        addrs","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]}]}