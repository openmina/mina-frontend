{"filename":"src/lib/ledger_catchup/super_catchup.ml","lines":[{"line":"(* Only show stdout for failed inline tests. *)","counters":[{"col_start":46,"col_end":46,"count":1}]},{"line":"open Inline_test_quiet_logs","counters":[]},{"line":"open Core","counters":[]},{"line":"open Async","counters":[]},{"line":"open Cache_lib","counters":[]},{"line":"open Pipe_lib","counters":[]},{"line":"open Mina_numbers","counters":[]},{"line":"open Mina_base","counters":[]},{"line":"open Mina_block","counters":[]},{"line":"open Network_peer","counters":[]},{"line":"","counters":[]},{"line":"module type CONTEXT = sig","counters":[]},{"line":"  val logger : Logger.t","counters":[]},{"line":"","counters":[]},{"line":"  val precomputed_values : Precomputed_values.t","counters":[]},{"line":"","counters":[]},{"line":"  val constraint_constants : Genesis_constants.Constraint_constants.t","counters":[]},{"line":"","counters":[]},{"line":"  val consensus_constants : Consensus.Constants.t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(** [Ledger_catchup] is a procedure that connects a foreign external transition","counters":[]},{"line":"    into a transition frontier by requesting a path of external_transitions","counters":[]},{"line":"    from its peer. It receives the state_hash to catchup from","counters":[]},{"line":"    [Catchup_scheduler]. With that state_hash, it will ask its peers for","counters":[]},{"line":"    a merkle path/list from their oldest transition to the state_hash it is","counters":[]},{"line":"    asking for. Upon receiving the merkle path/list, it will do the following:","counters":[]},{"line":"","counters":[]},{"line":"    1. verify the merkle path/list is correct by calling","counters":[]},{"line":"    [Transition_chain_verifier.verify]. This function would returns a list","counters":[]},{"line":"    of state hashes if the verification is successful.","counters":[]},{"line":"","counters":[]},{"line":"    2. using the list of state hashes to poke a transition frontier","counters":[]},{"line":"    in order to find the hashes of missing transitions. If none of the hashes","counters":[]},{"line":"    are found, then it means some more transitions are missing.","counters":[]},{"line":"","counters":[]},{"line":"    Once the list of missing hashes are computed, it would do another request to","counters":[]},{"line":"    download the corresponding transitions in a batch fashion. Next it will perform the","counters":[]},{"line":"    following validations on each external_transition:","counters":[]},{"line":"","counters":[]},{"line":"    1. Check the list of transitions corresponds to the list of hashes that we","counters":[]},{"line":"    requested;","counters":[]},{"line":"","counters":[]},{"line":"    2. Each transition is checked through [Transition_processor.Validator] and","counters":[]},{"line":"    [Protocol_state_validator]","counters":[]},{"line":"","counters":[]},{"line":"    If any of the external_transitions is invalid,","counters":[]},{"line":"    1) the sender is punished;","counters":[]},{"line":"    2) those external_transitions that already passed validation would be","counters":[]},{"line":"       invalidated.","counters":[]},{"line":"    Otherwise, [Ledger_catchup] will build a corresponding breadcrumb path from","counters":[]},{"line":"    the path of external_transitions. A breadcrumb from the path is built using","counters":[]},{"line":"    its corresponding external_transition staged_ledger_diff and applying it to","counters":[]},{"line":"    its preceding breadcrumb staged_ledger to obtain its corresponding","counters":[]},{"line":"    staged_ledger. If there was an error in building the breadcrumbs, then","counters":[]},{"line":"    catchup would invalidate the cached transitions.","counters":[]},{"line":"    After building the breadcrumb path, [Ledger_catchup] will then send it to","counters":[]},{"line":"    the [Processor] via writing them to catchup_breadcrumbs_writer. *)","counters":[]},{"line":"","counters":[]},{"line":"open Transition_frontier.Full_catchup_tree","counters":[]},{"line":"","counters":[]},{"line":"module G = Graph.Graphviz.Dot (struct","counters":[]},{"line":"  type nonrec t = t","counters":[]},{"line":"","counters":[]},{"line":"  module V = struct","counters":[]},{"line":"    type t = Node.t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module E = struct","counters":[]},{"line":"    type t = { parent : Node.t; child : Node.t }","counters":[]},{"line":"","counters":[]},{"line":"    let src t = t.parent","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"","counters":[]},{"line":"    let dst t = t.child","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let iter_vertex (f : V.t -> unit) (t : t) = Hashtbl.iter t.nodes ~f","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"","counters":[]},{"line":"  let iter_edges_e (f : E.t -> unit) (t : t) =","counters":[]},{"line":"    Hashtbl.iter t.nodes ~f:(fun child ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        match Hashtbl.find t.nodes child.parent with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ()","counters":[]},{"line":"        | Some parent ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            f { child; parent } )","counters":[]},{"line":"","counters":[]},{"line":"  let graph_attributes (_ : t) = [ `Rankdir `LeftToRight ]","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"","counters":[]},{"line":"  let get_subgraph _ = None","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"  let default_vertex_attributes _ = [ `Shape `Circle ]","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"","counters":[]},{"line":"  let vertex_attributes (v : Node.t) =","counters":[]},{"line":"    let color =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      match v.state with","counters":[]},{"line":"      | Failed ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (* red *)","counters":[]},{"line":"          0xFF3333","counters":[]},{"line":"      | Root _ | Finished ->","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"          (* green *)","counters":[]},{"line":"          0x00CC00","counters":[]},{"line":"      | To_download _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (* gray *)","counters":[]},{"line":"          0xA0A0A0","counters":[]},{"line":"      | Wait_for_parent _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (* black *)","counters":[]},{"line":"          0x000000","counters":[]},{"line":"      | To_build_breadcrumb _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (* dark purple *)","counters":[]},{"line":"          0x330033","counters":[]},{"line":"      | To_initial_validate _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (* yellow *)","counters":[]},{"line":"          0xFFFF33","counters":[]},{"line":"      | To_verify _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (* orange *)","counters":[]},{"line":"          0xFF9933","counters":[]},{"line":"    in","counters":[]},{"line":"    [ `Shape `Circle; `Style `Filled; `Fillcolor color ]","counters":[]},{"line":"","counters":[]},{"line":"  let vertex_name (node : V.t) =","counters":[]},{"line":"    sprintf \"\\\"%s\\\"\" (State_hash.to_base58_check node.state_hash)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"","counters":[]},{"line":"  let default_edge_attributes _ = []","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"","counters":[]},{"line":"  let edge_attributes _ = []","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"end)","counters":[]},{"line":"","counters":[]},{"line":"let write_graph (_ : t) =","counters":[]},{"line":"  let _ = G.output_graph in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  ()","counters":[]},{"line":"","counters":[]},{"line":"let verify_transition ~context:(module Context : CONTEXT) ~trust_system","counters":[]},{"line":"    ~frontier ~unprocessed_transition_cache enveloped_transition =","counters":[]},{"line":"  let open Context in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let sender = Envelope.Incoming.sender enveloped_transition in","counters":[]},{"line":"  let genesis_state_hash = Transition_frontier.genesis_state_hash frontier in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let transition_with_hash = Envelope.Incoming.data enveloped_transition in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let cached_initially_validated_transition_result =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    let open Result.Let_syntax in","counters":[]},{"line":"    let%bind initially_validated_transition =","counters":[]},{"line":"      transition_with_hash","counters":[]},{"line":"      |> Validation.skip_time_received_validation","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"           `This_block_was_not_received_via_gossip","counters":[]},{"line":"      |> Validation.validate_genesis_protocol_state ~genesis_state_hash","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"      >>= Validation.validate_protocol_versions","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      >>= Validation.validate_delta_block_chain","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    in","counters":[]},{"line":"    let enveloped_initially_validated_transition =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Envelope.Incoming.map enveloped_transition","counters":[]},{"line":"        ~f:(Fn.const initially_validated_transition)","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"    in","counters":[]},{"line":"    Transition_handler.Validator.validate_transition","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ~context:(module Context)","counters":[]},{"line":"      ~frontier ~unprocessed_transition_cache","counters":[]},{"line":"      enveloped_initially_validated_transition","counters":[]},{"line":"  in","counters":[]},{"line":"  let state_hash =","counters":[]},{"line":"    Validation.block_with_hash transition_with_hash","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"    |> State_hash.With_state_hashes.state_hash |> State_hash.to_yojson","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"  in","counters":[]},{"line":"  let open Deferred.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  match cached_initially_validated_transition_result with","counters":[]},{"line":"  | Ok x ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      [%log trace]","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"        ~metadata:[ (\"state_hash\", state_hash) ]","counters":[]},{"line":"        \"initial_validate: validation is successful\" ;","counters":[]},{"line":"      Deferred.return @@ Ok (`Building_path x)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  | Error (`In_frontier hash) ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      [%log trace]","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"        ~metadata:[ (\"state_hash\", state_hash) ]","counters":[]},{"line":"        \"initial_validate: transition queried during ledger catchup has \\","counters":[]},{"line":"         already been seen\" ;","counters":[]},{"line":"      Deferred.return @@ Ok (`In_frontier hash)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  | Error (`In_process consumed_state) -> (","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      [%log trace]","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"        ~metadata:[ (\"state_hash\", state_hash) ]","counters":[]},{"line":"        \"initial_validate: transition queried during ledger catchup is still \\","counters":[]},{"line":"         in process in one of the components in transition_frontier\" ;","counters":[]},{"line":"      match%map Ivar.read consumed_state with","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"      | `Failed ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          [%log trace]","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"            ~metadata:[ (\"state_hash\", state_hash) ]","counters":[]},{"line":"            \"initial_validate: transition queried during ledger catchup failed\" ;","counters":[]},{"line":"          Error (Error.of_string \"Previous transition failed\")","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"      | `Success hash ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          [%log trace]","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"            ~metadata:[ (\"state_hash\", state_hash) ]","counters":[]},{"line":"            \"initial_validate: transition queried during ledger catchup is \\","counters":[]},{"line":"             added to frontier\" ;","counters":[]},{"line":"          Ok (`In_frontier hash) )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"  | Error (`Verifier_error error) ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      [%log warn]","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"        ~metadata:","counters":[]},{"line":"          [ (\"error\", Error_json.error_to_yojson error)","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"          ; (\"state_hash\", state_hash)","counters":[]},{"line":"          ]","counters":[]},{"line":"        \"initial_validate: verifier threw an error while verifying transiton \\","counters":[]},{"line":"         queried during ledger catchup: $error\" ;","counters":[]},{"line":"      Deferred.Or_error.fail (Error.tag ~tag:\"verifier threw an error\" error)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"  | Error `Invalid_proof ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let%map () =","counters":[]},{"line":"        Trust_system.record_envelope_sender trust_system logger sender","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"          ( Trust_system.Actions.Gossiped_invalid_transition","counters":[]},{"line":"          , Some (\"invalid proof\", []) )","counters":[]},{"line":"      in","counters":[]},{"line":"      [%log warn]","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":16,"col_end":16,"count":0}]},{"line":"        ~metadata:[ (\"state_hash\", state_hash) ]","counters":[]},{"line":"        \"initial_validate: invalid proof\" ;","counters":[]},{"line":"      Error (Error.of_string \"invalid proof\")","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"  | Error `Invalid_genesis_protocol_state ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let%map () =","counters":[]},{"line":"        Trust_system.record_envelope_sender trust_system logger sender","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"          ( Trust_system.Actions.Gossiped_invalid_transition","counters":[]},{"line":"          , Some (\"invalid genesis protocol state\", []) )","counters":[]},{"line":"      in","counters":[]},{"line":"      [%log warn]","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":16,"col_end":16,"count":0}]},{"line":"        ~metadata:[ (\"state_hash\", state_hash) ]","counters":[]},{"line":"        \"initial_validate: invalid genesis protocol state\" ;","counters":[]},{"line":"      Error (Error.of_string \"invalid genesis protocol state\")","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"  | Error `Invalid_delta_block_chain_proof ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      [%log warn]","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"        ~metadata:[ (\"state_hash\", state_hash) ]","counters":[]},{"line":"        \"initial_validate: invalid delta transition chain proof\" ;","counters":[]},{"line":"      let%map () =","counters":[]},{"line":"        Trust_system.record_envelope_sender trust_system logger sender","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"          ( Trust_system.Actions.Gossiped_invalid_transition","counters":[]},{"line":"          , Some (\"invalid delta transition chain witness\", []) )","counters":[]},{"line":"      in","counters":[]},{"line":"      Error (Error.of_string \"invalid delta transition chain witness\")","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"  | Error `Invalid_protocol_version ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      [%log warn]","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"        ~metadata:[ (\"state_hash\", state_hash) ]","counters":[]},{"line":"        \"initial_validate: invalid protocol version\" ;","counters":[]},{"line":"      let transition = Validation.block transition_with_hash in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%map () =","counters":[]},{"line":"        Trust_system.record_envelope_sender trust_system logger sender","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"          ( Trust_system.Actions.Sent_invalid_protocol_version","counters":[]},{"line":"          , Some","counters":[]},{"line":"              ( \"Invalid current or proposed protocol version in catchup block\"","counters":[]},{"line":"              , [ ( \"current_protocol_version\"","counters":[]},{"line":"                  , `String","counters":[]},{"line":"                      ( Header.current_protocol_version","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"                          (Mina_block.header transition)","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"                      |> Protocol_version.to_string ) )","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                ; ( \"proposed_protocol_version\"","counters":[]},{"line":"                  , `String","counters":[]},{"line":"                      ( Header.proposed_protocol_version_opt","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"                          (Mina_block.header transition)","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"                      |> Option.value_map ~default:\"<None>\"","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"                           ~f:Protocol_version.to_string ) )","counters":[]},{"line":"                ] ) )","counters":[]},{"line":"      in","counters":[]},{"line":"      Error (Error.of_string \"invalid protocol version\")","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"  | Error `Mismatched_protocol_version ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      [%log warn]","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"        ~metadata:[ (\"state_hash\", state_hash) ]","counters":[]},{"line":"        \"initial_validate: mismatch protocol version\" ;","counters":[]},{"line":"      let transition = Validation.block transition_with_hash in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%map () =","counters":[]},{"line":"        Trust_system.record_envelope_sender trust_system logger sender","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"          ( Trust_system.Actions.Sent_mismatched_protocol_version","counters":[]},{"line":"          , Some","counters":[]},{"line":"              ( \"Current protocol version in catchup block does not match \\","counters":[]},{"line":"                 daemon protocol version\"","counters":[]},{"line":"              , [ ( \"block_current_protocol_version\"","counters":[]},{"line":"                  , `String","counters":[]},{"line":"                      ( Header.current_protocol_version","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"                          (Mina_block.header transition)","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"                      |> Protocol_version.to_string ) )","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                ; ( \"daemon_current_protocol_version\"","counters":[]},{"line":"                  , `String Protocol_version.(get_current () |> to_string) )","counters":[{"col_start":56,"col_end":56,"count":0},{"col_start":72,"col_end":72,"count":0}]},{"line":"                ] ) )","counters":[]},{"line":"      in","counters":[]},{"line":"      Error (Error.of_string \"mismatched protocol version\")","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"  | Error `Disconnected ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      [%log warn]","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"        ~metadata:[ (\"state_hash\", state_hash) ]","counters":[]},{"line":"        \"initial_validate: disconnected chain\" ;","counters":[]},{"line":"      Deferred.Or_error.fail @@ Error.of_string \"disconnected chain\"","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"","counters":[]},{"line":"let find_map_ok ?how xs ~f =","counters":[]},{"line":"  let res = Ivar.create () in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let errs = ref [] in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  don't_wait_for","counters":[]},{"line":"    (let%map () =","counters":[]},{"line":"       Deferred.List.iter xs ?how ~f:(fun x ->","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"           if Ivar.is_full res then Deferred.unit","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"           else","counters":[]},{"line":"             match%map","counters":[]},{"line":"               choose","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                 [ choice (Ivar.read res) (fun _ -> `Finished)","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"                 ; choice (f x) (fun x -> `Ok x)","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"                 ]","counters":[]},{"line":"             with","counters":[]},{"line":"             | `Finished ->","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                 ()","counters":[]},{"line":"             | `Ok (Ok x) ->","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                 Ivar.fill_if_empty res (Ok x)","counters":[]},{"line":"             | `Ok (Error e) ->","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                 errs := e :: !errs )","counters":[]},{"line":"     in","counters":[]},{"line":"     Ivar.fill_if_empty res (Error !errs) ) ;","counters":[{"col_start":5,"col_end":5,"count":0}]},{"line":"  Ivar.read res","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"type download_state_hashes_error =","counters":[]},{"line":"  [ `Peer_moves_too_fast","counters":[]},{"line":"  | `No_common_ancestor","counters":[]},{"line":"  | `Failed_to_download_transition_chain_proof","counters":[]},{"line":"  | `Invalid_transition_chain_proof ]","counters":[]},{"line":"","counters":[]},{"line":"let rec contains_no_common_ancestor = function","counters":[]},{"line":"  | [] ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      false","counters":[]},{"line":"  | `No_common_ancestor :: _ ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      true","counters":[]},{"line":"  | _ :: errors ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      contains_no_common_ancestor errors","counters":[]},{"line":"","counters":[]},{"line":"let try_to_connect_hash_chain t hashes ~frontier","counters":[]},{"line":"    ~blockchain_length_of_target_hash =","counters":[]},{"line":"  let logger = t.logger in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let blockchain_length_of_root =","counters":[]},{"line":"    Transition_frontier.root frontier","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"    |> Transition_frontier.Breadcrumb.consensus_state","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"    |> Consensus.Data.Consensus_state.blockchain_length","counters":[]},{"line":"  in","counters":[]},{"line":"  List.fold_until","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    (Non_empty_list.to_list hashes)","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"    ~init:(blockchain_length_of_target_hash, [])","counters":[]},{"line":"    ~f:(fun (blockchain_length, acc) hash ->","counters":[]},{"line":"      let f x = Continue_or_stop.Stop (Ok (x, acc)) in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":16,"col_end":16,"count":0}]},{"line":"      match","counters":[]},{"line":"        (Hashtbl.find t.nodes hash, Transition_frontier.find frontier hash)","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"      with","counters":[]},{"line":"      | Some node, None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          f (`Node node)","counters":[]},{"line":"      | Some node, Some b ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          finish t node (Ok b) ;","counters":[]},{"line":"          f (`Node node)","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"      | None, Some b ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          f (`Breadcrumb b)","counters":[]},{"line":"      | None, None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Continue (Unsigned.UInt32.pred blockchain_length, hash :: acc) )","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"    ~finish:(fun (blockchain_length, acc) ->","counters":[]},{"line":"      let module T = struct","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        type t = State_hash.t list [@@deriving to_yojson]","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"      end in","counters":[]},{"line":"      let all_hashes =","counters":[]},{"line":"        List.map (Transition_frontier.all_breadcrumbs frontier) ~f:(fun b ->","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"            Frontier_base.Breadcrumb.state_hash b )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"      in","counters":[]},{"line":"      [%log debug]","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"        ~metadata:","counters":[]},{"line":"          [ (\"n\", `Int (List.length acc))","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"          ; (\"hashes\", T.to_yojson acc)","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"          ; (\"all_hashes\", T.to_yojson all_hashes)","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"          ]","counters":[]},{"line":"        \"Finishing download_state_hashes with $n $hashes. with $all_hashes\" ;","counters":[]},{"line":"      if","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Unsigned.UInt32.compare blockchain_length blockchain_length_of_root <= 0","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"      then Result.fail `No_common_ancestor","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"      else Result.fail `Peer_moves_too_fast )","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"","counters":[]},{"line":"module Downloader = struct","counters":[]},{"line":"  module Key = struct","counters":[]},{"line":"    module T = struct","counters":[]},{"line":"      type t = State_hash.t * Length.t [@@deriving to_yojson, hash, sexp]","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"      let compare (h1, n1) (h2, n2) =","counters":[]},{"line":"        match Length.compare n1 n2 with 0 -> State_hash.compare h1 h2 | c -> c","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":72,"col_end":72,"count":0}]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    include T","counters":[]},{"line":"    include Hashable.Make (T)","counters":[]},{"line":"    include Comparable.Make (T)","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  include","counters":[]},{"line":"    Downloader.Make","counters":[]},{"line":"      (Key)","counters":[]},{"line":"      (struct","counters":[]},{"line":"        include Attempt_history.Attempt","counters":[]},{"line":"","counters":[]},{"line":"        let download : t = { failure_reason = `Download }","counters":[]},{"line":"","counters":[]},{"line":"        let worth_retrying (t : t) =","counters":[]},{"line":"          match t.failure_reason with `Download -> true | _ -> false","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"      end)","counters":[]},{"line":"      (struct","counters":[]},{"line":"        type t = Mina_block.t","counters":[]},{"line":"","counters":[]},{"line":"        let key (t : t) =","counters":[]},{"line":"          ( ( Mina_block.header t |> Header.protocol_state","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"            |> Mina_state.Protocol_state.hashes )","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"              .state_hash","counters":[]},{"line":"          , Mina_block.blockchain_length t )","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"      end)","counters":[]},{"line":"      (struct","counters":[]},{"line":"        type t = (State_hash.t * Length.t) option","counters":[]},{"line":"      end)","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let with_lengths hs ~target_length =","counters":[]},{"line":"  List.filter_mapi (Non_empty_list.to_list hs) ~f:(fun i x ->","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"      let open Option.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%map x_len = Length.sub target_length (Length.of_int i) in","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"      (x, x_len) )","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"(* returns a list of state-hashes with the older ones at the front *)","counters":[]},{"line":"let download_state_hashes t ~logger ~trust_system ~network ~frontier","counters":[]},{"line":"    ~target_hash ~target_length ~downloader ~blockchain_length_of_target_hash","counters":[]},{"line":"    ~preferred_peers =","counters":[]},{"line":"  [%log debug]","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":13,"col_end":13,"count":0}]},{"line":"    ~metadata:[ (\"target_hash\", State_hash.to_yojson target_hash) ]","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"    \"Doing a catchup job with target $target_hash\" ;","counters":[]},{"line":"  let%bind all_peers = Mina_networking.peers network >>| Peer.Set.of_list in","counters":[{"col_start":43,"col_end":43,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"  let preferred_peers_alive = Peer.Set.inter all_peers preferred_peers in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let non_preferred_peers = Peer.Set.diff all_peers preferred_peers_alive in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let peers =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Peer.Set.to_list preferred_peers @ Peer.Set.to_list non_preferred_peers","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"  in","counters":[]},{"line":"  let open Deferred.Result.Let_syntax in","counters":[]},{"line":"  find_map_ok ~how:(`Max_concurrent_jobs 5) peers ~f:(fun peer ->","counters":[]},{"line":"      let%bind transition_chain_proof =","counters":[]},{"line":"        let open Deferred.Let_syntax in","counters":[]},{"line":"        match%map","counters":[]},{"line":"          Mina_networking.get_transition_chain_proof","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"            ~timeout:(Time.Span.of_sec 10.) network peer target_hash","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"        with","counters":[]},{"line":"        | Error _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Result.fail `Failed_to_download_transition_chain_proof","counters":[]},{"line":"        | Ok transition_chain_proof ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Result.return transition_chain_proof","counters":[]},{"line":"      in","counters":[]},{"line":"      let now = Time.now () in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      (* a list of state_hashes from new to old *)","counters":[]},{"line":"      let%bind hashes =","counters":[]},{"line":"        match","counters":[]},{"line":"          Transition_chain_verifier.verify ~target_hash ~transition_chain_proof","counters":[]},{"line":"        with","counters":[]},{"line":"        | Some hs ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let ks = with_lengths hs ~target_length in","counters":[]},{"line":"            Downloader.update_knowledge downloader peer (`Some ks) ;","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            Downloader.mark_preferred downloader peer ~now ;","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            Deferred.Result.return hs","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let error_msg =","counters":[]},{"line":"              sprintf !\"Peer %{sexp:Network_peer.Peer.t} sent us bad proof\" peer","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"            in","counters":[]},{"line":"            let%bind.Deferred () =","counters":[]},{"line":"              Trust_system.(","counters":[]},{"line":"                record trust_system logger peer","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                  Actions.","counters":[]},{"line":"                    ( Sent_invalid_transition_chain_merkle_proof","counters":[]},{"line":"                    , Some (error_msg, []) ))","counters":[]},{"line":"            in","counters":[]},{"line":"            Deferred.Result.fail `Invalid_transition_chain_proof","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"      in","counters":[]},{"line":"      Deferred.return","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ( match","counters":[]},{"line":"            try_to_connect_hash_chain t hashes ~frontier","counters":[]},{"line":"              ~blockchain_length_of_target_hash","counters":[]},{"line":"          with","counters":[]},{"line":"        | Ok x ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Downloader.mark_preferred downloader peer ~now ;","counters":[]},{"line":"            Ok x","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"        | Error e ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Error e ) )","counters":[]},{"line":"","counters":[]},{"line":"let get_state_hashes = ()","counters":[]},{"line":"","counters":[]},{"line":"module Initial_validate_batcher = struct","counters":[]},{"line":"  open Network_pool.Batcher","counters":[]},{"line":"","counters":[]},{"line":"  type input = (Mina_block.t, State_hash.t) With_hash.t Envelope.Incoming.t","counters":[]},{"line":"","counters":[]},{"line":"  type nonrec 'a t = (input, input, 'a) t","counters":[]},{"line":"","counters":[]},{"line":"  let create ~verifier ~precomputed_values : _ t =","counters":[]},{"line":"    create","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ~logger:","counters":[]},{"line":"        (Logger.create","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"           ~metadata:[ (\"name\", `String \"initial_validate_batcher\") ]","counters":[]},{"line":"           () )","counters":[]},{"line":"      ~how_to_add:`Insert ~max_weight_per_call:1000","counters":[]},{"line":"      ~weight:(fun _ -> 1)","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"      ~compare_init:(fun e1 e2 ->","counters":[]},{"line":"        let len (x : input) = Mina_block.blockchain_length x.data.data in","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"        match Length.compare (len e1) (len e2) with","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"        | 0 ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            compare_envelope e1 e2","counters":[]},{"line":"        | c ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            c )","counters":[]},{"line":"      (fun xs ->","counters":[]},{"line":"        let input = function `Partially_validated x | `Init x -> x in","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"        let genesis_state_hash =","counters":[]},{"line":"          Precomputed_values.genesis_state_with_hashes precomputed_values","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"          |> State_hash.With_state_hashes.state_hash","counters":[]},{"line":"        in","counters":[]},{"line":"        List.map xs ~f:(fun x ->","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"            input x |> Envelope.Incoming.data","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"            |> With_hash.map_hash ~f:(fun state_hash ->","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                   { State_hash.State_hashes.state_hash","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"                   ; state_body_hash = None","counters":[]},{"line":"                   } )","counters":[]},{"line":"            |> Validation.wrap )","counters":[]},{"line":"        |> Validation.validate_proofs ~verifier ~genesis_state_hash","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"        >>| function","counters":[]},{"line":"        | Ok tvs ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Ok (List.map tvs ~f:(fun x -> `Valid x))","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"        | Error `Invalid_proof ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Ok (List.map xs ~f:(fun x -> `Potentially_invalid (input x)))","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"        | Error (`Verifier_error e) ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Error e )","counters":[]},{"line":"","counters":[]},{"line":"  let verify (t : _ t) = verify t","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Verify_work_batcher = struct","counters":[]},{"line":"  open Network_pool.Batcher","counters":[]},{"line":"","counters":[]},{"line":"  type input = Mina_block.initial_valid_block Envelope.Incoming.t","counters":[]},{"line":"","counters":[]},{"line":"  type nonrec 'a t = (input, input, 'a) t","counters":[]},{"line":"","counters":[]},{"line":"  let create ~verifier : _ t =","counters":[]},{"line":"    let works (x : input) =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let wh, _ = x.data in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Body.staged_ledger_diff (Mina_block.body wh.data)","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"      |> Staged_ledger_diff.completed_works","counters":[]},{"line":"    in","counters":[]},{"line":"    create","counters":[]},{"line":"      ~logger:","counters":[]},{"line":"        (Logger.create ~metadata:[ (\"name\", `String \"verify_work_batcher\") ] ())","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"      ~weight:(fun (x : input) ->","counters":[]},{"line":"        List.fold ~init:0 (works x) ~f:(fun acc { proofs; _ } ->","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"            acc + One_or_two.length proofs ) )","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"      ~max_weight_per_call:1000 ~how_to_add:`Insert","counters":[]},{"line":"      ~compare_init:(fun e1 e2 ->","counters":[]},{"line":"        let len (x : input) =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Validation.block x.data |> Mina_block.blockchain_length","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"        in","counters":[]},{"line":"        match Length.compare (len e1) (len e2) with","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"        | 0 ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            compare_envelope e1 e2","counters":[]},{"line":"        | c ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            c )","counters":[]},{"line":"      (fun xs ->","counters":[]},{"line":"        let input : _ -> input = function","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          | `Partially_validated x | `Init x ->","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"              x","counters":[]},{"line":"        in","counters":[]},{"line":"        List.concat_map xs ~f:(fun x ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"            works (input x)","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"            |> List.concat_map ~f:(fun { fee; prover; proofs } ->","counters":[]},{"line":"                   let msg = Sok_message.create ~fee ~prover in","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"                   One_or_two.to_list","counters":[]},{"line":"                     (One_or_two.map proofs ~f:(fun p -> (p, msg))) ) )","counters":[{"col_start":35,"col_end":35,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"        |> Verifier.verify_transaction_snarks verifier","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"        >>| function","counters":[]},{"line":"        | Ok true ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Ok (List.map xs ~f:(fun x -> `Valid (input x)))","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"        | Ok false ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Ok (List.map xs ~f:(fun x -> `Potentially_invalid (input x)))","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"        | Error e ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Error e )","counters":[]},{"line":"","counters":[]},{"line":"  let verify (t : _ t) = verify t","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let initial_validate ~context:(module Context : CONTEXT) ~trust_system","counters":[]},{"line":"    ~(batcher : _ Initial_validate_batcher.t) ~frontier","counters":[]},{"line":"    ~unprocessed_transition_cache transition =","counters":[]},{"line":"  let open Context in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let verification_start_time = Core.Time.now () in","counters":[]},{"line":"  let open Deferred.Result.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let state_hash =","counters":[]},{"line":"    Envelope.Incoming.data transition |> With_hash.hash |> State_hash.to_yojson","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"  in","counters":[]},{"line":"  [%log debug]","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":13,"col_end":13,"count":0}]},{"line":"    ~metadata:[ (\"state_hash\", state_hash) ]","counters":[]},{"line":"    \"initial_validate: start processing $state_hash\" ;","counters":[]},{"line":"  let%bind tv =","counters":[]},{"line":"    let open Deferred.Let_syntax in","counters":[]},{"line":"    match%bind Initial_validate_batcher.verify batcher transition with","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"    | Ok (Ok tv) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        return (Ok { transition with data = tv })","counters":[]},{"line":"    | Ok (Error invalid) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let s = \"initial_validate: block failed to verify, invalid proof\" in","counters":[]},{"line":"        [%log warn]","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"          ~metadata:[ (\"state_hash\", state_hash) ]","counters":[]},{"line":"          \"%s, %s\" s","counters":[]},{"line":"          (Verifier.invalid_to_string invalid) ;","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"        let%map () =","counters":[]},{"line":"          match transition.sender with","counters":[]},{"line":"          | Local ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Deferred.unit","counters":[]},{"line":"          | Remote peer ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Trust_system.(","counters":[]},{"line":"                record trust_system logger peer","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                  Actions.(Sent_invalid_proof, None))","counters":[]},{"line":"        in","counters":[]},{"line":"        Error (`Error (Error.of_string s))","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"    | Error e ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [%log warn]","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"          ~metadata:","counters":[]},{"line":"            [ (\"error\", Error_json.error_to_yojson e)","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"            ; (\"state_hash\", state_hash)","counters":[]},{"line":"            ]","counters":[]},{"line":"          \"initial_validate: verification of blockchain snark failed but it \\","counters":[]},{"line":"           was our fault\" ;","counters":[]},{"line":"        return (Error `Couldn't_reach_verifier)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"  in","counters":[]},{"line":"  let verification_end_time = Core.Time.now () in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  [%log debug]","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":13,"col_end":13,"count":0}]},{"line":"    ~metadata:","counters":[]},{"line":"      [ ( \"time_elapsed\"","counters":[]},{"line":"        , `Float","counters":[]},{"line":"            Core.Time.(","counters":[]},{"line":"              Span.to_sec @@ diff verification_end_time verification_start_time)","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"        )","counters":[]},{"line":"      ; (\"state_hash\", state_hash)","counters":[]},{"line":"      ]","counters":[]},{"line":"    \"initial_validate: verification of proofs complete\" ;","counters":[]},{"line":"  verify_transition","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"    ~context:(module Context)","counters":[]},{"line":"    ~trust_system ~frontier ~unprocessed_transition_cache tv","counters":[]},{"line":"  |> Deferred.map ~f:(Result.map_error ~f:(fun e -> `Error e))","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"","counters":[]},{"line":"open Frontier_base","counters":[]},{"line":"","counters":[]},{"line":"let check_invariant ~downloader t =","counters":[]},{"line":"  Downloader.check_invariant downloader ;","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  [%test_eq: int]","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":13,"col_end":13,"count":0}]},{"line":"    (Downloader.total_jobs downloader)","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"    (Hashtbl.count t.nodes ~f:(fun node ->","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"         Node.State.Enum.equal (Node.State.enum node.state) To_download ) )","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"","counters":[]},{"line":"let download s d ~key ~attempts =","counters":[]},{"line":"  let logger = Logger.create () in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  [%log debug]","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":13,"col_end":13,"count":0}]},{"line":"    ~metadata:[ (\"key\", Downloader.Key.to_yojson key); (\"caller\", `String s) ]","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"    \"Download download $key\" ;","counters":[]},{"line":"  Downloader.download d ~key ~attempts","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let create_node ~downloader t x =","counters":[]},{"line":"  let attempts = Attempt_history.empty in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let state, h, blockchain_length, parent, result =","counters":[]},{"line":"    match x with","counters":[]},{"line":"    | `Root root ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ( Node.State.Finished","counters":[]},{"line":"        , Breadcrumb.state_hash root","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"        , Breadcrumb.consensus_state root","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"          |> Consensus.Data.Consensus_state.blockchain_length","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"        , Breadcrumb.parent_hash root","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"        , Ivar.create_full (Ok `Added_to_frontier) )","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"    | `Hash (h, l, parent) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ( Node.State.To_download","counters":[]},{"line":"            (download \"create_node\" downloader ~key:(h, l) ~attempts)","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"        , h","counters":[]},{"line":"        , l","counters":[]},{"line":"        , parent","counters":[]},{"line":"        , Ivar.create () )","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"    | `Initial_validated (b, valid_cb) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let t = (Cached.peek b).Envelope.Incoming.data in","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"        ( Node.State.To_verify (b, valid_cb)","counters":[]},{"line":"        , Validation.block_with_hash t","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"          |> State_hash.With_state_hashes.state_hash","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"        , Validation.block t |> Mina_block.blockchain_length","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"        , Validation.block t |> Mina_block.header","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"          |> Mina_block.Header.protocol_state","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"          |> Mina_state.Protocol_state.previous_state_hash","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"        , Ivar.create () )","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"  in","counters":[]},{"line":"  let node =","counters":[]},{"line":"    { Node.state; state_hash = h; blockchain_length; attempts; parent; result }","counters":[]},{"line":"  in","counters":[]},{"line":"  upon (Ivar.read node.result) (fun _ ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"      Downloader.cancel downloader (h, blockchain_length) ) ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  Transition_frontier.Full_catchup_tree.add_state t.states node ;","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  Hashtbl.set t.nodes ~key:h ~data:node ;","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  ( try check_invariant ~downloader t","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"    with e ->","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"      [%log' debug t.logger]","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"        ~metadata:[ (\"exn\", `String (Exn.to_string e)) ]","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"        \"create_node $exn\" ) ;","counters":[]},{"line":"  write_graph t ; node","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"","counters":[]},{"line":"let set_state t node s = set_state t node s ; write_graph t","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"","counters":[]},{"line":"let pick ~context:(module Context : CONTEXT)","counters":[]},{"line":"    (x : Mina_state.Protocol_state.Value.t State_hash.With_state_hashes.t)","counters":[]},{"line":"    (y : Mina_state.Protocol_state.Value.t State_hash.With_state_hashes.t) =","counters":[]},{"line":"  let f = With_hash.map ~f:Mina_state.Protocol_state.consensus_state in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  match","counters":[]},{"line":"    Consensus.Hooks.select","counters":[]},{"line":"      ~context:(module Context)","counters":[]},{"line":"      ~existing:(f x) ~candidate:(f y)","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"  with","counters":[]},{"line":"  | `Keep ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      x","counters":[]},{"line":"  | `Take ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      y","counters":[]},{"line":"","counters":[]},{"line":"let forest_pick forest =","counters":[]},{"line":"  with_return (fun { return } ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      List.iter forest ~f:(Rose_tree.iter ~f:return) ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      assert false )","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"let setup_state_machine_runner ~context:(module Context : CONTEXT) ~t ~verifier","counters":[]},{"line":"    ~downloader ~trust_system ~frontier ~unprocessed_transition_cache","counters":[]},{"line":"    ~catchup_breadcrumbs_writer","counters":[]},{"line":"    ~(build_func :","counters":[]},{"line":"          ?skip_staged_ledger_verification:[ `All | `Proofs ]","counters":[]},{"line":"       -> logger:Logger.t","counters":[]},{"line":"       -> precomputed_values:Precomputed_values.t","counters":[]},{"line":"       -> verifier:Verifier.t","counters":[]},{"line":"       -> trust_system:Trust_system.t","counters":[]},{"line":"       -> parent:Breadcrumb.t","counters":[]},{"line":"       -> transition:Mina_block.almost_valid_block","counters":[]},{"line":"       -> sender:Envelope.Sender.t option","counters":[]},{"line":"       -> transition_receipt_time:Time.t option","counters":[]},{"line":"       -> unit","counters":[]},{"line":"       -> ( Breadcrumb.t","counters":[]},{"line":"          , [> `Invalid_staged_ledger_diff of Error.t","counters":[]},{"line":"            | `Invalid_staged_ledger_hash of Error.t","counters":[]},{"line":"            | `Fatal_error of exn ] )","counters":[]},{"line":"          Result.t","counters":[]},{"line":"          Deferred.t ) =","counters":[]},{"line":"  let open Context in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  (* setup_state_machine_runner returns a fully configured lambda function, which is the state machine runner *)","counters":[]},{"line":"  let initial_validation_batcher =","counters":[]},{"line":"    Initial_validate_batcher.create ~verifier ~precomputed_values","counters":[]},{"line":"  in","counters":[]},{"line":"  let verify_work_batcher = Verify_work_batcher.create ~verifier in","counters":[]},{"line":"  let set_state t node s =","counters":[]},{"line":"    set_state t node s ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    try check_invariant ~downloader t","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"    with e ->","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"      [%log' debug t.logger]","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"        ~metadata:[ (\"exn\", `String (Exn.to_string e)) ]","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"        \"set_state $exn\"","counters":[]},{"line":"  in","counters":[]},{"line":"  let rec run_node (node : Node.t) =","counters":[]},{"line":"    let state_hash = node.state_hash in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let failed ?error ~sender failure_reason =","counters":[]},{"line":"      [%log' debug t.logger] \"failed with $error\"","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"        ~metadata:","counters":[]},{"line":"          [ ( \"error\"","counters":[]},{"line":"            , Option.value_map ~default:`Null error ~f:(fun e ->","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                  `String (Error.to_string_hum e) ) )","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"          ; (\"reason\", Attempt_history.Attempt.reason_to_yojson failure_reason)","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"          ] ;","counters":[]},{"line":"      node.attempts <-","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ( match sender with","counters":[]},{"line":"        | Envelope.Sender.Local ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            node.attempts","counters":[]},{"line":"        | Remote peer ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Map.set node.attempts ~key:peer ~data:{ failure_reason } ) ;","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"      set_state t node","counters":[]},{"line":"        (To_download","counters":[]},{"line":"           (download \"failed\" downloader","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"              ~key:(state_hash, node.blockchain_length)","counters":[]},{"line":"              ~attempts:node.attempts ) ) ;","counters":[]},{"line":"      run_node node","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    in","counters":[]},{"line":"    let step d : (_, [ `Finished ]) Deferred.Result.t =","counters":[]},{"line":"      (* TODO: See if the bail out is happening. *)","counters":[]},{"line":"      Deferred.any [ (Ivar.read node.result >>| fun _ -> Error `Finished); d ]","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":46,"col_end":46,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"    in","counters":[]},{"line":"    let open Deferred.Result.Let_syntax in","counters":[]},{"line":"    let retry () =","counters":[]},{"line":"      let%bind () =","counters":[]},{"line":"        step (after (Time.Span.of_sec 15.) |> Deferred.map ~f:Result.return)","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"      in","counters":[]},{"line":"      run_node node","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    in","counters":[]},{"line":"    match node.state with","counters":[]},{"line":"    | Failed | Finished | Root _ ->","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"        return ()","counters":[]},{"line":"    | To_download download_job ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let start_time = Time.now () in","counters":[]},{"line":"        let%bind external_block, attempts =","counters":[]},{"line":"          step (Downloader.Job.result download_job)","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"        in","counters":[]},{"line":"        [%log' debug t.logger]","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"          ~metadata:","counters":[]},{"line":"            [ (\"state_hash\", State_hash.to_yojson state_hash)","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"            ; ( \"donwload_number\"","counters":[]},{"line":"              , `Int","counters":[]},{"line":"                  (Hashtbl.count t.nodes ~f:(fun node ->","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                       Node.State.Enum.equal","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                         (Node.State.enum node.state)","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"                         To_download ) ) )","counters":[]},{"line":"            ; (\"total_nodes\", `Int (Hashtbl.length t.nodes))","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"            ; ( \"node_states\"","counters":[]},{"line":"              , let s = Node.State.Enum.Table.create () in","counters":[]},{"line":"                Hashtbl.iter t.nodes ~f:(fun node ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                    Hashtbl.incr s (Node.State.enum node.state) ) ;","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"                `List","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  (List.map (Hashtbl.to_alist s) ~f:(fun (k, v) ->","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"                       `List [ Node.State.Enum.to_yojson k; `Int v ] ) ) )","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"            ; (\"total_jobs\", `Int (Downloader.total_jobs downloader))","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"            ; (\"downloader\", Downloader.to_yojson downloader)","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"            ]","counters":[]},{"line":"          \"download finished $state_hash\" ;","counters":[]},{"line":"        node.attempts <- attempts ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Mina_metrics.(","counters":[]},{"line":"          Gauge.set Catchup.download_time","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"            Time.(Span.to_ms @@ diff (now ()) start_time)) ;","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"        set_state t node (To_initial_validate external_block) ;","counters":[]},{"line":"        run_node node","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    | To_initial_validate external_block -> (","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let start_time = Time.now () in","counters":[]},{"line":"        match%bind","counters":[]},{"line":"          step","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"            ( initial_validate","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                ~context:(module Context)","counters":[]},{"line":"                ~trust_system ~batcher:initial_validation_batcher ~frontier","counters":[]},{"line":"                ~unprocessed_transition_cache","counters":[]},{"line":"                { external_block with","counters":[]},{"line":"                  data =","counters":[]},{"line":"                    { With_hash.data = external_block.data; hash = state_hash }","counters":[]},{"line":"                }","counters":[]},{"line":"            |> Deferred.map ~f:(fun x -> Ok x) )","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"        with","counters":[]},{"line":"        | Error (`Error e) ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (* TODO: Log *)","counters":[]},{"line":"            (* Validation failed. Record the failure and go back to download. *)","counters":[]},{"line":"            failed ~error:e ~sender:external_block.sender `Initial_validate","counters":[]},{"line":"        | Error `Couldn't_reach_verifier ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            retry ()","counters":[]},{"line":"        | Ok result -> (","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Mina_metrics.(","counters":[]},{"line":"              Gauge.set Catchup.initial_validation_time","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                Time.(Span.to_ms @@ diff (now ()) start_time)) ;","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"            match result with","counters":[]},{"line":"            | `In_frontier hash ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                finish t node (Ok (Transition_frontier.find_exn frontier hash)) ;","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"                Deferred.return (Ok ())","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"            | `Building_path tv ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (* To_initial_validate may only occur for a downloaded block,","counters":[]},{"line":"                   hence there is no validation callback *)","counters":[]},{"line":"                set_state t node (To_verify (tv, None)) ;","counters":[]},{"line":"                run_node node ) )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"    | To_verify (tv, valid_cb) -> (","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [%log debug] \"To_verify $state_hash %s callback\"","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"          ~metadata:[ (\"state_hash\", node.state_hash |> State_hash.to_yojson) ]","counters":[{"col_start":75,"col_end":75,"count":0}]},{"line":"          (Option.value_map valid_cb ~default:\"without\" ~f:(const \"with\")) ;","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"        let start_time = Time.now () in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let iv = Cached.peek tv in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        (* TODO: Set up job to invalidate tv on catchup_breadcrumbs_writer closing *)","counters":[]},{"line":"        match%bind","counters":[]},{"line":"          step","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"            (* TODO: give the batch verifier a way to somehow throw away stuff if","counters":[]},{"line":"               this node gets removed from the tree. *)","counters":[]},{"line":"            ( Verify_work_batcher.verify verify_work_batcher iv","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"            |> Deferred.map ~f:Result.return )","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"        with","counters":[]},{"line":"        | Error _e ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            [%log' debug t.logger] \"Couldn't reach verifier. Retrying\"","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"              ~metadata:[ (\"state_hash\", State_hash.to_yojson node.state_hash) ] ;","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"            (* No need to redownload in this case. We just wait a little and try again. *)","counters":[]},{"line":"            retry ()","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"        | Ok result -> (","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Mina_metrics.(","counters":[]},{"line":"              Gauge.set Catchup.verification_time","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                Time.(Span.to_ms @@ diff (now ()) start_time)) ;","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"            match result with","counters":[]},{"line":"            | Error err ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                [%log' warn t.logger] \"verification failed! redownloading\"","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"                  ~metadata:","counters":[]},{"line":"                    [ (\"state_hash\", State_hash.to_yojson node.state_hash)","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"                    ; (\"error\", `String (Verifier.invalid_to_string err))","counters":[{"col_start":66,"col_end":66,"count":0}]},{"line":"                    ] ;","counters":[]},{"line":"                ( match iv.sender with","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                | Local ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    ()","counters":[]},{"line":"                | Remote peer ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    Trust_system.(","counters":[]},{"line":"                      record trust_system logger peer","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                        Actions.(Sent_invalid_proof, None))","counters":[]},{"line":"                    |> don't_wait_for ) ;","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"                Option.value_map valid_cb ~default:ignore","counters":[]},{"line":"                  ~f:Mina_net2.Validation_callback.fire_if_not_already_fired","counters":[]},{"line":"                  `Reject ;","counters":[]},{"line":"                ignore","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  ( Cached.invalidate_with_failure tv","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"                    : Mina_block.initial_valid_block Envelope.Incoming.t ) ;","counters":[]},{"line":"                failed ~sender:iv.sender `Verify","counters":[]},{"line":"            | Ok av ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                let av =","counters":[]},{"line":"                  { av with","counters":[]},{"line":"                    data =","counters":[]},{"line":"                      Validation.skip_frontier_dependencies_validation","counters":[{"col_start":69,"col_end":69,"count":0}]},{"line":"                        `This_block_belongs_to_a_detached_subtree av.data","counters":[]},{"line":"                  }","counters":[]},{"line":"                in","counters":[]},{"line":"                let av = Cached.transform tv ~f:(fun _ -> av) in","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"                set_state t node (Wait_for_parent (av, valid_cb)) ;","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                run_node node ) )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"    | Wait_for_parent (av, valid_cb) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [%log debug] \"Wait_for_parent $state_hash %s callback\"","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"          ~metadata:[ (\"state_hash\", node.state_hash |> State_hash.to_yojson) ]","counters":[{"col_start":75,"col_end":75,"count":0}]},{"line":"          (Option.value_map valid_cb ~default:\"without\" ~f:(const \"with\")) ;","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"        let%bind parent =","counters":[]},{"line":"          step","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"            (let parent = Hashtbl.find_exn t.nodes node.parent in","counters":[]},{"line":"             match%map.Async.Deferred Ivar.read parent.result with","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"             | Ok `Added_to_frontier ->","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                 Ok parent.state_hash","counters":[]},{"line":"             | Error _ ->","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                 (* TODO consider rejecting the callback in some cases,","counters":[]},{"line":"                    see https://github.com/MinaProtocol/mina/issues/11087 *)","counters":[]},{"line":"                 Option.value_map valid_cb ~default:ignore","counters":[]},{"line":"                   ~f:Mina_net2.Validation_callback.fire_if_not_already_fired","counters":[]},{"line":"                   `Ignore ;","counters":[]},{"line":"                 ignore","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                   ( Cached.invalidate_with_failure av","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                     : Mina_block.almost_valid_block Envelope.Incoming.t ) ;","counters":[]},{"line":"                 finish t node (Error ()) ;","counters":[]},{"line":"                 Error `Finished )","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"        in","counters":[]},{"line":"        set_state t node (To_build_breadcrumb (`Parent parent, av, valid_cb)) ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        run_node node","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    | To_build_breadcrumb (`Parent parent_hash, c, valid_cb) -> (","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [%log debug] \"To_build_breadcrumb $state_hash %s callback\"","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"          ~metadata:[ (\"state_hash\", node.state_hash |> State_hash.to_yojson) ]","counters":[{"col_start":75,"col_end":75,"count":0}]},{"line":"          (Option.value_map valid_cb ~default:\"without\" ~f:(const \"with\")) ;","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"        let start_time = Time.now () in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let transition_receipt_time = Some start_time in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let av = Cached.peek c in","counters":[]},{"line":"        match%bind","counters":[]},{"line":"          let s =","counters":[]},{"line":"            let open Deferred.Result.Let_syntax in","counters":[]},{"line":"            let%bind parent =","counters":[]},{"line":"              Deferred.return","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                ( match Transition_frontier.find frontier parent_hash with","counters":[]},{"line":"                | None ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    Error `Parent_breadcrumb_not_found","counters":[]},{"line":"                | Some breadcrumb ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    Ok breadcrumb )","counters":[]},{"line":"            in","counters":[]},{"line":"            build_func ~logger ~skip_staged_ledger_verification:`Proofs","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              ~precomputed_values ~verifier ~trust_system ~parent","counters":[]},{"line":"              ~transition:av.data ~sender:(Some av.sender)","counters":[]},{"line":"              ~transition_receipt_time ()","counters":[]},{"line":"          in","counters":[]},{"line":"          step (Deferred.map ~f:Result.return s)","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"        with","counters":[]},{"line":"        | Error e ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (* TODO consider rejecting the callback in some cases,","counters":[]},{"line":"               see https://github.com/MinaProtocol/mina/issues/11087 *)","counters":[]},{"line":"            Option.value_map valid_cb ~default:ignore","counters":[]},{"line":"              ~f:Mina_net2.Validation_callback.fire_if_not_already_fired `Ignore ;","counters":[]},{"line":"            ignore","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              ( Cached.invalidate_with_failure c","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"                : Mina_block.almost_valid_block Envelope.Incoming.t ) ;","counters":[]},{"line":"            let e =","counters":[]},{"line":"              match e with","counters":[]},{"line":"              | `Exn e ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Error.tag (Error.of_exn e) ~tag:\"exn\"","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"              | `Fatal_error e ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Error.tag (Error.of_exn e) ~tag:\"fatal\"","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"              | `Invalid_staged_ledger_diff e ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Error.tag e ~tag:\"invalid staged ledger diff\"","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"              | `Invalid_staged_ledger_hash e ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Error.tag e ~tag:\"invalid staged ledger hash\"","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"              | `Parent_breadcrumb_not_found ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Error.tag","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                    (Error.of_string","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                       (sprintf \"Parent breadcrumb with state_hash %s not found\"","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                          (State_hash.to_base58_check parent_hash) ) )","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"                    ~tag:\"parent breadcrumb not found\"","counters":[]},{"line":"            in","counters":[]},{"line":"            failed ~error:e ~sender:av.sender `Build_breadcrumb","counters":[]},{"line":"        | Ok breadcrumb ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Mina_metrics.(","counters":[]},{"line":"              Gauge.set Catchup.build_breadcrumb_time","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                Time.(Span.to_ms @@ diff (now ()) start_time)) ;","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"            let%bind () = Scheduler.yield () |> Deferred.map ~f:Result.return in","counters":[{"col_start":40,"col_end":40,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"            let finished = Ivar.create () in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let c = Cached.transform c ~f:(fun _ -> breadcrumb) in","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"            Strict_pipe.Writer.write catchup_breadcrumbs_writer","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              ( [ Rose_tree.of_non_empty_list","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"                    (Non_empty_list.singleton (c, valid_cb))","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"                ]","counters":[]},{"line":"              , `Ledger_catchup finished ) ;","counters":[]},{"line":"            let%bind () =","counters":[]},{"line":"              (* The cached value is \"freed\" by the transition processor in [add_and_finalize]. *)","counters":[]},{"line":"              step (Deferred.map (Ivar.read finished) ~f:Result.return)","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"            in","counters":[]},{"line":"            Ivar.fill_if_empty node.result (Ok `Added_to_frontier) ;","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            set_state t node Finished ;","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            return () )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"  in","counters":[]},{"line":"  run_node","counters":[]},{"line":"","counters":[]},{"line":"(* TODO: In the future, this could take over scheduling bootstraps too. *)","counters":[]},{"line":"let run_catchup ~context:(module Context : CONTEXT) ~trust_system ~verifier","counters":[]},{"line":"    ~network ~frontier ~build_func","counters":[]},{"line":"    ~(catchup_job_reader :","counters":[]},{"line":"       ( State_hash.t","counters":[]},{"line":"       * ( ( Mina_block.initial_valid_block Envelope.Incoming.t","counters":[]},{"line":"           , State_hash.t )","counters":[]},{"line":"           Cached.t","counters":[]},{"line":"         * Mina_net2.Validation_callback.t option )","counters":[]},{"line":"         Rose_tree.t","counters":[]},{"line":"         list )","counters":[]},{"line":"       Strict_pipe.Reader.t ) ~unprocessed_transition_cache","counters":[]},{"line":"    ~(catchup_breadcrumbs_writer :","counters":[]},{"line":"       ( ( (Transition_frontier.Breadcrumb.t, State_hash.t) Cached.t","counters":[]},{"line":"         * Mina_net2.Validation_callback.t option )","counters":[]},{"line":"         Rose_tree.t","counters":[]},{"line":"         list","counters":[]},{"line":"         * [ `Ledger_catchup of unit Ivar.t | `Catchup_scheduler ]","counters":[]},{"line":"       , Strict_pipe.crash Strict_pipe.buffered","counters":[]},{"line":"       , unit )","counters":[]},{"line":"       Strict_pipe.Writer.t ) =","counters":[]},{"line":"  let open Context in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let t =","counters":[]},{"line":"    match Transition_frontier.catchup_tree frontier with","counters":[]},{"line":"    | Full t ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        t","counters":[]},{"line":"    | Hash _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        failwith","counters":[]},{"line":"          \"If super catchup is running, the frontier should have a full \\","counters":[]},{"line":"           catchup tree\"","counters":[]},{"line":"  in","counters":[]},{"line":"  let stop = Transition_frontier.closed frontier in","counters":[]},{"line":"  upon stop (fun () -> tear_down t) ;","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"  let combine = Option.merge ~f:(pick ~context:(module Context)) in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let pre_context","counters":[]},{"line":"      (trees :","counters":[]},{"line":"        ((Mina_block.initial_valid_block Envelope.Incoming.t, _) Cached.t * _)","counters":[]},{"line":"        Rose_tree.t","counters":[]},{"line":"        list ) =","counters":[]},{"line":"    let f tree =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let best = ref None in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Rose_tree.iter tree ~f:(fun (x, _vc) ->","counters":[]},{"line":"          let x, _ = Envelope.Incoming.data (Cached.peek x) in","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"          best :=","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            combine !best","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"              (Some","counters":[]},{"line":"                 (With_hash.map","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                    ~f:(Fn.compose Header.protocol_state Mina_block.header)","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"                    x ) ) ) ;","counters":[]},{"line":"      !best","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    in","counters":[]},{"line":"    List.map trees ~f |> List.reduce ~f:combine |> Option.join","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"  in","counters":[]},{"line":"  let best_tip_r, best_tip_w = Broadcast_pipe.create None in","counters":[]},{"line":"  let%bind downloader =","counters":[]},{"line":"    let knowledge h peer =","counters":[]},{"line":"      let heartbeat_timeout = Time_ns.Span.of_sec 30. in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      match h with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          return `All","counters":[]},{"line":"      | Some (h, len) -> (","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          match%map","counters":[]},{"line":"            Mina_networking.get_transition_chain_proof","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"              ~timeout:(Time.Span.of_sec 30.) ~heartbeat_timeout network peer h","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"          with","counters":[]},{"line":"          | Error _ ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              `Some []","counters":[]},{"line":"          | Ok p -> (","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              match","counters":[]},{"line":"                Transition_chain_verifier.verify ~target_hash:h","counters":[]},{"line":"                  ~transition_chain_proof:p","counters":[]},{"line":"              with","counters":[]},{"line":"              | Some hs ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  let ks = with_lengths hs ~target_length:len in","counters":[]},{"line":"                  `Some ks","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"              | None ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  `Some [] ) )","counters":[]},{"line":"    in","counters":[]},{"line":"    Downloader.create ~stop ~trust_system ~preferred:[] ~max_batch_size:5","counters":[]},{"line":"      ~get:(fun peer hs ->","counters":[]},{"line":"        let sec =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let sec_per_block =","counters":[]},{"line":"            Option.value_map","counters":[]},{"line":"              (Sys.getenv \"MINA_EXPECTED_PER_BLOCK_DOWNLOAD_TIME\")","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"              ~default:15. ~f:Float.of_string","counters":[]},{"line":"          in","counters":[]},{"line":"          Float.of_int (List.length hs) *. sec_per_block","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"        in","counters":[]},{"line":"        Mina_networking.get_transition_chain","counters":[]},{"line":"          ~heartbeat_timeout:(Time_ns.Span.of_sec sec)","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"          ~timeout:(Time.Span.of_sec sec) network peer (List.map hs ~f:fst) )","counters":[{"col_start":35,"col_end":35,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"      ~peers:(fun () -> Mina_networking.peers network)","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"      ~knowledge_context:","counters":[]},{"line":"        (Broadcast_pipe.map best_tip_r","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"           ~f:","counters":[]},{"line":"             (Option.map ~f:(fun x ->","counters":[]},{"line":"                  ( State_hash.With_state_hashes.state_hash x","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"                  , Mina_state.Protocol_state.consensus_state x.data","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"                    |> Consensus.Data.Consensus_state.blockchain_length ) ) ) )","counters":[{"col_start":70,"col_end":70,"count":0}]},{"line":"      ~knowledge","counters":[]},{"line":"  in","counters":[]},{"line":"  check_invariant ~downloader t ;","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let () =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Downloader.set_check_invariant (fun downloader ->","counters":[]},{"line":"        check_invariant ~downloader t )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"  in","counters":[]},{"line":"  (*","counters":[]},{"line":"  every ~stop (Time.Span.of_sec 10.) (fun () ->","counters":[]},{"line":"      [%log debug]","counters":[]},{"line":"        ~metadata:[ (\"states\", to_yojson t) ]","counters":[]},{"line":"        \"Catchup states $states\") ;","counters":[]},{"line":"  *)","counters":[]},{"line":"  let run_state_machine =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    setup_state_machine_runner ~t ~verifier ~downloader","counters":[]},{"line":"      ~context:(module Context)","counters":[]},{"line":"      ~trust_system ~frontier ~unprocessed_transition_cache","counters":[]},{"line":"      ~catchup_breadcrumbs_writer ~build_func","counters":[]},{"line":"  in","counters":[]},{"line":"  (* TODO: Maybe add everything from transition frontier at the beginning? *)","counters":[]},{"line":"  (* TODO: Print out the hashes you're adding *)","counters":[]},{"line":"  O1trace.thread \"handle_super_catchup_jobs\" (fun () ->","counters":[]},{"line":"      Strict_pipe.Reader.iter_without_pushback catchup_job_reader","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ~f:(fun (target_parent_hash, forest) ->","counters":[]},{"line":"          (* whenever anything comes through the catchup_job_reader, this anonymous function is called. `target_parent_hash` is actually the parent of all the trees in `forest`, is in other words if one expands `target_parent_hash` and combines it with `forest` them one actually obtains a single tree. *)","counters":[]},{"line":"          don't_wait_for","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (let prev_ctx = Broadcast_pipe.Reader.peek best_tip_r in","counters":[]},{"line":"             let ctx = combine prev_ctx (pre_context forest) in","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"             let eq x y =","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"               let f = Option.map ~f:State_hash.With_state_hashes.state_hash in","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"               Option.equal State_hash.equal (f x) (f y)","counters":[{"col_start":46,"col_end":46,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"             in","counters":[]},{"line":"             if eq prev_ctx ctx then Deferred.unit","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"             else Broadcast_pipe.Writer.write best_tip_w ctx ) ;","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"          don't_wait_for","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ( (* primary super_catchup business logic begins here, in this second `don't_wait_for` *)","counters":[]},{"line":"              [%log debug]","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                ~metadata:","counters":[]},{"line":"                  [ ( \"target_parent_hash\"","counters":[]},{"line":"                    , State_body_hash.to_yojson target_parent_hash )","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"                  ]","counters":[]},{"line":"                \"Catchup job started with $target_parent_hash \" ;","counters":[]},{"line":"              let state_hashes =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                let target_length =","counters":[]},{"line":"                  let len =","counters":[]},{"line":"                    forest_pick forest |> Tuple2.get1 |> Cached.peek","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":52,"col_end":52,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"                    |> Envelope.Incoming.data |> Validation.block","counters":[{"col_start":44,"col_end":44,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"                    |> Mina_block.blockchain_length","counters":[]},{"line":"                  in","counters":[]},{"line":"                  Option.value_exn (Length.sub len (Length.of_int 1))","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"                in","counters":[]},{"line":"                let blockchain_length_of_target_hash =","counters":[]},{"line":"                  let blockchain_length_of_dangling_block =","counters":[]},{"line":"                    List.hd_exn forest |> Rose_tree.root |> Tuple2.get1","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":55,"col_end":55,"count":0},{"col_start":70,"col_end":70,"count":0}]},{"line":"                    |> Cached.peek |> Envelope.Incoming.data |> Validation.block","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":59,"col_end":59,"count":0},{"col_start":79,"col_end":79,"count":0}]},{"line":"                    |> Mina_block.blockchain_length","counters":[]},{"line":"                  in","counters":[]},{"line":"                  Unsigned.UInt32.pred blockchain_length_of_dangling_block","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"                in","counters":[]},{"line":"                (* check if the target_parent_hash's own parent is a part of the transition frontier, or not *)","counters":[]},{"line":"                match","counters":[]},{"line":"                  List.find_map (List.concat_map ~f:Rose_tree.flatten forest)","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"                    ~f:(fun (c, _vc) ->","counters":[]},{"line":"                      let h =","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        State_hash.With_state_hashes.state_hash","counters":[]},{"line":"                          (Validation.block_with_hash (Cached.peek c).data)","counters":[{"col_start":52,"col_end":52,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"                      in","counters":[]},{"line":"                      ( match (Cached.peek c).sender with","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"                      | Local ->","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          ()","counters":[]},{"line":"                      | Remote peer ->","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          Downloader.add_knowledge downloader peer","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"                            [ (target_parent_hash, target_length) ] ) ;","counters":[]},{"line":"                      let%bind.Option { proof = path, root; _ } =","counters":[]},{"line":"                        Best_tip_lru.get h","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"                      in","counters":[]},{"line":"                      let%bind.Option p =","counters":[]},{"line":"                        Transition_chain_verifier.verify ~target_hash:h","counters":[]},{"line":"                          ~transition_chain_proof:","counters":[]},{"line":"                            ( ( Mina_block.header root |> Header.protocol_state","counters":[{"col_start":48,"col_end":48,"count":0},{"col_start":78,"col_end":78,"count":0}]},{"line":"                              |> Mina_state.Protocol_state.hashes )","counters":[{"col_start":64,"col_end":64,"count":0}]},{"line":"                                .state_hash","counters":[]},{"line":"                            , path )","counters":[]},{"line":"                      in","counters":[]},{"line":"                      Result.ok","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        (try_to_connect_hash_chain t p ~frontier","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"                           ~blockchain_length_of_target_hash ) )","counters":[]},{"line":"                with","counters":[]},{"line":"                | None ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    (* if the target_parent_hash's own parent is not a part of the transition frontier, then the entire chain of blocks connecting some node in the","counters":[]},{"line":"                       transition frontier to target_parent_hash needs to be downloaded *)","counters":[]},{"line":"                    let preferred_peers =","counters":[]},{"line":"                      List.fold (List.concat_map ~f:Rose_tree.flatten forest)","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"                        ~init:Peer.Set.empty ~f:(fun acc (c, _vc) ->","counters":[]},{"line":"                          match (Cached.peek c).sender with","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"                          | Local ->","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                              acc","counters":[]},{"line":"                          | Remote peer ->","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                              Peer.Set.add acc peer )","counters":[]},{"line":"                    in","counters":[]},{"line":"                    download_state_hashes t ~logger ~trust_system ~network","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"                      ~frontier ~downloader ~target_length","counters":[]},{"line":"                      ~target_hash:target_parent_hash","counters":[]},{"line":"                      ~blockchain_length_of_target_hash ~preferred_peers","counters":[]},{"line":"                | Some res ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    [%log debug] \"Succeeded in using cache.\" ;","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                    Deferred.Result.return res","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"              in","counters":[]},{"line":"              match%map state_hashes with","counters":[]},{"line":"              | Error errors ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  [%log debug]","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                    ~metadata:","counters":[]},{"line":"                      [ (\"target_hash\", State_hash.to_yojson target_parent_hash)","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"                      ]","counters":[]},{"line":"                    \"Failed to download state hashes for $target_hash\" ;","counters":[]},{"line":"                  if contains_no_common_ancestor errors then","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    List.iter forest ~f:(fun subtree ->","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"                        let transition =","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          Rose_tree.root subtree |> Tuple2.get1 |> Cached.peek","counters":[{"col_start":39,"col_end":39,"count":0},{"col_start":62,"col_end":62,"count":0},{"col_start":77,"col_end":77,"count":0}]},{"line":"                          |> Envelope.Incoming.data","counters":[]},{"line":"                        in","counters":[]},{"line":"                        let children_transitions =","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          List.concat_map","counters":[]},{"line":"                            (Rose_tree.children subtree)","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"                            ~f:Rose_tree.flatten","counters":[]},{"line":"                        in","counters":[]},{"line":"                        let children_state_hashes =","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          List.map children_transitions","counters":[]},{"line":"                            ~f:(fun (cached_transition, _vc) ->","counters":[]},{"line":"                              Cached.peek cached_transition","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"                              |> Envelope.Incoming.data","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"                              |> Validation.block_with_hash","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"                              |> State_hash.With_state_hashes.state_hash )","counters":[]},{"line":"                        in","counters":[]},{"line":"                        [%log error]","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"                          ~metadata:","counters":[]},{"line":"                            [ ( \"state_hashes_of_children\"","counters":[]},{"line":"                              , `List","counters":[]},{"line":"                                  (List.map children_state_hashes","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"                                     ~f:State_hash.to_yojson ) )","counters":[]},{"line":"                            ; ( \"state_hash\"","counters":[]},{"line":"                              , State_hash.to_yojson","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                                  ( Validation.block_with_hash transition","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"                                  |> State_hash.With_state_hashes.state_hash )","counters":[{"col_start":75,"col_end":75,"count":0}]},{"line":"                              )","counters":[]},{"line":"                            ; ( \"reason\"","counters":[]},{"line":"                              , `String","counters":[]},{"line":"                                  \"no common ancestor with our transition \\","counters":[]},{"line":"                                   frontier\" )","counters":[]},{"line":"                            ; ( \"protocol_state\"","counters":[]},{"line":"                              , Validation.block transition","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"                                |> Mina_block.header |> Header.protocol_state","counters":[{"col_start":51,"col_end":51,"count":0},{"col_start":76,"col_end":76,"count":0}]},{"line":"                                |> Mina_state.Protocol_state.value_to_yojson )","counters":[{"col_start":75,"col_end":75,"count":0}]},{"line":"                            ]","counters":[]},{"line":"                          \"Validation error: external transition with state \\","counters":[]},{"line":"                           hash $state_hash and its children were rejected for \\","counters":[]},{"line":"                           reason $reason\" ;","counters":[]},{"line":"                        Mina_metrics.(","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          Counter.inc Rejected_blocks.no_common_ancestor","counters":[]},{"line":"                            ( Float.of_int","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"                            @@ (1 + List.length children_transitions) )) ) ;","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"                  List.iter forest ~f:(fun subtree ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                      Rose_tree.iter subtree ~f:(fun (node, vc) ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                          (* TODO consider rejecting the callback in some cases,","counters":[]},{"line":"                             see https://github.com/MinaProtocol/mina/issues/11087 *)","counters":[]},{"line":"                          Option.value_map vc ~default:ignore","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            ~f:","counters":[]},{"line":"                              Mina_net2.Validation_callback","counters":[]},{"line":"                              .fire_if_not_already_fired `Ignore ;","counters":[]},{"line":"                          ignore @@ Cached.invalidate_with_failure node ) )","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"              | Ok (root, state_hashes) ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  [%log' debug t.logger]","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"                    ~metadata:","counters":[]},{"line":"                      [ (\"downloader\", Downloader.to_yojson downloader)","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"                      ; ( \"node_states\"","counters":[]},{"line":"                        , let s = Node.State.Enum.Table.create () in","counters":[]},{"line":"                          Hashtbl.iter t.nodes ~f:(fun node ->","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                              Hashtbl.incr s (Node.State.enum node.state) ) ;","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"                          `List","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            (List.map (Hashtbl.to_alist s) ~f:(fun (k, v) ->","counters":[{"col_start":36,"col_end":36,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"                                 `List [ Node.State.Enum.to_yojson k; `Int v ] )","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"                            ) )","counters":[]},{"line":"                      ]","counters":[]},{"line":"                    \"before entering state machine.  node_states: $node_states\" ;","counters":[]},{"line":"                  let root =","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    match root with","counters":[]},{"line":"                    | `Breadcrumb root ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        (* If we hit this case we should probably remove the parent from the","counters":[]},{"line":"                            table and prune, although in theory that should be handled by","counters":[]},{"line":"                           the frontier calling [Full_catchup_tree.apply_diffs]. *)","counters":[]},{"line":"                        create_node ~downloader t (`Root root)","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"                    | `Node node ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        (* TODO: Log what is going on with transition frontier. *)","counters":[]},{"line":"                        node","counters":[]},{"line":"                  in","counters":[]},{"line":"                  [%log debug]","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                    ~metadata:[ (\"n\", `Int (List.length state_hashes)) ]","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"                    \"Adding $n nodes\" ;","counters":[]},{"line":"                  (* if state_hashes is Ok, then we iterate through the forest and fold over state_hashes and call run_state_machine on each node.  order doesn't really matter because nodes called \"out of order\" will enter the `Wait_for_parent` state and begin running again when ready *)","counters":[]},{"line":"                  List.iter forest","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    ~f:","counters":[]},{"line":"                      (Rose_tree.iter ~f:(fun b_and_c ->","counters":[]},{"line":"                           let node =","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                             create_node ~downloader t","counters":[]},{"line":"                               (`Initial_validated b_and_c)","counters":[]},{"line":"                           in","counters":[]},{"line":"                           ignore","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                             ( run_state_machine node","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"                               : (unit, [ `Finished ]) Deferred.Result.t ) ) ) ;","counters":[]},{"line":"                  ignore","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    ( List.fold state_hashes","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                        ~init:(root.state_hash, root.blockchain_length)","counters":[]},{"line":"                        ~f:(fun (parent, l) h ->","counters":[]},{"line":"                          let l = Length.succ l in","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                          ( if not (Hashtbl.mem t.nodes h) then","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"                            let node =","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                              create_node t ~downloader (`Hash (h, l, parent))","counters":[]},{"line":"                            in","counters":[]},{"line":"                            don't_wait_for (run_state_machine node >>| ignore)","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":60,"col_end":60,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"                          ) ;","counters":[]},{"line":"                          (h, l) )","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                      : State_hash.t * Length.t ) ) ) )","counters":[]},{"line":"","counters":[]},{"line":"let run ~context:(module Context : CONTEXT) ~trust_system ~verifier ~network","counters":[]},{"line":"    ~frontier ~catchup_job_reader ~catchup_breadcrumbs_writer","counters":[]},{"line":"    ~unprocessed_transition_cache : unit =","counters":[]},{"line":"  O1trace.background_thread \"perform_super_catchup\" (fun () ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      run_catchup","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ~context:(module Context)","counters":[]},{"line":"        ~trust_system ~verifier ~network ~frontier ~catchup_job_reader","counters":[]},{"line":"        ~unprocessed_transition_cache ~catchup_breadcrumbs_writer","counters":[]},{"line":"        ~build_func:Transition_frontier.Breadcrumb.build )","counters":[]},{"line":"","counters":[]},{"line":"(* Unit tests *)","counters":[]},{"line":"","counters":[]},{"line":"(* let run_test_only ~logger ~precomputed_values ~trust_system ~verifier ~network ~frontier","counters":[]},{"line":"     ~catchup_job_reader ~catchup_breadcrumbs_writer","counters":[]},{"line":"     ~unprocessed_transition_cache : unit =","counters":[]},{"line":"   run_catchup ~logger ~trust_system ~verifier ~network ~frontier ~catchup_job_reader","counters":[]},{"line":"     ~precomputed_values ~unprocessed_transition_cache","counters":[]},{"line":"     ~catchup_breadcrumbs_writer ~build_func:(Transition_frontier.Breadcrumb.For_tests.build_fail)","counters":[]},{"line":"   |> don't_wait_for *)","counters":[]},{"line":"","counters":[]},{"line":"let%test_module \"Ledger_catchup tests\" =","counters":[]},{"line":"  ( module struct","counters":[]},{"line":"    let () =","counters":[]},{"line":"      Core.Backtrace.elide := false ;","counters":[]},{"line":"      Async.Scheduler.set_record_backtraces true","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"","counters":[]},{"line":"    let max_frontier_length = 10","counters":[]},{"line":"","counters":[]},{"line":"    let logger = Logger.create ()","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"    let precomputed_values = Lazy.force Precomputed_values.for_unit_tests","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"","counters":[]},{"line":"    let proof_level = precomputed_values.proof_level","counters":[]},{"line":"","counters":[]},{"line":"    let constraint_constants = precomputed_values.constraint_constants","counters":[]},{"line":"","counters":[]},{"line":"    let trust_system = Trust_system.null ()","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"    (* let time_controller = Block_time.Controller.basic ~logger *)","counters":[]},{"line":"","counters":[]},{"line":"    let use_super_catchup = true","counters":[]},{"line":"","counters":[]},{"line":"    let verifier =","counters":[]},{"line":"      Async.Thread_safe.block_on_async_exn (fun () ->","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"          Verifier.create ~logger ~proof_level ~constraint_constants","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ~conf_dir:None","counters":[]},{"line":"            ~pids:(Child_processes.Termination.create_pid_table ()) )","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"","counters":[]},{"line":"    module Context = struct","counters":[]},{"line":"      let logger = logger","counters":[]},{"line":"","counters":[]},{"line":"      let precomputed_values = precomputed_values","counters":[]},{"line":"","counters":[]},{"line":"      let constraint_constants = constraint_constants","counters":[]},{"line":"","counters":[]},{"line":"      let consensus_constants = precomputed_values.consensus_constants","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    (* let mock_verifier =","counters":[]},{"line":"       Async.Thread_safe.block_on_async_exn (fun () ->","counters":[]},{"line":"           Verifier.Dummy.create ~logger ~proof_level ~constraint_constants","counters":[]},{"line":"             ~conf_dir:None","counters":[]},{"line":"             ~pids:(Child_processes.Termination.create_pid_table ())) *)","counters":[]},{"line":"","counters":[]},{"line":"    let downcast_transition transition =","counters":[]},{"line":"      let transition =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        transition |> Validation.reset_frontier_dependencies_validation","counters":[{"col_start":70,"col_end":70,"count":0}]},{"line":"        |> Validation.reset_staged_ledger_diff_validation","counters":[]},{"line":"      in","counters":[]},{"line":"      Envelope.Incoming.wrap ~data:transition ~sender:Envelope.Sender.Local","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let downcast_breadcrumb breadcrumb =","counters":[]},{"line":"      downcast_transition","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ( Transition_frontier.Breadcrumb.validated_transition breadcrumb","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"        |> Mina_block.Validated.remember )","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"    type catchup_test =","counters":[]},{"line":"      { cache : Transition_handler.Unprocessed_transition_cache.t","counters":[]},{"line":"      ; job_writer :","counters":[]},{"line":"          ( State_hash.t","counters":[]},{"line":"            * ( ( Mina_block.initial_valid_block Envelope.Incoming.t","counters":[]},{"line":"                , State_hash.t )","counters":[]},{"line":"                Cached.t","counters":[]},{"line":"              * Mina_net2.Validation_callback.t option )","counters":[]},{"line":"              Rose_tree.t","counters":[]},{"line":"              list","counters":[]},{"line":"          , Strict_pipe.crash Strict_pipe.buffered","counters":[]},{"line":"          , unit )","counters":[]},{"line":"          Strict_pipe.Writer.t","counters":[]},{"line":"      ; breadcrumbs_reader :","counters":[]},{"line":"          ( ( (Transition_frontier.Breadcrumb.t, State_hash.t) Cached.t","counters":[]},{"line":"            * Mina_net2.Validation_callback.t option )","counters":[]},{"line":"            Rose_tree.t","counters":[]},{"line":"            list","counters":[]},{"line":"          * [ `Catchup_scheduler | `Ledger_catchup of unit Ivar.t ] )","counters":[]},{"line":"          Strict_pipe.Reader.t","counters":[]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    let setup_catchup_pipes ~network ~frontier =","counters":[]},{"line":"      let catchup_job_reader, catchup_job_writer =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Strict_pipe.create ~name:(__MODULE__ ^ __LOC__)","counters":[]},{"line":"          (Buffered (`Capacity 10, `Overflow Crash))","counters":[]},{"line":"      in","counters":[]},{"line":"      let catchup_breadcrumbs_reader, catchup_breadcrumbs_writer =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Strict_pipe.create ~name:(__MODULE__ ^ __LOC__)","counters":[]},{"line":"          (Buffered (`Capacity 10, `Overflow Crash))","counters":[]},{"line":"      in","counters":[]},{"line":"      let unprocessed_transition_cache =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Transition_handler.Unprocessed_transition_cache.create ~logger","counters":[]},{"line":"      in","counters":[]},{"line":"      run","counters":[]},{"line":"        ~context:(module Context)","counters":[]},{"line":"        ~verifier ~trust_system ~network ~frontier ~catchup_breadcrumbs_writer","counters":[]},{"line":"        ~catchup_job_reader ~unprocessed_transition_cache ;","counters":[]},{"line":"      { cache = unprocessed_transition_cache","counters":[]},{"line":"      ; job_writer = catchup_job_writer","counters":[]},{"line":"      ; breadcrumbs_reader = catchup_breadcrumbs_reader","counters":[]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    (* let setup_catchup_pipes_fail_build_breadcrumb ~network ~frontier =","counters":[]},{"line":"       let catchup_job_reader, catchup_job_writer =","counters":[]},{"line":"         Strict_pipe.create ~name:(__MODULE__ ^ __LOC__)","counters":[]},{"line":"           (Buffered (`Capacity 10, `Overflow Crash))","counters":[]},{"line":"       in","counters":[]},{"line":"       let catchup_breadcrumbs_reader, catchup_breadcrumbs_writer =","counters":[]},{"line":"         Strict_pipe.create ~name:(__MODULE__ ^ __LOC__)","counters":[]},{"line":"           (Buffered (`Capacity 10, `Overflow Crash))","counters":[]},{"line":"       in","counters":[]},{"line":"       let unprocessed_transition_cache =","counters":[]},{"line":"         Transition_handler.Unprocessed_transition_cache.create ~logger","counters":[]},{"line":"       in","counters":[]},{"line":"       run_test_only ~logger ~precomputed_values ~verifier ~trust_system ~network ~frontier","counters":[]},{"line":"         ~catchup_breadcrumbs_writer ~catchup_job_reader","counters":[]},{"line":"         ~unprocessed_transition_cache ;","counters":[]},{"line":"       { cache = unprocessed_transition_cache","counters":[]},{"line":"       ; job_writer = catchup_job_writer","counters":[]},{"line":"       ; breadcrumbs_reader = catchup_breadcrumbs_reader","counters":[]},{"line":"       } *)","counters":[]},{"line":"","counters":[]},{"line":"    let setup_catchup_with_target ~network ~frontier ~target_breadcrumb =","counters":[]},{"line":"      let test = setup_catchup_pipes ~network ~frontier in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let parent_hash =","counters":[]},{"line":"        Transition_frontier.Breadcrumb.parent_hash target_breadcrumb","counters":[]},{"line":"      in","counters":[]},{"line":"      let target_transition =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Transition_handler.Unprocessed_transition_cache.register_exn test.cache","counters":[]},{"line":"          (downcast_breadcrumb target_breadcrumb)","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"      in","counters":[]},{"line":"      Strict_pipe.Writer.write test.job_writer","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (parent_hash, [ Rose_tree.T ((target_transition, None), []) ]) ;","counters":[]},{"line":"      (`Test test, `Cached_transition target_transition)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let rec call_read ~target_best_tip_path ~breadcrumbs_reader","counters":[]},{"line":"        ~(my_peer : Fake_network.peer_network) b_list n =","counters":[]},{"line":"      if n < List.length target_best_tip_path then","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"        let%bind breadcrumb =","counters":[]},{"line":"          [%log info] \"calling read, n=%d...\" n ;","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"          match%map","counters":[]},{"line":"            Strict_pipe.Reader.read breadcrumbs_reader","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"            |> Async.with_timeout (Time.Span.create ~sec:30 ())","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"          with","counters":[]},{"line":"          | `Timeout ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              failwith","counters":[]},{"line":"                (String.concat","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                   [ \"read of breadcrumbs_reader pipe timed out, n= \"","counters":[]},{"line":"                   ; string_of_int n","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"                   ] )","counters":[]},{"line":"          | `Result res -> (","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              match res with","counters":[]},{"line":"              | `Eof ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  failwith \"breadcrumb not found\"","counters":[]},{"line":"              | `Ok (_, `Catchup_scheduler) ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  failwith \"breadcrumb not found\"","counters":[]},{"line":"              | `Ok (breadcrumbs, `Ledger_catchup ivar) ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  let breadcrumb : Breadcrumb.t =","counters":[]},{"line":"                    Rose_tree.root (List.hd_exn breadcrumbs)","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"                    |> Tuple2.get1 |> Cache_lib.Cached.invalidate_with_success","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":77,"col_end":77,"count":0}]},{"line":"                  in","counters":[]},{"line":"                  Ivar.fill ivar () ; breadcrumb )","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"        in","counters":[]},{"line":"        let%bind () =","counters":[]},{"line":"          Transition_frontier.add_breadcrumb_exn my_peer.state.frontier","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"            breadcrumb","counters":[]},{"line":"        in","counters":[]},{"line":"        call_read ~target_best_tip_path ~breadcrumbs_reader ~my_peer","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (List.append b_list [ breadcrumb ])","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"          (n + 1)","counters":[]},{"line":"      else Deferred.return b_list","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"","counters":[]},{"line":"    let test_successful_catchup ~my_net ~target_best_tip_path =","counters":[]},{"line":"      let open Fake_network in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let target_breadcrumb = List.last_exn target_best_tip_path in","counters":[]},{"line":"      let `Test { breadcrumbs_reader; _ }, _ =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        setup_catchup_with_target ~network:my_net.network","counters":[]},{"line":"          ~frontier:my_net.state.frontier ~target_breadcrumb","counters":[]},{"line":"      in","counters":[]},{"line":"      let%map breadcrumb_list =","counters":[]},{"line":"        call_read ~breadcrumbs_reader ~target_best_tip_path ~my_peer:my_net [] 0","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"      in","counters":[]},{"line":"      let breadcrumbs_tree = Rose_tree.of_list_exn breadcrumb_list in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      [%test_result: int]","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"        ~message:","counters":[]},{"line":"          \"Transition_frontier should not have any more catchup jobs at the \\","counters":[]},{"line":"           end of the test\"","counters":[]},{"line":"        ~equal:( = ) ~expect:0","counters":[]},{"line":"        (Broadcast_pipe.Reader.peek Catchup_jobs.reader) ;","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"      [%log info] \"target_best_tip_path length: %d\"","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":16,"col_end":16,"count":0}]},{"line":"        (List.length target_best_tip_path) ;","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"      let target_best_tip_tree = Rose_tree.of_list_exn target_best_tip_path in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      [%log info] \"breadcrumb_list length: %d\" (List.length breadcrumb_list) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"      let catchup_breadcrumbs_are_best_tip_path =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Rose_tree.equal target_best_tip_tree breadcrumbs_tree ~f:(fun br1 br2 ->","counters":[]},{"line":"            let b1 = Transition_frontier.Breadcrumb.validated_transition br1 in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let b2 = Transition_frontier.Breadcrumb.validated_transition br2 in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            (* We force evaluation of state body hash for both blocks for further equality check *)","counters":[]},{"line":"            let _hash1 = Mina_block.Validated.state_body_hash b1 in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let _hash2 = Mina_block.Validated.state_body_hash b2 in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            Mina_block.Validated.equal b1 b2 )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"      in","counters":[]},{"line":"      if not catchup_breadcrumbs_are_best_tip_path then","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        failwith","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          \"catchup breadcrumbs were not equal to the best tip path we expected\"","counters":[]},{"line":"","counters":[]},{"line":"    let%test_unit \"can catchup to a peer within [k/2,k]\" =","counters":[]},{"line":"      [%log info] \"running catchup to peer\" ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":16,"col_end":16,"count":0}]},{"line":"      Quickcheck.test ~trials:5","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Fake_network.Generator.(","counters":[]},{"line":"          let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"          let%bind peer_branch_size =","counters":[]},{"line":"            Int.gen_incl (max_frontier_length / 2) (max_frontier_length - 1)","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"          in","counters":[]},{"line":"          gen ~precomputed_values ~verifier ~max_frontier_length","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ~use_super_catchup","counters":[]},{"line":"            [ fresh_peer","counters":[]},{"line":"            ; peer_with_branch ~frontier_branch_size:peer_branch_size","counters":[]},{"line":"            ])","counters":[]},{"line":"        ~f:(fun network ->","counters":[]},{"line":"          let open Fake_network in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let [ my_net; peer_net ] = network.peer_networks in","counters":[]},{"line":"          let target_best_tip_path =","counters":[]},{"line":"            Transition_frontier.(","counters":[]},{"line":"              path_map ~f:Fn.id peer_net.state.frontier","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                (best_tip peer_net.state.frontier))","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"          in","counters":[]},{"line":"          Thread_safe.block_on_async_exn (fun () ->","counters":[]},{"line":"              test_successful_catchup ~my_net ~target_best_tip_path ) )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"catchup succeeds even if the parent transition is already \\","counters":[]},{"line":"                   in the frontier\" =","counters":[]},{"line":"      Quickcheck.test ~trials:1","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Fake_network.Generator.(","counters":[]},{"line":"          gen ~precomputed_values ~verifier ~max_frontier_length","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            ~use_super_catchup","counters":[]},{"line":"            [ fresh_peer; peer_with_branch ~frontier_branch_size:1 ])","counters":[]},{"line":"        ~f:(fun network ->","counters":[]},{"line":"          let open Fake_network in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let [ my_net; peer_net ] = network.peer_networks in","counters":[]},{"line":"          let target_best_tip_path =","counters":[]},{"line":"            [ Transition_frontier.best_tip peer_net.state.frontier ]","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"          in","counters":[]},{"line":"          Thread_safe.block_on_async_exn (fun () ->","counters":[]},{"line":"              test_successful_catchup ~my_net ~target_best_tip_path ) )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"catchup succeeds even if the parent transition is already \\","counters":[]},{"line":"                   in the frontier\" =","counters":[]},{"line":"      Quickcheck.test ~trials:1","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Fake_network.Generator.(","counters":[]},{"line":"          gen ~precomputed_values ~verifier ~max_frontier_length","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            ~use_super_catchup","counters":[]},{"line":"            [ fresh_peer; peer_with_branch ~frontier_branch_size:1 ])","counters":[]},{"line":"        ~f:(fun network ->","counters":[]},{"line":"          let open Fake_network in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let [ my_net; peer_net ] = network.peer_networks in","counters":[]},{"line":"          let target_best_tip_path =","counters":[]},{"line":"            [ Transition_frontier.best_tip peer_net.state.frontier ]","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"          in","counters":[]},{"line":"          Thread_safe.block_on_async_exn (fun () ->","counters":[]},{"line":"              test_successful_catchup ~my_net ~target_best_tip_path ) )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"when catchup fails to download state hashes, catchup will \\","counters":[]},{"line":"                   properly clear the unprocessed_transition_cache of the \\","counters":[]},{"line":"                   blocks that triggered catchup\" =","counters":[]},{"line":"      Quickcheck.test ~trials:1","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Fake_network.Generator.(","counters":[]},{"line":"          gen ~precomputed_values ~verifier ~max_frontier_length","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            ~use_super_catchup","counters":[]},{"line":"            [ fresh_peer","counters":[]},{"line":"            ; peer_with_branch","counters":[]},{"line":"                ~frontier_branch_size:((max_frontier_length * 3) + 1)","counters":[]},{"line":"            ])","counters":[]},{"line":"        ~f:(fun network ->","counters":[]},{"line":"          let open Fake_network in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let [ my_net; peer_net ] = network.peer_networks in","counters":[]},{"line":"          let target_best_tip_path =","counters":[]},{"line":"            [ Transition_frontier.best_tip peer_net.state.frontier ]","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"          in","counters":[]},{"line":"          let open Fake_network in","counters":[]},{"line":"          let target_breadcrumb = List.last_exn target_best_tip_path in","counters":[]},{"line":"          let test =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            setup_catchup_pipes ~network:my_net.network","counters":[]},{"line":"              ~frontier:my_net.state.frontier","counters":[]},{"line":"          in","counters":[]},{"line":"          let parent_hash =","counters":[]},{"line":"            Transition_frontier.Breadcrumb.parent_hash target_breadcrumb","counters":[]},{"line":"          in","counters":[]},{"line":"          let target_transition =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Transition_handler.Unprocessed_transition_cache.register_exn","counters":[]},{"line":"              test.cache","counters":[]},{"line":"              (downcast_breadcrumb target_breadcrumb)","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"          in","counters":[]},{"line":"          [%log info] \"download state hashes fails unit test\" ;","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":20,"col_end":20,"count":0}]},{"line":"          Strict_pipe.Writer.write test.job_writer","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (parent_hash, [ Rose_tree.T ((target_transition, None), []) ]) ;","counters":[]},{"line":"          Thread_safe.block_on_async_exn (fun () ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              let final = Cache_lib.Cached.final_state target_transition in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              match%map","counters":[]},{"line":"                Deferred.any","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                  [ (Ivar.read final >>| fun x -> `Catchup_failed x)","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"                  ; Strict_pipe.Reader.read test.breadcrumbs_reader","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"                    >>| const `Catchup_success","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"                  ]","counters":[]},{"line":"              with","counters":[]},{"line":"              | `Catchup_failed fnl -> (","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  match fnl with","counters":[]},{"line":"                  | `Failed ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      [%log info]","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                        \"download state hashes fails unit test: correctly fails\" ;","counters":[]},{"line":"","counters":[]},{"line":"                      ()","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                  | `Success _ ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      [%log info]","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                        \"download state hashes fails unit test: incorrectly \\","counters":[]},{"line":"                         succeeds\" ;","counters":[]},{"line":"","counters":[]},{"line":"                      failwith","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        \"target transition should've been invalidated with a \\","counters":[]},{"line":"                         failure\" )","counters":[]},{"line":"              | `Catchup_success ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  [%log info]","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                    \"download state hashes fails unit test: incorrectly \\","counters":[]},{"line":"                     succeeds\" ;","counters":[]},{"line":"","counters":[]},{"line":"                  failwith","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    \"target transition should've been invalidated with a \\","counters":[]},{"line":"                     failure\" ) )","counters":[]},{"line":"","counters":[]},{"line":"    let%test_unit \"when catchup fails to download a block, catchup will retry \\","counters":[]},{"line":"                   and attempt again\" =","counters":[]},{"line":"      let attempts_ivar = Ivar.create () in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let attempt_counter = ref 0 in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let impl_rpc :","counters":[]},{"line":"             Mina_networking.Rpcs.Get_transition_chain.query Envelope.Incoming.t","counters":[]},{"line":"          -> Mina_networking.Rpcs.Get_transition_chain.response Deferred.t =","counters":[]},{"line":"       fun _ ->","counters":[]},{"line":"        let () =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          attempt_counter := !attempt_counter + 1 ;","counters":[]},{"line":"          if !attempt_counter > 1 then Ivar.fill_if_empty attempts_ivar true","counters":[{"col_start":39,"col_end":39,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"        in","counters":[]},{"line":"        Deferred.return (Some [])","counters":[]},{"line":"      in","counters":[]},{"line":"      Quickcheck.test ~trials:1","counters":[]},{"line":"        Fake_network.Generator.(","counters":[]},{"line":"          gen ~precomputed_values ~verifier ~max_frontier_length","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            ~use_super_catchup","counters":[]},{"line":"            [ fresh_peer","counters":[]},{"line":"              (* ; peer_with_branch ~frontier_branch_size:(max_frontier_length / 2) *)","counters":[]},{"line":"            ; peer_with_branch_custom_rpc","counters":[]},{"line":"                ~frontier_branch_size:(max_frontier_length / 2)","counters":[]},{"line":"                ?get_staged_ledger_aux_and_pending_coinbases_at_hash:None","counters":[]},{"line":"                ?get_some_initial_peers:None ?answer_sync_ledger_query:None","counters":[]},{"line":"                ?get_ancestry:None ?get_best_tip:None ?get_node_status:None","counters":[]},{"line":"                ?get_transition_knowledge:None ?get_transition_chain_proof:None","counters":[]},{"line":"                ?get_transition_chain:(Some impl_rpc)","counters":[]},{"line":"            ; peer_with_branch_custom_rpc","counters":[]},{"line":"                ~frontier_branch_size:(max_frontier_length / 2)","counters":[]},{"line":"                ?get_staged_ledger_aux_and_pending_coinbases_at_hash:None","counters":[]},{"line":"                ?get_some_initial_peers:None ?answer_sync_ledger_query:None","counters":[]},{"line":"                ?get_ancestry:None ?get_best_tip:None ?get_node_status:None","counters":[]},{"line":"                ?get_transition_knowledge:None ?get_transition_chain_proof:None","counters":[]},{"line":"                ?get_transition_chain:(Some impl_rpc)","counters":[]},{"line":"            ; peer_with_branch_custom_rpc","counters":[]},{"line":"                ~frontier_branch_size:(max_frontier_length / 2)","counters":[]},{"line":"                ?get_staged_ledger_aux_and_pending_coinbases_at_hash:None","counters":[]},{"line":"                ?get_some_initial_peers:None ?answer_sync_ledger_query:None","counters":[]},{"line":"                ?get_ancestry:None ?get_best_tip:None ?get_node_status:None","counters":[]},{"line":"                ?get_transition_knowledge:None ?get_transition_chain_proof:None","counters":[]},{"line":"                ?get_transition_chain:(Some impl_rpc)","counters":[]},{"line":"            ])","counters":[]},{"line":"        ~f:(fun network ->","counters":[]},{"line":"          let open Fake_network in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let [ my_net; peer1; _; _ ] = network.peer_networks in","counters":[]},{"line":"          let target_best_tip_path =","counters":[]},{"line":"            [ Transition_frontier.best_tip peer1.state.frontier ]","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"          in","counters":[]},{"line":"          let open Fake_network in","counters":[]},{"line":"          let target_breadcrumb = List.last_exn target_best_tip_path in","counters":[]},{"line":"          let test =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            setup_catchup_pipes ~network:my_net.network","counters":[]},{"line":"              ~frontier:my_net.state.frontier","counters":[]},{"line":"          in","counters":[]},{"line":"          let parent_hash =","counters":[]},{"line":"            Transition_frontier.Breadcrumb.parent_hash target_breadcrumb","counters":[]},{"line":"          in","counters":[]},{"line":"          let target_transition =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Transition_handler.Unprocessed_transition_cache.register_exn","counters":[]},{"line":"              test.cache","counters":[]},{"line":"              (downcast_breadcrumb target_breadcrumb)","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"          in","counters":[]},{"line":"          Strict_pipe.Writer.write test.job_writer","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (parent_hash, [ Rose_tree.T ((target_transition, None), []) ]) ;","counters":[]},{"line":"          Thread_safe.block_on_async_exn (fun () ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              let final = Cache_lib.Cached.final_state target_transition in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              match%map","counters":[]},{"line":"                Deferred.any","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                  [ (Ivar.read final >>| fun x -> `Catchup_failed x)","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"                  ; (Ivar.read attempts_ivar >>| fun _ -> `Attempts_exceeded)","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":47,"col_end":47,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"                  ; Strict_pipe.Reader.read test.breadcrumbs_reader","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"                    >>| const `Catchup_success","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"                  ]","counters":[]},{"line":"              with","counters":[]},{"line":"              | `Attempts_exceeded ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  ()","counters":[]},{"line":"              | `Catchup_success ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  failwith","counters":[]},{"line":"                    \"target transition should've been invalidated with a \\","counters":[]},{"line":"                     failure\"","counters":[]},{"line":"              | `Catchup_failed fnl -> (","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  match fnl with","counters":[]},{"line":"                  | `Success _ ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      failwith \"final state should be at `Failed\"","counters":[]},{"line":"                  | `Failed ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      let catchup_tree =","counters":[]},{"line":"                        match","counters":[]},{"line":"                          Transition_frontier.catchup_tree my_net.state.frontier","counters":[]},{"line":"                        with","counters":[]},{"line":"                        | Full tr ->","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            tr","counters":[]},{"line":"                        | Hash _ ->","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            failwith","counters":[]},{"line":"                              \"in super catchup unit tests, the catchup tree \\","counters":[]},{"line":"                               should always be Full_catchup_tree, but it is \\","counters":[]},{"line":"                               Catchup_hash_tree for some reason\"","counters":[]},{"line":"                      in","counters":[]},{"line":"                      let catchup_tree_node_list =","counters":[]},{"line":"                        State_hash.Table.data catchup_tree.nodes","counters":[]},{"line":"                      in","counters":[]},{"line":"                      let catchup_tree_node =","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        List.hd_exn catchup_tree_node_list","counters":[]},{"line":"                      in","counters":[]},{"line":"                      let num_attempts =","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        Peer.Map.length catchup_tree_node.attempts","counters":[]},{"line":"                      in","counters":[]},{"line":"                      if num_attempts < 2 then","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        let failstring =","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          Format.sprintf","counters":[]},{"line":"                            \"UNIT TEST FAILED.  catchup should have made more \\","counters":[]},{"line":"                             attempts after failing to download a block.  \\","counters":[]},{"line":"                             attempts= %d.  length of catchup_tree_node_list= \\","counters":[]},{"line":"                             %d\"","counters":[]},{"line":"                            num_attempts","counters":[]},{"line":"                            (List.length catchup_tree_node_list)","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"                        in","counters":[]},{"line":"                        failwith failstring","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                      else () ) ) )","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"","counters":[]},{"line":"    (* let%test_unit \"when initial validation of a blocks fails (except for the \\","counters":[]},{"line":"                    verifier_unreachable case), then catchup will cancel the \\","counters":[]},{"line":"                    block's children's catchup job\" =","counters":[]},{"line":"       Quickcheck.test ~trials:1","counters":[]},{"line":"         Fake_network.Generator.(","counters":[]},{"line":"           gen ~precomputed_values ~verifier ~max_frontier_length","counters":[]},{"line":"             ~use_super_catchup","counters":[]},{"line":"             [ fresh_peer","counters":[]},{"line":"             ; broken_rpc_peer_branch","counters":[]},{"line":"                 ~frontier_branch_size:(max_frontier_length / 2)","counters":[]},{"line":"                 ~get_transition_chain_impl_option:None","counters":[]},{"line":"               (* TODO: write some kind of mock that makes validation fail, and thus make the test pass *)","counters":[]},{"line":"             ])","counters":[]},{"line":"         ~f:(fun network ->","counters":[]},{"line":"           let open Fake_network in","counters":[]},{"line":"           let [ my_net; peer_net ] = network.peer_networks in","counters":[]},{"line":"           let target_best_tip_path =","counters":[]},{"line":"             Transition_frontier.best_tip_path peer_net.state.frontier","counters":[]},{"line":"           in","counters":[]},{"line":"           let open Fake_network in","counters":[]},{"line":"           let target_breadcrumb_child = List.last_exn target_best_tip_path in","counters":[]},{"line":"           let target_breadcrumb_child_hash =","counters":[]},{"line":"             Transition_frontier.Breadcrumb.state_hash target_breadcrumb_child","counters":[]},{"line":"           in","counters":[]},{"line":"           let target_breadcrumb_parent =","counters":[]},{"line":"             List.nth_exn target_best_tip_path","counters":[]},{"line":"               (List.length target_best_tip_path - 2)","counters":[]},{"line":"           in","counters":[]},{"line":"           let test =","counters":[]},{"line":"             setup_catchup_pipes ~network:my_net.network","counters":[]},{"line":"               ~frontier:my_net.state.frontier","counters":[]},{"line":"           in","counters":[]},{"line":"           let parent_hash =","counters":[]},{"line":"             Transition_frontier.Breadcrumb.parent_hash target_breadcrumb_parent","counters":[]},{"line":"           in","counters":[]},{"line":"           let target_transition_parent =","counters":[]},{"line":"             Transition_handler.Unprocessed_transition_cache.register_exn","counters":[]},{"line":"               test.cache","counters":[]},{"line":"               (downcast_breadcrumb target_breadcrumb_parent)","counters":[]},{"line":"           in","counters":[]},{"line":"           let target_transition_child =","counters":[]},{"line":"             Transition_handler.Unprocessed_transition_cache.register_exn","counters":[]},{"line":"               test.cache","counters":[]},{"line":"               (downcast_breadcrumb target_breadcrumb_child)","counters":[]},{"line":"           in","counters":[]},{"line":"           [%log info] \"validation fails unit test\" ;","counters":[]},{"line":"           Strict_pipe.Writer.write test.job_writer","counters":[]},{"line":"             ( parent_hash","counters":[]},{"line":"             , [ Rose_tree.T","counters":[]},{"line":"                   ( target_transition_parent","counters":[]},{"line":"                   , [ Rose_tree.T (target_transition_child, []) ] )","counters":[]},{"line":"               ] ) ;","counters":[]},{"line":"           Thread_safe.block_on_async_exn (fun () ->","counters":[]},{"line":"               let final =","counters":[]},{"line":"                 Cache_lib.Cached.final_state target_transition_parent","counters":[]},{"line":"               in","counters":[]},{"line":"               match%map","counters":[]},{"line":"                 Deferred.any","counters":[]},{"line":"                   [ (Ivar.read final >>| fun x -> `Catchup_failed x)","counters":[]},{"line":"                   ; Strict_pipe.Reader.read test.breadcrumbs_reader","counters":[]},{"line":"                     >>| const `Catchup_success","counters":[]},{"line":"                   ]","counters":[]},{"line":"               with","counters":[]},{"line":"               | `Catchup_success ->","counters":[]},{"line":"                   [%log info]","counters":[]},{"line":"                     \"validation fails unit test: somehow incorrectly succeeded\" ;","counters":[]},{"line":"","counters":[]},{"line":"                   failwith","counters":[]},{"line":"                     \"target transition should've been invalidated with a \\","counters":[]},{"line":"                      failure\"","counters":[]},{"line":"               | `Catchup_failed fnl -> (","counters":[]},{"line":"                   match fnl with","counters":[]},{"line":"                   | `Success _ ->","counters":[]},{"line":"                       [%log info]","counters":[]},{"line":"                         \"validation fails unit test: somehow incorrectly \\","counters":[]},{"line":"                          succeeded\" ;","counters":[]},{"line":"                       failwith \"final state should be at `Failed\"","counters":[]},{"line":"                   | `Failed ->","counters":[]},{"line":"                       [%log info]","counters":[]},{"line":"                         \"validation fails unit test: correctly failed, running \\","counters":[]},{"line":"                          checks\" ;","counters":[]},{"line":"","counters":[]},{"line":"                       let catchup_tree =","counters":[]},{"line":"                         match","counters":[]},{"line":"                           Transition_frontier.catchup_tree my_net.state.frontier","counters":[]},{"line":"                         with","counters":[]},{"line":"                         | Full tr ->","counters":[]},{"line":"                             tr","counters":[]},{"line":"                         | Hash _ ->","counters":[]},{"line":"                             failwith","counters":[]},{"line":"                               \"in super catchup unit tests, the catchup tree \\","counters":[]},{"line":"                                should always be Full_catchup_tree, but it is \\","counters":[]},{"line":"                                Catchup_hash_tree for some reason\"","counters":[]},{"line":"                       in","counters":[]},{"line":"                       let catchup_tree_node_list =","counters":[]},{"line":"                         State_hash.Table.data catchup_tree.nodes","counters":[]},{"line":"                       in","counters":[]},{"line":"                       List.iter catchup_tree_node_list ~f:(fun catchup_node ->","counters":[]},{"line":"                           let hash = catchup_node.state_hash in","counters":[]},{"line":"                           if","counters":[]},{"line":"                             Marlin_plonk_bindings_pasta_fp.equal hash","counters":[]},{"line":"                               target_breadcrumb_child_hash","counters":[]},{"line":"                           then","counters":[]},{"line":"                             failwith","counters":[]},{"line":"                               \"the catchup job associated with \\","counters":[]},{"line":"                                target_breadcrumb_child_hash should have been \\","counters":[]},{"line":"                                cancelled and thus removed from the catchup \\","counters":[]},{"line":"                                tree, but it is still here\"","counters":[]},{"line":"                           else ()) ))) *)","counters":[]},{"line":"","counters":[]},{"line":"    (* let%test_unit \"when verification of a blocks fails, catchup will cancel \\","counters":[]},{"line":"                    its children's catchup job and remove the failed-to-verify \\","counters":[]},{"line":"                    block from the cache\" =","counters":[]},{"line":"       Quickcheck.test ~trials:1","counters":[]},{"line":"         Fake_network.Generator.(","counters":[]},{"line":"           gen ~precomputed_values ~verifier ~max_frontier_length","counters":[]},{"line":"             ~use_super_catchup","counters":[]},{"line":"             [ fresh_peer","counters":[]},{"line":"             ; broken_rpc_peer_branch","counters":[]},{"line":"                 ~frontier_branch_size:(max_frontier_length / 2)","counters":[]},{"line":"                 ~get_transition_chain_impl_option:None","counters":[]},{"line":"               (* TODO: write some kind of mock that makes verification fail, and thus make the test pass *)","counters":[]},{"line":"             ])","counters":[]},{"line":"         ~f:(fun network ->","counters":[]},{"line":"           let open Fake_network in","counters":[]},{"line":"           let [ my_net; peer_net ] = network.peer_networks in","counters":[]},{"line":"           let target_best_tip_path =","counters":[]},{"line":"             Transition_frontier.best_tip_path peer_net.state.frontier","counters":[]},{"line":"           in","counters":[]},{"line":"           let open Fake_network in","counters":[]},{"line":"           let target_breadcrumb_child = List.last_exn target_best_tip_path in","counters":[]},{"line":"           let target_breadcrumb_child_hash =","counters":[]},{"line":"             Transition_frontier.Breadcrumb.state_hash target_breadcrumb_child","counters":[]},{"line":"           in","counters":[]},{"line":"           let target_breadcrumb_parent =","counters":[]},{"line":"             List.nth_exn target_best_tip_path","counters":[]},{"line":"               (List.length target_best_tip_path - 2)","counters":[]},{"line":"           in","counters":[]},{"line":"           let test =","counters":[]},{"line":"             setup_catchup_pipes ~network:my_net.network","counters":[]},{"line":"               ~frontier:my_net.state.frontier","counters":[]},{"line":"           in","counters":[]},{"line":"           let parent_hash =","counters":[]},{"line":"             Transition_frontier.Breadcrumb.parent_hash target_breadcrumb_parent","counters":[]},{"line":"           in","counters":[]},{"line":"           let target_transition_parent =","counters":[]},{"line":"             Transition_handler.Unprocessed_transition_cache.register_exn","counters":[]},{"line":"               test.cache","counters":[]},{"line":"               (downcast_breadcrumb target_breadcrumb_parent)","counters":[]},{"line":"           in","counters":[]},{"line":"           let target_transition_child =","counters":[]},{"line":"             Transition_handler.Unprocessed_transition_cache.register_exn","counters":[]},{"line":"               test.cache","counters":[]},{"line":"               (downcast_breadcrumb target_breadcrumb_child)","counters":[]},{"line":"           in","counters":[]},{"line":"           Strict_pipe.Writer.write test.job_writer","counters":[]},{"line":"             ( parent_hash","counters":[]},{"line":"             , [ Rose_tree.T","counters":[]},{"line":"                   ( target_transition_parent","counters":[]},{"line":"                   , [ Rose_tree.T (target_transition_child, []) ] )","counters":[]},{"line":"               ] ) ;","counters":[]},{"line":"           Thread_safe.block_on_async_exn (fun () ->","counters":[]},{"line":"               let final =","counters":[]},{"line":"                 Cache_lib.Cached.final_state target_transition_parent","counters":[]},{"line":"               in","counters":[]},{"line":"               match%map","counters":[]},{"line":"                 Deferred.any","counters":[]},{"line":"                   [ (Ivar.read final >>| fun x -> `Catchup_failed x)","counters":[]},{"line":"                   ; Strict_pipe.Reader.read test.breadcrumbs_reader","counters":[]},{"line":"                     >>| const `Catchup_success","counters":[]},{"line":"                   ]","counters":[]},{"line":"               with","counters":[]},{"line":"               | `Catchup_success ->","counters":[]},{"line":"                   failwith","counters":[]},{"line":"                     \"target transition should've been invalidated with a \\","counters":[]},{"line":"                      failure\"","counters":[]},{"line":"               | `Catchup_failed fnl -> (","counters":[]},{"line":"                   match fnl with","counters":[]},{"line":"                   | `Success _ ->","counters":[]},{"line":"                       failwith \"final state should be at `Failed\"","counters":[]},{"line":"                   | `Failed ->","counters":[]},{"line":"                       let catchup_tree =","counters":[]},{"line":"                         match","counters":[]},{"line":"                           Transition_frontier.catchup_tree my_net.state.frontier","counters":[]},{"line":"                         with","counters":[]},{"line":"                         | Full tr ->","counters":[]},{"line":"                             tr","counters":[]},{"line":"                         | Hash _ ->","counters":[]},{"line":"                             failwith","counters":[]},{"line":"                               \"in super catchup unit tests, the catchup tree \\","counters":[]},{"line":"                                should always be Full_catchup_tree, but it is \\","counters":[]},{"line":"                                Catchup_hash_tree for some reason\"","counters":[]},{"line":"                       in","counters":[]},{"line":"                       let catchup_tree_node_list =","counters":[]},{"line":"                         State_hash.Table.data catchup_tree.nodes","counters":[]},{"line":"                       in","counters":[]},{"line":"                       List.iter catchup_tree_node_list ~f:(fun catchup_node ->","counters":[]},{"line":"                           let hash = catchup_node.state_hash in","counters":[]},{"line":"                           if","counters":[]},{"line":"                             Marlin_plonk_bindings_pasta_fp.equal hash","counters":[]},{"line":"                               target_breadcrumb_child_hash","counters":[]},{"line":"                           then","counters":[]},{"line":"                             failwith","counters":[]},{"line":"                               \"the catchup job associated with \\","counters":[]},{"line":"                                target_breadcrumb_child_hash should have been \\","counters":[]},{"line":"                                cancelled and thus removed from the catchup \\","counters":[]},{"line":"                                tree, but it is still here\"","counters":[]},{"line":"                           else ()) ))) *)","counters":[]},{"line":"","counters":[]},{"line":"    (* let%test_unit \"when building a breadcrumb fails, catchup will cancel its \\","counters":[]},{"line":"                    children's catchup job and remove the failed-to-build block \\","counters":[]},{"line":"                    from the cache\" =","counters":[]},{"line":"       Quickcheck.test ~trials:1","counters":[]},{"line":"         Fake_network.Generator.(","counters":[]},{"line":"           gen ~precomputed_values ~verifier ~max_frontier_length","counters":[]},{"line":"             ~use_super_catchup","counters":[]},{"line":"             [ fresh_peer","counters":[]},{"line":"             ; broken_rpc_peer_branch","counters":[]},{"line":"                 ~frontier_branch_size:(max_frontier_length / 2)","counters":[]},{"line":"                 ~get_transition_chain_impl_option:None","counters":[]},{"line":"             ])","counters":[]},{"line":"         ~f:(fun network ->","counters":[]},{"line":"           let open Fake_network in","counters":[]},{"line":"           let [ my_net; peer_net ] = network.peer_networks in","counters":[]},{"line":"           let target_best_tip_path =","counters":[]},{"line":"             Transition_frontier.best_tip_path peer_net.state.frontier","counters":[]},{"line":"           in","counters":[]},{"line":"           let open Fake_network in","counters":[]},{"line":"           let target_breadcrumb_child = List.last_exn target_best_tip_path in","counters":[]},{"line":"           let target_breadcrumb_child_hash =","counters":[]},{"line":"             Transition_frontier.Breadcrumb.state_hash target_breadcrumb_child","counters":[]},{"line":"           in","counters":[]},{"line":"           let target_breadcrumb_parent =","counters":[]},{"line":"             List.nth_exn target_best_tip_path","counters":[]},{"line":"               (List.length target_best_tip_path - 2)","counters":[]},{"line":"           in","counters":[]},{"line":"           let test =","counters":[]},{"line":"             setup_catchup_pipes ~network:my_net.network","counters":[]},{"line":"               ~frontier:my_net.state.frontier","counters":[]},{"line":"             (* setup_catchup_pipes_fail_build_breadcrumb ~network:my_net.network","counters":[]},{"line":"               ~frontier:my_net.state.frontier *)","counters":[]},{"line":"           in","counters":[]},{"line":"           let parent_hash =","counters":[]},{"line":"             Transition_frontier.Breadcrumb.parent_hash target_breadcrumb_parent","counters":[]},{"line":"           in","counters":[]},{"line":"           let target_transition_parent =","counters":[]},{"line":"             Transition_handler.Unprocessed_transition_cache.register_exn","counters":[]},{"line":"               test.cache","counters":[]},{"line":"               (downcast_breadcrumb target_breadcrumb_parent)","counters":[]},{"line":"           in","counters":[]},{"line":"           let target_transition_child =","counters":[]},{"line":"             Transition_handler.Unprocessed_transition_cache.register_exn","counters":[]},{"line":"               test.cache","counters":[]},{"line":"               (downcast_breadcrumb target_breadcrumb_child)","counters":[]},{"line":"           in","counters":[]},{"line":"           Strict_pipe.Writer.write test.job_writer","counters":[]},{"line":"             ( parent_hash","counters":[]},{"line":"             , [ Rose_tree.T","counters":[]},{"line":"                   ( target_transition_parent","counters":[]},{"line":"                   , [ Rose_tree.T (target_transition_child, []) ] )","counters":[]},{"line":"               ] ) ;","counters":[]},{"line":"           Thread_safe.block_on_async_exn (fun () ->","counters":[]},{"line":"               let final =","counters":[]},{"line":"                 Cache_lib.Cached.final_state target_transition_parent","counters":[]},{"line":"               in","counters":[]},{"line":"               match%map","counters":[]},{"line":"                 Deferred.any","counters":[]},{"line":"                   [ (Ivar.read final >>| fun x -> `Catchup_failed x)","counters":[]},{"line":"                   ; Strict_pipe.Reader.read test.breadcrumbs_reader","counters":[]},{"line":"                     >>| const `Catchup_success","counters":[]},{"line":"                   ]","counters":[]},{"line":"               with","counters":[]},{"line":"               | `Catchup_success ->","counters":[]},{"line":"                   failwith","counters":[]},{"line":"                     \"target transition should've been invalidated with a \\","counters":[]},{"line":"                      failure\"","counters":[]},{"line":"               | `Catchup_failed fnl -> (","counters":[]},{"line":"                   match fnl with","counters":[]},{"line":"                   | `Success _ ->","counters":[]},{"line":"                       failwith \"final state should be at `Failed\"","counters":[]},{"line":"                   | `Failed ->","counters":[]},{"line":"                       let catchup_tree =","counters":[]},{"line":"                         match","counters":[]},{"line":"                           Transition_frontier.catchup_tree my_net.state.frontier","counters":[]},{"line":"                         with","counters":[]},{"line":"                         | Full tr ->","counters":[]},{"line":"                             tr","counters":[]},{"line":"                         | Hash _ ->","counters":[]},{"line":"                             failwith","counters":[]},{"line":"                               \"in super catchup unit tests, the catchup tree \\","counters":[]},{"line":"                                should always be Full_catchup_tree, but it is \\","counters":[]},{"line":"                                Catchup_hash_tree for some reason\"","counters":[]},{"line":"                       in","counters":[]},{"line":"                       let catchup_tree_node_list =","counters":[]},{"line":"                         State_hash.Table.data catchup_tree.nodes","counters":[]},{"line":"                       in","counters":[]},{"line":"                       List.iter catchup_tree_node_list ~f:(fun catchup_node ->","counters":[]},{"line":"                           let hash = catchup_node.state_hash in","counters":[]},{"line":"                           if","counters":[]},{"line":"                             Marlin_plonk_bindings_pasta_fp.equal hash","counters":[]},{"line":"                               target_breadcrumb_child_hash","counters":[]},{"line":"                           then","counters":[]},{"line":"                             failwith","counters":[]},{"line":"                               \"the catchup job associated with \\","counters":[]},{"line":"                                target_breadcrumb_child_hash should have been \\","counters":[]},{"line":"                                cancelled and thus removed from the catchup \\","counters":[]},{"line":"                                tree, but it is still here\"","counters":[]},{"line":"                           else ()) ))) *)","counters":[]},{"line":"  end )","counters":[{"col_start":6,"col_end":6,"count":2}]}]}