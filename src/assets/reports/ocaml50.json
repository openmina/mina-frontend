{"filename":"src/lib/gossip_net/fake.ml","lines":[{"line":"open Async_kernel","counters":[]},{"line":"open Core","counters":[]},{"line":"open Pipe_lib","counters":[]},{"line":"open Network_peer","counters":[]},{"line":"","counters":[]},{"line":"(* TODO: Implement RPC version translations (documented in Async_rpc_kernel).","counters":[]},{"line":" * This code currently only supports the latest version of RPCs. *)","counters":[]},{"line":"","counters":[]},{"line":"module type S = sig","counters":[]},{"line":"  include Intf.Gossip_net_intf","counters":[]},{"line":"","counters":[]},{"line":"  type network","counters":[]},{"line":"","counters":[]},{"line":"  val create_network : Peer.t list -> network","counters":[]},{"line":"","counters":[]},{"line":"  val create_instance :","counters":[]},{"line":"       network","counters":[]},{"line":"    -> Peer.t","counters":[]},{"line":"    -> Rpc_intf.rpc_handler list","counters":[]},{"line":"    -> Message.sinks","counters":[]},{"line":"    -> t Deferred.t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make (Rpc_intf : Network_peer.Rpc_intf.Rpc_interface_intf) :","counters":[]},{"line":"  S with module Rpc_intf := Rpc_intf = struct","counters":[]},{"line":"  open Intf","counters":[]},{"line":"  open Rpc_intf","counters":[]},{"line":"","counters":[]},{"line":"  module Network = struct","counters":[]},{"line":"    type rpc_hook =","counters":[]},{"line":"      { hook :","counters":[]},{"line":"          'q 'r.","counters":[]},{"line":"             Peer.Id.t","counters":[]},{"line":"          -> ('q, 'r) rpc","counters":[]},{"line":"          -> 'q","counters":[]},{"line":"          -> 'r Network_peer.Rpc_intf.rpc_response Deferred.t","counters":[]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    type network_interface = { sinks : Message.sinks; rpc_hook : rpc_hook }","counters":[]},{"line":"","counters":[]},{"line":"    type node = { peer : Peer.t; mutable interface : network_interface option }","counters":[]},{"line":"","counters":[]},{"line":"    type t = { nodes : (Peer.Id.t, node list) Hashtbl.t }","counters":[]},{"line":"","counters":[]},{"line":"    let create peers =","counters":[]},{"line":"      let nodes = Hashtbl.create (module Peer.Id) in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      List.iter peers ~f:(fun peer ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          Hashtbl.add_multi nodes ~key:peer.Peer.peer_id","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ~data:{ peer; interface = None } ) ;","counters":[]},{"line":"      { nodes }","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let get_initial_peers { nodes } local_ip =","counters":[]},{"line":"      Hashtbl.data nodes |> List.concat","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"      |> List.filter_map ~f:(fun node ->","counters":[]},{"line":"             if Unix.Inet_addr.equal node.peer.host local_ip then None","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"             else Some node.peer )","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"","counters":[]},{"line":"    let lookup_node t peer =","counters":[]},{"line":"      let error = Error.of_string \"peer does not exist\" in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let nodes =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Hashtbl.find t.nodes peer.Peer.peer_id |> Option.value_exn ~error","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"      in","counters":[]},{"line":"      List.find nodes ~f:(fun node -> Peer.equal peer node.peer)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":14,"col_end":14,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"      |> Option.value_exn ~error","counters":[]},{"line":"","counters":[]},{"line":"    let attach_interface t peer interface =","counters":[]},{"line":"      let node = lookup_node t peer in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      node.interface <- Some interface","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let get_interface peer =","counters":[]},{"line":"      match peer.interface with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Some x ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Ok x","counters":[]},{"line":"      | None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Or_error.error_string","counters":[]},{"line":"            \"cannot call rpc on peer which was never registered\"","counters":[]},{"line":"","counters":[]},{"line":"    let broadcast t ~sender msg send_f =","counters":[]},{"line":"      Hashtbl.fold t.nodes ~init:Deferred.unit","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ~f:(fun ~key:_ ~data:nodes prev ->","counters":[]},{"line":"          prev","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          >>= fun () ->","counters":[]},{"line":"          Deferred.List.iter ~how:`Sequential nodes ~f:(fun node ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              if Peer.equal node.peer sender then Deferred.unit","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"              else","counters":[]},{"line":"                Option.fold node.interface","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  ~f:(fun a intf ->","counters":[]},{"line":"                    a","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                    >>= fun () ->","counters":[]},{"line":"                    let msg =","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      Envelope.(","counters":[]},{"line":"                        Incoming.wrap ~data:msg ~sender:(Sender.Remote sender))","counters":[]},{"line":"                    in","counters":[]},{"line":"                    send_f intf.sinks","counters":[]},{"line":"                      ( msg","counters":[]},{"line":"                      , Mina_net2.Validation_callback.create_without_expiration","counters":[{"col_start":78,"col_end":78,"count":0}]},{"line":"                          () ) )","counters":[]},{"line":"                  ~init:Deferred.unit ) )","counters":[]},{"line":"","counters":[]},{"line":"    let call_rpc :","counters":[]},{"line":"        type q r.","counters":[]},{"line":"           t","counters":[]},{"line":"        -> _","counters":[]},{"line":"        -> sender_id:Peer.Id.t","counters":[]},{"line":"        -> responder_id:Peer.Id.t","counters":[]},{"line":"        -> (q, r) rpc","counters":[]},{"line":"        -> q","counters":[]},{"line":"        -> r Network_peer.Rpc_intf.rpc_response Deferred.t =","counters":[]},{"line":"     fun t peer_table ~sender_id ~responder_id rpc query ->","counters":[]},{"line":"      let responder =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Option.value_exn","counters":[]},{"line":"          (Hashtbl.find peer_table responder_id)","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"          ~error:","counters":[]},{"line":"            (Error.createf \"failed to find peer %s in peer_table\" responder_id)","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"      in","counters":[]},{"line":"      match get_interface (lookup_node t responder) with","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"      | Ok intf ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          intf.rpc_hook.hook sender_id rpc query","counters":[]},{"line":"      | Error e ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Deferred.return (Network_peer.Rpc_intf.Failed_to_connect e)","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Instance = struct","counters":[]},{"line":"    type t =","counters":[]},{"line":"      { network : Network.t","counters":[]},{"line":"      ; me : Peer.t","counters":[]},{"line":"      ; rpc_handlers : rpc_handler list","counters":[]},{"line":"      ; peer_table : (Peer.Id.t, Peer.t) Hashtbl.t","counters":[]},{"line":"      ; initial_peers : Peer.t list","counters":[]},{"line":"      ; connection_gating : Mina_net2.connection_gating ref","counters":[]},{"line":"      ; ban_notification_reader : ban_notification Linear_pipe.Reader.t","counters":[]},{"line":"      ; ban_notification_writer : ban_notification Linear_pipe.Writer.t","counters":[]},{"line":"      ; time_controller : Block_time.Controller.t","counters":[]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    let rpc_hook t rpc_handlers =","counters":[]},{"line":"      let hook :","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          type q r.","counters":[]},{"line":"             Peer.Id.t","counters":[]},{"line":"          -> (q, r) rpc","counters":[]},{"line":"          -> q","counters":[]},{"line":"          -> r Network_peer.Rpc_intf.rpc_response Deferred.t =","counters":[]},{"line":"       fun peer rpc query ->","counters":[]},{"line":"        let (module Impl) = implementation_of_rpc rpc in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let latest_version =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (* this is assumed safe since there should always be at least one version *)","counters":[]},{"line":"          Int.Set.max_elt (Impl.versions ())","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"          |> Option.value_exn ~error:(Error.of_string \"no versions?\")","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"        in","counters":[]},{"line":"        let sender =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Hashtbl.find t.peer_table peer","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"          |> Option.value_exn ~error:(Error.createf \"cannot find peer %s\" peer)","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"        in","counters":[]},{"line":"        match","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          List.find_map rpc_handlers ~f:(fun handler ->","counters":[]},{"line":"              match_handler handler rpc ~do_:(fun f ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                  f sender ~version:latest_version query ) )","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"        with","counters":[]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            failwith \"fake gossip net error: rpc not implemented\"","counters":[]},{"line":"        | Some deferred ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let%map response = deferred in","counters":[]},{"line":"            Network_peer.Rpc_intf.Connected","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (Envelope.Incoming.wrap_peer ~data:(Ok response) ~sender)","counters":[]},{"line":"      in","counters":[]},{"line":"      Network.{ hook }","counters":[]},{"line":"","counters":[]},{"line":"    let create network me rpc_handlers sinks =","counters":[]},{"line":"      let initial_peers = Network.get_initial_peers network me.Peer.host in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let peer_table = Hashtbl.create (module Peer.Id) in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      List.iter initial_peers ~f:(fun peer ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          Hashtbl.add_exn peer_table ~key:peer.peer_id ~data:peer ) ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"      let ban_notification_reader, ban_notification_writer =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Linear_pipe.create ()","counters":[]},{"line":"      in","counters":[]},{"line":"      let time_controller =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Block_time.Controller.create","counters":[]},{"line":"        @@ Block_time.Controller.basic ~logger:(Logger.create ())","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"      in","counters":[]},{"line":"      let t =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { network","counters":[]},{"line":"        ; me","counters":[]},{"line":"        ; rpc_handlers","counters":[]},{"line":"        ; peer_table","counters":[]},{"line":"        ; initial_peers","counters":[]},{"line":"        ; connection_gating =","counters":[]},{"line":"            ref","counters":[]},{"line":"              Mina_net2.","counters":[]},{"line":"                { banned_peers = []; trusted_peers = []; isolate = false }","counters":[]},{"line":"        ; ban_notification_reader","counters":[]},{"line":"        ; ban_notification_writer","counters":[]},{"line":"        ; time_controller","counters":[]},{"line":"        }","counters":[]},{"line":"      in","counters":[]},{"line":"      Network.(","counters":[]},{"line":"        attach_interface network me","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"          { sinks; rpc_hook = rpc_hook t rpc_handlers }) ;","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"      t","counters":[]},{"line":"","counters":[]},{"line":"    let peers { peer_table; _ } = Hashtbl.data peer_table |> Deferred.return","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"","counters":[]},{"line":"    let bandwidth_info _ =","counters":[]},{"line":"      Deferred.Or_error.fail","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (Error.of_string \"fake bandwidth info: Not implemented\")","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"    let set_node_status _ _ = Deferred.Or_error.ok_unit","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"","counters":[]},{"line":"    let get_peer_node_status _ _ =","counters":[]},{"line":"      Deferred.Or_error.error_string \"fake node status: Not implemented\"","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let add_peer _ (_p : Peer.t) ~is_seed:_ = Deferred.return (Ok ())","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"","counters":[]},{"line":"    let initial_peers t =","counters":[]},{"line":"      Hashtbl.data t.peer_table","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"      |> List.map","counters":[]},{"line":"           ~f:","counters":[]},{"line":"             (Fn.compose Mina_net2.Multiaddr.of_string Peer.to_multiaddr_string)","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"    let random_peers t n =","counters":[]},{"line":"      let%map peers = peers t in","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"      List.take (List.permute @@ peers) n","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"","counters":[]},{"line":"    let random_peers_except t n ~except =","counters":[]},{"line":"      let%map peers = peers t in","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"      let peers_without_exception =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        List.filter peers ~f:(fun peer -> not (Base.Hash_set.mem except peer))","counters":[{"col_start":42,"col_end":42,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"      in","counters":[]},{"line":"      List.take (List.permute peers_without_exception) n","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"","counters":[]},{"line":"    let on_first_connect _ ~f = Deferred.return (f ())","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"","counters":[]},{"line":"    let on_first_high_connectivity _ ~f:_ = Deferred.never ()","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"    let ban_notification_reader { ban_notification_reader; _ } =","counters":[]},{"line":"      ban_notification_reader","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let query_peer ?heartbeat_timeout:_ ?timeout:_ t peer rpc query =","counters":[]},{"line":"      Network.call_rpc t.network t.peer_table ~sender_id:t.me.peer_id","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ~responder_id:peer rpc query","counters":[]},{"line":"","counters":[]},{"line":"    let query_peer' ?how ?heartbeat_timeout ?timeout t peer rpc qs =","counters":[]},{"line":"      let%map rs =","counters":[]},{"line":"        Deferred.List.map ?how qs","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"          ~f:(query_peer ?timeout ?heartbeat_timeout t peer rpc)","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"      in","counters":[]},{"line":"      with_return (fun { return } ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          let data =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            List.map rs ~f:(function","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"              | Connected x ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  x.data","counters":[]},{"line":"              | Failed_to_connect e ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  return (Network_peer.Rpc_intf.Failed_to_connect e) )","counters":[]},{"line":"            |> Or_error.all","counters":[]},{"line":"          in","counters":[]},{"line":"          let sender =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Option.value_exn","counters":[]},{"line":"              (Hashtbl.find t.peer_table peer)","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"              ~error:(Error.createf \"failed to find peer %s in peer_table\" peer)","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"          in","counters":[]},{"line":"          Connected (Envelope.Incoming.wrap_peer ~data ~sender) )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"    let query_random_peers _ = failwith \"TODO stub\"","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"","counters":[]},{"line":"    let broadcast_state ?origin_topic t state =","counters":[]},{"line":"      ignore origin_topic ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Network.broadcast t.network ~sender:t.me state","counters":[]},{"line":"        (fun (Any_sinks (sinksM, (sink_block, _, _))) (env, vc) ->","counters":[]},{"line":"          let time = Block_time.now t.time_controller in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let module M = (val sinksM) in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          M.Block_sink.push sink_block","counters":[]},{"line":"            (`Transition env, `Time_received time, `Valid_cb vc) )","counters":[]},{"line":"","counters":[]},{"line":"    let broadcast_snark_pool_diff ?origin_topic t diff =","counters":[]},{"line":"      ignore origin_topic ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Network.broadcast t.network ~sender:t.me diff","counters":[]},{"line":"        (fun (Any_sinks (sinksM, (_, _, sink_snark_work))) ->","counters":[]},{"line":"          let module M = (val sinksM) in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          M.Snark_sink.push sink_snark_work )","counters":[]},{"line":"","counters":[]},{"line":"    let broadcast_transaction_pool_diff ?origin_topic t diff =","counters":[]},{"line":"      ignore origin_topic ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Network.broadcast t.network ~sender:t.me diff","counters":[]},{"line":"        (fun (Any_sinks (sinksM, (_, sink_tx, _))) ->","counters":[]},{"line":"          let module M = (val sinksM) in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          M.Tx_sink.push sink_tx )","counters":[]},{"line":"","counters":[]},{"line":"    let connection_gating t = Deferred.return !(t.connection_gating)","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"","counters":[]},{"line":"    let set_connection_gating t config =","counters":[]},{"line":"      t.connection_gating := config ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Deferred.return config","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  type network = Network.t","counters":[]},{"line":"","counters":[]},{"line":"  include Instance","counters":[]},{"line":"","counters":[]},{"line":"  let restart_helper (_ : t) = ()","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"","counters":[]},{"line":"  let create_network = Network.create","counters":[]},{"line":"","counters":[]},{"line":"  let create_instance network local_ip impls sinks =","counters":[]},{"line":"    Deferred.return (Instance.create network local_ip impls sinks)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":1}]}]}