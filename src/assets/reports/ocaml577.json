{"filename":"src/lib/block_time/block_time.ml","lines":[{"line":"[%%import \"/src/config.mlh\"]","counters":[]},{"line":"","counters":[{"col_start":0,"col_end":0,"count":1}]},{"line":"open Core_kernel","counters":[]},{"line":"open Snark_params","counters":[]},{"line":"open Tick","counters":[]},{"line":"open Unsigned_extended","counters":[]},{"line":"open Snark_bits","counters":[]},{"line":"","counters":[]},{"line":"(** See documentation of the {!Mina_wire_types} library *)","counters":[]},{"line":"module Wire_types = Mina_wire_types.Block_time","counters":[]},{"line":"","counters":[]},{"line":"module Make_sig (A : Wire_types.Types.S) = struct","counters":[]},{"line":"  module type S = Intf.S with type Time.t = A.V1.t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make_str (_ : Wire_types.Concrete) = struct","counters":[]},{"line":"  module Time = struct","counters":[]},{"line":"    (* Milliseconds since epoch *)","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type t = UInt64.Stable.V1.t","counters":[{"col_start":8,"col_end":8,"count":2},{"col_start":13,"col_end":13,"count":1},{"col_start":17,"col_end":17,"count":0}]},{"line":"        [@@deriving sexp, compare, equal, hash, yojson]","counters":[{"col_start":54,"col_end":54,"count":5}]},{"line":"","counters":[]},{"line":"        let to_latest = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"        module T = struct","counters":[]},{"line":"          type typ = t [@@deriving sexp, compare, hash]","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"          type t = typ [@@deriving sexp, compare, hash]","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        end","counters":[]},{"line":"","counters":[]},{"line":"        include Hashable.Make (T)","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    let max_value = UInt64.max_int","counters":[]},{"line":"","counters":[]},{"line":"    let zero = UInt64.zero","counters":[]},{"line":"","counters":[]},{"line":"    module Controller = struct","counters":[]},{"line":"      [%%if time_offsets]","counters":[]},{"line":"","counters":[]},{"line":"      type t = unit -> Time.Span.t [@@deriving sexp]","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"      (* NB: All instances are identical by construction (see basic below). *)","counters":[]},{"line":"      let equal _ _ = true","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"      (* NB: All instances are identical by construction (see basic below). *)","counters":[]},{"line":"      let compare _ _ = 0","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"","counters":[]},{"line":"      let time_offset = ref None","counters":[]},{"line":"","counters":[]},{"line":"      let setting_enabled = ref None","counters":[]},{"line":"","counters":[]},{"line":"      let disable_setting_offset () = setting_enabled := Some false","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"","counters":[]},{"line":"      let enable_setting_offset () =","counters":[]},{"line":"        match !setting_enabled with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            setting_enabled := Some true","counters":[]},{"line":"        | Some true ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ()","counters":[]},{"line":"        | Some false ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            failwith","counters":[]},{"line":"              \"Cannot enable time offset mutations; it has been explicitly \\","counters":[]},{"line":"               disabled\"","counters":[]},{"line":"","counters":[]},{"line":"      let set_time_offset offset =","counters":[]},{"line":"        match !setting_enabled with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | Some true ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            time_offset := Some offset","counters":[]},{"line":"        | None | Some false ->","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"            failwith \"Cannot mutate the time offset\"","counters":[]},{"line":"","counters":[]},{"line":"      let create offset = offset","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"","counters":[]},{"line":"      let basic ~logger:_ () =","counters":[]},{"line":"        match !time_offset with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | Some offset ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            offset","counters":[]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let offset =","counters":[]},{"line":"              let env = \"MINA_TIME_OFFSET\" in","counters":[]},{"line":"              let env_offset =","counters":[]},{"line":"                match Core_kernel.Sys.getenv_opt env with","counters":[]},{"line":"                | Some tm ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    Int.of_string tm","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                | None ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    let default = 0 in","counters":[]},{"line":"                    eprintf","counters":[]},{"line":"                      \"Environment variable %s not found, using default of %d\\n\\","counters":[]},{"line":"                       %!\"","counters":[]},{"line":"                      env default ;","counters":[]},{"line":"                    default","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"              in","counters":[]},{"line":"              Core_kernel.Time.Span.of_int_sec env_offset","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"            in","counters":[]},{"line":"            time_offset := Some offset ;","counters":[]},{"line":"            offset","counters":[]},{"line":"","counters":[]},{"line":"      let get_time_offset ~logger = basic ~logger ()","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"","counters":[]},{"line":"      [%%else]","counters":[]},{"line":"","counters":[]},{"line":"      type t = unit [@@deriving sexp, equal, compare]","counters":[]},{"line":"","counters":[]},{"line":"      let create () = ()","counters":[]},{"line":"","counters":[]},{"line":"      let basic ~logger:_ = ()","counters":[]},{"line":"","counters":[]},{"line":"      let disable_setting_offset () = ()","counters":[]},{"line":"","counters":[]},{"line":"      let enable_setting_offset () = ()","counters":[]},{"line":"","counters":[]},{"line":"      let set_time_offset _ = failwith \"Cannot mutate the time offset\"","counters":[]},{"line":"","counters":[]},{"line":"      let get_time_offset _ = Core_kernel.Time.Span.of_int_sec 0","counters":[]},{"line":"","counters":[]},{"line":"      [%%endif]","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module B = Bits","counters":[]},{"line":"    module Bits = Bits.UInt64","counters":[]},{"line":"    include B.Snarkable.UInt64 (Tick)","counters":[]},{"line":"    module N = Mina_numbers.Nat.Make_checked (UInt64) (Bits)","counters":[]},{"line":"","counters":[]},{"line":"    let to_input (t : t) =","counters":[]},{"line":"      Random_oracle_input.Chunked.packed","counters":[{"col_start":6,"col_end":6,"count":12}]},{"line":"        (Tick.Field.project (Bits.to_bits t), 64)","counters":[{"col_start":26,"col_end":26,"count":12},{"col_start":40,"col_end":40,"count":12}]},{"line":"","counters":[]},{"line":"    module Checked = struct","counters":[]},{"line":"      type t = N.var","counters":[]},{"line":"","counters":[]},{"line":"      module Unsafe = N.Unsafe","counters":[]},{"line":"","counters":[]},{"line":"      let to_input (t : t) = N.to_input t","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"      let to_field = N.to_field","counters":[]},{"line":"","counters":[]},{"line":"      [%%define_locally N.(typ, ( = ), ( <= ), ( >= ), ( < ), ( > ))]","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Span = struct","counters":[]},{"line":"      [%%versioned","counters":[]},{"line":"      module Stable = struct","counters":[]},{"line":"        module V1 = struct","counters":[]},{"line":"          type t = UInt64.Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":2},{"col_start":15,"col_end":15,"count":1},{"col_start":19,"col_end":19,"count":0}]},{"line":"          [@@deriving sexp, compare, equal, hash, yojson]","counters":[{"col_start":56,"col_end":56,"count":5}]},{"line":"","counters":[]},{"line":"          let to_latest = Fn.id","counters":[]},{"line":"        end","counters":[]},{"line":"      end]","counters":[]},{"line":"","counters":[]},{"line":"      module Bits = B.UInt64","counters":[]},{"line":"      include B.Snarkable.UInt64 (Tick)","counters":[]},{"line":"","counters":[]},{"line":"      let of_time_span s = UInt64.of_int64 (Int64.of_float (Time.Span.to_ms s))","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":57,"col_end":57,"count":0},{"col_start":74,"col_end":74,"count":0}]},{"line":"","counters":[]},{"line":"      let to_time_span s = Time.Span.of_ms (Int64.to_float (UInt64.to_int64 s))","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":57,"col_end":57,"count":0},{"col_start":74,"col_end":74,"count":0}]},{"line":"","counters":[]},{"line":"      let to_time_ns_span s =","counters":[]},{"line":"        Time_ns.Span.of_ms (Int64.to_float (UInt64.to_int64 s))","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"","counters":[]},{"line":"      let of_time_ns_span ns : t =","counters":[]},{"line":"        let int64_ns = ns |> Time_ns.Span.to_int63_ns |> Int63.to_int64 in","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"        (* convert to milliseconds *)","counters":[]},{"line":"        Int64.(int64_ns / 1_000_000L) |> UInt64.of_int64","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      let to_string_hum s = to_time_ns_span s |> Time_ns.Span.to_string_hum","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"","counters":[]},{"line":"      let to_ms = UInt64.to_int64","counters":[]},{"line":"","counters":[]},{"line":"      let of_ms = UInt64.of_int64","counters":[]},{"line":"","counters":[]},{"line":"      [%%define_locally UInt64.Infix.(( + ), ( - ), ( * ))]","counters":[]},{"line":"","counters":[]},{"line":"      [%%define_locally UInt64.(( < ), ( > ), ( = ), ( <= ), ( >= ), min, zero)]","counters":[]},{"line":"","counters":[]},{"line":"      let to_input = to_input","counters":[]},{"line":"","counters":[]},{"line":"      module Checked = Checked","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    include Comparable.Make (Stable.Latest)","counters":[]},{"line":"    include Hashable.Make (Stable.Latest)","counters":[]},{"line":"","counters":[]},{"line":"    let of_time t =","counters":[]},{"line":"      UInt64.of_int64","counters":[{"col_start":6,"col_end":6,"count":1}]},{"line":"        (Int64.of_float (Time.Span.to_ms (Time.to_span_since_epoch t)))","counters":[{"col_start":22,"col_end":22,"count":1},{"col_start":39,"col_end":39,"count":1},{"col_start":65,"col_end":65,"count":1}]},{"line":"","counters":[]},{"line":"    (* TODO: Time.t can't hold the full uint64 range, so this can fail for large t *)","counters":[]},{"line":"    let to_time_exn t =","counters":[]},{"line":"      let t_int64 = UInt64.to_int64 t in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      if Int64.(t_int64 < zero) then failwith \"converting to negative timestamp\" ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"      Time.of_span_since_epoch (Time.Span.of_ms (Int64.to_float t_int64))","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":46,"col_end":46,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"","counters":[]},{"line":"    [%%if time_offsets]","counters":[]},{"line":"","counters":[]},{"line":"    let now offset = of_time (Time.sub (Time.now ()) (offset ()))","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":47,"col_end":47,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"","counters":[]},{"line":"    [%%else]","counters":[]},{"line":"","counters":[]},{"line":"    let now _ = of_time (Time.now ())","counters":[]},{"line":"","counters":[]},{"line":"    [%%endif]","counters":[]},{"line":"","counters":[]},{"line":"    let field_var_to_unpacked (x : Tick.Field.Var.t) =","counters":[]},{"line":"      Tick.Field.Checked.unpack ~length:64 x","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let epoch = of_time Time.epoch","counters":[{"col_start":22,"col_end":22,"count":1}]},{"line":"","counters":[]},{"line":"    let add x y = UInt64.add x y","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"","counters":[]},{"line":"    let diff x y = UInt64.sub x y","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"","counters":[]},{"line":"    let sub x y = UInt64.sub x y","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"","counters":[]},{"line":"    let to_span_since_epoch t = diff t epoch","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"","counters":[]},{"line":"    let of_span_since_epoch s = UInt64.add s epoch","counters":[{"col_start":32,"col_end":32,"count":3}]},{"line":"","counters":[]},{"line":"    let diff_checked x y =","counters":[]},{"line":"      let pack = Tick.Field.Var.project in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Span.unpack_var Tick.Field.Checked.(pack x - pack y)","counters":[{"col_start":45,"col_end":45,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"","counters":[]},{"line":"    let modulus t span = UInt64.rem t span","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"    let unpacked_to_number var =","counters":[]},{"line":"      let bits = Span.Unpacked.var_to_bits var in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Number.of_bits (bits :> Boolean.var list)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let to_int64 = Fn.compose Span.to_ms to_span_since_epoch","counters":[{"col_start":28,"col_end":28,"count":1}]},{"line":"","counters":[]},{"line":"    let of_int64 = Fn.compose of_span_since_epoch Span.of_ms","counters":[{"col_start":28,"col_end":28,"count":1}]},{"line":"","counters":[]},{"line":"    let of_uint64 : UInt64.t -> t = of_span_since_epoch","counters":[]},{"line":"","counters":[]},{"line":"    let to_uint64 : t -> UInt64.t = to_span_since_epoch","counters":[]},{"line":"","counters":[]},{"line":"    (* TODO: this can fail if the input has more than 63 bits, because it would be serialized to a negative number string *)","counters":[]},{"line":"    let to_string_exn t =","counters":[]},{"line":"      let t_int64 = UInt64.to_int64 t in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      if Int64.(t_int64 < zero) then failwith \"converting to negative timestamp\" ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"      Int64.to_string t_int64","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let of_time_ns ns : t =","counters":[]},{"line":"      let int64_ns = ns |> Time_ns.to_int63_ns_since_epoch |> Int63.to_int64 in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"      (* convert to milliseconds *)","counters":[]},{"line":"      Int64.(int64_ns / 1_000_000L) |> UInt64.of_int64","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    [%%if time_offsets]","counters":[]},{"line":"","counters":[]},{"line":"    let to_system_time (offset : Controller.t) (t : t) =","counters":[]},{"line":"      of_span_since_epoch","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Span.(to_span_since_epoch t + of_time_span (offset ()))","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":49,"col_end":49,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"","counters":[]},{"line":"    [%%else]","counters":[]},{"line":"","counters":[]},{"line":"    let to_system_time (_offset : Controller.t) (t : t) = t","counters":[]},{"line":"","counters":[]},{"line":"    [%%endif]","counters":[]},{"line":"","counters":[]},{"line":"    let to_string_system_time_exn (offset : Controller.t) (t : t) : string =","counters":[]},{"line":"      to_system_time offset t |> to_string_exn","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"","counters":[]},{"line":"    let of_string_exn string =","counters":[]},{"line":"      Int64.of_string string |> Span.of_ms |> of_span_since_epoch","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"","counters":[]},{"line":"    let gen_incl time_beginning time_end =","counters":[]},{"line":"      let open Quickcheck.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let time_beginning_int64 = to_int64 time_beginning in","counters":[]},{"line":"      let time_end_int64 = to_int64 time_end in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%map int64_time_span =","counters":[]},{"line":"        Int64.(gen_incl time_beginning_int64 time_end_int64)","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"      in","counters":[]},{"line":"      of_span_since_epoch @@ Span.of_ms int64_time_span","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"","counters":[]},{"line":"    let gen =","counters":[]},{"line":"      let open Quickcheck.Let_syntax in","counters":[]},{"line":"      let%map int64_time_span = Int64.(gen_incl zero max_value) in","counters":[{"col_start":46,"col_end":46,"count":1}]},{"line":"      of_span_since_epoch @@ Span.of_ms int64_time_span","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  include Time","counters":[]},{"line":"  module Timeout = Timeout_lib.Make (Time)","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"include Wire_types.Make (Make_sig) (Make_str)","counters":[{"col_start":44,"col_end":44,"count":1}]}]}