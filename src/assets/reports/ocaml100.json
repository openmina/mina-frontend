{"filename":"src/lib/transaction_snark/test/ring_sig.ml","lines":[{"line":"open Util","counters":[]},{"line":"open Core","counters":[]},{"line":"open Currency","counters":[]},{"line":"open Mina_base","counters":[]},{"line":"open Signature_lib","counters":[]},{"line":"module Impl = Pickles.Impls.Step","counters":[]},{"line":"module Inner_curve = Snark_params.Tick.Inner_curve","counters":[]},{"line":"module Nat = Pickles_types.Nat","counters":[]},{"line":"module Local_state = Mina_state.Local_state","counters":[]},{"line":"module Zkapp_command_segment = Transaction_snark.Zkapp_command_segment","counters":[]},{"line":"module Statement = Transaction_snark.Statement","counters":[]},{"line":"open Snark_params.Tick","counters":[]},{"line":"open Snark_params.Tick.Let_syntax","counters":[]},{"line":"","counters":[]},{"line":"(* check a signature on msg against a public key *)","counters":[]},{"line":"let check_sig pk msg sigma : Boolean.var Checked.t =","counters":[]},{"line":"  let%bind (module S) = Inner_curve.Checked.Shifted.create () in","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"  Schnorr.Chunked.Checked.verifies (module S) sigma pk msg","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"(* verify witness signature against public keys *)","counters":[]},{"line":"let%snarkydef_ verify_sig pubkeys msg sigma =","counters":[]},{"line":"  let%bind pubkeys =","counters":[]},{"line":"    exists","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"      (Typ.list ~length:(List.length pubkeys) Inner_curve.typ)","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"      ~compute:(As_prover.return pubkeys)","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"  in","counters":[]},{"line":"  Checked.List.exists pubkeys ~f:(fun pk -> check_sig pk msg sigma)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"  >>= Boolean.Assert.is_true","counters":[]},{"line":"","counters":[]},{"line":"let check_witness pubkeys msg witness =","counters":[]},{"line":"  Transaction_snark.dummy_constraints ()","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"  >>= fun () -> verify_sig pubkeys msg witness","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"","counters":[]},{"line":"type _ Snarky_backendless.Request.t +=","counters":[]},{"line":"  | Sigma : Schnorr.Chunked.Signature.t Snarky_backendless.Request.t","counters":[]},{"line":"","counters":[]},{"line":"let ring_sig_rule (ring_member_pks : Schnorr.Chunked.Public_key.t list) :","counters":[]},{"line":"    _ Pickles.Inductive_rule.t =","counters":[]},{"line":"  let ring_sig_main (tx_commitment : Zkapp_statement.Checked.t) : unit Checked.t","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      =","counters":[]},{"line":"    let msg_var =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Zkapp_statement.Checked.to_field_elements tx_commitment","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"      |> Random_oracle_input.Chunked.field_elements","counters":[]},{"line":"    in","counters":[]},{"line":"    let%bind sigma_var =","counters":[]},{"line":"      exists Schnorr.Chunked.Signature.typ ~request:(As_prover.return Sigma)","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"    in","counters":[]},{"line":"    check_witness ring_member_pks msg_var sigma_var","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  in","counters":[]},{"line":"  { identifier = \"ring-sig-rule\"","counters":[]},{"line":"  ; prevs = []","counters":[]},{"line":"  ; main =","counters":[]},{"line":"      (fun { public_input = x } ->","counters":[]},{"line":"        Run.run_checked @@ ring_sig_main x ;","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"        { previous_proof_statements = []","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        ; public_output = ()","counters":[]},{"line":"        ; auxiliary_output = ()","counters":[]},{"line":"        } )","counters":[]},{"line":"  ; uses_lookup = false","counters":[]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"let%test_unit \"1-of-1\" =","counters":[]},{"line":"  let gen =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"    let%map sk = Private_key.gen and msg = Field.gen_uniform in","counters":[]},{"line":"    (sk, Random_oracle.Input.Chunked.field_elements [| msg |])","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"  in","counters":[]},{"line":"  Quickcheck.test ~trials:1 gen ~f:(fun (sk, msg) ->","counters":[]},{"line":"      let pk = Inner_curve.(scale one sk) in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"      (let sigma = Schnorr.Chunked.sign sk msg in","counters":[]},{"line":"       let%bind sigma_var, msg_var =","counters":[]},{"line":"         exists","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"           Typ.(Schnorr.Chunked.Signature.typ * Schnorr.chunked_message_typ ())","counters":[{"col_start":74,"col_end":74,"count":0}]},{"line":"           ~compute:As_prover.(return (sigma, msg))","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"       in","counters":[]},{"line":"       check_witness [ pk ] msg_var sigma_var )","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"      |> Checked.map ~f:As_prover.return","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"      |> run_and_check |> Or_error.ok_exn )","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"","counters":[]},{"line":"let%test_unit \"1-of-2\" =","counters":[]},{"line":"  let gen =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"    let%map sk0 = Private_key.gen","counters":[]},{"line":"    and sk1 = Private_key.gen","counters":[]},{"line":"    and msg = Field.gen_uniform in","counters":[]},{"line":"    (sk0, sk1, Random_oracle.Input.Chunked.field_elements [| msg |])","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"  in","counters":[]},{"line":"  Quickcheck.test ~trials:1 gen ~f:(fun (sk0, sk1, msg) ->","counters":[]},{"line":"      let pk0 = Inner_curve.(scale one sk0) in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"      let pk1 = Inner_curve.(scale one sk1) in","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"      (let sigma1 = Schnorr.Chunked.sign sk1 msg in","counters":[]},{"line":"       let%bind sigma1_var =","counters":[]},{"line":"         exists Schnorr.Chunked.Signature.typ ~compute:(As_prover.return sigma1)","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"       and msg_var =","counters":[]},{"line":"         exists (Schnorr.chunked_message_typ ()) ~compute:(As_prover.return msg)","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":43,"col_end":43,"count":0},{"col_start":74,"col_end":74,"count":0}]},{"line":"       in","counters":[]},{"line":"       check_witness [ pk0; pk1 ] msg_var sigma1_var )","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"      |> Checked.map ~f:As_prover.return","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"      |> run_and_check |> Or_error.ok_exn )","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"","counters":[]},{"line":"(* test a snapp tx with a 3-account_update ring *)","counters":[]},{"line":"let%test_unit \"ring-signature snapp tx with 3 zkapp_command\" =","counters":[]},{"line":"  let open Mina_transaction_logic.For_tests in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let gen =","counters":[]},{"line":"    let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"    (* secret keys of ring participants*)","counters":[]},{"line":"    let%map ring_member_sks =","counters":[]},{"line":"      Quickcheck.Generator.list_with_length 3 Private_key.gen","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"    (* index of the key that will sign the msg *)","counters":[]},{"line":"    and sign_index = Base_quickcheck.Generator.int_inclusive 0 2","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"    and test_spec = Test_spec.gen in","counters":[]},{"line":"    (ring_member_sks, sign_index, test_spec)","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  in","counters":[]},{"line":"  (* set to true to print vk, zkapp_command *)","counters":[]},{"line":"  let debug_mode : bool = false in","counters":[]},{"line":"  Quickcheck.test ~trials:1 gen","counters":[]},{"line":"    ~f:(fun (ring_member_sks, sign_index, { init_ledger; specs }) ->","counters":[]},{"line":"      let ring_member_pks =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        List.map ring_member_sks ~f:Inner_curve.(scale one)","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"      in","counters":[]},{"line":"      Ledger.with_ledger ~depth:ledger_depth ~f:(fun ledger ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          Init_ledger.init (module Ledger.Ledger_inner) init_ledger ledger ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let spec = List.hd_exn specs in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let tag, _, (module P), Pickles.Provers.[ ringsig_prover; _ ] =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Pickles.compile () ~cache:Cache_dir.cache","counters":[]},{"line":"              ~public_input:(Input Zkapp_statement.typ) ~auxiliary_typ:Typ.unit","counters":[]},{"line":"              ~branches:(module Nat.N2)","counters":[]},{"line":"              ~max_proofs_verified:(module Nat.N2)","counters":[]},{"line":"                (* You have to put 2 here... *)","counters":[]},{"line":"              ~name:\"ringsig\"","counters":[]},{"line":"              ~constraint_constants:","counters":[]},{"line":"                (Genesis_constants.Constraint_constants.to_snark_keys_header","counters":[{"col_start":75,"col_end":75,"count":0}]},{"line":"                   constraint_constants )","counters":[]},{"line":"              ~choices:(fun ~self ->","counters":[]},{"line":"                [ ring_sig_rule ring_member_pks; dummy_rule self ] )","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"          in","counters":[]},{"line":"          let vk = Pickles.Side_loaded.Verification_key.of_compiled tag in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          ( if debug_mode then","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Binable.to_string (module Side_loaded_verification_key.Stable.V2) vk","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"            |> Base64.encode_exn ~alphabet:Base64.uri_safe_alphabet","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"            |> printf \"vk:\\n%s\\n\\n\" )","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":20,"col_end":20,"count":0}]},{"line":"          |> fun () ->","counters":[]},{"line":"          let Mina_transaction_logic.For_tests.Transaction_spec.","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"                { sender = sender, sender_nonce","counters":[]},{"line":"                ; receiver = ringsig_account_pk","counters":[]},{"line":"                ; amount","counters":[]},{"line":"                ; _","counters":[]},{"line":"                } =","counters":[]},{"line":"            spec","counters":[]},{"line":"          in","counters":[]},{"line":"          let fee = Amount.of_string \"1000000\" in","counters":[]},{"line":"          let vk = With_hash.of_data ~hash_data:Zkapp_account.digest_vk vk in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let total = Option.value_exn (Amount.add fee amount) in","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"          (let _is_new, _loc =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"             let pk = Public_key.compress sender.public_key in","counters":[]},{"line":"             let id = Account_id.create pk Token_id.default in","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"             Ledger.get_or_create_account ledger id","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"               (Account.create id","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                  Balance.(Option.value_exn (add_amount zero total)) )","counters":[{"col_start":42,"col_end":42,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"             |> Or_error.ok_exn","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"           in","counters":[]},{"line":"           let _is_new, loc =","counters":[]},{"line":"             let id = Account_id.create ringsig_account_pk Token_id.default in","counters":[]},{"line":"             Ledger.get_or_create_account ledger id","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"               (Account.create id Balance.(of_int 0))","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"             |> Or_error.ok_exn","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"           in","counters":[]},{"line":"           let a = Ledger.get ledger loc |> Option.value_exn in","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"           Ledger.set ledger loc","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":20,"col_end":20,"count":0}]},{"line":"             { a with","counters":[]},{"line":"               zkapp =","counters":[]},{"line":"                 Some","counters":[]},{"line":"                   { (Option.value ~default:Zkapp_account.default a.zkapp) with","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"                     verification_key = Some vk","counters":[]},{"line":"                   }","counters":[]},{"line":"             } ) ;","counters":[]},{"line":"          let sender_pk = sender.public_key |> Public_key.compress in","counters":[]},{"line":"          let fee_payer : Account_update.Fee_payer.t =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            { Account_update.Fee_payer.body =","counters":[]},{"line":"                { public_key = sender_pk","counters":[]},{"line":"                ; fee = Amount.to_fee fee","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"                ; valid_until = None","counters":[]},{"line":"                ; nonce = sender_nonce","counters":[]},{"line":"                }","counters":[]},{"line":"                (* Real signature added in below *)","counters":[]},{"line":"            ; authorization = Signature.dummy","counters":[]},{"line":"            }","counters":[]},{"line":"          in","counters":[]},{"line":"          let sender_account_update_data : Account_update.Simple.t =","counters":[]},{"line":"            { body =","counters":[]},{"line":"                { public_key = sender_pk","counters":[]},{"line":"                ; update = Account_update.Update.noop","counters":[]},{"line":"                ; token_id = Token_id.default","counters":[]},{"line":"                ; balance_change = Amount.(Signed.(negate (of_unsigned amount)))","counters":[{"col_start":56,"col_end":56,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"                ; increment_nonce = true","counters":[]},{"line":"                ; events = []","counters":[]},{"line":"                ; sequence_events = []","counters":[]},{"line":"                ; call_data = Field.zero","counters":[]},{"line":"                ; call_depth = 0","counters":[]},{"line":"                ; preconditions =","counters":[]},{"line":"                    { Account_update.Preconditions.network =","counters":[]},{"line":"                        Zkapp_precondition.Protocol_state.accept","counters":[]},{"line":"                    ; account = Nonce (Account.Nonce.succ sender_nonce)","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"                    }","counters":[]},{"line":"                ; caller = Call","counters":[]},{"line":"                ; use_full_commitment = false","counters":[]},{"line":"                ; authorization_kind = Signature","counters":[]},{"line":"                }","counters":[]},{"line":"            ; authorization = Signature Signature.dummy","counters":[]},{"line":"            }","counters":[]},{"line":"          in","counters":[]},{"line":"          let snapp_account_update_data : Account_update.Simple.t =","counters":[]},{"line":"            { body =","counters":[]},{"line":"                { public_key = ringsig_account_pk","counters":[]},{"line":"                ; update = Account_update.Update.noop","counters":[]},{"line":"                ; token_id = Token_id.default","counters":[]},{"line":"                ; balance_change = Amount.Signed.(of_unsigned amount)","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"                ; events = []","counters":[]},{"line":"                ; sequence_events = []","counters":[]},{"line":"                ; call_data = Field.zero","counters":[]},{"line":"                ; call_depth = 0","counters":[]},{"line":"                ; increment_nonce = false","counters":[]},{"line":"                ; preconditions =","counters":[]},{"line":"                    { Account_update.Preconditions.network =","counters":[]},{"line":"                        Zkapp_precondition.Protocol_state.accept","counters":[]},{"line":"                    ; account = Full Zkapp_precondition.Account.accept","counters":[]},{"line":"                    }","counters":[]},{"line":"                ; use_full_commitment = false","counters":[]},{"line":"                ; caller = Call","counters":[]},{"line":"                ; authorization_kind = Proof","counters":[]},{"line":"                }","counters":[]},{"line":"            ; authorization = Proof Mina_base.Proof.transaction_dummy","counters":[]},{"line":"            }","counters":[]},{"line":"          in","counters":[]},{"line":"          let protocol_state = Zkapp_precondition.Protocol_state.accept in","counters":[]},{"line":"          let ps =","counters":[]},{"line":"            Zkapp_command.Call_forest.With_hashes.of_zkapp_command_simple_list","counters":[]},{"line":"              [ sender_account_update_data; snapp_account_update_data ]","counters":[]},{"line":"          in","counters":[]},{"line":"          let account_updates_hash = Zkapp_command.Call_forest.hash ps in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let memo = Signed_command_memo.empty in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let memo_hash = Signed_command_memo.hash memo in","counters":[]},{"line":"          let transaction : Zkapp_command.Transaction_commitment.t =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Zkapp_command.Transaction_commitment.create ~account_updates_hash","counters":[]},{"line":"          in","counters":[]},{"line":"          let tx_statement : Zkapp_statement.t =","counters":[]},{"line":"            { account_update =","counters":[]},{"line":"                Account_update.Body.digest","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"                  (Zkapp_command.add_caller_simple snapp_account_update_data","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"                     Token_id.default )","counters":[]},{"line":"                    .body","counters":[]},{"line":"            ; calls = (Zkapp_command.Digest.Forest.empty :> field)","counters":[]},{"line":"            }","counters":[]},{"line":"          in","counters":[]},{"line":"          let msg =","counters":[]},{"line":"            tx_statement |> Zkapp_statement.to_field_elements","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"            |> Random_oracle_input.Chunked.field_elements","counters":[]},{"line":"          in","counters":[]},{"line":"          let signing_sk = List.nth_exn ring_member_sks sign_index in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let sigma = Schnorr.Chunked.sign signing_sk msg in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let handler (Snarky_backendless.Request.With { request; respond }) =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            match request with","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            | Sigma ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                respond @@ Provide sigma","counters":[]},{"line":"            | _ ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                respond Unhandled","counters":[]},{"line":"          in","counters":[]},{"line":"          let (), (), (pi : Pickles.Side_loaded.Proof.t) =","counters":[]},{"line":"            (fun () -> ringsig_prover ~handler tx_statement)","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"            |> Async.Thread_safe.block_on_async_exn","counters":[]},{"line":"          in","counters":[]},{"line":"          let fee_payer =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let txn_comm =","counters":[]},{"line":"              Zkapp_command.Transaction_commitment.create_complete transaction","counters":[]},{"line":"                ~memo_hash","counters":[]},{"line":"                ~fee_payer_hash:","counters":[]},{"line":"                  (Zkapp_command.Digest.Account_update.create","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"                     (Account_update.of_fee_payer fee_payer) )","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"            in","counters":[]},{"line":"            { fee_payer with","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              authorization =","counters":[]},{"line":"                Signature_lib.Schnorr.Chunked.sign sender.private_key","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"                  (Random_oracle.Input.Chunked.field txn_comm)","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"            }","counters":[]},{"line":"          in","counters":[]},{"line":"          let sender : Account_update.Simple.t =","counters":[]},{"line":"            let sender_signature =","counters":[]},{"line":"              Signature_lib.Schnorr.Chunked.sign sender.private_key","counters":[]},{"line":"                (Random_oracle.Input.Chunked.field transaction)","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"            in","counters":[]},{"line":"            { body = sender_account_update_data.body","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            ; authorization = Signature sender_signature","counters":[]},{"line":"            }","counters":[]},{"line":"          in","counters":[]},{"line":"          let zkapp_command : Zkapp_command.t =","counters":[]},{"line":"            Zkapp_command.of_simple","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"              { fee_payer","counters":[]},{"line":"              ; account_updates =","counters":[]},{"line":"                  [ sender","counters":[]},{"line":"                  ; { body = snapp_account_update_data.body","counters":[]},{"line":"                    ; authorization = Proof pi","counters":[]},{"line":"                    }","counters":[]},{"line":"                  ]","counters":[]},{"line":"              ; memo","counters":[]},{"line":"              }","counters":[]},{"line":"          in","counters":[]},{"line":"          ( if debug_mode then","counters":[]},{"line":"            (* print fee payer *)","counters":[]},{"line":"            Account_update.Fee_payer.to_yojson fee_payer","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"            |> Yojson.Safe.pretty_to_string","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"            |> printf \"fee_payer:\\n%s\\n\\n\"","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"            |> fun () ->","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"            (* print other_account_update data *)","counters":[]},{"line":"            Zkapp_command.Call_forest.iteri zkapp_command.account_updates","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"              ~f:(fun idx (p : Account_update.t) ->","counters":[]},{"line":"                Account_update.Body.to_yojson p.body","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"                |> Yojson.Safe.pretty_to_string","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"                |> printf \"other_account_update #%d body:\\n%s\\n\\n\" idx )","counters":[]},{"line":"            |> fun () ->","counters":[]},{"line":"            (* print other_account_update proof *)","counters":[]},{"line":"            Pickles.Side_loaded.Proof.Stable.V2.sexp_of_t pi","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"            |> Sexp.to_string |> Base64.encode_exn","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"            |> printf \"other_account_update_proof:\\n%s\\n\\n\"","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"            |> fun () ->","counters":[]},{"line":"            (* print protocol_state *)","counters":[]},{"line":"            Zkapp_precondition.Protocol_state.to_yojson protocol_state","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"            |> Yojson.Safe.pretty_to_string","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"            |> printf \"protocol_state:\\n%s\\n\\n\" )","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"          |> fun () ->","counters":[]},{"line":"          ignore (apply_zkapp_command ledger [ zkapp_command ] : Sparse_ledger.t) ) )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":84,"col_end":84,"count":2}]}]}