{"filename":"src/lib/sync_status/sync_status.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"(** Sync_status represent states interacting with peers in the coda protocol.","counters":[]},{"line":"    When the protocol is starting, the node should be in the CONNECT state","counters":[]},{"line":"    trying to connect to a peer. Once it connects to a peer, the node should be","counters":[]},{"line":"    in the LISTENING state waiting for peers to send a message to them. When","counters":[]},{"line":"    the node receives a constant flow of messages, its state should be SYNCED.","counters":[]},{"line":"    However, when the node is bootstrapping, its state is BOOTSTRAPPING. If it","counters":[]},{"line":"    hasnâ€™t received messages for some time","counters":[]},{"line":"    (Mina_compile_config.inactivity_secs), then it is OFFLINE. *)","counters":[]},{"line":"let to_string = function","counters":[]},{"line":"  | `Connecting ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      \"Connecting\"","counters":[]},{"line":"  | `Listening ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      \"Listening\"","counters":[]},{"line":"  | `Offline ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      \"Offline\"","counters":[]},{"line":"  | `Bootstrap ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      \"Bootstrap\"","counters":[]},{"line":"  | `Synced ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      \"Synced\"","counters":[]},{"line":"  | `Catchup ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      \"Catchup\"","counters":[]},{"line":"","counters":[]},{"line":"let of_string string =","counters":[]},{"line":"  match String.lowercase string with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | \"connecting\" ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Ok `Connecting","counters":[]},{"line":"  | \"listening\" ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Ok `Listening","counters":[]},{"line":"  | \"offline\" ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Ok `Offline","counters":[]},{"line":"  | \"bootstrap\" ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Ok `Bootstrap","counters":[]},{"line":"  | \"synced\" ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Ok `Synced","counters":[]},{"line":"  | \"catchup\" ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Ok `Catchup","counters":[]},{"line":"  | status ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Error (Error.createf !\"%s is not a valid status\" status)","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"let to_yojson status = `String (to_string status)","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"let of_yojson : Yojson.Safe.t -> (_, string) Result.t = function","counters":[]},{"line":"  | `String s ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Result.map_error ~f:Error.to_string_hum (of_string s)","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"  | _ ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Error \"expected string\"","counters":[]},{"line":"","counters":[]},{"line":"module T = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type t =","counters":[{"col_start":6,"col_end":6,"count":2},{"col_start":11,"col_end":11,"count":1}]},{"line":"        [ `Connecting | `Listening | `Offline | `Bootstrap | `Synced | `Catchup ]","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      [@@deriving sexp, hash, compare, equal, enumerate]","counters":[{"col_start":55,"col_end":55,"count":5}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"      let to_yojson = to_yojson","counters":[]},{"line":"","counters":[]},{"line":"      let of_yojson = of_yojson","counters":[]},{"line":"","counters":[]},{"line":"      module T = struct","counters":[]},{"line":"        type typ = t [@@deriving sexp, hash, compare, equal, enumerate]","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"        type t = typ [@@deriving sexp, hash, compare, equal, enumerate]","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      include Hashable.Make (T)","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"include T","counters":[]},{"line":"include Hashable.Make (T)","counters":[]},{"line":"","counters":[]},{"line":"let check_conv to_repr of_repr ok_or_fail =","counters":[]},{"line":"  List.for_all","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    [ `Offline; `Bootstrap; `Synced; `Connecting; `Listening; `Catchup ]","counters":[]},{"line":"    ~f:(fun sync_status ->","counters":[]},{"line":"      equal sync_status (of_repr (to_repr sync_status) |> ok_or_fail) )","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"","counters":[]},{"line":"let%test \"of_string (to_string x) == x\" =","counters":[]},{"line":"  check_conv to_string of_string Or_error.ok_exn","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let%test \"of_yojson (to_yojson x) == x\" =","counters":[]},{"line":"  check_conv to_yojson of_yojson (function Error e -> failwith e | Ok x -> x)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":43,"col_end":43,"count":0},{"col_start":67,"col_end":67,"count":0},{"col_start":76,"col_end":76,"count":2}]}]}