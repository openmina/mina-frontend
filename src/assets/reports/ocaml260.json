{"filename":"src/lib/consensus/proof_of_stake.ml","lines":[{"line":"open Async_kernel","counters":[]},{"line":"open Core_kernel","counters":[]},{"line":"open Signed","counters":[]},{"line":"open Unsigned","counters":[]},{"line":"open Currency","counters":[]},{"line":"open Fold_lib","counters":[]},{"line":"open Signature_lib","counters":[]},{"line":"open Snark_params","counters":[]},{"line":"open Num_util","counters":[]},{"line":"","counters":[]},{"line":"module Segment_id = Mina_numbers.Nat.Make32 ()","counters":[]},{"line":"","counters":[]},{"line":"module Wire_types = Mina_wire_types.Consensus_proof_of_stake","counters":[]},{"line":"","counters":[]},{"line":"module Make_sig (A : Wire_types.Types.S) = struct","counters":[]},{"line":"  module type S =","counters":[]},{"line":"    Proof_of_stake_intf.Full","counters":[]},{"line":"      with type Data.Consensus_state.Value.Stable.V1.t =","counters":[]},{"line":"        A.Data.Consensus_state.Value.V1.t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make_str (A : Wire_types.Concrete) = struct","counters":[]},{"line":"  module Time = Block_time","counters":[]},{"line":"  module Run = Snark_params.Tick.Run","counters":[]},{"line":"  module Length = Mina_numbers.Length","counters":[]},{"line":"","counters":[]},{"line":"  module type CONTEXT = sig","counters":[]},{"line":"    val logger : Logger.t","counters":[]},{"line":"","counters":[]},{"line":"    val constraint_constants : Genesis_constants.Constraint_constants.t","counters":[]},{"line":"","counters":[]},{"line":"    val consensus_constants : Constants.t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let make_checked t = Snark_params.Tick.Run.make_checked t","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"  let name = \"proof_of_stake\"","counters":[]},{"line":"","counters":[]},{"line":"  let genesis_ledger_total_currency ~ledger =","counters":[]},{"line":"    Mina_ledger.Ledger.foldi ~init:Amount.zero (Lazy.force ledger)","counters":[{"col_start":4,"col_end":4,"count":12},{"col_start":57,"col_end":57,"count":12}]},{"line":"      ~f:(fun _addr sum (account : Mina_base.Account.t) ->","counters":[]},{"line":"        (* only default token matters for total currency used to determine stake *)","counters":[]},{"line":"        if Mina_base.(Token_id.equal account.token_id Token_id.default) then","counters":[{"col_start":8,"col_end":8,"count":216},{"col_start":35,"col_end":35,"count":216}]},{"line":"          Amount.add sum (Balance.to_amount @@ account.balance)","counters":[{"col_start":10,"col_end":10,"count":216},{"col_start":42,"col_end":42,"count":216}]},{"line":"          |> Option.value_exn ?here:None ?error:None","counters":[{"col_start":13,"col_end":13,"count":216}]},{"line":"               ~message:\"failed to calculate total currency in genesis ledger\"","counters":[]},{"line":"        else sum )","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"  let genesis_ledger_hash ~ledger =","counters":[]},{"line":"    Mina_ledger.Ledger.merkle_root (Lazy.force ledger)","counters":[{"col_start":4,"col_end":4,"count":8},{"col_start":45,"col_end":45,"count":8}]},{"line":"    |> Mina_base.Frozen_ledger_hash.of_ledger_hash","counters":[{"col_start":7,"col_end":7,"count":8}]},{"line":"","counters":[]},{"line":"  let compute_delegatee_table keys ~iter_accounts =","counters":[]},{"line":"    let open Mina_base in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let outer_table = Public_key.Compressed.Table.create () in","counters":[]},{"line":"    iter_accounts (fun i (acct : Account.t) ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        if","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Option.is_some acct.delegate","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"          (* Only default tokens may delegate. *)","counters":[]},{"line":"          && Token_id.equal acct.token_id Token_id.default","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"          && Public_key.Compressed.Set.mem keys (Option.value_exn acct.delegate)","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"        then","counters":[]},{"line":"          Public_key.Compressed.Table.update outer_table","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (Option.value_exn acct.delegate) ~f:(function","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"            | None ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Account.Index.Table.of_alist_exn [ (i, acct) ]","counters":[]},{"line":"            | Some table ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Account.Index.Table.add_exn table ~key:i ~data:acct ;","counters":[]},{"line":"                table ) ) ;","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"    (* TODO: this metric tracking currently assumes that the result of","counters":[]},{"line":"       compute_delegatee_table is called with the full set of block production","counters":[]},{"line":"       keypairs every time the set changes, which is true right now, but this","counters":[]},{"line":"       should be control flow should be refactored to make this clearer *)","counters":[]},{"line":"    let num_delegators =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Public_key.Compressed.Table.fold outer_table ~init:0","counters":[]},{"line":"        ~f:(fun ~key:_ ~data sum -> sum + Account.Index.Table.length data)","counters":[{"col_start":36,"col_end":36,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"    in","counters":[]},{"line":"    Mina_metrics.Gauge.set Mina_metrics.Consensus.staking_keypairs","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (Float.of_int @@ Public_key.Compressed.Set.length keys) ;","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"    Mina_metrics.Gauge.set Mina_metrics.Consensus.stake_delegators","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (Float.of_int num_delegators) ;","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"    outer_table","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let compute_delegatee_table_sparse_ledger keys ledger =","counters":[]},{"line":"    compute_delegatee_table keys ~iter_accounts:(fun f ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        Mina_ledger.Sparse_ledger.iteri ledger ~f:(fun i acct -> f i acct) )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"","counters":[]},{"line":"  let compute_delegatee_table_ledger_db keys ledger =","counters":[]},{"line":"    compute_delegatee_table keys ~iter_accounts:(fun f ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        Mina_ledger.Ledger.Db.iteri ledger ~f:(fun i acct -> f i acct) )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"","counters":[]},{"line":"  let compute_delegatee_table_genesis_ledger keys ledger =","counters":[]},{"line":"    compute_delegatee_table keys ~iter_accounts:(fun f ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        Mina_ledger.Ledger.iteri ledger ~f:(fun i acct -> f i acct) )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"","counters":[]},{"line":"  module Typ = Snark_params.Tick.Typ","counters":[]},{"line":"","counters":[]},{"line":"  module Configuration = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type t =","counters":[{"col_start":8,"col_end":8,"count":2},{"col_start":13,"col_end":13,"count":2}]},{"line":"          { delta : int","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"          ; k : int","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"          ; slots_per_epoch : int","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"          ; slot_duration : int","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"          ; epoch_duration : int","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"          ; genesis_state_timestamp : Block_time.Stable.V1.t","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"          ; acceptable_network_delay : int","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"          }","counters":[]},{"line":"        [@@deriving yojson, fields]","counters":[{"col_start":34,"col_end":34,"count":5}]},{"line":"","counters":[]},{"line":"        let to_latest = Fn.id","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    let t ~constraint_constants ~protocol_constants =","counters":[]},{"line":"      let constants =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Constants.create ~constraint_constants ~protocol_constants","counters":[]},{"line":"      in","counters":[]},{"line":"      let of_int32 = UInt32.to_int in","counters":[]},{"line":"      let of_span = Fn.compose Int64.to_int Block_time.Span.to_ms in","counters":[]},{"line":"      { delta = of_int32 constants.delta","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"      ; k = of_int32 constants.k","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"      ; slots_per_epoch = of_int32 constants.slots_per_epoch","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"      ; slot_duration = of_span constants.slot_duration_ms","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"      ; epoch_duration = of_span constants.epoch_duration","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"      ; genesis_state_timestamp = constants.genesis_state_timestamp","counters":[]},{"line":"      ; acceptable_network_delay = of_span constants.delta_duration","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"      }","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Constants = Constants","counters":[]},{"line":"  module Genesis_epoch_data = Genesis_epoch_data","counters":[]},{"line":"","counters":[]},{"line":"  module Data = struct","counters":[]},{"line":"    module Epoch_seed = struct","counters":[]},{"line":"      include Mina_base.Epoch_seed","counters":[]},{"line":"","counters":[]},{"line":"      type _unused = unit constraint t = Stable.Latest.t","counters":[]},{"line":"","counters":[]},{"line":"      let initial : t = of_hash Outside_hash_image.t","counters":[{"col_start":30,"col_end":30,"count":1}]},{"line":"","counters":[]},{"line":"      let update (seed : t) vrf_result =","counters":[]},{"line":"        let open Random_oracle in","counters":[{"col_start":8,"col_end":8,"count":2}]},{"line":"        hash ~init:Hash_prefix_states.epoch_seed","counters":[]},{"line":"          [| (seed :> Tick.Field.t); vrf_result |]","counters":[]},{"line":"        |> of_hash","counters":[{"col_start":11,"col_end":11,"count":2}]},{"line":"","counters":[]},{"line":"      let update_var (seed : var) vrf_result =","counters":[]},{"line":"        let open Random_oracle.Checked in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        make_checked (fun () ->","counters":[]},{"line":"            hash ~init:Hash_prefix_states.epoch_seed","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              [| var_to_hash_packed seed; vrf_result |]","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"            |> var_of_hash_packed )","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Epoch_and_slot = struct","counters":[]},{"line":"      type t = Epoch.t * Slot.t [@@deriving sexp]","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"","counters":[]},{"line":"      let of_time_exn ~(constants : Constants.t) tm : t =","counters":[]},{"line":"        let epoch = Epoch.of_time_exn tm ~constants in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let time_since_epoch =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Time.diff tm (Epoch.start_time epoch ~constants)","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"        in","counters":[]},{"line":"        let slot =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          uint32_of_int64","counters":[]},{"line":"          @@ Int64.Infix.(","counters":[]},{"line":"               Time.Span.to_ms time_since_epoch","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"               / Time.Span.to_ms constants.slot_duration_ms)","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"        in","counters":[]},{"line":"        (epoch, slot)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Block_data = struct","counters":[]},{"line":"      type t =","counters":[]},{"line":"        { stake_proof : Stake_proof.t","counters":[]},{"line":"        ; global_slot : Mina_numbers.Global_slot.t","counters":[]},{"line":"        ; global_slot_since_genesis : Mina_numbers.Global_slot.t","counters":[]},{"line":"        ; vrf_result : Random_oracle.Digest.t","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"      let prover_state { stake_proof; _ } = stake_proof","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"      let global_slot { global_slot; _ } = global_slot","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"","counters":[]},{"line":"      let epoch_ledger { stake_proof; _ } = stake_proof.ledger","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"      let global_slot_since_genesis { global_slot_since_genesis; _ } =","counters":[]},{"line":"        global_slot_since_genesis","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      let coinbase_receiver { stake_proof; _ } =","counters":[]},{"line":"        stake_proof.coinbase_receiver_pk","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Epoch_data_for_vrf = struct","counters":[]},{"line":"      [%%versioned","counters":[]},{"line":"      module Stable = struct","counters":[]},{"line":"        [@@@no_toplevel_latest_type]","counters":[]},{"line":"","counters":[]},{"line":"        module V2 = struct","counters":[]},{"line":"          type t =","counters":[{"col_start":10,"col_end":10,"count":2},{"col_start":15,"col_end":15,"count":2}]},{"line":"            { epoch_ledger : Mina_base.Epoch_ledger.Value.Stable.V1.t","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"            ; epoch_seed : Mina_base.Epoch_seed.Stable.V1.t","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"            ; epoch : Mina_numbers.Length.Stable.V1.t","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"            ; global_slot : Mina_numbers.Global_slot.Stable.V1.t","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"            ; global_slot_since_genesis : Mina_numbers.Global_slot.Stable.V1.t","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"            ; delegatee_table :","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"                Mina_base.Account.Stable.V2.t","counters":[]},{"line":"                Mina_base.Account.Index.Stable.V1.Table.t","counters":[]},{"line":"                Public_key.Compressed.Stable.V1.Table.t","counters":[]},{"line":"            }","counters":[]},{"line":"          [@@deriving sexp]","counters":[{"col_start":26,"col_end":26,"count":5}]},{"line":"","counters":[]},{"line":"          let to_latest = Fn.id","counters":[]},{"line":"        end","counters":[]},{"line":"      end]","counters":[]},{"line":"","counters":[]},{"line":"      type t = Stable.Latest.t =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { epoch_ledger : Mina_base.Epoch_ledger.Value.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"        ; epoch_seed : Mina_base.Epoch_seed.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"        ; epoch : Mina_numbers.Length.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":14,"col_end":14,"count":0}]},{"line":"        ; global_slot : Mina_numbers.Global_slot.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":20,"col_end":20,"count":0}]},{"line":"        ; global_slot_since_genesis : Mina_numbers.Global_slot.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"        ; delegatee_table :","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"            Mina_base.Account.t Mina_base.Account.Index.Table.t","counters":[]},{"line":"            Public_key.Compressed.Table.t","counters":[]},{"line":"        }","counters":[]},{"line":"      [@@deriving sexp]","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Slot_won = struct","counters":[]},{"line":"      [%%versioned","counters":[]},{"line":"      module Stable = struct","counters":[]},{"line":"        [@@@no_toplevel_latest_type]","counters":[]},{"line":"","counters":[]},{"line":"        module V1 = struct","counters":[]},{"line":"          type t =","counters":[{"col_start":10,"col_end":10,"count":2},{"col_start":15,"col_end":15,"count":2}]},{"line":"            { delegator :","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"                Public_key.Compressed.Stable.V1.t","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                * Mina_base.Account.Index.Stable.V1.t","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"            ; producer : Keypair.Stable.V1.t","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"            ; global_slot : Mina_numbers.Global_slot.Stable.V1.t","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"            ; global_slot_since_genesis : Mina_numbers.Global_slot.Stable.V1.t","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"            ; vrf_result : Consensus_vrf.Output_hash.Stable.V1.t","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"            }","counters":[]},{"line":"          [@@deriving sexp]","counters":[{"col_start":26,"col_end":26,"count":5}]},{"line":"","counters":[]},{"line":"          let to_latest = Fn.id","counters":[]},{"line":"        end","counters":[]},{"line":"      end]","counters":[]},{"line":"","counters":[]},{"line":"      type t = Stable.Latest.t =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { delegator : Public_key.Compressed.t * Mina_base.Account.Index.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":72,"col_end":72,"count":0}]},{"line":"        ; producer : Keypair.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"        ; global_slot : Mina_numbers.Global_slot.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":20,"col_end":20,"count":0}]},{"line":"        ; global_slot_since_genesis : Mina_numbers.Global_slot.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"        ; vrf_result : Consensus_vrf.Output_hash.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"        }","counters":[]},{"line":"      [@@deriving sexp]","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Local_state = struct","counters":[]},{"line":"      module Snapshot = struct","counters":[]},{"line":"        module Ledger_snapshot = struct","counters":[]},{"line":"          type t =","counters":[]},{"line":"            | Genesis_epoch_ledger of Mina_ledger.Ledger.t","counters":[]},{"line":"            | Ledger_db of Mina_ledger.Ledger.Db.t","counters":[]},{"line":"","counters":[]},{"line":"          let merkle_root = function","counters":[]},{"line":"            | Genesis_epoch_ledger ledger ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Mina_ledger.Ledger.merkle_root ledger","counters":[]},{"line":"            | Ledger_db ledger ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Mina_ledger.Ledger.Db.merkle_root ledger","counters":[]},{"line":"","counters":[]},{"line":"          let compute_delegatee_table keys ledger =","counters":[]},{"line":"            match ledger with","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            | Genesis_epoch_ledger ledger ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                compute_delegatee_table_genesis_ledger keys ledger","counters":[]},{"line":"            | Ledger_db ledger ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                compute_delegatee_table_ledger_db keys ledger","counters":[]},{"line":"","counters":[]},{"line":"          let close = function","counters":[]},{"line":"            | Genesis_epoch_ledger _ ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ()","counters":[]},{"line":"            | Ledger_db ledger ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Mina_ledger.Ledger.Db.close ledger","counters":[]},{"line":"","counters":[]},{"line":"          let remove ~location = function","counters":[]},{"line":"            | Genesis_epoch_ledger _ ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ()","counters":[]},{"line":"            | Ledger_db ledger ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Mina_ledger.Ledger.Db.close ledger ;","counters":[]},{"line":"                File_system.rmrf location","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"","counters":[]},{"line":"          let ledger_subset keys ledger =","counters":[]},{"line":"            match ledger with","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            | Genesis_epoch_ledger ledger ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Mina_ledger.Sparse_ledger.of_ledger_subset_exn ledger keys","counters":[]},{"line":"            | Ledger_db ledger ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Mina_ledger.(","counters":[]},{"line":"                  Sparse_ledger.of_any_ledger","counters":[]},{"line":"                  @@ Ledger.Any_ledger.cast_database_to_mask (module Ledger.Db) ledger)","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"        end","counters":[]},{"line":"","counters":[]},{"line":"        type t =","counters":[]},{"line":"          { ledger : Ledger_snapshot.t","counters":[]},{"line":"          ; delegatee_table :","counters":[]},{"line":"              Mina_base.Account.t Mina_base.Account.Index.Table.t","counters":[]},{"line":"              Public_key.Compressed.Table.t","counters":[]},{"line":"          }","counters":[]},{"line":"","counters":[]},{"line":"        let delegators t key =","counters":[]},{"line":"          Public_key.Compressed.Table.find t.delegatee_table key","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"        let to_yojson { ledger; delegatee_table } =","counters":[]},{"line":"          `Assoc","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            [ ( \"ledger_hash\"","counters":[]},{"line":"              , Ledger_snapshot.merkle_root ledger","counters":[]},{"line":"                |> Mina_base.Ledger_hash.to_yojson )","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"            ; ( \"delegators\"","counters":[]},{"line":"              , `Assoc","counters":[]},{"line":"                  ( Hashtbl.to_alist delegatee_table","counters":[]},{"line":"                  |> List.map ~f:(fun (key, delegators) ->","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"                         ( Public_key.Compressed.to_string key","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"                         , `Assoc","counters":[]},{"line":"                             ( Hashtbl.to_alist delegators","counters":[]},{"line":"                             |> List.map ~f:(fun (addr, account) ->","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"                                    ( Int.to_string addr","counters":[{"col_start":36,"col_end":36,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"                                    , Mina_base.Account.to_yojson account ) ) )","counters":[{"col_start":64,"col_end":64,"count":0}]},{"line":"                         ) ) ) )","counters":[]},{"line":"            ]","counters":[]},{"line":"","counters":[]},{"line":"        let ledger t = t.ledger","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      module Data = struct","counters":[]},{"line":"        type epoch_ledger_uuids =","counters":[]},{"line":"          { staking : Uuid.t","counters":[]},{"line":"          ; next : Uuid.t","counters":[]},{"line":"          ; genesis_state_hash : Mina_base.State_hash.t","counters":[]},{"line":"          }","counters":[]},{"line":"","counters":[]},{"line":"        (* Invariant: Snapshot's delegators are taken from accounts in block_production_pubkeys *)","counters":[]},{"line":"        type t =","counters":[]},{"line":"          { mutable staking_epoch_snapshot : Snapshot.t","counters":[]},{"line":"          ; mutable next_epoch_snapshot : Snapshot.t","counters":[]},{"line":"          ; last_checked_slot_and_epoch :","counters":[]},{"line":"              (Epoch.t * Slot.t) Public_key.Compressed.Table.t","counters":[]},{"line":"          ; mutable last_epoch_delegatee_table :","counters":[]},{"line":"              Mina_base.Account.t Mina_base.Account.Index.Table.t","counters":[]},{"line":"              Public_key.Compressed.Table.t","counters":[]},{"line":"              Option.t","counters":[]},{"line":"          ; mutable epoch_ledger_uuids : epoch_ledger_uuids","counters":[]},{"line":"          ; epoch_ledger_location : string","counters":[]},{"line":"          }","counters":[]},{"line":"","counters":[]},{"line":"        let to_yojson t =","counters":[]},{"line":"          `Assoc","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            [ ( \"staking_epoch_snapshot\"","counters":[]},{"line":"              , [%to_yojson: Snapshot.t] t.staking_epoch_snapshot )","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"            ; ( \"next_epoch_snapshot\"","counters":[]},{"line":"              , [%to_yojson: Snapshot.t] t.next_epoch_snapshot )","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"            ; ( \"last_checked_slot_and_epoch\"","counters":[]},{"line":"              , `Assoc","counters":[]},{"line":"                  ( Public_key.Compressed.Table.to_alist","counters":[]},{"line":"                      t.last_checked_slot_and_epoch","counters":[]},{"line":"                  |> List.map ~f:(fun (key, epoch_and_slot) ->","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"                         ( Public_key.Compressed.to_string key","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"                         , [%to_yojson: Epoch.t * Slot.t] epoch_and_slot ) ) )","counters":[{"col_start":40,"col_end":40,"count":0},{"col_start":46,"col_end":46,"count":0},{"col_start":50,"col_end":50,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"              )","counters":[]},{"line":"            ]","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      (* The outer ref changes whenever we swap in new staker set; all the snapshots are recomputed *)","counters":[]},{"line":"      type t = Data.t ref [@@deriving to_yojson]","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"","counters":[]},{"line":"      let staking_epoch_ledger_location (t : t) =","counters":[]},{"line":"        !t.epoch_ledger_location ^ Uuid.to_string !t.epoch_ledger_uuids.staking","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"","counters":[]},{"line":"      let next_epoch_ledger_location (t : t) =","counters":[]},{"line":"        !t.epoch_ledger_location ^ Uuid.to_string !t.epoch_ledger_uuids.next","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"","counters":[]},{"line":"      let current_epoch_delegatee_table ~(local_state : t) =","counters":[]},{"line":"        !local_state.staking_epoch_snapshot.delegatee_table","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      let last_epoch_delegatee_table ~(local_state : t) =","counters":[]},{"line":"        !local_state.last_epoch_delegatee_table","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      let current_block_production_keys t =","counters":[]},{"line":"        Public_key.Compressed.Table.keys !t.Data.last_checked_slot_and_epoch","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        |> Public_key.Compressed.Set.of_list","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"","counters":[]},{"line":"      let make_last_checked_slot_and_epoch_table old_table new_keys ~default =","counters":[]},{"line":"        let module Set = Public_key.Compressed.Set in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let module Table = Public_key.Compressed.Table in","counters":[]},{"line":"        let last_checked_slot_and_epoch = Table.create () in","counters":[]},{"line":"        Set.iter new_keys ~f:(fun pk ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            let data = Option.value (Table.find old_table pk) ~default in","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"            Table.add_exn last_checked_slot_and_epoch ~key:pk ~data ) ;","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"        last_checked_slot_and_epoch","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      let epoch_ledger_uuids_to_yojson","counters":[]},{"line":"          Data.{ staking; next; genesis_state_hash } =","counters":[]},{"line":"        `Assoc","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          [ (\"staking\", `String (Uuid.to_string staking))","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"          ; (\"next\", `String (Uuid.to_string next))","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"          ; ( \"genesis_state_hash\"","counters":[]},{"line":"            , Mina_base.State_hash.to_yojson genesis_state_hash )","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"          ]","counters":[]},{"line":"","counters":[]},{"line":"      let epoch_ledger_uuids_from_file location =","counters":[]},{"line":"        let open Yojson.Safe.Util in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let open Result.Let_syntax in","counters":[]},{"line":"        let json = Yojson.Safe.from_file location in","counters":[]},{"line":"        let uuid str =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Result.(","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            map_error","counters":[]},{"line":"              (try_with (fun () -> Uuid.of_string str))","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"              ~f:(fun ex -> Exn.to_string ex))","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"        in","counters":[]},{"line":"        let%bind staking = json |> member \"staking\" |> to_string |> uuid in","counters":[{"col_start":55,"col_end":55,"count":0},{"col_start":68,"col_end":68,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"        let%bind next = json |> member \"next\" |> to_string |> uuid in","counters":[{"col_start":49,"col_end":49,"count":0},{"col_start":62,"col_end":62,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"        let%map genesis_state_hash =","counters":[]},{"line":"          json |> member \"genesis_state_hash\" |> Mina_base.State_hash.of_yojson","counters":[{"col_start":49,"col_end":49,"count":0},{"col_start":78,"col_end":78,"count":0}]},{"line":"        in","counters":[]},{"line":"        Data.{ staking; next; genesis_state_hash }","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      let create_epoch_ledger ~location ~context:(module Context : CONTEXT)","counters":[]},{"line":"          ~genesis_epoch_ledger =","counters":[]},{"line":"        let open Context in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        if Sys.file_exists location then (","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"          [%log info]","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"            ~metadata:[ (\"location\", `String location) ]","counters":[]},{"line":"            \"Loading epoch ledger from disk: $location\" ;","counters":[]},{"line":"          Snapshot.Ledger_snapshot.Ledger_db","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (Mina_ledger.Ledger.Db.create ~directory_name:location","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"               ~depth:constraint_constants.ledger_depth () ) )","counters":[]},{"line":"        else Genesis_epoch_ledger (Lazy.force genesis_epoch_ledger)","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"      let create block_producer_pubkeys ~context:(module Context : CONTEXT)","counters":[]},{"line":"          ~genesis_ledger ~genesis_epoch_data ~epoch_ledger_location","counters":[]},{"line":"          ~genesis_state_hash =","counters":[]},{"line":"        let open Context in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        (* TODO: remove this duplicate of the genesis ledger *)","counters":[]},{"line":"        let genesis_epoch_ledger_staking, genesis_epoch_ledger_next =","counters":[]},{"line":"          Option.value_map genesis_epoch_data","counters":[]},{"line":"            ~default:(genesis_ledger, genesis_ledger)","counters":[]},{"line":"            ~f:(fun { Genesis_epoch_data.staking; next } ->","counters":[]},{"line":"              ( staking.ledger","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              , Option.value_map next ~default:staking.ledger ~f:(fun next ->","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                    next.ledger ) ) )","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"        in","counters":[]},{"line":"        let epoch_ledger_uuids_location = epoch_ledger_location ^ \".json\" in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let create_new_uuids () =","counters":[]},{"line":"          let epoch_ledger_uuids =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Data.","counters":[]},{"line":"              { staking = Uuid_unix.create ()","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"              ; next = Uuid_unix.create ()","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"              ; genesis_state_hash","counters":[]},{"line":"              }","counters":[]},{"line":"          in","counters":[]},{"line":"          Yojson.Safe.to_file epoch_ledger_uuids_location","counters":[]},{"line":"            (epoch_ledger_uuids_to_yojson epoch_ledger_uuids) ;","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"          epoch_ledger_uuids","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        in","counters":[]},{"line":"        let ledger_location uuid =","counters":[]},{"line":"          epoch_ledger_location ^ Uuid.to_string uuid","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"        in","counters":[]},{"line":"        let epoch_ledger_uuids =","counters":[]},{"line":"          if Sys.file_exists epoch_ledger_uuids_location then (","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"            let epoch_ledger_uuids =","counters":[]},{"line":"              match","counters":[]},{"line":"                epoch_ledger_uuids_from_file epoch_ledger_uuids_location","counters":[]},{"line":"              with","counters":[]},{"line":"              | Ok res ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  res","counters":[]},{"line":"              | Error str ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  [%log error]","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                    \"Failed to read epoch ledger uuids from file $path: \\","counters":[]},{"line":"                     $error. Creating new uuids..\"","counters":[]},{"line":"                    ~metadata:","counters":[]},{"line":"                      [ (\"path\", `String epoch_ledger_uuids_location)","counters":[]},{"line":"                      ; (\"error\", `String str)","counters":[]},{"line":"                      ] ;","counters":[]},{"line":"                  create_new_uuids ()","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"            in","counters":[]},{"line":"            (*If the genesis hash matches and both the files are present. If only one of them is present then it could be stale data and might cause the node to never be able to bootstrap*)","counters":[]},{"line":"            if","counters":[]},{"line":"              Mina_base.State_hash.equal epoch_ledger_uuids.genesis_state_hash","counters":[]},{"line":"                genesis_state_hash","counters":[]},{"line":"            then epoch_ledger_uuids","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"            else","counters":[]},{"line":"              (*Clean-up outdated epoch ledgers*)","counters":[]},{"line":"              let staking_ledger_location =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ledger_location epoch_ledger_uuids.staking","counters":[]},{"line":"              in","counters":[]},{"line":"              let next_ledger_location =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ledger_location epoch_ledger_uuids.next","counters":[]},{"line":"              in","counters":[]},{"line":"              [%log info]","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"                \"Cleaning up old epoch ledgers with genesis state $state_hash \\","counters":[]},{"line":"                 at locations $staking and $next\"","counters":[]},{"line":"                ~metadata:","counters":[]},{"line":"                  [ ( \"state_hash\"","counters":[]},{"line":"                    , Mina_base.State_hash.to_yojson","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                        epoch_ledger_uuids.genesis_state_hash )","counters":[]},{"line":"                  ; (\"staking\", `String staking_ledger_location)","counters":[]},{"line":"                  ; (\"next\", `String next_ledger_location)","counters":[]},{"line":"                  ] ;","counters":[]},{"line":"              File_system.rmrf staking_ledger_location ;","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              File_system.rmrf next_ledger_location ;","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              create_new_uuids () )","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"          else create_new_uuids ()","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"        in","counters":[]},{"line":"        let staking_epoch_ledger_location =","counters":[]},{"line":"          ledger_location epoch_ledger_uuids.staking","counters":[]},{"line":"        in","counters":[]},{"line":"        let staking_epoch_ledger =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          create_epoch_ledger ~location:staking_epoch_ledger_location","counters":[]},{"line":"            ~context:(module Context)","counters":[]},{"line":"            ~genesis_epoch_ledger:genesis_epoch_ledger_staking","counters":[]},{"line":"        in","counters":[]},{"line":"        let next_epoch_ledger_location =","counters":[]},{"line":"          ledger_location epoch_ledger_uuids.next","counters":[]},{"line":"        in","counters":[]},{"line":"        let next_epoch_ledger =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          create_epoch_ledger ~location:next_epoch_ledger_location","counters":[]},{"line":"            ~context:(module Context)","counters":[]},{"line":"            ~genesis_epoch_ledger:genesis_epoch_ledger_next","counters":[]},{"line":"        in","counters":[]},{"line":"        ref","counters":[]},{"line":"          { Data.staking_epoch_snapshot =","counters":[]},{"line":"              { Snapshot.ledger = staking_epoch_ledger","counters":[]},{"line":"              ; delegatee_table =","counters":[]},{"line":"                  Snapshot.Ledger_snapshot.compute_delegatee_table","counters":[{"col_start":65,"col_end":65,"count":0}]},{"line":"                    block_producer_pubkeys staking_epoch_ledger","counters":[]},{"line":"              }","counters":[]},{"line":"          ; next_epoch_snapshot =","counters":[]},{"line":"              { Snapshot.ledger = next_epoch_ledger","counters":[]},{"line":"              ; delegatee_table =","counters":[]},{"line":"                  Snapshot.Ledger_snapshot.compute_delegatee_table","counters":[{"col_start":65,"col_end":65,"count":0}]},{"line":"                    block_producer_pubkeys next_epoch_ledger","counters":[]},{"line":"              }","counters":[]},{"line":"          ; last_checked_slot_and_epoch =","counters":[]},{"line":"              make_last_checked_slot_and_epoch_table","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                (Public_key.Compressed.Table.create ())","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                block_producer_pubkeys ~default:(Epoch.zero, Slot.zero)","counters":[]},{"line":"          ; last_epoch_delegatee_table = None","counters":[]},{"line":"          ; epoch_ledger_uuids","counters":[]},{"line":"          ; epoch_ledger_location","counters":[]},{"line":"          }","counters":[]},{"line":"","counters":[]},{"line":"      let block_production_keys_swap ~(constants : Constants.t) t","counters":[]},{"line":"          block_production_pubkeys now =","counters":[]},{"line":"        let old : Data.t = !t in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let s { Snapshot.ledger; delegatee_table = _ } =","counters":[]},{"line":"          { Snapshot.ledger","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          ; delegatee_table =","counters":[]},{"line":"              Snapshot.Ledger_snapshot.compute_delegatee_table","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"                block_production_pubkeys ledger","counters":[]},{"line":"          }","counters":[]},{"line":"        in","counters":[]},{"line":"        t :=","counters":[]},{"line":"          { Data.staking_epoch_snapshot = s old.staking_epoch_snapshot","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"          ; next_epoch_snapshot =","counters":[]},{"line":"              s old.next_epoch_snapshot","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              (* assume these keys are different and therefore we haven't checked any","counters":[]},{"line":"               * slots or epochs *)","counters":[]},{"line":"          ; last_checked_slot_and_epoch =","counters":[]},{"line":"              make_last_checked_slot_and_epoch_table","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                !t.Data.last_checked_slot_and_epoch block_production_pubkeys","counters":[]},{"line":"                ~default:","counters":[]},{"line":"                  ((* TODO: Be smarter so that we don't have to look at the slot before again *)","counters":[]},{"line":"                   let epoch, slot =","counters":[]},{"line":"                     Epoch_and_slot.of_time_exn now ~constants","counters":[]},{"line":"                   in","counters":[]},{"line":"                   ( epoch","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"                   , UInt32.(","counters":[]},{"line":"                       if compare slot zero > 0 then sub slot one else slot) )","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":53,"col_end":53,"count":0},{"col_start":55,"col_end":55,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"                  )","counters":[]},{"line":"          ; last_epoch_delegatee_table = None","counters":[]},{"line":"          ; epoch_ledger_uuids = old.epoch_ledger_uuids","counters":[]},{"line":"          ; epoch_ledger_location = old.epoch_ledger_location","counters":[]},{"line":"          }","counters":[]},{"line":"","counters":[]},{"line":"      type snapshot_identifier = Staking_epoch_snapshot | Next_epoch_snapshot","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      [@@deriving to_yojson, equal]","counters":[]},{"line":"","counters":[]},{"line":"      let get_snapshot (t : t) id =","counters":[]},{"line":"        match id with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | Staking_epoch_snapshot ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            !t.staking_epoch_snapshot","counters":[]},{"line":"        | Next_epoch_snapshot ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            !t.next_epoch_snapshot","counters":[]},{"line":"","counters":[]},{"line":"      let set_snapshot (t : t) id v =","counters":[]},{"line":"        match id with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | Staking_epoch_snapshot ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            !t.staking_epoch_snapshot <- v","counters":[]},{"line":"        | Next_epoch_snapshot ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            !t.next_epoch_snapshot <- v","counters":[]},{"line":"","counters":[]},{"line":"      let reset_snapshot ~context:(module Context : CONTEXT) (t : t) id","counters":[]},{"line":"          ~sparse_ledger =","counters":[]},{"line":"        let open Context in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let open Or_error.Let_syntax in","counters":[]},{"line":"        let module Ledger_transfer =","counters":[]},{"line":"          Mina_ledger.Ledger_transfer.From_sparse_ledger (Mina_ledger.Ledger.Db) in","counters":[]},{"line":"        let delegatee_table =","counters":[]},{"line":"          compute_delegatee_table_sparse_ledger","counters":[]},{"line":"            (current_block_production_keys t)","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"            sparse_ledger","counters":[]},{"line":"        in","counters":[]},{"line":"        match id with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | Staking_epoch_snapshot ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let location = staking_epoch_ledger_location t in","counters":[]},{"line":"            Snapshot.Ledger_snapshot.remove !t.staking_epoch_snapshot.ledger","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              ~location ;","counters":[]},{"line":"            let ledger =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Mina_ledger.Ledger.Db.create ~directory_name:location","counters":[]},{"line":"                ~depth:constraint_constants.ledger_depth ()","counters":[]},{"line":"            in","counters":[]},{"line":"            let%map (_ : Mina_ledger.Ledger.Db.t) =","counters":[]},{"line":"              Ledger_transfer.transfer_accounts ~src:sparse_ledger ~dest:ledger","counters":[]},{"line":"            in","counters":[]},{"line":"            !t.staking_epoch_snapshot <-","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              { delegatee_table","counters":[]},{"line":"              ; ledger = Snapshot.Ledger_snapshot.Ledger_db ledger","counters":[]},{"line":"              }","counters":[]},{"line":"        | Next_epoch_snapshot ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let location = next_epoch_ledger_location t in","counters":[]},{"line":"            Snapshot.Ledger_snapshot.remove !t.next_epoch_snapshot.ledger","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              ~location ;","counters":[]},{"line":"            let ledger =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Mina_ledger.Ledger.Db.create ~directory_name:location","counters":[]},{"line":"                ~depth:constraint_constants.ledger_depth ()","counters":[]},{"line":"            in","counters":[]},{"line":"            let%map (_ : Mina_ledger.Ledger.Db.t) =","counters":[]},{"line":"              Ledger_transfer.transfer_accounts ~src:sparse_ledger ~dest:ledger","counters":[]},{"line":"            in","counters":[]},{"line":"            !t.next_epoch_snapshot <-","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              { delegatee_table","counters":[]},{"line":"              ; ledger = Snapshot.Ledger_snapshot.Ledger_db ledger","counters":[]},{"line":"              }","counters":[]},{"line":"","counters":[]},{"line":"      let next_epoch_ledger (t : t) =","counters":[]},{"line":"        Snapshot.ledger @@ get_snapshot t Next_epoch_snapshot","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"","counters":[]},{"line":"      let staking_epoch_ledger (t : t) =","counters":[]},{"line":"        Snapshot.ledger @@ get_snapshot t Staking_epoch_snapshot","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"","counters":[]},{"line":"      let _seen_slot (t : t) epoch slot =","counters":[]},{"line":"        let module Table = Public_key.Compressed.Table in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let unseens =","counters":[]},{"line":"          Table.to_alist !t.last_checked_slot_and_epoch","counters":[]},{"line":"          |> List.filter_map ~f:(fun (pk, last_checked_epoch_and_slot) ->","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"                 let i =","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                   Tuple2.compare ~cmp1:Epoch.compare ~cmp2:Slot.compare","counters":[]},{"line":"                     last_checked_epoch_and_slot (epoch, slot)","counters":[]},{"line":"                 in","counters":[]},{"line":"                 if i > 0 then None","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"                 else if i = 0 then","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                   (*vrf evaluation was stopped at this point because it was either the end of the epoch or the key won this slot; re-check this slot when staking keys are reset so that we don't skip producing block. This will not occur in the normal flow because [slot] will be greater than the last-checked-slot*)","counters":[]},{"line":"                   Some pk","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"                 else (","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                   Table.set !t.last_checked_slot_and_epoch ~key:pk","counters":[]},{"line":"                     ~data:(epoch, slot) ;","counters":[]},{"line":"                   Some pk ) )","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"        in","counters":[]},{"line":"        match unseens with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | [] ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            `All_seen","counters":[]},{"line":"        | nel ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            `Unseen (Public_key.Compressed.Set.of_list nel)","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Epoch_ledger = struct","counters":[]},{"line":"      include Mina_base.Epoch_ledger","counters":[]},{"line":"","counters":[]},{"line":"      let genesis ~ledger =","counters":[]},{"line":"        { Poly.hash = genesis_ledger_hash ~ledger","counters":[{"col_start":8,"col_end":8,"count":8}]},{"line":"        ; total_currency = genesis_ledger_total_currency ~ledger","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"      let graphql_type () : ('ctx, Value.t option) Graphql_async.Schema.typ =","counters":[]},{"line":"        let open Graphql_async in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let open Schema in","counters":[]},{"line":"        obj \"epochLedger\" ~fields:(fun _ ->","counters":[]},{"line":"            [ field \"hash\"","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"                ~typ:","counters":[]},{"line":"                  (non_null @@ Mina_base_unix.Graphql_scalars.LedgerHash.typ ())","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":75,"col_end":75,"count":0}]},{"line":"                ~args:Arg.[]","counters":[]},{"line":"                ~resolve:(fun _ { Poly.hash; _ } -> hash)","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"            ; field \"totalCurrency\"","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                ~typ:(non_null @@ Currency_unix.Graphql_scalars.Amount.typ ())","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":73,"col_end":73,"count":0}]},{"line":"                ~args:Arg.[]","counters":[]},{"line":"                ~resolve:(fun _ { Poly.total_currency; _ } -> total_currency)","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"            ] )","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Vrf = struct","counters":[]},{"line":"      include Consensus_vrf","counters":[]},{"line":"      module T = Integrated","counters":[]},{"line":"","counters":[]},{"line":"      type _ Snarky_backendless.Request.t +=","counters":[]},{"line":"        | Winner_address :","counters":[]},{"line":"            Mina_base.Account.Index.t Snarky_backendless.Request.t","counters":[]},{"line":"        | Winner_pk : Public_key.Compressed.t Snarky_backendless.Request.t","counters":[]},{"line":"        | Coinbase_receiver_pk :","counters":[]},{"line":"            Public_key.Compressed.t Snarky_backendless.Request.t","counters":[]},{"line":"        | Producer_private_key : Scalar.value Snarky_backendless.Request.t","counters":[]},{"line":"        | Producer_public_key : Public_key.t Snarky_backendless.Request.t","counters":[]},{"line":"","counters":[]},{"line":"      let%snarkydef.Snark_params.Tick get_vrf_evaluation","counters":[]},{"line":"          ~(constraint_constants : Genesis_constants.Constraint_constants.t)","counters":[]},{"line":"          shifted ~block_stake_winner ~block_creator ~ledger ~message =","counters":[]},{"line":"        let open Mina_base in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let open Snark_params.Tick in","counters":[]},{"line":"        let%bind private_key =","counters":[]},{"line":"          request_witness Scalar.typ (As_prover.return Producer_private_key)","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"        in","counters":[]},{"line":"        let staker_addr = message.Message.delegator in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let%bind account =","counters":[]},{"line":"          with_label __LOC__ (fun () ->","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"              Frozen_ledger_hash.get ~depth:constraint_constants.ledger_depth","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ledger staker_addr )","counters":[]},{"line":"        in","counters":[]},{"line":"        let%bind () =","counters":[]},{"line":"          [%with_label_ \"Account is for the default token\"] (fun () ->","counters":[{"col_start":57,"col_end":57,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"              make_checked (fun () ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                  Token_id.(","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    Checked.Assert.equal account.token_id","counters":[]},{"line":"                      (Checked.constant default)) ) )","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"        in","counters":[]},{"line":"        let%bind () =","counters":[]},{"line":"          [%with_label_ \"Block stake winner matches account pk\"] (fun () ->","counters":[{"col_start":62,"col_end":62,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"              Public_key.Compressed.Checked.Assert.equal block_stake_winner","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                account.public_key )","counters":[]},{"line":"        in","counters":[]},{"line":"        let%bind () =","counters":[]},{"line":"          [%with_label_ \"Block creator matches delegate pk\"] (fun () ->","counters":[{"col_start":58,"col_end":58,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"              Public_key.Compressed.Checked.Assert.equal block_creator","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                account.delegate )","counters":[]},{"line":"        in","counters":[]},{"line":"        let%bind delegate =","counters":[]},{"line":"          [%with_label_ \"Decompress delegate pk\"] (fun () ->","counters":[{"col_start":47,"col_end":47,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"              Public_key.decompress_var account.delegate )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"        in","counters":[]},{"line":"        let%map evaluation =","counters":[]},{"line":"          with_label __LOC__ (fun () ->","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"              T.Checked.eval_and_check_public_key shifted ~private_key","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ~public_key:delegate message )","counters":[]},{"line":"        in","counters":[]},{"line":"        (evaluation, account)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      module Checked = struct","counters":[]},{"line":"        let%snarkydef.Tick check","counters":[]},{"line":"            ~(constraint_constants : Genesis_constants.Constraint_constants.t)","counters":[]},{"line":"            shifted ~(epoch_ledger : Epoch_ledger.var) ~block_stake_winner","counters":[]},{"line":"            ~block_creator ~global_slot ~seed =","counters":[]},{"line":"          let open Snark_params.Tick in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let%bind winner_addr =","counters":[]},{"line":"            request_witness","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"              (Mina_base.Account.Index.Unpacked.typ","counters":[]},{"line":"                 ~ledger_depth:constraint_constants.ledger_depth )","counters":[]},{"line":"              (As_prover.return Winner_address)","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%bind result, winner_account =","counters":[]},{"line":"            get_vrf_evaluation ~constraint_constants shifted","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"              ~ledger:epoch_ledger.hash ~block_stake_winner ~block_creator","counters":[]},{"line":"              ~message:{ Message.global_slot; seed; delegator = winner_addr }","counters":[]},{"line":"          in","counters":[]},{"line":"          let my_stake = winner_account.balance in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let%bind truncated_result = Output.Checked.truncate result in","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"          let%map satisifed =","counters":[]},{"line":"            Threshold.Checked.is_satisfied ~my_stake","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"              ~total_stake:epoch_ledger.total_currency truncated_result","counters":[]},{"line":"          in","counters":[]},{"line":"          (satisifed, result, truncated_result, winner_account)","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      let eval = T.eval","counters":[]},{"line":"","counters":[]},{"line":"      module Precomputed = struct","counters":[]},{"line":"        let keypairs = Lazy.force Key_gen.Sample_keypairs.keypairs","counters":[{"col_start":32,"col_end":32,"count":1}]},{"line":"","counters":[]},{"line":"        let genesis_winner = keypairs.(0)","counters":[]},{"line":"","counters":[]},{"line":"        let genesis_stake_proof :","counters":[]},{"line":"            genesis_epoch_ledger:Mina_ledger.Ledger.t Lazy.t -> Stake_proof.t =","counters":[]},{"line":"         fun ~genesis_epoch_ledger ->","counters":[]},{"line":"          let pk, sk = genesis_winner in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let dummy_sparse_ledger =","counters":[]},{"line":"            Mina_ledger.Sparse_ledger.of_ledger_subset_exn","counters":[]},{"line":"              (Lazy.force genesis_epoch_ledger)","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"              [ Mina_base.(Account_id.create pk Token_id.default) ]","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"          in","counters":[]},{"line":"          { delegator = 0","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          ; delegator_pk = pk","counters":[]},{"line":"          ; coinbase_receiver_pk = pk","counters":[]},{"line":"          ; ledger = dummy_sparse_ledger","counters":[]},{"line":"          ; producer_private_key = sk","counters":[]},{"line":"          ; producer_public_key = Public_key.decompress_exn pk","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"          }","counters":[]},{"line":"","counters":[]},{"line":"        let handler :","counters":[]},{"line":"               constraint_constants:Genesis_constants.Constraint_constants.t","counters":[]},{"line":"            -> genesis_epoch_ledger:Mina_ledger.Ledger.t Lazy.t","counters":[]},{"line":"            -> Snark_params.Tick.Handler.t =","counters":[]},{"line":"         fun ~constraint_constants ~genesis_epoch_ledger ->","counters":[]},{"line":"          let pk, sk = genesis_winner in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let dummy_sparse_ledger =","counters":[]},{"line":"            Mina_ledger.Sparse_ledger.of_ledger_subset_exn","counters":[]},{"line":"              (Lazy.force genesis_epoch_ledger)","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"              [ Mina_base.(Account_id.create pk Token_id.default) ]","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"          in","counters":[]},{"line":"          let empty_pending_coinbase =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Mina_base.Pending_coinbase.create","counters":[]},{"line":"              ~depth:constraint_constants.pending_coinbase_depth ()","counters":[]},{"line":"            |> Or_error.ok_exn","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"          in","counters":[]},{"line":"          let ledger_handler =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            unstage (Mina_ledger.Sparse_ledger.handler dummy_sparse_ledger)","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"          in","counters":[]},{"line":"          let pending_coinbase_handler =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            unstage","counters":[]},{"line":"              (Mina_base.Pending_coinbase.handler","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"                 ~depth:constraint_constants.pending_coinbase_depth","counters":[]},{"line":"                 empty_pending_coinbase ~is_new_stack:true )","counters":[]},{"line":"          in","counters":[]},{"line":"          let handlers =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Snarky_backendless.Request.Handler.(","counters":[]},{"line":"              push","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                (push fail (create_single pending_coinbase_handler))","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"                (create_single ledger_handler))","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"          in","counters":[]},{"line":"          fun (With { request; respond }) ->","counters":[]},{"line":"            match request with","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            | Winner_address ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                respond (Provide 0)","counters":[]},{"line":"            | Winner_pk ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                respond (Provide pk)","counters":[]},{"line":"            | Coinbase_receiver_pk ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                respond (Provide pk)","counters":[]},{"line":"            | Producer_private_key ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                respond (Provide sk)","counters":[]},{"line":"            | Producer_public_key ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                respond (Provide (Public_key.decompress_exn pk))","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"            | _ ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                respond","counters":[]},{"line":"                  (Provide","counters":[]},{"line":"                     (Snarky_backendless.Request.Handler.run handlers","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"                        [ \"Ledger Handler\"; \"Pending Coinbase Handler\" ]","counters":[]},{"line":"                        request ) )","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      let check ~context:(module Context : CONTEXT) ~global_slot ~seed","counters":[]},{"line":"          ~producer_private_key ~producer_public_key ~total_stake","counters":[]},{"line":"          ~(get_delegators :","counters":[]},{"line":"                Public_key.Compressed.t","counters":[]},{"line":"             -> Mina_base.Account.t Mina_base.Account.Index.Table.t option ) =","counters":[]},{"line":"        let open Context in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let open Message in","counters":[]},{"line":"        let open Interruptible.Let_syntax in","counters":[]},{"line":"        let delegators =","counters":[]},{"line":"          get_delegators producer_public_key","counters":[]},{"line":"          |> Option.value_map ~f:Hashtbl.to_alist ~default:[]","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"        in","counters":[]},{"line":"        let rec go acc = function","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          | [] ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Interruptible.return acc","counters":[]},{"line":"          | (delegator, (account : Mina_base.Account.t)) :: delegators ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let%bind () = Interruptible.return () in","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"              let vrf_result =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                T.eval ~constraint_constants ~private_key:producer_private_key","counters":[]},{"line":"                  { global_slot; seed; delegator }","counters":[]},{"line":"              in","counters":[]},{"line":"              let truncated_vrf_result = Output.truncate vrf_result in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              [%log debug]","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"                \"VRF result for delegator: $delegator, balance: $balance, \\","counters":[]},{"line":"                 amount: $amount, result: $result\"","counters":[]},{"line":"                ~metadata:","counters":[]},{"line":"                  [ ( \"delegator\"","counters":[]},{"line":"                    , `Int (Mina_base.Account.Index.to_int delegator) )","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"                  ; ( \"delegator_pk\"","counters":[]},{"line":"                    , Public_key.Compressed.to_yojson account.public_key )","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"                  ; (\"balance\", `Int (Balance.to_int account.balance))","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                  ; (\"amount\", `Int (Amount.to_int total_stake))","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"                  ; ( \"result\"","counters":[]},{"line":"                    , `String","counters":[]},{"line":"                        (* use sexp representation; int might be too small *)","counters":[]},{"line":"                        ( Fold.string_bits truncated_vrf_result","counters":[]},{"line":"                        |> Bignum_bigint.of_bit_fold_lsb","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                        |> Bignum_bigint.sexp_of_t |> Sexp.to_string ) )","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":54,"col_end":54,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"                  ] ;","counters":[]},{"line":"              Mina_metrics.Counter.inc_one","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Mina_metrics.Consensus.vrf_evaluations ;","counters":[]},{"line":"              if","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Threshold.is_satisfied ~my_stake:account.balance ~total_stake","counters":[]},{"line":"                  truncated_vrf_result","counters":[]},{"line":"              then","counters":[]},{"line":"                let string_of_blake2 =","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Blake2.(Fn.compose to_raw_string digest_string)","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                in","counters":[]},{"line":"                let vrf_eval = string_of_blake2 truncated_vrf_result in","counters":[]},{"line":"                let this_vrf () =","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  go","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    (Some","counters":[]},{"line":"                       ( `Vrf_eval vrf_eval","counters":[]},{"line":"                       , `Vrf_output vrf_result","counters":[]},{"line":"                       , `Delegator (account.public_key, delegator) ) )","counters":[]},{"line":"                    delegators","counters":[]},{"line":"                in","counters":[]},{"line":"                match acc with","counters":[]},{"line":"                | Some (`Vrf_eval prev_best_vrf_eval, _, _) ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    if String.compare prev_best_vrf_eval vrf_eval < 0 then","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"                      this_vrf ()","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                    else go acc delegators","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                | None ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    this_vrf ()","counters":[]},{"line":"              else go acc delegators","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"        in","counters":[]},{"line":"        go None delegators","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Optional_state_hash = struct","counters":[]},{"line":"      [%%versioned","counters":[]},{"line":"      module Stable = struct","counters":[]},{"line":"        module V1 = struct","counters":[]},{"line":"          type t = Mina_base.State_hash.Stable.V1.t option","counters":[{"col_start":10,"col_end":10,"count":2},{"col_start":15,"col_end":15,"count":1},{"col_start":19,"col_end":19,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"          [@@deriving sexp, compare, hash, to_yojson]","counters":[{"col_start":52,"col_end":52,"count":5}]},{"line":"","counters":[]},{"line":"          let to_latest = Fn.id","counters":[]},{"line":"        end","counters":[]},{"line":"      end]","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Epoch_data = struct","counters":[]},{"line":"      include Mina_base.Epoch_data","counters":[]},{"line":"","counters":[]},{"line":"      module Make (Lock_checkpoint : sig","counters":[]},{"line":"        type t [@@deriving sexp, compare, hash, to_yojson]","counters":[]},{"line":"","counters":[]},{"line":"        val typ : (Mina_base.State_hash.var, t) Typ.t","counters":[]},{"line":"","counters":[]},{"line":"        type graphql_type","counters":[]},{"line":"","counters":[]},{"line":"        val graphql_type : unit -> ('ctx, graphql_type) Graphql_async.Schema.typ","counters":[]},{"line":"","counters":[]},{"line":"        val resolve : t -> graphql_type","counters":[]},{"line":"","counters":[]},{"line":"        val to_input :","counters":[]},{"line":"          t -> Snark_params.Tick.Field.t Random_oracle.Input.Chunked.t","counters":[]},{"line":"","counters":[]},{"line":"        val null : t","counters":[]},{"line":"      end) =","counters":[]},{"line":"      struct","counters":[]},{"line":"        open Snark_params","counters":[]},{"line":"","counters":[]},{"line":"        module Value = struct","counters":[]},{"line":"          type t =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ( Epoch_ledger.Value.t","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":14,"col_end":14,"count":0}]},{"line":"            , Epoch_seed.t","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"            , Mina_base.State_hash.t","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"            , Lock_checkpoint.t","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"            , Length.t )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"            Poly.t","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          [@@deriving sexp, compare, hash, to_yojson]","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"        end","counters":[]},{"line":"","counters":[]},{"line":"        let typ : (var, Value.t) Typ.t =","counters":[]},{"line":"          Typ.of_hlistable","counters":[{"col_start":25,"col_end":25,"count":2}]},{"line":"            [ Epoch_ledger.typ","counters":[]},{"line":"            ; Epoch_seed.typ","counters":[]},{"line":"            ; Mina_base.State_hash.typ","counters":[]},{"line":"            ; Lock_checkpoint.typ","counters":[]},{"line":"            ; Length.typ","counters":[]},{"line":"            ]","counters":[]},{"line":"            ~var_to_hlist:Poly.to_hlist ~var_of_hlist:Poly.of_hlist","counters":[]},{"line":"            ~value_to_hlist:Poly.to_hlist ~value_of_hlist:Poly.of_hlist","counters":[]},{"line":"","counters":[]},{"line":"        let graphql_type name =","counters":[]},{"line":"          let open Graphql_async in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let open Schema in","counters":[]},{"line":"          obj name ~fields:(fun _ ->","counters":[]},{"line":"              [ field \"ledger\"","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":20,"col_end":20,"count":0}]},{"line":"                  ~typ:(non_null @@ Epoch_ledger.graphql_type ())","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"                  ~args:Arg.[]","counters":[]},{"line":"                  ~resolve:(fun _ { Poly.ledger; _ } -> ledger)","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"              ; field \"seed\"","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                  ~typ:","counters":[]},{"line":"                    (non_null @@ Mina_base_unix.Graphql_scalars.EpochSeed.typ ())","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":76,"col_end":76,"count":0}]},{"line":"                  ~args:Arg.[]","counters":[]},{"line":"                  ~resolve:(fun _ { Poly.seed; _ } -> seed)","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"              ; field \"startCheckpoint\"","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                  ~typ:","counters":[]},{"line":"                    (non_null @@ Mina_base_unix.Graphql_scalars.StateHash.typ ())","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":76,"col_end":76,"count":0}]},{"line":"                  ~args:Arg.[]","counters":[]},{"line":"                  ~resolve:(fun _ { Poly.start_checkpoint; _ } ->","counters":[]},{"line":"                    start_checkpoint )","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"              ; field \"lockCheckpoint\"","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                  ~typ:(Lock_checkpoint.graphql_type ())","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                  ~args:Arg.[]","counters":[]},{"line":"                  ~resolve:(fun _ { Poly.lock_checkpoint; _ } ->","counters":[]},{"line":"                    Lock_checkpoint.resolve lock_checkpoint )","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"              ; field \"epochLength\"","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                  ~typ:","counters":[]},{"line":"                    (non_null @@ Mina_numbers_unix.Graphql_scalars.Length.typ ())","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":76,"col_end":76,"count":0}]},{"line":"                  ~args:Arg.[]","counters":[]},{"line":"                  ~resolve:(fun _ { Poly.epoch_length; _ } -> epoch_length)","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"              ] )","counters":[]},{"line":"","counters":[]},{"line":"        let to_input","counters":[]},{"line":"            ({ ledger; seed; start_checkpoint; lock_checkpoint; epoch_length } :","counters":[]},{"line":"              Value.t ) =","counters":[]},{"line":"          let open Random_oracle.Input.Chunked in","counters":[{"col_start":10,"col_end":10,"count":10}]},{"line":"          List.reduce_exn ~f:append","counters":[]},{"line":"            [ field (seed :> Tick.Field.t)","counters":[{"col_start":18,"col_end":18,"count":10}]},{"line":"            ; field (start_checkpoint :> Tick.Field.t)","counters":[{"col_start":18,"col_end":18,"count":10}]},{"line":"            ; Length.to_input epoch_length","counters":[{"col_start":28,"col_end":28,"count":10}]},{"line":"            ; Epoch_ledger.to_input ledger","counters":[{"col_start":34,"col_end":34,"count":10}]},{"line":"            ; Lock_checkpoint.to_input lock_checkpoint","counters":[{"col_start":37,"col_end":37,"count":10}]},{"line":"            ]","counters":[]},{"line":"","counters":[]},{"line":"        let var_to_input","counters":[]},{"line":"            ({ ledger; seed; start_checkpoint; lock_checkpoint; epoch_length } :","counters":[]},{"line":"              var ) =","counters":[]},{"line":"          let open Random_oracle.Input.Chunked in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          List.reduce_exn ~f:append","counters":[]},{"line":"            [ field (Epoch_seed.var_to_hash_packed seed)","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"            ; field (Mina_base.State_hash.var_to_hash_packed start_checkpoint)","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"            ; Length.Checked.to_input epoch_length","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"            ; Epoch_ledger.var_to_input ledger","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"            ; field (Mina_base.State_hash.var_to_hash_packed lock_checkpoint)","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"            ]","counters":[]},{"line":"","counters":[]},{"line":"        let genesis ~(genesis_epoch_data : Genesis_epoch_data.Data.t) =","counters":[]},{"line":"          { Poly.ledger = Epoch_ledger.genesis ~ledger:genesis_epoch_data.ledger","counters":[{"col_start":10,"col_end":10,"count":8}]},{"line":"          ; seed = genesis_epoch_data.seed","counters":[]},{"line":"          ; start_checkpoint = Mina_base.State_hash.(of_hash zero)","counters":[{"col_start":59,"col_end":59,"count":8}]},{"line":"          ; lock_checkpoint = Lock_checkpoint.null","counters":[]},{"line":"          ; epoch_length = Length.of_int 1","counters":[{"col_start":39,"col_end":39,"count":8}]},{"line":"          }","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      module T = struct","counters":[]},{"line":"        include Mina_base.State_hash","counters":[]},{"line":"","counters":[]},{"line":"        let to_input (t : t) =","counters":[]},{"line":"          Random_oracle.Input.Chunked.field (t :> Tick.Field.t)","counters":[{"col_start":10,"col_end":10,"count":10}]},{"line":"","counters":[]},{"line":"        let null = Mina_base.State_hash.(of_hash zero)","counters":[{"col_start":47,"col_end":47,"count":1}]},{"line":"","counters":[]},{"line":"        open Graphql_async","counters":[]},{"line":"        open Schema","counters":[]},{"line":"","counters":[]},{"line":"        type graphql_type = string","counters":[]},{"line":"","counters":[]},{"line":"        let graphql_type () = non_null string","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"","counters":[]},{"line":"        let resolve = to_base58_check","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      module Staking = Make (T)","counters":[]},{"line":"      module Next = Make (T)","counters":[]},{"line":"","counters":[]},{"line":"      (* stable-versioned types are disallowed as functor application results","counters":[]},{"line":"         we create them outside the results, and make sure they match the corresponding non-versioned types","counters":[]},{"line":"      *)","counters":[]},{"line":"","counters":[]},{"line":"      module Staking_value_versioned = struct","counters":[]},{"line":"        module Value = struct","counters":[]},{"line":"          module Lock_checkpoint = Mina_base.State_hash","counters":[]},{"line":"","counters":[]},{"line":"          [%%versioned","counters":[]},{"line":"          module Stable = struct","counters":[]},{"line":"            module V1 = struct","counters":[]},{"line":"              type t =","counters":[{"col_start":14,"col_end":14,"count":2},{"col_start":19,"col_end":19,"count":1}]},{"line":"                ( Epoch_ledger.Value.Stable.V1.t","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"                , Epoch_seed.Stable.V1.t","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                , Mina_base.State_hash.Stable.V1.t","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                , Lock_checkpoint.Stable.V1.t","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                , Length.Stable.V1.t )","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                Poly.Stable.V1.t","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"              [@@deriving sexp, compare, equal, hash, yojson]","counters":[{"col_start":60,"col_end":60,"count":5}]},{"line":"","counters":[]},{"line":"              let to_latest = Fn.id","counters":[]},{"line":"            end","counters":[]},{"line":"          end]","counters":[]},{"line":"","counters":[]},{"line":"          type _unused = unit constraint Stable.Latest.t = Staking.Value.t","counters":[]},{"line":"        end","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      module Next_value_versioned = struct","counters":[]},{"line":"        module Value = struct","counters":[]},{"line":"          module Lock_checkpoint = Mina_base.State_hash","counters":[]},{"line":"","counters":[]},{"line":"          [%%versioned","counters":[]},{"line":"          module Stable = struct","counters":[]},{"line":"            module V1 = struct","counters":[]},{"line":"              type t =","counters":[{"col_start":14,"col_end":14,"count":2},{"col_start":19,"col_end":19,"count":1}]},{"line":"                ( Epoch_ledger.Value.Stable.V1.t","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"                , Epoch_seed.Stable.V1.t","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                , Mina_base.State_hash.Stable.V1.t","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                , Lock_checkpoint.Stable.V1.t","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                , Length.Stable.V1.t )","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                Poly.Stable.V1.t","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"              [@@deriving sexp, compare, equal, hash, yojson]","counters":[{"col_start":60,"col_end":60,"count":5}]},{"line":"","counters":[]},{"line":"              let to_latest = Fn.id","counters":[]},{"line":"            end","counters":[]},{"line":"          end]","counters":[]},{"line":"","counters":[]},{"line":"          type _unused = unit constraint Stable.Latest.t = Next.Value.t","counters":[]},{"line":"        end","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      let next_to_staking (next : Next.Value.t) : Staking.Value.t = next","counters":[{"col_start":68,"col_end":68,"count":0}]},{"line":"","counters":[]},{"line":"      let update_pair","counters":[]},{"line":"          ((staking_data, next_data) : Staking.Value.t * Next.Value.t)","counters":[]},{"line":"          epoch_count ~prev_epoch ~next_epoch ~next_slot","counters":[]},{"line":"          ~prev_protocol_state_hash ~producer_vrf_result ~snarked_ledger_hash","counters":[]},{"line":"          ~genesis_ledger_hash ~total_currency ~(constants : Constants.t) =","counters":[]},{"line":"        let next_staking_ledger =","counters":[{"col_start":8,"col_end":8,"count":2}]},{"line":"          (*If snarked ledger hash is still the genesis ledger hash then the epoch ledger should continue to be `next_data.ledger`. This is because the epoch ledgers at genesis can be different from the genesis ledger*)","counters":[]},{"line":"          if","counters":[]},{"line":"            Mina_base.Frozen_ledger_hash.equal snarked_ledger_hash","counters":[]},{"line":"              genesis_ledger_hash","counters":[]},{"line":"          then next_data.ledger","counters":[{"col_start":15,"col_end":15,"count":2}]},{"line":"          else { Epoch_ledger.Poly.hash = snarked_ledger_hash; total_currency }","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"        in","counters":[]},{"line":"        let staking_data', next_data', epoch_count' =","counters":[]},{"line":"          if Epoch.(next_epoch > prev_epoch) then","counters":[]},{"line":"            ( next_to_staking next_data","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"            , { Poly.seed = next_data.seed","counters":[]},{"line":"              ; ledger = next_staking_ledger","counters":[]},{"line":"              ; start_checkpoint =","counters":[]},{"line":"                  prev_protocol_state_hash","counters":[]},{"line":"                  (* TODO: We need to make sure issue #2328 is properly addressed. *)","counters":[]},{"line":"              ; lock_checkpoint = Mina_base.State_hash.(of_hash zero)","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"              ; epoch_length = Length.of_int 1","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"              }","counters":[]},{"line":"            , Length.succ epoch_count )","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"          else (","counters":[{"col_start":15,"col_end":15,"count":2}]},{"line":"            assert (Epoch.equal next_epoch prev_epoch) ;","counters":[{"col_start":19,"col_end":19,"count":2},{"col_start":30,"col_end":30,"count":2}]},{"line":"            ( staking_data","counters":[]},{"line":"            , Poly.","counters":[]},{"line":"                { next_data with","counters":[]},{"line":"                  epoch_length = Length.succ next_data.epoch_length","counters":[{"col_start":43,"col_end":43,"count":2}]},{"line":"                }","counters":[]},{"line":"            , epoch_count ) )","counters":[]},{"line":"        in","counters":[]},{"line":"        let curr_seed, curr_lock_checkpoint =","counters":[]},{"line":"          if Slot.in_seed_update_range next_slot ~constants then","counters":[]},{"line":"            ( Epoch_seed.update next_data'.seed producer_vrf_result","counters":[{"col_start":12,"col_end":12,"count":2},{"col_start":30,"col_end":30,"count":2}]},{"line":"            , prev_protocol_state_hash )","counters":[]},{"line":"          else (next_data'.seed, next_data'.lock_checkpoint)","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"        in","counters":[]},{"line":"        let next_data'' =","counters":[]},{"line":"          Poly.","counters":[]},{"line":"            { next_data' with","counters":[]},{"line":"              seed = curr_seed","counters":[]},{"line":"            ; lock_checkpoint = curr_lock_checkpoint","counters":[]},{"line":"            }","counters":[]},{"line":"        in","counters":[]},{"line":"        (staking_data', next_data'', epoch_count')","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Consensus_transition = struct","counters":[]},{"line":"      include Mina_numbers.Global_slot","counters":[]},{"line":"      module Value = Mina_numbers.Global_slot","counters":[]},{"line":"","counters":[]},{"line":"      type var = Checked.t","counters":[]},{"line":"","counters":[]},{"line":"      let genesis = zero","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Consensus_time = struct","counters":[]},{"line":"      include Global_slot","counters":[]},{"line":"","counters":[]},{"line":"      let to_string_hum = time_hum","counters":[]},{"line":"","counters":[]},{"line":"      (* externally, we are only interested in when the slot starts *)","counters":[]},{"line":"      let to_time ~(constants : Constants.t) t = start_time ~constants t","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"","counters":[]},{"line":"      (* create dummy block to split map on *)","counters":[]},{"line":"      let get_old ~constants (t : Global_slot.t) : Global_slot.t =","counters":[]},{"line":"        let ( `Acceptable_network_delay _","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            , `Gc_width _","counters":[]},{"line":"            , `Gc_width_epoch gc_width_epoch","counters":[]},{"line":"            , `Gc_width_slot gc_width_slot","counters":[]},{"line":"            , `Gc_interval _ ) =","counters":[]},{"line":"          Constants.gc_parameters constants","counters":[]},{"line":"        in","counters":[]},{"line":"        let gs = of_epoch_and_slot ~constants (gc_width_epoch, gc_width_slot) in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        if Global_slot.(t < gs) then","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (* block not beyond gc_width *)","counters":[]},{"line":"          Global_slot.zero ~constants","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        else","counters":[]},{"line":"          (* subtract epoch, slot components of gc_width *)","counters":[]},{"line":"          Global_slot.diff ~constants t (gc_width_epoch, gc_width_slot)","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"      let to_uint32 t = Global_slot.slot_number t","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"","counters":[]},{"line":"      let to_global_slot = slot_number","counters":[]},{"line":"","counters":[]},{"line":"      let of_global_slot ~(constants : Constants.t) slot =","counters":[]},{"line":"        of_slot_number ~constants slot","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    [%%if true]","counters":[]},{"line":"","counters":[]},{"line":"    module Min_window_density = struct","counters":[]},{"line":"      (* Three cases for updating the densities of sub-windows","counters":[]},{"line":"         - same sub-window, then add 1 to the sub-window densities","counters":[]},{"line":"         - passed a few sub_windows, but didn't skip a window, then","counters":[]},{"line":"         assign 0 to all the skipped sub-windows, then mark next sub-window density to be 1","counters":[]},{"line":"         - skipped more than a window, set every sub-window to be 0 and mark next sub-window density to be 1","counters":[]},{"line":"      *)","counters":[]},{"line":"","counters":[]},{"line":"      let update_min_window_density ~incr_window ~constants ~prev_global_slot","counters":[]},{"line":"          ~next_global_slot ~prev_sub_window_densities ~prev_min_window_density","counters":[]},{"line":"          =","counters":[]},{"line":"        (* This function takes the previous window (prev_sub_window_densities) and the next_global_slot","counters":[]},{"line":"           (e.g. the slot of the new block) and returns minimum window density and the new block's","counters":[]},{"line":"           window (i.e. the next window).","counters":[]},{"line":"","counters":[]},{"line":"           The current window is obtained by projecting the previous window to the next_global_slot","counters":[]},{"line":"           as described in the Mina consensus spec.","counters":[]},{"line":"","counters":[]},{"line":"           Next, we use the current window and prev_min_window_density to compute the minimum window density.","counters":[]},{"line":"","counters":[]},{"line":"           Finally, we update the current window to obtain the next window that accounts for the presenence","counters":[]},{"line":"           of the new block.  Note that we only increment the block's sub-window when the incr_window","counters":[]},{"line":"           parameter is true, which happens when creating a new block, but not when evaluating virtual","counters":[]},{"line":"           minimum window densities (a.k.a. the relative minimum window density) for the long-range fork rule.","counters":[]},{"line":"","counters":[]},{"line":"           In the following code, we deal with three different windows","counters":[]},{"line":"           * Previous window - the previous window","counters":[]},{"line":"           (prev_global_sub_window - sub_windows_per_window, prev_global_sub_window]","counters":[]},{"line":"","counters":[]},{"line":"           * Current window  - the projected window used to compute the minimum window density","counters":[]},{"line":"           [next_global_sub_window - sub_windows_per_window, next_global_sub_window)","counters":[]},{"line":"","counters":[]},{"line":"           * Next window     - the new (or virtual) block's window that is returned","counters":[]},{"line":"           (next_global_sub_window - sub_windows_per_window, next_global_sub_window]","counters":[]},{"line":"","counters":[]},{"line":"           All of these are derived from prev_sub_window_densities using ring-shifting and relative sub-window indexes.","counters":[]},{"line":"        *)","counters":[]},{"line":"        let prev_global_sub_window =","counters":[{"col_start":8,"col_end":8,"count":2}]},{"line":"          Global_sub_window.of_global_slot ~constants prev_global_slot","counters":[]},{"line":"        in","counters":[]},{"line":"        let next_global_sub_window =","counters":[{"col_start":8,"col_end":8,"count":2}]},{"line":"          Global_sub_window.of_global_slot ~constants next_global_slot","counters":[]},{"line":"        in","counters":[]},{"line":"","counters":[]},{"line":"        (*","counters":[]},{"line":"          Compute the relative sub-window indexes in [0, sub_windows_per_window) needed for ring-shifting","counters":[]},{"line":"         *)","counters":[]},{"line":"        let prev_relative_sub_window =","counters":[{"col_start":8,"col_end":8,"count":2}]},{"line":"          Global_sub_window.sub_window ~constants prev_global_sub_window","counters":[]},{"line":"        in","counters":[]},{"line":"        let next_relative_sub_window =","counters":[{"col_start":8,"col_end":8,"count":2}]},{"line":"          Global_sub_window.sub_window ~constants next_global_sub_window","counters":[]},{"line":"        in","counters":[]},{"line":"","counters":[]},{"line":"        let same_sub_window =","counters":[{"col_start":8,"col_end":8,"count":2}]},{"line":"          Global_sub_window.equal prev_global_sub_window next_global_sub_window","counters":[]},{"line":"        in","counters":[]},{"line":"","counters":[]},{"line":"        (* This function checks whether the current window overlaps with the previous window.","counters":[]},{"line":"         *   N.B. this requires the precondition that next_global_sub_window >= prev_global_sub_window","counters":[]},{"line":"         *        whenever update_min_window_density is called.","counters":[]},{"line":"         *)","counters":[]},{"line":"        let overlapping_window =","counters":[{"col_start":8,"col_end":8,"count":2}]},{"line":"          Global_sub_window.(","counters":[]},{"line":"            add prev_global_sub_window","counters":[{"col_start":14,"col_end":14,"count":2}]},{"line":"              (constant constants.sub_windows_per_window)","counters":[{"col_start":22,"col_end":22,"count":2}]},{"line":"            >= next_global_sub_window)","counters":[]},{"line":"        in","counters":[]},{"line":"","counters":[]},{"line":"        (* Compute the current window (equivalent to ring-shifting)","counters":[]},{"line":"           If we are not in the same sub-window and the previous window","counters":[]},{"line":"           and the current windows overlap, then we zero the densities","counters":[]},{"line":"           between, and not including, prev and next (relative).","counters":[]},{"line":"        *)","counters":[]},{"line":"        let current_sub_window_densities =","counters":[]},{"line":"          List.mapi prev_sub_window_densities ~f:(fun i density ->","counters":[]},{"line":"              let gt_prev_sub_window =","counters":[{"col_start":14,"col_end":14,"count":6}]},{"line":"                Sub_window.(of_int i > prev_relative_sub_window)","counters":[{"col_start":33,"col_end":33,"count":6}]},{"line":"              in","counters":[]},{"line":"              let lt_next_sub_window =","counters":[]},{"line":"                Sub_window.(of_int i < next_relative_sub_window)","counters":[{"col_start":33,"col_end":33,"count":6}]},{"line":"              in","counters":[]},{"line":"              let within_range =","counters":[]},{"line":"                if","counters":[]},{"line":"                  UInt32.compare prev_relative_sub_window","counters":[{"col_start":31,"col_end":31,"count":6}]},{"line":"                    next_relative_sub_window","counters":[]},{"line":"                  < 0","counters":[]},{"line":"                then gt_prev_sub_window && lt_next_sub_window","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"                else gt_prev_sub_window || lt_next_sub_window","counters":[{"col_start":21,"col_end":21,"count":6},{"col_start":38,"col_end":38,"count":4},{"col_start":60,"col_end":60,"count":0}]},{"line":"              in","counters":[]},{"line":"              if same_sub_window then density","counters":[{"col_start":38,"col_end":38,"count":6}]},{"line":"              else if overlapping_window && not within_range then density","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"              else Length.zero )","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"        in","counters":[]},{"line":"        let current_window_density =","counters":[{"col_start":8,"col_end":8,"count":2}]},{"line":"          List.fold current_sub_window_densities ~init:Length.zero ~f:Length.add","counters":[]},{"line":"        in","counters":[]},{"line":"","counters":[]},{"line":"        (* Compute minimum window density, taking into account the grace-period *)","counters":[]},{"line":"        let min_window_density =","counters":[{"col_start":8,"col_end":8,"count":2}]},{"line":"          if","counters":[]},{"line":"            same_sub_window","counters":[{"col_start":26,"col_end":26,"count":2}]},{"line":"            || UInt32.compare","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                 (Global_slot.slot_number next_global_slot)","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"                 constants.grace_period_end","counters":[]},{"line":"               < 0","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"          then prev_min_window_density","counters":[{"col_start":15,"col_end":15,"count":2}]},{"line":"          else Length.min current_window_density prev_min_window_density","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"        in","counters":[]},{"line":"","counters":[]},{"line":"        (* Compute the next window by mutating the current window *)","counters":[]},{"line":"        let next_sub_window_densities =","counters":[]},{"line":"          List.mapi current_sub_window_densities ~f:(fun i density ->","counters":[]},{"line":"              let is_next_sub_window =","counters":[{"col_start":14,"col_end":14,"count":6}]},{"line":"                Sub_window.(of_int i = next_relative_sub_window)","counters":[{"col_start":33,"col_end":33,"count":6}]},{"line":"              in","counters":[]},{"line":"              if is_next_sub_window then","counters":[]},{"line":"                let f = if incr_window then Length.succ else Fn.id in","counters":[{"col_start":16,"col_end":16,"count":2},{"col_start":44,"col_end":44,"count":2},{"col_start":61,"col_end":61,"count":0}]},{"line":"                if same_sub_window then f density else f Length.zero","counters":[{"col_start":40,"col_end":40,"count":2},{"col_start":55,"col_end":55,"count":0}]},{"line":"              else density )","counters":[{"col_start":19,"col_end":19,"count":4}]},{"line":"        in","counters":[]},{"line":"","counters":[]},{"line":"        (* Final result is the min window density and window for the new (or virtual) block *)","counters":[]},{"line":"        (min_window_density, next_sub_window_densities)","counters":[{"col_start":8,"col_end":8,"count":2}]},{"line":"","counters":[]},{"line":"      module Checked = struct","counters":[]},{"line":"        let%snarkydef.Tick update_min_window_density","counters":[]},{"line":"            ~(constants : Constants.var) ~prev_global_slot ~next_global_slot","counters":[]},{"line":"            ~prev_sub_window_densities ~prev_min_window_density =","counters":[]},{"line":"          (* Please see Min_window_density.update_min_window_density for documentation *)","counters":[]},{"line":"          let open Tick in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let open Tick.Checked.Let_syntax in","counters":[]},{"line":"          let%bind prev_global_sub_window =","counters":[]},{"line":"            Global_sub_window.Checked.of_global_slot ~constants prev_global_slot","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%bind next_global_sub_window =","counters":[]},{"line":"            Global_sub_window.Checked.of_global_slot ~constants next_global_slot","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%bind prev_relative_sub_window =","counters":[]},{"line":"            Global_sub_window.Checked.sub_window ~constants","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"              prev_global_sub_window","counters":[]},{"line":"          in","counters":[]},{"line":"          let%bind next_relative_sub_window =","counters":[]},{"line":"            Global_sub_window.Checked.sub_window ~constants","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"              next_global_sub_window","counters":[]},{"line":"          in","counters":[]},{"line":"          let%bind same_sub_window =","counters":[]},{"line":"            Global_sub_window.Checked.equal prev_global_sub_window","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"              next_global_sub_window","counters":[]},{"line":"          in","counters":[]},{"line":"          let%bind overlapping_window =","counters":[]},{"line":"            Global_sub_window.Checked.(","counters":[]},{"line":"              let%bind x =","counters":[]},{"line":"                add prev_global_sub_window constants.sub_windows_per_window","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"              in","counters":[]},{"line":"              x >= next_global_sub_window)","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"          in","counters":[]},{"line":"          let if_ cond ~then_ ~else_ =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let%bind cond = cond and then_ = then_ and else_ = else_ in","counters":[]},{"line":"            Length.Checked.if_ cond ~then_ ~else_","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%bind current_sub_window_densities =","counters":[]},{"line":"            Checked.List.mapi prev_sub_window_densities ~f:(fun i density ->","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                let%bind gt_prev_sub_window =","counters":[]},{"line":"                  Sub_window.Checked.(","counters":[]},{"line":"                    constant (UInt32.of_int i) > prev_relative_sub_window)","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"                in","counters":[]},{"line":"                let%bind lt_next_sub_window =","counters":[]},{"line":"                  Sub_window.Checked.(","counters":[]},{"line":"                    constant (UInt32.of_int i) < next_relative_sub_window)","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"                in","counters":[]},{"line":"                let%bind within_range =","counters":[]},{"line":"                  Sub_window.Checked.(","counters":[]},{"line":"                    let if_ cond ~then_ ~else_ =","counters":[]},{"line":"                      let%bind cond = cond","counters":[]},{"line":"                      and then_ = then_","counters":[]},{"line":"                      and else_ = else_ in","counters":[]},{"line":"                      Boolean.if_ cond ~then_ ~else_","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                    in","counters":[]},{"line":"                    if_","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                      (prev_relative_sub_window < next_relative_sub_window)","counters":[]},{"line":"                      ~then_:Boolean.(gt_prev_sub_window &&& lt_next_sub_window)","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"                      ~else_:Boolean.(gt_prev_sub_window ||| lt_next_sub_window))","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"                in","counters":[]},{"line":"                if_","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  (Checked.return same_sub_window)","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                  ~then_:(Checked.return density)","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"                  ~else_:","counters":[]},{"line":"                    (if_","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                       Boolean.(overlapping_window && not within_range)","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"                       ~then_:(Checked.return density)","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"                       ~else_:(Checked.return Length.Checked.zero) ) )","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%bind current_window_density =","counters":[]},{"line":"            Checked.List.fold current_sub_window_densities","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"              ~init:Length.Checked.zero ~f:Length.Checked.add","counters":[]},{"line":"          in","counters":[]},{"line":"          let%bind min_window_density =","counters":[]},{"line":"            let%bind in_grace_period =","counters":[]},{"line":"              Global_slot.Checked.( < ) next_global_slot","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"                (Global_slot.Checked.of_slot_number ~constants","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                   (Mina_numbers.Global_slot.Checked.Unsafe.of_field","counters":[{"col_start":67,"col_end":67,"count":0}]},{"line":"                      (Length.Checked.to_field constants.grace_period_end) ) )","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"            in","counters":[]},{"line":"            if_","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Boolean.(same_sub_window ||| in_grace_period)","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"              ~then_:(Checked.return prev_min_window_density)","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"              ~else_:","counters":[]},{"line":"                (Length.Checked.min current_window_density","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"                   prev_min_window_density )","counters":[]},{"line":"          in","counters":[]},{"line":"          let%bind next_sub_window_densities =","counters":[]},{"line":"            Checked.List.mapi current_sub_window_densities ~f:(fun i density ->","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                let%bind is_next_sub_window =","counters":[]},{"line":"                  Sub_window.Checked.(","counters":[]},{"line":"                    constant (UInt32.of_int i) = next_relative_sub_window)","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"                in","counters":[]},{"line":"                if_","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  (Checked.return is_next_sub_window)","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                  ~then_:","counters":[]},{"line":"                    (if_","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                       (Checked.return same_sub_window)","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                       ~then_:Length.Checked.(succ density)","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"                       ~else_:Length.Checked.(succ zero) )","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"                  ~else_:(Checked.return density) )","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"          in","counters":[]},{"line":"          return (min_window_density, next_sub_window_densities)","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      let%test_module \"Min window length tests\" =","counters":[]},{"line":"        ( module struct","counters":[]},{"line":"          (* This is the reference implementation, which is much more readable than","counters":[]},{"line":"             the actual implementation. The reason this one is not implemented is because","counters":[]},{"line":"             array-indexing is not supported in Snarky. We could use list-indexing, but it","counters":[]},{"line":"             takes O(n) instead of O(1).","counters":[]},{"line":"          *)","counters":[]},{"line":"","counters":[]},{"line":"          let update_min_window_density_reference_implementation ~constants","counters":[]},{"line":"              ~prev_global_slot ~next_global_slot ~prev_sub_window_densities","counters":[]},{"line":"              ~prev_min_window_density =","counters":[]},{"line":"            let prev_global_sub_window =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Global_sub_window.of_global_slot ~constants prev_global_slot","counters":[]},{"line":"            in","counters":[]},{"line":"            let next_global_sub_window =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Global_sub_window.of_global_slot ~constants next_global_slot","counters":[]},{"line":"            in","counters":[]},{"line":"            let sub_window_diff =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              UInt32.(","counters":[]},{"line":"                to_int","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                @@ min (succ constants.sub_windows_per_window)","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"                @@ Global_sub_window.sub next_global_sub_window","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"                     prev_global_sub_window)","counters":[]},{"line":"            in","counters":[]},{"line":"            let n = Array.length prev_sub_window_densities in","counters":[]},{"line":"            let current_sub_window_densities =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Array.init n ~f:(fun i ->","counters":[]},{"line":"                  if i + sub_window_diff < n then","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    prev_sub_window_densities.(i + sub_window_diff)","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                  else Length.zero )","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"            in","counters":[]},{"line":"            let current_window_density =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Array.fold current_sub_window_densities ~init:Length.zero","counters":[]},{"line":"                ~f:Length.add","counters":[]},{"line":"            in","counters":[]},{"line":"            let min_window_density =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              if","counters":[]},{"line":"                sub_window_diff = 0","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"                || UInt32.compare","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                     (Global_slot.slot_number next_global_slot)","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"                     constants.grace_period_end","counters":[]},{"line":"                   < 0","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"              then prev_min_window_density","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"              else Length.min current_window_density prev_min_window_density","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"            in","counters":[]},{"line":"            current_sub_window_densities.(n - 1) <-","counters":[]},{"line":"              Length.succ current_sub_window_densities.(n - 1) ;","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"            (min_window_density, current_sub_window_densities)","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"","counters":[]},{"line":"          let constants = Lazy.force Constants.for_unit_tests","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"          (* converting the input for actual implementation to the input required by the","counters":[]},{"line":"             reference implementation *)","counters":[]},{"line":"          let actual_to_reference ~prev_global_slot ~prev_sub_window_densities =","counters":[]},{"line":"            let prev_global_sub_window =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Global_sub_window.of_global_slot ~constants prev_global_slot","counters":[]},{"line":"            in","counters":[]},{"line":"            let prev_relative_sub_window =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Sub_window.to_int","counters":[]},{"line":"              @@ Global_sub_window.sub_window ~constants prev_global_sub_window","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"            in","counters":[]},{"line":"            List.to_array","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            @@ List.drop prev_sub_window_densities prev_relative_sub_window","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"            @ List.take prev_sub_window_densities prev_relative_sub_window","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"            @ [ List.nth_exn prev_sub_window_densities prev_relative_sub_window","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"              ]","counters":[]},{"line":"","counters":[]},{"line":"          (* slot_diff are generated in such a way so that we can test different cases","counters":[]},{"line":"             in the update function, I use a weighted union to generate it.","counters":[]},{"line":"             weight | range of the slot diff","counters":[]},{"line":"             1      | [0*slots_per_sub_window, 1*slots_per_sub_window)","counters":[]},{"line":"             1/4    | [1*slots_per_sub_window, 2*slots_per_sub_window)","counters":[]},{"line":"             1/9    | [2*slots_per_sub_window, 3*slots_per_sub_window)","counters":[]},{"line":"             ...","counters":[]},{"line":"             1/n^2  | [n*slots_per_sub_window, (n+1)*slots_per_sub_window)","counters":[]},{"line":"          *)","counters":[]},{"line":"          let gen_slot_diff =","counters":[]},{"line":"            let to_int = Length.to_int in","counters":[]},{"line":"            Quickcheck.Generator.weighted_union","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"            @@ List.init","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                 (2 * to_int constants.sub_windows_per_window)","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                 ~f:(fun i ->","counters":[]},{"line":"                   ( 1.0 /. (Float.of_int (i + 1) ** 2.)","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"                   , Core.Int.gen_incl","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                       (i * to_int constants.slots_per_sub_window)","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"                       ((i + 1) * to_int constants.slots_per_sub_window) ) )","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"          let num_global_slots_to_test = 1","counters":[]},{"line":"","counters":[]},{"line":"          (* generate an initial global_slot and a list of successive global_slot following","counters":[]},{"line":"             the initial slot. The length of the list is fixed because this same list would","counters":[]},{"line":"             also passed into a snarky computation, and the *Typ* of the list requires a","counters":[]},{"line":"             fixed length. *)","counters":[]},{"line":"          let gen_global_slots :","counters":[]},{"line":"              (Global_slot.t * Global_slot.t list) Quickcheck.Generator.t =","counters":[]},{"line":"            let open Quickcheck.Generator in","counters":[]},{"line":"            let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"            let module GS = Mina_numbers.Global_slot in","counters":[]},{"line":"            let%bind prev_global_slot = small_positive_int in","counters":[]},{"line":"            let%bind slot_diffs =","counters":[]},{"line":"              Core.List.gen_with_length num_global_slots_to_test gen_slot_diff","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"            in","counters":[]},{"line":"            let _, global_slots =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              List.fold slot_diffs ~init:(prev_global_slot, [])","counters":[]},{"line":"                ~f:(fun (prev_global_slot, acc) slot_diff ->","counters":[]},{"line":"                  let next_global_slot = prev_global_slot + slot_diff in","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  (next_global_slot, next_global_slot :: acc) )","counters":[]},{"line":"            in","counters":[]},{"line":"            return","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              ( Global_slot.of_slot_number ~constants","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"                  (GS.of_int prev_global_slot)","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"              , List.map global_slots ~f:(fun s ->","counters":[]},{"line":"                    Global_slot.of_slot_number ~constants (GS.of_int s) )","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"                |> List.rev )","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"","counters":[]},{"line":"          let gen_length =","counters":[]},{"line":"            Quickcheck.Generator.union","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"            @@ List.init (Length.to_int constants.slots_per_sub_window)","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"                 ~f:(fun n -> Quickcheck.Generator.return @@ Length.of_int n)","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":73,"col_end":73,"count":0}]},{"line":"","counters":[]},{"line":"          let gen_min_window_density =","counters":[]},{"line":"            let open Quickcheck.Generator in","counters":[]},{"line":"            let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"            let%bind prev_sub_window_densities =","counters":[]},{"line":"              list_with_length","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                (Length.to_int constants.sub_windows_per_window)","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                gen_length","counters":[]},{"line":"            in","counters":[]},{"line":"            let min_window_density =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let initial xs = List.(rev (tl_exn (rev xs))) in","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":47,"col_end":47,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"              List.fold","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                (initial prev_sub_window_densities)","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                ~init:Length.zero ~f:Length.add","counters":[]},{"line":"            in","counters":[]},{"line":"            return (min_window_density, prev_sub_window_densities)","counters":[]},{"line":"","counters":[]},{"line":"          let gen =","counters":[]},{"line":"            Quickcheck.Generator.tuple2 gen_global_slots gen_min_window_density","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"","counters":[]},{"line":"          let update_several_times ~f ~prev_global_slot ~next_global_slots","counters":[]},{"line":"              ~prev_sub_window_densities ~prev_min_window_density ~constants =","counters":[]},{"line":"            List.fold next_global_slots","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              ~init:","counters":[]},{"line":"                ( prev_global_slot","counters":[]},{"line":"                , prev_sub_window_densities","counters":[]},{"line":"                , prev_min_window_density )","counters":[]},{"line":"              ~f:(fun","counters":[]},{"line":"                   ( prev_global_slot","counters":[]},{"line":"                   , prev_sub_window_densities","counters":[]},{"line":"                   , prev_min_window_density )","counters":[]},{"line":"                   next_global_slot","counters":[]},{"line":"                 ->","counters":[]},{"line":"                let min_window_density, sub_window_densities =","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  f ~constants ~prev_global_slot ~next_global_slot","counters":[]},{"line":"                    ~prev_sub_window_densities ~prev_min_window_density","counters":[]},{"line":"                in","counters":[]},{"line":"                (next_global_slot, sub_window_densities, min_window_density) )","counters":[]},{"line":"","counters":[]},{"line":"          let update_several_times_checked ~f ~prev_global_slot","counters":[]},{"line":"              ~next_global_slots ~prev_sub_window_densities","counters":[]},{"line":"              ~prev_min_window_density ~constants =","counters":[]},{"line":"            let open Tick.Checked in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let open Tick.Checked.Let_syntax in","counters":[]},{"line":"            List.fold next_global_slots","counters":[]},{"line":"              ~init:","counters":[]},{"line":"                ( prev_global_slot","counters":[]},{"line":"                , prev_sub_window_densities","counters":[]},{"line":"                , prev_min_window_density )","counters":[]},{"line":"              ~f:(fun","counters":[]},{"line":"                   ( prev_global_slot","counters":[]},{"line":"                   , prev_sub_window_densities","counters":[]},{"line":"                   , prev_min_window_density )","counters":[]},{"line":"                   next_global_slot","counters":[]},{"line":"                 ->","counters":[]},{"line":"                let%bind min_window_density, sub_window_densities =","counters":[]},{"line":"                  f ~constants ~prev_global_slot ~next_global_slot","counters":[]},{"line":"                    ~prev_sub_window_densities ~prev_min_window_density","counters":[]},{"line":"                in","counters":[]},{"line":"                return","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  (next_global_slot, sub_window_densities, min_window_density) )","counters":[]},{"line":"","counters":[]},{"line":"          let%test_unit \"the actual implementation is equivalent to the \\","counters":[]},{"line":"                         reference implementation\" =","counters":[]},{"line":"            Quickcheck.test ~trials:100 gen","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              ~f:(fun","counters":[]},{"line":"                   ( ((prev_global_slot : Global_slot.t), next_global_slots)","counters":[]},{"line":"                   , (prev_min_window_density, prev_sub_window_densities) )","counters":[]},{"line":"                 ->","counters":[]},{"line":"                let _, _, min_window_density1 =","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  update_several_times","counters":[]},{"line":"                    ~f:(update_min_window_density ~incr_window:true)","counters":[]},{"line":"                    ~prev_global_slot ~next_global_slots","counters":[]},{"line":"                    ~prev_sub_window_densities ~prev_min_window_density","counters":[]},{"line":"                    ~constants","counters":[]},{"line":"                in","counters":[]},{"line":"                let _, _, min_window_density2 =","counters":[]},{"line":"                  update_several_times","counters":[]},{"line":"                    ~f:update_min_window_density_reference_implementation","counters":[]},{"line":"                    ~prev_global_slot ~next_global_slots","counters":[]},{"line":"                    ~prev_sub_window_densities:","counters":[]},{"line":"                      (actual_to_reference ~prev_global_slot","counters":[]},{"line":"                         ~prev_sub_window_densities )","counters":[]},{"line":"                    ~prev_min_window_density ~constants","counters":[]},{"line":"                in","counters":[]},{"line":"                assert (Length.(equal min_window_density1 min_window_density2)) )","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"","counters":[]},{"line":"          let%test_unit \"Inside snark computation is equivalent to outside \\","counters":[]},{"line":"                         snark computation\" =","counters":[]},{"line":"            Quickcheck.test ~trials:100 gen","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              ~f:(fun (slots, min_window_densities) ->","counters":[]},{"line":"                Test_util.test_equal","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  (Typ.tuple3","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                     (Typ.tuple2 Global_slot.typ","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                        (Typ.list ~length:num_global_slots_to_test","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                           Global_slot.typ ) )","counters":[]},{"line":"                     (Typ.tuple2 Length.typ","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                        (Typ.list","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                           ~length:","counters":[]},{"line":"                             (Length.to_int constants.sub_windows_per_window)","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"                           Length.typ ) )","counters":[]},{"line":"                     Constants.typ )","counters":[]},{"line":"                  (Typ.tuple3 Global_slot.typ","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                     (Typ.list","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                        ~length:(Length.to_int constants.sub_windows_per_window)","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"                        Length.typ )","counters":[]},{"line":"                     Length.typ )","counters":[]},{"line":"                  (fun ( (prev_global_slot, next_global_slots)","counters":[]},{"line":"                       , (prev_min_window_density, prev_sub_window_densities)","counters":[]},{"line":"                       , constants ) ->","counters":[]},{"line":"                    update_several_times_checked","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      ~f:Checked.update_min_window_density ~prev_global_slot","counters":[]},{"line":"                      ~next_global_slots ~prev_sub_window_densities","counters":[]},{"line":"                      ~prev_min_window_density ~constants )","counters":[]},{"line":"                  (fun ( (prev_global_slot, next_global_slots)","counters":[]},{"line":"                       , (prev_min_window_density, prev_sub_window_densities)","counters":[]},{"line":"                       , constants ) ->","counters":[]},{"line":"                    update_several_times","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      ~f:(update_min_window_density ~incr_window:true)","counters":[]},{"line":"                      ~prev_global_slot ~next_global_slots","counters":[]},{"line":"                      ~prev_sub_window_densities ~prev_min_window_density","counters":[]},{"line":"                      ~constants )","counters":[]},{"line":"                  (slots, min_window_densities, constants) )","counters":[]},{"line":"        end )","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    [%%else]","counters":[]},{"line":"","counters":[]},{"line":"    module Min_window_density = struct","counters":[]},{"line":"      let update_min_window_density ~constants:_ ~prev_global_slot:_","counters":[]},{"line":"          ~next_global_slot:_ ~prev_sub_window_densities","counters":[]},{"line":"          ~prev_min_window_density =","counters":[]},{"line":"        (prev_min_window_density, prev_sub_window_densities)","counters":[]},{"line":"","counters":[]},{"line":"      module Checked = struct","counters":[]},{"line":"        let update_min_window_density ~constants:_ ~prev_global_slot:_","counters":[]},{"line":"            ~next_global_slot:_ ~prev_sub_window_densities","counters":[]},{"line":"            ~prev_min_window_density =","counters":[]},{"line":"          Tick.Checked.return","counters":[]},{"line":"            (prev_min_window_density, prev_sub_window_densities)","counters":[]},{"line":"      end","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    [%%endif]","counters":[]},{"line":"","counters":[]},{"line":"    (* We have a list of state hashes. When we extend the blockchain,","counters":[]},{"line":"       we see if the **previous** state should be saved as a checkpoint.","counters":[]},{"line":"       This is because we have convenient access to the entire previous","counters":[]},{"line":"       protocol state hash.","counters":[]},{"line":"","counters":[]},{"line":"       We divide the slots of an epoch into \"checkpoint windows\": chunks of","counters":[]},{"line":"       size [checkpoint_window_size]. The goal is to record the first block","counters":[]},{"line":"       in a given window as a check-point if there are any blocks in that","counters":[]},{"line":"       window, and zero checkpoints if the window was empty.","counters":[]},{"line":"","counters":[]},{"line":"       To that end, we store in each state a bit [checkpoint_window_filled] which","counters":[]},{"line":"       is true iff there has already been a state in the history of the given state","counters":[]},{"line":"       which is in the same checkpoint window as the given state.","counters":[]},{"line":"    *)","counters":[]},{"line":"    module Consensus_state = struct","counters":[]},{"line":"      module Poly = struct","counters":[]},{"line":"        [%%versioned","counters":[]},{"line":"        module Stable = struct","counters":[]},{"line":"          module V1 = struct","counters":[]},{"line":"            type ( 'length","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"                 , 'vrf_output","counters":[]},{"line":"                 , 'amount","counters":[]},{"line":"                 , 'global_slot","counters":[]},{"line":"                 , 'global_slot_since_genesis","counters":[]},{"line":"                 , 'staking_epoch_data","counters":[]},{"line":"                 , 'next_epoch_data","counters":[]},{"line":"                 , 'bool","counters":[]},{"line":"                 , 'pk )","counters":[]},{"line":"                 t =","counters":[{"col_start":17,"col_end":17,"count":12}]},{"line":"                  ( 'length","counters":[]},{"line":"                  , 'vrf_output","counters":[]},{"line":"                  , 'amount","counters":[]},{"line":"                  , 'global_slot","counters":[]},{"line":"                  , 'global_slot_since_genesis","counters":[]},{"line":"                  , 'staking_epoch_data","counters":[]},{"line":"                  , 'next_epoch_data","counters":[]},{"line":"                  , 'bool","counters":[]},{"line":"                  , 'pk )","counters":[]},{"line":"                  A.Data.Consensus_state.Poly.V1.t =","counters":[]},{"line":"              { blockchain_length : 'length","counters":[{"col_start":16,"col_end":16,"count":1},{"col_start":32,"col_end":32,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"              ; epoch_count : 'length","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"              ; min_window_density : 'length","counters":[{"col_start":16,"col_end":16,"count":1},{"col_start":33,"col_end":33,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"              ; sub_window_densities : 'length list","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":47,"col_end":47,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"              ; last_vrf_output : 'vrf_output","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"              ; total_currency : 'amount","counters":[{"col_start":16,"col_end":16,"count":1},{"col_start":29,"col_end":29,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"              ; curr_global_slot : 'global_slot","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"              ; global_slot_since_genesis : 'global_slot_since_genesis","counters":[{"col_start":16,"col_end":16,"count":1},{"col_start":40,"col_end":40,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"              ; staking_epoch_data : 'staking_epoch_data","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"              ; next_epoch_data : 'next_epoch_data","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"              ; has_ancestor_in_same_checkpoint_window : 'bool","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":53,"col_end":53,"count":0},{"col_start":57,"col_end":57,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"              ; block_stake_winner : 'pk","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"              ; block_creator : 'pk","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"              ; coinbase_receiver : 'pk","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"              ; supercharge_coinbase : 'bool","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"              }","counters":[]},{"line":"            [@@deriving sexp, equal, compare, hash, yojson, fields, hlist]","counters":[{"col_start":73,"col_end":73,"count":3}]},{"line":"          end","counters":[]},{"line":"        end]","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      module Value = struct","counters":[]},{"line":"        [%%versioned","counters":[]},{"line":"        module Stable = struct","counters":[]},{"line":"          module V1 = struct","counters":[]},{"line":"            type t =","counters":[{"col_start":12,"col_end":12,"count":2},{"col_start":17,"col_end":17,"count":1}]},{"line":"              ( Length.Stable.V1.t","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":16,"col_end":16,"count":0}]},{"line":"              , Vrf.Output.Truncated.Stable.V1.t","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"              , Amount.Stable.V1.t","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"              , Global_slot.Stable.V1.t","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"              , Mina_numbers.Global_slot.Stable.V1.t","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"              , Epoch_data.Staking_value_versioned.Value.Stable.V1.t","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"              , Epoch_data.Next_value_versioned.Value.Stable.V1.t","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"              , bool","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"              , Public_key.Compressed.Stable.V1.t )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"              Poly.Stable.V1.t","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"            [@@deriving sexp, equal, compare, hash, yojson]","counters":[{"col_start":58,"col_end":58,"count":5}]},{"line":"","counters":[]},{"line":"            let to_latest = Fn.id","counters":[]},{"line":"          end","counters":[]},{"line":"        end]","counters":[]},{"line":"","counters":[]},{"line":"        module For_tests = struct","counters":[]},{"line":"          let with_global_slot_since_genesis (state : t) slot_number =","counters":[]},{"line":"            let global_slot_since_genesis : Mina_numbers.Global_slot.t =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              slot_number","counters":[]},{"line":"            in","counters":[]},{"line":"            { state with global_slot_since_genesis }","counters":[]},{"line":"        end","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      open Snark_params.Tick","counters":[]},{"line":"","counters":[]},{"line":"      type var =","counters":[]},{"line":"        ( Length.Checked.t","counters":[]},{"line":"        , Vrf.Output.Truncated.var","counters":[]},{"line":"        , Amount.var","counters":[]},{"line":"        , Global_slot.Checked.t","counters":[]},{"line":"        , Mina_numbers.Global_slot.Checked.t","counters":[]},{"line":"        , Epoch_data.var","counters":[]},{"line":"        , Epoch_data.var","counters":[]},{"line":"        , Boolean.var","counters":[]},{"line":"        , Public_key.Compressed.var )","counters":[]},{"line":"        Poly.t","counters":[]},{"line":"","counters":[]},{"line":"      let typ ~(constraint_constants : Genesis_constants.Constraint_constants.t)","counters":[]},{"line":"          : (var, Value.t) Typ.t =","counters":[]},{"line":"        let sub_windows_per_window =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          constraint_constants.sub_windows_per_window","counters":[]},{"line":"        in","counters":[]},{"line":"        Snark_params.Tick.Typ.of_hlistable","counters":[]},{"line":"          [ Length.typ","counters":[]},{"line":"          ; Length.typ","counters":[]},{"line":"          ; Length.typ","counters":[]},{"line":"          ; Typ.list ~length:sub_windows_per_window Length.typ","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"          ; Vrf.Output.Truncated.typ","counters":[]},{"line":"          ; Amount.typ","counters":[]},{"line":"          ; Global_slot.typ","counters":[]},{"line":"          ; Mina_numbers.Global_slot.typ","counters":[]},{"line":"          ; Epoch_data.Staking.typ","counters":[]},{"line":"          ; Epoch_data.Next.typ","counters":[]},{"line":"          ; Boolean.typ","counters":[]},{"line":"          ; Public_key.Compressed.typ","counters":[]},{"line":"          ; Public_key.Compressed.typ","counters":[]},{"line":"          ; Public_key.Compressed.typ","counters":[]},{"line":"          ; Boolean.typ","counters":[]},{"line":"          ]","counters":[]},{"line":"          ~var_to_hlist:Poly.to_hlist ~var_of_hlist:Poly.of_hlist","counters":[]},{"line":"          ~value_to_hlist:Poly.to_hlist ~value_of_hlist:Poly.of_hlist","counters":[]},{"line":"","counters":[]},{"line":"      let to_input","counters":[]},{"line":"          ({ Poly.blockchain_length","counters":[]},{"line":"           ; epoch_count","counters":[]},{"line":"           ; min_window_density","counters":[]},{"line":"           ; sub_window_densities","counters":[]},{"line":"           ; last_vrf_output","counters":[]},{"line":"           ; total_currency","counters":[]},{"line":"           ; curr_global_slot","counters":[]},{"line":"           ; global_slot_since_genesis","counters":[]},{"line":"           ; staking_epoch_data","counters":[]},{"line":"           ; next_epoch_data","counters":[]},{"line":"           ; has_ancestor_in_same_checkpoint_window","counters":[]},{"line":"           ; block_stake_winner","counters":[]},{"line":"           ; block_creator","counters":[]},{"line":"           ; coinbase_receiver","counters":[]},{"line":"           ; supercharge_coinbase","counters":[]},{"line":"           } :","counters":[]},{"line":"            Value.t ) =","counters":[]},{"line":"        let open Random_oracle.Input.Chunked in","counters":[{"col_start":8,"col_end":8,"count":5}]},{"line":"        List.reduce_exn ~f:append","counters":[]},{"line":"          [ Length.to_input blockchain_length","counters":[{"col_start":26,"col_end":26,"count":5}]},{"line":"          ; Length.to_input epoch_count","counters":[{"col_start":26,"col_end":26,"count":5}]},{"line":"          ; Length.to_input min_window_density","counters":[{"col_start":26,"col_end":26,"count":5}]},{"line":"          ; List.reduce_exn ~f:append","counters":[{"col_start":26,"col_end":26,"count":5}]},{"line":"              (List.map ~f:Length.to_input sub_window_densities)","counters":[{"col_start":22,"col_end":22,"count":5}]},{"line":"          ; Vrf.Output.Truncated.to_input last_vrf_output","counters":[{"col_start":40,"col_end":40,"count":5}]},{"line":"          ; Amount.to_input total_currency","counters":[{"col_start":26,"col_end":26,"count":5}]},{"line":"          ; Global_slot.to_input curr_global_slot","counters":[{"col_start":31,"col_end":31,"count":5}]},{"line":"          ; Mina_numbers.Global_slot.to_input global_slot_since_genesis","counters":[{"col_start":44,"col_end":44,"count":5}]},{"line":"          ; packed","counters":[{"col_start":17,"col_end":17,"count":5}]},{"line":"              ( Mina_base.Util.field_of_bool","counters":[{"col_start":43,"col_end":43,"count":5}]},{"line":"                  has_ancestor_in_same_checkpoint_window","counters":[]},{"line":"              , 1 )","counters":[]},{"line":"          ; packed (Mina_base.Util.field_of_bool supercharge_coinbase, 1)","counters":[{"col_start":17,"col_end":17,"count":5},{"col_start":47,"col_end":47,"count":5}]},{"line":"          ; Epoch_data.Staking.to_input staking_epoch_data","counters":[{"col_start":38,"col_end":38,"count":5}]},{"line":"          ; Epoch_data.Next.to_input next_epoch_data","counters":[{"col_start":35,"col_end":35,"count":5}]},{"line":"          ; Public_key.Compressed.to_input block_stake_winner","counters":[{"col_start":41,"col_end":41,"count":5}]},{"line":"          ; Public_key.Compressed.to_input block_creator","counters":[{"col_start":41,"col_end":41,"count":5}]},{"line":"          ; Public_key.Compressed.to_input coinbase_receiver","counters":[{"col_start":41,"col_end":41,"count":5}]},{"line":"          ]","counters":[]},{"line":"","counters":[]},{"line":"      let var_to_input","counters":[]},{"line":"          ({ Poly.blockchain_length","counters":[]},{"line":"           ; epoch_count","counters":[]},{"line":"           ; min_window_density","counters":[]},{"line":"           ; sub_window_densities","counters":[]},{"line":"           ; last_vrf_output","counters":[]},{"line":"           ; total_currency","counters":[]},{"line":"           ; curr_global_slot","counters":[]},{"line":"           ; global_slot_since_genesis","counters":[]},{"line":"           ; staking_epoch_data","counters":[]},{"line":"           ; next_epoch_data","counters":[]},{"line":"           ; has_ancestor_in_same_checkpoint_window","counters":[]},{"line":"           ; block_stake_winner","counters":[]},{"line":"           ; block_creator","counters":[]},{"line":"           ; coinbase_receiver","counters":[]},{"line":"           ; supercharge_coinbase","counters":[]},{"line":"           } :","counters":[]},{"line":"            var ) =","counters":[]},{"line":"        let open Random_oracle.Input.Chunked in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        List.reduce_exn ~f:append","counters":[]},{"line":"          [ Length.Checked.to_input blockchain_length","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"          ; Length.Checked.to_input epoch_count","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"          ; Length.Checked.to_input min_window_density","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"          ; List.reduce_exn ~f:append","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"              (List.map ~f:Length.Checked.to_input sub_window_densities)","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"          ; Vrf.Output.Truncated.var_to_input last_vrf_output","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"          ; Amount.var_to_input total_currency","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"          ; Global_slot.Checked.to_input curr_global_slot","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"          ; Mina_numbers.Global_slot.Checked.to_input global_slot_since_genesis","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"          ; packed","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"              ((has_ancestor_in_same_checkpoint_window :> Tick.Field.Var.t), 1)","counters":[]},{"line":"          ; packed ((supercharge_coinbase :> Tick.Field.Var.t), 1)","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"          ; Epoch_data.Staking.var_to_input staking_epoch_data","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"          ; Epoch_data.Next.var_to_input next_epoch_data","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"          ; Public_key.Compressed.Checked.to_input block_stake_winner","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"          ; Public_key.Compressed.Checked.to_input block_creator","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"          ; Public_key.Compressed.Checked.to_input coinbase_receiver","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"          ]","counters":[]},{"line":"","counters":[]},{"line":"      let global_slot { Poly.curr_global_slot; _ } = curr_global_slot","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"","counters":[]},{"line":"      let checkpoint_window ~(constants : Constants.t) (slot : Global_slot.t) =","counters":[]},{"line":"        UInt32.Infix.(","counters":[{"col_start":8,"col_end":8,"count":4}]},{"line":"          Global_slot.slot_number slot","counters":[{"col_start":32,"col_end":32,"count":4}]},{"line":"          / constants.checkpoint_window_size_in_slots)","counters":[]},{"line":"","counters":[]},{"line":"      let same_checkpoint_window_unchecked ~constants slot1 slot2 =","counters":[]},{"line":"        UInt32.equal","counters":[{"col_start":8,"col_end":8,"count":2}]},{"line":"          (checkpoint_window slot1 ~constants)","counters":[{"col_start":27,"col_end":27,"count":2}]},{"line":"          (checkpoint_window slot2 ~constants)","counters":[{"col_start":27,"col_end":27,"count":2}]},{"line":"","counters":[]},{"line":"      let update ~(constants : Constants.t)","counters":[]},{"line":"          ~(previous_consensus_state : Value.t)","counters":[]},{"line":"          ~(consensus_transition : Consensus_transition.t)","counters":[]},{"line":"          ~(previous_protocol_state_hash : Mina_base.State_hash.t)","counters":[]},{"line":"          ~(supply_increase : Currency.Amount.Signed.t)","counters":[]},{"line":"          ~(snarked_ledger_hash : Mina_base.Frozen_ledger_hash.t)","counters":[]},{"line":"          ~(genesis_ledger_hash : Mina_base.Frozen_ledger_hash.t)","counters":[]},{"line":"          ~(producer_vrf_result : Random_oracle.Digest.t)","counters":[]},{"line":"          ~(block_stake_winner : Public_key.Compressed.t)","counters":[]},{"line":"          ~(block_creator : Public_key.Compressed.t)","counters":[]},{"line":"          ~(coinbase_receiver : Public_key.Compressed.t)","counters":[]},{"line":"          ~(supercharge_coinbase : bool) : Value.t Or_error.t =","counters":[]},{"line":"        let open Or_error.Let_syntax in","counters":[{"col_start":8,"col_end":8,"count":2}]},{"line":"        let prev_epoch, prev_slot =","counters":[]},{"line":"          Global_slot.to_epoch_and_slot","counters":[]},{"line":"            previous_consensus_state.curr_global_slot","counters":[]},{"line":"        in","counters":[]},{"line":"        let next_global_slot =","counters":[{"col_start":8,"col_end":8,"count":2}]},{"line":"          Global_slot.of_slot_number consensus_transition ~constants","counters":[]},{"line":"        in","counters":[]},{"line":"        let next_epoch, next_slot =","counters":[{"col_start":8,"col_end":8,"count":2}]},{"line":"          Global_slot.to_epoch_and_slot next_global_slot","counters":[]},{"line":"        in","counters":[]},{"line":"        let%bind slot_diff =","counters":[]},{"line":"          Global_slot.(","counters":[]},{"line":"            next_global_slot - previous_consensus_state.curr_global_slot)","counters":[]},{"line":"          |> Option.value_map","counters":[{"col_start":28,"col_end":28,"count":2}]},{"line":"               ~default:","counters":[]},{"line":"                 (Or_error.errorf","counters":[{"col_start":32,"col_end":32,"count":2}]},{"line":"                    !\"Next global slot %{sexp: Global_slot.t} smaller than \\","counters":[{"col_start":21,"col_end":21,"count":4}]},{"line":"                      current global slot %{sexp: Global_slot.t}\"","counters":[]},{"line":"                    next_global_slot previous_consensus_state.curr_global_slot )","counters":[]},{"line":"               ~f:(fun diff -> Ok diff)","counters":[{"col_start":31,"col_end":31,"count":2}]},{"line":"        in","counters":[]},{"line":"        let%map total_currency =","counters":[]},{"line":"          let total, `Overflow overflow =","counters":[]},{"line":"            Amount.add_signed_flagged previous_consensus_state.total_currency","counters":[]},{"line":"              supply_increase","counters":[]},{"line":"          in","counters":[]},{"line":"          if overflow then","counters":[{"col_start":10,"col_end":10,"count":2}]},{"line":"            Or_error.errorf","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"              !\"New total currency less than zero. supply_increase: %{sexp: \\","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                Amount.Signed.t} previous total currency: %{sexp: Amount.t}\"","counters":[]},{"line":"              supply_increase previous_consensus_state.total_currency","counters":[]},{"line":"          else Ok total","counters":[{"col_start":15,"col_end":15,"count":2}]},{"line":"        and () =","counters":[]},{"line":"          if","counters":[]},{"line":"            Consensus_transition.(","counters":[]},{"line":"              equal consensus_transition Consensus_transition.genesis)","counters":[{"col_start":18,"col_end":18,"count":2},{"col_start":69,"col_end":69,"count":2}]},{"line":"            || Global_slot.(","counters":[]},{"line":"                 previous_consensus_state.curr_global_slot < next_global_slot)","counters":[{"col_start":77,"col_end":77,"count":0}]},{"line":"          then Ok ()","counters":[{"col_start":15,"col_end":15,"count":2}]},{"line":"          else","counters":[]},{"line":"            Or_error.errorf","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"              !\"(epoch, slot) did not increase. prev=%{sexp:Epoch.t * Slot.t}, \\","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                next=%{sexp:Epoch.t * Slot.t}\"","counters":[]},{"line":"              (prev_epoch, prev_slot) (next_epoch, next_slot)","counters":[]},{"line":"        in","counters":[]},{"line":"        let staking_epoch_data, next_epoch_data, epoch_count =","counters":[{"col_start":8,"col_end":8,"count":2}]},{"line":"          Epoch_data.update_pair ~constants","counters":[]},{"line":"            ( previous_consensus_state.staking_epoch_data","counters":[]},{"line":"            , previous_consensus_state.next_epoch_data )","counters":[]},{"line":"            previous_consensus_state.epoch_count ~prev_epoch ~next_epoch","counters":[]},{"line":"            ~next_slot ~prev_protocol_state_hash:previous_protocol_state_hash","counters":[]},{"line":"            ~producer_vrf_result ~snarked_ledger_hash ~genesis_ledger_hash","counters":[]},{"line":"            ~total_currency","counters":[]},{"line":"        in","counters":[]},{"line":"        let min_window_density, sub_window_densities =","counters":[{"col_start":8,"col_end":8,"count":2}]},{"line":"          Min_window_density.update_min_window_density ~constants","counters":[]},{"line":"            ~incr_window:true","counters":[]},{"line":"            ~prev_global_slot:previous_consensus_state.curr_global_slot","counters":[]},{"line":"            ~next_global_slot","counters":[]},{"line":"            ~prev_sub_window_densities:","counters":[]},{"line":"              previous_consensus_state.sub_window_densities","counters":[]},{"line":"            ~prev_min_window_density:previous_consensus_state.min_window_density","counters":[]},{"line":"        in","counters":[]},{"line":"        { Poly.blockchain_length =","counters":[]},{"line":"            Length.succ previous_consensus_state.blockchain_length","counters":[{"col_start":22,"col_end":22,"count":2}]},{"line":"        ; epoch_count","counters":[]},{"line":"        ; min_window_density","counters":[]},{"line":"        ; sub_window_densities","counters":[]},{"line":"        ; last_vrf_output = Vrf.Output.truncate producer_vrf_result","counters":[{"col_start":46,"col_end":46,"count":2}]},{"line":"        ; total_currency","counters":[]},{"line":"        ; curr_global_slot = next_global_slot","counters":[]},{"line":"        ; global_slot_since_genesis =","counters":[]},{"line":"            Mina_numbers.Global_slot.add","counters":[{"col_start":39,"col_end":39,"count":2}]},{"line":"              previous_consensus_state.global_slot_since_genesis slot_diff","counters":[]},{"line":"        ; staking_epoch_data","counters":[]},{"line":"        ; next_epoch_data","counters":[]},{"line":"        ; has_ancestor_in_same_checkpoint_window =","counters":[]},{"line":"            same_checkpoint_window_unchecked ~constants","counters":[{"col_start":43,"col_end":43,"count":2}]},{"line":"              (Global_slot.create ~constants ~epoch:prev_epoch ~slot:prev_slot)","counters":[]},{"line":"              (Global_slot.create ~constants ~epoch:next_epoch ~slot:next_slot)","counters":[]},{"line":"        ; block_stake_winner","counters":[]},{"line":"        ; block_creator","counters":[]},{"line":"        ; coinbase_receiver","counters":[]},{"line":"        ; supercharge_coinbase","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"      let same_checkpoint_window ~(constants : Constants.var)","counters":[]},{"line":"          ~prev:(slot1 : Global_slot.Checked.t)","counters":[]},{"line":"          ~next:(slot2 : Global_slot.Checked.t) =","counters":[]},{"line":"        let module Slot = Mina_numbers.Global_slot in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let slot1 : Slot.Checked.t = Global_slot.slot_number slot1 in","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"        let checkpoint_window_size_in_slots =","counters":[]},{"line":"          constants.checkpoint_window_size_in_slots","counters":[]},{"line":"        in","counters":[]},{"line":"        let%bind _q1, r1 =","counters":[]},{"line":"          Slot.Checked.div_mod slot1","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"            (Slot.Checked.Unsafe.of_field","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"               (Length.Checked.to_field checkpoint_window_size_in_slots) )","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"        in","counters":[]},{"line":"        let next_window_start =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Run.Field.(","counters":[]},{"line":"            Slot.Checked.to_field slot1","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"            - Slot.Checked.to_field r1","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"            + Length.Checked.to_field checkpoint_window_size_in_slots)","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"        in","counters":[]},{"line":"        Slot.Checked.( < )","counters":[]},{"line":"          (Global_slot.slot_number slot2)","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"          (Slot.Checked.Unsafe.of_field next_window_start)","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"","counters":[]},{"line":"      let same_checkpoint_window ~constants ~prev ~next =","counters":[]},{"line":"        same_checkpoint_window ~constants ~prev ~next","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      let negative_one ~genesis_ledger","counters":[]},{"line":"          ~(genesis_epoch_data : Genesis_epoch_data.t)","counters":[]},{"line":"          ~(constants : Constants.t)","counters":[]},{"line":"          ~(constraint_constants : Genesis_constants.Constraint_constants.t) =","counters":[]},{"line":"        let max_sub_window_density = constants.slots_per_sub_window in","counters":[{"col_start":8,"col_end":8,"count":4}]},{"line":"        let max_window_density = constants.slots_per_window in","counters":[]},{"line":"        let blockchain_length, global_slot_since_genesis =","counters":[]},{"line":"          match constraint_constants.fork with","counters":[]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":4}]},{"line":"              (Length.zero, Mina_numbers.Global_slot.zero)","counters":[]},{"line":"          | Some { previous_length; previous_global_slot; _ } ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (*Note: global_slot_since_genesis at fork point is the same as global_slot_since_genesis in the new genesis. This value is used to check transaction validity and existence of locked tokens.","counters":[]},{"line":"                For reviewers, should this be incremented by 1 because it's technically a new block? we don't really know how many slots passed since the fork point*)","counters":[]},{"line":"              (previous_length, previous_global_slot)","counters":[]},{"line":"        in","counters":[]},{"line":"        let default_epoch_data =","counters":[]},{"line":"          Genesis_epoch_data.Data.","counters":[]},{"line":"            { ledger = genesis_ledger; seed = Epoch_seed.initial }","counters":[]},{"line":"        in","counters":[]},{"line":"        let genesis_epoch_data_staking, genesis_epoch_data_next =","counters":[]},{"line":"          Option.value_map genesis_epoch_data","counters":[]},{"line":"            ~default:(default_epoch_data, default_epoch_data) ~f:(fun data ->","counters":[]},{"line":"              (data.staking, Option.value ~default:data.staking data.next) )","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"        in","counters":[]},{"line":"        let genesis_winner_pk = fst Vrf.Precomputed.genesis_winner in","counters":[{"col_start":8,"col_end":8,"count":4}]},{"line":"        { Poly.blockchain_length","counters":[{"col_start":8,"col_end":8,"count":4}]},{"line":"        ; epoch_count = Length.zero","counters":[]},{"line":"        ; min_window_density = max_window_density","counters":[]},{"line":"        ; sub_window_densities =","counters":[]},{"line":"            Length.zero","counters":[]},{"line":"            :: List.init","counters":[{"col_start":23,"col_end":23,"count":4}]},{"line":"                 (Length.to_int constants.sub_windows_per_window - 1)","counters":[{"col_start":30,"col_end":30,"count":4}]},{"line":"                 ~f:(Fn.const max_sub_window_density)","counters":[{"col_start":28,"col_end":28,"count":4}]},{"line":"        ; last_vrf_output = Vrf.Output.Truncated.dummy","counters":[]},{"line":"        ; total_currency = genesis_ledger_total_currency ~ledger:genesis_ledger","counters":[]},{"line":"        ; curr_global_slot = Global_slot.zero ~constants","counters":[]},{"line":"        ; global_slot_since_genesis","counters":[]},{"line":"        ; staking_epoch_data =","counters":[]},{"line":"            Epoch_data.Staking.genesis","counters":[]},{"line":"              ~genesis_epoch_data:genesis_epoch_data_staking","counters":[]},{"line":"        ; next_epoch_data =","counters":[]},{"line":"            Epoch_data.Next.genesis ~genesis_epoch_data:genesis_epoch_data_next","counters":[]},{"line":"        ; has_ancestor_in_same_checkpoint_window = false","counters":[]},{"line":"        ; block_stake_winner = genesis_winner_pk","counters":[]},{"line":"        ; block_creator = genesis_winner_pk","counters":[]},{"line":"        ; coinbase_receiver = genesis_winner_pk","counters":[]},{"line":"        ; supercharge_coinbase = true","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"      let create_genesis_from_transition ~negative_one_protocol_state_hash","counters":[]},{"line":"          ~consensus_transition ~genesis_ledger","counters":[]},{"line":"          ~(genesis_epoch_data : Genesis_epoch_data.t) ~constraint_constants","counters":[]},{"line":"          ~constants : Value.t =","counters":[]},{"line":"        let staking_seed =","counters":[{"col_start":8,"col_end":8,"count":2}]},{"line":"          Option.value_map genesis_epoch_data ~default:Epoch_seed.initial","counters":[]},{"line":"            ~f:(fun data -> data.staking.seed)","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"        in","counters":[]},{"line":"        let producer_vrf_result =","counters":[{"col_start":8,"col_end":8,"count":2}]},{"line":"          let _, sk = Vrf.Precomputed.genesis_winner in","counters":[]},{"line":"          Vrf.eval ~constraint_constants ~private_key:sk","counters":[{"col_start":17,"col_end":17,"count":2}]},{"line":"            { Vrf.Message.global_slot = consensus_transition","counters":[]},{"line":"            ; seed = staking_seed","counters":[]},{"line":"            ; delegator = 0","counters":[]},{"line":"            }","counters":[]},{"line":"        in","counters":[]},{"line":"        let snarked_ledger_hash =","counters":[]},{"line":"          Lazy.force genesis_ledger |> Mina_ledger.Ledger.merkle_root","counters":[{"col_start":39,"col_end":39,"count":2}]},{"line":"          |> Mina_base.Frozen_ledger_hash.of_ledger_hash","counters":[{"col_start":13,"col_end":13,"count":2}]},{"line":"        in","counters":[]},{"line":"        let genesis_winner_pk = fst Vrf.Precomputed.genesis_winner in","counters":[{"col_start":8,"col_end":8,"count":2}]},{"line":"        (* no coinbases for genesis block, so CLI flag for coinbase receiver","counters":[]},{"line":"           not relevant","counters":[]},{"line":"        *)","counters":[]},{"line":"        Or_error.ok_exn","counters":[{"col_start":8,"col_end":8,"count":2}]},{"line":"          (update ~constants ~producer_vrf_result","counters":[]},{"line":"             ~previous_consensus_state:","counters":[]},{"line":"               (negative_one ~genesis_ledger ~genesis_epoch_data ~constants","counters":[]},{"line":"                  ~constraint_constants )","counters":[]},{"line":"             ~previous_protocol_state_hash:negative_one_protocol_state_hash","counters":[]},{"line":"             ~consensus_transition ~supply_increase:Currency.Amount.Signed.zero","counters":[]},{"line":"             ~snarked_ledger_hash ~genesis_ledger_hash:snarked_ledger_hash","counters":[]},{"line":"             ~block_stake_winner:genesis_winner_pk","counters":[]},{"line":"             ~block_creator:genesis_winner_pk","counters":[]},{"line":"             ~coinbase_receiver:genesis_winner_pk ~supercharge_coinbase:true )","counters":[]},{"line":"","counters":[]},{"line":"      let create_genesis ~negative_one_protocol_state_hash ~genesis_ledger","counters":[]},{"line":"          ~genesis_epoch_data ~constraint_constants ~constants : Value.t =","counters":[]},{"line":"        create_genesis_from_transition ~negative_one_protocol_state_hash","counters":[{"col_start":8,"col_end":8,"count":2}]},{"line":"          ~consensus_transition:Consensus_transition.genesis ~genesis_ledger","counters":[]},{"line":"          ~genesis_epoch_data ~constraint_constants ~constants","counters":[]},{"line":"","counters":[]},{"line":"      (* Check that both epoch and slot are zero.","counters":[]},{"line":"       *)","counters":[]},{"line":"      let is_genesis_state (t : Value.t) =","counters":[]},{"line":"        Mina_numbers.Global_slot.(","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          equal zero (Global_slot.slot_number t.curr_global_slot))","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"      let is_genesis (global_slot : Global_slot.Checked.t) =","counters":[]},{"line":"        let open Mina_numbers.Global_slot in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Checked.equal (Checked.constant zero)","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"          (Global_slot.slot_number global_slot)","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"","counters":[]},{"line":"      let is_genesis_state_var (t : var) = is_genesis t.curr_global_slot","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"","counters":[]},{"line":"      let epoch_count (t : Value.t) = t.epoch_count","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"","counters":[]},{"line":"      let supercharge_coinbase_var (t : var) = t.supercharge_coinbase","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"","counters":[]},{"line":"      let supercharge_coinbase (t : Value.t) = t.supercharge_coinbase","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"","counters":[]},{"line":"      let compute_supercharge_coinbase ~(winner_account : Mina_base.Account.var)","counters":[]},{"line":"          ~global_slot =","counters":[]},{"line":"        let open Snark_params.Tick in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let%map winner_locked =","counters":[]},{"line":"          Mina_base.Account.Checked.has_locked_tokens ~global_slot","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"            winner_account","counters":[]},{"line":"        in","counters":[]},{"line":"        Boolean.not winner_locked","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      let%snarkydef_ update_var (previous_state : var)","counters":[]},{"line":"          (transition_data : Consensus_transition.var)","counters":[]},{"line":"          (previous_protocol_state_hash : Mina_base.State_hash.var)","counters":[]},{"line":"          ~(supply_increase : Currency.Amount.Signed.var)","counters":[]},{"line":"          ~(previous_blockchain_state_ledger_hash :","counters":[]},{"line":"             Mina_base.Frozen_ledger_hash.var ) ~genesis_ledger_hash","counters":[]},{"line":"          ~constraint_constants","counters":[]},{"line":"          ~(protocol_constants : Mina_base.Protocol_constants_checked.var) =","counters":[]},{"line":"        let open Snark_params.Tick in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let%bind constants =","counters":[]},{"line":"          Constants.Checked.create ~constraint_constants ~protocol_constants","counters":[]},{"line":"        in","counters":[]},{"line":"        let { Poly.curr_global_slot = prev_global_slot; _ } = previous_state in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let next_global_slot =","counters":[]},{"line":"          Global_slot.Checked.of_slot_number ~constants transition_data","counters":[]},{"line":"        in","counters":[]},{"line":"        let%bind slot_diff =","counters":[]},{"line":"          [%with_label_ \"Next global slot is less that previous global slot\"]","counters":[{"col_start":75,"col_end":75,"count":0},{"col_start":76,"col_end":76,"count":0}]},{"line":"            (fun () ->","counters":[]},{"line":"              Global_slot.Checked.sub next_global_slot prev_global_slot )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"        in","counters":[]},{"line":"        let%bind () =","counters":[]},{"line":"          let%bind global_slot_increased =","counters":[]},{"line":"            Global_slot.Checked.(prev_global_slot < next_global_slot)","counters":[]},{"line":"          in","counters":[]},{"line":"          let%bind is_genesis = is_genesis next_global_slot in","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"          Boolean.Assert.any [ global_slot_increased; is_genesis ]","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        in","counters":[]},{"line":"        let%bind next_epoch, next_slot =","counters":[]},{"line":"          Global_slot.Checked.to_epoch_and_slot next_global_slot","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"        and prev_epoch, _prev_slot =","counters":[]},{"line":"          Global_slot.Checked.to_epoch_and_slot prev_global_slot","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"        in","counters":[]},{"line":"        let%bind global_slot_since_genesis =","counters":[]},{"line":"          Mina_numbers.Global_slot.Checked.add","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"            previous_state.global_slot_since_genesis slot_diff","counters":[]},{"line":"        in","counters":[]},{"line":"        let%bind epoch_increased = Epoch.Checked.(prev_epoch < next_epoch) in","counters":[]},{"line":"        let%bind staking_epoch_data =","counters":[]},{"line":"          Epoch_data.if_ epoch_increased ~then_:previous_state.next_epoch_data","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"            ~else_:previous_state.staking_epoch_data","counters":[]},{"line":"        in","counters":[]},{"line":"        let next_slot_number = Global_slot.slot_number next_global_slot in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let%bind block_stake_winner =","counters":[]},{"line":"          exists Public_key.Compressed.typ","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"            ~request:As_prover.(return Vrf.Winner_pk)","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"        in","counters":[]},{"line":"        let%bind block_creator =","counters":[]},{"line":"          let%bind.Checked bc_compressed =","counters":[]},{"line":"            exists Public_key.typ","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"              ~request:As_prover.(return Vrf.Producer_public_key)","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"          in","counters":[]},{"line":"          Public_key.compress_var bc_compressed","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        in","counters":[]},{"line":"        let%bind coinbase_receiver =","counters":[]},{"line":"          exists Public_key.Compressed.typ","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"            ~request:As_prover.(return Vrf.Coinbase_receiver_pk)","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"        in","counters":[]},{"line":"        let%bind ( threshold_satisfied","counters":[]},{"line":"                 , vrf_result","counters":[]},{"line":"                 , truncated_vrf_result","counters":[]},{"line":"                 , winner_account ) =","counters":[]},{"line":"          let%bind (module M) = Inner_curve.Checked.Shifted.create () in","counters":[{"col_start":65,"col_end":65,"count":0}]},{"line":"          Vrf.Checked.check ~constraint_constants","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (module M)","counters":[]},{"line":"            ~epoch_ledger:staking_epoch_data.ledger","counters":[]},{"line":"            ~global_slot:next_slot_number ~block_stake_winner ~block_creator","counters":[]},{"line":"            ~seed:staking_epoch_data.seed","counters":[]},{"line":"        in","counters":[]},{"line":"        let%bind supercharge_coinbase =","counters":[]},{"line":"          compute_supercharge_coinbase ~winner_account","counters":[]},{"line":"            ~global_slot:global_slot_since_genesis","counters":[]},{"line":"        in","counters":[]},{"line":"        let%bind new_total_currency, `Overflow overflow =","counters":[]},{"line":"          Currency.Amount.Checked.add_signed_flagged","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"            previous_state.total_currency supply_increase","counters":[]},{"line":"        in","counters":[]},{"line":"        let%bind () =","counters":[]},{"line":"          [%with_label_ \"Total currency is greater than or equal to zero\"]","counters":[{"col_start":72,"col_end":72,"count":0},{"col_start":73,"col_end":73,"count":0}]},{"line":"            (fun () -> Boolean.Assert.is_true (Boolean.not overflow))","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"        in","counters":[]},{"line":"        let%bind has_ancestor_in_same_checkpoint_window =","counters":[]},{"line":"          same_checkpoint_window ~constants ~prev:prev_global_slot","counters":[]},{"line":"            ~next:next_global_slot","counters":[]},{"line":"        in","counters":[]},{"line":"        let%bind in_seed_update_range =","counters":[]},{"line":"          Slot.Checked.in_seed_update_range next_slot ~constants","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"        in","counters":[]},{"line":"        let%bind update_next_epoch_ledger =","counters":[]},{"line":"          (*If snarked ledger hash is still the genesis ledger hash then the epoch ledger should continue to be `next_data.ledger`. This is because the epoch ledgers at genesis can be different from the genesis ledger*)","counters":[]},{"line":"          let%bind snarked_ledger_is_still_genesis =","counters":[]},{"line":"            Mina_base.Frozen_ledger_hash.equal_var genesis_ledger_hash","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"              previous_blockchain_state_ledger_hash","counters":[]},{"line":"          in","counters":[]},{"line":"          Boolean.(epoch_increased &&& not snarked_ledger_is_still_genesis)","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        in","counters":[]},{"line":"        let%bind next_epoch_data =","counters":[]},{"line":"          let%map seed =","counters":[]},{"line":"            let base = previous_state.next_epoch_data.seed in","counters":[]},{"line":"            let%bind updated = Epoch_seed.update_var base vrf_result in","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"            Epoch_seed.if_ in_seed_update_range ~then_:updated ~else_:base","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          and epoch_length =","counters":[]},{"line":"            let open Length.Checked in","counters":[]},{"line":"            let%bind base =","counters":[]},{"line":"              if_ epoch_increased ~then_:zero","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                ~else_:previous_state.next_epoch_data.epoch_length","counters":[]},{"line":"            in","counters":[]},{"line":"            succ base","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          and ledger =","counters":[]},{"line":"            Epoch_ledger.if_ update_next_epoch_ledger","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"              ~then_:","counters":[]},{"line":"                { total_currency = new_total_currency","counters":[]},{"line":"                ; hash = previous_blockchain_state_ledger_hash","counters":[]},{"line":"                }","counters":[]},{"line":"              ~else_:previous_state.next_epoch_data.ledger","counters":[]},{"line":"          and start_checkpoint =","counters":[]},{"line":"            Mina_base.State_hash.if_ epoch_increased","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"              ~then_:previous_protocol_state_hash","counters":[]},{"line":"              ~else_:previous_state.next_epoch_data.start_checkpoint","counters":[]},{"line":"          (* Want this to be the protocol state hash once we leave the seed","counters":[]},{"line":"             update range. *)","counters":[]},{"line":"          and lock_checkpoint =","counters":[]},{"line":"            let%bind base =","counters":[]},{"line":"              (* TODO: Should this be zero or some other sentinel value? *)","counters":[]},{"line":"              Mina_base.State_hash.if_ epoch_increased","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                ~then_:Mina_base.State_hash.(var_of_t (of_hash zero))","counters":[{"col_start":52,"col_end":52,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"                ~else_:previous_state.next_epoch_data.lock_checkpoint","counters":[]},{"line":"            in","counters":[]},{"line":"            Mina_base.State_hash.if_ in_seed_update_range","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              ~then_:previous_protocol_state_hash ~else_:base","counters":[]},{"line":"          in","counters":[]},{"line":"          { Epoch_data.Poly.seed","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          ; epoch_length","counters":[]},{"line":"          ; ledger","counters":[]},{"line":"          ; start_checkpoint","counters":[]},{"line":"          ; lock_checkpoint","counters":[]},{"line":"          }","counters":[]},{"line":"        and blockchain_length =","counters":[]},{"line":"          Length.Checked.succ previous_state.blockchain_length","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"        and epoch_count =","counters":[]},{"line":"          Length.Checked.succ_if previous_state.epoch_count epoch_increased","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"        and min_window_density, sub_window_densities =","counters":[]},{"line":"          Min_window_density.Checked.update_min_window_density ~constants","counters":[]},{"line":"            ~prev_global_slot ~next_global_slot","counters":[]},{"line":"            ~prev_sub_window_densities:previous_state.sub_window_densities","counters":[]},{"line":"            ~prev_min_window_density:previous_state.min_window_density","counters":[]},{"line":"        in","counters":[]},{"line":"        Checked.return","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ( `Success threshold_satisfied","counters":[]},{"line":"          , { Poly.blockchain_length","counters":[]},{"line":"            ; epoch_count","counters":[]},{"line":"            ; min_window_density","counters":[]},{"line":"            ; sub_window_densities","counters":[]},{"line":"            ; last_vrf_output = truncated_vrf_result","counters":[]},{"line":"            ; curr_global_slot = next_global_slot","counters":[]},{"line":"            ; global_slot_since_genesis","counters":[]},{"line":"            ; total_currency = new_total_currency","counters":[]},{"line":"            ; staking_epoch_data","counters":[]},{"line":"            ; next_epoch_data","counters":[]},{"line":"            ; has_ancestor_in_same_checkpoint_window","counters":[]},{"line":"            ; block_stake_winner","counters":[]},{"line":"            ; block_creator","counters":[]},{"line":"            ; coinbase_receiver","counters":[]},{"line":"            ; supercharge_coinbase","counters":[]},{"line":"            } )","counters":[]},{"line":"","counters":[]},{"line":"      type display =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { blockchain_length : int","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"        ; epoch_count : int","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"        ; curr_epoch : int","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"        ; curr_slot : int","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"        ; global_slot_since_genesis : int","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"        ; total_currency : int","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"        }","counters":[]},{"line":"      [@@deriving yojson]","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"","counters":[]},{"line":"      let display (t : Value.t) =","counters":[]},{"line":"        let epoch, slot = Global_slot.to_epoch_and_slot t.curr_global_slot in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        { blockchain_length = Length.to_int t.blockchain_length","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"        ; epoch_count = Length.to_int t.epoch_count","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"        ; curr_epoch = Segment_id.to_int epoch","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"        ; curr_slot = Segment_id.to_int slot","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"        ; global_slot_since_genesis =","counters":[]},{"line":"            Mina_numbers.Global_slot.to_int t.global_slot_since_genesis","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"        ; total_currency = Amount.to_int t.total_currency","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"      let curr_global_slot (t : Value.t) = t.curr_global_slot","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"","counters":[]},{"line":"      let curr_ f = Fn.compose f curr_global_slot","counters":[{"col_start":20,"col_end":20,"count":3}]},{"line":"","counters":[]},{"line":"      let curr_epoch_and_slot = curr_ Global_slot.to_epoch_and_slot","counters":[{"col_start":36,"col_end":36,"count":1}]},{"line":"","counters":[]},{"line":"      let curr_epoch = curr_ Global_slot.epoch","counters":[{"col_start":27,"col_end":27,"count":1}]},{"line":"","counters":[]},{"line":"      let curr_slot = curr_ Global_slot.slot","counters":[{"col_start":26,"col_end":26,"count":1}]},{"line":"","counters":[]},{"line":"      let blockchain_length_var (t : var) = t.blockchain_length","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"      let min_window_density_var (t : var) = t.min_window_density","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"","counters":[]},{"line":"      let total_currency_var (t : var) = t.total_currency","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"","counters":[]},{"line":"      let staking_epoch_data_var (t : var) : Epoch_data.var =","counters":[]},{"line":"        t.staking_epoch_data","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      let staking_epoch_data (t : Value.t) = t.staking_epoch_data","counters":[{"col_start":45,"col_end":45,"count":1}]},{"line":"","counters":[]},{"line":"      let next_epoch_data_var (t : var) : Epoch_data.var = t.next_epoch_data","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"","counters":[]},{"line":"      let next_epoch_data (t : Value.t) = t.next_epoch_data","counters":[{"col_start":42,"col_end":42,"count":1}]},{"line":"","counters":[]},{"line":"      let coinbase_receiver_var (t : var) = t.coinbase_receiver","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"      let curr_global_slot_var (t : var) =","counters":[]},{"line":"        Global_slot.slot_number t.curr_global_slot","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      let curr_global_slot (t : Value.t) =","counters":[]},{"line":"        Global_slot.slot_number t.curr_global_slot","counters":[{"col_start":8,"col_end":8,"count":1}]},{"line":"","counters":[]},{"line":"      let consensus_time (t : Value.t) = t.curr_global_slot","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"","counters":[]},{"line":"      let global_slot_since_genesis_var (t : var) = t.global_slot_since_genesis","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"","counters":[]},{"line":"      [%%define_locally","counters":[]},{"line":"      Poly.","counters":[]},{"line":"        ( blockchain_length","counters":[]},{"line":"        , min_window_density","counters":[]},{"line":"        , total_currency","counters":[]},{"line":"        , global_slot_since_genesis","counters":[]},{"line":"        , block_stake_winner","counters":[]},{"line":"        , block_creator","counters":[]},{"line":"        , coinbase_receiver )]","counters":[]},{"line":"","counters":[]},{"line":"      module Unsafe = struct","counters":[]},{"line":"        (* TODO: very unsafe, do not use unless you know what you are doing *)","counters":[]},{"line":"        let dummy_advance (t : Value.t) ?(increase_epoch_count = false)","counters":[{"col_start":65,"col_end":65,"count":0}]},{"line":"            ~new_global_slot : Value.t =","counters":[]},{"line":"          let new_epoch_count =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            if increase_epoch_count then Length.succ t.epoch_count","counters":[{"col_start":41,"col_end":41,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"            else t.epoch_count","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"          in","counters":[]},{"line":"          { t with","counters":[]},{"line":"            epoch_count = new_epoch_count","counters":[]},{"line":"          ; curr_global_slot = new_global_slot","counters":[]},{"line":"          }","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      let graphql_type () : ('ctx, Value.t option) Graphql_async.Schema.typ =","counters":[]},{"line":"        let open Graphql_async in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let open Signature_lib_unix.Graphql_scalars in","counters":[]},{"line":"        let public_key = PublicKey.typ () in","counters":[]},{"line":"        let open Schema in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let length = Mina_numbers_unix.Graphql_scalars.Length.typ () in","counters":[]},{"line":"        let amount = Currency_unix.Graphql_scalars.Amount.typ () in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        obj \"ConsensusState\" ~fields:(fun _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            [ field \"blockchainLength\" ~typ:(non_null length)","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"                ~doc:\"Length of the blockchain at this block\"","counters":[]},{"line":"                ~deprecated:(Deprecated (Some \"use blockHeight instead\"))","counters":[]},{"line":"                ~args:Arg.[]","counters":[]},{"line":"                ~resolve:(fun _ { Poly.blockchain_length; _ } ->","counters":[]},{"line":"                  blockchain_length )","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"            ; field \"blockHeight\" ~typ:(non_null length)","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"                ~doc:\"Height of the blockchain at this block\"","counters":[]},{"line":"                ~args:Arg.[]","counters":[]},{"line":"                ~resolve:(fun _ { Poly.blockchain_length; _ } ->","counters":[]},{"line":"                  blockchain_length )","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"            ; field \"epochCount\" ~typ:(non_null length)","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"                ~args:Arg.[]","counters":[]},{"line":"                ~resolve:(fun _ { Poly.epoch_count; _ } -> epoch_count)","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"            ; field \"minWindowDensity\" ~typ:(non_null length)","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"                ~args:Arg.[]","counters":[]},{"line":"                ~resolve:(fun _ { Poly.min_window_density; _ } ->","counters":[]},{"line":"                  min_window_density )","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"            ; field \"lastVrfOutput\" ~typ:(non_null string)","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"                ~args:Arg.[]","counters":[]},{"line":"                ~resolve:(fun (_ : 'ctx resolve_info)","counters":[]},{"line":"                              { Poly.last_vrf_output; _ } ->","counters":[]},{"line":"                  Vrf.Output.Truncated.to_base58_check last_vrf_output )","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"            ; field \"totalCurrency\"","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                ~doc:\"Total currency in circulation at this block\"","counters":[]},{"line":"                ~typ:(non_null amount)","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                ~args:Arg.[]","counters":[]},{"line":"                ~resolve:(fun _ { Poly.total_currency; _ } -> total_currency)","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"            ; field \"stakingEpochData\"","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                ~typ:","counters":[]},{"line":"                  ( non_null","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                  @@ Epoch_data.Staking.graphql_type \"StakingEpochData\" )","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                ~args:Arg.[]","counters":[]},{"line":"                ~resolve:(fun (_ : 'ctx resolve_info)","counters":[]},{"line":"                              { Poly.staking_epoch_data; _ } ->","counters":[]},{"line":"                  staking_epoch_data )","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"            ; field \"nextEpochData\"","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                ~typ:(non_null @@ Epoch_data.Next.graphql_type \"NextEpochData\")","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"                ~args:Arg.[]","counters":[]},{"line":"                ~resolve:(fun (_ : 'ctx resolve_info)","counters":[]},{"line":"                              { Poly.next_epoch_data; _ } -> next_epoch_data )","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"            ; field \"hasAncestorInSameCheckpointWindow\" ~typ:(non_null bool)","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"                ~args:Arg.[]","counters":[]},{"line":"                ~resolve:(fun _","counters":[]},{"line":"                              { Poly.has_ancestor_in_same_checkpoint_window; _ } ->","counters":[]},{"line":"                  has_ancestor_in_same_checkpoint_window )","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"            ; field \"slot\" ~doc:\"Slot in which this block was created\"","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                ~typ:(non_null @@ Graphql_scalars.Slot.typ ())","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"                ~args:Arg.[]","counters":[]},{"line":"                ~resolve:(fun _ { Poly.curr_global_slot; _ } ->","counters":[]},{"line":"                  Global_slot.slot curr_global_slot )","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"            ; field \"slotSinceGenesis\"","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                ~doc:\"Slot since genesis (across all hard-forks)\"","counters":[]},{"line":"                ~typ:","counters":[]},{"line":"                  ( non_null","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                  @@ Mina_numbers_unix.Graphql_scalars.GlobalSlot.typ () )","counters":[{"col_start":68,"col_end":68,"count":0}]},{"line":"                ~args:Arg.[]","counters":[]},{"line":"                ~resolve:(fun _ { Poly.global_slot_since_genesis; _ } ->","counters":[]},{"line":"                  global_slot_since_genesis )","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"            ; field \"epoch\" ~doc:\"Epoch in which this block was created\"","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                ~typ:(non_null @@ Graphql_scalars.Epoch.typ ())","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"                ~args:Arg.[]","counters":[]},{"line":"                ~resolve:(fun _ { Poly.curr_global_slot; _ } ->","counters":[]},{"line":"                  Global_slot.epoch curr_global_slot )","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"            ; field \"superchargedCoinbase\" ~typ:(non_null bool)","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"                ~doc:","counters":[]},{"line":"                  \"Whether or not this coinbase was \\\"supercharged\\\", ie. \\","counters":[]},{"line":"                   created by an account that has no locked tokens\"","counters":[]},{"line":"                ~args:Arg.[]","counters":[]},{"line":"                ~resolve:(fun _ { Poly.supercharge_coinbase; _ } ->","counters":[]},{"line":"                  supercharge_coinbase )","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"            ; field \"blockStakeWinner\" ~typ:(non_null public_key)","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"                ~doc:","counters":[]},{"line":"                  \"The public key that is responsible for winning this block \\","counters":[]},{"line":"                   (including delegations)\"","counters":[]},{"line":"                ~args:Arg.[]","counters":[]},{"line":"                ~resolve:(fun _ { Poly.block_stake_winner; _ } ->","counters":[]},{"line":"                  block_stake_winner )","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"            ; field \"blockCreator\" ~typ:(non_null public_key)","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"                ~doc:\"The block producer public key that created this block\"","counters":[]},{"line":"                ~args:Arg.[]","counters":[]},{"line":"                ~resolve:(fun _ { Poly.block_creator; _ } -> block_creator)","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"            ; field \"coinbaseReceiever\" ~typ:(non_null public_key)","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"                ~args:Arg.[]","counters":[]},{"line":"                ~resolve:(fun _ { Poly.coinbase_receiver; _ } ->","counters":[]},{"line":"                  coinbase_receiver )","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"            ] )","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Prover_state = struct","counters":[]},{"line":"      include Stake_proof","counters":[]},{"line":"","counters":[]},{"line":"      let genesis_data = Vrf.Precomputed.genesis_stake_proof","counters":[]},{"line":"","counters":[]},{"line":"      let precomputed_handler = Vrf.Precomputed.handler","counters":[]},{"line":"","counters":[]},{"line":"      let handler","counters":[]},{"line":"          { delegator","counters":[]},{"line":"          ; delegator_pk","counters":[]},{"line":"          ; coinbase_receiver_pk","counters":[]},{"line":"          ; ledger","counters":[]},{"line":"          ; producer_private_key","counters":[]},{"line":"          ; producer_public_key","counters":[]},{"line":"          } ~(constraint_constants : Genesis_constants.Constraint_constants.t)","counters":[]},{"line":"          ~pending_coinbase:","counters":[]},{"line":"            { Mina_base.Pending_coinbase_witness.pending_coinbases","counters":[]},{"line":"            ; is_new_stack","counters":[]},{"line":"            } : Snark_params.Tick.Handler.t =","counters":[]},{"line":"        let ledger_handler =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          unstage (Mina_ledger.Sparse_ledger.handler ledger)","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"        in","counters":[]},{"line":"        let pending_coinbase_handler =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          unstage","counters":[]},{"line":"            (Mina_base.Pending_coinbase.handler","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"               ~depth:constraint_constants.pending_coinbase_depth","counters":[]},{"line":"               pending_coinbases ~is_new_stack )","counters":[]},{"line":"        in","counters":[]},{"line":"        let handlers =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Snarky_backendless.Request.Handler.(","counters":[]},{"line":"            push","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"              (push fail (create_single pending_coinbase_handler))","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"              (create_single ledger_handler))","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"        in","counters":[]},{"line":"        fun (With { request; respond }) ->","counters":[]},{"line":"          match request with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | Vrf.Winner_address ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              respond (Provide delegator)","counters":[]},{"line":"          | Vrf.Winner_pk ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              respond (Provide delegator_pk)","counters":[]},{"line":"          | Vrf.Coinbase_receiver_pk ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              respond (Provide coinbase_receiver_pk)","counters":[]},{"line":"          | Vrf.Producer_private_key ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              respond (Provide producer_private_key)","counters":[]},{"line":"          | Vrf.Producer_public_key ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              respond (Provide producer_public_key)","counters":[]},{"line":"          | _ ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              respond","counters":[]},{"line":"                (Provide","counters":[]},{"line":"                   (Snarky_backendless.Request.Handler.run handlers","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"                      [ \"Ledger Handler\"; \"Pending Coinbase Handler\" ]","counters":[]},{"line":"                      request ) )","counters":[]},{"line":"","counters":[]},{"line":"      let ledger_depth { ledger; _ } = ledger.depth","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"    end","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Coinbase_receiver = struct","counters":[]},{"line":"    type t = [ `Producer | `Other of Public_key.Compressed.t ]","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"    [@@deriving yojson]","counters":[]},{"line":"","counters":[]},{"line":"    let resolve ~self : t -> Public_key.Compressed.t = function","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"      | `Producer ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          self","counters":[]},{"line":"      | `Other pk ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          pk","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Hooks = struct","counters":[]},{"line":"    open Data","counters":[]},{"line":"","counters":[]},{"line":"    module Rpcs = struct","counters":[]},{"line":"      open Async","counters":[]},{"line":"","counters":[]},{"line":"      [%%versioned_rpc","counters":[]},{"line":"      module Get_epoch_ledger = struct","counters":[]},{"line":"        module Master = struct","counters":[]},{"line":"          let name = \"get_epoch_ledger\"","counters":[]},{"line":"","counters":[]},{"line":"          module T = struct","counters":[]},{"line":"            type query = Mina_base.Ledger_hash.t","counters":[]},{"line":"","counters":[]},{"line":"            type response = (Mina_ledger.Sparse_ledger.t, string) Result.t","counters":[]},{"line":"          end","counters":[]},{"line":"","counters":[]},{"line":"          module Caller = T","counters":[]},{"line":"          module Callee = T","counters":[]},{"line":"        end","counters":[]},{"line":"","counters":[]},{"line":"        include Master.T","counters":[]},{"line":"","counters":[]},{"line":"        let sent_counter = Mina_metrics.Network.get_epoch_ledger_rpcs_sent","counters":[]},{"line":"","counters":[]},{"line":"        let received_counter =","counters":[]},{"line":"          Mina_metrics.Network.get_epoch_ledger_rpcs_received","counters":[]},{"line":"","counters":[]},{"line":"        let failed_request_counter =","counters":[]},{"line":"          Mina_metrics.Network.get_epoch_ledger_rpc_requests_failed","counters":[]},{"line":"","counters":[]},{"line":"        let failed_response_counter =","counters":[]},{"line":"          Mina_metrics.Network.get_epoch_ledger_rpc_responses_failed","counters":[]},{"line":"","counters":[]},{"line":"        module M = Versioned_rpc.Both_convert.Plain.Make (Master)","counters":[]},{"line":"        include M","counters":[]},{"line":"","counters":[]},{"line":"        include Perf_histograms.Rpc.Plain.Extend (struct","counters":[]},{"line":"          include M","counters":[]},{"line":"          include Master","counters":[]},{"line":"        end)","counters":[]},{"line":"","counters":[]},{"line":"        module V2 = struct","counters":[{"col_start":8,"col_end":8,"count":3}]},{"line":"          module T = struct","counters":[]},{"line":"            type query = Mina_base.Ledger_hash.Stable.V1.t","counters":[{"col_start":12,"col_end":12,"count":1},{"col_start":21,"col_end":21,"count":1},{"col_start":57,"col_end":57,"count":4}]},{"line":"","counters":[]},{"line":"            type response =","counters":[{"col_start":12,"col_end":12,"count":1},{"col_start":24,"col_end":24,"count":1}]},{"line":"              ( Mina_ledger.Sparse_ledger.Stable.V2.t","counters":[]},{"line":"              , string )","counters":[]},{"line":"              Core_kernel.Result.Stable.V1.t","counters":[{"col_start":43,"col_end":43,"count":4}]},{"line":"","counters":[]},{"line":"            let query_of_caller_model = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"            let callee_model_of_query = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"            let response_of_callee_model = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"            let caller_model_of_response = Fn.id","counters":[]},{"line":"          end","counters":[]},{"line":"","counters":[]},{"line":"          module T' =","counters":[]},{"line":"            Perf_histograms.Rpc.Plain.Decorate_bin_io","counters":[]},{"line":"              (struct","counters":[]},{"line":"                include M","counters":[]},{"line":"                include Master","counters":[]},{"line":"              end)","counters":[]},{"line":"              (T)","counters":[]},{"line":"","counters":[]},{"line":"          include T'","counters":[]},{"line":"          include Register (T')","counters":[]},{"line":"        end","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"","counters":[]},{"line":"        let implementation ~context:(module Context : CONTEXT) ~local_state","counters":[]},{"line":"            ~genesis_ledger_hash conn ~version:_ ledger_hash =","counters":[]},{"line":"          let open Context in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let open Mina_base in","counters":[]},{"line":"          let open Local_state in","counters":[]},{"line":"          let open Snapshot in","counters":[]},{"line":"          Deferred.create (fun ivar ->","counters":[]},{"line":"              [%log info]","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"                ~metadata:","counters":[]},{"line":"                  [ (\"peer\", Network_peer.Peer.to_yojson conn)","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"                  ; (\"ledger_hash\", Mina_base.Ledger_hash.to_yojson ledger_hash)","counters":[{"col_start":66,"col_end":66,"count":0}]},{"line":"                  ]","counters":[]},{"line":"                \"Serving epoch ledger query with hash $ledger_hash from $peer\" ;","counters":[]},{"line":"              let response =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                if","counters":[]},{"line":"                  Ledger_hash.equal ledger_hash","counters":[]},{"line":"                    (Frozen_ledger_hash.to_ledger_hash genesis_ledger_hash)","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"                then Error \"refusing to serve genesis ledger\"","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                else","counters":[]},{"line":"                  let candidate_snapshots =","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    [ !local_state.Data.staking_epoch_snapshot","counters":[]},{"line":"                    ; !local_state.Data.next_epoch_snapshot","counters":[]},{"line":"                    ]","counters":[]},{"line":"                  in","counters":[]},{"line":"                  let res =","counters":[]},{"line":"                    List.find_map candidate_snapshots ~f:(fun snapshot ->","counters":[]},{"line":"                        (* if genesis epoch ledger is different from genesis ledger*)","counters":[]},{"line":"                        match snapshot.ledger with","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                        | Genesis_epoch_ledger genesis_epoch_ledger ->","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            if","counters":[]},{"line":"                              Ledger_hash.equal ledger_hash","counters":[]},{"line":"                                (Mina_ledger.Ledger.merkle_root","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"                                   genesis_epoch_ledger )","counters":[]},{"line":"                            then","counters":[]},{"line":"                              Some","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                                (Error \"refusing to serve genesis epoch ledger\")","counters":[]},{"line":"                            else None","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"                        | Ledger_db ledger ->","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            if","counters":[]},{"line":"                              Ledger_hash.equal ledger_hash","counters":[]},{"line":"                                (Mina_ledger.Ledger.Db.merkle_root ledger)","counters":[{"col_start":65,"col_end":65,"count":0}]},{"line":"                            then","counters":[]},{"line":"                              Some","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                                (Ok","counters":[]},{"line":"                                   ( Mina_ledger.Sparse_ledger.of_any_ledger","counters":[{"col_start":75,"col_end":75,"count":0}]},{"line":"                                   @@ Mina_ledger.Ledger.Any_ledger.cast_database_to_mask","counters":[{"col_start":88,"col_end":88,"count":0}]},{"line":"                                        (module Mina_ledger.Ledger.Db)","counters":[]},{"line":"                                        ledger ) )","counters":[]},{"line":"                            else None )","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"                  in","counters":[]},{"line":"                  Option.value res ~default:(Error \"epoch ledger not found\")","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"              in","counters":[]},{"line":"              Result.iter_error response ~f:(fun err ->","counters":[]},{"line":"                  Mina_metrics.Counter.inc_one failed_response_counter ;","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  [%log info]","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"                    ~metadata:","counters":[]},{"line":"                      [ (\"peer\", Network_peer.Peer.to_yojson conn)","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"                      ; (\"error\", `String err)","counters":[]},{"line":"                      ; ( \"ledger_hash\"","counters":[]},{"line":"                        , Mina_base.Ledger_hash.to_yojson ledger_hash )","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"                      ]","counters":[]},{"line":"                    \"Failed to serve epoch ledger query with hash $ledger_hash \\","counters":[]},{"line":"                     from $peer: $error\" ) ;","counters":[]},{"line":"              if Ivar.is_full ivar then [%log error] \"Ivar.fill bug is here!\" ;","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"              Ivar.fill ivar response )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"      end]","counters":[]},{"line":"","counters":[]},{"line":"      open Network_peer.Rpc_intf","counters":[]},{"line":"","counters":[]},{"line":"      type ('query, 'response) rpc =","counters":[]},{"line":"        | Get_epoch_ledger","counters":[]},{"line":"            : (Get_epoch_ledger.query, Get_epoch_ledger.response) rpc","counters":[]},{"line":"","counters":[]},{"line":"      type rpc_handler =","counters":[]},{"line":"        | Rpc_handler :","counters":[]},{"line":"            { rpc : ('q, 'r) rpc","counters":[]},{"line":"            ; f : ('q, 'r) rpc_fn","counters":[]},{"line":"            ; cost : 'q -> int","counters":[]},{"line":"            ; budget : int * [ `Per of Core.Time.Span.t ]","counters":[]},{"line":"            }","counters":[]},{"line":"            -> rpc_handler","counters":[]},{"line":"","counters":[]},{"line":"      type query =","counters":[]},{"line":"        { query :","counters":[]},{"line":"            'q 'r.","counters":[]},{"line":"               Network_peer.Peer.t","counters":[]},{"line":"            -> ('q, 'r) rpc","counters":[]},{"line":"            -> 'q","counters":[]},{"line":"            -> 'r Network_peer.Rpc_intf.rpc_response Deferred.t","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"      let implementation_of_rpc :","counters":[]},{"line":"          type q r. (q, r) rpc -> (q, r) rpc_implementation = function","counters":[]},{"line":"        | Get_epoch_ledger ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (module Get_epoch_ledger)","counters":[]},{"line":"","counters":[]},{"line":"      let match_handler :","counters":[]},{"line":"          type q r.","counters":[]},{"line":"          rpc_handler -> (q, r) rpc -> do_:((q, r) rpc_fn -> 'a) -> 'a option =","counters":[]},{"line":"       fun handler rpc ~do_ ->","counters":[]},{"line":"        match (rpc, handler) with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | Get_epoch_ledger, Rpc_handler { rpc = Get_epoch_ledger; f; _ } ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Some (do_ f)","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"","counters":[]},{"line":"      let rpc_handlers ~context:(module Context : CONTEXT) ~local_state","counters":[]},{"line":"          ~genesis_ledger_hash =","counters":[]},{"line":"        [ Rpc_handler","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            { rpc = Get_epoch_ledger","counters":[]},{"line":"            ; f =","counters":[]},{"line":"                Get_epoch_ledger.implementation","counters":[]},{"line":"                  ~context:(module Context)","counters":[]},{"line":"                  ~local_state ~genesis_ledger_hash","counters":[]},{"line":"            ; cost = (fun _ -> 1)","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"            ; budget = (2, `Per Core.Time.Span.minute)","counters":[]},{"line":"            }","counters":[]},{"line":"        ]","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    let is_genesis_epoch ~(constants : Constants.t) time =","counters":[]},{"line":"      Epoch.(equal (of_time_exn ~constants time) zero)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"","counters":[]},{"line":"    (* Select the correct epoch data to use from a consensus state for a given epoch.","counters":[]},{"line":"     * The rule for selecting the correct epoch data changes based on whether or not","counters":[]},{"line":"     * the consensus state we are selecting from is in the epoch we want to select.","counters":[]},{"line":"     * There is also a special case for when the consensus state we are selecting","counters":[]},{"line":"     * from is in the genesis epoch.","counters":[]},{"line":"     *)","counters":[]},{"line":"    let select_epoch_data ~(consensus_state : Consensus_state.Value.t) ~epoch =","counters":[]},{"line":"      let curr_epoch = Consensus_state.curr_epoch consensus_state in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      (* are we in the same epoch as the consensus state? *)","counters":[]},{"line":"      let in_same_epoch = Epoch.equal epoch curr_epoch in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      (* are we in the next epoch after the consensus state? *)","counters":[]},{"line":"      let in_next_epoch = Epoch.equal epoch (Epoch.succ curr_epoch) in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"      (* is the consensus state from the genesis epoch? *)","counters":[]},{"line":"      let from_genesis_epoch =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Length.equal consensus_state.epoch_count Length.zero","counters":[]},{"line":"      in","counters":[]},{"line":"      let in_initial_epoch = Epoch.(equal zero) epoch in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"      if in_next_epoch then","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Ok (Epoch_data.next_to_staking consensus_state.next_epoch_data)","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"      else if in_same_epoch || (from_genesis_epoch && in_initial_epoch) then","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":54,"col_end":54,"count":0},{"col_start":70,"col_end":70,"count":0}]},{"line":"        Ok consensus_state.staking_epoch_data","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      else Error ()","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"","counters":[]},{"line":"    let epoch_snapshot_name = function","counters":[]},{"line":"      | `Genesis ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          \"genesis\"","counters":[]},{"line":"      | `Curr ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          \"curr\"","counters":[]},{"line":"      | `Last ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          \"last\"","counters":[]},{"line":"","counters":[]},{"line":"    (* Select the correct epoch snapshot to use from local state for an epoch.","counters":[]},{"line":"     * The rule for selecting the correct epoch snapshot is predicated off of","counters":[]},{"line":"     * whether or not the first transition in the epoch in question has been","counters":[]},{"line":"     * finalized yet, as the local state epoch snapshot pointers are not","counters":[]},{"line":"     * updated until the consensus state reaches the root of the transition","counters":[]},{"line":"     * frontier.This does not apply to the genesis epoch where we should always","counters":[]},{"line":"     * take the staking epoch snapshot because epoch ledger transition will not","counters":[]},{"line":"     * happen for genesis epoch.","counters":[]},{"line":"     * This function does not guarantee that the selected epoch snapshot is valid","counters":[]},{"line":"     * (i.e. it does not check that the epoch snapshot's ledger hash is the same","counters":[]},{"line":"     * as the ledger hash specified by the epoch data).","counters":[]},{"line":"     *)","counters":[]},{"line":"    let select_epoch_snapshot ~(constants : Constants.t)","counters":[]},{"line":"        ~(consensus_state : Consensus_state.Value.t) ~local_state ~epoch =","counters":[]},{"line":"      let open Local_state in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let open Epoch_data.Poly in","counters":[]},{"line":"      (* are we in the next epoch after the consensus state? *)","counters":[]},{"line":"      let in_next_epoch =","counters":[]},{"line":"        Epoch.equal epoch","counters":[]},{"line":"          (Epoch.succ (Consensus_state.curr_epoch consensus_state))","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"      in","counters":[]},{"line":"      (* has the first transition in the epoch (other than the genesis epoch) reached finalization? *)","counters":[]},{"line":"      let epoch_is_not_finalized =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let is_genesis_epoch = Length.equal epoch Length.zero in","counters":[]},{"line":"        let epoch_is_finalized =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Length.(consensus_state.next_epoch_data.epoch_length > constants.k)","counters":[]},{"line":"        in","counters":[]},{"line":"        (not epoch_is_finalized) && not is_genesis_epoch","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"      in","counters":[]},{"line":"      if in_next_epoch || epoch_is_not_finalized then","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"        (`Curr, !local_state.Data.next_epoch_snapshot)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      else (`Last, !local_state.staking_epoch_snapshot)","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"","counters":[]},{"line":"    let get_epoch_ledger ~constants ~(consensus_state : Consensus_state.Value.t)","counters":[]},{"line":"        ~local_state =","counters":[]},{"line":"      let _, snapshot =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        select_epoch_snapshot ~constants ~consensus_state","counters":[]},{"line":"          ~epoch:(Data.Consensus_state.curr_epoch consensus_state)","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"          ~local_state","counters":[]},{"line":"      in","counters":[]},{"line":"      Data.Local_state.Snapshot.ledger snapshot","counters":[]},{"line":"","counters":[]},{"line":"    type required_snapshot =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      { snapshot_id : Local_state.snapshot_identifier","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"      ; expected_root : Mina_base.Frozen_ledger_hash.t","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"      }","counters":[]},{"line":"    [@@deriving to_yojson]","counters":[]},{"line":"","counters":[]},{"line":"    type local_state_sync =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      | One of required_snapshot","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"      | Both of","counters":[]},{"line":"          { next : Mina_base.Frozen_ledger_hash.t","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"          ; staking : Mina_base.Frozen_ledger_hash.t","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"          }","counters":[]},{"line":"    [@@deriving to_yojson]","counters":[]},{"line":"","counters":[]},{"line":"    let local_state_sync_count (s : local_state_sync) =","counters":[]},{"line":"      match s with One _ -> 1 | Both _ -> 2","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"","counters":[]},{"line":"    let required_local_state_sync ~constants","counters":[]},{"line":"        ~(consensus_state : Consensus_state.Value.t) ~local_state =","counters":[]},{"line":"      let open Mina_base in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let epoch = Consensus_state.curr_epoch consensus_state in","counters":[]},{"line":"      let source, _snapshot =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        select_epoch_snapshot ~constants ~consensus_state ~local_state ~epoch","counters":[]},{"line":"      in","counters":[]},{"line":"      let required_snapshot_sync snapshot_id expected_root =","counters":[]},{"line":"        Option.some_if","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (not","counters":[]},{"line":"             (Ledger_hash.equal","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                (Frozen_ledger_hash.to_ledger_hash expected_root)","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"                (Local_state.Snapshot.Ledger_snapshot.merkle_root","counters":[{"col_start":64,"col_end":64,"count":0}]},{"line":"                   (Local_state.get_snapshot local_state snapshot_id).ledger ) ) )","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"          { snapshot_id; expected_root }","counters":[]},{"line":"      in","counters":[]},{"line":"      match source with","counters":[]},{"line":"      | `Curr ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Option.map","counters":[]},{"line":"            (required_snapshot_sync Next_epoch_snapshot","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"               consensus_state.staking_epoch_data.ledger.hash ) ~f:(fun s ->","counters":[]},{"line":"              One s )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"      | `Last -> (","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          match","counters":[]},{"line":"            ( required_snapshot_sync Next_epoch_snapshot","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                consensus_state.next_epoch_data.ledger.hash","counters":[]},{"line":"            , required_snapshot_sync Staking_epoch_snapshot","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                consensus_state.staking_epoch_data.ledger.hash )","counters":[]},{"line":"          with","counters":[]},{"line":"          | None, None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              None","counters":[]},{"line":"          | Some x, None | None, Some x ->","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"              Some (One x)","counters":[]},{"line":"          | Some next, Some staking ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Some","counters":[]},{"line":"                (Both","counters":[]},{"line":"                   { next = next.expected_root","counters":[]},{"line":"                   ; staking = staking.expected_root","counters":[]},{"line":"                   } ) )","counters":[]},{"line":"","counters":[]},{"line":"    let sync_local_state ~context:(module Context : CONTEXT) ~trust_system","counters":[]},{"line":"        ~local_state ~random_peers ~(query_peer : Rpcs.query) requested_syncs =","counters":[]},{"line":"      let open Context in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let open Local_state in","counters":[]},{"line":"      let open Snapshot in","counters":[]},{"line":"      let open Deferred.Let_syntax in","counters":[]},{"line":"      [%log info]","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"        \"Syncing local state; requesting $num_requested snapshots from peers\"","counters":[]},{"line":"        ~metadata:","counters":[]},{"line":"          [ (\"num_requested\", `Int (local_state_sync_count requested_syncs))","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"          ; (\"requested_syncs\", local_state_sync_to_yojson requested_syncs)","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"          ; (\"local_state\", Local_state.to_yojson local_state)","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"          ] ;","counters":[]},{"line":"      let sync { snapshot_id; expected_root = target_ledger_hash } =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (* if requested last epoch ledger is equal to the current epoch ledger","counters":[]},{"line":"           then we don't need make a rpc call to the peers. *)","counters":[]},{"line":"        if","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          equal_snapshot_identifier snapshot_id Staking_epoch_snapshot","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"          && Mina_base.(","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"               Ledger_hash.equal","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                 (Frozen_ledger_hash.to_ledger_hash target_ledger_hash)","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                 (Local_state.Snapshot.Ledger_snapshot.merkle_root","counters":[{"col_start":65,"col_end":65,"count":0}]},{"line":"                    !local_state.next_epoch_snapshot.ledger ))","counters":[]},{"line":"        then (","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"          Local_state.Snapshot.Ledger_snapshot.remove","counters":[]},{"line":"            !local_state.staking_epoch_snapshot.ledger","counters":[]},{"line":"            ~location:(staking_epoch_ledger_location local_state) ;","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"          match !local_state.next_epoch_snapshot.ledger with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | Local_state.Snapshot.Ledger_snapshot.Genesis_epoch_ledger _ ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              set_snapshot local_state Staking_epoch_snapshot","counters":[]},{"line":"                !local_state.next_epoch_snapshot ;","counters":[]},{"line":"              Deferred.Or_error.ok_unit","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"          | Ledger_db next_epoch_ledger ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let ledger =","counters":[]},{"line":"                Mina_ledger.Ledger.Db.create_checkpoint next_epoch_ledger","counters":[]},{"line":"                  ~directory_name:(staking_epoch_ledger_location local_state)","counters":[{"col_start":63,"col_end":63,"count":0}]},{"line":"                  ()","counters":[]},{"line":"              in","counters":[]},{"line":"              set_snapshot local_state Staking_epoch_snapshot","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                { ledger = Ledger_snapshot.Ledger_db ledger","counters":[]},{"line":"                ; delegatee_table =","counters":[]},{"line":"                    !local_state.next_epoch_snapshot.delegatee_table","counters":[]},{"line":"                } ;","counters":[]},{"line":"              Deferred.Or_error.ok_unit )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"        else","counters":[]},{"line":"          let%bind peers = random_peers 5 in","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"          Deferred.List.fold peers","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ~init:","counters":[]},{"line":"              (Or_error.error_string \"Failed to sync epoch ledger: No peers\")","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"            ~f:(fun acc peer ->","counters":[]},{"line":"              match acc with","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              | Ok () ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Deferred.Or_error.ok_unit","counters":[]},{"line":"              | Error _ -> (","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  match%bind","counters":[]},{"line":"                    query_peer.query peer Rpcs.Get_epoch_ledger","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                      (Mina_base.Frozen_ledger_hash.to_ledger_hash","counters":[{"col_start":65,"col_end":65,"count":0}]},{"line":"                         target_ledger_hash )","counters":[]},{"line":"                  with","counters":[]},{"line":"                  | Connected { data = Ok (Ok sparse_ledger); _ } -> (","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      match","counters":[]},{"line":"                        reset_snapshot","counters":[]},{"line":"                          ~context:(module Context)","counters":[]},{"line":"                          local_state snapshot_id ~sparse_ledger","counters":[]},{"line":"                      with","counters":[]},{"line":"                      | Ok () ->","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          (*Don't fail if recording fails*)","counters":[]},{"line":"                          don't_wait_for","counters":[]},{"line":"                            Trust_system.(","counters":[]},{"line":"                              record trust_system logger peer","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                                Actions.(Epoch_ledger_provided, None)) ;","counters":[]},{"line":"                          Deferred.Or_error.ok_unit","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                      | Error e ->","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          [%log faulty_peer_without_punishment]","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"                            ~metadata:","counters":[]},{"line":"                              [ (\"peer\", Network_peer.Peer.to_yojson peer)","counters":[{"col_start":67,"col_end":67,"count":0}]},{"line":"                              ; (\"error\", Error_json.error_to_yojson e)","counters":[{"col_start":67,"col_end":67,"count":0}]},{"line":"                              ]","counters":[]},{"line":"                            \"Peer $peer failed to serve requested epoch \\","counters":[]},{"line":"                             ledger: $error\" ;","counters":[]},{"line":"                          return (Error e) )","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                  | Connected { data = Ok (Error err); _ } ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      (* TODO figure out punishments here. *)","counters":[]},{"line":"                      [%log faulty_peer_without_punishment]","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"                        ~metadata:","counters":[]},{"line":"                          [ (\"peer\", Network_peer.Peer.to_yojson peer)","counters":[{"col_start":63,"col_end":63,"count":0}]},{"line":"                          ; (\"error\", `String err)","counters":[]},{"line":"                          ]","counters":[]},{"line":"                        \"Peer $peer failed to serve requested epoch ledger: \\","counters":[]},{"line":"                         $error\" ;","counters":[]},{"line":"                      return (Or_error.error_string err)","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"                  | Connected { data = Error err; _ } ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      [%log faulty_peer_without_punishment]","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"                        ~metadata:","counters":[]},{"line":"                          [ (\"peer\", Network_peer.Peer.to_yojson peer)","counters":[{"col_start":63,"col_end":63,"count":0}]},{"line":"                          ; (\"error\", `String (Error.to_string_mach err))","counters":[{"col_start":66,"col_end":66,"count":0}]},{"line":"                          ]","counters":[]},{"line":"                        \"Peer $peer failed to serve requested epoch ledger: \\","counters":[]},{"line":"                         $error\" ;","counters":[]},{"line":"                      return (Error err)","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                  | Failed_to_connect err ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      [%log faulty_peer_without_punishment]","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"                        ~metadata:","counters":[]},{"line":"                          [ (\"peer\", Network_peer.Peer.to_yojson peer)","counters":[{"col_start":63,"col_end":63,"count":0}]},{"line":"                          ; (\"error\", Error_json.error_to_yojson err)","counters":[{"col_start":63,"col_end":63,"count":0}]},{"line":"                          ]","counters":[]},{"line":"                        \"Failed to connect to $peer to retrieve epoch ledger: \\","counters":[]},{"line":"                         $error\" ;","counters":[]},{"line":"                      return (Error err) ) )","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"      in","counters":[]},{"line":"      match requested_syncs with","counters":[]},{"line":"      | One required_sync ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let open Async.Deferred.Let_syntax in","counters":[]},{"line":"          let start = Core.Time.now () in","counters":[]},{"line":"          let%map result = sync required_sync in","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"          let { snapshot_id; _ } = required_sync in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          ( match snapshot_id with","counters":[]},{"line":"          | Staking_epoch_snapshot ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Mina_metrics.(","counters":[]},{"line":"                Counter.inc Bootstrap.staking_epoch_ledger_sync_ms","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                  Core.Time.(diff (now ()) start |> Span.to_ms))","counters":[{"col_start":37,"col_end":37,"count":0},{"col_start":52,"col_end":52,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"          | Next_epoch_snapshot ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Mina_metrics.(","counters":[]},{"line":"                Counter.inc Bootstrap.next_epoch_ledger_sync_ms","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                  Core.Time.(diff (now ()) start |> Span.to_ms)) ) ;","counters":[{"col_start":37,"col_end":37,"count":0},{"col_start":52,"col_end":52,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"          result","counters":[]},{"line":"      | Both { staking; next } ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (*Sync staking ledger before syncing the next ledger*)","counters":[]},{"line":"          let open Deferred.Or_error.Let_syntax in","counters":[]},{"line":"          let start = Core.Time.now () in","counters":[]},{"line":"          let%bind () =","counters":[]},{"line":"            sync","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"              { snapshot_id = Staking_epoch_snapshot; expected_root = staking }","counters":[]},{"line":"          in","counters":[]},{"line":"          Mina_metrics.(","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Counter.inc Bootstrap.staking_epoch_ledger_sync_ms","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"              Core.Time.(diff (now ()) start |> Span.to_ms)) ;","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":48,"col_end":48,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"          let start = Core.Time.now () in","counters":[]},{"line":"          let%map () =","counters":[]},{"line":"            sync { snapshot_id = Next_epoch_snapshot; expected_root = next }","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"          in","counters":[]},{"line":"          Mina_metrics.(","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Counter.inc Bootstrap.next_epoch_ledger_sync_ms","counters":[]},{"line":"              Core.Time.(diff (now ()) start |> Span.to_ms))","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":48,"col_end":48,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"","counters":[]},{"line":"    let received_within_window ~constants (epoch, slot) ~time_received =","counters":[]},{"line":"      let open Int64 in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let ( < ) x y = compare x y < 0 in","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"      let ( >= ) x y = compare x y >= 0 in","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"      let time_received =","counters":[]},{"line":"        Time.(","counters":[]},{"line":"          of_span_since_epoch","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"            (Span.of_ms (Unix_timestamp.to_int64 time_received)))","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"      in","counters":[]},{"line":"      let slot_diff =","counters":[]},{"line":"        Epoch.diff_in_slots ~constants","counters":[]},{"line":"          (Epoch_and_slot.of_time_exn time_received ~constants)","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"          (epoch, slot)","counters":[]},{"line":"      in","counters":[]},{"line":"      if slot_diff < 0L then Error `Too_early","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"      else if slot_diff >= UInt32.(to_int64 (add constants.delta (of_int 1)))","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":42,"col_end":42,"count":0},{"col_start":47,"col_end":47,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"      then Error (`Too_late (sub slot_diff UInt32.(to_int64 constants.delta)))","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"      else Ok ()","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"","counters":[]},{"line":"    let received_at_valid_time ~(constants : Constants.t)","counters":[]},{"line":"        (consensus_state : Consensus_state.Value.t) ~time_received =","counters":[]},{"line":"      received_within_window ~constants","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (Consensus_state.curr_epoch_and_slot consensus_state)","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"        ~time_received","counters":[]},{"line":"","counters":[]},{"line":"    let is_short_range ~constants =","counters":[]},{"line":"      let open Consensus_state in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let is_pred x1 x2 = Epoch.equal (Epoch.succ x1) x2 in","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"      let pred_case c1 c2 =","counters":[]},{"line":"        let e1, e2 = (curr_epoch c1, curr_epoch c2) in","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"        let c1_next_is_finalized =","counters":[]},{"line":"          not (Slot.in_seed_update_range ~constants (Slot.succ (curr_slot c1)))","counters":[{"col_start":39,"col_end":39,"count":0},{"col_start":61,"col_end":61,"count":0},{"col_start":72,"col_end":72,"count":0}]},{"line":"        in","counters":[]},{"line":"        is_pred e1 e2 && c1_next_is_finalized","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"        && Mina_base.State_hash.equal c1.next_epoch_data.lock_checkpoint","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"             c2.staking_epoch_data.lock_checkpoint","counters":[]},{"line":"      in","counters":[]},{"line":"      fun c1 c2 ->","counters":[]},{"line":"        if Epoch.equal (curr_epoch c1) (curr_epoch c2) then","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"          Mina_base.State_hash.equal c1.staking_epoch_data.lock_checkpoint","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            c2.staking_epoch_data.lock_checkpoint","counters":[]},{"line":"        else pred_case c1 c2 || pred_case c2 c1","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"","counters":[]},{"line":"    type select_status = [ `Keep | `Take ] [@@deriving equal]","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"    let select ~context:(module Context : CONTEXT) ~existing:existing_with_hash","counters":[]},{"line":"        ~candidate:candidate_with_hash =","counters":[]},{"line":"      let open Context in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let { With_hash.hash =","counters":[]},{"line":"              { Mina_base.State_hash.State_hashes.state_hash = existing_hash","counters":[]},{"line":"              ; _","counters":[]},{"line":"              }","counters":[]},{"line":"          ; data = existing","counters":[]},{"line":"          } =","counters":[]},{"line":"        existing_with_hash","counters":[]},{"line":"      in","counters":[]},{"line":"      let { With_hash.hash =","counters":[]},{"line":"              { Mina_base.State_hash.State_hashes.state_hash = candidate_hash","counters":[]},{"line":"              ; _","counters":[]},{"line":"              }","counters":[]},{"line":"          ; data = candidate","counters":[]},{"line":"          } =","counters":[]},{"line":"        candidate_with_hash","counters":[]},{"line":"      in","counters":[]},{"line":"      let string_of_choice = function `Take -> \"Take\" | `Keep -> \"Keep\" in","counters":[{"col_start":38,"col_end":38,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"      let log_result choice msg =","counters":[]},{"line":"        [%log debug] \"Select result: $choice -- $message\"","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"          ~metadata:","counters":[]},{"line":"            [ (\"choice\", `String (string_of_choice choice))","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"            ; (\"message\", `String msg)","counters":[]},{"line":"            ]","counters":[]},{"line":"      in","counters":[]},{"line":"      let log_choice ~precondition_msg ~choice_msg choice =","counters":[]},{"line":"        let choice_msg =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          match choice with","counters":[]},{"line":"          | `Take ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              choice_msg","counters":[]},{"line":"          | `Keep ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Printf.sprintf \"not (%s)\" choice_msg","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"        in","counters":[]},{"line":"        let msg = Printf.sprintf \"(%s) && (%s)\" precondition_msg choice_msg in","counters":[]},{"line":"        log_result choice msg","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      in","counters":[]},{"line":"      [%log debug] \"Selecting best consensus state\"","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"        ~metadata:","counters":[]},{"line":"          [ (\"existing\", Consensus_state.Value.to_yojson existing)","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"          ; (\"candidate\", Consensus_state.Value.to_yojson candidate)","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"          ] ;","counters":[]},{"line":"      (* TODO: add fork_before_checkpoint check *)","counters":[]},{"line":"      (* Each branch contains a precondition predicate and a choice predicate,","counters":[]},{"line":"       * which takes the new state when true. Each predicate is also decorated","counters":[]},{"line":"       * with a string description, used for debugging messages *)","counters":[]},{"line":"      let less_than_or_equal_when a b ~compare ~condition =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let c = compare a b in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        c < 0 || (c = 0 && condition)","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":12,"col_end":12,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"      in","counters":[]},{"line":"      let candidate_hash_is_bigger =","counters":[]},{"line":"        Mina_base.State_hash.(candidate_hash > existing_hash)","counters":[]},{"line":"      in","counters":[]},{"line":"      let candidate_vrf_is_bigger =","counters":[]},{"line":"        let string_of_blake2 =","counters":[]},{"line":"          Blake2.(Fn.compose to_raw_string digest_string)","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"        in","counters":[]},{"line":"        let compare_blake2 a b =","counters":[]},{"line":"          String.compare (string_of_blake2 a) (string_of_blake2 b)","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"        in","counters":[]},{"line":"        less_than_or_equal_when existing.last_vrf_output","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"          candidate.last_vrf_output ~compare:compare_blake2","counters":[]},{"line":"          ~condition:candidate_hash_is_bigger","counters":[]},{"line":"      in","counters":[]},{"line":"      let blockchain_length_is_longer =","counters":[]},{"line":"        less_than_or_equal_when existing.blockchain_length","counters":[]},{"line":"          candidate.blockchain_length ~compare:Length.compare","counters":[]},{"line":"          ~condition:candidate_vrf_is_bigger","counters":[]},{"line":"      in","counters":[]},{"line":"      let long_fork_chain_quality_is_better =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (* The min window density if we imagine extending to the max slot of the two chains. *)","counters":[]},{"line":"        (* TODO: You could argue that instead this should be imagine extending to the current consensus time. *)","counters":[]},{"line":"        let max_slot =","counters":[]},{"line":"          Global_slot.max candidate.curr_global_slot existing.curr_global_slot","counters":[]},{"line":"        in","counters":[]},{"line":"        let virtual_min_window_density (s : Consensus_state.Value.t) =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          if Global_slot.equal s.curr_global_slot max_slot then","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            s.min_window_density","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          else","counters":[]},{"line":"            Min_window_density.update_min_window_density ~incr_window:false","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              ~constants:consensus_constants","counters":[]},{"line":"              ~prev_global_slot:s.curr_global_slot ~next_global_slot:max_slot","counters":[]},{"line":"              ~prev_sub_window_densities:s.sub_window_densities","counters":[]},{"line":"              ~prev_min_window_density:s.min_window_density","counters":[]},{"line":"            |> fst","counters":[]},{"line":"        in","counters":[]},{"line":"        less_than_or_equal_when","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"          (virtual_min_window_density existing)","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"          (virtual_min_window_density candidate)","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"          ~compare:Length.compare ~condition:blockchain_length_is_longer","counters":[]},{"line":"      in","counters":[]},{"line":"      let precondition_msg, choice_msg, should_take =","counters":[]},{"line":"        if is_short_range existing candidate ~constants:consensus_constants then","counters":[]},{"line":"          ( \"most recent finalized checkpoints are equal\"","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          , \"candidate length is longer than existing length \"","counters":[]},{"line":"          , blockchain_length_is_longer )","counters":[]},{"line":"        else","counters":[]},{"line":"          ( \"most recent finalized checkpoints are not equal\"","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          , \"candidate virtual min-length is longer than existing virtual \\","counters":[]},{"line":"             min-length\"","counters":[]},{"line":"          , long_fork_chain_quality_is_better )","counters":[]},{"line":"      in","counters":[]},{"line":"      let choice = if should_take then `Take else `Keep in","counters":[{"col_start":39,"col_end":39,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"      log_choice ~precondition_msg ~choice_msg choice ;","counters":[]},{"line":"      choice","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let epoch_end_time = Epoch.end_time","counters":[]},{"line":"","counters":[]},{"line":"    let get_epoch_data_for_vrf ~(constants : Constants.t) now","counters":[]},{"line":"        (state : Consensus_state.Value.t) ~local_state ~logger :","counters":[]},{"line":"        Epoch_data_for_vrf.t * Local_state.Snapshot.Ledger_snapshot.t =","counters":[]},{"line":"      let curr_epoch, curr_slot =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Epoch.epoch_and_slot_of_time_exn ~constants","counters":[]},{"line":"          (Block_time.of_span_since_epoch (Block_time.Span.of_ms now))","counters":[{"col_start":40,"col_end":40,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"      in","counters":[]},{"line":"      let epoch, slot =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        if","counters":[]},{"line":"          Epoch.equal curr_epoch (Consensus_state.curr_epoch state)","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"          && Slot.equal curr_slot (Consensus_state.curr_slot state)","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"        then Epoch.incr ~constants (curr_epoch, curr_slot)","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"        else (curr_epoch, curr_slot)","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"      in","counters":[]},{"line":"      let global_slot =","counters":[]},{"line":"        Global_slot.of_epoch_and_slot ~constants (epoch, slot)","counters":[]},{"line":"        |> Global_slot.slot_number","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"      in","counters":[]},{"line":"      [%log debug]","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"        \"Systime: %d, epoch-slot@systime: %08d-%04d, starttime@epoch@systime: \\","counters":[]},{"line":"         %d\"","counters":[]},{"line":"        (Int64.to_int now) (Epoch.to_int epoch) (Slot.to_int slot)","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"        ( Int64.to_int @@ Time.Span.to_ms @@ Time.to_span_since_epoch","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"        @@ Epoch.start_time ~constants epoch ) ;","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"      [%log debug]","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"        !\"Selecting correct epoch data from state -- epoch by time: %d, state \\","counters":[]},{"line":"          epoch: %d, state epoch count: %d\"","counters":[]},{"line":"        (Epoch.to_int epoch)","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"        (Epoch.to_int (Consensus_state.curr_epoch state))","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"        (Length.to_int state.epoch_count) ;","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"      let epoch_data =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        match select_epoch_data ~consensus_state:state ~epoch with","counters":[]},{"line":"        | Ok epoch_data ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            epoch_data","counters":[]},{"line":"        | Error () ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            [%log fatal]","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"              \"An empty epoch is detected! This could be caused by the \\","counters":[]},{"line":"               following reasons: system time is out of sync with protocol \\","counters":[]},{"line":"               state time; or internet connection is down or unstable If it is \\","counters":[]},{"line":"               the first case, please setup NTP. If it is the second case, \\","counters":[]},{"line":"               please check the internet connection.\" ;","counters":[]},{"line":"            exit 99","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"      in","counters":[]},{"line":"      let epoch_snapshot =","counters":[]},{"line":"        let source, snapshot =","counters":[]},{"line":"          select_epoch_snapshot ~constants ~consensus_state:state ~local_state","counters":[]},{"line":"            ~epoch","counters":[]},{"line":"        in","counters":[]},{"line":"        let snapshot_ledger_hash =","counters":[]},{"line":"          Local_state.Snapshot.Ledger_snapshot.merkle_root snapshot.ledger","counters":[]},{"line":"        in","counters":[]},{"line":"        [%log debug]","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"          ~metadata:","counters":[]},{"line":"            [ ( \"ledger_hash\"","counters":[]},{"line":"              , Mina_base.Frozen_ledger_hash.to_yojson snapshot_ledger_hash )","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"            ]","counters":[]},{"line":"          !\"Using %s_epoch_snapshot root hash $ledger_hash\"","counters":[]},{"line":"          (epoch_snapshot_name source) ;","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"        (*TODO: uncomment after #6956 is resolved*)","counters":[]},{"line":"        (*assert (","counters":[]},{"line":"          Mina_base.Frozen_ledger_hash.equal snapshot_ledger_hash","counters":[]},{"line":"          epoch_data.ledger.hash ) ;*)","counters":[]},{"line":"        snapshot","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      in","counters":[]},{"line":"      let global_slot_since_genesis =","counters":[]},{"line":"        let slot_diff =","counters":[]},{"line":"          match","counters":[]},{"line":"            Mina_numbers.Global_slot.sub global_slot","counters":[]},{"line":"              (Consensus_state.curr_global_slot state)","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"          with","counters":[]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              [%log fatal]","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                \"Checking slot-winner for slot $slot which is older than the \\","counters":[]},{"line":"                 slot in the latest consensus state $state\"","counters":[]},{"line":"                ~metadata:","counters":[]},{"line":"                  [ (\"slot\", Mina_numbers.Global_slot.to_yojson slot)","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"                  ; (\"state\", Consensus_state.Value.to_yojson state)","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"                  ] ;","counters":[]},{"line":"              failwith","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                \"Checking slot-winner for a slot which is older than the slot \\","counters":[]},{"line":"                 in the latest consensus state. System time might be \\","counters":[]},{"line":"                 out-of-sync\"","counters":[]},{"line":"          | Some diff ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              diff","counters":[]},{"line":"        in","counters":[]},{"line":"        Mina_numbers.Global_slot.add","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"          (Consensus_state.global_slot_since_genesis state)","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"          slot_diff","counters":[]},{"line":"      in","counters":[]},{"line":"      let delegatee_table = epoch_snapshot.delegatee_table in","counters":[]},{"line":"      ( Epoch_data_for_vrf.","counters":[]},{"line":"          { epoch_ledger = epoch_data.ledger","counters":[]},{"line":"          ; epoch_seed = epoch_data.seed","counters":[]},{"line":"          ; delegatee_table","counters":[]},{"line":"          ; epoch","counters":[]},{"line":"          ; global_slot","counters":[]},{"line":"          ; global_slot_since_genesis","counters":[]},{"line":"          }","counters":[]},{"line":"      , epoch_snapshot.ledger )","counters":[]},{"line":"","counters":[]},{"line":"    let get_block_data ~(slot_won : Slot_won.t) ~ledger_snapshot","counters":[]},{"line":"        ~coinbase_receiver =","counters":[]},{"line":"      let delegator_pk, delegator_idx = slot_won.delegator in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let producer_public_key = slot_won.producer.public_key in","counters":[]},{"line":"      let producer_private_key = slot_won.producer.private_key in","counters":[]},{"line":"      let producer_pk = Public_key.compress producer_public_key in","counters":[]},{"line":"      { Block_data.stake_proof =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          { producer_private_key","counters":[]},{"line":"          ; producer_public_key","counters":[]},{"line":"          ; delegator = delegator_idx","counters":[]},{"line":"          ; delegator_pk","counters":[]},{"line":"          ; coinbase_receiver_pk =","counters":[]},{"line":"              Coinbase_receiver.resolve ~self:producer_pk coinbase_receiver","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"          ; ledger =","counters":[]},{"line":"              Local_state.Snapshot.Ledger_snapshot.ledger_subset","counters":[{"col_start":63,"col_end":63,"count":0}]},{"line":"                [ Mina_base.(Account_id.create producer_pk Token_id.default)","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"                ; Mina_base.(Account_id.create delegator_pk Token_id.default)","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"                ]","counters":[]},{"line":"                ledger_snapshot","counters":[]},{"line":"          }","counters":[]},{"line":"      ; global_slot = slot_won.global_slot","counters":[]},{"line":"      ; global_slot_since_genesis = slot_won.global_slot_since_genesis","counters":[]},{"line":"      ; vrf_result = slot_won.vrf_result","counters":[]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    let frontier_root_transition (prev : Consensus_state.Value.t)","counters":[]},{"line":"        (next : Consensus_state.Value.t) ~(local_state : Local_state.t)","counters":[]},{"line":"        ~snarked_ledger ~genesis_ledger_hash =","counters":[]},{"line":"      let snarked_ledger_hash =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Mina_ledger.Ledger.Db.merkle_root snarked_ledger","counters":[]},{"line":"      in","counters":[]},{"line":"      if","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        not","counters":[]},{"line":"          (Epoch.equal","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"             (Consensus_state.curr_epoch prev)","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"             (Consensus_state.curr_epoch next) )","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"      then (","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"        !local_state.last_epoch_delegatee_table <-","counters":[]},{"line":"          Some !local_state.staking_epoch_snapshot.delegatee_table ;","counters":[]},{"line":"        Local_state.Snapshot.Ledger_snapshot.remove","counters":[]},{"line":"          !local_state.staking_epoch_snapshot.ledger","counters":[]},{"line":"          ~location:(Local_state.staking_epoch_ledger_location local_state) ;","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"        !local_state.staking_epoch_snapshot <- !local_state.next_epoch_snapshot ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        (*If snarked ledger hash is still the genesis ledger hash then the epoch ledger should continue to be `next_data.ledger`. This is because the epoch ledgers at genesis can be different from the genesis ledger*)","counters":[]},{"line":"        if","counters":[]},{"line":"          not","counters":[]},{"line":"            (Mina_base.Frozen_ledger_hash.equal snarked_ledger_hash","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"               genesis_ledger_hash )","counters":[]},{"line":"        then (","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"          let epoch_ledger_uuids =","counters":[]},{"line":"            Local_state.Data.","counters":[]},{"line":"              { staking = !local_state.epoch_ledger_uuids.next","counters":[]},{"line":"              ; next = Uuid_unix.create ()","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"              ; genesis_state_hash =","counters":[]},{"line":"                  !local_state.epoch_ledger_uuids.genesis_state_hash","counters":[]},{"line":"              }","counters":[]},{"line":"          in","counters":[]},{"line":"          !local_state.epoch_ledger_uuids <- epoch_ledger_uuids ;","counters":[]},{"line":"          Yojson.Safe.to_file","counters":[]},{"line":"            (!local_state.epoch_ledger_location ^ \".json\")","counters":[]},{"line":"            (Local_state.epoch_ledger_uuids_to_yojson epoch_ledger_uuids) ;","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"          !local_state.next_epoch_snapshot <-","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            { ledger =","counters":[]},{"line":"                Local_state.Snapshot.Ledger_snapshot.Ledger_db","counters":[]},{"line":"                  (Mina_ledger.Ledger.Db.create_checkpoint snarked_ledger","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"                     ~directory_name:","counters":[]},{"line":"                       ( !local_state.epoch_ledger_location","counters":[]},{"line":"                       ^ Uuid.to_string epoch_ledger_uuids.next )","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"                     () )","counters":[]},{"line":"            ; delegatee_table =","counters":[]},{"line":"                compute_delegatee_table_ledger_db","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"                  (Local_state.current_block_production_keys local_state)","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"                  snarked_ledger","counters":[]},{"line":"            } ) )","counters":[]},{"line":"","counters":[]},{"line":"    let should_bootstrap_len ~context:(module Context : CONTEXT) ~existing","counters":[]},{"line":"        ~candidate =","counters":[]},{"line":"      let open Context in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let open UInt32.Infix in","counters":[]},{"line":"      UInt32.compare (candidate - existing)","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"        ( (UInt32.of_int 2 * consensus_constants.k)","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"        + (consensus_constants.delta + UInt32.of_int 1) )","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"      > 0","counters":[]},{"line":"","counters":[]},{"line":"    let should_bootstrap ~context:(module Context : CONTEXT) ~existing","counters":[]},{"line":"        ~candidate =","counters":[]},{"line":"      match select ~context:(module Context) ~existing ~candidate with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | `Keep ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          false","counters":[]},{"line":"      | `Take ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          should_bootstrap_len","counters":[]},{"line":"            ~context:(module Context)","counters":[]},{"line":"            ~existing:","counters":[]},{"line":"              (Consensus_state.blockchain_length (With_hash.data existing))","counters":[{"col_start":47,"col_end":47,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"            ~candidate:","counters":[]},{"line":"              (Consensus_state.blockchain_length (With_hash.data candidate))","counters":[{"col_start":47,"col_end":47,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"","counters":[]},{"line":"    let%test \"should_bootstrap is sane\" =","counters":[]},{"line":"      let module Context = struct","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let logger = Logger.create ()","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"","counters":[]},{"line":"        let constraint_constants =","counters":[]},{"line":"          Genesis_constants.Constraint_constants.for_unit_tests","counters":[]},{"line":"","counters":[]},{"line":"        let consensus_constants = Lazy.force Constants.for_unit_tests","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"      end in","counters":[]},{"line":"      (* Even when consensus constants are of prod sizes, candidate should still trigger a bootstrap *)","counters":[]},{"line":"      should_bootstrap_len","counters":[]},{"line":"        ~context:(module Context)","counters":[]},{"line":"        ~existing:Length.zero","counters":[]},{"line":"        ~candidate:(Length.of_int 100_000_000)","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"","counters":[]},{"line":"    let to_unix_timestamp recieved_time =","counters":[]},{"line":"      recieved_time |> Time.to_span_since_epoch |> Time.Span.to_ms","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"      |> Unix_timestamp.of_int64","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"    let%test \"Receive a valid consensus_state with a bit of delay\" =","counters":[]},{"line":"      let constants = Lazy.force Constants.for_unit_tests in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let genesis_ledger = Genesis_ledger.(Packed.t for_unit_tests) in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"      let genesis_epoch_data = Genesis_epoch_data.for_unit_tests in","counters":[]},{"line":"      let negative_one =","counters":[]},{"line":"        Consensus_state.negative_one ~genesis_ledger ~genesis_epoch_data","counters":[]},{"line":"          ~constants","counters":[]},{"line":"          ~constraint_constants:","counters":[]},{"line":"            Genesis_constants.Constraint_constants.for_unit_tests","counters":[]},{"line":"      in","counters":[]},{"line":"      let curr_epoch, curr_slot =","counters":[]},{"line":"        Consensus_state.curr_epoch_and_slot negative_one","counters":[]},{"line":"      in","counters":[]},{"line":"      let delay = UInt32.(div (add constants.delta (of_int 1)) (of_int 2)) in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":57,"col_end":57,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"      let new_slot = UInt32.Infix.(curr_slot + delay) in","counters":[]},{"line":"      let time_received =","counters":[]},{"line":"        Epoch.slot_start_time ~constants curr_epoch new_slot","counters":[]},{"line":"      in","counters":[]},{"line":"      received_at_valid_time ~constants negative_one","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ~time_received:(to_unix_timestamp time_received)","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"      |> Result.is_ok","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"    let%test \"Receive an invalid consensus_state\" =","counters":[]},{"line":"      let epoch = Epoch.of_int 5 in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let constants = Lazy.force Constants.for_unit_tests in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let genesis_ledger = Genesis_ledger.(Packed.t for_unit_tests) in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"      let genesis_epoch_data = Genesis_epoch_data.for_unit_tests in","counters":[]},{"line":"      let negative_one =","counters":[]},{"line":"        Consensus_state.negative_one ~genesis_ledger ~genesis_epoch_data","counters":[]},{"line":"          ~constants","counters":[]},{"line":"          ~constraint_constants:","counters":[]},{"line":"            Genesis_constants.Constraint_constants.for_unit_tests","counters":[]},{"line":"      in","counters":[]},{"line":"      let start_time = Epoch.start_time ~constants epoch in","counters":[]},{"line":"      let ((curr_epoch, curr_slot) as curr) =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Epoch_and_slot.of_time_exn ~constants start_time","counters":[]},{"line":"      in","counters":[]},{"line":"      let curr_global_slot = Global_slot.of_epoch_and_slot ~constants curr in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let consensus_state =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { negative_one with","counters":[]},{"line":"          curr_global_slot","counters":[]},{"line":"        ; global_slot_since_genesis = Global_slot.slot_number curr_global_slot","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"        }","counters":[]},{"line":"      in","counters":[]},{"line":"      let too_early =","counters":[]},{"line":"        (* TODO: Does this make sense? *)","counters":[]},{"line":"        Epoch.start_time ~constants (Consensus_state.curr_slot negative_one)","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"      in","counters":[]},{"line":"      let too_late =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let delay = UInt32.(mul (add constants.delta (of_int 1)) (of_int 2)) in","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":59,"col_end":59,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"        let delayed_slot = UInt32.Infix.(curr_slot + delay) in","counters":[]},{"line":"        Epoch.slot_start_time ~constants curr_epoch delayed_slot","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"      in","counters":[]},{"line":"      let times = [ too_late; too_early ] in","counters":[]},{"line":"      List.for_all times ~f:(fun time ->","counters":[]},{"line":"          not","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ( received_at_valid_time ~constants consensus_state","counters":[]},{"line":"                ~time_received:(to_unix_timestamp time)","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"            |> Result.is_ok ) )","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"","counters":[]},{"line":"    module type State_hooks_intf =","counters":[]},{"line":"      Intf.State_hooks","counters":[]},{"line":"        with type consensus_state := Consensus_state.Value.t","counters":[]},{"line":"         and type consensus_state_var := Consensus_state.var","counters":[]},{"line":"         and type consensus_transition := Consensus_transition.t","counters":[]},{"line":"         and type block_data := Block_data.t","counters":[]},{"line":"","counters":[]},{"line":"    module Make_state_hooks","counters":[]},{"line":"        (Blockchain_state : Intf.Blockchain_state)","counters":[]},{"line":"        (Protocol_state : Intf.Protocol_state","counters":[]},{"line":"                            with type blockchain_state :=","counters":[]},{"line":"                              Blockchain_state.Value.t","counters":[]},{"line":"                             and type blockchain_state_var :=","counters":[]},{"line":"                              Blockchain_state.var","counters":[]},{"line":"                             and type consensus_state := Consensus_state.Value.t","counters":[]},{"line":"                             and type consensus_state_var := Consensus_state.var)","counters":[]},{"line":"        (Snark_transition : Intf.Snark_transition","counters":[]},{"line":"                              with type blockchain_state_var :=","counters":[]},{"line":"                                Blockchain_state.var","counters":[]},{"line":"                               and type consensus_transition_var :=","counters":[]},{"line":"                                Consensus_transition.var) :","counters":[]},{"line":"      State_hooks_intf","counters":[]},{"line":"        with type blockchain_state := Blockchain_state.Value.t","counters":[]},{"line":"         and type protocol_state := Protocol_state.Value.t","counters":[]},{"line":"         and type protocol_state_var := Protocol_state.var","counters":[]},{"line":"         and type snark_transition_var := Snark_transition.var = struct","counters":[]},{"line":"      (* TODO: only track total currency from accounts > 1% of the currency using transactions *)","counters":[]},{"line":"","counters":[]},{"line":"      let genesis_winner = Vrf.Precomputed.genesis_winner","counters":[]},{"line":"","counters":[]},{"line":"      let check_block_data ~constants ~logger (block_data : Block_data.t)","counters":[]},{"line":"          global_slot =","counters":[]},{"line":"        if","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          not","counters":[]},{"line":"            (Mina_numbers.Global_slot.equal","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"               (Global_slot.slot_number global_slot)","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"               block_data.global_slot )","counters":[]},{"line":"        then","counters":[]},{"line":"          [%log error]","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"            !\"VRF was evaluated at (epoch, slot) %{sexp:Epoch_and_slot.t} but \\","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"              the corresponding block was produced at a time corresponding to \\","counters":[]},{"line":"              %{sexp:Epoch_and_slot.t}. This means that generating the block \\","counters":[]},{"line":"              took more time than expected.\"","counters":[]},{"line":"            (Global_slot.to_epoch_and_slot","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"               (Global_slot.of_slot_number ~constants block_data.global_slot) )","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"            (Global_slot.to_epoch_and_slot global_slot)","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"","counters":[]},{"line":"      let generate_transition","counters":[]},{"line":"          ~(previous_protocol_state : Protocol_state.Value.t) ~blockchain_state","counters":[]},{"line":"          ~current_time ~(block_data : Block_data.t) ~supercharge_coinbase","counters":[]},{"line":"          ~snarked_ledger_hash ~genesis_ledger_hash ~supply_increase ~logger","counters":[]},{"line":"          ~constraint_constants =","counters":[]},{"line":"        let previous_consensus_state =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Protocol_state.consensus_state previous_protocol_state","counters":[]},{"line":"        in","counters":[]},{"line":"        let constants =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Constants.create ~constraint_constants","counters":[]},{"line":"            ~protocol_constants:","counters":[]},{"line":"              ( Protocol_state.constants previous_protocol_state","counters":[]},{"line":"              |> Mina_base.Protocol_constants_checked.t_of_value )","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"        in","counters":[]},{"line":"        (let actual_global_slot =","counters":[]},{"line":"           let time = Time.of_span_since_epoch (Time.Span.of_ms current_time) in","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"           Global_slot.of_epoch_and_slot ~constants","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"             (Epoch_and_slot.of_time_exn ~constants time)","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"         in","counters":[]},{"line":"         check_block_data ~constants ~logger block_data actual_global_slot ) ;","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"        let consensus_transition = block_data.global_slot in","counters":[]},{"line":"        let previous_protocol_state_hash =","counters":[]},{"line":"          Protocol_state.hash previous_protocol_state","counters":[]},{"line":"        in","counters":[]},{"line":"        let block_creator =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          block_data.stake_proof.producer_public_key |> Public_key.compress","counters":[]},{"line":"        in","counters":[]},{"line":"        let consensus_state =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Or_error.ok_exn","counters":[]},{"line":"            (Consensus_state.update ~constants ~previous_consensus_state","counters":[]},{"line":"               ~consensus_transition","counters":[]},{"line":"               ~producer_vrf_result:block_data.Block_data.vrf_result","counters":[]},{"line":"               ~previous_protocol_state_hash ~supply_increase","counters":[]},{"line":"               ~snarked_ledger_hash ~genesis_ledger_hash","counters":[]},{"line":"               ~block_stake_winner:block_data.stake_proof.delegator_pk","counters":[]},{"line":"               ~block_creator","counters":[]},{"line":"               ~coinbase_receiver:block_data.stake_proof.coinbase_receiver_pk","counters":[]},{"line":"               ~supercharge_coinbase )","counters":[]},{"line":"        in","counters":[]},{"line":"        let genesis_state_hash =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Protocol_state.genesis_state_hash","counters":[]},{"line":"            ~state_hash:(Some previous_protocol_state_hash)","counters":[]},{"line":"            previous_protocol_state","counters":[]},{"line":"        in","counters":[]},{"line":"        let protocol_state =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Protocol_state.create_value ~genesis_state_hash","counters":[]},{"line":"            ~previous_state_hash:(Protocol_state.hash previous_protocol_state)","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"            ~blockchain_state ~consensus_state","counters":[]},{"line":"            ~constants:(Protocol_state.constants previous_protocol_state)","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"        in","counters":[]},{"line":"        (protocol_state, consensus_transition)","counters":[]},{"line":"","counters":[]},{"line":"      include struct","counters":[]},{"line":"        let%snarkydef.Tick next_state_checked ~constraint_constants","counters":[]},{"line":"            ~(prev_state : Protocol_state.var)","counters":[]},{"line":"            ~(prev_state_hash : Mina_base.State_hash.var) transition","counters":[]},{"line":"            supply_increase =","counters":[]},{"line":"          Consensus_state.update_var ~constraint_constants","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (Protocol_state.consensus_state prev_state)","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"            (Snark_transition.consensus_transition transition)","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"            prev_state_hash ~supply_increase","counters":[]},{"line":"            ~previous_blockchain_state_ledger_hash:","counters":[]},{"line":"              ( Protocol_state.blockchain_state prev_state","counters":[]},{"line":"              |> Blockchain_state.snarked_ledger_hash )","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"            ~genesis_ledger_hash:","counters":[]},{"line":"              ( Protocol_state.blockchain_state prev_state","counters":[]},{"line":"              |> Blockchain_state.genesis_ledger_hash )","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"            ~protocol_constants:(Protocol_state.constants prev_state)","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      module For_tests = struct","counters":[]},{"line":"        let gen_consensus_state","counters":[]},{"line":"            ~(constraint_constants : Genesis_constants.Constraint_constants.t)","counters":[]},{"line":"            ~constants ~(gen_slot_advancement : int Quickcheck.Generator.t) :","counters":[]},{"line":"            (   previous_protocol_state:","counters":[]},{"line":"                  Protocol_state.Value.t","counters":[]},{"line":"                  Mina_base.State_hash.With_state_hashes.t","counters":[]},{"line":"             -> snarked_ledger_hash:Mina_base.Frozen_ledger_hash.t","counters":[]},{"line":"             -> coinbase_receiver:Public_key.Compressed.t","counters":[]},{"line":"             -> supercharge_coinbase:bool","counters":[]},{"line":"             -> Consensus_state.Value.t )","counters":[]},{"line":"            Quickcheck.Generator.t =","counters":[]},{"line":"          let open Consensus_state in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let genesis_ledger_hash =","counters":[]},{"line":"            let (module L) = Genesis_ledger.for_unit_tests in","counters":[]},{"line":"            Lazy.force L.t |> Mina_ledger.Ledger.merkle_root","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"            |> Mina_base.Frozen_ledger_hash.of_ledger_hash","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"          in","counters":[]},{"line":"          let open Quickcheck.Let_syntax in","counters":[]},{"line":"          let%bind slot_advancement = gen_slot_advancement in","counters":[]},{"line":"          let%map producer_vrf_result = Vrf.Output.gen in","counters":[]},{"line":"          fun ~(previous_protocol_state :","counters":[]},{"line":"                 Protocol_state.Value.t Mina_base.State_hash.With_state_hashes.t","counters":[]},{"line":"                 ) ~(snarked_ledger_hash : Mina_base.Frozen_ledger_hash.t)","counters":[]},{"line":"              ~coinbase_receiver ~supercharge_coinbase ->","counters":[]},{"line":"            let prev =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Protocol_state.consensus_state","counters":[]},{"line":"                (With_hash.data previous_protocol_state)","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"            in","counters":[]},{"line":"            let blockchain_length = Length.succ prev.blockchain_length in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let curr_global_slot =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Global_slot.(prev.curr_global_slot + slot_advancement)","counters":[]},{"line":"            in","counters":[]},{"line":"            let global_slot_since_genesis =","counters":[]},{"line":"              Mina_numbers.Global_slot.(","counters":[]},{"line":"                add prev.global_slot_since_genesis (of_int slot_advancement))","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"            in","counters":[]},{"line":"            let curr_epoch, curr_slot =","counters":[]},{"line":"              Global_slot.to_epoch_and_slot curr_global_slot","counters":[]},{"line":"            in","counters":[]},{"line":"            let total_currency =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Option.value_exn","counters":[]},{"line":"                (Amount.add prev.total_currency","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                   constraint_constants.coinbase_amount )","counters":[]},{"line":"            in","counters":[]},{"line":"            let prev_epoch, prev_slot =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Consensus_state.curr_epoch_and_slot prev","counters":[]},{"line":"            in","counters":[]},{"line":"            let staking_epoch_data, next_epoch_data, epoch_count =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Epoch_data.update_pair ~constants","counters":[]},{"line":"                (prev.staking_epoch_data, prev.next_epoch_data)","counters":[]},{"line":"                prev.epoch_count ~prev_epoch ~next_epoch:curr_epoch","counters":[]},{"line":"                ~next_slot:curr_slot","counters":[]},{"line":"                ~prev_protocol_state_hash:","counters":[]},{"line":"                  (Mina_base.State_hash.With_state_hashes.state_hash","counters":[{"col_start":67,"col_end":67,"count":0}]},{"line":"                     previous_protocol_state )","counters":[]},{"line":"                ~producer_vrf_result ~snarked_ledger_hash ~genesis_ledger_hash","counters":[]},{"line":"                ~total_currency","counters":[]},{"line":"            in","counters":[]},{"line":"            let min_window_density, sub_window_densities =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Min_window_density.update_min_window_density ~constants","counters":[]},{"line":"                ~incr_window:true ~prev_global_slot:prev.curr_global_slot","counters":[]},{"line":"                ~next_global_slot:curr_global_slot","counters":[]},{"line":"                ~prev_sub_window_densities:prev.sub_window_densities","counters":[]},{"line":"                ~prev_min_window_density:prev.min_window_density","counters":[]},{"line":"            in","counters":[]},{"line":"            let genesis_winner_pk = fst Vrf.Precomputed.genesis_winner in","counters":[]},{"line":"            { Poly.blockchain_length","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            ; epoch_count","counters":[]},{"line":"            ; min_window_density","counters":[]},{"line":"            ; sub_window_densities","counters":[]},{"line":"            ; last_vrf_output = Vrf.Output.truncate producer_vrf_result","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"            ; total_currency","counters":[]},{"line":"            ; curr_global_slot","counters":[]},{"line":"            ; global_slot_since_genesis","counters":[]},{"line":"            ; staking_epoch_data","counters":[]},{"line":"            ; next_epoch_data","counters":[]},{"line":"            ; has_ancestor_in_same_checkpoint_window =","counters":[]},{"line":"                same_checkpoint_window_unchecked ~constants","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"                  (Global_slot.create ~constants ~epoch:prev_epoch","counters":[]},{"line":"                     ~slot:prev_slot )","counters":[]},{"line":"                  (Global_slot.create ~constants ~epoch:curr_epoch","counters":[]},{"line":"                     ~slot:curr_slot )","counters":[]},{"line":"            ; block_stake_winner = genesis_winner_pk","counters":[]},{"line":"            ; block_creator = genesis_winner_pk","counters":[]},{"line":"            ; coinbase_receiver","counters":[]},{"line":"            ; supercharge_coinbase","counters":[]},{"line":"            }","counters":[]},{"line":"      end","counters":[]},{"line":"    end","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let time_hum ~(constants : Constants.t) (now : Block_time.t) =","counters":[]},{"line":"    let epoch, slot = Epoch.epoch_and_slot_of_time_exn ~constants now in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Printf.sprintf \"epoch=%d, slot=%d\" (Epoch.to_int epoch) (Slot.to_int slot)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":51,"col_end":51,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"","counters":[]},{"line":"  let%test_module \"Proof of stake tests\" =","counters":[]},{"line":"    ( module struct","counters":[]},{"line":"      open Mina_base","counters":[]},{"line":"      open Mina_ledger","counters":[]},{"line":"      open Data","counters":[]},{"line":"      open Consensus_state","counters":[]},{"line":"","counters":[]},{"line":"      let constraint_constants =","counters":[]},{"line":"        Genesis_constants.Constraint_constants.for_unit_tests","counters":[]},{"line":"","counters":[]},{"line":"      let constants = Lazy.force Constants.for_unit_tests","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"","counters":[]},{"line":"      let genesis_epoch_data = Genesis_epoch_data.for_unit_tests","counters":[]},{"line":"","counters":[]},{"line":"      module Genesis_ledger = (val Genesis_ledger.for_unit_tests)","counters":[]},{"line":"","counters":[]},{"line":"      module Context : CONTEXT = struct","counters":[]},{"line":"        let logger = Logger.null ()","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"","counters":[]},{"line":"        let constraint_constants = constraint_constants","counters":[]},{"line":"","counters":[]},{"line":"        let consensus_constants = constants","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      let test_update constraint_constants =","counters":[]},{"line":"        (* build pieces needed to apply \"update\" *)","counters":[]},{"line":"        let snarked_ledger_hash =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Frozen_ledger_hash.of_ledger_hash","counters":[]},{"line":"            (Ledger.merkle_root (Lazy.force Genesis_ledger.t))","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"        in","counters":[]},{"line":"        let previous_protocol_state_hash = State_hash.(of_hash zero) in","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"        let previous_consensus_state =","counters":[]},{"line":"          Consensus_state.create_genesis","counters":[]},{"line":"            ~negative_one_protocol_state_hash:previous_protocol_state_hash","counters":[]},{"line":"            ~genesis_ledger:Genesis_ledger.t ~genesis_epoch_data","counters":[]},{"line":"            ~constraint_constants ~constants","counters":[]},{"line":"        in","counters":[]},{"line":"        (*If this is a fork then check blockchain length and global_slot_since_genesis have been set correctly*)","counters":[]},{"line":"        ( match constraint_constants.fork with","counters":[]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ()","counters":[]},{"line":"        | Some fork ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            assert (","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"              Mina_numbers.Global_slot.(","counters":[]},{"line":"                equal fork.previous_global_slot","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                  previous_consensus_state.global_slot_since_genesis) ) ;","counters":[]},{"line":"            assert (","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"              Mina_numbers.Length.(","counters":[]},{"line":"                equal","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                  (succ fork.previous_length)","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                  previous_consensus_state.blockchain_length) ) ) ;","counters":[]},{"line":"        let global_slot =","counters":[]},{"line":"          Core_kernel.Time.now () |> Time.of_time","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"          |> Epoch_and_slot.of_time_exn ~constants","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"          |> Global_slot.of_epoch_and_slot ~constants","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"        in","counters":[]},{"line":"        let consensus_transition : Consensus_transition.t =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Global_slot.slot_number global_slot","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"        in","counters":[]},{"line":"        let supply_increase =","counters":[]},{"line":"          Currency.Amount.(Signed.of_unsigned (of_int 42))","counters":[{"col_start":44,"col_end":44,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"        in","counters":[]},{"line":"        (* setup ledger, needed to compute producer_vrf_result here and handler below *)","counters":[]},{"line":"        let open Mina_base in","counters":[]},{"line":"        (* choose largest account as most likely to produce a block *)","counters":[]},{"line":"        let ledger_data = Lazy.force Genesis_ledger.t in","counters":[]},{"line":"        let ledger = Ledger.Any_ledger.cast (module Ledger) ledger_data in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let pending_coinbases =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Pending_coinbase.create","counters":[]},{"line":"            ~depth:constraint_constants.pending_coinbase_depth ()","counters":[]},{"line":"          |> Or_error.ok_exn","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"        in","counters":[]},{"line":"        let maybe_sk, account = Genesis_ledger.largest_account_exn () in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let producer_private_key = Option.value_exn maybe_sk in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let producer_public_key_compressed = Account.public_key account in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let account_id =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Account_id.create producer_public_key_compressed Token_id.default","counters":[]},{"line":"        in","counters":[]},{"line":"        let location =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Ledger.Any_ledger.M.location_of_account ledger account_id","counters":[]},{"line":"        in","counters":[]},{"line":"        let delegator =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Option.value_exn location |> Ledger.Any_ledger.M.Location.to_path_exn","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"          |> Ledger.Addr.to_int","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"        in","counters":[]},{"line":"        let producer_vrf_result =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let seed =","counters":[]},{"line":"            let next_epoch, _ = Global_slot.to_epoch_and_slot global_slot in","counters":[]},{"line":"            let prev_epoch, _ =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Global_slot.to_epoch_and_slot","counters":[]},{"line":"                previous_consensus_state.curr_global_slot","counters":[]},{"line":"            in","counters":[]},{"line":"            if UInt32.compare next_epoch prev_epoch > 0 then","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"              previous_consensus_state.next_epoch_data.seed","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"            else previous_consensus_state.staking_epoch_data.seed","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"          in","counters":[]},{"line":"          Vrf.eval ~constraint_constants ~private_key:producer_private_key","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"            { global_slot = Global_slot.slot_number global_slot","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"            ; seed","counters":[]},{"line":"            ; delegator","counters":[]},{"line":"            }","counters":[]},{"line":"        in","counters":[]},{"line":"        let next_consensus_state =","counters":[]},{"line":"          update ~constants ~previous_consensus_state ~consensus_transition","counters":[]},{"line":"            ~previous_protocol_state_hash ~supply_increase ~snarked_ledger_hash","counters":[]},{"line":"            ~genesis_ledger_hash:snarked_ledger_hash ~producer_vrf_result","counters":[]},{"line":"            ~block_stake_winner:producer_public_key_compressed","counters":[]},{"line":"            ~block_creator:producer_public_key_compressed","counters":[]},{"line":"            ~coinbase_receiver:producer_public_key_compressed","counters":[]},{"line":"            ~supercharge_coinbase:true","counters":[]},{"line":"          |> Or_error.ok_exn","counters":[]},{"line":"        in","counters":[]},{"line":"        (*If this is a fork then check blockchain length and global_slot_since_genesis have increased correctly*)","counters":[]},{"line":"        ( match constraint_constants.fork with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ()","counters":[]},{"line":"        | Some fork ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let slot_diff =","counters":[]},{"line":"              Option.value_exn","counters":[]},{"line":"                Global_slot.(","counters":[]},{"line":"                  global_slot - previous_consensus_state.curr_global_slot)","counters":[]},{"line":"            in","counters":[]},{"line":"            assert (","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"              Mina_numbers.Global_slot.(","counters":[]},{"line":"                equal","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                  (add fork.previous_global_slot slot_diff)","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                  next_consensus_state.global_slot_since_genesis) ) ;","counters":[]},{"line":"            assert (","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"              Mina_numbers.Length.(","counters":[]},{"line":"                equal","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                  (succ (succ fork.previous_length))","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"                  next_consensus_state.blockchain_length) ) ) ;","counters":[]},{"line":"        (* build pieces needed to apply \"update_var\" *)","counters":[]},{"line":"        let checked_computation =","counters":[]},{"line":"          let open Snark_params.Tick in","counters":[]},{"line":"          (* work in Checked monad *)","counters":[]},{"line":"          let%bind previous_state =","counters":[]},{"line":"            exists","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"              (typ ~constraint_constants)","counters":[]},{"line":"              ~compute:(As_prover.return previous_consensus_state)","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%bind transition_data =","counters":[]},{"line":"            exists Consensus_transition.typ","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"              ~compute:(As_prover.return consensus_transition)","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%bind previous_protocol_state_hash =","counters":[]},{"line":"            exists State_hash.typ","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"              ~compute:(As_prover.return previous_protocol_state_hash)","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%bind supply_increase =","counters":[]},{"line":"            exists Amount.Signed.typ ~compute:(As_prover.return supply_increase)","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%bind previous_blockchain_state_ledger_hash =","counters":[]},{"line":"            exists Mina_base.Frozen_ledger_hash.typ","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"              ~compute:(As_prover.return snarked_ledger_hash)","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"          in","counters":[]},{"line":"          let genesis_ledger_hash = previous_blockchain_state_ledger_hash in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let%bind constants_checked =","counters":[]},{"line":"            exists Mina_base.Protocol_constants_checked.typ","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"              ~compute:","counters":[]},{"line":"                (As_prover.return","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                   (Mina_base.Protocol_constants_checked.value_of_t","counters":[{"col_start":66,"col_end":66,"count":0}]},{"line":"                      Genesis_constants.for_unit_tests.protocol ) )","counters":[]},{"line":"          in","counters":[]},{"line":"          let result =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            update_var previous_state transition_data","counters":[]},{"line":"              previous_protocol_state_hash ~supply_increase","counters":[]},{"line":"              ~previous_blockchain_state_ledger_hash ~genesis_ledger_hash","counters":[]},{"line":"              ~constraint_constants ~protocol_constants:constants_checked","counters":[]},{"line":"          in","counters":[]},{"line":"          (* setup handler *)","counters":[]},{"line":"          let indices =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Ledger.Any_ledger.M.foldi ~init:[] ledger ~f:(fun i accum _acct ->","counters":[]},{"line":"                Ledger.Any_ledger.M.Addr.to_int i :: accum )","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"          in","counters":[]},{"line":"          let sparse_ledger =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Sparse_ledger.of_ledger_index_subset_exn ledger indices","counters":[]},{"line":"          in","counters":[]},{"line":"          let producer_public_key =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Public_key.decompress_exn producer_public_key_compressed","counters":[]},{"line":"          in","counters":[]},{"line":"          let handler =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Prover_state.handler ~constraint_constants","counters":[]},{"line":"              { delegator","counters":[]},{"line":"              ; delegator_pk = producer_public_key_compressed","counters":[]},{"line":"              ; coinbase_receiver_pk = producer_public_key_compressed","counters":[]},{"line":"              ; ledger = sparse_ledger","counters":[]},{"line":"              ; producer_private_key","counters":[]},{"line":"              ; producer_public_key","counters":[]},{"line":"              }","counters":[]},{"line":"              ~pending_coinbase:","counters":[]},{"line":"                { Pending_coinbase_witness.pending_coinbases","counters":[]},{"line":"                ; is_new_stack = true","counters":[]},{"line":"                }","counters":[]},{"line":"          in","counters":[]},{"line":"          let%map `Success _, var =","counters":[]},{"line":"            Snark_params.Tick.handle (fun () -> result) handler","counters":[{"col_start":35,"col_end":35,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"          in","counters":[]},{"line":"          As_prover.read (typ ~constraint_constants) var","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        in","counters":[]},{"line":"        let checked_value =","counters":[]},{"line":"          Or_error.ok_exn @@ Snark_params.Tick.run_and_check checked_computation","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"        in","counters":[]},{"line":"        let diff =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Sexp_diff_kernel.Algo.diff","counters":[]},{"line":"            ~original:(Value.sexp_of_t checked_value)","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"            ~updated:(Value.sexp_of_t next_consensus_state)","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"            ()","counters":[]},{"line":"        in","counters":[]},{"line":"        if not (Value.equal checked_value next_consensus_state) then (","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"          eprintf \"Different states:\\n%s\\n%!\"","counters":[]},{"line":"            (Sexp_diff_kernel.Display.display_with_ansi_colors","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"               (Sexp_diff_kernel.Display.Display_options.create","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"                  ~collapse_threshold:1000 Two_column )","counters":[]},{"line":"               diff ) ;","counters":[]},{"line":"          failwith \"Test failed\" )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"      let%test_unit \"update, update_var agree starting from same genesis state\"","counters":[]},{"line":"          =","counters":[]},{"line":"        test_update constraint_constants","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      let%test_unit \"update, update_var agree starting from same genesis state \\","counters":[]},{"line":"                     after fork\" =","counters":[]},{"line":"        let constraint_constants_with_fork =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let fork_constants =","counters":[]},{"line":"            Some","counters":[]},{"line":"              { Genesis_constants.Fork_constants.previous_state_hash =","counters":[]},{"line":"                  Result.ok_or_failwith","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"                    (State_hash.of_yojson","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"                       (`String","counters":[]},{"line":"                         \"3NL3bc213VQEFx6XTLbc3HxHqHH9ANbhHxRxSnBcRzXcKgeFA6TY\"","counters":[]},{"line":"                         ) )","counters":[]},{"line":"              ; previous_length = Mina_numbers.Length.of_int 100","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"              ; previous_global_slot = Mina_numbers.Global_slot.of_int 200","counters":[{"col_start":69,"col_end":69,"count":0}]},{"line":"              }","counters":[]},{"line":"          in","counters":[]},{"line":"          { constraint_constants with fork = fork_constants }","counters":[]},{"line":"        in","counters":[]},{"line":"        test_update constraint_constants_with_fork","counters":[]},{"line":"","counters":[]},{"line":"      let%test_unit \"vrf win rate\" =","counters":[]},{"line":"        let constants = Lazy.force Constants.for_unit_tests in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let constraint_constants =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Genesis_constants.Constraint_constants.for_unit_tests","counters":[]},{"line":"        in","counters":[]},{"line":"        let previous_protocol_state_hash =","counters":[]},{"line":"          Mina_base.State_hash.(of_hash zero)","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"        in","counters":[]},{"line":"        let previous_consensus_state =","counters":[]},{"line":"          Consensus_state.create_genesis","counters":[]},{"line":"            ~negative_one_protocol_state_hash:previous_protocol_state_hash","counters":[]},{"line":"            ~genesis_ledger:Genesis_ledger.t ~genesis_epoch_data","counters":[]},{"line":"            ~constraint_constants ~constants","counters":[]},{"line":"        in","counters":[]},{"line":"        let seed = previous_consensus_state.staking_epoch_data.seed in","counters":[]},{"line":"        let maybe_sk, account = Genesis_ledger.largest_account_exn () in","counters":[]},{"line":"        let private_key = Option.value_exn maybe_sk in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let public_key_compressed = Account.public_key account in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let total_stake =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          genesis_ledger_total_currency ~ledger:Genesis_ledger.t","counters":[]},{"line":"        in","counters":[]},{"line":"        let block_producer_pubkeys =","counters":[]},{"line":"          Public_key.Compressed.Set.of_list [ public_key_compressed ]","counters":[]},{"line":"        in","counters":[]},{"line":"        let ledger = Lazy.force Genesis_ledger.t in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let delegatee_table =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          compute_delegatee_table_genesis_ledger block_producer_pubkeys ledger","counters":[]},{"line":"        in","counters":[]},{"line":"        let epoch_snapshot =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          { Local_state.Snapshot.delegatee_table","counters":[]},{"line":"          ; ledger = Genesis_epoch_ledger ledger","counters":[]},{"line":"          }","counters":[]},{"line":"        in","counters":[]},{"line":"        let balance = Balance.to_int account.balance in","counters":[]},{"line":"        let total_stake_int = Currency.Amount.to_int total_stake in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let stake_fraction =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          float_of_int balance /. float_of_int total_stake_int","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"        in","counters":[]},{"line":"        let expected = stake_fraction *. 0.75 in","counters":[]},{"line":"        let samples = 1000 in","counters":[]},{"line":"        let check i =","counters":[]},{"line":"          let global_slot = UInt32.of_int i in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let%map result =","counters":[]},{"line":"            Interruptible.force","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"              (Vrf.check","counters":[]},{"line":"                 ~context:(module Context)","counters":[]},{"line":"                 ~global_slot ~seed ~producer_private_key:private_key","counters":[]},{"line":"                 ~producer_public_key:public_key_compressed ~total_stake","counters":[]},{"line":"                 ~get_delegators:","counters":[]},{"line":"                   (Local_state.Snapshot.delegators epoch_snapshot) )","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"          in","counters":[]},{"line":"          match Result.ok_exn result with Some _ -> 1 | None -> 0","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":42,"col_end":42,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"        in","counters":[]},{"line":"        let rec loop acc_count i =","counters":[]},{"line":"          match i < samples with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | true ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let%bind count = check i in","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"              loop (acc_count + count) (i + 1)","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"          | false ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              return acc_count","counters":[]},{"line":"        in","counters":[]},{"line":"        let actual =","counters":[]},{"line":"          Async.Thread_safe.block_on_async_exn (fun () -> loop 0 0)","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"        in","counters":[]},{"line":"        let diff =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Float.abs (float_of_int actual -. (expected *. float_of_int samples))","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"        in","counters":[]},{"line":"        let tolerance = 100. in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        (* 100 is a reasonable choice for samples = 1000 and for very low likelihood of failure; this should be recalculated if sample count was to be adjusted *)","counters":[]},{"line":"        let within_tolerance = Float.(diff < tolerance) in","counters":[]},{"line":"        if not within_tolerance then","counters":[]},{"line":"          failwithf \"actual vs. expected: %d vs %f\" actual expected ()","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"      (* Consensus selection tests. *)","counters":[]},{"line":"","counters":[]},{"line":"      let sum_lengths = List.fold ~init:Length.zero ~f:Length.add","counters":[]},{"line":"","counters":[]},{"line":"      let rec gen_except ~exclude ~gen ~equal =","counters":[]},{"line":"        let open Quickcheck.Generator.Let_syntax in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let%bind x = gen in","counters":[]},{"line":"        if List.mem exclude x ~equal then gen_except ~exclude ~gen ~equal","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"        else return x","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"      (* This generator is quadratic, but that should be ok since the max amount we generate with it","counters":[]},{"line":"       * is 8. *)","counters":[]},{"line":"      let gen_unique_list amount ~gen ~equal =","counters":[]},{"line":"        let rec loop n ls =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let open Quickcheck.Generator.Let_syntax in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          if n <= 0 then return ls","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"          else","counters":[]},{"line":"            let%bind x = gen_except ~exclude:ls ~gen ~equal in","counters":[]},{"line":"            loop (n - 1) (x :: ls)","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"        in","counters":[]},{"line":"        loop amount []","counters":[]},{"line":"","counters":[]},{"line":"      let gen_with_hash gen =","counters":[]},{"line":"        let open Quickcheck.Generator.Let_syntax in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let%bind data = gen in","counters":[]},{"line":"        let%map hash = State_hash.gen in","counters":[]},{"line":"        { With_hash.data","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        ; hash =","counters":[]},{"line":"            { State_hash.State_hashes.state_hash = hash","counters":[]},{"line":"            ; state_body_hash = None","counters":[]},{"line":"            }","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"      let gen_num_blocks_in_slots ~slot_fill_rate ~slot_fill_rate_delta n =","counters":[]},{"line":"        let open Quickcheck.Generator.Let_syntax in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let min_blocks =","counters":[]},{"line":"          Float.to_int","counters":[]},{"line":"            ( Float.of_int n","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"            *. Float.max (slot_fill_rate -. slot_fill_rate_delta) 0.0 )","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"        in","counters":[]},{"line":"        let max_blocks =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Float.to_int","counters":[]},{"line":"            ( Float.of_int n","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"            *. Float.min (slot_fill_rate +. slot_fill_rate_delta) 1.0 )","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"        in","counters":[]},{"line":"        Core.Int.gen_incl min_blocks max_blocks >>| Length.of_int","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"","counters":[]},{"line":"      let gen_num_blocks_in_epochs ~slot_fill_rate ~slot_fill_rate_delta n =","counters":[]},{"line":"        gen_num_blocks_in_slots ~slot_fill_rate ~slot_fill_rate_delta","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (n * Length.to_int constants.slots_per_epoch)","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"","counters":[]},{"line":"      let gen_min_density_windows_from_slot_fill_rate ~slot_fill_rate","counters":[]},{"line":"          ~slot_fill_rate_delta =","counters":[]},{"line":"        let open Quickcheck.Generator.Let_syntax in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let constants = Lazy.force Constants.for_unit_tests in","counters":[]},{"line":"        let constraint_constants =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Genesis_constants.Constraint_constants.for_unit_tests","counters":[]},{"line":"        in","counters":[]},{"line":"        let gen_sub_window_density =","counters":[]},{"line":"          gen_num_blocks_in_slots ~slot_fill_rate ~slot_fill_rate_delta","counters":[]},{"line":"            (Length.to_int constants.slots_per_sub_window)","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"        in","counters":[]},{"line":"        let%map sub_window_densities =","counters":[]},{"line":"          Quickcheck.Generator.list_with_length","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"            constraint_constants.sub_windows_per_window gen_sub_window_density","counters":[]},{"line":"        in","counters":[]},{"line":"        let min_window_density =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          List.fold ~init:Length.zero ~f:Length.add","counters":[]},{"line":"            (List.take sub_window_densities","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"               (List.length sub_window_densities - 1) )","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"        in","counters":[]},{"line":"        (min_window_density, sub_window_densities)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      (* Computes currency at height, assuming every block contains coinbase (ignoring inflation scheduling). *)","counters":[]},{"line":"      let currency_at_height ~genesis_currency height =","counters":[]},{"line":"        let constraint_constants =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Genesis_constants.Constraint_constants.for_unit_tests","counters":[]},{"line":"        in","counters":[]},{"line":"        Option.value_exn","counters":[]},{"line":"          Amount.(","counters":[]},{"line":"            genesis_currency","counters":[]},{"line":"            + of_int (height * to_int constraint_constants.coinbase_amount))","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"","counters":[]},{"line":"      (* TODO: Deprecate this in favor of just returning a constant in the monad from the outside. *)","counters":[]},{"line":"      let opt_gen opt ~gen =","counters":[]},{"line":"        match opt with Some v -> Quickcheck.Generator.return v | None -> gen","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"","counters":[]},{"line":"      let gen_epoch_data ~genesis_currency ~starts_at_block_height","counters":[]},{"line":"          ?start_checkpoint ?lock_checkpoint epoch_length :","counters":[]},{"line":"          Epoch_data.Value.t Quickcheck.Generator.t =","counters":[]},{"line":"        let open Quickcheck.Generator.Let_syntax in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let height_at_end_of_epoch =","counters":[]},{"line":"          Length.add starts_at_block_height epoch_length","counters":[]},{"line":"        in","counters":[]},{"line":"        let%bind ledger_hash = Frozen_ledger_hash.gen in","counters":[]},{"line":"        let%bind seed = Epoch_seed.gen in","counters":[]},{"line":"        let%bind start_checkpoint =","counters":[]},{"line":"          opt_gen start_checkpoint ~gen:State_hash.gen","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"        in","counters":[]},{"line":"        let%map lock_checkpoint = opt_gen lock_checkpoint ~gen:State_hash.gen in","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"        let ledger : Epoch_ledger.Value.t =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          { hash = ledger_hash","counters":[]},{"line":"          ; total_currency =","counters":[]},{"line":"              currency_at_height ~genesis_currency","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                (Length.to_int height_at_end_of_epoch)","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"          }","counters":[]},{"line":"        in","counters":[]},{"line":"        { Epoch_data.Poly.ledger","counters":[]},{"line":"        ; seed","counters":[]},{"line":"        ; start_checkpoint","counters":[]},{"line":"        ; lock_checkpoint","counters":[]},{"line":"        ; epoch_length","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"      let default_slot_fill_rate = 0.65","counters":[]},{"line":"","counters":[]},{"line":"      let default_slot_fill_rate_delta = 0.15","counters":[]},{"line":"","counters":[]},{"line":"      (** A root epoch of a block refers the epoch from which we can begin","counters":[]},{"line":"         *  simulating information for that block. Because we need to simulate","counters":[]},{"line":"         *  both the staking epoch and the next staking epoch, the root epoch","counters":[]},{"line":"         *  is the staking epoch. The root epoch position this function generates","counters":[]},{"line":"         *  is the epoch number of the staking epoch and the block height the","counters":[]},{"line":"         *  staking epoch starts at (the simulation of all blocks preceeding the","counters":[]},{"line":"         *  staking epoch).","counters":[]},{"line":"         *)","counters":[]},{"line":"      let gen_spot_root_epoch_position ~slot_fill_rate ~slot_fill_rate_delta =","counters":[]},{"line":"        let open Quickcheck.Generator.Let_syntax in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let%bind root_epoch_int = Core.Int.gen_incl 0 100 in","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"        let%map root_block_height =","counters":[]},{"line":"          gen_num_blocks_in_epochs ~slot_fill_rate ~slot_fill_rate_delta","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"            root_epoch_int","counters":[]},{"line":"        in","counters":[]},{"line":"        (UInt32.of_int root_epoch_int, root_block_height)","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"","counters":[]},{"line":"      let gen_vrf_output =","counters":[]},{"line":"        let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"        let%map output = Vrf.Output.gen in","counters":[]},{"line":"        Vrf.Output.truncate output","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      (* TODO: consider shoving this logic directly into Field.gen to avoid non-deterministic cycles *)","counters":[]},{"line":"      let rec gen_vrf_output_gt target =","counters":[]},{"line":"        let open Quickcheck.Generator.Let_syntax in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let string_of_blake2 =","counters":[]},{"line":"          Blake2.(Fn.compose to_raw_string digest_string)","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"        in","counters":[]},{"line":"        let compare_blake2 a b =","counters":[]},{"line":"          String.compare (string_of_blake2 a) (string_of_blake2 b)","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"        in","counters":[]},{"line":"        let%bind output = gen_vrf_output in","counters":[]},{"line":"        if compare_blake2 target output < 0 then return output","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"        else gen_vrf_output_gt target","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"      (** This generator generates blocks \"from thin air\" by simulating","counters":[]},{"line":"         *  the properties of a chain up to a point in time. This avoids","counters":[]},{"line":"         *  the work of computing all prior blocks in order to generate","counters":[]},{"line":"         *  a block at some point in the chain, hence why it is coined a","counters":[]},{"line":"         *  \"spot generator\".","counters":[]},{"line":"         *","counters":[]},{"line":"         * TODO:","counters":[]},{"line":"         *   - special case genesis","counters":[]},{"line":"         *   - has_ancestor_in_same_checkpoint_window","counters":[]},{"line":"         * NOTES:","counters":[]},{"line":"         *   - vrf outputs and ledger hashes are entirely fake","counters":[]},{"line":"         *   - density windows are computed distinctly from block heights and epoch lengths, so some non-obvious invariants may be broken there","counters":[]},{"line":"         *)","counters":[]},{"line":"      let gen_spot ?root_epoch_position","counters":[]},{"line":"          ?(slot_fill_rate = default_slot_fill_rate)","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"          ?(slot_fill_rate_delta = default_slot_fill_rate_delta)","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"          ?(genesis_currency = Currency.Amount.of_int 200000)","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"          ?gen_staking_epoch_length ?gen_next_epoch_length","counters":[]},{"line":"          ?gen_curr_epoch_position ?staking_start_checkpoint","counters":[]},{"line":"          ?staking_lock_checkpoint ?next_start_checkpoint ?next_lock_checkpoint","counters":[]},{"line":"          ?(gen_vrf_output = gen_vrf_output) () :","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"          Consensus_state.Value.t Quickcheck.Generator.t =","counters":[]},{"line":"        let open Quickcheck.Generator.Let_syntax in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let constants = Lazy.force Constants.for_unit_tests in","counters":[]},{"line":"        let gen_num_blocks_in_slots =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          gen_num_blocks_in_slots ~slot_fill_rate ~slot_fill_rate_delta","counters":[]},{"line":"        in","counters":[]},{"line":"        let gen_num_blocks_in_epochs =","counters":[]},{"line":"          gen_num_blocks_in_epochs ~slot_fill_rate ~slot_fill_rate_delta","counters":[]},{"line":"        in","counters":[]},{"line":"        (* Populate default generators. *)","counters":[]},{"line":"        let gen_staking_epoch_length =","counters":[]},{"line":"          Option.value gen_staking_epoch_length","counters":[]},{"line":"            ~default:(gen_num_blocks_in_epochs 1)","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"        in","counters":[]},{"line":"        let gen_next_epoch_length =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Option.value gen_next_epoch_length","counters":[]},{"line":"            ~default:(gen_num_blocks_in_epochs 1)","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"        in","counters":[]},{"line":"        let gen_curr_epoch_position =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let default =","counters":[]},{"line":"            let max_epoch_slot = Length.to_int constants.slots_per_epoch - 1 in","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"            let%bind curr_epoch_slot =","counters":[]},{"line":"              Core.Int.gen_incl 0 max_epoch_slot >>| UInt32.of_int","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"            in","counters":[]},{"line":"            let%map curr_epoch_length =","counters":[]},{"line":"              gen_num_blocks_in_slots (Length.to_int curr_epoch_slot)","counters":[{"col_start":36,"col_end":36,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"            in","counters":[]},{"line":"            (curr_epoch_slot, curr_epoch_length)","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          in","counters":[]},{"line":"          Option.value gen_curr_epoch_position ~default","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"        in","counters":[]},{"line":"        let%bind root_epoch, root_block_height =","counters":[]},{"line":"          match root_epoch_position with","counters":[]},{"line":"          | Some (root_epoch, root_block_height) ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              return (root_epoch, root_block_height)","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              gen_spot_root_epoch_position ~slot_fill_rate ~slot_fill_rate_delta","counters":[]},{"line":"        in","counters":[]},{"line":"        (* Generate blockchain position and epoch lengths. *)","counters":[]},{"line":"        (* staking_epoch == root_epoch, next_staking_epoch == root_epoch + 1 *)","counters":[]},{"line":"        let curr_epoch = Length.add root_epoch (Length.of_int 2) in","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"        let%bind staking_epoch_length = gen_staking_epoch_length in","counters":[]},{"line":"        let%bind next_staking_epoch_length = gen_next_epoch_length in","counters":[]},{"line":"        let%bind curr_epoch_slot, curr_epoch_length = gen_curr_epoch_position in","counters":[]},{"line":"        (* Compute state slot and length. *)","counters":[]},{"line":"        let curr_global_slot =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Global_slot.of_epoch_and_slot ~constants (curr_epoch, curr_epoch_slot)","counters":[]},{"line":"        in","counters":[]},{"line":"        let blockchain_length =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          sum_lengths","counters":[]},{"line":"            [ root_block_height","counters":[]},{"line":"            ; staking_epoch_length","counters":[]},{"line":"            ; next_staking_epoch_length","counters":[]},{"line":"            ; curr_epoch_length","counters":[]},{"line":"            ]","counters":[]},{"line":"        in","counters":[]},{"line":"        (* Compute total currency for state. *)","counters":[]},{"line":"        let total_currency =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          currency_at_height ~genesis_currency (Length.to_int blockchain_length)","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"        in","counters":[]},{"line":"        (* Generate epoch data for staking and next epochs. *)","counters":[]},{"line":"        let%bind staking_epoch_data =","counters":[]},{"line":"          gen_epoch_data ~genesis_currency","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"            ~starts_at_block_height:root_block_height","counters":[]},{"line":"            ?start_checkpoint:staking_start_checkpoint","counters":[]},{"line":"            ?lock_checkpoint:staking_lock_checkpoint staking_epoch_length","counters":[]},{"line":"        in","counters":[]},{"line":"        let%bind next_staking_epoch_data =","counters":[]},{"line":"          gen_epoch_data ~genesis_currency","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"            ~starts_at_block_height:","counters":[]},{"line":"              (Length.add root_block_height staking_epoch_length)","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"            ?start_checkpoint:next_start_checkpoint","counters":[]},{"line":"            ?lock_checkpoint:next_lock_checkpoint next_staking_epoch_length","counters":[]},{"line":"        in","counters":[]},{"line":"        (* Generate chain quality and vrf output. *)","counters":[]},{"line":"        let%bind min_window_density, sub_window_densities =","counters":[]},{"line":"          gen_min_density_windows_from_slot_fill_rate ~slot_fill_rate","counters":[]},{"line":"            ~slot_fill_rate_delta","counters":[]},{"line":"        in","counters":[]},{"line":"        let%bind vrf_output = gen_vrf_output in","counters":[]},{"line":"        (* Generate block reward information (unused in chain selection). *)","counters":[]},{"line":"        let%map staker_pk = Public_key.Compressed.gen in","counters":[]},{"line":"        { Consensus_state.Poly.blockchain_length","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        ; epoch_count = curr_epoch","counters":[]},{"line":"        ; min_window_density","counters":[]},{"line":"        ; sub_window_densities","counters":[]},{"line":"        ; last_vrf_output = vrf_output","counters":[]},{"line":"        ; total_currency","counters":[]},{"line":"        ; curr_global_slot","counters":[]},{"line":"        ; staking_epoch_data","counters":[]},{"line":"        ; next_epoch_data = next_staking_epoch_data","counters":[]},{"line":"        ; global_slot_since_genesis =","counters":[]},{"line":"            Global_slot.slot_number curr_global_slot","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"            (* These values are not used in selection, so we just set them to something. *)","counters":[]},{"line":"        ; has_ancestor_in_same_checkpoint_window = true","counters":[]},{"line":"        ; block_stake_winner = staker_pk","counters":[]},{"line":"        ; block_creator = staker_pk","counters":[]},{"line":"        ; coinbase_receiver = staker_pk","counters":[]},{"line":"        ; supercharge_coinbase = false","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"      (** This generator generates pairs of spot blocks that share common checkpoints.","counters":[]},{"line":"         *  The overlap of the checkpoints and the root epoch positions of the blocks","counters":[]},{"line":"         *  that are generated can be configured independently so that this function","counters":[]},{"line":"         *  can be used in other generators that wish to generates pairs of spot blocks","counters":[]},{"line":"         *  with specific constraints.","counters":[]},{"line":"         *)","counters":[]},{"line":"      let gen_spot_pair_common_checkpoints ?blockchain_length_relativity","counters":[]},{"line":"          ?vrf_output_relativity ~a_checkpoints ~b_checkpoints","counters":[]},{"line":"          ?(gen_a_root_epoch_position = Quickcheck.Generator.return)","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"          ?(gen_b_root_epoch_position = Quickcheck.Generator.return)","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"          ?(min_a_curr_epoch_slot = 0) () =","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"        let open Quickcheck.Generator.Let_syntax in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let slot_fill_rate = default_slot_fill_rate in","counters":[]},{"line":"        let slot_fill_rate_delta = default_slot_fill_rate_delta in","counters":[]},{"line":"        (* Both states will share the same root epoch position. *)","counters":[]},{"line":"        let%bind base_root_epoch_position =","counters":[]},{"line":"          gen_spot_root_epoch_position ~slot_fill_rate:default_slot_fill_rate","counters":[]},{"line":"            ~slot_fill_rate_delta:default_slot_fill_rate_delta","counters":[]},{"line":"        in","counters":[]},{"line":"        (* Generate unique state hashes. *)","counters":[]},{"line":"        let%bind hashes =","counters":[]},{"line":"          gen_unique_list 2 ~gen:State_hash.gen ~equal:State_hash.equal","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"        in","counters":[]},{"line":"        let[@warning \"-8\"] [ hash_a; hash_b ] = hashes in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        (* Generate common checkpoints. *)","counters":[]},{"line":"        let%bind checkpoints =","counters":[]},{"line":"          gen_unique_list 2 ~gen:State_hash.gen ~equal:State_hash.equal","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"        in","counters":[]},{"line":"        let[@warning \"-8\"] [ start_checkpoint; lock_checkpoint ] =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          checkpoints","counters":[]},{"line":"        in","counters":[]},{"line":"        let%bind a, a_curr_epoch_length =","counters":[]},{"line":"          (* If we are constraining the second state to have a greater blockchain length than the","counters":[]},{"line":"           * first, we need to constrain the first blockchain length such that there is some room","counters":[]},{"line":"           * leftover in the epoch for at least 1 more block to be generated. *)","counters":[]},{"line":"          let gen_curr_epoch_position =","counters":[]},{"line":"            let max_epoch_slot =","counters":[]},{"line":"              match blockchain_length_relativity with","counters":[]},{"line":"              | Some `Ascending ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Length.to_int constants.slots_per_epoch - 4","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"              (* -1 to bring into inclusive range, -3 to provide 2 slots of fudge room *)","counters":[]},{"line":"              | _ ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Length.to_int constants.slots_per_epoch - 1","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"              (* -1 to bring into inclusive range *)","counters":[]},{"line":"            in","counters":[]},{"line":"            let%bind slot =","counters":[]},{"line":"              Core.Int.gen_incl min_a_curr_epoch_slot max_epoch_slot","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"            in","counters":[]},{"line":"            let%map length =","counters":[]},{"line":"              gen_num_blocks_in_slots ~slot_fill_rate ~slot_fill_rate_delta slot","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"            in","counters":[]},{"line":"            (Length.of_int slot, length)","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"          in","counters":[]},{"line":"          let ( staking_start_checkpoint","counters":[]},{"line":"              , staking_lock_checkpoint","counters":[]},{"line":"              , next_start_checkpoint","counters":[]},{"line":"              , next_lock_checkpoint ) =","counters":[]},{"line":"            a_checkpoints start_checkpoint lock_checkpoint","counters":[]},{"line":"          in","counters":[]},{"line":"          let%bind root_epoch_position =","counters":[]},{"line":"            gen_a_root_epoch_position base_root_epoch_position","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%map a =","counters":[]},{"line":"            gen_spot ~slot_fill_rate ~slot_fill_rate_delta ~root_epoch_position","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"              ?staking_start_checkpoint ?staking_lock_checkpoint","counters":[]},{"line":"              ?next_start_checkpoint ?next_lock_checkpoint","counters":[]},{"line":"              ~gen_curr_epoch_position ()","counters":[]},{"line":"          in","counters":[]},{"line":"          let a_curr_epoch_length =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let _, root_epoch_length = root_epoch_position in","counters":[]},{"line":"            let length_till_curr_epoch =","counters":[]},{"line":"              sum_lengths","counters":[]},{"line":"                [ root_epoch_length","counters":[]},{"line":"                ; a.staking_epoch_data.epoch_length","counters":[]},{"line":"                ; a.next_epoch_data.epoch_length","counters":[]},{"line":"                ]","counters":[]},{"line":"            in","counters":[]},{"line":"            Option.value_exn","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"              (Length.sub a.blockchain_length length_till_curr_epoch)","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"          in","counters":[]},{"line":"          (a, a_curr_epoch_length)","counters":[]},{"line":"        in","counters":[]},{"line":"        let%map b =","counters":[]},{"line":"          (* Handle relativity constriants for second state. *)","counters":[]},{"line":"          let ( gen_staking_epoch_length","counters":[]},{"line":"              , gen_next_epoch_length","counters":[]},{"line":"              , gen_curr_epoch_position ) =","counters":[]},{"line":"            let a_curr_epoch_slot = Global_slot.slot a.curr_global_slot in","counters":[]},{"line":"            match blockchain_length_relativity with","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            | Some `Equal ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ( Some (return a.staking_epoch_data.epoch_length)","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                , Some (return a.next_epoch_data.epoch_length)","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                , Some (return (a_curr_epoch_slot, a_curr_epoch_length)) )","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"            | Some `Ascending ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (* Generate second state position by extending the first state's position *)","counters":[]},{"line":"                let gen_greater_position =","counters":[]},{"line":"                  let max_epoch_slot =","counters":[]},{"line":"                    Length.to_int constants.slots_per_epoch - 1","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                  in","counters":[]},{"line":"                  (* This invariant needs to be held for the position of `a` *)","counters":[]},{"line":"                  assert (max_epoch_slot > Length.to_int a_curr_epoch_slot + 2) ;","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"                  (* To make this easier, we assume there is a next block in the slot directly preceeding the block for `a`. *)","counters":[]},{"line":"                  let%bind added_slots =","counters":[]},{"line":"                    Core.Int.gen_incl","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"                      (Length.to_int a_curr_epoch_slot + 2)","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                      max_epoch_slot","counters":[]},{"line":"                  in","counters":[]},{"line":"                  let%map added_blocks =","counters":[]},{"line":"                    gen_num_blocks_in_slots ~slot_fill_rate","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"                      ~slot_fill_rate_delta added_slots","counters":[]},{"line":"                  in","counters":[]},{"line":"                  let b_slot =","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    Length.add","counters":[]},{"line":"                      (Length.add a_curr_epoch_slot (UInt32.of_int added_slots))","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"                      UInt32.one","counters":[]},{"line":"                  in","counters":[]},{"line":"                  let b_blockchain_length =","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    Length.add","counters":[]},{"line":"                      (Length.add a_curr_epoch_length added_blocks)","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                      UInt32.one","counters":[]},{"line":"                  in","counters":[]},{"line":"                  (b_slot, b_blockchain_length)","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                in","counters":[]},{"line":"                ( Some (return a.staking_epoch_data.epoch_length)","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                , Some (return a.next_epoch_data.epoch_length)","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                , Some gen_greater_position )","counters":[]},{"line":"            | None ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (None, None, None)","counters":[]},{"line":"          in","counters":[]},{"line":"          let gen_vrf_output =","counters":[]},{"line":"            match vrf_output_relativity with","counters":[]},{"line":"            | Some `Equal ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Some (return a.last_vrf_output)","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"            | Some `Ascending ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Some (gen_vrf_output_gt a.last_vrf_output)","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"            | None ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                None","counters":[]},{"line":"          in","counters":[]},{"line":"          let ( staking_start_checkpoint","counters":[]},{"line":"              , staking_lock_checkpoint","counters":[]},{"line":"              , next_start_checkpoint","counters":[]},{"line":"              , next_lock_checkpoint ) =","counters":[]},{"line":"            b_checkpoints start_checkpoint lock_checkpoint","counters":[]},{"line":"          in","counters":[]},{"line":"          let%bind root_epoch_position =","counters":[]},{"line":"            gen_b_root_epoch_position base_root_epoch_position","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"          in","counters":[]},{"line":"          gen_spot ~slot_fill_rate ~slot_fill_rate_delta ~root_epoch_position","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ?staking_start_checkpoint ?staking_lock_checkpoint","counters":[]},{"line":"            ?next_start_checkpoint ?next_lock_checkpoint","counters":[]},{"line":"            ?gen_staking_epoch_length ?gen_next_epoch_length","counters":[]},{"line":"            ?gen_curr_epoch_position ?gen_vrf_output ()","counters":[]},{"line":"        in","counters":[]},{"line":"        ( With_hash.","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            { data = a","counters":[]},{"line":"            ; hash =","counters":[]},{"line":"                { State_hash.State_hashes.state_hash = hash_a","counters":[]},{"line":"                ; state_body_hash = None","counters":[]},{"line":"                }","counters":[]},{"line":"            }","counters":[]},{"line":"        , With_hash.","counters":[]},{"line":"            { data = b","counters":[]},{"line":"            ; hash =","counters":[]},{"line":"                { State_hash.State_hashes.state_hash = hash_b","counters":[]},{"line":"                ; state_body_hash = None","counters":[]},{"line":"                }","counters":[]},{"line":"            } )","counters":[]},{"line":"","counters":[]},{"line":"      let gen_spot_pair_short_aligned ?blockchain_length_relativity","counters":[]},{"line":"          ?vrf_output_relativity () =","counters":[]},{"line":"        (* Both states will share their staking epoch checkpoints. *)","counters":[]},{"line":"        let checkpoints start lock = (Some start, Some lock, None, None) in","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"        gen_spot_pair_common_checkpoints ?blockchain_length_relativity","counters":[]},{"line":"          ?vrf_output_relativity ~a_checkpoints:checkpoints","counters":[]},{"line":"          ~b_checkpoints:checkpoints ()","counters":[]},{"line":"","counters":[]},{"line":"      let gen_spot_pair_short_misaligned ?blockchain_length_relativity","counters":[]},{"line":"          ?vrf_output_relativity () =","counters":[]},{"line":"        let open Quickcheck.Generator.Let_syntax in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let slot_fill_rate = default_slot_fill_rate in","counters":[]},{"line":"        let slot_fill_rate_delta = default_slot_fill_rate_delta in","counters":[]},{"line":"        let a_checkpoints start lock = (None, None, Some start, Some lock) in","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"        let b_checkpoints start lock = (Some start, Some lock, None, None) in","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"        let gen_b_root_epoch_position (a_root_epoch, a_root_length) =","counters":[]},{"line":"          (* Compute the root epoch position of `b`. This needs to be one epoch ahead of a, so we","counters":[]},{"line":"           * compute it by extending the root epoch position of `a` by a single epoch *)","counters":[]},{"line":"          let b_root_epoch = UInt32.succ a_root_epoch in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let%map added_blocks =","counters":[]},{"line":"            gen_num_blocks_in_epochs ~slot_fill_rate ~slot_fill_rate_delta 1","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"          in","counters":[]},{"line":"          let b_root_length = Length.add a_root_length added_blocks in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          (b_root_epoch, b_root_length)","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        in","counters":[]},{"line":"        (* Constrain first state to be within last 1/3rd of its epoch (ensuring it's checkpoints and seed are fixed). *)","counters":[]},{"line":"        let min_a_curr_epoch_slot =","counters":[]},{"line":"          (2 * (Length.to_int constants.slots_per_epoch / 3)) + 1","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"        in","counters":[]},{"line":"        gen_spot_pair_common_checkpoints ?blockchain_length_relativity","counters":[]},{"line":"          ?vrf_output_relativity ~a_checkpoints ~b_checkpoints","counters":[]},{"line":"          ~gen_b_root_epoch_position ~min_a_curr_epoch_slot ()","counters":[]},{"line":"","counters":[]},{"line":"      let gen_spot_pair_long =","counters":[]},{"line":"        let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"        let%bind hashes =","counters":[]},{"line":"          gen_unique_list 2 ~gen:State_hash.gen ~equal:State_hash.equal","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"        in","counters":[]},{"line":"        let[@warning \"-8\"] [ hash_a; hash_b ] = hashes in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let%bind checkpoints =","counters":[]},{"line":"          gen_unique_list 8 ~gen:State_hash.gen ~equal:State_hash.equal","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"        in","counters":[]},{"line":"        let[@warning \"-8\"] [ a_staking_start_checkpoint","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"                           ; a_staking_lock_checkpoint","counters":[]},{"line":"                           ; a_next_start_checkpoint","counters":[]},{"line":"                           ; a_next_lock_checkpoint","counters":[]},{"line":"                           ; b_staking_start_checkpoint","counters":[]},{"line":"                           ; b_staking_lock_checkpoint","counters":[]},{"line":"                           ; b_next_start_checkpoint","counters":[]},{"line":"                           ; b_next_lock_checkpoint","counters":[]},{"line":"                           ] =","counters":[]},{"line":"          checkpoints","counters":[]},{"line":"        in","counters":[]},{"line":"        let%bind a =","counters":[]},{"line":"          gen_spot ~staking_start_checkpoint:a_staking_start_checkpoint","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"            ~staking_lock_checkpoint:a_staking_lock_checkpoint","counters":[]},{"line":"            ~next_start_checkpoint:a_next_start_checkpoint","counters":[]},{"line":"            ~next_lock_checkpoint:a_next_lock_checkpoint ()","counters":[]},{"line":"        in","counters":[]},{"line":"        let%map b =","counters":[]},{"line":"          gen_spot ~staking_start_checkpoint:b_staking_start_checkpoint","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"            ~staking_lock_checkpoint:b_staking_lock_checkpoint","counters":[]},{"line":"            ~next_start_checkpoint:b_next_start_checkpoint","counters":[]},{"line":"            ~next_lock_checkpoint:b_next_lock_checkpoint ()","counters":[]},{"line":"        in","counters":[]},{"line":"        ( With_hash.","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            { data = a","counters":[]},{"line":"            ; hash =","counters":[]},{"line":"                { State_hash.State_hashes.state_hash = hash_a","counters":[]},{"line":"                ; state_body_hash = None","counters":[]},{"line":"                }","counters":[]},{"line":"            }","counters":[]},{"line":"        , With_hash.","counters":[]},{"line":"            { data = b","counters":[]},{"line":"            ; hash =","counters":[]},{"line":"                { State_hash.State_hashes.state_hash = hash_b","counters":[]},{"line":"                ; state_body_hash = None","counters":[]},{"line":"                }","counters":[]},{"line":"            } )","counters":[]},{"line":"","counters":[]},{"line":"      let gen_spot_pair =","counters":[]},{"line":"        let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"        let%bind a, b =","counters":[]},{"line":"          match%bind","counters":[]},{"line":"            Quickcheck.Generator.of_list","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"              [ `Short_aligned; `Short_misaligned; `Long ]","counters":[]},{"line":"          with","counters":[]},{"line":"          | `Short_aligned ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              gen_spot_pair_short_aligned ()","counters":[]},{"line":"          | `Short_misaligned ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              gen_spot_pair_short_misaligned ()","counters":[]},{"line":"          | `Long ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              gen_spot_pair_long","counters":[]},{"line":"        in","counters":[]},{"line":"        if%map Quickcheck.Generator.bool then (a, b) else (b, a)","counters":[]},{"line":"","counters":[]},{"line":"      let assert_consensus_state_set (type t) (set : t) ~project ~assertion ~f =","counters":[]},{"line":"        (* TODO: make output prettier *)","counters":[]},{"line":"        if not (f set) then","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":16,"col_end":16,"count":0}]},{"line":"          let indent_size = 2 in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let indent = String.init indent_size ~f:(Fn.const ' ') in","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"          let indented_json state =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            state |> Consensus_state.Value.to_yojson","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            |> Yojson.Safe.pretty_to_string |> String.split ~on:'\\n'","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"            |> String.concat ~sep:(indent ^ \"\\n\")","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"          in","counters":[]},{"line":"          let message =","counters":[]},{"line":"            let comparison_sep = Printf.sprintf \"\\n%svs\\n\" indent in","counters":[]},{"line":"            let comparison =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              set |> project |> List.map ~f:indented_json","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"              |> String.concat ~sep:comparison_sep","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"            in","counters":[]},{"line":"            Printf.sprintf \"Expected pair of consensus states to be %s:\\n%s\"","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"              assertion comparison","counters":[]},{"line":"          in","counters":[]},{"line":"          raise (Failure message)","counters":[]},{"line":"","counters":[]},{"line":"      let assert_consensus_state_pair =","counters":[]},{"line":"        assert_consensus_state_set ~project:(fun (a, b) -> [ a; b ])","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"","counters":[]},{"line":"      let assert_hashed_consensus_state_pair =","counters":[]},{"line":"        assert_consensus_state_set ~project:(fun (a, b) ->","counters":[]},{"line":"            [ With_hash.data a; With_hash.data b ] )","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"","counters":[]},{"line":"      let assert_hashed_consensus_state_triple =","counters":[]},{"line":"        assert_consensus_state_set ~project:(fun (a, b, c) ->","counters":[]},{"line":"            [ With_hash.data a; With_hash.data b; With_hash.data c ] )","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"","counters":[]},{"line":"      let is_selected (a, b) =","counters":[]},{"line":"        Hooks.equal_select_status `Take","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (Hooks.select ~context:(module Context) ~existing:a ~candidate:b)","counters":[]},{"line":"","counters":[]},{"line":"      let is_not_selected (a, b) =","counters":[]},{"line":"        Hooks.equal_select_status `Keep","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (Hooks.select ~context:(module Context) ~existing:a ~candidate:b)","counters":[]},{"line":"","counters":[]},{"line":"      let assert_selected =","counters":[]},{"line":"        assert_hashed_consensus_state_pair ~assertion:\"trigger selection\"","counters":[]},{"line":"          ~f:is_selected","counters":[]},{"line":"","counters":[]},{"line":"      let assert_not_selected =","counters":[]},{"line":"        assert_hashed_consensus_state_pair ~assertion:\"do not trigger selection\"","counters":[]},{"line":"          ~f:is_not_selected","counters":[]},{"line":"","counters":[]},{"line":"      let%test_unit \"generator sanity check: equal states are always in short \\","counters":[]},{"line":"                     fork range\" =","counters":[]},{"line":"        let constants = Lazy.force Constants.for_unit_tests in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Quickcheck.test (gen_spot ()) ~f:(fun state ->","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"            assert_consensus_state_pair (state, state)","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              ~assertion:\"within long range\" ~f:(fun (a, b) ->","counters":[]},{"line":"                Hooks.is_short_range a b ~constants ) )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"","counters":[]},{"line":"      let%test_unit \"generator sanity check: gen_spot_pair_short_aligned \\","counters":[]},{"line":"                     always generates pairs of states in short fork range\" =","counters":[]},{"line":"        let constants = Lazy.force Constants.for_unit_tests in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Quickcheck.test (gen_spot_pair_short_aligned ()) ~f:(fun (a, b) ->","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"            assert_consensus_state_pair","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (With_hash.data a, With_hash.data b)","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"              ~assertion:\"within short range\"","counters":[]},{"line":"              ~f:(fun (a, b) -> Hooks.is_short_range a b ~constants) )","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"","counters":[]},{"line":"      let%test_unit \"generator sanity check: gen_spot_pair_short_misaligned \\","counters":[]},{"line":"                     always generates pairs of states in short fork range\" =","counters":[]},{"line":"        let constants = Lazy.force Constants.for_unit_tests in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Quickcheck.test (gen_spot_pair_short_misaligned ()) ~f:(fun (a, b) ->","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"            assert_consensus_state_pair","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (With_hash.data a, With_hash.data b)","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"              ~assertion:\"within short range\"","counters":[]},{"line":"              ~f:(fun (a, b) -> Hooks.is_short_range a b ~constants) )","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"","counters":[]},{"line":"      let%test_unit \"generator sanity check: gen_spot_pair_long always \\","counters":[]},{"line":"                     generates pairs of states in long fork range\" =","counters":[]},{"line":"        let constants = Lazy.force Constants.for_unit_tests in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Quickcheck.test gen_spot_pair_long ~f:(fun (a, b) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            assert_consensus_state_pair","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (With_hash.data a, With_hash.data b)","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"              ~assertion:\"within long range\"","counters":[]},{"line":"              ~f:(fun (a, b) -> not (Hooks.is_short_range ~constants a b)) )","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"","counters":[]},{"line":"      let%test_unit \"selection case: equal states\" =","counters":[]},{"line":"        Quickcheck.test","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (Quickcheck.Generator.tuple2 State_hash.gen (gen_spot ()))","counters":[{"col_start":37,"col_end":37,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"          ~f:(fun (hash, state) ->","counters":[]},{"line":"            let hashed_state =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              { With_hash.data = state","counters":[]},{"line":"              ; hash =","counters":[]},{"line":"                  { State_hash.State_hashes.state_hash = hash","counters":[]},{"line":"                  ; state_body_hash = None","counters":[]},{"line":"                  }","counters":[]},{"line":"              }","counters":[]},{"line":"            in","counters":[]},{"line":"            assert_not_selected (hashed_state, hashed_state) )","counters":[]},{"line":"","counters":[]},{"line":"      let%test_unit \"selection case: aligned checkpoints & different lengths\" =","counters":[]},{"line":"        Quickcheck.test","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (gen_spot_pair_short_aligned ~blockchain_length_relativity:`Ascending","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"             () )","counters":[]},{"line":"          ~f:assert_selected","counters":[]},{"line":"","counters":[]},{"line":"      let%test_unit \"selection case: aligned checkpoints & equal lengths & \\","counters":[]},{"line":"                     different vrfs\" =","counters":[]},{"line":"        Quickcheck.test","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (gen_spot_pair_short_aligned ~blockchain_length_relativity:`Equal","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"             ~vrf_output_relativity:`Ascending () )","counters":[]},{"line":"          ~f:assert_selected","counters":[]},{"line":"","counters":[]},{"line":"      let%test_unit \"selection case: aligned checkpoints & equal lengths & \\","counters":[]},{"line":"                     equal vrfs & different hashes\" =","counters":[]},{"line":"        Quickcheck.test","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (gen_spot_pair_short_aligned ~blockchain_length_relativity:`Equal","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"             ~vrf_output_relativity:`Equal () )","counters":[]},{"line":"          ~f:(fun (a, b) ->","counters":[]},{"line":"            if","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              State_hash.(","counters":[]},{"line":"                With_state_hashes.state_hash b > With_state_hashes.state_hash a)","counters":[{"col_start":43,"col_end":43,"count":0},{"col_start":76,"col_end":76,"count":0}]},{"line":"            then assert_selected (a, b)","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"            else assert_selected (b, a) )","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"","counters":[]},{"line":"      let%test_unit \"selection case: misaligned checkpoints & different lengths\"","counters":[]},{"line":"          =","counters":[]},{"line":"        Quickcheck.test","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (gen_spot_pair_short_misaligned","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"             ~blockchain_length_relativity:`Ascending () )","counters":[]},{"line":"          ~f:assert_selected","counters":[]},{"line":"","counters":[]},{"line":"      (* TODO: This test always succeeds, but this could be a false positive as the blockchain length equality constraint","counters":[]},{"line":"       * is broken for misaligned short forks.","counters":[]},{"line":"       *)","counters":[]},{"line":"      let%test_unit \"selection case: misaligned checkpoints & equal lengths & \\","counters":[]},{"line":"                     different vrfs\" =","counters":[]},{"line":"        Quickcheck.test","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (gen_spot_pair_short_misaligned ~blockchain_length_relativity:`Equal","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"             ~vrf_output_relativity:`Ascending () )","counters":[]},{"line":"          ~f:assert_selected","counters":[]},{"line":"","counters":[]},{"line":"      (* TODO: This test fails because the blockchain length equality constraint is broken for misaligned short forks.","counters":[]},{"line":"         let%test_unit \"selection case: misaligned checkpoints & equal lengths & equal vrfs & different hashes\" =","counters":[]},{"line":"         Quickcheck.test","counters":[]},{"line":"         (gen_spot_pair_short_misaligned ~blockchain_length_relativity:`Equal ~vrf_output_relativity:`Equal ())","counters":[]},{"line":"         ~f:(fun (a, b) ->","counters":[]},{"line":"         if State_hash.compare (With_hash.hash a) (With_hash.hash b) > 0 then","counters":[]},{"line":"         assert_selected (a, b)","counters":[]},{"line":"         else","counters":[]},{"line":"         assert_selected (b, a))","counters":[]},{"line":"      *)","counters":[]},{"line":"","counters":[]},{"line":"      (* TODO: expand long fork generation to support relativity constraints","counters":[]},{"line":"         let%test_unit \"selection case: distinct checkpoints & different min window densities\" =","counters":[]},{"line":"         failwith \"TODO\"","counters":[]},{"line":"","counters":[]},{"line":"         let%test_unit \"selection case: distinct checkpoints & equal min window densities & different lengths\" =","counters":[]},{"line":"         failwith \"TODO\"","counters":[]},{"line":"","counters":[]},{"line":"         let%test_unit \"selection case: distinct checkpoints & equal min window densities & equal lengths & different vrfs\" =","counters":[]},{"line":"         failwith \"TODO\"","counters":[]},{"line":"","counters":[]},{"line":"         let%test_unit \"selection case: distinct checkpoints & equal min window densities & equal lengths & qequals vrfs & different hashes\" =","counters":[]},{"line":"         failwith \"TODO\"","counters":[]},{"line":"      *)","counters":[]},{"line":"","counters":[]},{"line":"      let%test_unit \"selection invariant: candidate selections are not \\","counters":[]},{"line":"                     commutative\" =","counters":[]},{"line":"        let select existing candidate =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Hooks.select ~context:(module Context) ~existing ~candidate","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        in","counters":[]},{"line":"        Quickcheck.test gen_spot_pair","counters":[]},{"line":"          ~f:","counters":[]},{"line":"            (assert_hashed_consensus_state_pair","counters":[]},{"line":"               ~assertion:\"chains do not trigger a selection cycle\"","counters":[]},{"line":"               ~f:(fun (a, b) ->","counters":[]},{"line":"                 not","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                   ([%equal: Hooks.select_status * Hooks.select_status]","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                      (select a b, select b a)","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"                      (`Take, `Take) ) ) )","counters":[]},{"line":"","counters":[]},{"line":"      (* We define a homogeneous binary relation for consensus states by adapting the binary chain","counters":[]},{"line":"       * selection rule and extending it to consider equality of chains. From this, we can test","counters":[]},{"line":"       * that this extended relations forms a non-strict partial order over the set of consensus","counters":[]},{"line":"       * states.","counters":[]},{"line":"       *","counters":[]},{"line":"       * We omit partial order reflexivity and antisymmetry tests as they are merely testing properties","counters":[]},{"line":"       * of equality related to the partial order we define from binary chain selection. Chain","counters":[]},{"line":"       * selection, as is written, will always reject equal elements, so the only property we are","counters":[]},{"line":"       * truly interested in it holding is transitivity (when lifted to a homogeneous binary relation).","counters":[]},{"line":"       *","counters":[]},{"line":"       * TODO: Improved quickcheck generator which better explores related states via our spot","counters":[]},{"line":"       * pair generation rules. Doing this requires re-working our spot pair generators to","counters":[]},{"line":"       * work by extending an already generated consensus state with some relative constraints.","counters":[]},{"line":"       *)","counters":[]},{"line":"      let%test_unit \"selection invariant: partial order transitivity\" =","counters":[]},{"line":"        let select existing candidate =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Hooks.select ~context:(module Context) ~existing ~candidate","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        in","counters":[]},{"line":"        let ( <= ) a b =","counters":[]},{"line":"          match (select a b, select b a) with","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"          | `Keep, `Keep ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              true","counters":[]},{"line":"          | `Keep, `Take ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              true","counters":[]},{"line":"          | `Take, `Keep ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              false","counters":[]},{"line":"          | `Take, `Take ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              assert_hashed_consensus_state_pair (a, b)","counters":[]},{"line":"                ~assertion:\"chains do not trigger a selection cycle\"","counters":[]},{"line":"                ~f:(Fn.const false) ;","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"              (* unreachable *)","counters":[]},{"line":"              false","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"        in","counters":[]},{"line":"        let chains_hold_transitivity (a, b, c) =","counters":[]},{"line":"          if a <= b then if b <= c then a <= c else c <= b","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"          else if b <= c then if c <= a then b <= a else a <= c","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"          else if c <= a then if a <= b then c <= b else b <= a","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"          else false","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"        in","counters":[]},{"line":"        let gen = gen_with_hash (gen_spot ()) in","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"        Quickcheck.test","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (Quickcheck.Generator.tuple3 gen gen gen)","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"          ~f:","counters":[]},{"line":"            (assert_hashed_consensus_state_triple","counters":[]},{"line":"               ~assertion:\"chains hold partial order transitivity\"","counters":[]},{"line":"               ~f:chains_hold_transitivity )","counters":[]},{"line":"    end )","counters":[]},{"line":"","counters":[]},{"line":"  module Exported = struct","counters":[]},{"line":"    module Global_slot = Global_slot","counters":[]},{"line":"    module Block_data = Data.Block_data","counters":[]},{"line":"    module Consensus_state = Data.Consensus_state","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Body_reference = Body_reference","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"include Wire_types.Make (Make_sig) (Make_str)","counters":[{"col_start":44,"col_end":44,"count":1}]}]}