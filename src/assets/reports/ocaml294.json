{"filename":"src/lib/transition_frontier/catchup_hash_tree.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Mina_base","counters":[]},{"line":"open Frontier_base","counters":[]},{"line":"","counters":[]},{"line":"module Catchup_job_id = Unique_id.Int ()","counters":[]},{"line":"","counters":[]},{"line":"module Node = struct","counters":[]},{"line":"  module State = struct","counters":[]},{"line":"    module Ids = struct","counters":[]},{"line":"      type t = Catchup_job_id.Hash_set.t","counters":[]},{"line":"","counters":[]},{"line":"      let equal = Hash_set.equal","counters":[]},{"line":"","counters":[]},{"line":"      let to_yojson (t : t) =","counters":[]},{"line":"        `List","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (List.map (Hash_set.to_list t) ~f:(fun x ->","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"               `String (Catchup_job_id.to_string x) ) )","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    type t = Have_breadcrumb | Part_of_catchups of Ids.t","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":51,"col_end":51,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"    [@@deriving to_yojson, equal]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  type t =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    { parent : State_hash.t","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"    ; state : State.t","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":20,"col_end":20,"count":0}]},{"line":"          (* If a node has a breadcrumb, then all of its ancestors have","counters":[]},{"line":"             breadcrumbs as well. *)","counters":[]},{"line":"    }","counters":[]},{"line":"  [@@deriving to_yojson]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module L = struct","counters":[]},{"line":"  type t = Logger.t","counters":[]},{"line":"","counters":[]},{"line":"  let to_yojson _ = `String \"logger\"","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module State_hash_table = struct","counters":[]},{"line":"  type 'a t = 'a State_hash.Table.t","counters":[]},{"line":"","counters":[]},{"line":"  let to_yojson f t : Yojson.Safe.t =","counters":[]},{"line":"    `Assoc","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (List.map (State_hash.Table.to_alist t) ~f:(fun (h, x) ->","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"           (State_hash.to_base58_check h, f x) ) )","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module State_hash_hash_set = struct","counters":[]},{"line":"  type t = State_hash.Hash_set.t","counters":[]},{"line":"","counters":[]},{"line":"  let to_yojson (t : t) : Yojson.Safe.t =","counters":[]},{"line":"    `List (List.map (Hash_set.to_list t) ~f:State_hash.to_yojson)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module State_hash_set = struct","counters":[]},{"line":"  type t = State_hash.Set.t","counters":[]},{"line":"","counters":[]},{"line":"  let to_yojson (t : t) : Yojson.Safe.t =","counters":[]},{"line":"    `List (List.map (Set.to_list t) ~f:State_hash.to_yojson)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"type t =","counters":[{"col_start":0,"col_end":0,"count":0}]},{"line":"  { nodes : Node.t State_hash_table.t","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"  ; tips : State_hash_hash_set.t","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"  ; children : State_hash_set.t State_hash_table.t","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"  ; mutable root : State_hash.t","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"  ; logger : L.t","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"  }","counters":[]},{"line":"[@@deriving to_yojson]","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"","counters":[]},{"line":"let max_catchup_chain_length t =","counters":[]},{"line":"  let rec missing_length acc (node : Node.t) =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    match node.state with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Have_breadcrumb ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        acc","counters":[]},{"line":"    | Part_of_catchups _ -> (","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        match Hashtbl.find t.nodes node.parent with","counters":[]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (* This node is a root. *)","counters":[]},{"line":"            acc","counters":[]},{"line":"        | Some parent ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            missing_length (acc + 1) parent )","counters":[]},{"line":"  in","counters":[]},{"line":"  Hash_set.fold t.tips ~init:0 ~f:(fun acc tip ->","counters":[]},{"line":"      Int.max acc (missing_length 0 (Hashtbl.find_exn t.nodes tip)) )","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"","counters":[]},{"line":"let create ~root =","counters":[]},{"line":"  let root_hash = Breadcrumb.state_hash root in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let parent = Breadcrumb.parent_hash root in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let nodes =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    State_hash.Table.of_alist_exn","counters":[]},{"line":"      [ (root_hash, { Node.parent; state = Have_breadcrumb }) ]","counters":[]},{"line":"  in","counters":[]},{"line":"  { root = root_hash","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  ; tips = State_hash.Hash_set.create ()","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"  ; children =","counters":[]},{"line":"      State_hash.Table.of_alist_exn","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"        [ (parent, State_hash.Set.singleton root_hash) ]","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"  ; nodes","counters":[]},{"line":"  ; logger = Logger.create ()","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"let check_for_parent t h ~parent:p ~check_has_breadcrumb =","counters":[]},{"line":"  match Hashtbl.find t.nodes p with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | None ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      [%log' debug t.logger]","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"        ~metadata:","counters":[]},{"line":"          [ (\"parent\", State_hash.to_yojson p)","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"          ; (\"hash\", State_hash.to_yojson h)","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"          ; (\"tree\", to_yojson t)","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"          ]","counters":[]},{"line":"        \"hash tree invariant broken: $parent not found in $tree for $hash\"","counters":[]},{"line":"  | Some x ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      if check_has_breadcrumb && not (Node.State.equal x.state Have_breadcrumb)","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"      then","counters":[]},{"line":"        [%log' debug t.logger]","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"          ~metadata:","counters":[]},{"line":"            [ (\"parent\", State_hash.to_yojson p)","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"            ; (\"hash\", State_hash.to_yojson h)","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"            ; (\"tree\", to_yojson t)","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"            ]","counters":[]},{"line":"          \"hash tree invariant broken: expected $parent to have breadcrumb \\","counters":[]},{"line":"           (child is $hash) in $tree\"","counters":[]},{"line":"      else ()","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"","counters":[]},{"line":"let add_child t h ~parent =","counters":[]},{"line":"  Hashtbl.update t.children parent ~f:(function","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        State_hash.Set.singleton h","counters":[]},{"line":"    | Some s ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Set.add s h )","counters":[]},{"line":"","counters":[]},{"line":"let add t h ~parent ~job =","counters":[]},{"line":"  if Hashtbl.mem t.nodes h then","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    match (Hashtbl.find_exn t.nodes h).state with","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"    | Have_breadcrumb ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ()","counters":[]},{"line":"    | Part_of_catchups s ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Hash_set.add s job","counters":[]},{"line":"  else (","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"    check_for_parent t h ~parent ~check_has_breadcrumb:false ;","counters":[]},{"line":"    if not (Hashtbl.mem t.children h) then Hash_set.add t.tips h ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":43,"col_end":43,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"    add_child t h ~parent ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Hash_set.remove t.tips parent ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Hashtbl.set t.nodes ~key:h","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ~data:","counters":[]},{"line":"        { parent; state = Part_of_catchups (Catchup_job_id.Hash_set.create ()) }","counters":[{"col_start":73,"col_end":73,"count":0}]},{"line":"    )","counters":[]},{"line":"","counters":[]},{"line":"let breadcrumb_added (t : t) b =","counters":[]},{"line":"  let h = Breadcrumb.state_hash b in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let parent = Breadcrumb.parent_hash b in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  check_for_parent t h ~parent ~check_has_breadcrumb:true ;","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  Hashtbl.update t.nodes h ~f:(function","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (* New child *)","counters":[]},{"line":"        add_child t h ~parent ;","counters":[]},{"line":"        { parent; state = Have_breadcrumb }","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    | Some x ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { x with state = Have_breadcrumb } ) ;","counters":[]},{"line":"  Hash_set.remove t.tips h","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let remove_node t h =","counters":[]},{"line":"  Hash_set.remove t.tips h ;","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  match Hashtbl.find_and_remove t.nodes h with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | None ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ()","counters":[]},{"line":"  | Some { parent; _ } ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Hashtbl.change t.children parent ~f:(function","counters":[]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            None","counters":[]},{"line":"        | Some s ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let s' = Set.remove s h in","counters":[]},{"line":"            if Set.is_empty s' then None else Some s' )","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"","counters":[]},{"line":"(* Remove everything not reachable from the root *)","counters":[]},{"line":"let prune t =","counters":[]},{"line":"  let keep = State_hash.Hash_set.create () in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let rec go stack =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    match stack with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | [] ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ()","counters":[]},{"line":"    | next :: stack ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Hash_set.add keep next ;","counters":[]},{"line":"        let stack =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          match Hashtbl.find t.children next with","counters":[]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              stack","counters":[]},{"line":"          | Some cs ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              List.rev_append (Set.to_list cs) stack","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"        in","counters":[]},{"line":"        go stack","counters":[]},{"line":"  in","counters":[]},{"line":"  go [ t.root ] ;","counters":[]},{"line":"  List.iter (Hashtbl.keys t.nodes) ~f:(fun h ->","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"      if not (Hash_set.mem keep h) then remove_node t h )","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"let catchup_failed t job =","counters":[]},{"line":"  let to_remove =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Hashtbl.fold t.nodes ~init:[] ~f:(fun ~key ~data acc ->","counters":[]},{"line":"        match data.state with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | Have_breadcrumb ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            acc","counters":[]},{"line":"        | Part_of_catchups s ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Hash_set.remove s job ;","counters":[]},{"line":"            if Hash_set.is_empty s then key :: acc else acc )","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"  in","counters":[]},{"line":"  List.iter to_remove ~f:(remove_node t)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"","counters":[]},{"line":"let apply_diffs t (ds : Diff.Full.E.t list) =","counters":[]},{"line":"  List.iter ds ~f:(function","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    | E (New_node (Full b)) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        breadcrumb_added t b","counters":[]},{"line":"    | E (Root_transitioned { new_root; garbage = Full hs; _ }) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        List.iter (Diff.Node_list.to_lite hs) ~f:(remove_node t) ;","counters":[{"col_start":40,"col_end":40,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"        let h = (Root_data.Limited.hashes new_root).state_hash in","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"        Hashtbl.change t.nodes h ~f:(function","counters":[]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              [%log' debug t.logger]","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                ~metadata:","counters":[]},{"line":"                  [ (\"hash\", State_hash.to_yojson h); (\"tree\", to_yojson t) ]","counters":[{"col_start":48,"col_end":48,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"                \"hash $tree invariant broken: new root $hash not present. \\","counters":[]},{"line":"                 Diffs may have been applied out of order\" ;","counters":[]},{"line":"              None","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"          | Some x ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              t.root <- h ;","counters":[]},{"line":"              Some { x with state = Have_breadcrumb } ) ;","counters":[]},{"line":"        prune t","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    | E (Best_tip_changed _) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        () )","counters":[{"col_start":11,"col_end":11,"count":2}]}]}