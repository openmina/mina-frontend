{"filename":"src/ffi/mask.rs","lines":[{"line":"use std::{borrow::Borrow, cell::RefCell, rc::Rc, str::FromStr};","counters":[]},{"line":"","counters":[]},{"line":"use mina_hasher::Fp;","counters":[]},{"line":"use mina_p2p_messages::v2::NonZeroCurvePointUncompressedStableV1;","counters":[]},{"line":"use ocaml_interop::{","counters":[]},{"line":"    impl_to_ocaml_polymorphic_variant, impl_to_ocaml_variant, ocaml_export, DynBox, OCaml,","counters":[]},{"line":"    OCamlBytes, OCamlException, OCamlInt, OCamlList, OCamlRef, OCamlRuntime, ToOCaml,","counters":[]},{"line":"};","counters":[]},{"line":"","counters":[]},{"line":"use crate::{","counters":[]},{"line":"    account::{Account, AccountId},","counters":[]},{"line":"    address::Address,","counters":[]},{"line":"    base::{AccountIndex, BaseLedger, MerklePath},","counters":[]},{"line":"    ffi::util::*,","counters":[]},{"line":"    ffi::DatabaseFFI,","counters":[]},{"line":"    short_backtrace, Mask, UnregisterBehavior,","counters":[]},{"line":"};","counters":[]},{"line":"","counters":[]},{"line":"// #[derive(Clone)]","counters":[]},{"line":"struct MaskFFI(Rc<RefCell<Option<Mask>>>);","counters":[]},{"line":"","counters":[]},{"line":"impl Drop for MaskFFI {","counters":[]},{"line":"    fn drop(&mut self) {","counters":[{"col_start":4,"col_end":24,"count":2}]},{"line":"        let mask_id = RefCell::borrow(&self.0).as_ref().map(|mask| mask.short());","counters":[{"col_start":0,"col_end":60,"count":2},{"col_start":67,"col_end":79,"count":0},{"col_start":79,"col_end":81,"count":2}]},{"line":"        elog!(\"rust_mask_drop {:?}\", mask_id);","counters":[{"col_start":0,"col_end":46,"count":2}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":2}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"fn with_mask<F, R>(rt: &mut &mut OCamlRuntime, mask: OCamlRef<DynBox<MaskFFI>>, fun: F) -> R","counters":[{"col_start":0,"col_end":92,"count":2860}]},{"line":"where","counters":[{"col_start":0,"col_end":5,"count":2860}]},{"line":"    F: FnOnce(&mut Mask) -> R,","counters":[{"col_start":0,"col_end":30,"count":2860}]},{"line":"{","counters":[{"col_start":0,"col_end":1,"count":2860}]},{"line":"    // elog!(\"111\");","counters":[{"col_start":0,"col_end":20,"count":2860}]},{"line":"    let mask = rt.get(mask);","counters":[{"col_start":0,"col_end":28,"count":2860}]},{"line":"    // elog!(\"222\");","counters":[{"col_start":0,"col_end":20,"count":2860}]},{"line":"    let mask: &MaskFFI = mask.borrow();","counters":[{"col_start":0,"col_end":39,"count":2860}]},{"line":"    // elog!(\"333\");","counters":[{"col_start":0,"col_end":20,"count":2860}]},{"line":"    let mut mask = mask.0.borrow_mut();","counters":[{"col_start":0,"col_end":39,"count":2860}]},{"line":"","counters":[]},{"line":"    // elog!(","counters":[{"col_start":0,"col_end":13,"count":2860}]},{"line":"    //     \"with_mask {:p}\",","counters":[{"col_start":0,"col_end":28,"count":2860}]},{"line":"    //     Arc::as_ptr(&mask.borrow().as_ref().unwrap().inner)","counters":[{"col_start":0,"col_end":62,"count":2860}]},{"line":"    // );","counters":[{"col_start":0,"col_end":9,"count":2860}]},{"line":"","counters":[]},{"line":"    // let mut db = db.0.borrow_mut();","counters":[{"col_start":0,"col_end":38,"count":2860}]},{"line":"","counters":[]},{"line":"    fun(mask.as_mut().unwrap())","counters":[{"col_start":0,"col_end":31,"count":2860}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":2860}]},{"line":"","counters":[]},{"line":"pub enum PolymorphicGetOrAdded {","counters":[]},{"line":"    Added,","counters":[]},{"line":"    Existed,","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl_to_ocaml_polymorphic_variant! {","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"    PolymorphicGetOrAdded {","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"        PolymorphicGetOrAdded::Added,","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"        PolymorphicGetOrAdded::Existed,","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"pub enum PolymorphicPath {","counters":[]},{"line":"    Left(Vec<u8>),","counters":[]},{"line":"    Right(Vec<u8>),","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl_to_ocaml_polymorphic_variant! {","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"    PolymorphicPath {","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"        PolymorphicPath::Left(hash: OCamlBytes),","counters":[{"col_start":0,"col_end":48,"count":0}]},{"line":"        PolymorphicPath::Right(hash: OCamlBytes),","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"#[derive(Debug, PartialEq, Eq)]","counters":[{"col_start":9,"col_end":14,"count":0}]},{"line":"pub enum DatabaseErrorFFI {","counters":[]},{"line":"    OutOfLeaves,","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl_to_ocaml_variant! {","counters":[]},{"line":"    DatabaseErrorFFI {","counters":[]},{"line":"        DatabaseErrorFFI::OutOfLeaves,","counters":[]},{"line":"    }","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"// type rust_grandchildren = [ `Check | `Recursive | `I_promise_I_am_reparenting_this_mask ]","counters":[]},{"line":"#[allow(non_camel_case_types)]","counters":[]},{"line":"pub enum PolymorphicGrandchildren {","counters":[]},{"line":"    Check,","counters":[]},{"line":"    Recursive,","counters":[]},{"line":"    I_promise_I_am_reparenting_this_mask,","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"// static DB_CLOSED: Lazy<Mutex<HashMap<PathBuf, Database<V2>>>> =","counters":[]},{"line":"//     Lazy::new(|| Mutex::new(HashMap::with_capacity(16)));","counters":[]},{"line":"","counters":[]},{"line":"// static DB_CLOSED: Arc<Mutex<Option<HashMap<PathBuf, Database<V2>>>>> = Arc::new(Mutex::new(None));","counters":[]},{"line":"","counters":[]},{"line":"// fn get_list_of<'a, T>(","counters":[]},{"line":"//     rt: &'a mut &mut OCamlRuntime,","counters":[]},{"line":"//     list: OCamlRef<OCamlList<OCamlBytes>>,","counters":[]},{"line":"// ) -> Vec<T>","counters":[]},{"line":"// where","counters":[]},{"line":"//     T: BinProtRead,","counters":[]},{"line":"// {","counters":[]},{"line":"//     let mut list_ref = rt.get(list);","counters":[]},{"line":"//     let mut list = Vec::with_capacity(2048);","counters":[]},{"line":"","counters":[]},{"line":"//     while let Some((head, tail)) = list_ref.uncons() {","counters":[]},{"line":"//         let object: T = serde_binprot::from_slice(head.as_bytes()).unwrap();","counters":[]},{"line":"//         list.push(object);","counters":[]},{"line":"//         list_ref = tail;","counters":[]},{"line":"//     }","counters":[]},{"line":"","counters":[]},{"line":"//     list","counters":[]},{"line":"// }","counters":[]},{"line":"","counters":[]},{"line":"// fn get_set_of<'a, T>(","counters":[]},{"line":"//     rt: &'a mut &mut OCamlRuntime,","counters":[]},{"line":"//     list: OCamlRef<OCamlList<OCamlBytes>>,","counters":[]},{"line":"// ) -> HashSet<T>","counters":[]},{"line":"// where","counters":[]},{"line":"//     T: Deserialize<'a> + Hash + Eq,","counters":[]},{"line":"// {","counters":[]},{"line":"//     let mut list_ref = rt.get(list);","counters":[]},{"line":"//     let mut set = HashSet::with_capacity(2048);","counters":[]},{"line":"","counters":[]},{"line":"//     while let Some((head, tail)) = list_ref.uncons() {","counters":[]},{"line":"//         let object: T = serde_binprot::from_slice(head.as_bytes()).unwrap();","counters":[]},{"line":"//         set.insert(object);","counters":[]},{"line":"//         list_ref = tail;","counters":[]},{"line":"//     }","counters":[]},{"line":"","counters":[]},{"line":"//     set","counters":[]},{"line":"// }","counters":[]},{"line":"","counters":[]},{"line":"// fn get_list_addr_account<'a>(","counters":[]},{"line":"//     rt: &'a mut &mut OCamlRuntime,","counters":[]},{"line":"//     list: OCamlRef<OCamlList<(String, OCamlBytes)>>,","counters":[]},{"line":"// ) -> Vec<(Address, Account)> {","counters":[]},{"line":"//     let mut list_ref = rt.get(list);","counters":[]},{"line":"//     let mut list = Vec::with_capacity(2048);","counters":[]},{"line":"","counters":[]},{"line":"//     while let Some((head, tail)) = list_ref.uncons() {","counters":[]},{"line":"//         let addr = head.fst().as_str();","counters":[]},{"line":"//         let account = head.snd().as_bytes();","counters":[]},{"line":"","counters":[]},{"line":"//         let addr = Address::try_from(addr).unwrap();","counters":[]},{"line":"//         let object: Account = serde_binprot::from_slice(account).unwrap();","counters":[]},{"line":"//         list.push((addr, object));","counters":[]},{"line":"","counters":[]},{"line":"//         list_ref = tail;","counters":[]},{"line":"//     }","counters":[]},{"line":"","counters":[]},{"line":"//     list","counters":[]},{"line":"// }","counters":[]},{"line":"","counters":[]},{"line":"// fn get_addr(rt: &mut &mut OCamlRuntime, addr: OCamlRef<String>) -> Address {","counters":[]},{"line":"//     let addr_ref = rt.get(addr);","counters":[]},{"line":"//     Address::try_from(addr_ref.as_str()).unwrap()","counters":[]},{"line":"// }","counters":[]},{"line":"","counters":[]},{"line":"// fn get<'a, T>(rt: &'a mut &mut OCamlRuntime, object: OCamlRef<OCamlBytes>) -> T","counters":[]},{"line":"// where","counters":[]},{"line":"//     T: Deserialize<'a>,","counters":[]},{"line":"// {","counters":[]},{"line":"//     let object_ref = rt.get(object);","counters":[]},{"line":"//     serde_binprot::from_slice(object_ref.as_bytes()).unwrap()","counters":[]},{"line":"// }","counters":[]},{"line":"","counters":[]},{"line":"// fn get_index(rt: &mut &mut OCamlRuntime, index: OCamlRef<OCamlInt>) -> AccountIndex {","counters":[]},{"line":"//     let index: i64 = index.to_rust(rt);","counters":[]},{"line":"//     let index: u64 = index.try_into().unwrap();","counters":[]},{"line":"//     AccountIndex(index)","counters":[]},{"line":"// }","counters":[]},{"line":"","counters":[]},{"line":"// fn hash_to_ocaml(hash: Fp) -> Vec<u8> {","counters":[]},{"line":"//     let hash: BigInt = hash.into();","counters":[]},{"line":"//     serialize(&hash).unwrap()","counters":[]},{"line":"// }","counters":[]},{"line":"","counters":[]},{"line":"fn get_cloned_mask(","counters":[]},{"line":"    rt: &mut &mut OCamlRuntime,","counters":[]},{"line":"    mask: OCamlRef<DynBox<MaskFFI>>,","counters":[]},{"line":") -> Rc<RefCell<Option<Mask>>> {","counters":[]},{"line":"    let mask = rt.get(mask);","counters":[]},{"line":"    let mask: &MaskFFI = mask.borrow();","counters":[]},{"line":"    // let mut mask = mask.0.borrow_mut();","counters":[]},{"line":"    Rc::clone(&mask.0)","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"ocaml_export! {","counters":[]},{"line":"    fn rust_mask_create(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        depth: OCamlRef<OCamlInt>,","counters":[]},{"line":"    ) -> OCaml<DynBox<MaskFFI>> {","counters":[]},{"line":"        elog!(\"backtrace=\\n{}\", short_backtrace());","counters":[]},{"line":"","counters":[]},{"line":"        let depth: i64 = depth.to_rust(rt);","counters":[]},{"line":"        let depth: usize = depth.try_into().unwrap();","counters":[]},{"line":"","counters":[]},{"line":"        let mask = Mask::new_unattached(depth);","counters":[]},{"line":"","counters":[]},{"line":"        let mask = MaskFFI(Rc::new(RefCell::new(Some(mask))));","counters":[]},{"line":"","counters":[]},{"line":"        OCaml::box_value(rt, mask)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_cast_database_to_mask(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        db: OCamlRef<DynBox<DatabaseFFI>>","counters":[]},{"line":"    ) -> OCaml<DynBox<MaskFFI>> {","counters":[]},{"line":"        // let bt = backtrace::Backtrace::new();","counters":[]},{"line":"        // elog!(\"rust_cast_database_to_mask bt={:#?}\", bt);","counters":[]},{"line":"","counters":[]},{"line":"        let db = {","counters":[]},{"line":"            let db = rt.get(db);","counters":[]},{"line":"            let db: &DatabaseFFI = db.borrow();","counters":[]},{"line":"","counters":[]},{"line":"            // elog!(\"CAST_DATABASE_TO_MASK PTR={:p}\", Rc::as_ptr(&db.0));","counters":[]},{"line":"","counters":[]},{"line":"            let db = db.0.borrow_mut();","counters":[]},{"line":"            let db = db.as_ref().unwrap().clone();","counters":[]},{"line":"","counters":[]},{"line":"            db","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        // elog!(\"AAA\");","counters":[]},{"line":"        let mask = Mask::new_root(db);","counters":[]},{"line":"        let mask = MaskFFI(Rc::new(RefCell::new(Some(mask))));","counters":[]},{"line":"        // elog!(\"BBB\");","counters":[]},{"line":"","counters":[]},{"line":"        OCaml::box_value(rt, mask)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_cast(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        mask: OCamlRef<DynBox<MaskFFI>>","counters":[]},{"line":"    ) -> OCaml<DynBox<MaskFFI>> {","counters":[]},{"line":"        // let bt = backtrace::Backtrace::new();","counters":[]},{"line":"        // elog!(\"rust_cast bt={:#?}\", bt);","counters":[]},{"line":"","counters":[]},{"line":"        let mask = rt.get(mask);","counters":[]},{"line":"","counters":[]},{"line":"        // let mask = with_mask(rt, mask, |mask| {","counters":[]},{"line":"        //     mask.clone()","counters":[]},{"line":"        // });","counters":[]},{"line":"        // let mask = MaskFFI(Rc::new(RefCell::new(Some(mask))));","counters":[]},{"line":"","counters":[]},{"line":"        mask","counters":[]},{"line":"        // OCaml::box_value(rt, mask)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_mask_copy(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        mask: OCamlRef<DynBox<MaskFFI>>","counters":[]},{"line":"    ) -> OCaml<DynBox<MaskFFI>> {","counters":[]},{"line":"        let mask = with_mask(rt, mask, |mask| {","counters":[{"col_start":46,"col_end":47,"count":0}]},{"line":"            let uuid = mask.get_uuid();","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"            let copy = mask.copy();","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"            assert_ne!(uuid, copy.get_uuid());","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"            copy","counters":[{"col_start":12,"col_end":16,"count":0}]},{"line":"        });","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"        let mask = MaskFFI(Rc::new(RefCell::new(Some(mask))));","counters":[]},{"line":"","counters":[]},{"line":"        OCaml::box_value(rt, mask)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_mask_set_parent(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        mask: OCamlRef<DynBox<MaskFFI>>,","counters":[]},{"line":"        parent: OCamlRef<DynBox<MaskFFI>>","counters":[]},{"line":"    ) -> OCaml<DynBox<MaskFFI>> {","counters":[]},{"line":"        let parent = {","counters":[]},{"line":"            let parent = rt.get(parent);","counters":[]},{"line":"            let parent: &MaskFFI = parent.borrow();","counters":[]},{"line":"            let parent = parent.0.borrow_mut();","counters":[]},{"line":"            (*parent).as_ref().unwrap().clone()","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        let mask = with_mask(rt, mask, |mask| {","counters":[{"col_start":46,"col_end":47,"count":0}]},{"line":"            mask.set_parent(parent, None)","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"        });","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"        let mask = MaskFFI(Rc::new(RefCell::new(Some(mask))));","counters":[]},{"line":"","counters":[]},{"line":"        OCaml::box_value(rt, mask)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_mask_register_mask(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        mask: OCamlRef<DynBox<MaskFFI>>,","counters":[]},{"line":"        mask2: OCamlRef<DynBox<MaskFFI>>","counters":[]},{"line":"    ) -> OCaml<DynBox<MaskFFI>> {","counters":[]},{"line":"        // let bt = backtrace::Backtrace::new();","counters":[]},{"line":"","counters":[]},{"line":"        // elog!(\"AAA bt={:#?}\", bt);","counters":[]},{"line":"        let mask2 = {","counters":[]},{"line":"            let mask2 = rt.get(mask2);","counters":[]},{"line":"            let mask2: &MaskFFI = mask2.borrow();","counters":[]},{"line":"            let mask2 = mask2.0.borrow_mut();","counters":[]},{"line":"            // elog!(\"BBB {:p}\", Arc::as_ptr(&mask2.borrow().as_ref().unwrap().inner));","counters":[]},{"line":"            (*mask2).as_ref().unwrap().clone()","counters":[]},{"line":"        };","counters":[]},{"line":"        // elog!(\"CCC\");","counters":[]},{"line":"","counters":[]},{"line":"        let mask = with_mask(rt, mask, |mask| {","counters":[{"col_start":46,"col_end":47,"count":0}]},{"line":"            mask.register_mask(mask2)","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"        });","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"        // elog!(\"DDD\");","counters":[]},{"line":"","counters":[]},{"line":"        let mask = MaskFFI(Rc::new(RefCell::new(Some(mask))));","counters":[]},{"line":"","counters":[]},{"line":"        OCaml::box_value(rt, mask)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_mask_unregister_mask(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        mask: OCamlRef<DynBox<MaskFFI>>,","counters":[]},{"line":"        behavior: OCamlRef<PolymorphicGrandchildren>","counters":[]},{"line":"    ) -> OCaml<DynBox<MaskFFI>> {","counters":[]},{"line":"        let behavior = rt.get(behavior);","counters":[]},{"line":"","counters":[]},{"line":"        let behavior = ocaml_interop::ocaml_unpack_polymorphic_variant! {","counters":[{"col_start":23,"col_end":73,"count":0}]},{"line":"            behavior => {","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"                Check => UnregisterBehavior::Check,","counters":[{"col_start":0,"col_end":51,"count":0}]},{"line":"                Recursive => UnregisterBehavior::Recursive,","counters":[{"col_start":0,"col_end":59,"count":0}]},{"line":"                I_promise_I_am_reparenting_this_mask => UnregisterBehavior::IPromiseIAmReparentingThisMask,","counters":[{"col_start":0,"col_end":107,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        }.unwrap();","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        let mask = with_mask(rt, mask, |mask| {","counters":[{"col_start":46,"col_end":47,"count":0}]},{"line":"            mask.unregister_mask(behavior)","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"        });","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        let mask = MaskFFI(Rc::new(RefCell::new(Some(mask))));","counters":[]},{"line":"","counters":[]},{"line":"        OCaml::box_value(rt, mask)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_mask_remove_and_reparent(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        mask: OCamlRef<DynBox<MaskFFI>>","counters":[]},{"line":"    ) {","counters":[]},{"line":"        with_mask(rt, mask, |mask| {","counters":[{"col_start":35,"col_end":36,"count":0}]},{"line":"            mask.remove_and_reparent()","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"        });","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        OCaml::unit()","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_mask_commit(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        mask: OCamlRef<DynBox<MaskFFI>>","counters":[]},{"line":"    ) {","counters":[]},{"line":"        with_mask(rt, mask, |mask| {","counters":[{"col_start":35,"col_end":36,"count":0}]},{"line":"            mask.commit()","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"        });","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        OCaml::unit()","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_print_backtrace(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        _int: OCamlRef<OCamlInt>","counters":[]},{"line":"    ) {","counters":[]},{"line":"        eprintln!(\"rust_print_backtrace=\\n{}\", short_backtrace());","counters":[]},{"line":"","counters":[]},{"line":"        OCaml::unit()","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_mask_get_uuid(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        mask: OCamlRef<DynBox<MaskFFI>>","counters":[]},{"line":"    ) -> OCaml<String> {","counters":[]},{"line":"        let uuid = with_mask(rt, mask, |mask| {","counters":[{"col_start":46,"col_end":47,"count":0}]},{"line":"            mask.get_uuid()","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"        });","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        uuid.to_ocaml(rt)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_mask_get_directory(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        mask: OCamlRef<DynBox<MaskFFI>>","counters":[]},{"line":"    ) -> OCaml<Option<String>> {","counters":[]},{"line":"        let dir = with_mask(rt, mask, |mask| {","counters":[{"col_start":45,"col_end":46,"count":0}]},{"line":"            mask.get_directory().map(|d| d.into_os_string().into_string().unwrap())","counters":[{"col_start":0,"col_end":37,"count":0},{"col_start":41,"col_end":82,"count":0},{"col_start":82,"col_end":83,"count":0}]},{"line":"        });","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        dir.to_ocaml(rt)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_mask_depth(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        mask: OCamlRef<DynBox<MaskFFI>>","counters":[]},{"line":"    ) -> OCaml<OCamlInt> {","counters":[]},{"line":"        let depth = with_mask(rt, mask, |mask| {","counters":[{"col_start":47,"col_end":48,"count":0}]},{"line":"            mask.depth() as i64","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"        });","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        depth.to_ocaml(rt)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_mask_close(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        mask: OCamlRef<DynBox<MaskFFI>>","counters":[]},{"line":"    ) {","counters":[]},{"line":"        // let mask = rt.get(mask);","counters":[]},{"line":"        // let mask: &MaskFFI = mask.borrow();","counters":[]},{"line":"","counters":[]},{"line":"        with_mask(rt, mask, |mask| {","counters":[{"col_start":35,"col_end":36,"count":0}]},{"line":"            mask.close();","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"        });","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        OCaml::unit()","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_mask_get(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        mask: OCamlRef<DynBox<MaskFFI>>,","counters":[]},{"line":"        addr: OCamlRef<String>,","counters":[]},{"line":"    ) -> OCaml<Option<OCamlBytes>> {","counters":[]},{"line":"        elog!(\"backtrace=\\n{}\", short_backtrace());","counters":[]},{"line":"","counters":[]},{"line":"        let addr = get_addr(rt, addr);","counters":[]},{"line":"","counters":[]},{"line":"        let mut acc = None;","counters":[]},{"line":"","counters":[]},{"line":"        let account = with_mask(rt, mask, |mask| {","counters":[{"col_start":49,"col_end":50,"count":0}]},{"line":"            mask.get(addr.clone())","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"        }).map(|account| {","counters":[{"col_start":0,"col_end":9,"count":0},{"col_start":25,"col_end":26,"count":0}]},{"line":"            acc = Some(account.clone());","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"            account.serialize()","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"        });","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        elog!(\"rust_mask_get is_some={:?} addr={:?} account={:?}\", account.is_some(), addr, acc);","counters":[]},{"line":"","counters":[]},{"line":"        account.to_ocaml(rt)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_mask_get_batch(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        mask: OCamlRef<DynBox<MaskFFI>>,","counters":[]},{"line":"        addrs: OCamlRef<OCamlList<OCamlBytes>>,","counters":[]},{"line":"    ) -> OCaml<OCamlList<(String, Option<OCamlBytes>)>> {","counters":[]},{"line":"        let mut addrs_ref = rt.get(addrs);","counters":[]},{"line":"","counters":[]},{"line":"        let mut addrs = Vec::with_capacity(2048);","counters":[]},{"line":"        while let Some((head, tail)) = addrs_ref.uncons() {","counters":[]},{"line":"            let addr = Address::try_from(head.as_str()).unwrap();","counters":[]},{"line":"            addrs.push(addr);","counters":[]},{"line":"            addrs_ref = tail;","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        let accounts: Vec<(String, Option<Vec<u8>>)> = with_mask(rt, mask, |mask| {","counters":[{"col_start":82,"col_end":83,"count":0}]},{"line":"            mask.get_batch(&addrs)","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"        }).into_iter()","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"          .map(|(addr, opt_account)| {","counters":[{"col_start":37,"col_end":38,"count":0}]},{"line":"              let addr = addr.to_string();","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"              let opt_account = opt_account.map(|acc| acc.serialize());","counters":[{"col_start":0,"col_end":48,"count":0},{"col_start":54,"col_end":69,"count":0},{"col_start":69,"col_end":71,"count":0}]},{"line":"              (addr, opt_account)","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"          })","counters":[{"col_start":0,"col_end":11,"count":0}]},{"line":"          .collect();","counters":[]},{"line":"","counters":[]},{"line":"        accounts.to_ocaml(rt)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_mask_get_list(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        mask: OCamlRef<DynBox<MaskFFI>>,","counters":[]},{"line":"    ) -> OCaml<OCamlList<OCamlBytes>> {","counters":[]},{"line":"","counters":[]},{"line":"        let accounts: Vec<Vec<u8>> = with_mask(rt, mask, |mask| {","counters":[{"col_start":64,"col_end":65,"count":0}]},{"line":"            mask.to_list()","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"        }).into_iter()","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"          .map(|account| {","counters":[{"col_start":25,"col_end":26,"count":0}]},{"line":"              serialize(&account)","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"          })","counters":[{"col_start":0,"col_end":11,"count":0}]},{"line":"          .collect();","counters":[]},{"line":"","counters":[]},{"line":"        accounts.to_ocaml(rt)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_mask_accounts(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        mask: OCamlRef<DynBox<MaskFFI>>,","counters":[]},{"line":"    ) -> OCaml<OCamlList<OCamlBytes>> {","counters":[]},{"line":"","counters":[]},{"line":"        let accounts: Vec<Vec<u8>> = with_mask(rt, mask, |mask| {","counters":[{"col_start":64,"col_end":65,"count":0}]},{"line":"            mask.accounts()","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"        }).into_iter()","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"          .map(|account_id| {","counters":[{"col_start":28,"col_end":29,"count":0}]},{"line":"              serialize(&account_id)","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"          })","counters":[{"col_start":0,"col_end":11,"count":0}]},{"line":"          .collect();","counters":[]},{"line":"","counters":[]},{"line":"        accounts.to_ocaml(rt)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_mask_get_inner_hash_at_addr(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        mask: OCamlRef<DynBox<MaskFFI>>,","counters":[]},{"line":"        addr: OCamlRef<String>,","counters":[]},{"line":"    ) -> OCaml<OCamlBytes> {","counters":[]},{"line":"        let addr = get_addr(rt, addr);","counters":[]},{"line":"","counters":[]},{"line":"        let hash = with_mask(rt, mask, |mask| {","counters":[{"col_start":46,"col_end":47,"count":0}]},{"line":"            mask.get_inner_hash_at_addr(addr)","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"        }).map(|hash| {","counters":[{"col_start":0,"col_end":9,"count":0},{"col_start":22,"col_end":23,"count":0}]},{"line":"              hash_to_ocaml(hash)","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"          })","counters":[{"col_start":0,"col_end":11,"count":0}]},{"line":"          .unwrap();","counters":[]},{"line":"","counters":[]},{"line":"        hash.to_ocaml(rt)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_mask_set_inner_hash_at_addr(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        mask: OCamlRef<DynBox<MaskFFI>>,","counters":[]},{"line":"        addr: OCamlRef<String>,","counters":[]},{"line":"        hash: OCamlRef<String>,","counters":[]},{"line":"    ) {","counters":[]},{"line":"        let addr = get_addr(rt, addr);","counters":[]},{"line":"","counters":[]},{"line":"        let hash: String = hash.to_rust(rt);","counters":[]},{"line":"        let hash = Fp::from_str(&hash).unwrap();","counters":[]},{"line":"","counters":[]},{"line":"        with_mask(rt, mask, |mask| {","counters":[{"col_start":35,"col_end":36,"count":0}]},{"line":"            mask.set_inner_hash_at_addr(addr, hash).unwrap()","counters":[{"col_start":0,"col_end":60,"count":0}]},{"line":"        });","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        OCaml::unit()","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_mask_get_at_index(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        mask: OCamlRef<DynBox<MaskFFI>>,","counters":[]},{"line":"        index: OCamlRef<OCamlInt>","counters":[]},{"line":"    ) -> OCaml<OCamlBytes> {","counters":[]},{"line":"        let index = get_index(rt, index);","counters":[]},{"line":"","counters":[]},{"line":"        let account = with_mask(rt, mask, |mask| {","counters":[{"col_start":49,"col_end":50,"count":0}]},{"line":"            mask.get_at_index(index).unwrap()","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"        });","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"        let account = serialize(&account);","counters":[]},{"line":"","counters":[]},{"line":"        account.to_ocaml(rt)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_mask_location_of_account(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        mask: OCamlRef<DynBox<MaskFFI>>,","counters":[]},{"line":"        account_id: OCamlRef<OCamlBytes>","counters":[]},{"line":"    ) -> OCaml<Option<String>> {","counters":[]},{"line":"        elog!(\"backtrace=\\n{}\", short_backtrace());","counters":[]},{"line":"","counters":[]},{"line":"        let account_id = get(rt, account_id);","counters":[]},{"line":"","counters":[]},{"line":"        let mut a = None;","counters":[]},{"line":"        let mut acc = None;","counters":[]},{"line":"","counters":[]},{"line":"        let addr = with_mask(rt, mask, |mask| {","counters":[{"col_start":46,"col_end":47,"count":0}]},{"line":"            mask.location_of_account(&account_id)","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"        }).map(|addr| {","counters":[{"col_start":0,"col_end":9,"count":0},{"col_start":22,"col_end":23,"count":0}]},{"line":"            a = Some(addr.clone());","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"            acc = Some(with_mask(rt, mask, |mask| mask.get(addr.clone()).unwrap()));","counters":[{"col_start":0,"col_end":43,"count":0},{"col_start":50,"col_end":81,"count":0},{"col_start":81,"col_end":84,"count":0}]},{"line":"","counters":[]},{"line":"            addr.to_string()","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"        });","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        // eprintln!(\"rust_mask_location_of_account is_some={:?} account_id={:?} addr={:?}\", addr.is_some(), account_id, a);","counters":[]},{"line":"","counters":[]},{"line":"        // eprintln!(\"rust_mask_location_of_account is_some={:?} addr={:?} account={:?}\", addr.is_some(), a, acc);","counters":[]},{"line":"","counters":[]},{"line":"        addr.to_ocaml(rt)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_mask_location_of_account_batch(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        mask: OCamlRef<DynBox<MaskFFI>>,","counters":[]},{"line":"        account_ids: OCamlRef<OCamlList<OCamlBytes>>","counters":[]},{"line":"    ) -> OCaml<OCamlList<(OCamlBytes, Option<String>)>> {","counters":[]},{"line":"        elog!(\"backtrace=\\n{}\", short_backtrace());","counters":[]},{"line":"","counters":[]},{"line":"        let account_ids = get_list_of::<AccountId>(rt, account_ids);","counters":[]},{"line":"","counters":[]},{"line":"        // eprintln!(\"mask_location_of_account_batch={:?}\", account_ids);","counters":[]},{"line":"","counters":[]},{"line":"        let addrs = with_mask(rt, mask, |mask| {","counters":[{"col_start":47,"col_end":48,"count":0}]},{"line":"            mask.location_of_account_batch(&account_ids)","counters":[{"col_start":0,"col_end":56,"count":0}]},{"line":"        }).into_iter()","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"          .map(|(account_id, opt_addr)| {","counters":[{"col_start":40,"col_end":41,"count":0}]},{"line":"              let account_id = serialize(&account_id);","counters":[{"col_start":0,"col_end":54,"count":0}]},{"line":"              let addr = opt_addr.map(|addr| addr.to_string());","counters":[{"col_start":0,"col_end":38,"count":0},{"col_start":45,"col_end":61,"count":0},{"col_start":61,"col_end":63,"count":0}]},{"line":"              (account_id, addr)","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"        })","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"          .collect::<Vec<_>>();","counters":[]},{"line":"","counters":[]},{"line":"        addrs.to_ocaml(rt)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_mask_last_filled(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        mask: OCamlRef<DynBox<MaskFFI>>,","counters":[]},{"line":"    ) -> OCaml<Option<String>> {","counters":[]},{"line":"        let addr = with_mask(rt, mask, |mask| {","counters":[{"col_start":46,"col_end":47,"count":0}]},{"line":"            mask.last_filled()","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"        }).map(|addr| {","counters":[{"col_start":0,"col_end":9,"count":0},{"col_start":22,"col_end":23,"count":0}]},{"line":"            addr.to_string()","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"        });","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        addr.to_ocaml(rt)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_mask_token_owners(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        mask: OCamlRef<DynBox<MaskFFI>>,","counters":[]},{"line":"    ) -> OCaml<OCamlList<OCamlBytes>> {","counters":[]},{"line":"        let owners = with_mask(rt, mask, |mask| {","counters":[{"col_start":48,"col_end":49,"count":0}]},{"line":"            mask.token_owners()","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"        }).iter()","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"          .map(|account_id| {","counters":[{"col_start":28,"col_end":29,"count":0}]},{"line":"              serialize(account_id)","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"        })","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"          .collect::<Vec<_>>();","counters":[]},{"line":"","counters":[]},{"line":"        owners.to_ocaml(rt)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_mask_token_owner(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        mask: OCamlRef<DynBox<MaskFFI>>,","counters":[]},{"line":"        token_id: OCamlRef<OCamlBytes>,","counters":[]},{"line":"    ) -> OCaml<Option<OCamlBytes>> {","counters":[]},{"line":"        let token_id = get(rt, token_id);","counters":[]},{"line":"","counters":[]},{"line":"        let owner = with_mask(rt, mask, |mask| {","counters":[{"col_start":47,"col_end":48,"count":0}]},{"line":"            mask.token_owner(token_id)","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"        }).map(|account_id| {","counters":[{"col_start":0,"col_end":9,"count":0},{"col_start":28,"col_end":29,"count":0}]},{"line":"            serialize(&account_id)","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"        });","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        owner.to_ocaml(rt)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_mask_tokens(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        mask: OCamlRef<DynBox<MaskFFI>>,","counters":[]},{"line":"        pubkey: OCamlRef<OCamlBytes>,","counters":[]},{"line":"    ) -> OCaml<OCamlList<OCamlBytes>> {","counters":[]},{"line":"        let pubkey: NonZeroCurvePointUncompressedStableV1 = get(rt, pubkey);","counters":[]},{"line":"","counters":[]},{"line":"        let tokens = with_mask(rt, mask, |mask| {","counters":[{"col_start":48,"col_end":49,"count":0}]},{"line":"            mask.tokens(pubkey.into())","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"        }).iter()","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"          .map(|token_id| {","counters":[{"col_start":26,"col_end":27,"count":0}]},{"line":"            serialize(token_id)","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"        })","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"          .collect::<Vec<_>>();","counters":[]},{"line":"","counters":[]},{"line":"        tokens.to_ocaml(rt)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_mask_set(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        mask: OCamlRef<DynBox<MaskFFI>>,","counters":[]},{"line":"        addr: OCamlRef<String>,","counters":[]},{"line":"        account: OCamlRef<OCamlBytes>,","counters":[]},{"line":"    ) {","counters":[]},{"line":"        elog!(\"backtrace=\\n{}\", short_backtrace());","counters":[]},{"line":"","counters":[]},{"line":"        let addr = get_addr(rt, addr);","counters":[]},{"line":"        let account = get(rt, account);","counters":[]},{"line":"","counters":[]},{"line":"        elog!(\"rust_mask_set addr={:?}\", addr);","counters":[]},{"line":"","counters":[]},{"line":"        with_mask(rt, mask, |mask| {","counters":[{"col_start":35,"col_end":36,"count":0}]},{"line":"            mask.set(addr, account)","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"        });","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        OCaml::unit()","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_mask_index_of_account(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        mask: OCamlRef<DynBox<MaskFFI>>,","counters":[]},{"line":"        account_id: OCamlRef<OCamlBytes>","counters":[]},{"line":"    ) -> OCaml<OCamlInt> {","counters":[]},{"line":"        let account_id = get(rt, account_id);","counters":[]},{"line":"","counters":[]},{"line":"        // eprintln!(\"mask_index_of_account={:?}\", account_id);","counters":[]},{"line":"","counters":[]},{"line":"        let index = with_mask(rt, mask, |mask| {","counters":[{"col_start":47,"col_end":48,"count":0}]},{"line":"            mask.index_of_account(account_id)","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"        }).map(|index| {","counters":[{"col_start":0,"col_end":9,"count":0},{"col_start":23,"col_end":24,"count":0}]},{"line":"            index.0 as i64","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"        })","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"          .unwrap();","counters":[]},{"line":"","counters":[]},{"line":"        index.to_ocaml(rt)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_mask_set_at_index(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        mask: OCamlRef<DynBox<MaskFFI>>,","counters":[]},{"line":"        index: OCamlRef<OCamlInt>,","counters":[]},{"line":"        account: OCamlRef<OCamlBytes>,","counters":[]},{"line":"    ) {","counters":[]},{"line":"        let index = get_index(rt, index);","counters":[]},{"line":"        let account = get(rt, account);","counters":[]},{"line":"","counters":[]},{"line":"        with_mask(rt, mask, |mask| {","counters":[{"col_start":35,"col_end":36,"count":0}]},{"line":"            mask.set_at_index(index, account)","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"        }).unwrap();","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        OCaml::unit()","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_mask_get_or_create_account(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        mask: OCamlRef<DynBox<MaskFFI>>,","counters":[]},{"line":"        account_id: OCamlRef<OCamlBytes>,","counters":[]},{"line":"        account: OCamlRef<OCamlBytes>,","counters":[]},{"line":"    ) -> OCaml<Result<(PolymorphicGetOrAdded, String), DatabaseErrorFFI>> {","counters":[]},{"line":"        let account_id = get(rt, account_id);","counters":[]},{"line":"        let account = get(rt, account);","counters":[]},{"line":"","counters":[]},{"line":"        // eprintln!(\"mask_get_or_create_account={:?}\", account_id);","counters":[]},{"line":"        // eprintln!(\"backtrace=\\n{}\", short_backtrace());","counters":[]},{"line":"","counters":[]},{"line":"        let result = with_mask(rt, mask, |mask| {","counters":[{"col_start":48,"col_end":49,"count":0}]},{"line":"            mask.get_or_create_account(account_id, account)","counters":[{"col_start":0,"col_end":59,"count":0}]},{"line":"        });","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        use crate::base::GetOrCreated::*;","counters":[]},{"line":"        use crate::database::DatabaseError::*;","counters":[]},{"line":"","counters":[]},{"line":"        let result = match result {","counters":[]},{"line":"            Ok(value) => {","counters":[]},{"line":"                let get_or_added = match value {","counters":[]},{"line":"                    Added(_) => PolymorphicGetOrAdded::Added,","counters":[]},{"line":"                    Existed(_) => PolymorphicGetOrAdded::Existed,","counters":[]},{"line":"                };","counters":[]},{"line":"                let addr = value.addr();","counters":[]},{"line":"                Ok((get_or_added, addr.to_string()))","counters":[]},{"line":"            },","counters":[]},{"line":"            Err(e) => match e {","counters":[]},{"line":"                OutOfLeaves => Err(DatabaseErrorFFI::OutOfLeaves),","counters":[]},{"line":"            },","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        result.to_ocaml(rt)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_mask_num_accounts(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        mask: OCamlRef<DynBox<MaskFFI>>","counters":[]},{"line":"    ) -> OCaml<OCamlInt> {","counters":[]},{"line":"        let num_accounts = with_mask(rt, mask, |mask| {","counters":[{"col_start":54,"col_end":55,"count":0}]},{"line":"            mask.num_accounts() as i64","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"        });","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        num_accounts.to_ocaml(rt)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_mask_iter(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        mask: OCamlRef<DynBox<MaskFFI>>,","counters":[]},{"line":"        ocaml_method: OCamlRef<fn(OCamlInt, OCamlBytes)>,","counters":[]},{"line":"    ) {","counters":[]},{"line":"        let (num_accounts, depth) = with_mask(rt, mask, |mask| {","counters":[{"col_start":63,"col_end":64,"count":0}]},{"line":"            (mask.num_accounts(), mask.depth())","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"        });","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        let ocaml_method = ocaml_method.to_boxroot(rt);","counters":[]},{"line":"","counters":[]},{"line":"        for index in 0..num_accounts {","counters":[]},{"line":"            let account_index = AccountIndex(index as u64);","counters":[]},{"line":"            let addr = Address::from_index(account_index, depth as usize);","counters":[]},{"line":"","counters":[]},{"line":"            let account = with_mask(rt, mask, |mask| {","counters":[{"col_start":53,"col_end":54,"count":0}]},{"line":"                mask.get(addr)","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"            });","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"            let account = match account {","counters":[]},{"line":"                Some(account) => account,","counters":[]},{"line":"                None => continue,","counters":[]},{"line":"            };","counters":[]},{"line":"","counters":[]},{"line":"            let account = serialize(&account);","counters":[]},{"line":"","counters":[]},{"line":"            let index = index as i64;","counters":[]},{"line":"            let _: Result<OCaml<()>, OCamlException> = ocaml_method.try_call(rt, &index, &account);","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        OCaml::unit()","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_mask_foldi(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        mask: OCamlRef<DynBox<MaskFFI>>,","counters":[]},{"line":"        ocaml_method: OCamlRef<fn(String, OCamlBytes)>,","counters":[]},{"line":"    ) {","counters":[]},{"line":"        let (num_accounts, depth) = with_mask(rt, mask, |mask| {","counters":[{"col_start":63,"col_end":64,"count":0}]},{"line":"            (mask.num_accounts(), mask.depth())","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"        });","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        let ocaml_method = ocaml_method.to_boxroot(rt);","counters":[]},{"line":"","counters":[]},{"line":"        for index in 0..num_accounts {","counters":[]},{"line":"            let index = AccountIndex(index as u64);","counters":[]},{"line":"            let addr = Address::from_index(index, depth as usize);","counters":[]},{"line":"","counters":[]},{"line":"            let account = with_mask(rt, mask, |mask| {","counters":[{"col_start":53,"col_end":54,"count":0}]},{"line":"                mask.get(addr.clone())","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"            });","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"            let account = match account {","counters":[]},{"line":"                Some(account) => account,","counters":[]},{"line":"                None => continue,","counters":[]},{"line":"            };","counters":[]},{"line":"","counters":[]},{"line":"            let account = serialize(&account);","counters":[]},{"line":"            let addr = addr.to_string();","counters":[]},{"line":"","counters":[]},{"line":"            let _: Result<OCaml<()>, _> = ocaml_method.try_call(rt, &addr, &account);","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        OCaml::unit()","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_mask_foldi_with_ignored_accounts(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        mask: OCamlRef<DynBox<MaskFFI>>,","counters":[]},{"line":"        ignored_accounts: OCamlRef<OCamlList<OCamlBytes>>,","counters":[]},{"line":"        ocaml_method: OCamlRef<fn(String, OCamlBytes)>,","counters":[]},{"line":"    ) {","counters":[]},{"line":"        let (num_accounts, depth) = with_mask(rt, mask, |mask| {","counters":[{"col_start":63,"col_end":64,"count":0}]},{"line":"            (mask.num_accounts(), mask.depth())","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"        });","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        let ignored_accounts = get_set_of::<AccountId>(rt, ignored_accounts);","counters":[]},{"line":"        let ocaml_method = ocaml_method.to_boxroot(rt);","counters":[]},{"line":"","counters":[]},{"line":"        for index in 0..num_accounts {","counters":[]},{"line":"            let index = AccountIndex(index as u64);","counters":[]},{"line":"            let addr = Address::from_index(index, depth as usize);","counters":[]},{"line":"","counters":[]},{"line":"            let account = with_mask(rt, mask, |mask| {","counters":[{"col_start":53,"col_end":54,"count":0}]},{"line":"                mask.get(addr.clone())","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"            });","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"            let account = match account {","counters":[]},{"line":"                Some(account) => account,","counters":[]},{"line":"                None => continue,","counters":[]},{"line":"            };","counters":[]},{"line":"","counters":[]},{"line":"            if ignored_accounts.contains(&account.id()) {","counters":[]},{"line":"                continue;","counters":[]},{"line":"            }","counters":[]},{"line":"","counters":[]},{"line":"            let account = serialize(&account);","counters":[]},{"line":"            let addr = addr.to_string();","counters":[]},{"line":"","counters":[]},{"line":"            let _: Result<OCaml<()>, _> = ocaml_method.try_call(rt, &addr, &account);","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        OCaml::unit()","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_mask_merkle_root(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        mask: OCamlRef<DynBox<MaskFFI>>,","counters":[]},{"line":"    ) -> OCaml<OCamlBytes> {","counters":[]},{"line":"        elog!(\"backtrace=\\n{}\", short_backtrace());","counters":[]},{"line":"","counters":[]},{"line":"        let hash = with_mask(rt, mask, |mask| {","counters":[{"col_start":46,"col_end":47,"count":0}]},{"line":"            mask.merkle_root()","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"        });","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        let hash = hash_to_ocaml(hash);","counters":[]},{"line":"","counters":[]},{"line":"        hash.to_ocaml(rt)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_mask_remove_accounts(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        mask: OCamlRef<DynBox<MaskFFI>>,","counters":[]},{"line":"        account_ids: OCamlRef<OCamlList<OCamlBytes>>,","counters":[]},{"line":"    ) {","counters":[]},{"line":"        let account_ids = get_list_of(rt, account_ids);","counters":[]},{"line":"","counters":[]},{"line":"        // eprintln!(\"remove_accounts={:?}\", account_ids);","counters":[]},{"line":"","counters":[]},{"line":"        with_mask(rt, mask, |mask| {","counters":[{"col_start":35,"col_end":36,"count":0}]},{"line":"            mask.remove_accounts(&account_ids)","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"        });","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        OCaml::unit()","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_mask_set_all_accounts_rooted_at(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        mask: OCamlRef<DynBox<MaskFFI>>,","counters":[]},{"line":"        addr: OCamlRef<String>,","counters":[]},{"line":"        accounts: OCamlRef<OCamlList<OCamlBytes>>,","counters":[]},{"line":"    ) {","counters":[]},{"line":"        let addr = get_addr(rt, addr);","counters":[]},{"line":"        let accounts = get_list_of(rt, accounts);","counters":[]},{"line":"","counters":[]},{"line":"        with_mask(rt, mask, |mask| {","counters":[{"col_start":35,"col_end":36,"count":0}]},{"line":"            mask.set_all_accounts_rooted_at(addr, &accounts).unwrap()","counters":[{"col_start":0,"col_end":69,"count":0}]},{"line":"        });","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        OCaml::unit()","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_mask_set_batch_accounts(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        mask: OCamlRef<DynBox<MaskFFI>>,","counters":[]},{"line":"        accounts: OCamlRef<OCamlList<(String, OCamlBytes)>>,","counters":[]},{"line":"    ) {","counters":[]},{"line":"        let accounts = get_list_addr_account(rt, accounts);","counters":[]},{"line":"","counters":[]},{"line":"        with_mask(rt, mask, |mask| {","counters":[{"col_start":35,"col_end":36,"count":0}]},{"line":"            mask.set_batch_accounts(&accounts)","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"        });","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        OCaml::unit()","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_mask_get_all_accounts_rooted_at(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        mask: OCamlRef<DynBox<MaskFFI>>,","counters":[]},{"line":"        addr: OCamlRef<String>,","counters":[]},{"line":"    ) -> OCaml<OCamlList<(String, OCamlBytes)>> {","counters":[]},{"line":"        let addr = get_addr(rt, addr);","counters":[]},{"line":"","counters":[]},{"line":"        let accounts = with_mask(rt, mask, |mask| {","counters":[{"col_start":50,"col_end":51,"count":0}]},{"line":"            mask.get_all_accounts_rooted_at(addr)","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"        }).unwrap_or_default()","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"          .iter()","counters":[]},{"line":"            .map(|(addr, account)| {","counters":[{"col_start":35,"col_end":36,"count":0}]},{"line":"              let addr = addr.to_string();","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"              let account = serialize(account);","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"              (addr, account)","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"            })","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"            .collect::<Vec<_>>();","counters":[]},{"line":"","counters":[]},{"line":"        accounts.to_ocaml(rt)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_mask_merkle_path(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        mask: OCamlRef<DynBox<MaskFFI>>,","counters":[]},{"line":"        addr: OCamlRef<String>,","counters":[]},{"line":"    ) -> OCaml<OCamlList<PolymorphicPath>> {","counters":[]},{"line":"        let addr = get_addr(rt, addr);","counters":[]},{"line":"","counters":[]},{"line":"        let path = with_mask(rt, mask, |mask| {","counters":[{"col_start":46,"col_end":47,"count":0}]},{"line":"            mask.merkle_path(addr)","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"        }).into_iter()","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"          .map(|path| {","counters":[{"col_start":22,"col_end":23,"count":0}]},{"line":"              match path {","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"                  MerklePath::Left(hash) => PolymorphicPath::Left(hash_to_ocaml(hash)),","counters":[{"col_start":35,"col_end":86,"count":0}]},{"line":"                  MerklePath::Right(hash) => PolymorphicPath::Right(hash_to_ocaml(hash)),","counters":[{"col_start":36,"col_end":88,"count":0}]},{"line":"              }","counters":[]},{"line":"          })","counters":[{"col_start":10,"col_end":11,"count":0}]},{"line":"          .collect::<Vec<_>>();","counters":[]},{"line":"","counters":[]},{"line":"        path.to_ocaml(rt)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_mask_merkle_path_at_addr(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        mask: OCamlRef<DynBox<MaskFFI>>,","counters":[]},{"line":"        addr: OCamlRef<String>,","counters":[]},{"line":"    ) -> OCaml<OCamlList<PolymorphicPath>> {","counters":[]},{"line":"        let addr = get_addr(rt, addr);","counters":[]},{"line":"","counters":[]},{"line":"        let path = with_mask(rt, mask, |mask| {","counters":[{"col_start":46,"col_end":47,"count":0}]},{"line":"            mask.merkle_path(addr)","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"        }).into_iter()","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"          .map(|path| {","counters":[{"col_start":22,"col_end":23,"count":0}]},{"line":"              match path {","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"                  MerklePath::Left(hash) => PolymorphicPath::Left(hash_to_ocaml(hash)),","counters":[{"col_start":35,"col_end":86,"count":0}]},{"line":"                  MerklePath::Right(hash) => PolymorphicPath::Right(hash_to_ocaml(hash)),","counters":[{"col_start":36,"col_end":88,"count":0}]},{"line":"              }","counters":[]},{"line":"          })","counters":[{"col_start":10,"col_end":11,"count":0}]},{"line":"          .collect::<Vec<_>>();","counters":[]},{"line":"","counters":[]},{"line":"        path.to_ocaml(rt)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_mask_merkle_path_at_index(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        mask: OCamlRef<DynBox<MaskFFI>>,","counters":[]},{"line":"        index: OCamlRef<OCamlInt>,","counters":[]},{"line":"    ) -> OCaml<OCamlList<PolymorphicPath>> {","counters":[]},{"line":"        let index = get_index(rt, index);","counters":[]},{"line":"","counters":[]},{"line":"        let path = with_mask(rt, mask, |mask| {","counters":[{"col_start":46,"col_end":47,"count":0}]},{"line":"            let depth = mask.depth();","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"            let addr = Address::from_index(index, depth as usize);","counters":[{"col_start":0,"col_end":66,"count":0}]},{"line":"            mask.merkle_path(addr)","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"        }).into_iter()","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"          .map(|path| {","counters":[{"col_start":22,"col_end":23,"count":0}]},{"line":"              match path {","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"                  MerklePath::Left(hash) => PolymorphicPath::Left(hash_to_ocaml(hash)),","counters":[{"col_start":35,"col_end":86,"count":0}]},{"line":"                  MerklePath::Right(hash) => PolymorphicPath::Right(hash_to_ocaml(hash)),","counters":[{"col_start":36,"col_end":88,"count":0}]},{"line":"                  // MerklePath::Left(hash) => PolymorphicPath::Left(hash.to_string()),","counters":[]},{"line":"                  // MerklePath::Right(hash) => PolymorphicPath::Right(hash.to_string()),","counters":[]},{"line":"              }","counters":[]},{"line":"          })","counters":[{"col_start":10,"col_end":11,"count":0}]},{"line":"          .collect::<Vec<_>>();","counters":[]},{"line":"","counters":[]},{"line":"        path.to_ocaml(rt)","counters":[]},{"line":"    }","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"// database_create : int -> database = \"rust_mask_create\"","counters":[]},{"line":"// database_get_uuid : database -> string = \"rust_mask_get_uuid\"","counters":[]},{"line":"// database_depth : database -> int = \"rust_mask_depth\"","counters":[]},{"line":"// database_create_checkpoint : database -> database = \"rust_mask_create_checkpoint\"","counters":[]},{"line":"// database_make_checkpoint : database -> unit = \"rust_mask_make_checkpoint\"","counters":[]},{"line":"// database_close : database -> unit = \"rust_mask_close\"","counters":[]},{"line":"// database_get : database -> addr -> account option = \"rust_mask_get\"","counters":[]},{"line":"// database_get_batch : database -> addr list -> (addr * (account option)) list = \"rust_mask_get_batch\"","counters":[]},{"line":"// database_get_list : database -> bytes list = \"rust_mask_get_list\"","counters":[]},{"line":"// database_accounts : database -> bytes list = \"rust_mask_accounts\"","counters":[]},{"line":"// database_get_inner_hash_at_addr : database -> addr -> bytes = \"rust_mask_get_inner_hash_at_addr\"","counters":[]},{"line":"// database_set_inner_hash_at_addr : database -> addr -> bytes -> unit = \"rust_mask_set_inner_hash_at_addr\"","counters":[]},{"line":"// database_get_at_index : database -> int -> account = \"rust_mask_get_at_index\"","counters":[]},{"line":"// database_iter : database -> (int -> bytes -> unit) -> unit = \"rust_mask_iter\"","counters":[]},{"line":"// database_location_of_account : database -> account_id -> addr option = \"rust_mask_location_of_account\"","counters":[]},{"line":"// database_location_of_account_batch : database -> account_id list -> (account_id * (addr option)) list = \"rust_mask_location_of_account_batch\"","counters":[]},{"line":"","counters":[]},{"line":"// database_last_filled : database -> addr option = \"rust_mask_last_filled\"","counters":[]},{"line":"// database_token_owners : database -> bytes list = \"rust_mask_token_owners\"","counters":[]},{"line":"// database_token_owner : database -> token_id -> account_id option = \"rust_mask_token_owner\"","counters":[]},{"line":"// database_tokens : database -> pubkey -> token_id list = \"rust_mask_tokens\"","counters":[]},{"line":"// database_set : database -> addr -> account -> unit = \"rust_mask_set\"","counters":[]},{"line":"// database_index_of_account : database -> account_id -> int = \"rust_mask_index_of_account\"","counters":[]},{"line":"// database_set_at_index : database -> int -> account -> unit = \"rust_mask_set_at_index\"","counters":[]},{"line":"// database_get_or_create_account : database -> account_id -> account -> (([ `Added | `Existed ] * addr), rust_maskerror) result = \"rust_mask_get_or_create_account\"","counters":[]},{"line":"// database_num_accounts : database -> int = \"rust_mask_num_accounts\"","counters":[]},{"line":"// database_fold_with_account_ids : database -> bytes list -> bytes -> (bytes -> unit) -> bytes = \"rust_mask_fold_with_ignored_accounts\"","counters":[]},{"line":"// database_fold : database -> bytes -> (bytes -> unit) -> bytes = \"rust_mask_fold\"","counters":[]},{"line":"// database_fold_until : database -> bytes -> (bytes -> bool) -> bytes = \"rust_mask_fold_until\"","counters":[]},{"line":"// database_merkle_root : database -> bytes = \"rust_mask_merkle_root\"","counters":[]},{"line":"// database_remove_accounts : database -> account_id list -> unit = \"rust_mask_remove_accounts\"","counters":[]},{"line":"// database_merkle_path : database -> addr -> bytes list = \"rust_mask_merkle_path\"","counters":[]},{"line":"// database_merkle_path_at_addr : database -> bytes -> bytes list = \"rust_mask_merkle_path_at_addr\"","counters":[]},{"line":"// database_merkle_path_at_index : database -> int -> bytes list = \"rust_mask_merkle_path_at_index\"","counters":[]},{"line":"// database_set_all_accounts_rooted_at : database -> addr -> bytes list -> unit = \"rust_mask_set_all_accounts_rooted_at\"","counters":[]},{"line":"// database_set_batch_accounts : database -> (addr * account) list -> unit = \"rust_mask_set_batch_accounts\"","counters":[]},{"line":"// database_get_all_accounts_rooted_at : database -> addr -> (addr * account) list = \"rust_mask_get_all_accounts_rooted_at\"","counters":[]},{"line":"","counters":[]},{"line":"// (* TODO: Make those method *)","counters":[]},{"line":"// database_foldi : database -> (addr -> bytes -> unit) -> unit = \"rust_mask_foldi\"","counters":[]},{"line":"// database_foldi_with_ignored_accounts : database -> account list -> (addr -> bytes -> unit) -> unit = \"rust_mask_foldi_with_ignored_accounts\"","counters":[]},{"line":"","counters":[]},{"line":"#[allow(clippy::let_and_return)]","counters":[]},{"line":"fn impl_rust_random_account() -> Vec<u8> {","counters":[]},{"line":"    // elog!(\"rust_random_account begin\");","counters":[]},{"line":"","counters":[]},{"line":"    let account = Account::rand();","counters":[]},{"line":"    let ser = serialize(&account);","counters":[]},{"line":"","counters":[]},{"line":"    // let ser: Vec<u8> = vec![","counters":[]},{"line":"    //     178, 29, 73, 50, 85, 80, 131, 166, 53, 11, 48, 224, 103, 89, 161, 207, 149, 31, 170, 21,","counters":[]},{"line":"    //     165, 181, 94, 18, 149, 177, 54, 71, 185, 77, 109, 49, 1, 144, 247, 164, 171, 110, 24, 3,","counters":[]},{"line":"    //     12, 25, 163, 63, 125, 83, 66, 174, 2, 160, 62, 45, 137, 185, 47, 16, 129, 145, 190, 203,","counters":[]},{"line":"    //     124, 35, 119, 251, 26, 1, 1, 6, 49, 50, 56, 54, 56, 56, 252, 29, 154, 218, 214, 79, 98,","counters":[]},{"line":"    //     177, 181, 253, 181, 152, 127, 0, 145, 177, 91, 155, 59, 239, 161, 174, 217, 42, 201, 30,","counters":[]},{"line":"    //     46, 11, 187, 88, 49, 5, 111, 254, 222, 87, 42, 45, 90, 1, 236, 173, 205, 215, 241, 20, 0,","counters":[]},{"line":"    //     77, 12, 197, 234, 69, 202, 22, 55, 50, 183, 255, 238, 8, 29, 79, 199, 92, 12, 146, 223,","counters":[]},{"line":"    //     105, 45, 135, 77, 89, 73, 141, 11, 137, 28, 54, 21, 0, 1, 4, 4, 1, 0, 4, 3, 4, 3, 2, 3, 0,","counters":[]},{"line":"    //     6, 49, 49, 56, 54, 54, 51,","counters":[]},{"line":"    // ];","counters":[]},{"line":"","counters":[]},{"line":"    // let account: Account = serde_binprot::from_slice(&ser).unwrap();","counters":[]},{"line":"","counters":[]},{"line":"    // // account2.permissions = Permissions::user_default();","counters":[]},{"line":"","counters":[]},{"line":"    // // let account_hash2 = account2.hash();","counters":[]},{"line":"","counters":[]},{"line":"    // // elog!(\"HASH2={:?}\", account_hash2.to_string());","counters":[]},{"line":"","counters":[]},{"line":"    // // let mut account2 = Account::empty();","counters":[]},{"line":"","counters":[]},{"line":"    // // account2.public_key = account.public_key;","counters":[]},{"line":"    // // account2.token_id = account.token_id;","counters":[]},{"line":"    // // // account2.token_permissions = account.token_permissions;","counters":[]},{"line":"    // // account2.token_permissions = TokenPermissions::TokenOwned { disable_new_accounts: false };","counters":[]},{"line":"","counters":[]},{"line":"    // // elog!(\"ACCOUNT={:#?}\", account2);","counters":[]},{"line":"","counters":[]},{"line":"    // let ser = serialize(&account).unwrap();","counters":[]},{"line":"","counters":[]},{"line":"    // elog!(\"rust_random_account end\");","counters":[]},{"line":"","counters":[]},{"line":"    ser","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"// pub struct Account {","counters":[]},{"line":"//     pub public_key: CompressedPubKey,         // Public_key.Compressed.t","counters":[]},{"line":"//     pub token_id: TokenId,                    // Token_id.t","counters":[]},{"line":"//     pub token_permissions: TokenPermissions,  // Token_permissions.t","counters":[]},{"line":"//     pub token_symbol: TokenSymbol,            // Token_symbol.t","counters":[]},{"line":"//     pub balance: Balance,                     // Balance.t","counters":[]},{"line":"//     pub nonce: Nonce,                         // Nonce.t","counters":[]},{"line":"//     pub receipt_chain_hash: ReceiptChainHash, // Receipt.Chain_hash.t","counters":[]},{"line":"//     pub delegate: Option<CompressedPubKey>,   // Public_key.Compressed.t option","counters":[]},{"line":"//     pub voting_for: VotingFor,                // State_hash.t","counters":[]},{"line":"//     pub timing: Timing,                       // Timing.t","counters":[]},{"line":"//     pub permissions: Permissions<AuthRequired>, // Permissions.t","counters":[]},{"line":"//     pub zkapp: Option<ZkAppAccount>,          // Zkapp_account.t","counters":[]},{"line":"//     pub zkapp_uri: String,                    // string","counters":[]},{"line":"// }","counters":[]}]}