{"filename":"src/lib/memory_stats/memory_stats.ml","lines":[{"line":"(* memory_stats.ml -- log OCaml memory data *)","counters":[]},{"line":"","counters":[]},{"line":"open Core_kernel","counters":[]},{"line":"open Async_kernel","counters":[]},{"line":"open Gc.Stat","counters":[]},{"line":"","counters":[]},{"line":"let ocaml_memory_stats () =","counters":[]},{"line":"  let bytes_per_word = Sys.word_size / 8 in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let stat = Gc.stat () in","counters":[]},{"line":"  [ (\"heap_size_bytes\", `Int (stat.heap_words * bytes_per_word))","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  ; (\"heap_chunks\", `Int stat.heap_chunks)","counters":[]},{"line":"  ; (\"max_heap_size_bytes\", `Int (stat.top_heap_words * bytes_per_word))","counters":[]},{"line":"  ; (\"live_size_bytes\", `Int (stat.live_words * bytes_per_word))","counters":[]},{"line":"  ; (\"live_blocks\", `Int stat.live_blocks)","counters":[]},{"line":"  ; (\"fragments\", `Int stat.fragments)","counters":[]},{"line":"  ]","counters":[]},{"line":"","counters":[]},{"line":"let log_memory_stats logger ~process =","counters":[]},{"line":"  don't_wait_for","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    ((* Curve points are allocated in C++ and deallocated with finalizers.","counters":[]},{"line":"             The points on the C++ heap are much bigger than the OCaml heap","counters":[]},{"line":"             objects that point to them, which makes the GC underestimate how","counters":[]},{"line":"             much memory has been allocated since the last collection and not","counters":[]},{"line":"             run major GCs often enough, which means the finalizers don't run","counters":[]},{"line":"             and we use way too much memory. As a band-aid solution, we run a","counters":[]},{"line":"             major GC cycle every ten minutes.","counters":[]},{"line":"     *)","counters":[]},{"line":"     let gc_method =","counters":[]},{"line":"       Option.value ~default:\"full\" @@ Stdlib.Sys.getenv_opt \"MINA_GC_HACK_MODE\"","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"     in","counters":[]},{"line":"     (* Doing Gc.major is known to work, but takes quite a bit of time.","counters":[]},{"line":"             Running a single slice might be sufficient, but I haven't tested it","counters":[]},{"line":"             and the documentation isn't super clear. *)","counters":[]},{"line":"     let gc_fun =","counters":[{"col_start":5,"col_end":5,"count":0}]},{"line":"       match gc_method with","counters":[]},{"line":"       | \"full\" ->","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"           Gc.major","counters":[]},{"line":"       | \"slice\" ->","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"           fun () -> ignore (Gc.major_slice 0)","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"       | other ->","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"           failwithf","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"             \"MINA_GC_HACK_MODE was %s, it should be full or slice. Default is \\","counters":[]},{"line":"              full.\"","counters":[]},{"line":"             other","counters":[]},{"line":"     in","counters":[]},{"line":"     let interval =","counters":[]},{"line":"       Time_ns.Span.of_sec","counters":[]},{"line":"       @@ Option.(","counters":[]},{"line":"            value ~default:600.","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"              ( map ~f:Float.of_string","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"              @@ Stdlib.Sys.getenv_opt \"MINA_GC_HACK_INTERVAL\" ))","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"     in","counters":[]},{"line":"     let log_stats suffix =","counters":[{"col_start":5,"col_end":5,"count":0}]},{"line":"       let proc = (\"process\", `String process) in","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"       [%log debug] \"OCaml memory statistics, %s\" suffix","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"         ~metadata:(proc :: ocaml_memory_stats ())","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"     in","counters":[]},{"line":"     let rec loop () =","counters":[]},{"line":"       log_stats \"before major gc\" ;","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"       gc_fun () ;","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"       log_stats \"after major gc\" ;","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"       let%bind () = after interval in","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"       loop ()","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"     in","counters":[]},{"line":"     loop () )","counters":[{"col_start":8,"col_end":8,"count":0}]}]}