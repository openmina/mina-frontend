{"filename":"src/coverage/stats.rs","lines":[{"line":"use std::fmt;","counters":[]},{"line":"","counters":[]},{"line":"use btreemultimap::BTreeMultiMap;","counters":[]},{"line":"","counters":[]},{"line":"use super::cov::FileCounters;","counters":[]},{"line":"","counters":[]},{"line":"#[derive(Debug)]","counters":[{"col_start":9,"col_end":14,"count":0}]},{"line":"pub struct Stats(BTreeMultiMap<usize, (String, usize, usize)>);","counters":[]},{"line":"","counters":[]},{"line":"impl Stats {","counters":[]},{"line":"    // If we are just interested in coverage statistics for some subset of source files","counters":[]},{"line":"    pub fn filter_filenames(&self, filenames: &Vec<&str>) -> Self {","counters":[{"col_start":4,"col_end":67,"count":0}]},{"line":"        let mut filtered_map = BTreeMultiMap::new();","counters":[{"col_start":0,"col_end":51,"count":0}]},{"line":"","counters":[]},{"line":"        for (k, v) in self","counters":[{"col_start":13,"col_end":17,"count":4},{"col_start":22,"col_end":26,"count":0}]},{"line":"            .0","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"            .iter()","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"            .filter(|(_, (filename, _, _))| filenames.iter().any(|name| filename.ends_with(name)))","counters":[{"col_start":0,"col_end":20,"count":0},{"col_start":44,"col_end":65,"count":0},{"col_start":72,"col_end":96,"count":0},{"col_start":96,"col_end":97,"count":0},{"col_start":97,"col_end":98,"count":0}]},{"line":"        {","counters":[{"col_start":8,"col_end":9,"count":4}]},{"line":"            filtered_map.insert(*k, v.clone());","counters":[{"col_start":0,"col_end":47,"count":4}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":4}]},{"line":"","counters":[]},{"line":"        Self(filtered_map)","counters":[{"col_start":8,"col_end":26,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    // If we are interested just in top `n` files with more coverage","counters":[]},{"line":"    pub fn filter_top(&self, n: usize) -> Self {","counters":[{"col_start":4,"col_end":48,"count":0}]},{"line":"        let mut filtered_map = BTreeMultiMap::new();","counters":[{"col_start":0,"col_end":51,"count":0}]},{"line":"","counters":[]},{"line":"        for (k, v) in self.0.clone().iter().rev().take(n) {","counters":[{"col_start":13,"col_end":17,"count":0},{"col_start":22,"col_end":57,"count":0},{"col_start":58,"col_end":59,"count":0}]},{"line":"            filtered_map.insert(*k, v.clone());","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        Self(filtered_map)","counters":[{"col_start":8,"col_end":26,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    // returns: (coverage percent, total counters, covered counters)","counters":[]},{"line":"    pub fn get_total(&self) -> (usize, usize, usize) {","counters":[{"col_start":4,"col_end":54,"count":0}]},{"line":"        let (total, covered) = self.0.iter().fold(","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"            (0, 0),","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"            |(acc_total, acc_covered), (_, (_, file_total, file_covered))| {","counters":[{"col_start":0,"col_end":12,"count":0},{"col_start":75,"col_end":76,"count":0}]},{"line":"                (acc_total + file_total, acc_covered + file_covered)","counters":[{"col_start":0,"col_end":68,"count":0}]},{"line":"            },","counters":[{"col_start":0,"col_end":13,"count":0},{"col_start":13,"col_end":14,"count":0}]},{"line":"        );","counters":[{"col_start":0,"col_end":10,"count":0}]},{"line":"        let cov_percent = (covered * 100) / total;","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"        (cov_percent, total, covered)","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn has_coverage_increased(&self, rhs: &Self) -> bool {","counters":[{"col_start":4,"col_end":62,"count":0}]},{"line":"        self.get_total().2 > rhs.get_total().2","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn from_file_counters(filecounters: &Vec<FileCounters>) -> Self {","counters":[{"col_start":4,"col_end":73,"count":0}]},{"line":"        let mut result = BTreeMultiMap::new();","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"","counters":[]},{"line":"        for FileCounters {","counters":[]},{"line":"            filename, counters, ..","counters":[{"col_start":12,"col_end":30,"count":0}]},{"line":"        } in filecounters.iter()","counters":[{"col_start":26,"col_end":32,"count":0}]},{"line":"        {","counters":[]},{"line":"            let (total, covered) = counters.iter().fold((0, 0), |(total, covered), counters| {","counters":[{"col_start":17,"col_end":64,"count":0},{"col_start":93,"col_end":94,"count":0}]},{"line":"                (","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"                    total + counters.len(),","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"                    covered","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"                        + counters","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"                            .iter()","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"                            .fold(0, |acc, counter| if *counter != 0 { acc + 1 } else { acc }),","counters":[{"col_start":0,"col_end":37,"count":0},{"col_start":52,"col_end":68,"count":0},{"col_start":71,"col_end":78,"count":0},{"col_start":88,"col_end":91,"count":0},{"col_start":92,"col_end":93,"count":0},{"col_start":93,"col_end":95,"count":0}]},{"line":"                )","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"            });","counters":[{"col_start":0,"col_end":13,"count":0},{"col_start":13,"col_end":15,"count":0}]},{"line":"","counters":[]},{"line":"            if total != 0 {","counters":[{"col_start":0,"col_end":25,"count":0},{"col_start":26,"col_end":27,"count":0}]},{"line":"                let cov_percent = (covered * 100) / total;","counters":[{"col_start":0,"col_end":58,"count":0}]},{"line":"                result.insert(cov_percent, (filename.clone(), total, covered));","counters":[{"col_start":0,"col_end":79,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0},{"col_start":13,"col_end":14,"count":0}]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        Self(result)","counters":[{"col_start":8,"col_end":20,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn from_bisect_dump(bisect_dump: &Vec<(String, Vec<i64>, Vec<i64>)>) -> Self {","counters":[{"col_start":4,"col_end":86,"count":0}]},{"line":"        let mut result = BTreeMultiMap::new();","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"","counters":[]},{"line":"        for (filename, _points, counts) in bisect_dump.iter() {","counters":[{"col_start":13,"col_end":38,"count":0},{"col_start":55,"col_end":61,"count":0}]},{"line":"            let covered = counts","counters":[{"col_start":16,"col_end":32,"count":0}]},{"line":"                .iter()","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"                .fold(0, |acc, counter| if *counter != 0 { acc + 1 } else { acc });","counters":[{"col_start":0,"col_end":25,"count":0},{"col_start":40,"col_end":56,"count":0},{"col_start":59,"col_end":66,"count":0},{"col_start":76,"col_end":79,"count":0},{"col_start":80,"col_end":81,"count":0},{"col_start":81,"col_end":83,"count":0}]},{"line":"            let total = counts.len();","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"            if total != 0 {","counters":[{"col_start":0,"col_end":25,"count":0},{"col_start":26,"col_end":27,"count":0}]},{"line":"                let cov_percent = (covered * 100) / total;","counters":[{"col_start":0,"col_end":58,"count":0}]},{"line":"                result.insert(cov_percent, (filename.clone(), total, covered));","counters":[{"col_start":0,"col_end":79,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0},{"col_start":13,"col_end":14,"count":0}]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        Self(result)","counters":[{"col_start":8,"col_end":20,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl fmt::Display for Stats {","counters":[]},{"line":"    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {","counters":[{"col_start":4,"col_end":57,"count":0}]},{"line":"        for (percent, (filename, total, covered)) in self.0.iter() {","counters":[{"col_start":13,"col_end":47,"count":18},{"col_start":60,"col_end":66,"count":0}]},{"line":"            write!(","counters":[{"col_start":12,"col_end":19,"count":18}]},{"line":"                f,","counters":[{"col_start":0,"col_end":18,"count":18}]},{"line":"                \"{:>3}% {:>4}/{:>4}: {}\\n\",","counters":[{"col_start":0,"col_end":43,"count":18}]},{"line":"                percent, covered, total, filename","counters":[{"col_start":0,"col_end":49,"count":18}]},{"line":"            )?;","counters":[{"col_start":0,"col_end":13,"count":18},{"col_start":13,"col_end":14,"count":0}]},{"line":"        }","counters":[]},{"line":"        let (percent, total, covered) = self.get_total();","counters":[{"col_start":13,"col_end":57,"count":0}]},{"line":"        write!(f, \"{:>3}% {:>4}/{:>4}: Total\\n\", percent, covered, total)","counters":[{"col_start":0,"col_end":73,"count":0}]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"}","counters":[]}]}