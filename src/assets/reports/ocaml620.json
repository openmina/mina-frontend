{"filename":"src/lib/mina_base/signature.ml","lines":[{"line":"[%%import \"/src/config.mlh\"]","counters":[]},{"line":"","counters":[{"col_start":0,"col_end":0,"count":1}]},{"line":"open Core_kernel","counters":[]},{"line":"open Snark_params.Tick","counters":[]},{"line":"","counters":[]},{"line":"module Poly = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      [@@@with_all_version_tags]","counters":[]},{"line":"","counters":[]},{"line":"      type ('field, 'scalar) t = 'field * 'scalar","counters":[{"col_start":6,"col_end":6,"count":5},{"col_start":12,"col_end":12,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":29,"col_end":29,"count":8},{"col_start":33,"col_end":33,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"      [@@deriving sexp, compare, equal, hash]","counters":[{"col_start":44,"col_end":44,"count":15}]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"[%%versioned","counters":[]},{"line":"module Stable = struct","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"  module V1 = struct","counters":[]},{"line":"    [@@@with_all_version_tags]","counters":[]},{"line":"","counters":[]},{"line":"    type t =","counters":[{"col_start":4,"col_end":4,"count":4},{"col_start":9,"col_end":9,"count":2}]},{"line":"      ( (Field.t[@version_asserted])","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"      , (Inner_curve.Scalar.t[@version_asserted]) )","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"      Poly.Stable.V1.t","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    [@@deriving sexp, compare, equal, hash]","counters":[{"col_start":42,"col_end":42,"count":15}]},{"line":"","counters":[]},{"line":"    module Codable_arg = struct","counters":[]},{"line":"      (* version tag for compatibility with pre-Berkeley hard fork","counters":[]},{"line":"         Base58Check-serialized signatures","counters":[]},{"line":"      *)","counters":[]},{"line":"      type t =","counters":[{"col_start":6,"col_end":6,"count":1},{"col_start":11,"col_end":11,"count":1}]},{"line":"        (Field.t, Inner_curve.Scalar.t) Poly.Stable.V1.With_all_version_tags.t","counters":[]},{"line":"      [@@deriving bin_io_unversioned]","counters":[{"col_start":36,"col_end":36,"count":4}]},{"line":"","counters":[]},{"line":"      let description = \"Signature\"","counters":[]},{"line":"","counters":[]},{"line":"      let version_byte = Base58_check.Version_bytes.signature","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    (* Base58Check encodes t *)","counters":[]},{"line":"    let _f : unit -> (t, Codable_arg.t) Type_equal.t = fun () -> Type_equal.T","counters":[{"col_start":65,"col_end":65,"count":0}]},{"line":"","counters":[]},{"line":"    include Codable.Make_base58_check (Codable_arg)","counters":[]},{"line":"","counters":[]},{"line":"    let to_latest = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"    let gen = Quickcheck.Generator.tuple2 Field.gen Inner_curve.Scalar.gen","counters":[{"col_start":40,"col_end":40,"count":1}]},{"line":"  end","counters":[]},{"line":"end]","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let dummy = (Field.one, Inner_curve.Scalar.one)","counters":[]},{"line":"","counters":[]},{"line":"module Raw = struct","counters":[]},{"line":"  open Rosetta_coding.Coding","counters":[]},{"line":"","counters":[]},{"line":"  let encode (field, scalar) = of_field field ^ of_scalar scalar","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"","counters":[]},{"line":"  let decode raw =","counters":[]},{"line":"    let len = String.length raw in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let field_len = len / 2 in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let field_enc = String.sub raw ~pos:0 ~len:field_len in","counters":[]},{"line":"    let scalar_enc = String.sub raw ~pos:field_len ~len:field_len in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    try Some (to_field field_enc, to_scalar scalar_enc) with _ -> None","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":42,"col_end":42,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"","counters":[]},{"line":"  let%test_unit \"partial isomorphism\" =","counters":[]},{"line":"    Quickcheck.test ~trials:300 Stable.Latest.gen ~f:(fun signature ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        [%test_eq: t option] (Some signature) (encode signature |> decode) )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":52,"col_end":52,"count":0},{"col_start":72,"col_end":72,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"[%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"type var = Field.Var.t * Inner_curve.Scalar.var","counters":[]},{"line":"","counters":[]},{"line":"[%%endif]","counters":[]},{"line":"","counters":[]},{"line":"[%%define_locally","counters":[]},{"line":"Stable.Latest.","counters":[]},{"line":"  (of_base58_check_exn, of_base58_check, of_yojson, to_yojson, to_base58_check)]","counters":[]},{"line":"","counters":[]},{"line":"let%test \"Base58Check is stable\" =","counters":[]},{"line":"  let expected =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    \"7mWxjLYgbJUkZNcGouvhVj5tJ8yu9hoexb9ntvPK8t5LHqzmrL6QJjjKtf5SgmxB4QWkDw7qoMMbbNGtHVpsbJHPyTy2EzRQ\"","counters":[]},{"line":"  in","counters":[]},{"line":"  let got = to_base58_check dummy in","counters":[]},{"line":"  String.equal got expected","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":26,"col_end":26,"count":1}]}]}