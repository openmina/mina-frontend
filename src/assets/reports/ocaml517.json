{"filename":"src/lib/mina_block/precomputed_block.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Mina_base","counters":[]},{"line":"open Mina_state","counters":[]},{"line":"","counters":[]},{"line":"module Proof = struct","counters":[]},{"line":"  type t = Proof.t","counters":[]},{"line":"","counters":[]},{"line":"  let to_bin_string proof =","counters":[]},{"line":"    let proof_string = Binable.to_string (module Proof.Stable.Latest) proof in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    (* We use base64 with the uri-safe alphabet to ensure that encoding and","counters":[]},{"line":"        decoding is cheap, and that the proof can be easily sent over http","counters":[]},{"line":"        etc. without escaping or re-encoding.","counters":[]},{"line":"    *)","counters":[]},{"line":"    Base64.encode_string ~alphabet:Base64.uri_safe_alphabet proof_string","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let of_bin_string str =","counters":[]},{"line":"    let str = Base64.decode_exn ~alphabet:Base64.uri_safe_alphabet str in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Binable.of_string (module Proof.Stable.Latest) str","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let sexp_of_t proof = Sexp.Atom (to_bin_string proof)","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"","counters":[]},{"line":"  let _sexp_of_t_structured = Proof.sexp_of_t","counters":[]},{"line":"","counters":[]},{"line":"  (* Supports decoding base64-encoded and structure encoded proofs. *)","counters":[]},{"line":"  let t_of_sexp = function","counters":[]},{"line":"    | Sexp.Atom str ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        of_bin_string str","counters":[]},{"line":"    | sexp ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Proof.t_of_sexp sexp","counters":[]},{"line":"","counters":[]},{"line":"  let to_yojson proof = `String (to_bin_string proof)","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"","counters":[]},{"line":"  let _to_yojson_structured = Proof.to_yojson","counters":[]},{"line":"","counters":[]},{"line":"  let of_yojson = function","counters":[]},{"line":"    | `String str ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Or_error.try_with (fun () -> of_bin_string str)","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"        |> Result.map_error ~f:(fun err ->","counters":[]},{"line":"               sprintf \"Precomputed_block.Proof.of_yojson: %s\"","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                 (Error.to_string_hum err) )","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"    | json ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Proof.of_yojson json","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module T = struct","counters":[]},{"line":"  (* the accounts_accessed, accounts_created, and tokens_used fields","counters":[]},{"line":"     are used for storing blocks in the archive db, they're not needed","counters":[]},{"line":"     for replaying blocks","counters":[]},{"line":"","counters":[]},{"line":"     in tokens_used, the account id is the token owner","counters":[]},{"line":"  *)","counters":[]},{"line":"  type t =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    { scheduled_time : Block_time.t","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"    ; protocol_state : Protocol_state.value","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"    ; protocol_state_proof : Proof.t","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"    ; staged_ledger_diff : Staged_ledger_diff.t","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"    ; delta_transition_chain_proof :","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"        Frozen_ledger_hash.t * Frozen_ledger_hash.t list","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"    ; accounts_accessed : (int * Account.t) list","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"    ; accounts_created : (Account_id.t * Currency.Fee.t) list","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":54,"col_end":54,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"    ; tokens_used : (Token_id.t * Account_id.t option) list","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":52,"col_end":52,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"    }","counters":[]},{"line":"  [@@deriving sexp, yojson]","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"include T","counters":[]},{"line":"","counters":[]},{"line":"[%%versioned","counters":[]},{"line":"module Stable = struct","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"  [@@@no_toplevel_latest_type]","counters":[]},{"line":"","counters":[]},{"line":"  [@@@with_versioned_json]","counters":[]},{"line":"","counters":[]},{"line":"  module V3 = struct","counters":[]},{"line":"    type t = T.t =","counters":[{"col_start":4,"col_end":4,"count":2},{"col_start":9,"col_end":9,"count":2}]},{"line":"      { scheduled_time : Block_time.Stable.V1.t","counters":[]},{"line":"      ; protocol_state : Protocol_state.Value.Stable.V2.t","counters":[]},{"line":"      ; protocol_state_proof : Mina_base.Proof.Stable.V2.t","counters":[]},{"line":"      ; staged_ledger_diff : Staged_ledger_diff.Stable.V2.t","counters":[]},{"line":"            (* TODO: Delete this or find out why it is here. *)","counters":[]},{"line":"      ; delta_transition_chain_proof :","counters":[]},{"line":"          Frozen_ledger_hash.Stable.V1.t * Frozen_ledger_hash.Stable.V1.t list","counters":[]},{"line":"      ; accounts_accessed : (int * Account.Stable.V2.t) list","counters":[]},{"line":"      ; accounts_created :","counters":[]},{"line":"          (Account_id.Stable.V2.t * Currency.Fee.Stable.V1.t) list","counters":[]},{"line":"      ; tokens_used :","counters":[]},{"line":"          (Token_id.Stable.V2.t * Account_id.Stable.V2.t option) list","counters":[]},{"line":"      }","counters":[{"col_start":6,"col_end":6,"count":5}]},{"line":"","counters":[]},{"line":"    let to_latest = Fn.id","counters":[]},{"line":"  end","counters":[]},{"line":"end]","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"(* functions for the versioned json, not the unversioned ones provided by `T` *)","counters":[]},{"line":"[%%define_locally Stable.Latest.(to_yojson, of_yojson)]","counters":[]},{"line":"","counters":[]},{"line":"let of_block ~logger","counters":[]},{"line":"    ~(constraint_constants : Genesis_constants.Constraint_constants.t)","counters":[]},{"line":"    ~scheduled_time ~staged_ledger block_with_hash =","counters":[]},{"line":"  let ledger = Staged_ledger.ledger staged_ledger in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let block = With_hash.data block_with_hash in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let state_hash =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    (With_hash.hash block_with_hash).State_hash.State_hashes.state_hash","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"  in","counters":[]},{"line":"  let account_ids_accessed = Block.account_ids_accessed block in","counters":[]},{"line":"  let start = Time.now () in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let accounts_accessed =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    List.filter_map account_ids_accessed ~f:(fun acct_id ->","counters":[]},{"line":"        try","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let index = Mina_ledger.Ledger.index_of_account_exn ledger acct_id in","counters":[]},{"line":"          let account = Mina_ledger.Ledger.get_at_index_exn ledger index in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          Some (index, account)","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        with exn ->","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"          [%log error]","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"            \"When computing accounts accessed for precomputed block, exception \\","counters":[]},{"line":"             when finding account id in staged ledger\"","counters":[]},{"line":"            ~metadata:","counters":[]},{"line":"              [ (\"account_id\", Account_id.to_yojson acct_id)","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"              ; (\"exception\", `String (Exn.to_string exn))","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"              ] ;","counters":[]},{"line":"          None )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"  in","counters":[]},{"line":"  let header = Block.header block in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let accounts_accessed_time = Time.now () in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  [%log debug]","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":13,"col_end":13,"count":0}]},{"line":"    \"Precomputed block for $state_hash: accounts-accessed took $time ms\"","counters":[]},{"line":"    ~metadata:","counters":[]},{"line":"      [ (\"state_hash\", Mina_base.State_hash.to_yojson state_hash)","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"      ; ( \"time\"","counters":[]},{"line":"        , `Float (Time.Span.to_ms (Time.diff accounts_accessed_time start)) )","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"      ] ;","counters":[]},{"line":"  let accounts_created =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    let account_creation_fee = constraint_constants.account_creation_fee in","counters":[]},{"line":"    let previous_block_state_hash =","counters":[]},{"line":"      Mina_state.Protocol_state.previous_state_hash","counters":[]},{"line":"        (Header.protocol_state header)","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"    in","counters":[]},{"line":"    List.map","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":11,"col_end":11,"count":0}]},{"line":"      (Staged_ledger.latest_block_accounts_created staged_ledger","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"         ~previous_block_state_hash ) ~f:(fun acct_id ->","counters":[]},{"line":"        (acct_id, account_creation_fee) )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"  in","counters":[]},{"line":"  let tokens_used =","counters":[]},{"line":"    let unique_tokens =","counters":[]},{"line":"      List.map account_ids_accessed ~f:Account_id.token_id","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"      |> List.dedup_and_sort ~compare:Token_id.compare","counters":[]},{"line":"    in","counters":[]},{"line":"    List.map unique_tokens ~f:(fun token_id ->","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":11,"col_end":11,"count":0}]},{"line":"        let owner = Mina_ledger.Ledger.token_owner ledger token_id in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        (token_id, owner) )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"  in","counters":[]},{"line":"  let account_created_time = Time.now () in","counters":[]},{"line":"  [%log debug]","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":13,"col_end":13,"count":0}]},{"line":"    \"Precomputed block for $state_hash: accounts-created took $time ms\"","counters":[]},{"line":"    ~metadata:","counters":[]},{"line":"      [ (\"state_hash\", Mina_base.State_hash.to_yojson state_hash)","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"      ; ( \"time\"","counters":[]},{"line":"        , `Float","counters":[]},{"line":"            (Time.Span.to_ms","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"               (Time.diff account_created_time accounts_accessed_time) ) )","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"      ] ;","counters":[]},{"line":"","counters":[]},{"line":"  { scheduled_time","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  ; protocol_state = Header.protocol_state header","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"  ; protocol_state_proof = Header.protocol_state_proof header","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"  ; staged_ledger_diff =","counters":[]},{"line":"      Staged_ledger_diff.Body.staged_ledger_diff (Block.body block)","counters":[{"col_start":47,"col_end":47,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"  ; delta_transition_chain_proof = Header.delta_block_chain_proof header","counters":[{"col_start":64,"col_end":64,"count":0}]},{"line":"  ; accounts_accessed","counters":[]},{"line":"  ; accounts_created","counters":[]},{"line":"  ; tokens_used","counters":[]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"(* NOTE: This serialization is used externally and MUST NOT change.","counters":[]},{"line":"    If the underlying types change, you should write a conversion, or add","counters":[]},{"line":"    optional fields and handle them appropriately.","counters":[]},{"line":"*)","counters":[]},{"line":"(* But if you really need to update it, see output of CLI command:","counters":[]},{"line":"   `dune exec dump_blocks 2> block.txt` *)","counters":[]},{"line":"let%test_unit \"Sexp serialization is stable\" =","counters":[]},{"line":"  let serialized_block = Sample_precomputed_block.sample_block_sexp in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  ignore @@ t_of_sexp @@ Sexp.of_string serialized_block","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"","counters":[]},{"line":"let%test_unit \"Sexp serialization roundtrips\" =","counters":[]},{"line":"  let serialized_block = Sample_precomputed_block.sample_block_sexp in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let sexp = Sexp.of_string serialized_block in","counters":[]},{"line":"  let sexp_roundtrip = sexp_of_t @@ t_of_sexp sexp in","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"  [%test_eq: Sexp.t] sexp sexp_roundtrip","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":13,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"(* NOTE: This serialization is used externally and MUST NOT change.","counters":[]},{"line":"    If the underlying types change, you should write a conversion, or add","counters":[]},{"line":"    optional fields and handle them appropriately.","counters":[]},{"line":"*)","counters":[]},{"line":"(* But if you really need to update it, see output of CLI command:","counters":[]},{"line":"   `dune exec dump_blocks 2> block.txt` *)","counters":[]},{"line":"let%test_unit \"JSON serialization is stable\" =","counters":[]},{"line":"  let serialized_block = Sample_precomputed_block.sample_block_json in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  match of_yojson @@ Yojson.Safe.from_string serialized_block with","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"  | Ok _ ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ()","counters":[]},{"line":"  | Error err ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      failwith err","counters":[]},{"line":"","counters":[]},{"line":"let%test_unit \"JSON serialization roundtrips\" =","counters":[]},{"line":"  let serialized_block = Sample_precomputed_block.sample_block_json in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let json = Yojson.Safe.from_string serialized_block in","counters":[]},{"line":"  let json_roundtrip =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    match Result.map ~f:to_yojson @@ of_yojson json with","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"    | Ok json ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        json","counters":[]},{"line":"    | Error err ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        failwith err","counters":[]},{"line":"  in","counters":[]},{"line":"  assert (Yojson.Safe.equal json json_roundtrip)","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":47,"col_end":47,"count":2}]}]}