{"filename":"src/lib/codable/codable.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"module type Iso_intf = sig","counters":[]},{"line":"  type original","counters":[]},{"line":"","counters":[]},{"line":"  type standardized [@@deriving yojson]","counters":[]},{"line":"","counters":[]},{"line":"  val encode : original -> standardized","counters":[]},{"line":"","counters":[]},{"line":"  val decode : standardized -> original","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type S = sig","counters":[]},{"line":"  type t","counters":[]},{"line":"","counters":[]},{"line":"  val to_yojson : t -> Yojson.Safe.t","counters":[]},{"line":"","counters":[]},{"line":"  val of_yojson : Yojson.Safe.t -> t Ppx_deriving_yojson_runtime.error_or","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make (Iso : Iso_intf) = struct","counters":[]},{"line":"  let to_yojson t = Iso.encode t |> Iso.standardized_to_yojson","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"  let of_yojson json =","counters":[]},{"line":"    Result.map ~f:Iso.decode (Iso.standardized_of_yojson json)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"","counters":[]},{"line":"  module For_tests = struct","counters":[]},{"line":"    let check_encoding t ~equal =","counters":[]},{"line":"      match of_yojson (to_yojson t) with","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"      | Ok result ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          equal t result","counters":[]},{"line":"      | Error e ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          failwithf !\"%s\" e ()","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module For_tests = struct","counters":[]},{"line":"  let check_encoding (type t) (module M : S with type t = t) t ~equal =","counters":[]},{"line":"    match M.of_yojson (M.to_yojson t) with","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"    | Ok result ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        equal t result","counters":[]},{"line":"    | Error e ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        failwithf !\"%s\" e ()","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make_of_int (Iso : sig","counters":[]},{"line":"  type t","counters":[]},{"line":"","counters":[]},{"line":"  val to_int : t -> int","counters":[]},{"line":"","counters":[]},{"line":"  val of_int : int -> t","counters":[]},{"line":"end) =","counters":[]},{"line":"Make (struct","counters":[]},{"line":"  type original = Iso.t","counters":[]},{"line":"","counters":[]},{"line":"  type standardized = int [@@deriving yojson]","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"  let encode = Iso.to_int","counters":[]},{"line":"","counters":[]},{"line":"  let decode = Iso.of_int","counters":[]},{"line":"end)","counters":[]},{"line":"","counters":[]},{"line":"module Make_of_string (Iso : sig","counters":[]},{"line":"  type t","counters":[]},{"line":"","counters":[]},{"line":"  val to_string : t -> string","counters":[]},{"line":"","counters":[]},{"line":"  val of_string : string -> t","counters":[]},{"line":"end) =","counters":[]},{"line":"Make (struct","counters":[]},{"line":"  type original = Iso.t","counters":[]},{"line":"","counters":[]},{"line":"  type standardized = string [@@deriving yojson]","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"  let encode = Iso.to_string","counters":[]},{"line":"","counters":[]},{"line":"  let decode = Iso.of_string","counters":[]},{"line":"end)","counters":[]},{"line":"","counters":[]},{"line":"module Make_base58_check (T : sig","counters":[]},{"line":"  type t [@@deriving bin_io]","counters":[]},{"line":"","counters":[]},{"line":"  val description : string","counters":[]},{"line":"","counters":[]},{"line":"  val version_byte : char","counters":[]},{"line":"end) =","counters":[]},{"line":"struct","counters":[]},{"line":"  module Base58_check = Base58_check.Make (T)","counters":[]},{"line":"","counters":[]},{"line":"  let to_base58_check t = Base58_check.encode (Binable.to_string (module T) t)","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"","counters":[]},{"line":"  let of_base58_check s =","counters":[]},{"line":"    let open Or_error.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let%bind decoded = Base58_check.decode s in","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"    Or_error.try_with (fun () -> Binable.of_string (module T) decoded)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"","counters":[]},{"line":"  let of_base58_check_exn s = of_base58_check s |> Or_error.ok_exn","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"  let to_yojson t = `String (to_base58_check t)","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"","counters":[]},{"line":"  let of_yojson = function","counters":[]},{"line":"    | `String s ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Result.map_error (of_base58_check s) ~f:Error.to_string_hum","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"    | json ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        failwithf \"of_yojson: expect JSON string, got %s\"","counters":[]},{"line":"          (Yojson.Safe.to_string json)","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"          ()","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type Base58_check_base_intf = sig","counters":[]},{"line":"  type t","counters":[]},{"line":"","counters":[]},{"line":"  (** Base58Check decoding *)","counters":[]},{"line":"  val of_base58_check : string -> t Base.Or_error.t","counters":[]},{"line":"","counters":[]},{"line":"  (** Base58Check decoding *)","counters":[]},{"line":"  val of_base58_check_exn : string -> t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type Base58_check_intf = sig","counters":[]},{"line":"  type t","counters":[]},{"line":"","counters":[]},{"line":"  (** explicit Base58Check encoding *)","counters":[]},{"line":"  val to_base58_check : t -> string","counters":[]},{"line":"","counters":[]},{"line":"  include Base58_check_base_intf with type t := t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make_base64 (T : sig","counters":[]},{"line":"  type t [@@deriving bin_io]","counters":[]},{"line":"end) =","counters":[]},{"line":"struct","counters":[]},{"line":"  let to_base64 (t : T.t) : string =","counters":[]},{"line":"    Binable.to_string (module T) t","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":20,"col_end":20,"count":0}]},{"line":"    |> (* raises only on errors from invalid optional arguments *)","counters":[]},{"line":"    Base64.encode_exn","counters":[]},{"line":"","counters":[]},{"line":"  let of_base64 b64 : T.t Or_error.t =","counters":[]},{"line":"    match Base64.decode b64 with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Ok s -> (","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        try Ok (Binable.of_string (module T) s)","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"        with Bin_prot.Common.Read_error _ as e ->","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"          Error (Error.of_exn ~backtrace:`Get e) )","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"    | Error (`Msg msg) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Error (Error.of_string msg)","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type Base64_intf = sig","counters":[]},{"line":"  type t","counters":[]},{"line":"","counters":[]},{"line":"  val to_base64 : t -> string","counters":[]},{"line":"","counters":[]},{"line":"  val of_base64 : string -> t Or_error.t","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}