{"filename":"src/lib/consensus/intf.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Mina_numbers","counters":[]},{"line":"open Async","counters":[]},{"line":"open Currency","counters":[]},{"line":"open Signature_lib","counters":[]},{"line":"open Mina_base","counters":[]},{"line":"","counters":[]},{"line":"module type CONTEXT = sig","counters":[]},{"line":"  val logger : Logger.t","counters":[]},{"line":"","counters":[]},{"line":"  val constraint_constants : Genesis_constants.Constraint_constants.t","counters":[]},{"line":"","counters":[]},{"line":"  val consensus_constants : Constants.t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type Constants = sig","counters":[]},{"line":"  [%%versioned:","counters":[]},{"line":"  module Stable : sig","counters":[]},{"line":"    module V1 : sig","counters":[]},{"line":"      type t","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  val create : protocol_constants:Genesis_constants.Protocol.t -> t","counters":[]},{"line":"","counters":[]},{"line":"  val gc_parameters :","counters":[]},{"line":"       t","counters":[]},{"line":"    -> [ `Acceptable_network_delay of Length.t ]","counters":[]},{"line":"       * [ `Gc_width of Length.t ]","counters":[]},{"line":"       * [ `Gc_width_epoch of Length.t ]","counters":[]},{"line":"       * [ `Gc_width_slot of Length.t ]","counters":[]},{"line":"       * [ `Gc_interval of Length.t ]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type Blockchain_state = sig","counters":[]},{"line":"  module Poly : sig","counters":[]},{"line":"    type ( 'staged_ledger_hash","counters":[]},{"line":"         , 'snarked_ledger_hash","counters":[]},{"line":"         , 'local_state","counters":[]},{"line":"         , 'time","counters":[]},{"line":"         , 'body_ref )","counters":[]},{"line":"         t","counters":[]},{"line":"    [@@deriving sexp]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Value : sig","counters":[]},{"line":"    type t =","counters":[]},{"line":"      ( Staged_ledger_hash.t","counters":[]},{"line":"      , Frozen_ledger_hash.t","counters":[]},{"line":"      , Mina_transaction_logic.Zkapp_command_logic.Local_state.Value.t","counters":[]},{"line":"      , Block_time.t","counters":[]},{"line":"      , Body_reference.t )","counters":[]},{"line":"      Poly.t","counters":[]},{"line":"    [@@deriving sexp]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  type var =","counters":[]},{"line":"    ( Staged_ledger_hash.var","counters":[]},{"line":"    , Frozen_ledger_hash.var","counters":[]},{"line":"    , Mina_transaction_logic.Zkapp_command_logic.Local_state.Checked.t","counters":[]},{"line":"    , Block_time.Checked.t","counters":[]},{"line":"    , Body_reference.var )","counters":[]},{"line":"    Poly.t","counters":[]},{"line":"","counters":[]},{"line":"  val staged_ledger_hash :","counters":[]},{"line":"    ('staged_ledger_hash, _, _, _, _) Poly.t -> 'staged_ledger_hash","counters":[]},{"line":"","counters":[]},{"line":"  val snarked_ledger_hash :","counters":[]},{"line":"    (_, 'frozen_ledger_hash, _, _, _) Poly.t -> 'frozen_ledger_hash","counters":[]},{"line":"","counters":[]},{"line":"  val genesis_ledger_hash :","counters":[]},{"line":"    (_, 'frozen_ledger_hash, _, _, _) Poly.t -> 'frozen_ledger_hash","counters":[]},{"line":"","counters":[]},{"line":"  val timestamp : (_, _, _, 'time, _) Poly.t -> 'time","counters":[]},{"line":"","counters":[]},{"line":"  val body_reference : (_, _, _, _, 'body_reference) Poly.t -> 'body_reference","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type Protocol_state = sig","counters":[]},{"line":"  type blockchain_state","counters":[]},{"line":"","counters":[]},{"line":"  type blockchain_state_var","counters":[]},{"line":"","counters":[]},{"line":"  type consensus_state","counters":[]},{"line":"","counters":[]},{"line":"  type consensus_state_var","counters":[]},{"line":"","counters":[]},{"line":"  module Poly : sig","counters":[]},{"line":"    type ('state_hash, 'body) t [@@deriving equal, hash, sexp, to_yojson]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Body : sig","counters":[]},{"line":"    module Poly : sig","counters":[]},{"line":"      type ('state_hash, 'blockchain_state, 'consensus_state, 'constants) t","counters":[]},{"line":"      [@@deriving sexp]","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Value : sig","counters":[]},{"line":"      type t =","counters":[]},{"line":"        ( State_hash.t","counters":[]},{"line":"        , blockchain_state","counters":[]},{"line":"        , consensus_state","counters":[]},{"line":"        , Protocol_constants_checked.Value.Stable.V1.t )","counters":[]},{"line":"        Poly.t","counters":[]},{"line":"      [@@deriving sexp, to_yojson]","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    type var =","counters":[]},{"line":"      ( State_hash.var","counters":[]},{"line":"      , blockchain_state_var","counters":[]},{"line":"      , consensus_state_var","counters":[]},{"line":"      , Protocol_constants_checked.var )","counters":[]},{"line":"      Poly.t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Value : sig","counters":[]},{"line":"    type t = (State_hash.t, Body.Value.t) Poly.t","counters":[]},{"line":"    [@@deriving sexp, equal, compare]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  type var = (State_hash.var, Body.var) Poly.t","counters":[]},{"line":"","counters":[]},{"line":"  val create_value :","counters":[]},{"line":"       previous_state_hash:State_hash.t","counters":[]},{"line":"    -> genesis_state_hash:State_hash.t","counters":[]},{"line":"    -> blockchain_state:blockchain_state","counters":[]},{"line":"    -> consensus_state:consensus_state","counters":[]},{"line":"    -> constants:Protocol_constants_checked.Value.t","counters":[]},{"line":"    -> Value.t","counters":[]},{"line":"","counters":[]},{"line":"  val previous_state_hash : ('state_hash, _) Poly.t -> 'state_hash","counters":[]},{"line":"","counters":[]},{"line":"  val body : (_, 'body) Poly.t -> 'body","counters":[]},{"line":"","counters":[]},{"line":"  val blockchain_state :","counters":[]},{"line":"    (_, (_, 'blockchain_state, _, _) Body.Poly.t) Poly.t -> 'blockchain_state","counters":[]},{"line":"","counters":[]},{"line":"  val genesis_state_hash :","counters":[]},{"line":"    ?state_hash:State_hash.t option -> Value.t -> State_hash.t","counters":[]},{"line":"","counters":[]},{"line":"  val consensus_state :","counters":[]},{"line":"    (_, (_, _, 'consensus_state, _) Body.Poly.t) Poly.t -> 'consensus_state","counters":[]},{"line":"","counters":[]},{"line":"  val constants : (_, (_, _, _, 'constants) Body.Poly.t) Poly.t -> 'constants","counters":[]},{"line":"","counters":[]},{"line":"  val hash : Value.t -> State_hash.t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type Snark_transition = sig","counters":[]},{"line":"  type blockchain_state_var","counters":[]},{"line":"","counters":[]},{"line":"  type consensus_transition_var","counters":[]},{"line":"","counters":[]},{"line":"  module Poly : sig","counters":[]},{"line":"    type ('blockchain_state, 'consensus_transition, 'pending_coinbase_update) t","counters":[]},{"line":"    [@@deriving sexp]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Value : sig","counters":[]},{"line":"    type t [@@deriving sexp]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  type var =","counters":[]},{"line":"    ( blockchain_state_var","counters":[]},{"line":"    , consensus_transition_var","counters":[]},{"line":"    , Pending_coinbase.Update.var )","counters":[]},{"line":"    Poly.t","counters":[]},{"line":"","counters":[]},{"line":"  val consensus_transition :","counters":[]},{"line":"    (_, 'consensus_transition, _) Poly.t -> 'consensus_transition","counters":[]},{"line":"","counters":[]},{"line":"  val blockchain_state : ('blockchain_state, _, _) Poly.t -> 'blockchain_state","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type State_hooks = sig","counters":[]},{"line":"  type consensus_state","counters":[]},{"line":"","counters":[]},{"line":"  type consensus_state_var","counters":[]},{"line":"","counters":[]},{"line":"  type consensus_transition","counters":[]},{"line":"","counters":[]},{"line":"  type block_data","counters":[]},{"line":"","counters":[]},{"line":"  type blockchain_state","counters":[]},{"line":"","counters":[]},{"line":"  type protocol_state","counters":[]},{"line":"","counters":[]},{"line":"  type protocol_state_var","counters":[]},{"line":"","counters":[]},{"line":"  type snark_transition_var","counters":[]},{"line":"","counters":[]},{"line":"  (**","counters":[]},{"line":"   * Generate a new protocol state and consensus specific transition data","counters":[]},{"line":"   * for a new transition. Called from the block producer in order to generate","counters":[]},{"line":"   * a new transition to broadcast to the network. Returns `None` if a new","counters":[]},{"line":"   * transition cannot be generated.","counters":[]},{"line":"  *)","counters":[]},{"line":"  val generate_transition :","counters":[]},{"line":"       previous_protocol_state:protocol_state","counters":[]},{"line":"    -> blockchain_state:blockchain_state","counters":[]},{"line":"    -> current_time:Unix_timestamp.t","counters":[]},{"line":"    -> block_data:block_data","counters":[]},{"line":"    -> supercharge_coinbase:bool","counters":[]},{"line":"    -> snarked_ledger_hash:Mina_base.Frozen_ledger_hash.t","counters":[]},{"line":"    -> genesis_ledger_hash:Mina_base.Frozen_ledger_hash.t","counters":[]},{"line":"    -> supply_increase:Currency.Amount.Signed.t","counters":[]},{"line":"    -> logger:Logger.t","counters":[]},{"line":"    -> constraint_constants:Genesis_constants.Constraint_constants.t","counters":[]},{"line":"    -> protocol_state * consensus_transition","counters":[]},{"line":"","counters":[]},{"line":"  (**","counters":[]},{"line":"   * Create a constrained, checked var for the next consensus state of","counters":[]},{"line":"   * a given consensus state and snark transition.","counters":[]},{"line":"  *)","counters":[]},{"line":"  val next_state_checked :","counters":[]},{"line":"       constraint_constants:Genesis_constants.Constraint_constants.t","counters":[]},{"line":"    -> prev_state:protocol_state_var","counters":[]},{"line":"    -> prev_state_hash:Mina_base.State_hash.var","counters":[]},{"line":"    -> snark_transition_var","counters":[]},{"line":"    -> Currency.Amount.Signed.var","counters":[]},{"line":"    -> ([ `Success of Snark_params.Tick.Boolean.var ] * consensus_state_var)","counters":[]},{"line":"       Snark_params.Tick.Checked.t","counters":[]},{"line":"","counters":[]},{"line":"  val genesis_winner : Public_key.Compressed.t * Private_key.t","counters":[]},{"line":"","counters":[]},{"line":"  module For_tests : sig","counters":[]},{"line":"    val gen_consensus_state :","counters":[]},{"line":"         constraint_constants:Genesis_constants.Constraint_constants.t","counters":[]},{"line":"      -> constants:Constants.t","counters":[]},{"line":"      -> gen_slot_advancement:int Quickcheck.Generator.t","counters":[]},{"line":"      -> (   previous_protocol_state:","counters":[]},{"line":"               protocol_state Mina_base.State_hash.With_state_hashes.t","counters":[]},{"line":"          -> snarked_ledger_hash:Mina_base.Frozen_ledger_hash.t","counters":[]},{"line":"          -> coinbase_receiver:Public_key.Compressed.t","counters":[]},{"line":"          -> supercharge_coinbase:bool","counters":[]},{"line":"          -> consensus_state )","counters":[]},{"line":"         Quickcheck.Generator.t","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type S = sig","counters":[]},{"line":"  val name : string","counters":[]},{"line":"","counters":[]},{"line":"  (** Return a string that tells a human what the consensus view of an instant in time is.","counters":[]},{"line":"    *","counters":[]},{"line":"    * This is mostly useful for PoStake and other consensus mechanisms that have their own","counters":[]},{"line":"    * notions of time.","counters":[]},{"line":"  *)","counters":[]},{"line":"  val time_hum : constants:Constants.t -> Block_time.t -> string","counters":[]},{"line":"","counters":[]},{"line":"  module Constants = Constants","counters":[]},{"line":"","counters":[]},{"line":"  module Configuration : sig","counters":[]},{"line":"    [%%versioned:","counters":[]},{"line":"    module Stable : sig","counters":[]},{"line":"      module V1 : sig","counters":[]},{"line":"        type t =","counters":[]},{"line":"          { delta : int","counters":[]},{"line":"          ; k : int","counters":[]},{"line":"          ; slots_per_epoch : int","counters":[]},{"line":"          ; slot_duration : int","counters":[]},{"line":"          ; epoch_duration : int","counters":[]},{"line":"          ; genesis_state_timestamp : Block_time.Stable.V1.t","counters":[]},{"line":"          ; acceptable_network_delay : int","counters":[]},{"line":"          }","counters":[]},{"line":"        [@@deriving yojson, fields]","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    val t :","counters":[]},{"line":"         constraint_constants:Genesis_constants.Constraint_constants.t","counters":[]},{"line":"      -> protocol_constants:Genesis_constants.Protocol.t","counters":[]},{"line":"      -> t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Genesis_epoch_data : sig","counters":[]},{"line":"    module Data : sig","counters":[]},{"line":"      type t =","counters":[]},{"line":"        { ledger : Mina_ledger.Ledger.t Lazy.t; seed : Mina_base.Epoch_seed.t }","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    type tt = { staking : Data.t; next : Data.t option }","counters":[]},{"line":"","counters":[]},{"line":"    type t = tt option","counters":[]},{"line":"","counters":[]},{"line":"    val for_unit_tests : t","counters":[]},{"line":"","counters":[]},{"line":"    val compiled : t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Data : sig","counters":[]},{"line":"    module Local_state : sig","counters":[]},{"line":"      module Snapshot : sig","counters":[]},{"line":"        module Ledger_snapshot : sig","counters":[]},{"line":"          type t =","counters":[]},{"line":"            | Genesis_epoch_ledger of Mina_ledger.Ledger.t","counters":[]},{"line":"            | Ledger_db of Mina_ledger.Ledger.Db.t","counters":[]},{"line":"","counters":[]},{"line":"          val close : t -> unit","counters":[]},{"line":"","counters":[]},{"line":"          val merkle_root : t -> Mina_base.Ledger_hash.t","counters":[]},{"line":"        end","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      type t [@@deriving to_yojson]","counters":[]},{"line":"","counters":[]},{"line":"      val create :","counters":[]},{"line":"           Signature_lib.Public_key.Compressed.Set.t","counters":[]},{"line":"        -> context:(module CONTEXT)","counters":[]},{"line":"        -> genesis_ledger:Mina_ledger.Ledger.t Lazy.t","counters":[]},{"line":"        -> genesis_epoch_data:Genesis_epoch_data.t","counters":[]},{"line":"        -> epoch_ledger_location:string","counters":[]},{"line":"        -> genesis_state_hash:State_hash.t","counters":[]},{"line":"        -> t","counters":[]},{"line":"","counters":[]},{"line":"      val current_block_production_keys :","counters":[]},{"line":"        t -> Signature_lib.Public_key.Compressed.Set.t","counters":[]},{"line":"","counters":[]},{"line":"      val current_epoch_delegatee_table :","counters":[]},{"line":"           local_state:t","counters":[]},{"line":"        -> Mina_base.Account.t Mina_base.Account.Index.Table.t","counters":[]},{"line":"           Public_key.Compressed.Table.t","counters":[]},{"line":"","counters":[]},{"line":"      val last_epoch_delegatee_table :","counters":[]},{"line":"           local_state:t","counters":[]},{"line":"        -> Mina_base.Account.t Mina_base.Account.Index.Table.t","counters":[]},{"line":"           Public_key.Compressed.Table.t","counters":[]},{"line":"           option","counters":[]},{"line":"","counters":[]},{"line":"      val next_epoch_ledger : t -> Snapshot.Ledger_snapshot.t","counters":[]},{"line":"","counters":[]},{"line":"      val staking_epoch_ledger : t -> Snapshot.Ledger_snapshot.t","counters":[]},{"line":"","counters":[]},{"line":"      (** Swap in a new set of block production keys and invalidate and/or","counters":[]},{"line":"          recompute cached data *)","counters":[]},{"line":"      val block_production_keys_swap :","counters":[]},{"line":"           constants:Constants.t","counters":[]},{"line":"        -> t","counters":[]},{"line":"        -> Signature_lib.Public_key.Compressed.Set.t","counters":[]},{"line":"        -> Block_time.t","counters":[]},{"line":"        -> unit","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Vrf : sig","counters":[]},{"line":"      val check :","counters":[]},{"line":"           context:(module CONTEXT)","counters":[]},{"line":"        -> global_slot:Mina_numbers.Global_slot.t","counters":[]},{"line":"        -> seed:Mina_base.Epoch_seed.t","counters":[]},{"line":"        -> producer_private_key:Signature_lib.Private_key.t","counters":[]},{"line":"        -> producer_public_key:Signature_lib.Public_key.Compressed.t","counters":[]},{"line":"        -> total_stake:Amount.t","counters":[]},{"line":"        -> get_delegators:","counters":[]},{"line":"             (   Public_key.Compressed.t","counters":[]},{"line":"              -> Mina_base.Account.t Mina_base.Account.Index.Table.t option )","counters":[]},{"line":"        -> ( ( [ `Vrf_eval of string ]","counters":[]},{"line":"             * [> `Vrf_output of Consensus_vrf.Output_hash.t ]","counters":[]},{"line":"             * [> `Delegator of","counters":[]},{"line":"                  Signature_lib.Public_key.Compressed.t","counters":[]},{"line":"                  * Mina_base.Account.Index.t ] )","counters":[]},{"line":"             option","counters":[]},{"line":"           , unit )","counters":[]},{"line":"           Interruptible.t","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Prover_state : sig","counters":[]},{"line":"      [%%versioned:","counters":[]},{"line":"      module Stable : sig","counters":[]},{"line":"        [@@@no_toplevel_latest_type]","counters":[]},{"line":"","counters":[]},{"line":"        module V2 : sig","counters":[]},{"line":"          type t","counters":[]},{"line":"","counters":[]},{"line":"          val to_latest : t -> t","counters":[]},{"line":"        end","counters":[]},{"line":"      end]","counters":[]},{"line":"","counters":[]},{"line":"      type t = Stable.Latest.t [@@deriving to_yojson, sexp]","counters":[]},{"line":"","counters":[]},{"line":"      val genesis_data : genesis_epoch_ledger:Mina_ledger.Ledger.t Lazy.t -> t","counters":[]},{"line":"","counters":[]},{"line":"      val precomputed_handler :","counters":[]},{"line":"           constraint_constants:Genesis_constants.Constraint_constants.t","counters":[]},{"line":"        -> genesis_epoch_ledger:Mina_ledger.Ledger.t Lazy.t","counters":[]},{"line":"        -> Snark_params.Tick.Handler.t","counters":[]},{"line":"","counters":[]},{"line":"      val handler :","counters":[]},{"line":"           t","counters":[]},{"line":"        -> constraint_constants:Genesis_constants.Constraint_constants.t","counters":[]},{"line":"        -> pending_coinbase:Mina_base.Pending_coinbase_witness.t","counters":[]},{"line":"        -> Snark_params.Tick.Handler.t","counters":[]},{"line":"","counters":[]},{"line":"      val ledger_depth : t -> int","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Consensus_transition : sig","counters":[]},{"line":"      module Value : sig","counters":[]},{"line":"        [%%versioned:","counters":[]},{"line":"        module Stable : sig","counters":[]},{"line":"          module V1 : sig","counters":[]},{"line":"            type t [@@deriving sexp, to_yojson]","counters":[]},{"line":"          end","counters":[]},{"line":"        end]","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      include Snark_params.Tick.Snarkable.S with type value := Value.t","counters":[]},{"line":"","counters":[]},{"line":"      val genesis : Value.t","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Consensus_time : sig","counters":[]},{"line":"      [%%versioned:","counters":[]},{"line":"      module Stable : sig","counters":[]},{"line":"        module V1 : sig","counters":[]},{"line":"          type t [@@deriving compare, sexp, yojson]","counters":[]},{"line":"        end","counters":[]},{"line":"      end]","counters":[]},{"line":"","counters":[]},{"line":"      val to_string_hum : t -> string","counters":[]},{"line":"","counters":[]},{"line":"      val to_time : constants:Constants.t -> t -> Block_time.t","counters":[]},{"line":"","counters":[]},{"line":"      val of_time_exn : constants:Constants.t -> Block_time.t -> t","counters":[]},{"line":"","counters":[]},{"line":"      (** Gets the corresponding a reasonable consensus time that is considered to be \"old\" and not accepted by other peers by the consensus mechanism *)","counters":[]},{"line":"      val get_old : constants:Constants.t -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"      val to_uint32 : t -> Unsigned.UInt32.t","counters":[]},{"line":"","counters":[]},{"line":"      val epoch : t -> Unsigned.UInt32.t","counters":[]},{"line":"","counters":[]},{"line":"      val slot : t -> Unsigned.UInt32.t","counters":[]},{"line":"","counters":[]},{"line":"      val succ : t -> t","counters":[]},{"line":"","counters":[]},{"line":"      val start_time : constants:Constants.t -> t -> Block_time.t","counters":[]},{"line":"","counters":[]},{"line":"      val end_time : constants:Constants.t -> t -> Block_time.t","counters":[]},{"line":"","counters":[]},{"line":"      val to_global_slot : t -> Mina_numbers.Global_slot.t","counters":[]},{"line":"","counters":[]},{"line":"      val of_global_slot :","counters":[]},{"line":"        constants:Constants.t -> Mina_numbers.Global_slot.t -> t","counters":[]},{"line":"","counters":[]},{"line":"      val zero : constants:Constants.t -> t","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Consensus_state : sig","counters":[]},{"line":"      module Value : sig","counters":[]},{"line":"        [%%versioned:","counters":[]},{"line":"        module Stable : sig","counters":[]},{"line":"          module V1 : sig","counters":[]},{"line":"            type t [@@deriving hash, equal, compare, sexp, yojson]","counters":[]},{"line":"          end","counters":[]},{"line":"        end]","counters":[]},{"line":"","counters":[]},{"line":"        module For_tests : sig","counters":[]},{"line":"          val with_global_slot_since_genesis :","counters":[]},{"line":"            t -> Mina_numbers.Global_slot.t -> t","counters":[]},{"line":"        end","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      type display [@@deriving yojson]","counters":[]},{"line":"","counters":[]},{"line":"      type var","counters":[]},{"line":"","counters":[]},{"line":"      val typ :","counters":[]},{"line":"           constraint_constants:Genesis_constants.Constraint_constants.t","counters":[]},{"line":"        -> (var, Value.t) Snark_params.Tick.Typ.t","counters":[]},{"line":"","counters":[]},{"line":"      val negative_one :","counters":[]},{"line":"           genesis_ledger:Mina_ledger.Ledger.t Lazy.t","counters":[]},{"line":"        -> genesis_epoch_data:Genesis_epoch_data.t","counters":[]},{"line":"        -> constants:Constants.t","counters":[]},{"line":"        -> constraint_constants:Genesis_constants.Constraint_constants.t","counters":[]},{"line":"        -> Value.t","counters":[]},{"line":"","counters":[]},{"line":"      val create_genesis_from_transition :","counters":[]},{"line":"           negative_one_protocol_state_hash:Mina_base.State_hash.t","counters":[]},{"line":"        -> consensus_transition:Consensus_transition.Value.t","counters":[]},{"line":"        -> genesis_ledger:Mina_ledger.Ledger.t Lazy.t","counters":[]},{"line":"        -> genesis_epoch_data:Genesis_epoch_data.t","counters":[]},{"line":"        -> constraint_constants:Genesis_constants.Constraint_constants.t","counters":[]},{"line":"        -> constants:Constants.t","counters":[]},{"line":"        -> Value.t","counters":[]},{"line":"","counters":[]},{"line":"      val create_genesis :","counters":[]},{"line":"           negative_one_protocol_state_hash:Mina_base.State_hash.t","counters":[]},{"line":"        -> genesis_ledger:Mina_ledger.Ledger.t Lazy.t","counters":[]},{"line":"        -> genesis_epoch_data:Genesis_epoch_data.t","counters":[]},{"line":"        -> constraint_constants:Genesis_constants.Constraint_constants.t","counters":[]},{"line":"        -> constants:Constants.t","counters":[]},{"line":"        -> Value.t","counters":[]},{"line":"","counters":[]},{"line":"      open Snark_params.Tick","counters":[]},{"line":"","counters":[]},{"line":"      val var_to_input : var -> Field.Var.t Random_oracle.Input.Chunked.t","counters":[]},{"line":"","counters":[]},{"line":"      val to_input : Value.t -> Field.t Random_oracle.Input.Chunked.t","counters":[]},{"line":"","counters":[]},{"line":"      val display : Value.t -> display","counters":[]},{"line":"","counters":[]},{"line":"      val consensus_time : Value.t -> Consensus_time.t","counters":[]},{"line":"","counters":[]},{"line":"      val blockchain_length : Value.t -> Length.t","counters":[]},{"line":"","counters":[]},{"line":"      val min_window_density : Value.t -> Length.t","counters":[]},{"line":"","counters":[]},{"line":"      val block_stake_winner : Value.t -> Public_key.Compressed.t","counters":[]},{"line":"","counters":[]},{"line":"      val block_creator : Value.t -> Public_key.Compressed.t","counters":[]},{"line":"","counters":[]},{"line":"      val coinbase_receiver : Value.t -> Public_key.Compressed.t","counters":[]},{"line":"","counters":[]},{"line":"      val coinbase_receiver_var : var -> Public_key.Compressed.var","counters":[]},{"line":"","counters":[]},{"line":"      val curr_global_slot_var : var -> Global_slot.Checked.t","counters":[]},{"line":"","counters":[]},{"line":"      val blockchain_length_var : var -> Length.Checked.t","counters":[]},{"line":"","counters":[]},{"line":"      val min_window_density_var : var -> Length.Checked.t","counters":[]},{"line":"","counters":[]},{"line":"      val total_currency_var : var -> Amount.Checked.t","counters":[]},{"line":"","counters":[]},{"line":"      val staking_epoch_data_var : var -> Mina_base.Epoch_data.var","counters":[]},{"line":"","counters":[]},{"line":"      val staking_epoch_data : Value.t -> Mina_base.Epoch_data.Value.t","counters":[]},{"line":"","counters":[]},{"line":"      val next_epoch_data_var : var -> Mina_base.Epoch_data.var","counters":[]},{"line":"","counters":[]},{"line":"      val next_epoch_data : Value.t -> Mina_base.Epoch_data.Value.t","counters":[]},{"line":"","counters":[]},{"line":"      val graphql_type : unit -> ('ctx, Value.t option) Graphql_async.Schema.typ","counters":[]},{"line":"","counters":[]},{"line":"      val curr_slot : Value.t -> Slot.t","counters":[]},{"line":"","counters":[]},{"line":"      val epoch_count : Value.t -> Length.t","counters":[]},{"line":"","counters":[]},{"line":"      val curr_global_slot : Value.t -> Mina_numbers.Global_slot.t","counters":[]},{"line":"","counters":[]},{"line":"      val total_currency : Value.t -> Amount.t","counters":[]},{"line":"","counters":[]},{"line":"      val global_slot_since_genesis : Value.t -> Mina_numbers.Global_slot.t","counters":[]},{"line":"","counters":[]},{"line":"      val global_slot_since_genesis_var :","counters":[]},{"line":"        var -> Mina_numbers.Global_slot.Checked.t","counters":[]},{"line":"","counters":[]},{"line":"      val is_genesis_state : Value.t -> bool","counters":[]},{"line":"","counters":[]},{"line":"      val is_genesis_state_var : var -> Boolean.var Checked.t","counters":[]},{"line":"","counters":[]},{"line":"      val supercharge_coinbase_var : var -> Boolean.var","counters":[]},{"line":"","counters":[]},{"line":"      val supercharge_coinbase : Value.t -> bool","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Block_data : sig","counters":[]},{"line":"      type t","counters":[]},{"line":"","counters":[]},{"line":"      val epoch_ledger : t -> Mina_ledger.Sparse_ledger.t","counters":[]},{"line":"","counters":[]},{"line":"      val global_slot : t -> Mina_numbers.Global_slot.t","counters":[]},{"line":"","counters":[]},{"line":"      val prover_state : t -> Prover_state.t","counters":[]},{"line":"","counters":[]},{"line":"      val global_slot_since_genesis : t -> Mina_numbers.Global_slot.t","counters":[]},{"line":"","counters":[]},{"line":"      val coinbase_receiver : t -> Public_key.Compressed.t","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Epoch_data_for_vrf : sig","counters":[]},{"line":"      [%%versioned:","counters":[]},{"line":"      module Stable : sig","counters":[]},{"line":"        module V2 : sig","counters":[]},{"line":"          type t =","counters":[]},{"line":"            { epoch_ledger : Mina_base.Epoch_ledger.Value.Stable.V1.t","counters":[]},{"line":"            ; epoch_seed : Mina_base.Epoch_seed.Stable.V1.t","counters":[]},{"line":"            ; epoch : Mina_numbers.Length.Stable.V1.t","counters":[]},{"line":"            ; global_slot : Mina_numbers.Global_slot.Stable.V1.t","counters":[]},{"line":"            ; global_slot_since_genesis : Mina_numbers.Global_slot.Stable.V1.t","counters":[]},{"line":"            ; delegatee_table :","counters":[]},{"line":"                Mina_base.Account.Stable.V2.t","counters":[]},{"line":"                Mina_base.Account.Index.Stable.V1.Table.t","counters":[]},{"line":"                Public_key.Compressed.Stable.V1.Table.t","counters":[]},{"line":"            }","counters":[]},{"line":"          [@@deriving sexp]","counters":[]},{"line":"","counters":[]},{"line":"          val to_latest : t -> t","counters":[]},{"line":"        end","counters":[]},{"line":"      end]","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Slot_won : sig","counters":[]},{"line":"      [%%versioned:","counters":[]},{"line":"      module Stable : sig","counters":[]},{"line":"        module V1 : sig","counters":[]},{"line":"          type t =","counters":[]},{"line":"            { delegator :","counters":[]},{"line":"                Signature_lib.Public_key.Compressed.Stable.V1.t","counters":[]},{"line":"                * Mina_base.Account.Index.Stable.V1.t","counters":[]},{"line":"            ; producer : Signature_lib.Keypair.Stable.V1.t","counters":[]},{"line":"            ; global_slot : Mina_numbers.Global_slot.Stable.V1.t","counters":[]},{"line":"            ; global_slot_since_genesis : Mina_numbers.Global_slot.Stable.V1.t","counters":[]},{"line":"            ; vrf_result : Consensus_vrf.Output_hash.Stable.V1.t","counters":[]},{"line":"            }","counters":[]},{"line":"          [@@deriving sexp]","counters":[]},{"line":"","counters":[]},{"line":"          val to_latest : t -> t","counters":[]},{"line":"        end","counters":[]},{"line":"      end]","counters":[]},{"line":"    end","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Coinbase_receiver : sig","counters":[]},{"line":"    (* Producer: block producer receives coinbases","counters":[]},{"line":"       Other: specified account (with default token) receives coinbases","counters":[]},{"line":"    *)","counters":[]},{"line":"","counters":[]},{"line":"    type t = [ `Producer | `Other of Public_key.Compressed.t ]","counters":[]},{"line":"    [@@deriving yojson]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Hooks : sig","counters":[]},{"line":"    open Data","counters":[]},{"line":"","counters":[]},{"line":"    module Rpcs : sig","counters":[]},{"line":"      include Network_peer.Rpc_intf.Rpc_interface_intf","counters":[]},{"line":"","counters":[]},{"line":"      val rpc_handlers :","counters":[]},{"line":"           context:(module CONTEXT)","counters":[]},{"line":"        -> local_state:Local_state.t","counters":[]},{"line":"        -> genesis_ledger_hash:Frozen_ledger_hash.t","counters":[]},{"line":"        -> rpc_handler list","counters":[]},{"line":"","counters":[]},{"line":"      type query =","counters":[]},{"line":"        { query :","counters":[]},{"line":"            'q 'r.","counters":[]},{"line":"               Network_peer.Peer.t","counters":[]},{"line":"            -> ('q, 'r) rpc","counters":[]},{"line":"            -> 'q","counters":[]},{"line":"            -> 'r Network_peer.Rpc_intf.rpc_response Deferred.t","counters":[]},{"line":"        }","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    (* Check whether we are in the genesis epoch *)","counters":[]},{"line":"    val is_genesis_epoch : constants:Constants.t -> Block_time.t -> bool","counters":[]},{"line":"","counters":[]},{"line":"    (**","counters":[]},{"line":"     * Check that a consensus state was received at a valid time.","counters":[]},{"line":"    *)","counters":[]},{"line":"    val received_at_valid_time :","counters":[]},{"line":"         constants:Constants.t","counters":[]},{"line":"      -> Consensus_state.Value.t","counters":[]},{"line":"      -> time_received:Unix_timestamp.t","counters":[]},{"line":"      -> (unit, [ `Too_early | `Too_late of int64 ]) result","counters":[]},{"line":"","counters":[]},{"line":"    type select_status = [ `Keep | `Take ] [@@deriving equal]","counters":[]},{"line":"","counters":[]},{"line":"    (**","counters":[]},{"line":"     * Select between two ledger builder controller tips given the consensus","counters":[]},{"line":"     * states for the two tips. Returns `\\`Keep` if the first tip should be","counters":[]},{"line":"     * kept, or `\\`Take` if the second tip should be taken instead.","counters":[]},{"line":"    *)","counters":[]},{"line":"    val select :","counters":[]},{"line":"         context:(module CONTEXT)","counters":[]},{"line":"      -> existing:","counters":[]},{"line":"           Consensus_state.Value.t Mina_base.State_hash.With_state_hashes.t","counters":[]},{"line":"      -> candidate:","counters":[]},{"line":"           Consensus_state.Value.t Mina_base.State_hash.With_state_hashes.t","counters":[]},{"line":"      -> select_status","counters":[]},{"line":"","counters":[]},{"line":"    (*Data required to evaluate VRFs for an epoch*)","counters":[]},{"line":"    val get_epoch_data_for_vrf :","counters":[]},{"line":"         constants:Constants.t","counters":[]},{"line":"      -> Unix_timestamp.t","counters":[]},{"line":"      -> Consensus_state.Value.t","counters":[]},{"line":"      -> local_state:Local_state.t","counters":[]},{"line":"      -> logger:Logger.t","counters":[]},{"line":"      -> Data.Epoch_data_for_vrf.t * Local_state.Snapshot.Ledger_snapshot.t","counters":[]},{"line":"","counters":[]},{"line":"    val get_block_data :","counters":[]},{"line":"         slot_won:Slot_won.t","counters":[]},{"line":"      -> ledger_snapshot:Local_state.Snapshot.Ledger_snapshot.t","counters":[]},{"line":"      -> coinbase_receiver:Coinbase_receiver.t","counters":[]},{"line":"      -> Block_data.t","counters":[]},{"line":"","counters":[]},{"line":"    (**","counters":[]},{"line":"     * A hook for managing local state when the locked tip is updated.","counters":[]},{"line":"     *)","counters":[]},{"line":"    val frontier_root_transition :","counters":[]},{"line":"         Consensus_state.Value.t","counters":[]},{"line":"      -> Consensus_state.Value.t","counters":[]},{"line":"      -> local_state:Local_state.t","counters":[]},{"line":"      -> snarked_ledger:Mina_ledger.Ledger.Db.t","counters":[]},{"line":"      -> genesis_ledger_hash:Mina_base.Frozen_ledger_hash.t","counters":[]},{"line":"      -> unit","counters":[]},{"line":"","counters":[]},{"line":"    (**","counters":[]},{"line":"     * Indicator of when we should bootstrap","counters":[]},{"line":"     *)","counters":[]},{"line":"    val should_bootstrap :","counters":[]},{"line":"         context:(module CONTEXT)","counters":[]},{"line":"      -> existing:","counters":[]},{"line":"           Consensus_state.Value.t Mina_base.State_hash.With_state_hashes.t","counters":[]},{"line":"      -> candidate:","counters":[]},{"line":"           Consensus_state.Value.t Mina_base.State_hash.With_state_hashes.t","counters":[]},{"line":"      -> bool","counters":[]},{"line":"","counters":[]},{"line":"    val get_epoch_ledger :","counters":[]},{"line":"         constants:Constants.t","counters":[]},{"line":"      -> consensus_state:Consensus_state.Value.t","counters":[]},{"line":"      -> local_state:Local_state.t","counters":[]},{"line":"      -> Data.Local_state.Snapshot.Ledger_snapshot.t","counters":[]},{"line":"","counters":[]},{"line":"    val epoch_end_time :","counters":[]},{"line":"      constants:Constants.t -> Mina_numbers.Length.t -> Block_time.t","counters":[]},{"line":"","counters":[]},{"line":"    (** Data needed to synchronize the local state. *)","counters":[]},{"line":"    type local_state_sync [@@deriving to_yojson]","counters":[]},{"line":"","counters":[]},{"line":"    (**","counters":[]},{"line":"     * Predicate indicating whether or not the local state requires synchronization.","counters":[]},{"line":"     *)","counters":[]},{"line":"    val required_local_state_sync :","counters":[]},{"line":"         constants:Constants.t","counters":[]},{"line":"      -> consensus_state:Consensus_state.Value.t","counters":[]},{"line":"      -> local_state:Local_state.t","counters":[]},{"line":"      -> local_state_sync option","counters":[]},{"line":"","counters":[]},{"line":"    (**","counters":[]},{"line":"     * Synchronize local state over the network.","counters":[]},{"line":"     *)","counters":[]},{"line":"    val sync_local_state :","counters":[]},{"line":"         context:(module CONTEXT)","counters":[]},{"line":"      -> trust_system:Trust_system.t","counters":[]},{"line":"      -> local_state:Local_state.t","counters":[]},{"line":"      -> random_peers:(int -> Network_peer.Peer.t list Deferred.t)","counters":[]},{"line":"      -> query_peer:Rpcs.query","counters":[]},{"line":"      -> local_state_sync","counters":[]},{"line":"      -> unit Deferred.Or_error.t","counters":[]},{"line":"","counters":[]},{"line":"    module Make_state_hooks","counters":[]},{"line":"        (Blockchain_state : Blockchain_state)","counters":[]},{"line":"        (Protocol_state : Protocol_state","counters":[]},{"line":"                            with type blockchain_state :=","counters":[]},{"line":"                              Blockchain_state.Value.t","counters":[]},{"line":"                             and type blockchain_state_var :=","counters":[]},{"line":"                              Blockchain_state.var","counters":[]},{"line":"                             and type consensus_state := Consensus_state.Value.t","counters":[]},{"line":"                             and type consensus_state_var := Consensus_state.var)","counters":[]},{"line":"        (Snark_transition : Snark_transition","counters":[]},{"line":"                              with type blockchain_state_var :=","counters":[]},{"line":"                                Blockchain_state.var","counters":[]},{"line":"                               and type consensus_transition_var :=","counters":[]},{"line":"                                Consensus_transition.var) :","counters":[]},{"line":"      State_hooks","counters":[]},{"line":"        with type blockchain_state := Blockchain_state.Value.t","counters":[]},{"line":"         and type protocol_state := Protocol_state.Value.t","counters":[]},{"line":"         and type protocol_state_var := Protocol_state.var","counters":[]},{"line":"         and type snark_transition_var := Snark_transition.var","counters":[]},{"line":"         and type consensus_state := Consensus_state.Value.t","counters":[]},{"line":"         and type consensus_state_var := Consensus_state.var","counters":[]},{"line":"         and type consensus_transition := Consensus_transition.Value.t","counters":[]},{"line":"         and type block_data := Block_data.t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Body_reference = Body_reference","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":1}]}]}