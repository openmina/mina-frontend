{"filename":"src/libp2p_ipc/incremental_parsing.ml","lines":[{"line":"open Async","counters":[]},{"line":"open Core","counters":[]},{"line":"open Stdint","counters":[]},{"line":"","counters":[]},{"line":"module Fragment_view = struct","counters":[]},{"line":"  type t = { fragments : bytes list; start_offset : int; end_offset : int }","counters":[]},{"line":"","counters":[]},{"line":"  type ('result, 'state) decode_f =","counters":[]},{"line":"       buf:bytes","counters":[]},{"line":"    -> start:int","counters":[]},{"line":"    -> end_:int","counters":[]},{"line":"    -> 'state","counters":[]},{"line":"    -> [ `Finished of 'result | `Incomplete of 'state ]","counters":[]},{"line":"","counters":[]},{"line":"  type 'result decoder =","counters":[]},{"line":"    | Decoder :","counters":[]},{"line":"        { size : int","counters":[]},{"line":"        ; initial_state : 'state","counters":[]},{"line":"        ; read : ('result, 'state) decode_f","counters":[]},{"line":"        }","counters":[]},{"line":"        -> 'result decoder","counters":[]},{"line":"","counters":[]},{"line":"  let decoder_size (Decoder { size; _ }) = size","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"","counters":[]},{"line":"  let map_decoder (Decoder d) ~f =","counters":[]},{"line":"    let read ~buf ~start ~end_ s =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      match d.read ~buf ~start ~end_ s with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | `Incomplete s' ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          `Incomplete s'","counters":[]},{"line":"      | `Finished x ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          `Finished (f x)","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"    in","counters":[]},{"line":"    Decoder { d with read }","counters":[]},{"line":"","counters":[]},{"line":"  let unsafe_decode (Decoder d) t =","counters":[]},{"line":"    let fail s = failwithf \"Fragment_view.unsafe_decode: %s\" s () in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"    let decode_from_this_fragment ~start ~end_ ~remaining_bytes ~state fragment","counters":[]},{"line":"        =","counters":[]},{"line":"      let finish_expected = end_ - start + 1 >= remaining_bytes in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      match d.read ~buf:fragment ~start ~end_ state with","counters":[]},{"line":"      | `Finished result when finish_expected ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Ok result","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"      | `Finished result ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          fail \"unexpected completion\"","counters":[]},{"line":"      | `Incomplete st when finish_expected ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          fail \"expected completion\"","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"      | `Incomplete st ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Error st","counters":[]},{"line":"    in","counters":[]},{"line":"    let rec decode_from_next_fragment ~start ~remaining_bytes ~state","counters":[]},{"line":"        remaining_fragments =","counters":[]},{"line":"      let fragment, remaining_fragments' =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        match remaining_fragments with","counters":[]},{"line":"        | h :: t ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (h, t)","counters":[]},{"line":"        | [] ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            failwith \"Fragment_view.unsafe_decode: invariant broken\"","counters":[]},{"line":"      in","counters":[]},{"line":"      let is_last_fragment = List.is_empty remaining_fragments' in","counters":[]},{"line":"      let len = Bytes.length fragment in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let end_ = if is_last_fragment then t.end_offset else len - 1 in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":42,"col_end":42,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"      match","counters":[]},{"line":"        decode_from_this_fragment ~start ~end_ ~remaining_bytes ~state fragment","counters":[]},{"line":"      with","counters":[]},{"line":"      | Ok result ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          result","counters":[]},{"line":"      | Error state' ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let remaining_bytes' = remaining_bytes - (end_ - start + 1) in","counters":[]},{"line":"          decode_from_next_fragment ~start:0 ~remaining_bytes:remaining_bytes'","counters":[]},{"line":"            ~state:state' remaining_fragments'","counters":[]},{"line":"    in","counters":[]},{"line":"    decode_from_next_fragment ~start:t.start_offset ~remaining_bytes:d.size","counters":[]},{"line":"      ~state:d.initial_state t.fragments","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Decoders = struct","counters":[]},{"line":"  open Fragment_view","counters":[]},{"line":"","counters":[]},{"line":"  let align (Decoder d) alignment =","counters":[]},{"line":"    let size = alignment * ((d.size + alignment - 1) / alignment) in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Decoder { d with size }","counters":[]},{"line":"","counters":[]},{"line":"  let unit : unit decoder =","counters":[]},{"line":"    Decoder","counters":[]},{"line":"      { size = 0","counters":[]},{"line":"      ; initial_state = ()","counters":[]},{"line":"      ; read = (fun ~buf:_ ~start:_ ~end_:_ () -> `Finished ())","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"  (* unfortunatley requires copying of bytes, which sucks... *)","counters":[]},{"line":"  let bytes size : bytes decoder =","counters":[]},{"line":"    let open struct","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      type state =","counters":[]},{"line":"        { bytes_read : int","counters":[]},{"line":"        ; accumulator : (bytes * [ `Full | `Slice of int * int ]) list","counters":[]},{"line":"        }","counters":[]},{"line":"    end in","counters":[]},{"line":"    let initial_state = { bytes_read = 0; accumulator = [] } in","counters":[]},{"line":"    let extract_result slices =","counters":[]},{"line":"      let result = Bytes.create size in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      assert (","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":13,"col_end":13,"count":0}]},{"line":"        List.fold_right slices ~init:0 ~f:(fun (buf, slice_view) i ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"            let start, len =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              match slice_view with","counters":[]},{"line":"              | `Full ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  (0, Bytes.length buf)","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"              | `Slice (start, end_) ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  (start, end_ - start + 1)","counters":[]},{"line":"            in","counters":[]},{"line":"            Bytes.unsafe_blit ~src:buf ~src_pos:start ~dst:result ~dst_pos:i","counters":[]},{"line":"              ~len ;","counters":[]},{"line":"            i + len )","counters":[]},{"line":"        = size ) ;","counters":[]},{"line":"      result","counters":[]},{"line":"    in","counters":[]},{"line":"    let rec read ~buf ~start ~end_ s =","counters":[]},{"line":"      if s.bytes_read = size then `Finished (extract_result s.accumulator)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"      else","counters":[]},{"line":"        let required = size - s.bytes_read in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let available = end_ - start + 1 in","counters":[]},{"line":"        let slice_size = min required available in","counters":[]},{"line":"        let slice_end = start + slice_size - 1 in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let slice_view =","counters":[]},{"line":"          if start = 0 && slice_end = Bytes.length buf - 1 then `Full","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":49,"col_end":49,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"          else `Slice (start, slice_end)","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"        in","counters":[]},{"line":"        let bytes_read' = s.bytes_read + slice_size in","counters":[]},{"line":"        let accumulator' = (buf, slice_view) :: s.accumulator in","counters":[]},{"line":"        if bytes_read' = size then `Finished (extract_result accumulator')","counters":[{"col_start":35,"col_end":35,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"        else","counters":[]},{"line":"          `Incomplete { bytes_read = bytes_read'; accumulator = accumulator' }","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    in","counters":[]},{"line":"    Decoder { size; initial_state; read }","counters":[]},{"line":"","counters":[]},{"line":"  let uint32 : Uint32.t decoder =","counters":[]},{"line":"    let open struct","counters":[]},{"line":"      type state = { bytes_read : int; accumulator : Uint32.t }","counters":[]},{"line":"    end in","counters":[]},{"line":"    let size = 4 in","counters":[]},{"line":"    let initial_state = { bytes_read = 0; accumulator = Uint32.zero } in","counters":[]},{"line":"    (* read uint32 byte-by-byte for X-fragment solution *)","counters":[]},{"line":"    let rec read_bytes ~buf ~start ~end_ s =","counters":[]},{"line":"      if s.bytes_read = size then `Finished s.accumulator","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"      else","counters":[]},{"line":"        let b = Bytes.unsafe_get buf start |> Char.to_int |> Uint32.of_int in","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"        let s' =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let accumulator =","counters":[]},{"line":"            Uint32.logor s.accumulator (Uint32.shift_left b (8 * s.bytes_read))","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"          in","counters":[]},{"line":"          let bytes_read = s.bytes_read + 1 in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          { bytes_read; accumulator }","counters":[]},{"line":"        in","counters":[]},{"line":"        if start = end_ then `Incomplete s'","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"        else read_bytes ~buf ~start:(start + 1) ~end_ s'","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"    in","counters":[]},{"line":"    let read ~buf ~start ~end_ state =","counters":[]},{"line":"      (* select and optimized solution if possible *)","counters":[]},{"line":"      if state.bytes_read = 0 && start + size - 1 <= end_ then","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"        `Finished (Uint32.of_bytes_little_endian buf start)","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"      else read_bytes ~buf ~start ~end_ state","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"    in","counters":[]},{"line":"    Decoder { size; initial_state; read }","counters":[]},{"line":"","counters":[]},{"line":"  let monomorphic_list (element : 'elt decoder) (count : int) :","counters":[]},{"line":"      'elt list decoder =","counters":[]},{"line":"    let (Decoder","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"          { size = elt_size","counters":[]},{"line":"          ; initial_state = elt_initial_state","counters":[]},{"line":"          ; read = read_elt","counters":[]},{"line":"          } ) =","counters":[]},{"line":"      element","counters":[]},{"line":"    in","counters":[]},{"line":"    let open struct","counters":[]},{"line":"      type ('elt, 'elt_state) state =","counters":[]},{"line":"        { elements_read : int","counters":[]},{"line":"        ; element_state : 'elt_state","counters":[]},{"line":"        ; accumulator : 'elt list","counters":[]},{"line":"        }","counters":[]},{"line":"    end in","counters":[]},{"line":"    let size = elt_size * count in","counters":[]},{"line":"    let rec read ~buf ~start ~end_ s =","counters":[]},{"line":"      match read_elt ~buf ~start ~end_ s.element_state with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | `Incomplete element_state ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          `Incomplete { s with element_state }","counters":[]},{"line":"      | `Finished elt ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let elements_read = s.elements_read + 1 in","counters":[]},{"line":"          let accumulator = elt :: s.accumulator in","counters":[]},{"line":"          if elements_read = count then `Finished (List.rev accumulator)","counters":[{"col_start":40,"col_end":40,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"          else","counters":[]},{"line":"            let start' = start + elt_size in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let state' =","counters":[]},{"line":"              { element_state = elt_initial_state; elements_read; accumulator }","counters":[]},{"line":"            in","counters":[]},{"line":"            if start' <= end_ then","counters":[]},{"line":"              read ~buf ~start:(start + elt_size) ~end_ state'","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"            else `Incomplete state'","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"    in","counters":[]},{"line":"    let initial_state =","counters":[]},{"line":"      { elements_read = 0; element_state = elt_initial_state; accumulator = [] }","counters":[]},{"line":"    in","counters":[]},{"line":"    Decoder { size; initial_state; read }","counters":[]},{"line":"","counters":[]},{"line":"  let polymorphic_list (elements : 'elt decoder list) : 'elt list decoder =","counters":[]},{"line":"    let open struct","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      type 'elt state =","counters":[]},{"line":"        | State :","counters":[]},{"line":"            { current_elt_size : int","counters":[]},{"line":"            ; read_current_elt : ('elt, 'elt_state) decode_f","counters":[]},{"line":"            ; current_elt_state : 'elt_state","counters":[]},{"line":"            ; remaining_elements : 'elt decoder list","counters":[]},{"line":"            ; accumulator : 'elt list","counters":[]},{"line":"            }","counters":[]},{"line":"            -> 'elt state","counters":[]},{"line":"    end in","counters":[]},{"line":"    let advance remaining_elements accumulator =","counters":[]},{"line":"      match remaining_elements with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | [] ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          None","counters":[]},{"line":"      | Decoder","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          { size = current_elt_size","counters":[]},{"line":"          ; initial_state = current_elt_state","counters":[]},{"line":"          ; read = read_current_elt","counters":[]},{"line":"          }","counters":[]},{"line":"        :: remaining_elements ->","counters":[]},{"line":"          Some","counters":[]},{"line":"            (State","counters":[]},{"line":"               { current_elt_size","counters":[]},{"line":"               ; read_current_elt","counters":[]},{"line":"               ; current_elt_state","counters":[]},{"line":"               ; remaining_elements","counters":[]},{"line":"               ; accumulator","counters":[]},{"line":"               } )","counters":[]},{"line":"    in","counters":[]},{"line":"    match advance elements [] with","counters":[]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        map_decoder unit ~f:(Fn.const [])","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"    | Some initial_state ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let size =","counters":[]},{"line":"          List.sum (module Int) elements ~f:(fun (Decoder { size; _ }) -> size)","counters":[{"col_start":74,"col_end":74,"count":0}]},{"line":"        in","counters":[]},{"line":"        let rec read ~buf ~start ~end_ (State s) =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          match s.read_current_elt ~buf ~start ~end_ s.current_elt_state with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | `Incomplete current_elt_state ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              `Incomplete (State { s with current_elt_state })","counters":[]},{"line":"          | `Finished elt -> (","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let accumulator = elt :: s.accumulator in","counters":[]},{"line":"              match advance s.remaining_elements accumulator with","counters":[]},{"line":"              | None ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  `Finished (List.rev accumulator)","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"              | Some s' ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  let start' = start + s.current_elt_size in","counters":[]},{"line":"                  if start' <= end_ then read ~buf ~start:start' ~end_ s'","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"                  else `Incomplete s' )","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"        in","counters":[]},{"line":"        Decoder { size; initial_state; read }","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let%test_module \"decoder tests\" =","counters":[]},{"line":"  ( module struct","counters":[]},{"line":"    open Fragment_view","counters":[]},{"line":"    open Decoders","counters":[]},{"line":"","counters":[]},{"line":"    let gen_bytes ?n () =","counters":[]},{"line":"      let open Quickcheck.Generator.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%bind n =","counters":[]},{"line":"        Option.map n ~f:return |> Option.value ~default:(Int.gen_incl 1 1024)","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"      in","counters":[]},{"line":"      Bytes.gen_with_length n Char.quickcheck_generator","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let gen_slices buf =","counters":[]},{"line":"      let open Quickcheck.Generator.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let rec slice_list ~num_slices ~slice_chance ~start ~index src =","counters":[]},{"line":"        let get () = Bytes.sub src ~pos:start ~len:(index - start + 1) in","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"        let new_slice () =","counters":[]},{"line":"          slice_list ~num_slices:(num_slices - 1) ~slice_chance","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ~start:(index + 1) ~index:(index + 1) src","counters":[]},{"line":"        in","counters":[]},{"line":"        let continue_slice () =","counters":[]},{"line":"          slice_list ~num_slices ~slice_chance ~start ~index:(index + 1) src","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        in","counters":[]},{"line":"        if index >= Bytes.length src - 1 then return [ get () ]","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":46,"col_end":46,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"        else if num_slices >= Bytes.length src - 1 - index then","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"          new_slice () >>| List.cons (get ())","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"        else","counters":[]},{"line":"          let%bind roll = Float.gen_incl 0.0 1.0 in","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"          if Float.(roll <= slice_chance) then","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            new_slice () >>| List.cons (get ())","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"          else continue_slice ()","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"      in","counters":[]},{"line":"      let size = Bytes.length buf in","counters":[]},{"line":"      let%bind num_slices = Int.gen_incl 0 (size - 1) in","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"      let slice_chance =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Float.of_int (size - 1 - num_slices) /. Float.of_int size","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"      in","counters":[]},{"line":"      slice_list ~num_slices ~slice_chance ~start:0 ~index:0 buf","counters":[]},{"line":"","counters":[]},{"line":"    let gen_fragment_view buf =","counters":[]},{"line":"      let open Quickcheck.Generator.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let gen_garbage =","counters":[]},{"line":"        let%bind n = Int.gen_incl 0 255 in","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"        gen_bytes ~n ()","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      in","counters":[]},{"line":"      let add_prefix p ls =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Stdlib.Bytes.cat p (List.hd_exn ls) :: List.tl_exn ls","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"      in","counters":[]},{"line":"      let add_suffix s ls =","counters":[]},{"line":"        List.take ls (List.length ls - 1)","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"        @ [ Stdlib.Bytes.cat (List.last_exn ls) s ]","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"      in","counters":[]},{"line":"      let%bind slices = gen_slices buf in","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"      let%map prefix = gen_garbage and suffix = gen_garbage in","counters":[]},{"line":"      { fragments = slices |> add_prefix prefix |> add_suffix suffix","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"      ; start_offset = Bytes.length prefix","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"      ; end_offset =","counters":[]},{"line":"          ( Bytes.length (List.last_exn slices)","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"          + if List.length slices = 1 then Bytes.length prefix else 0 )","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":43,"col_end":43,"count":0},{"col_start":54,"col_end":54,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    let%test_unit \"bytes decoder\" =","counters":[]},{"line":"      Quickcheck.test","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (Quickcheck.Generator.bind (gen_bytes ()) ~f:gen_fragment_view)","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"        ~f:(fun view ->","counters":[]},{"line":"          let size =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            List.sum (module Int) view.fragments ~f:Bytes.length","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"            - view.start_offset","counters":[]},{"line":"            - (Bytes.length (List.last_exn view.fragments) - view.end_offset)","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"          in","counters":[]},{"line":"          let expected =","counters":[]},{"line":"            view.fragments","counters":[]},{"line":"            |> List.map ~f:Stdlib.Bytes.unsafe_to_string","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"            |> String.concat","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"            |> String.sub ~pos:view.start_offset ~len:size","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"            |> Stdlib.Bytes.unsafe_of_string","counters":[]},{"line":"          in","counters":[]},{"line":"          let result = unsafe_decode (bytes size) view in","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"          [%test_eq: bytes] result expected )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"uint32 decoder\" =","counters":[]},{"line":"      let gen_serialized_uint32 =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"        let%map n = Core.Int64.(gen_incl zero (of_int 2 ** of_int 32)) in","counters":[{"col_start":39,"col_end":39,"count":0},{"col_start":52,"col_end":52,"count":0},{"col_start":57,"col_end":57,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"        let buf = Bytes.create 4 in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Uint32.(to_bytes_little_endian (of_int64 n) buf 0) ;","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"        buf","counters":[]},{"line":"      in","counters":[]},{"line":"      Quickcheck.test","counters":[]},{"line":"        (Quickcheck.Generator.bind gen_serialized_uint32 ~f:gen_fragment_view)","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"        ~f:(fun view ->","counters":[]},{"line":"          let size =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            List.sum (module Int) view.fragments ~f:Bytes.length","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"            - view.start_offset","counters":[]},{"line":"            - (Bytes.length (List.last_exn view.fragments) - view.end_offset)","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"          in","counters":[]},{"line":"          let expected =","counters":[]},{"line":"            view.fragments","counters":[]},{"line":"            |> List.map ~f:Stdlib.Bytes.unsafe_to_string","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"            |> String.concat","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"            |> String.sub ~pos:view.start_offset ~len:size","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"            |> Stdlib.Bytes.unsafe_of_string","counters":[]},{"line":"          in","counters":[]},{"line":"          let result = unsafe_decode (bytes size) view in","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"          [%test_eq: bytes] result expected )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"  end )","counters":[]},{"line":"","counters":[]},{"line":"module Fragment_stream = struct","counters":[]},{"line":"  type t =","counters":[]},{"line":"    { buffered_fragments : bytes Queue.t","counters":[]},{"line":"    ; mutable buffered_size : int","counters":[]},{"line":"    ; mutable first_fragment_offset : int","counters":[]},{"line":"    ; mutable outstanding_read_request : (int * unit Ivar.t) option","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let create () =","counters":[]},{"line":"    { buffered_fragments = Queue.create ()","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"    ; buffered_size = 0","counters":[]},{"line":"    ; first_fragment_offset = 0","counters":[]},{"line":"    ; outstanding_read_request = None","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let add_fragment t fragment =","counters":[]},{"line":"    let len = Bytes.length fragment in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Queue.enqueue t.buffered_fragments fragment ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    t.buffered_size <- t.buffered_size + len ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Option.iter t.outstanding_read_request ~f:(fun (remaining, signal) ->","counters":[]},{"line":"        let remaining' = remaining - len in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        if remaining' <= 0 then (","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"          t.outstanding_read_request <- None ;","counters":[]},{"line":"          Ivar.fill signal () )","counters":[]},{"line":"        else t.outstanding_read_request <- Some (remaining', signal) )","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"  let read_now_exn t amount_to_read =","counters":[]},{"line":"    (* IMPORTANT: maintain tail recursion *)","counters":[]},{"line":"    let rec dequeue_fragments acc amount_read =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let frag = Queue.peek_exn t.buffered_fragments in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let len = Bytes.length frag - t.first_fragment_offset in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"      let delta_read = min len (amount_to_read - amount_read) in","counters":[]},{"line":"      let amount_read' = amount_read + delta_read in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      t.buffered_size <- t.buffered_size - delta_read ;","counters":[]},{"line":"      t.first_fragment_offset <-","counters":[]},{"line":"        ( if delta_read = len then (","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"          ignore (Queue.dequeue_exn t.buffered_fragments : bytes) ;","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"          0 )","counters":[]},{"line":"        else t.first_fragment_offset + delta_read ) ;","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"      let acc' = frag :: acc in","counters":[]},{"line":"      if amount_read' = amount_to_read then acc'","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"      else dequeue_fragments acc' amount_read'","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"    in","counters":[]},{"line":"    assert (t.buffered_size >= amount_to_read) ;","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"    let start_offset = t.first_fragment_offset in","counters":[]},{"line":"    let fragments, last_fragment =","counters":[]},{"line":"      let rev_fragments = dequeue_fragments [] 0 in","counters":[]},{"line":"      (List.rev rev_fragments, List.hd_exn rev_fragments)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":14,"col_end":14,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"    in","counters":[]},{"line":"    let end_offset =","counters":[]},{"line":"      ( if t.first_fragment_offset = 0 then Bytes.length last_fragment","counters":[{"col_start":44,"col_end":44,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"      else t.first_fragment_offset )","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"      - 1","counters":[]},{"line":"    in","counters":[]},{"line":"    { Fragment_view.fragments; start_offset; end_offset }","counters":[]},{"line":"","counters":[]},{"line":"  let read t amount =","counters":[]},{"line":"    assert (Option.is_none t.outstanding_read_request) ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":11,"col_end":11,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"    if t.buffered_size >= amount then return (read_now_exn t amount)","counters":[{"col_start":38,"col_end":38,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"    else","counters":[]},{"line":"      let amount_required = amount - t.buffered_size in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let wait_signal = Ivar.create () in","counters":[]},{"line":"      t.outstanding_read_request <- Some (amount_required, wait_signal) ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%map () = Ivar.read wait_signal in","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"      read_now_exn t amount","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"  let read_and_decode t decoder =","counters":[]},{"line":"    let open Fragment_view in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    read t (decoder_size decoder) >>| unsafe_decode decoder","counters":[{"col_start":7,"col_end":7,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"include Monad.Make (struct","counters":[]},{"line":"  type 'a t = Fragment_stream.t -> 'a Deferred.t","counters":[]},{"line":"","counters":[]},{"line":"  let return x = Fn.const (Deferred.return x)","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"","counters":[]},{"line":"  let map =","counters":[]},{"line":"    `Custom (fun m ~f stream -> Deferred.map (m stream) ~f:(fun x -> f x))","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":46,"col_end":46,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"","counters":[]},{"line":"  let bind m ~f stream = Deferred.bind (m stream) ~f:(fun x -> f x stream)","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"end)","counters":[]},{"line":"","counters":[]},{"line":"let parse decoder stream = Fragment_stream.read_and_decode stream decoder","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":72,"col_end":72,"count":2}]}]}