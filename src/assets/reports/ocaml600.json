{"filename":"src/lib/pickles_base/proofs_verified.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"[@@@warning \"-4\"] (* sexp-related fragile pattern-matching warning *)","counters":[]},{"line":"","counters":[]},{"line":"[%%versioned","counters":[]},{"line":"module Stable = struct","counters":[]},{"line":"  module V1 = struct","counters":[]},{"line":"    type t = Mina_wire_types.Pickles_base.Proofs_verified.V1.t = N0 | N1 | N2","counters":[{"col_start":4,"col_end":4,"count":4},{"col_start":9,"col_end":9,"count":2},{"col_start":65,"col_end":65,"count":1},{"col_start":68,"col_end":68,"count":0},{"col_start":73,"col_end":73,"count":1}]},{"line":"    [@@deriving sexp, compare, yojson, hash, equal]","counters":[{"col_start":50,"col_end":50,"count":5}]},{"line":"","counters":[]},{"line":"    let to_latest = Fn.id","counters":[]},{"line":"  end","counters":[]},{"line":"end]","counters":[]},{"line":"","counters":[]},{"line":"[@@@warning \"+4\"]","counters":[]},{"line":"","counters":[]},{"line":"let to_int : t -> int = function N0 -> 0 | N1 -> 1 | N2 -> 2","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":43,"col_end":43,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"","counters":[]},{"line":"(** Inside the circuit, we use two different representations for this type,","counters":[]},{"line":"    depending on what we need it for.","counters":[]},{"line":"","counters":[]},{"line":"    Sometimes, we use it for masking out a list of 2 points by taking the","counters":[]},{"line":"    a prefix of length 0, 1, or 2. In this setting, we we will represent a value","counters":[]},{"line":"    of this type as a sequence of 2 bits like so:","counters":[]},{"line":"    00: N0","counters":[]},{"line":"    10: N1","counters":[]},{"line":"    11: N2","counters":[]},{"line":"","counters":[]},{"line":"    We call this a **prefix mask**.","counters":[]},{"line":"","counters":[]},{"line":"    Sometimes, we use it to select something from a list of 3 values. In this","counters":[]},{"line":"    case, we will represent a value of this type as a sequence of 3 bits like so:","counters":[]},{"line":"","counters":[]},{"line":"    100: N0","counters":[]},{"line":"    010: N1","counters":[]},{"line":"    001: N2","counters":[]},{"line":"","counters":[]},{"line":"    We call this a **one-hot vector** as elsewhere.","counters":[]},{"line":"*)","counters":[]},{"line":"","counters":[]},{"line":"type proofs_verified = t","counters":[]},{"line":"","counters":[]},{"line":"let of_nat (type n) (n : n Pickles_types.Nat.t) : t =","counters":[]},{"line":"  let open Pickles_types.Nat in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  match n with","counters":[]},{"line":"  | Z ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      N0","counters":[]},{"line":"  | S Z ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      N1","counters":[]},{"line":"  | S (S Z) ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      N2","counters":[]},{"line":"  | S _ ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      failwithf \"Proofs_verified.of_nat: got %d\" (to_int n) ()","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"","counters":[]},{"line":"type 'f boolean = 'f Snarky_backendless.Cvar.t Snarky_backendless.Boolean.t","counters":[]},{"line":"","counters":[]},{"line":"type 'a vec2 = ('a, Pickles_types.Nat.N2.n) Pickles_types.Vector.t","counters":[]},{"line":"","counters":[]},{"line":"module Prefix_mask = struct","counters":[]},{"line":"  module Checked = struct","counters":[]},{"line":"    type 'f t = 'f boolean vec2","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let[@warning \"-40-42\"] there : proofs_verified -> bool vec2 = function","counters":[]},{"line":"    | N0 ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [ false; false ]","counters":[]},{"line":"    | N1 ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [ true; false ]","counters":[]},{"line":"    | N2 ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [ true; true ]","counters":[]},{"line":"","counters":[]},{"line":"  let[@warning \"-40-42\"] back : bool vec2 -> proofs_verified = function","counters":[]},{"line":"    | [ false; false ] ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        N0","counters":[]},{"line":"    | [ true; false ] ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        N1","counters":[]},{"line":"    | [ true; true ] ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        N2","counters":[]},{"line":"    | [ false; true ] ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        invalid_arg \"Prefix_mask.back: invalid mask [false; true]\"","counters":[]},{"line":"","counters":[]},{"line":"  let typ (type f)","counters":[]},{"line":"      (module Impl : Snarky_backendless.Snark_intf.Run with type field = f) :","counters":[]},{"line":"      (f Checked.t, proofs_verified) Impl.Typ.t =","counters":[]},{"line":"    let open Impl in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Typ.transport","counters":[]},{"line":"      (Pickles_types.Vector.typ Boolean.typ Pickles_types.Nat.N2.n)","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"      ~there ~back","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module One_hot = struct","counters":[]},{"line":"  module Checked = struct","counters":[]},{"line":"    type 'f t = ('f, Pickles_types.Nat.N3.n) One_hot_vector.t","counters":[]},{"line":"","counters":[]},{"line":"    let to_input (type f) (t : f t) =","counters":[]},{"line":"      Random_oracle_input.Chunked.packeds","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (Array.map","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"           Pickles_types.(Vector.to_array (t :> (f boolean, Nat.N3.n) Vector.t))","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"           ~f:(fun b -> ((b :> f Snarky_backendless.Cvar.t), 1)) )","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let there : proofs_verified -> int = function N0 -> 0 | N1 -> 1 | N2 -> 2","counters":[{"col_start":48,"col_end":48,"count":0},{"col_start":58,"col_end":58,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"","counters":[]},{"line":"  let back : int -> proofs_verified = function","counters":[]},{"line":"    | 0 ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        N0","counters":[]},{"line":"    | 1 ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        N1","counters":[]},{"line":"    | 2 ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        N2","counters":[]},{"line":"    | _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        failwith \"Invalid mask\"","counters":[]},{"line":"","counters":[]},{"line":"  let to_input ~zero ~one (t : t) =","counters":[]},{"line":"    let one_hot =","counters":[{"col_start":4,"col_end":4,"count":1}]},{"line":"      match t with","counters":[]},{"line":"      | N0 ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          [| one; zero; zero |]","counters":[]},{"line":"      | N1 ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          [| zero; one; zero |]","counters":[]},{"line":"      | N2 ->","counters":[{"col_start":8,"col_end":8,"count":1}]},{"line":"          [| zero; zero; one |]","counters":[]},{"line":"    in","counters":[]},{"line":"    Random_oracle_input.Chunked.packeds (Array.map one_hot ~f:(fun b -> (b, 1)))","counters":[{"col_start":49,"col_end":49,"count":1},{"col_start":72,"col_end":72,"count":3}]},{"line":"","counters":[]},{"line":"  let typ (type f)","counters":[]},{"line":"      (module Impl : Snarky_backendless.Snark_intf.Run with type field = f) :","counters":[]},{"line":"      (f Checked.t, proofs_verified) Impl.Typ.t =","counters":[]},{"line":"    let module M = One_hot_vector.Make (Impl) in","counters":[{"col_start":4,"col_end":4,"count":1}]},{"line":"    let open Impl in","counters":[]},{"line":"    Typ.transport (M.typ Pickles_types.Nat.N3.n) ~there ~back","counters":[{"col_start":23,"col_end":23,"count":1}]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}