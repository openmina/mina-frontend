{"filename":"src/lib/currency/currency.ml","lines":[{"line":"[%%import \"/src/config.mlh\"]","counters":[]},{"line":"","counters":[{"col_start":0,"col_end":0,"count":1}]},{"line":"open Core_kernel","counters":[]},{"line":"open Snark_bits","counters":[]},{"line":"open Snark_params","counters":[]},{"line":"open Tick","counters":[]},{"line":"","counters":[]},{"line":"[%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"open Bitstring_lib","counters":[]},{"line":"open Let_syntax","counters":[]},{"line":"","counters":[]},{"line":"[%%endif]","counters":[]},{"line":"","counters":[]},{"line":"open Intf","counters":[]},{"line":"","counters":[]},{"line":"type uint64 = Unsigned.uint64","counters":[]},{"line":"","counters":[]},{"line":"(** See documentation of the {!Mina_wire_types} library *)","counters":[]},{"line":"module Wire_types = Mina_wire_types.Currency","counters":[]},{"line":"","counters":[]},{"line":"(** Define the expected full signature of the module, based on the types defined","counters":[]},{"line":"    in {!Mina_wire_types} *)","counters":[]},{"line":"module Make_sig (A : Wire_types.Types.S) = struct","counters":[]},{"line":"  module type S =","counters":[]},{"line":"    Intf.Full","counters":[]},{"line":"    (* full interface defined in a separate file, as it would appear","counters":[]},{"line":"       in the MLI *)","counters":[]},{"line":"      with type Fee.Stable.V1.t = A.Fee.V1.t","counters":[]},{"line":"      (* with added type equalities *)","counters":[]},{"line":"       and type Amount.Stable.V1.t = A.Amount.V1.t","counters":[]},{"line":"       and type Balance.Stable.V1.t = A.Balance.V1.t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(** Then we make the real module, which has to have a signature of type","counters":[]},{"line":"    {!Make_sig(A)}. Here, since all types are simple type aliases, we don't need","counters":[]},{"line":"    to use [A] in the implementation. Otherwise, we would need to add type","counters":[]},{"line":"    equalities to the corresponding type in [A] in each type definition. *)","counters":[]},{"line":"module Make_str (A : Wire_types.Concrete) = struct","counters":[]},{"line":"  module Signed_poly = Signed_poly","counters":[]},{"line":"","counters":[]},{"line":"  [%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"  module Signed_var = struct","counters":[]},{"line":"    type 'mag repr = ('mag, Sgn.var) Signed_poly.t","counters":[]},{"line":"","counters":[]},{"line":"    (* Invariant: At least one of these is Some *)","counters":[]},{"line":"    type nonrec 'mag t =","counters":[]},{"line":"      { repr : 'mag repr; mutable value : Field.Var.t option }","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  [%%endif]","counters":[]},{"line":"","counters":[]},{"line":"  module Make (Unsigned : sig","counters":[]},{"line":"    include Unsigned_extended.S","counters":[]},{"line":"","counters":[]},{"line":"    val to_uint64 : t -> uint64","counters":[]},{"line":"","counters":[]},{"line":"    val of_uint64 : uint64 -> t","counters":[]},{"line":"  end) (M : sig","counters":[]},{"line":"    val length : int","counters":[]},{"line":"  end) : sig","counters":[]},{"line":"    [%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"    include","counters":[]},{"line":"      S","counters":[]},{"line":"        with type t = Unsigned.t","counters":[]},{"line":"         and type var = Field.Var.t","counters":[]},{"line":"         and type Signed.var = Field.Var.t Signed_var.t","counters":[]},{"line":"         and type Signed.signed_fee = (Unsigned.t, Sgn.t) Signed_poly.t","counters":[]},{"line":"         and type Signed.Checked.signed_fee_var = Field.Var.t Signed_var.t","counters":[]},{"line":"","counters":[]},{"line":"    val pack_var : var -> Field.Var.t","counters":[]},{"line":"","counters":[]},{"line":"    [%%else]","counters":[]},{"line":"","counters":[]},{"line":"    include","counters":[]},{"line":"      S","counters":[]},{"line":"        with type t = Unsigned.t","counters":[]},{"line":"         and type Signed.signed_fee := (Unsigned.t, Sgn.t) Signed_poly.t","counters":[]},{"line":"","counters":[]},{"line":"    [%%endif]","counters":[]},{"line":"","counters":[]},{"line":"    val scale : t -> int -> t option","counters":[]},{"line":"  end = struct","counters":[]},{"line":"    let max_int = Unsigned.max_int","counters":[]},{"line":"","counters":[]},{"line":"    let length_in_bits = M.length","counters":[]},{"line":"","counters":[]},{"line":"    type t = Unsigned.t [@@deriving sexp, compare, hash]","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"    (* can't be automatically derived *)","counters":[]},{"line":"    let dhall_type = Ppx_dhall_type.Dhall_type.Text","counters":[]},{"line":"","counters":[]},{"line":"    [%%define_locally","counters":[]},{"line":"    Unsigned.(to_uint64, of_uint64, of_int, to_int, of_string, to_string)]","counters":[]},{"line":"","counters":[]},{"line":"    let precision = 9","counters":[]},{"line":"","counters":[]},{"line":"    let precision_exp = Unsigned.of_int @@ Int.pow 10 precision","counters":[{"col_start":38,"col_end":38,"count":2},{"col_start":49,"col_end":49,"count":2}]},{"line":"","counters":[]},{"line":"    let to_formatted_string amount =","counters":[]},{"line":"      let rec go num_stripped_zeros num =","counters":[{"col_start":6,"col_end":6,"count":4}]},{"line":"        let open Int in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        if num mod 10 = 0 && num <> 0 then go (num_stripped_zeros + 1) (num / 10)","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"        else (num_stripped_zeros, num)","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"      in","counters":[]},{"line":"","counters":[]},{"line":"      let whole = Unsigned.div amount precision_exp in","counters":[]},{"line":"      let remainder = Unsigned.to_int (Unsigned.rem amount precision_exp) in","counters":[{"col_start":6,"col_end":6,"count":4},{"col_start":50,"col_end":50,"count":4}]},{"line":"      if Int.(remainder = 0) then to_string whole","counters":[{"col_start":6,"col_end":6,"count":4},{"col_start":34,"col_end":34,"count":4}]},{"line":"      else","counters":[]},{"line":"        let num_stripped_zeros, num = go 0 remainder in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Printf.sprintf \"%s.%0*d\" (to_string whole)","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"          Int.(precision - num_stripped_zeros)","counters":[]},{"line":"          num","counters":[]},{"line":"","counters":[]},{"line":"    let of_formatted_string input =","counters":[]},{"line":"      let parts = String.split ~on:'.' input in","counters":[{"col_start":6,"col_end":6,"count":23}]},{"line":"      match parts with","counters":[{"col_start":6,"col_end":6,"count":23}]},{"line":"      | [ whole ] ->","counters":[{"col_start":8,"col_end":8,"count":22}]},{"line":"          of_string (whole ^ String.make precision '0')","counters":[{"col_start":39,"col_end":39,"count":22}]},{"line":"      | [ whole; decimal ] ->","counters":[{"col_start":8,"col_end":8,"count":1}]},{"line":"          let decimal_length = String.length decimal in","counters":[]},{"line":"          if Int.(decimal_length > precision) then","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"            of_string (whole ^ String.sub decimal ~pos:0 ~len:precision)","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"          else","counters":[]},{"line":"            of_string","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"              ( whole ^ decimal","counters":[]},{"line":"              ^ String.make Int.(precision - decimal_length) '0' )","counters":[{"col_start":26,"col_end":26,"count":1}]},{"line":"      | _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          failwith \"Currency.of_formatted_string: Invalid currency input\"","counters":[]},{"line":"","counters":[]},{"line":"    module Arg = struct","counters":[]},{"line":"      type typ = t [@@deriving sexp, hash, compare]","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"      type t = typ [@@deriving sexp, hash, compare]","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"      let to_string = to_formatted_string","counters":[]},{"line":"","counters":[]},{"line":"      let of_string = of_formatted_string","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    include Codable.Make_of_string (Arg)","counters":[]},{"line":"    include Hashable.Make (Arg)","counters":[]},{"line":"    include Comparable.Make (Arg)","counters":[]},{"line":"","counters":[]},{"line":"    let gen_incl a b : t Quickcheck.Generator.t =","counters":[]},{"line":"      let a = Bignum_bigint.of_string Unsigned.(to_string a) in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"      let b = Bignum_bigint.of_string Unsigned.(to_string b) in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"      Quickcheck.Generator.map","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Bignum_bigint.(gen_incl a b)","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"        ~f:(fun n -> of_string (Bignum_bigint.to_string n))","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"","counters":[]},{"line":"    let gen : t Quickcheck.Generator.t =","counters":[]},{"line":"      let m = Bignum_bigint.of_string Unsigned.(to_string max_int) in","counters":[{"col_start":56,"col_end":56,"count":2}]},{"line":"      Quickcheck.Generator.map","counters":[{"col_start":6,"col_end":6,"count":2},{"col_start":29,"col_end":29,"count":2}]},{"line":"        Bignum_bigint.(gen_incl zero m)","counters":[{"col_start":30,"col_end":30,"count":2}]},{"line":"        ~f:(fun n -> of_string (Bignum_bigint.to_string n))","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"","counters":[]},{"line":"    module Vector = struct","counters":[]},{"line":"      include M","counters":[]},{"line":"      include Unsigned","counters":[]},{"line":"","counters":[]},{"line":"      let empty = zero","counters":[]},{"line":"","counters":[]},{"line":"      let get t i = Infix.((t lsr i) land one = one)","counters":[{"col_start":20,"col_end":20,"count":2880}]},{"line":"","counters":[]},{"line":"      let set v i b =","counters":[]},{"line":"        if b then Infix.(v lor (one lsl i))","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"        else Infix.(v land lognot (one lsl i))","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module B = Bits.Vector.Make (Vector)","counters":[]},{"line":"","counters":[]},{"line":"    include (B : Bits_intf.Convertible_bits with type t := t)","counters":[]},{"line":"","counters":[]},{"line":"    [%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"    type var = Field.Var.t","counters":[]},{"line":"","counters":[]},{"line":"    let pack_var = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"    let equal_var = Field.Checked.equal","counters":[]},{"line":"","counters":[]},{"line":"    let m = Snark_params.Tick.m","counters":[]},{"line":"","counters":[]},{"line":"    let make_checked = Snark_params.Tick.make_checked","counters":[]},{"line":"","counters":[]},{"line":"    let var_to_bits_ (t : var) = Field.Checked.unpack ~length:length_in_bits t","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"","counters":[]},{"line":"    let var_to_bits t = var_to_bits_ t >>| Bitstring.Lsb_first.of_list","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"    let var_to_input (t : var) =","counters":[]},{"line":"      Random_oracle.Input.Chunked.packed (t, length_in_bits)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let var_to_input_legacy (t : var) =","counters":[]},{"line":"      var_to_bits_ t >>| Random_oracle.Input.Legacy.bitstring","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"","counters":[]},{"line":"    let var_of_t (t : t) : var = Field.Var.constant (Field.project (to_bits t))","counters":[{"col_start":33,"col_end":33,"count":4},{"col_start":65,"col_end":65,"count":4},{"col_start":74,"col_end":74,"count":4}]},{"line":"","counters":[]},{"line":"    let if_ cond ~then_ ~else_ : var Checked.t =","counters":[]},{"line":"      Field.Checked.if_ cond ~then_ ~else_","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let () = assert (Int.(length_in_bits mod 16 = 0))","counters":[{"col_start":20,"col_end":20,"count":2}]},{"line":"","counters":[]},{"line":"    (** UNSAFE. Take the field element formed by the final [length_in_bits] bits","counters":[]},{"line":"        of the argument.","counters":[]},{"line":"","counters":[]},{"line":"        WARNING: The returned value may be chosen arbitrarily by a malicious","counters":[]},{"line":"        prover, and this is really only useful for the more-efficient bit","counters":[]},{"line":"        projection. Users of this function must manually assert the relationship","counters":[]},{"line":"        between the argument and the return value, or the circuit will be","counters":[]},{"line":"        underconstrained.","counters":[]},{"line":"    *)","counters":[]},{"line":"    let image_from_bits_unsafe (t : var) =","counters":[]},{"line":"      make_checked (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          let _, _, actual_packed =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Pickles.Scalar_challenge.to_field_checked' ~num_bits:length_in_bits","counters":[]},{"line":"              m","counters":[]},{"line":"              (Kimchi_backend_common.Scalar_challenge.create t)","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"          in","counters":[]},{"line":"          actual_packed )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"    (** [range_check t] asserts that [0 <= t < 2^length_in_bits].","counters":[]},{"line":"","counters":[]},{"line":"        Any value consumed or returned by functions in this module must satisfy","counters":[]},{"line":"        this assertion.","counters":[]},{"line":"    *)","counters":[]},{"line":"    let range_check t =","counters":[]},{"line":"      let%bind actual = image_from_bits_unsafe t in","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"      with_label \"range_check\" (fun () -> Field.Checked.Assert.equal actual t)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"","counters":[]},{"line":"    let seal x = make_checked (fun () -> Pickles.Util.seal Tick.m x)","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"","counters":[]},{"line":"    let modulus_as_field =","counters":[]},{"line":"      lazy (Fn.apply_n_times ~n:length_in_bits Field.(mul (of_int 2)) Field.one)","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":56,"col_end":56,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"","counters":[]},{"line":"    let double_modulus_as_field =","counters":[]},{"line":"      lazy (Field.(mul (of_int 2)) (Lazy.force modulus_as_field))","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"","counters":[]},{"line":"    (** [range_check_flagged kind t] returns [t'] that fits in [length_in_bits]","counters":[]},{"line":"        bits, and satisfies [t' = t + k * 2^length_in_bits] for some [k].","counters":[]},{"line":"        The [`Overflow b] return value is false iff [t' = t].","counters":[]},{"line":"","counters":[]},{"line":"        This function should be used when [t] was computed via addition or","counters":[]},{"line":"        subtraction, to calculate the equivalent value that would be returned by","counters":[]},{"line":"        overflowing or underflowing an integer with [length_in_bits] bits.","counters":[]},{"line":"","counters":[]},{"line":"        The [`Add] and [`Sub] values for [kind] are specializations that use","counters":[]},{"line":"        fewer constraints and perform fewer calculations. Any inputs that satisfy","counters":[]},{"line":"        the invariants for [`Add] or [`Sub] will return the same value if","counters":[]},{"line":"        [`Add_or_sub] is used instead.","counters":[]},{"line":"","counters":[]},{"line":"        Invariants:","counters":[]},{"line":"        * if [kind] is [`Add], [0 <= t < 2 * 2^length_in_bits - 1];","counters":[]},{"line":"        * if [kind] is [`Sub], [- 2^length_in_bits < t < 2^length_in_bits];","counters":[]},{"line":"        * if [kind] is [`Add_or_sub],","counters":[]},{"line":"          [- 2^length_in_bits < t < 2 * 2^length_in_bits - 1].","counters":[]},{"line":"    *)","counters":[]},{"line":"    let range_check_flagged (kind : [ `Add | `Sub | `Add_or_sub ]) t =","counters":[]},{"line":"      let%bind adjustment_factor =","counters":[]},{"line":"        exists Field.typ","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"          ~compute:","counters":[]},{"line":"            As_prover.(","counters":[]},{"line":"              let%map t = read Field.typ t in","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"              match kind with","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              | `Add ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  if Int.(Field.compare t (Lazy.force modulus_as_field) < 0)","counters":[{"col_start":38,"col_end":38,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"                  then (* Within range. *)","counters":[]},{"line":"                    Field.zero","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                  else","counters":[]},{"line":"                    (* Overflowed. We compensate by subtracting [modulus_as_field]. *)","counters":[]},{"line":"                    Field.(negate one)","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"              | `Sub ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  if Int.(Field.compare t (Lazy.force modulus_as_field) < 0)","counters":[{"col_start":38,"col_end":38,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"                  then (* Within range. *)","counters":[]},{"line":"                    Field.zero","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                  else","counters":[]},{"line":"                    (* Underflowed, but appears as an overflow because of wrapping in","counters":[]},{"line":"                       the field (that is, -1 is the largest field element, -2 is the","counters":[]},{"line":"                       second largest, etc.). Compensate by adding [modulus_as_field].","counters":[]},{"line":"                    *)","counters":[]},{"line":"                    Field.one","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"              | `Add_or_sub ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  (* This case is a little more nuanced: -modulus_as_field < t <","counters":[]},{"line":"                     2*modulus_as_field, and we need to detect which 'side of 0' we","counters":[]},{"line":"                     are. Thus, we have 3 cases:","counters":[]},{"line":"                  *)","counters":[]},{"line":"                  if Int.(Field.compare t (Lazy.force modulus_as_field) < 0)","counters":[{"col_start":38,"col_end":38,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"                  then","counters":[]},{"line":"                    (* 1. we are already in the desired range, no adjustment; *)","counters":[]},{"line":"                    Field.zero","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                  else if","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                    Int.(","counters":[]},{"line":"                      Field.compare t (Lazy.force double_modulus_as_field) < 0)","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"                  then","counters":[]},{"line":"                    (* 2. we are in the range","counters":[]},{"line":"                          [modulus_as_field <= t < 2 * modulus_as_field],","counters":[]},{"line":"                          so this was an addition that overflowed, and we should","counters":[]},{"line":"                          compensate by subtracting [modulus_as_field];","counters":[]},{"line":"                    *)","counters":[]},{"line":"                    Field.(negate one)","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                  else","counters":[]},{"line":"                    (* 3. we are outside of either range, so this must be the","counters":[]},{"line":"                          underflow of a subtraction, and we should compensate by","counters":[]},{"line":"                          adding [modulus_as_field].","counters":[]},{"line":"                    *)","counters":[]},{"line":"                    Field.one)","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"      in","counters":[]},{"line":"      let%bind out_of_range =","counters":[]},{"line":"        match kind with","counters":[]},{"line":"        | `Add ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (* 0 or -1 => 0 or 1 *)","counters":[]},{"line":"            Boolean.of_field (Field.Var.negate adjustment_factor)","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"        | `Sub ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (* Already 0 or 1 *)","counters":[]},{"line":"            Boolean.of_field adjustment_factor","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"        | `Add_or_sub ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (* The return flag [out_of_range] is a boolean represented by either 0","counters":[]},{"line":"               when [t] is in range or 1 when [t] is out-of-range.","counters":[]},{"line":"               Notice that [out_of_range = adjustment_factor^2] gives us exactly","counters":[]},{"line":"               the desired values, and moreover we can ensure that","counters":[]},{"line":"               [adjustment_factor] is exactly one of -1, 0 or 1 by checking that","counters":[]},{"line":"               [out_of_range] is boolean.","counters":[]},{"line":"            *)","counters":[]},{"line":"            Field.Checked.mul adjustment_factor adjustment_factor","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"            >>= Boolean.of_field","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"      in","counters":[]},{"line":"      (* [t_adjusted = t + adjustment_factor * modulus_as_field] *)","counters":[]},{"line":"      let t_adjusted =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let open Field.Var in","counters":[]},{"line":"        add t (scale adjustment_factor (Lazy.force modulus_as_field))","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"      in","counters":[]},{"line":"      let%bind t_adjusted = seal t_adjusted in","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"      let%map () = range_check t_adjusted in","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"      (t_adjusted, `Overflow out_of_range)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let of_field (x : Field.t) : t =","counters":[]},{"line":"      of_bits (List.take (Field.unpack x) length_in_bits)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"    let to_field (x : t) : Field.t = Field.project (to_bits x)","counters":[{"col_start":37,"col_end":37,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"","counters":[]},{"line":"    let typ : (var, t) Typ.t =","counters":[]},{"line":"      let (Typ typ) = Field.typ in","counters":[]},{"line":"      Typ.transport","counters":[{"col_start":18,"col_end":18,"count":2}]},{"line":"        (Typ { typ with check = (fun x -> make_checked_ast @@ range_check x) })","counters":[{"col_start":42,"col_end":42,"count":0},{"col_start":72,"col_end":72,"count":0}]},{"line":"        ~there:to_field ~back:of_field","counters":[]},{"line":"","counters":[]},{"line":"    [%%endif]","counters":[]},{"line":"","counters":[]},{"line":"    let zero = Unsigned.zero","counters":[]},{"line":"","counters":[]},{"line":"    let one = Unsigned.one","counters":[]},{"line":"","counters":[]},{"line":"    let sub x y = if x < y then None else Some (Unsigned.sub x y)","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":42,"col_end":42,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"","counters":[]},{"line":"    let sub_flagged x y =","counters":[]},{"line":"      let z = Unsigned.sub x y in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      (z, `Underflow (x < y))","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let add x y =","counters":[]},{"line":"      let z = Unsigned.add x y in","counters":[{"col_start":6,"col_end":6,"count":216}]},{"line":"      if z < x then None else Some z","counters":[{"col_start":6,"col_end":6,"count":216},{"col_start":20,"col_end":20,"count":0},{"col_start":30,"col_end":30,"count":216}]},{"line":"","counters":[]},{"line":"    let add_flagged x y =","counters":[]},{"line":"      let z = Unsigned.add x y in","counters":[{"col_start":6,"col_end":6,"count":2}]},{"line":"      (z, `Overflow (z < x))","counters":[{"col_start":6,"col_end":6,"count":2}]},{"line":"","counters":[]},{"line":"    let add_signed_flagged x y =","counters":[]},{"line":"      match y.Signed_poly.sgn with","counters":[{"col_start":6,"col_end":6,"count":2}]},{"line":"      | Sgn.Pos ->","counters":[{"col_start":8,"col_end":8,"count":2}]},{"line":"          let z, `Overflow b = add_flagged x y.Signed_poly.magnitude in","counters":[]},{"line":"          (z, `Overflow b)","counters":[{"col_start":10,"col_end":10,"count":2}]},{"line":"      | Sgn.Neg ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let z, `Underflow b = sub_flagged x y.Signed_poly.magnitude in","counters":[]},{"line":"          (z, `Overflow b)","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"    let scale u64 i =","counters":[]},{"line":"      let i = Unsigned.of_int i in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let max_val = Unsigned.(div max_int i) in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"      if max_val >= u64 then Some (Unsigned.mul u64 i) else None","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":46,"col_end":46,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"","counters":[]},{"line":"    let ( + ) = add","counters":[]},{"line":"","counters":[]},{"line":"    let ( - ) = sub","counters":[]},{"line":"","counters":[]},{"line":"    type magnitude = t [@@deriving sexp, hash, compare, yojson]","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"","counters":[]},{"line":"    let to_input (t : t) =","counters":[]},{"line":"      Random_oracle.Input.Chunked.packed","counters":[{"col_start":6,"col_end":6,"count":41}]},{"line":"        (Field.project (to_bits t), length_in_bits)","counters":[{"col_start":21,"col_end":21,"count":41},{"col_start":30,"col_end":30,"count":41}]},{"line":"","counters":[]},{"line":"    let to_input_legacy t = Random_oracle.Input.Legacy.bitstring @@ to_bits t","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":74,"col_end":74,"count":0}]},{"line":"","counters":[]},{"line":"    module Signed = struct","counters":[]},{"line":"      type ('magnitude, 'sgn) typ = ('magnitude, 'sgn) Signed_poly.t =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { magnitude : 'magnitude; sgn : 'sgn }","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"      [@@deriving sexp, hash, compare, yojson, hlist]","counters":[]},{"line":"","counters":[]},{"line":"      type t = (Unsigned.t, Sgn.t) Signed_poly.t [@@deriving sexp, hash, yojson]","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":79,"col_end":79,"count":0}]},{"line":"","counters":[]},{"line":"      let compare : t -> t -> int =","counters":[]},{"line":"        let cmp = [%compare: (Unsigned.t, Sgn.t) Signed_poly.t] in","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":42,"col_end":42,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"        fun t1 t2 ->","counters":[]},{"line":"          if Unsigned.(equal t1.magnitude zero && equal t2.magnitude zero) then","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":50,"col_end":50,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"            0","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          else cmp t1 t2","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"","counters":[]},{"line":"      let equal : t -> t -> bool =","counters":[]},{"line":"        let eq = [%equal: (Unsigned.t, Sgn.t) Signed_poly.t] in","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"        fun t1 t2 ->","counters":[]},{"line":"          if Unsigned.(equal t1.magnitude zero && equal t2.magnitude zero) then","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":50,"col_end":50,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"            true","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          else eq t1 t2","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"","counters":[]},{"line":"      let is_zero (t : t) : bool = Unsigned.(equal t.magnitude zero)","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"      let is_positive (t : t) : bool =","counters":[]},{"line":"        match t.sgn with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | Pos ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            not Unsigned.(equal zero t.magnitude)","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"        | Neg ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            false","counters":[]},{"line":"","counters":[]},{"line":"      let is_negative (t : t) : bool =","counters":[]},{"line":"        match t.sgn with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | Neg ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            not Unsigned.(equal zero t.magnitude)","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"        | Pos ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            false","counters":[]},{"line":"","counters":[]},{"line":"      type magnitude = Unsigned.t [@@deriving sexp, compare]","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"      let create ~magnitude ~sgn = { magnitude; sgn }","counters":[{"col_start":35,"col_end":35,"count":4}]},{"line":"","counters":[]},{"line":"      let sgn { sgn; _ } = sgn","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"","counters":[]},{"line":"      let magnitude { magnitude; _ } = magnitude","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"      let zero : t = create ~magnitude:zero ~sgn:Sgn.Pos","counters":[]},{"line":"","counters":[]},{"line":"      let gen =","counters":[]},{"line":"        Quickcheck.Generator.map2 gen Sgn.gen ~f:(fun magnitude sgn ->","counters":[{"col_start":32,"col_end":32,"count":2}]},{"line":"            if Unsigned.(equal zero magnitude) then zero","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"            else create ~magnitude ~sgn )","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"","counters":[]},{"line":"      let sgn_to_bool = function Sgn.Pos -> true | Neg -> false","counters":[{"col_start":33,"col_end":33,"count":11},{"col_start":51,"col_end":51,"count":0}]},{"line":"","counters":[]},{"line":"      let to_bits ({ sgn; magnitude } : t) =","counters":[]},{"line":"        sgn_to_bool sgn :: to_bits magnitude","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"","counters":[]},{"line":"      let to_input { sgn; magnitude } =","counters":[]},{"line":"        Random_oracle.Input.Chunked.(","counters":[{"col_start":8,"col_end":8,"count":11}]},{"line":"          append (to_input magnitude)","counters":[{"col_start":25,"col_end":25,"count":11}]},{"line":"            (packed (Field.project [ sgn_to_bool sgn ], 1)))","counters":[{"col_start":18,"col_end":18,"count":11},{"col_start":33,"col_end":33,"count":11},{"col_start":47,"col_end":47,"count":11}]},{"line":"","counters":[]},{"line":"      let to_input_legacy t = Random_oracle.Input.Legacy.bitstring (to_bits t)","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":74,"col_end":74,"count":0}]},{"line":"","counters":[]},{"line":"      let add (x : t) (y : t) : t option =","counters":[]},{"line":"        match (x.sgn, y.sgn) with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | Neg, (Neg as sgn) | Pos, (Pos as sgn) ->","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"            let open Option.Let_syntax in","counters":[]},{"line":"            let%map magnitude = add x.magnitude y.magnitude in","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"            create ~sgn ~magnitude","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"        | Pos, Neg | Neg, Pos ->","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"            let c = compare_magnitude x.magnitude y.magnitude in","counters":[]},{"line":"            Some","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              ( if Int.( < ) c 0 then","counters":[]},{"line":"                create ~sgn:y.sgn","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  ~magnitude:Unsigned.Infix.(y.magnitude - x.magnitude)","counters":[]},{"line":"              else if Int.( > ) c 0 then","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"                create ~sgn:x.sgn","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  ~magnitude:Unsigned.Infix.(x.magnitude - y.magnitude)","counters":[]},{"line":"              else zero )","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"","counters":[]},{"line":"      let add_flagged (x : t) (y : t) : t * [ `Overflow of bool ] =","counters":[]},{"line":"        match (x.sgn, y.sgn) with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | Neg, (Neg as sgn) | Pos, (Pos as sgn) ->","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"            let magnitude, `Overflow b = add_flagged x.magnitude y.magnitude in","counters":[]},{"line":"            (create ~sgn ~magnitude, `Overflow b)","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"        | Pos, Neg | Neg, Pos ->","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"            let c = compare_magnitude x.magnitude y.magnitude in","counters":[]},{"line":"            ( ( if Int.( < ) c 0 then","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"                create ~sgn:y.sgn","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  ~magnitude:Unsigned.Infix.(y.magnitude - x.magnitude)","counters":[]},{"line":"              else if Int.( > ) c 0 then","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"                create ~sgn:x.sgn","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  ~magnitude:Unsigned.Infix.(x.magnitude - y.magnitude)","counters":[]},{"line":"              else zero )","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"            , `Overflow false )","counters":[]},{"line":"","counters":[]},{"line":"      let negate t =","counters":[]},{"line":"        if Unsigned.(equal zero t.magnitude) then zero","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"        else { t with sgn = Sgn.negate t.sgn }","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"      let of_unsigned magnitude : t = create ~magnitude ~sgn:Sgn.Pos","counters":[{"col_start":38,"col_end":38,"count":2}]},{"line":"","counters":[]},{"line":"      let ( + ) = add","counters":[]},{"line":"","counters":[]},{"line":"      let to_fee = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"      let of_fee = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"      [%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"      type signed_fee = t","counters":[]},{"line":"","counters":[]},{"line":"      let magnitude_to_field = to_field","counters":[]},{"line":"","counters":[]},{"line":"      let to_field (t : t) : Field.t =","counters":[]},{"line":"        Field.mul (Sgn.to_field t.sgn) (magnitude_to_field t.magnitude)","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"","counters":[]},{"line":"      type repr = var Signed_var.repr","counters":[]},{"line":"","counters":[]},{"line":"      type nonrec var = var Signed_var.t","counters":[]},{"line":"","counters":[]},{"line":"      let repr_typ : (repr, t) Typ.t =","counters":[]},{"line":"        Typ.of_hlistable [ typ; Sgn.typ ] ~var_to_hlist:typ_to_hlist","counters":[{"col_start":23,"col_end":23,"count":2}]},{"line":"          ~var_of_hlist:typ_of_hlist ~value_to_hlist:typ_to_hlist","counters":[]},{"line":"          ~value_of_hlist:typ_of_hlist","counters":[]},{"line":"","counters":[]},{"line":"      let typ : (var, t) Typ.t =","counters":[]},{"line":"        Typ.transport_var repr_typ","counters":[{"col_start":24,"col_end":24,"count":2}]},{"line":"          ~back:(fun repr -> { Signed_var.value = None; repr })","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"          ~there:(fun { Signed_var.repr; _ } -> repr)","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"","counters":[]},{"line":"      let create_var ~magnitude ~sgn : var =","counters":[]},{"line":"        { repr = { magnitude; sgn }; value = None }","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      module Checked = struct","counters":[]},{"line":"        type t = var","counters":[]},{"line":"","counters":[]},{"line":"        type signed_fee_var = t","counters":[]},{"line":"","counters":[]},{"line":"        let repr (t : var) = Checked.return t.repr","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"        let value (t : var) =","counters":[]},{"line":"          match t.value with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | Some x ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Checked.return x","counters":[]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let r = t.repr in","counters":[]},{"line":"              let%map x =","counters":[]},{"line":"                Field.Checked.mul (r.sgn :> Field.Var.t) r.magnitude","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"              in","counters":[]},{"line":"              t.value <- Some x ;","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              x","counters":[]},{"line":"","counters":[]},{"line":"        let to_field_var = value","counters":[]},{"line":"","counters":[]},{"line":"        let to_input t =","counters":[]},{"line":"          let%map { magnitude; sgn } = repr t in","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"          let mag = var_to_input magnitude in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          Random_oracle.Input.Chunked.(","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            append mag (packed ((Sgn.Checked.is_pos sgn :> Field.Var.t), 1)))","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"","counters":[]},{"line":"        let to_input_legacy t =","counters":[]},{"line":"          let to_bits { magnitude; sgn } =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let%map magnitude = var_to_bits_ magnitude in","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"            Sgn.Checked.is_pos sgn :: magnitude","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"          in","counters":[]},{"line":"          repr t >>= to_bits >>| Random_oracle.Input.Legacy.bitstring","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"","counters":[]},{"line":"        let constant ({ magnitude; sgn } as t) =","counters":[]},{"line":"          { Signed_var.repr =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              { magnitude = var_of_t magnitude; sgn = Sgn.Checked.constant sgn }","counters":[{"col_start":35,"col_end":35,"count":0},{"col_start":73,"col_end":73,"count":0}]},{"line":"          ; value = Some (Field.Var.constant (to_field t))","counters":[{"col_start":43,"col_end":43,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"          }","counters":[]},{"line":"","counters":[]},{"line":"        let of_unsigned magnitude : var =","counters":[]},{"line":"          { repr = { magnitude; sgn = Sgn.Checked.pos }","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          ; value = Some magnitude","counters":[]},{"line":"          }","counters":[]},{"line":"","counters":[]},{"line":"        let negate (t : var) : var =","counters":[]},{"line":"          { value = Option.map t.value ~f:Field.Var.negate","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"          ; repr =","counters":[]},{"line":"              (let { magnitude; sgn } = t.repr in","counters":[]},{"line":"               { magnitude; sgn = Sgn.Checked.negate sgn } )","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"          }","counters":[]},{"line":"","counters":[]},{"line":"        let if_repr cond ~then_ ~else_ =","counters":[]},{"line":"          let%map sgn = Sgn.Checked.if_ cond ~then_:then_.sgn ~else_:else_.sgn","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"          and magnitude =","counters":[]},{"line":"            if_ cond ~then_:then_.magnitude ~else_:else_.magnitude","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"          in","counters":[]},{"line":"          { sgn; magnitude }","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"        let if_ cond ~(then_ : var) ~(else_ : var) : var Checked.t =","counters":[]},{"line":"          let%bind repr = if_repr cond ~then_:then_.repr ~else_:else_.repr in","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"          let%map value =","counters":[]},{"line":"            match (then_.value, else_.value) with","counters":[]},{"line":"            | Some v1, Some v2 ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Field.Checked.if_ cond ~then_:v1 ~else_:v2 >>| Option.return","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"            | _ ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                return None","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"          in","counters":[]},{"line":"          { Signed_var.value; repr }","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"        let sgn (t : var) =","counters":[]},{"line":"          let%map r = repr t in","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"          r.sgn","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"        let magnitude (t : var) =","counters":[]},{"line":"          let%map r = repr t in","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"          r.magnitude","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"        let add_flagged (x : var) (y : var) =","counters":[]},{"line":"          let%bind xv = value x and yv = value y in","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"          let%bind sgn =","counters":[]},{"line":"            exists Sgn.typ","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"              ~compute:","counters":[]},{"line":"                (let open As_prover in","counters":[]},{"line":"                let%map x = read typ x and y = read typ y in","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"                match add x y with","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                | Some r ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    r.sgn","counters":[]},{"line":"                | None -> (","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    match (x.sgn, y.sgn) with","counters":[]},{"line":"                    | Sgn.Neg, Sgn.Neg ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        (* Ensure that we provide a value in the range","counters":[]},{"line":"                           [-modulus_as_field < magnitude < 2*modulus_as_field]","counters":[]},{"line":"                           for [range_check_flagged].","counters":[]},{"line":"                        *)","counters":[]},{"line":"                        Sgn.Neg","counters":[]},{"line":"                    | _ ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        Sgn.Pos ))","counters":[]},{"line":"          in","counters":[]},{"line":"          let value = Field.Var.add xv yv in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let%bind magnitude =","counters":[]},{"line":"            Tick.Field.Checked.mul (sgn :> Field.Var.t) value","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%bind res_magnitude, `Overflow overflow =","counters":[]},{"line":"            range_check_flagged `Add_or_sub magnitude","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"          in","counters":[]},{"line":"          (* Recompute the result from [res_magnitude], since it may have been","counters":[]},{"line":"             adjusted.","counters":[]},{"line":"          *)","counters":[]},{"line":"          let%map res_value =","counters":[]},{"line":"            Field.Checked.mul (sgn :> Field.Var.t) magnitude","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"          in","counters":[]},{"line":"          ( { Signed_var.repr = { magnitude = res_magnitude; sgn }","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ; value = Some res_value","counters":[]},{"line":"            }","counters":[]},{"line":"          , `Overflow overflow )","counters":[]},{"line":"","counters":[]},{"line":"        let add (x : var) (y : var) =","counters":[]},{"line":"          let%bind xv = value x and yv = value y in","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"          let%bind sgn =","counters":[]},{"line":"            exists Sgn.typ","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"              ~compute:","counters":[]},{"line":"                (let open As_prover in","counters":[]},{"line":"                let%map x = read typ x and y = read typ y in","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"                Option.value_map (add x y) ~default:Sgn.Pos ~f:(fun r -> r.sgn))","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":73,"col_end":73,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%bind res_value = seal (Field.Var.add xv yv) in","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"          let%bind magnitude =","counters":[]},{"line":"            Tick.Field.Checked.mul (sgn :> Field.Var.t) res_value","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%map () = range_check magnitude in","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"          { Signed_var.repr = { magnitude; sgn }; value = Some res_value }","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"        let ( + ) = add","counters":[]},{"line":"","counters":[]},{"line":"        let equal (t1 : var) (t2 : var) =","counters":[]},{"line":"          let%bind t1 = value t1 and t2 = value t2 in","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"          Field.Checked.equal t1 t2","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"        let assert_equal (t1 : var) (t2 : var) =","counters":[]},{"line":"          let%bind t1 = value t1 and t2 = value t2 in","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"          Field.Checked.Assert.equal t1 t2","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"        let to_fee = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"        let of_fee = Fn.id","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      [%%endif]","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    [%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"    module Checked = struct","counters":[]},{"line":"      module N = Mina_numbers.Nat.Make_checked (Unsigned) (B)","counters":[]},{"line":"","counters":[]},{"line":"      type t = var","counters":[]},{"line":"","counters":[]},{"line":"      let if_ = if_","counters":[]},{"line":"","counters":[]},{"line":"      (* Unpacking protects against underflow *)","counters":[]},{"line":"      let sub (x : var) (y : var) =","counters":[]},{"line":"        let%bind res = seal (Field.Var.sub x y) in","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"        let%map () = range_check res in","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"        res","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      let sub_flagged x y =","counters":[]},{"line":"        let%bind z = seal (Field.Var.sub x y) in","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"        let%map z, `Overflow underflow = range_check_flagged `Sub z in","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"        (z, `Underflow underflow)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      let sub_or_zero x y =","counters":[]},{"line":"        let%bind res, `Underflow underflow = sub_flagged x y in","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"        Field.Checked.if_ underflow ~then_:Field.(Var.constant zero) ~else_:res","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"","counters":[]},{"line":"      let assert_equal x y = Field.Checked.Assert.equal x y","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"      let equal x y = Field.Checked.equal x y","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"      let ( = ) = equal","counters":[]},{"line":"","counters":[]},{"line":"      let ( < ) x y =","counters":[]},{"line":"        let%bind diff = seal (Field.Var.sub x y) in","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"        (* [lt] is true iff [x - y < 0], ie. [x < y] *)","counters":[]},{"line":"        let%map _res, `Overflow lt = range_check_flagged `Sub diff in","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"        lt","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      (* x <= y iff not (y < x) *)","counters":[]},{"line":"      let ( <= ) x y =","counters":[]},{"line":"        let%map y_lt_x = y < x in","counters":[]},{"line":"        Boolean.not y_lt_x","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      (* x >= y iff y <= x *)","counters":[]},{"line":"      let ( >= ) x y = y <= x","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"      let ( > ) x y = y < x","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"      (* Unpacking protects against overflow *)","counters":[]},{"line":"      let add (x : var) (y : var) =","counters":[]},{"line":"        let%bind res = seal (Field.Var.add x y) in","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"        let%map () = range_check res in","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"        res","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      let add_flagged x y =","counters":[]},{"line":"        let%bind z = seal (Field.Var.add x y) in","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"        let%map z, `Overflow overflow = range_check_flagged `Add z in","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"        (z, `Overflow overflow)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      let ( - ) = sub","counters":[]},{"line":"","counters":[]},{"line":"      let ( + ) = add","counters":[]},{"line":"","counters":[]},{"line":"      let add_signed (t : var) (d : Signed.var) =","counters":[]},{"line":"        let%bind d = Signed.Checked.to_field_var d in","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"        let%bind res = seal (Field.Var.add t d) in","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"        let%map () = range_check res in","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"        res","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      let add_signed_flagged (t : var) (d : Signed.var) =","counters":[]},{"line":"        let%bind d = Signed.Checked.to_field_var d in","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"        let%bind res = seal (Field.Var.add t d) in","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"        let%map res, `Overflow overflow = range_check_flagged `Add_or_sub res in","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"        (res, `Overflow overflow)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      let scale (f : Field.Var.t) (t : var) =","counters":[]},{"line":"        let%bind res = Field.Checked.mul t f in","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"        let%map () = range_check res in","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"        res","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      let%test_module \"currency_test\" =","counters":[]},{"line":"        ( module struct","counters":[]},{"line":"          let expect_failure err c =","counters":[]},{"line":"            if Or_error.is_ok (check c) then failwith err","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"","counters":[]},{"line":"          let expect_success err c =","counters":[]},{"line":"            match check c with","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            | Ok () ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ()","counters":[]},{"line":"            | Error e ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Error.(raise (tag ~tag:err e))","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"","counters":[]},{"line":"          let to_bigint x = Bignum_bigint.of_string (Unsigned.to_string x)","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":70,"col_end":70,"count":0}]},{"line":"","counters":[]},{"line":"          let of_bigint x = Unsigned.of_string (Bignum_bigint.to_string x)","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":70,"col_end":70,"count":0}]},{"line":"","counters":[]},{"line":"          let gen_incl x y =","counters":[]},{"line":"            Quickcheck.Generator.map ~f:of_bigint","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (Bignum_bigint.gen_incl (to_bigint x) (to_bigint y))","counters":[{"col_start":36,"col_end":36,"count":0},{"col_start":47,"col_end":47,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"","counters":[]},{"line":"          let shrinker =","counters":[]},{"line":"            Quickcheck.Shrinker.create (fun i ->","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                Sequence.unfold ~init:i ~f:(fun i ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                    if Unsigned.equal i Unsigned.zero then None","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"                    else","counters":[]},{"line":"                      let n = Unsigned.div i (Unsigned.of_int 10) in","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"                      Some (n, n) ) )","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"          (* TODO: When we do something to make snarks run fast for tests, increase the trials *)","counters":[]},{"line":"          let qc_test_fast = Quickcheck.test ~trials:100","counters":[]},{"line":"","counters":[]},{"line":"          let%test_unit \"subtraction_completeness\" =","counters":[]},{"line":"            let generator =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"              let%bind x = gen_incl Unsigned.zero Unsigned.max_int in","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"              let%map y = gen_incl Unsigned.zero x in","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"              (x, y)","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"            in","counters":[]},{"line":"            qc_test_fast generator ~f:(fun (lo, hi) ->","counters":[]},{"line":"                expect_success","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  (sprintf !\"subtraction: lo=%{Unsigned} hi=%{Unsigned}\" lo hi)","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"                  (var_of_t lo - var_of_t hi) )","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"          let%test_unit \"subtraction_soundness\" =","counters":[]},{"line":"            let generator =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"              let%bind x = gen_incl Unsigned.zero Unsigned.(sub max_int one) in","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"              let%map y = gen_incl Unsigned.(add x one) Unsigned.max_int in","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"              (x, y)","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"            in","counters":[]},{"line":"            qc_test_fast generator ~f:(fun (lo, hi) ->","counters":[]},{"line":"                expect_failure","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  (sprintf !\"underflow: lo=%{Unsigned} hi=%{Unsigned}\" lo hi)","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"                  (var_of_t lo - var_of_t hi) )","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"          let%test_unit \"addition_completeness\" =","counters":[]},{"line":"            let generator =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"              let%bind x = gen_incl Unsigned.zero Unsigned.max_int in","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"              let%map y = gen_incl Unsigned.zero Unsigned.(sub max_int x) in","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"              (x, y)","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"            in","counters":[]},{"line":"            qc_test_fast generator ~f:(fun (x, y) ->","counters":[]},{"line":"                expect_success","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  (sprintf !\"overflow: x=%{Unsigned} y=%{Unsigned}\" x y)","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"                  (var_of_t x + var_of_t y) )","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"          let%test_unit \"addition_soundness\" =","counters":[]},{"line":"            let generator =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"              let%bind x = gen_incl Unsigned.one Unsigned.max_int in","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"              let%map y =","counters":[]},{"line":"                gen_incl Unsigned.(add (sub max_int x) one) Unsigned.max_int","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"              in","counters":[]},{"line":"              (x, y)","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"            in","counters":[]},{"line":"            qc_test_fast generator ~f:(fun (x, y) ->","counters":[]},{"line":"                expect_failure","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  (sprintf !\"overflow: x=%{Unsigned} y=%{Unsigned}\" x y)","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"                  (var_of_t x + var_of_t y) )","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"          let%test_unit \"formatting_roundtrip\" =","counters":[]},{"line":"            let generator = gen_incl Unsigned.zero Unsigned.max_int in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            qc_test_fast generator ~shrinker ~f:(fun num ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"                match of_formatted_string (to_formatted_string num) with","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"                | after_format ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    if Unsigned.equal after_format num then ()","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"                    else","counters":[]},{"line":"                      Error.(","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        raise","counters":[]},{"line":"                          (of_string","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                             (sprintf","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"                                !\"formatting: num=%{Unsigned} middle=%{String} \\","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"                                  after=%{Unsigned}\"","counters":[]},{"line":"                                num (to_formatted_string num) after_format ) ))","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"                | exception e ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    let err = Error.of_exn e in","counters":[]},{"line":"                    Error.(","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      raise","counters":[]},{"line":"                        (tag","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                           ~tag:(sprintf !\"formatting: num=%{Unsigned}\" num)","counters":[{"col_start":39,"col_end":39,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"                           err )) )","counters":[]},{"line":"","counters":[]},{"line":"          let%test_unit \"formatting_trailing_zeros\" =","counters":[]},{"line":"            let generator = gen_incl Unsigned.zero Unsigned.max_int in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            qc_test_fast generator ~shrinker ~f:(fun num ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"                let formatted = to_formatted_string num in","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                let has_decimal = String.contains formatted '.' in","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                let trailing_zero = String.is_suffix formatted ~suffix:\"0\" in","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                if has_decimal && trailing_zero then","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"                  Error.(","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    raise","counters":[]},{"line":"                      (of_string","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                         (sprintf","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                            !\"formatting: num=%{Unsigned} formatted=%{String}\"","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                            num (to_formatted_string num) ) )) )","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"        end )","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    [%%endif]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let currency_length = 64","counters":[]},{"line":"","counters":[]},{"line":"  module Fee = struct","counters":[]},{"line":"    module T =","counters":[]},{"line":"      Make","counters":[]},{"line":"        (Unsigned_extended.UInt64)","counters":[]},{"line":"        (struct","counters":[]},{"line":"          let length = currency_length","counters":[]},{"line":"        end)","counters":[]},{"line":"","counters":[]},{"line":"    include T","counters":[]},{"line":"","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"      [@@@no_toplevel_latest_type]","counters":[]},{"line":"","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        [@@@with_all_version_tags]","counters":[]},{"line":"","counters":[]},{"line":"        type t = Unsigned_extended.UInt64.Stable.V1.t","counters":[{"col_start":8,"col_end":8,"count":4},{"col_start":13,"col_end":13,"count":2}]},{"line":"        [@@deriving sexp, compare, hash, equal]","counters":[{"col_start":46,"col_end":46,"count":15}]},{"line":"","counters":[]},{"line":"        [%%define_from_scope to_yojson, of_yojson, dhall_type]","counters":[]},{"line":"","counters":[]},{"line":"        let to_latest = Fn.id","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    type _unused = unit constraint Signed.t = (t, Sgn.t) Signed_poly.t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Amount = struct","counters":[]},{"line":"    (* See documentation for {!module:Mina_wire_types} *)","counters":[]},{"line":"    module Make_sig (A : sig","counters":[]},{"line":"      type t","counters":[]},{"line":"    end) =","counters":[]},{"line":"    struct","counters":[]},{"line":"      module type S = sig","counters":[]},{"line":"        [%%versioned:","counters":[]},{"line":"        module Stable : sig","counters":[]},{"line":"          module V1 : sig","counters":[]},{"line":"            [@@@with_all_version_tags]","counters":[]},{"line":"","counters":[]},{"line":"            type t = A.t [@@deriving sexp, compare, hash, equal, yojson]","counters":[]},{"line":"","counters":[]},{"line":"            (* not automatically derived *)","counters":[]},{"line":"            val dhall_type : Ppx_dhall_type.Dhall_type.t","counters":[]},{"line":"          end","counters":[]},{"line":"        end]","counters":[]},{"line":"","counters":[]},{"line":"        [%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"        (* Give a definition to var, it will be hidden at the interface level *)","counters":[]},{"line":"        include","counters":[]},{"line":"          Basic","counters":[]},{"line":"            with type t := Stable.Latest.t","counters":[]},{"line":"             and type var =","counters":[]},{"line":"              Pickles.Impls.Step.Impl.Internal_Basic.field","counters":[]},{"line":"              Snarky_backendless.Cvar.t","counters":[]},{"line":"","counters":[]},{"line":"        [%%else]","counters":[]},{"line":"","counters":[]},{"line":"        include Basic with type t := Stable.Latest.t","counters":[]},{"line":"","counters":[]},{"line":"        [%%endif]","counters":[]},{"line":"","counters":[]},{"line":"        include Arithmetic_intf with type t := t","counters":[]},{"line":"","counters":[]},{"line":"        include Codable.S with type t := t","counters":[]},{"line":"","counters":[]},{"line":"        [%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"        module Signed :","counters":[]},{"line":"          Signed_intf","counters":[]},{"line":"            with type magnitude := t","counters":[]},{"line":"             and type magnitude_var := var","counters":[]},{"line":"             and type signed_fee := Fee.Signed.t","counters":[]},{"line":"             and type Checked.signed_fee_var := Fee.Signed.Checked.t","counters":[]},{"line":"","counters":[]},{"line":"        [%%else]","counters":[]},{"line":"","counters":[]},{"line":"        module Signed :","counters":[]},{"line":"          Signed_intf","counters":[]},{"line":"            with type magnitude := t","counters":[]},{"line":"             and type signed_fee := Fee.Signed.t","counters":[]},{"line":"","counters":[]},{"line":"        [%%endif]","counters":[]},{"line":"","counters":[]},{"line":"        (* TODO: Delete these functions *)","counters":[]},{"line":"","counters":[]},{"line":"        val of_fee : Fee.t -> t","counters":[]},{"line":"","counters":[]},{"line":"        val to_fee : t -> Fee.t","counters":[]},{"line":"","counters":[]},{"line":"        val add_fee : t -> Fee.t -> t option","counters":[]},{"line":"","counters":[]},{"line":"        [%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"        module Checked : sig","counters":[]},{"line":"          include","counters":[]},{"line":"            Checked_arithmetic_intf","counters":[]},{"line":"              with type var := var","counters":[]},{"line":"               and type signed_var := Signed.var","counters":[]},{"line":"               and type value := t","counters":[]},{"line":"","counters":[]},{"line":"          val add_signed : var -> Signed.var -> var Checked.t","counters":[]},{"line":"","counters":[]},{"line":"          val of_fee : Fee.var -> var","counters":[]},{"line":"","counters":[]},{"line":"          val to_fee : var -> Fee.var","counters":[]},{"line":"","counters":[]},{"line":"          module Unsafe : sig","counters":[]},{"line":"            val of_field : Field.Var.t -> t","counters":[]},{"line":"          end","counters":[]},{"line":"        end","counters":[]},{"line":"","counters":[]},{"line":"        [%%endif]","counters":[]},{"line":"","counters":[]},{"line":"        val add_signed_flagged : t -> Signed.t -> t * [ `Overflow of bool ]","counters":[]},{"line":"      end","counters":[]},{"line":"    end","counters":[]},{"line":"    [@@warning \"-32\"]","counters":[]},{"line":"","counters":[]},{"line":"    module Make_str (A : sig","counters":[]},{"line":"      type t = Unsigned_extended.UInt64.Stable.V1.t","counters":[]},{"line":"    end) : Make_sig(A).S = struct","counters":[]},{"line":"      module T =","counters":[]},{"line":"        Make","counters":[]},{"line":"          (Unsigned_extended.UInt64)","counters":[]},{"line":"          (struct","counters":[]},{"line":"            let length = currency_length","counters":[]},{"line":"          end)","counters":[]},{"line":"","counters":[]},{"line":"      [%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"      include (","counters":[]},{"line":"        T :","counters":[]},{"line":"          module type of T","counters":[]},{"line":"            with type var = T.var","counters":[]},{"line":"             and module Signed = T.Signed","counters":[]},{"line":"             and module Checked := T.Checked )","counters":[]},{"line":"","counters":[]},{"line":"      [%%else]","counters":[]},{"line":"","counters":[]},{"line":"      include (T : module type of T with module Signed = T.Signed)","counters":[]},{"line":"","counters":[]},{"line":"      [%%endif]","counters":[]},{"line":"","counters":[]},{"line":"      [%%versioned","counters":[]},{"line":"      module Stable = struct","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"        [@@@no_toplevel_latest_type]","counters":[]},{"line":"","counters":[]},{"line":"        module V1 = struct","counters":[]},{"line":"          [@@@with_all_version_tags]","counters":[]},{"line":"","counters":[]},{"line":"          type t = Unsigned_extended.UInt64.Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":4},{"col_start":15,"col_end":15,"count":2},{"col_start":19,"col_end":19,"count":0}]},{"line":"          [@@deriving sexp, compare, hash, equal, yojson]","counters":[{"col_start":56,"col_end":56,"count":15}]},{"line":"","counters":[]},{"line":"          [%%define_from_scope to_yojson, of_yojson, dhall_type]","counters":[]},{"line":"","counters":[]},{"line":"          let to_latest = Fn.id","counters":[]},{"line":"        end","counters":[]},{"line":"      end]","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      let of_fee (fee : Fee.t) : t = fee","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"      let to_fee (fee : t) : Fee.t = fee","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"      let add_fee (t : t) (fee : Fee.t) = add t (of_fee fee)","counters":[{"col_start":42,"col_end":42,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"","counters":[]},{"line":"      [%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"      module Checked = struct","counters":[]},{"line":"        include T.Checked","counters":[]},{"line":"","counters":[]},{"line":"        let of_fee (fee : Fee.var) : var = fee","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"","counters":[]},{"line":"        let to_fee (t : var) : Fee.var = t","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"","counters":[]},{"line":"        module Unsafe = struct","counters":[]},{"line":"          let of_field : Field.Var.t -> var = Fn.id","counters":[]},{"line":"        end","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      [%%endif]","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    include Make_str (struct","counters":[]},{"line":"      type t = Unsigned_extended.UInt64.Stable.V1.t","counters":[]},{"line":"    end)","counters":[]},{"line":"    (*include Wire_types.Make.Amount (Make_sig) (Make_str)*)","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Balance = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type t = Amount.Stable.V1.t","counters":[{"col_start":8,"col_end":8,"count":2},{"col_start":13,"col_end":13,"count":1},{"col_start":17,"col_end":17,"count":0}]},{"line":"        [@@deriving sexp, compare, equal, hash, yojson]","counters":[{"col_start":54,"col_end":54,"count":5}]},{"line":"","counters":[]},{"line":"        let to_latest = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"        (* can't be automatically derived *)","counters":[]},{"line":"        let dhall_type = Ppx_dhall_type.Dhall_type.Text","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    [%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"    include (Amount : Basic with type t := t with type var = Amount.var)","counters":[]},{"line":"","counters":[]},{"line":"    [%%else]","counters":[]},{"line":"","counters":[]},{"line":"    include (Amount : Basic with type t := t)","counters":[]},{"line":"","counters":[]},{"line":"    [%%endif]","counters":[]},{"line":"","counters":[]},{"line":"    let to_amount = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"    let add_amount = Amount.add","counters":[]},{"line":"","counters":[]},{"line":"    let add_amount_flagged = Amount.add_flagged","counters":[]},{"line":"","counters":[]},{"line":"    let sub_amount = Amount.sub","counters":[]},{"line":"","counters":[]},{"line":"    let sub_amount_flagged = Amount.sub_flagged","counters":[]},{"line":"","counters":[]},{"line":"    let add_signed_amount_flagged = Amount.add_signed_flagged","counters":[]},{"line":"","counters":[]},{"line":"    let ( + ) = add_amount","counters":[]},{"line":"","counters":[]},{"line":"    let ( - ) = sub_amount","counters":[]},{"line":"","counters":[]},{"line":"    [%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"    module Checked = struct","counters":[]},{"line":"      include Amount.Checked","counters":[]},{"line":"","counters":[]},{"line":"      module Unsafe = struct","counters":[]},{"line":"        let of_field (x : Field.Var.t) : var = x","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      let to_amount = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"      let add_signed_amount = add_signed","counters":[]},{"line":"","counters":[]},{"line":"      let add_amount = add","counters":[]},{"line":"","counters":[]},{"line":"      let sub_amount = sub","counters":[]},{"line":"","counters":[]},{"line":"      let add_amount_flagged = add_flagged","counters":[]},{"line":"","counters":[]},{"line":"      let add_signed_amount_flagged = add_signed_flagged","counters":[]},{"line":"","counters":[]},{"line":"      let sub_amount_flagged = sub_flagged","counters":[]},{"line":"","counters":[]},{"line":"      let ( + ) = add_amount","counters":[]},{"line":"","counters":[]},{"line":"      let ( - ) = sub_amount","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    [%%endif]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Fee_rate = struct","counters":[]},{"line":"    type t = Q.t","counters":[]},{"line":"","counters":[]},{"line":"    let uint64_to_z u64 = Z.of_string @@ Unsigned.UInt64.to_string u64","counters":[{"col_start":26,"col_end":26,"count":1},{"col_start":65,"col_end":65,"count":1}]},{"line":"","counters":[]},{"line":"    let uint64_of_z z = Unsigned.UInt64.of_string @@ Z.to_string z","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"","counters":[]},{"line":"    let max_uint64_z = uint64_to_z Unsigned.UInt64.max_int","counters":[{"col_start":33,"col_end":33,"count":1}]},{"line":"","counters":[]},{"line":"    let fits_uint64 z =","counters":[]},{"line":"      let open Z in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      leq zero z && leq z max_uint64_z","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":20,"col_end":20,"count":0}]},{"line":"","counters":[]},{"line":"    (** check if a Q.t is in range *)","counters":[]},{"line":"    let check_q Q.{ num; den } : bool =","counters":[]},{"line":"      let open Z in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      fits_uint64 num && fits_int32 den","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"      && if equal zero den then equal zero num else true","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"","counters":[]},{"line":"    let of_q q = if check_q q then Some q else None","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"","counters":[]},{"line":"    let of_q_exn q = Option.value_exn (of_q q)","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"","counters":[]},{"line":"    let to_q = ident","counters":[]},{"line":"","counters":[]},{"line":"    let make fee weight = of_q @@ Q.make (uint64_to_z fee) (Z.of_int weight)","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":52,"col_end":52,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"","counters":[]},{"line":"    let make_exn fee weight = Option.value_exn (make fee weight)","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"","counters":[]},{"line":"    let to_uint64 Q.{ num; den } =","counters":[]},{"line":"      if Z.(equal den Z.one) then Some (uint64_of_z num) else None","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":50,"col_end":50,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"","counters":[]},{"line":"    let to_uint64_exn fr = Option.value_exn (to_uint64 fr)","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"","counters":[]},{"line":"    let add x y = of_q @@ Q.add x y","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"","counters":[]},{"line":"    let add_flagged x y =","counters":[]},{"line":"      let z = Q.add x y in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      (z, `Overflow (check_q z))","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"","counters":[]},{"line":"    let sub x y = of_q @@ Q.sub x y","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"","counters":[]},{"line":"    let sub_flagged x y =","counters":[]},{"line":"      let z = Q.sub x y in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      (z, `Underflow (check_q z))","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"","counters":[]},{"line":"    let mul x y = of_q @@ Q.mul x y","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"","counters":[]},{"line":"    let div x y = of_q @@ Q.div x y","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"","counters":[]},{"line":"    let ( + ) = add","counters":[]},{"line":"","counters":[]},{"line":"    let ( - ) = sub","counters":[]},{"line":"","counters":[]},{"line":"    let ( * ) = mul","counters":[]},{"line":"","counters":[]},{"line":"    let scale fr s = fr * Q.of_int s","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"","counters":[]},{"line":"    let scale_exn fr s = Option.value_exn (scale fr s)","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"","counters":[]},{"line":"    let compare = Q.compare","counters":[]},{"line":"","counters":[]},{"line":"    let t_of_sexp sexp =","counters":[]},{"line":"      let open Ppx_sexp_conv_lib.Conv in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      pair_of_sexp Fee.t_of_sexp int_of_sexp sexp","counters":[]},{"line":"      |> fun (fee, weight) -> make_exn fee weight","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"","counters":[]},{"line":"    let sexp_of_t Q.{ num = fee; den = weight } =","counters":[]},{"line":"      let sexp_of_fee fee = Fee.sexp_of_t @@ uint64_of_z fee in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"      let sexp_of_weight weight = sexp_of_int @@ Z.to_int weight in","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"      sexp_of_pair sexp_of_fee sexp_of_weight (fee, weight)","counters":[]},{"line":"","counters":[]},{"line":"    include Comparable.Make (struct","counters":[]},{"line":"      type nonrec t = t","counters":[]},{"line":"","counters":[]},{"line":"      let compare = compare","counters":[]},{"line":"","counters":[]},{"line":"      let t_of_sexp = t_of_sexp","counters":[]},{"line":"","counters":[]},{"line":"      let sexp_of_t = sexp_of_t","counters":[]},{"line":"    end)","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let%test_module \"sub_flagged module\" =","counters":[]},{"line":"    ( module struct","counters":[]},{"line":"      [%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"      open Tick","counters":[]},{"line":"","counters":[]},{"line":"      module type Sub_flagged_S = sig","counters":[]},{"line":"        type t","counters":[]},{"line":"","counters":[]},{"line":"        type magnitude = t [@@deriving sexp, compare]","counters":[]},{"line":"","counters":[]},{"line":"        type var","counters":[]},{"line":"","counters":[]},{"line":"        (* TODO =","counters":[]},{"line":"           field Snarky_backendless.Cvar.t Snarky_backendless.Boolean.t list *)","counters":[]},{"line":"","counters":[]},{"line":"        val zero : t","counters":[]},{"line":"","counters":[]},{"line":"        val ( - ) : t -> t -> t option","counters":[]},{"line":"","counters":[]},{"line":"        val typ : (var, t) Typ.t","counters":[]},{"line":"","counters":[]},{"line":"        val gen : t Quickcheck.Generator.t","counters":[]},{"line":"","counters":[]},{"line":"        module Checked : sig","counters":[]},{"line":"          val sub_flagged :","counters":[]},{"line":"            var -> var -> (var * [ `Underflow of Boolean.var ]) Tick.Checked.t","counters":[]},{"line":"        end","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      let run_test (module M : Sub_flagged_S) =","counters":[]},{"line":"        let open M in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let sub_flagged_unchecked (x, y) =","counters":[]},{"line":"          if compare_magnitude x y < 0 then (zero, true)","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"          else (Option.value_exn (x - y), false)","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"        in","counters":[]},{"line":"        let sub_flagged_checked =","counters":[]},{"line":"          let f (x, y) =","counters":[]},{"line":"            Tick.Checked.map (M.Checked.sub_flagged x y)","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"              ~f:(fun (r, `Underflow u) -> (r, u))","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"          in","counters":[]},{"line":"          Test_util.checked_to_unchecked (Typ.tuple2 typ typ)","counters":[{"col_start":39,"col_end":39,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"            (Typ.tuple2 typ Boolean.typ)","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"            f","counters":[]},{"line":"        in","counters":[]},{"line":"        Quickcheck.test ~trials:100 (Quickcheck.Generator.tuple2 gen gen)","counters":[{"col_start":63,"col_end":63,"count":0}]},{"line":"          ~f:(fun p ->","counters":[]},{"line":"            let m, u = sub_flagged_unchecked p in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let m_checked, u_checked = sub_flagged_checked p in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            assert (Bool.equal u u_checked) ;","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"            if not u then [%test_eq: M.magnitude] m m_checked )","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"      let%test_unit \"fee sub_flagged\" = run_test (module Fee)","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"      let%test_unit \"amount sub_flagged\" = run_test (module Amount)","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"","counters":[]},{"line":"      [%%endif]","counters":[]},{"line":"    end )","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(** Finally, we use [Make] to create the full module where the types defined","counters":[]},{"line":"    here and in {!Mina_wire_types} are fully unified. *)","counters":[]},{"line":"include Wire_types.Make (Make_sig) (Make_str)","counters":[{"col_start":44,"col_end":44,"count":1}]}]}