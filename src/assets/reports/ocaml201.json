{"filename":"src/lib/network_pool/transaction_pool.ml","lines":[{"line":"(** A pool of transactions that can be included in future blocks. Combined with","counters":[]},{"line":"    the Network_pool module, this handles storing and gossiping the correct","counters":[]},{"line":"    transactions (user commands) and providing them to the block producer code.","counters":[]},{"line":"*)","counters":[]},{"line":"","counters":[]},{"line":"(* Only show stdout for failed inline tests.*)","counters":[{"col_start":46,"col_end":46,"count":1}]},{"line":"open Inline_test_quiet_logs","counters":[]},{"line":"open Core","counters":[]},{"line":"open Async","counters":[]},{"line":"open Mina_base","counters":[]},{"line":"open Mina_transaction","counters":[]},{"line":"open Pipe_lib","counters":[]},{"line":"open Network_peer","counters":[]},{"line":"","counters":[]},{"line":"let max_per_15_seconds = 10","counters":[]},{"line":"","counters":[]},{"line":"(* TEMP HACK UNTIL DEFUNCTORING: transition frontier interface is simplified *)","counters":[]},{"line":"module type Transition_frontier_intf = sig","counters":[]},{"line":"  type t","counters":[]},{"line":"","counters":[]},{"line":"  type staged_ledger","counters":[]},{"line":"","counters":[]},{"line":"  module Breadcrumb : sig","counters":[]},{"line":"    type t","counters":[]},{"line":"","counters":[]},{"line":"    val staged_ledger : t -> staged_ledger","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  type best_tip_diff =","counters":[]},{"line":"    { new_commands : User_command.Valid.t With_status.t list","counters":[]},{"line":"    ; removed_commands : User_command.Valid.t With_status.t list","counters":[]},{"line":"    ; reorg_best_tip : bool","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  val best_tip : t -> Breadcrumb.t","counters":[]},{"line":"","counters":[]},{"line":"  val best_tip_diff_pipe : t -> best_tip_diff Broadcast_pipe.Reader.t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(* versioned type, outside of functors *)","counters":[]},{"line":"module Diff_versioned = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    [@@@no_toplevel_latest_type]","counters":[]},{"line":"","counters":[]},{"line":"    module V2 = struct","counters":[]},{"line":"      type t = User_command.Stable.V2.t list [@@deriving sexp, yojson, hash]","counters":[{"col_start":6,"col_end":6,"count":2},{"col_start":11,"col_end":11,"count":1},{"col_start":15,"col_end":15,"count":0},{"col_start":43,"col_end":43,"count":0},{"col_start":75,"col_end":75,"count":5}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  (* We defer do any checking on signed-commands until the call to","counters":[]},{"line":"     [add_from_gossip_gossip_exn].","counters":[]},{"line":"","counters":[]},{"line":"     The real solution would be to have more explicit queueing to make sure things don't happen out of order, factor","counters":[]},{"line":"     [add_from_gossip_gossip_exn] into [check_from_gossip_exn] (which just does","counters":[]},{"line":"     the checks) and [set_from_gossip_exn] (which just does the mutating the pool),","counters":[]},{"line":"     and do the same for snapp commands as well.","counters":[]},{"line":"  *)","counters":[]},{"line":"  type t = User_command.t list [@@deriving sexp, yojson]","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":11,"col_end":11,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"  module Diff_error = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      [@@@no_toplevel_latest_type]","counters":[]},{"line":"","counters":[]},{"line":"      module V2 = struct","counters":[]},{"line":"        type t =","counters":[{"col_start":8,"col_end":8,"count":2},{"col_start":13,"col_end":13,"count":2}]},{"line":"          | Insufficient_replace_fee","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | Duplicate","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | Invalid_nonce","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | Insufficient_funds","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | Overflow","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | Bad_token","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | Unwanted_fee_token","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | Expired","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | Overloaded","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | Fee_payer_account_not_found","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | Fee_payer_not_permitted_to_send","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        [@@deriving sexp, yojson, compare]","counters":[{"col_start":41,"col_end":41,"count":5}]},{"line":"","counters":[]},{"line":"        let to_latest = Fn.id","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    (* IMPORTANT! Do not change the names of these errors as to adjust the","counters":[]},{"line":"     * to_yojson output without updating Rosetta's construction API to handle","counters":[]},{"line":"     * the changes *)","counters":[]},{"line":"    type t = Stable.Latest.t =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      | Insufficient_replace_fee","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Duplicate","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Invalid_nonce","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Insufficient_funds","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Overflow","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Bad_token","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Unwanted_fee_token","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Expired","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Overloaded","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Fee_payer_account_not_found","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Fee_payer_not_permitted_to_send","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    [@@deriving sexp, yojson]","counters":[]},{"line":"","counters":[]},{"line":"    let to_string_name = function","counters":[]},{"line":"      | Insufficient_replace_fee ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          \"insufficient_replace_fee\"","counters":[]},{"line":"      | Duplicate ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          \"duplicate\"","counters":[]},{"line":"      | Invalid_nonce ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          \"invalid_nonce\"","counters":[]},{"line":"      | Insufficient_funds ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          \"insufficient_funds\"","counters":[]},{"line":"      | Overflow ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          \"overflow\"","counters":[]},{"line":"      | Bad_token ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          \"bad_token\"","counters":[]},{"line":"      | Unwanted_fee_token ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          \"unwanted_fee_token\"","counters":[]},{"line":"      | Expired ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          \"expired\"","counters":[]},{"line":"      | Overloaded ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          \"overloaded\"","counters":[]},{"line":"      | Fee_payer_account_not_found ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          \"fee_payer_account_not_found\"","counters":[]},{"line":"      | Fee_payer_not_permitted_to_send ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          \"fee_payer_not_permitted_to_send\"","counters":[]},{"line":"","counters":[]},{"line":"    let to_string_hum = function","counters":[]},{"line":"      | Insufficient_replace_fee ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          \"This transaction would have replaced an existing transaction in the \\","counters":[]},{"line":"           pool, but the fee was too low\"","counters":[]},{"line":"      | Duplicate ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          \"This transaction is a duplicate of one already in the pool\"","counters":[]},{"line":"      | Invalid_nonce ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          \"This transaction had an invalid nonce\"","counters":[]},{"line":"      | Insufficient_funds ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          \"There are not enough funds in the fee-payer's account to execute \\","counters":[]},{"line":"           this transaction\"","counters":[]},{"line":"      | Overflow ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          \"Executing this transaction would result in an integer overflow\"","counters":[]},{"line":"      | Bad_token ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          \"This transaction uses non-default tokens where they are not \\","counters":[]},{"line":"           permitted\"","counters":[]},{"line":"      | Unwanted_fee_token ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          \"This transaction pays fees in a non-default token that this pool \\","counters":[]},{"line":"           does not accept\"","counters":[]},{"line":"      | Expired ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          \"This transaction has expired\"","counters":[]},{"line":"      | Overloaded ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          \"The diff containing this transaction was too large\"","counters":[]},{"line":"      | Fee_payer_account_not_found ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          \"Fee payer account was not found in the best tip ledger\"","counters":[]},{"line":"      | Fee_payer_not_permitted_to_send ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          \"Fee payer account permissions don't allow sending funds\"","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Rejected = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      [@@@no_toplevel_latest_type]","counters":[]},{"line":"","counters":[]},{"line":"      module V3 = struct","counters":[]},{"line":"        type t = (User_command.Stable.V2.t * Diff_error.Stable.V2.t) list","counters":[{"col_start":8,"col_end":8,"count":2},{"col_start":13,"col_end":13,"count":1},{"col_start":17,"col_end":17,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":66,"col_end":66,"count":0},{"col_start":69,"col_end":69,"count":0},{"col_start":72,"col_end":72,"count":0}]},{"line":"        [@@deriving sexp, yojson, compare]","counters":[{"col_start":41,"col_end":41,"count":5}]},{"line":"","counters":[]},{"line":"        let to_latest = Fn.id","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    type t = Stable.Latest.t [@@deriving sexp, yojson, compare]","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":13,"col_end":13,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  type rejected = Rejected.t [@@deriving sexp, yojson, compare]","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"","counters":[]},{"line":"  type verified = Transaction_hash.User_command_with_valid_signature.t list","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":74,"col_end":74,"count":0}]},{"line":"  [@@deriving sexp, to_yojson]","counters":[]},{"line":"","counters":[]},{"line":"  let summary t = Printf.sprintf \"Transaction diff of length %d\" (List.length t)","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":76,"col_end":76,"count":0}]},{"line":"","counters":[]},{"line":"  let is_empty t = List.is_empty t","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"type Structured_log_events.t +=","counters":[]},{"line":"  | Rejecting_command_for_reason of","counters":[]},{"line":"      { command : User_command.t","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"      ; reason : Diff_versioned.Diff_error.t","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"      ; error_extra : (string * Yojson.Safe.t) list","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"      }","counters":[]},{"line":"  [@@deriving register_event { msg = \"Rejecting command because: $reason\" }]","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":27,"col_end":27,"count":3}]},{"line":"","counters":[]},{"line":"module type S = sig","counters":[]},{"line":"  open Intf","counters":[]},{"line":"","counters":[]},{"line":"  type transition_frontier","counters":[]},{"line":"","counters":[]},{"line":"  module Resource_pool : sig","counters":[]},{"line":"    include","counters":[]},{"line":"      Transaction_resource_pool_intf","counters":[]},{"line":"        with type transition_frontier := transition_frontier","counters":[]},{"line":"","counters":[]},{"line":"    module Diff :","counters":[]},{"line":"      Transaction_pool_diff_intf","counters":[]},{"line":"        with type resource_pool := t","counters":[]},{"line":"         and type Diff_error.t = Diff_versioned.Diff_error.t","counters":[]},{"line":"         and type Rejected.t = Diff_versioned.Rejected.t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  include","counters":[]},{"line":"    Network_pool_base_intf","counters":[]},{"line":"      with type resource_pool := Resource_pool.t","counters":[]},{"line":"       and type transition_frontier := transition_frontier","counters":[]},{"line":"       and type resource_pool_diff := Diff_versioned.t","counters":[]},{"line":"       and type resource_pool_diff_verified := Diff_versioned.verified","counters":[]},{"line":"       and type config := Resource_pool.Config.t","counters":[]},{"line":"       and type transition_frontier_diff :=","counters":[]},{"line":"        Resource_pool.transition_frontier_diff","counters":[]},{"line":"       and type rejected_diff := Diff_versioned.rejected","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(* Functor over user command, base ledger and transaction validator for","counters":[]},{"line":"   mocking. *)","counters":[]},{"line":"module Make0","counters":[]},{"line":"    (Base_ledger : Intf.Base_ledger_intf) (Staged_ledger : sig","counters":[]},{"line":"      type t","counters":[]},{"line":"","counters":[]},{"line":"      val ledger : t -> Base_ledger.t","counters":[]},{"line":"    end)","counters":[]},{"line":"    (Transition_frontier : Transition_frontier_intf","counters":[]},{"line":"                             with type staged_ledger := Staged_ledger.t) =","counters":[]},{"line":"struct","counters":[]},{"line":"  type verification_failure =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    | Command_failure of Diff_versioned.Diff_error.t","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"    | Invalid_failure of Verifier.invalid","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"  [@@deriving to_yojson]","counters":[]},{"line":"","counters":[]},{"line":"  module Breadcrumb = Transition_frontier.Breadcrumb","counters":[]},{"line":"","counters":[]},{"line":"  module Resource_pool = struct","counters":[]},{"line":"    type transition_frontier_diff =","counters":[]},{"line":"      Transition_frontier.best_tip_diff * Base_ledger.t","counters":[]},{"line":"","counters":[]},{"line":"    let label = \"transaction_pool\"","counters":[]},{"line":"","counters":[]},{"line":"    let preload_accounts ledger account_ids =","counters":[]},{"line":"      let existing_account_ids, existing_account_locs =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Set.to_list account_ids","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"        |> Base_ledger.location_of_account_batch ledger","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"        |> List.filter_map ~f:(function","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"             | id, Some loc ->","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                 Some (id, loc)","counters":[]},{"line":"             | _, None ->","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                 None )","counters":[]},{"line":"        |> List.unzip","counters":[]},{"line":"      in","counters":[]},{"line":"      Base_ledger.get_batch ledger existing_account_locs","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"      |> List.map ~f:snd","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"      |> List.zip_exn existing_account_ids","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"      |> List.fold ~init:Account_id.Map.empty ~f:(fun map (id, maybe_account) ->","counters":[]},{"line":"             let account =","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"               Option.value_exn maybe_account","counters":[]},{"line":"                 ~message:\"Somehow a public key has a location but no account\"","counters":[]},{"line":"             in","counters":[]},{"line":"             Map.add_exn map ~key:id ~data:account )","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"    module Config = struct","counters":[]},{"line":"      type t =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { trust_system : (Trust_system.t[@sexp.opaque])","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        ; pool_max_size : int","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              (* note this value needs to be mostly the same across gossipping nodes, so","counters":[]},{"line":"                 nodes with larger pools don't send nodes with smaller pools lots of","counters":[]},{"line":"                 low fee transactions the smaller-pooled nodes consider useless and get","counters":[]},{"line":"                 themselves banned.","counters":[]},{"line":"","counters":[]},{"line":"                 we offer this value separately from the one in genesis_constants, because","counters":[]},{"line":"                 we may wish a different value for testing","counters":[]},{"line":"              *)","counters":[]},{"line":"        ; verifier : (Verifier.t[@sexp.opaque])","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        ; genesis_constants : Genesis_constants.t","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        }","counters":[]},{"line":"      [@@deriving sexp_of, make]","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    let make_config = Config.make","counters":[]},{"line":"","counters":[]},{"line":"    module Batcher = Batcher.Transaction_pool","counters":[]},{"line":"","counters":[]},{"line":"    module Lru_cache = struct","counters":[]},{"line":"      let max_size = 2048","counters":[]},{"line":"","counters":[]},{"line":"      module T = struct","counters":[]},{"line":"        type t = User_command.t list [@@deriving hash]","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      module Q = Hash_queue.Make (Int)","counters":[]},{"line":"","counters":[]},{"line":"      type t = unit Q.t","counters":[]},{"line":"","counters":[]},{"line":"      let add t h =","counters":[]},{"line":"        if not (Q.mem t h) then (","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"          if Q.length t >= max_size then ignore (Q.dequeue_front t : 'a option) ;","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"          Q.enqueue_back_exn t h () ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          `Already_mem false )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        else (","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"          ignore (Q.lookup_and_move_to_back t h : unit option) ;","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"          `Already_mem true )","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Mutex = struct","counters":[]},{"line":"      open Async","counters":[]},{"line":"","counters":[]},{"line":"      type t = unit Mvar.Read_write.t","counters":[]},{"line":"","counters":[]},{"line":"      let acquire (t : t) = Mvar.take t","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"","counters":[]},{"line":"      let release (t : t) =","counters":[]},{"line":"        assert (Mvar.is_empty t) ;","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"        don't_wait_for (Mvar.put t ())","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"","counters":[]},{"line":"      let with_ t ~f =","counters":[]},{"line":"        let%bind () = acquire t in","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"        let%map x = f () in","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"        release t ; x","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":20,"col_end":20,"count":0}]},{"line":"","counters":[]},{"line":"      let create () =","counters":[]},{"line":"        let t = Mvar.create () in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        don't_wait_for (Mvar.put t ()) ;","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"        t","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    type t =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      { mutable pool : Indexed_pool.t","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"      ; recently_seen : (Lru_cache.t[@sexp.opaque])","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      ; locally_generated_uncommitted :","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ( Transaction_hash.User_command_with_valid_signature.t","counters":[]},{"line":"          , Time.t * [ `Batch of int ] )","counters":[]},{"line":"          Hashtbl.t","counters":[]},{"line":"            (** Commands generated on this machine, that are not included in the","counters":[]},{"line":"                current best tip, along with the time they were added. *)","counters":[]},{"line":"      ; locally_generated_committed :","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ( Transaction_hash.User_command_with_valid_signature.t","counters":[]},{"line":"          , Time.t * [ `Batch of int ] )","counters":[]},{"line":"          Hashtbl.t","counters":[]},{"line":"            (** Ones that are included in the current best tip. *)","counters":[]},{"line":"      ; mutable current_batch : int","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"      ; mutable remaining_in_batch : int","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"      ; config : Config.t","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      ; logger : (Logger.t[@sexp.opaque])","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      ; batcher : Batcher.t","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      ; mutable best_tip_diff_relay : (unit Deferred.t[@sexp.opaque]) Option.t","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"      ; mutable best_tip_ledger : (Base_ledger.t[@sexp.opaque]) Option.t","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"      }","counters":[]},{"line":"    [@@deriving sexp_of]","counters":[]},{"line":"","counters":[]},{"line":"    let member t x =","counters":[]},{"line":"      Indexed_pool.member t.pool (Transaction_hash.User_command.of_checked x)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":73,"col_end":73,"count":0}]},{"line":"","counters":[]},{"line":"    let transactions t = Indexed_pool.transactions ~logger:t.logger t.pool","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"    let all_from_account { pool; _ } = Indexed_pool.all_from_account pool","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"    let get_all { pool; _ } = Indexed_pool.get_all pool","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"","counters":[]},{"line":"    let find_by_hash x hash = Indexed_pool.find_by_hash x.pool hash","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"","counters":[]},{"line":"    (** Get the best tip ledger*)","counters":[]},{"line":"    let get_best_tip_ledger frontier =","counters":[]},{"line":"      Transition_frontier.best_tip frontier","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"      |> Breadcrumb.staged_ledger |> Staged_ledger.ledger","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"","counters":[]},{"line":"    let drop_until_below_max_size :","counters":[]},{"line":"           pool_max_size:int","counters":[]},{"line":"        -> Indexed_pool.t","counters":[]},{"line":"        -> Indexed_pool.t","counters":[]},{"line":"           * Transaction_hash.User_command_with_valid_signature.t Sequence.t =","counters":[]},{"line":"     fun ~pool_max_size pool ->","counters":[]},{"line":"      let rec go pool' dropped =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        if Indexed_pool.size pool' > pool_max_size then (","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"          let dropped', pool'' = Indexed_pool.remove_lowest_fee pool' in","counters":[]},{"line":"          assert (not (Sequence.is_empty dropped')) ;","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"          go pool'' @@ Sequence.append dropped dropped' )","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"        else (pool', dropped)","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"      in","counters":[]},{"line":"      go pool @@ Sequence.empty","counters":[]},{"line":"","counters":[]},{"line":"    let has_sufficient_fee ~pool_max_size pool cmd : bool =","counters":[]},{"line":"      match Indexed_pool.min_fee pool with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          true","counters":[]},{"line":"      | Some min_fee ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          if Indexed_pool.size pool >= pool_max_size then","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"            Currency.Fee_rate.(User_command.fee_per_wu cmd > min_fee)","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"          else true","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"","counters":[]},{"line":"    let diff_error_of_indexed_pool_error :","counters":[]},{"line":"        Indexed_pool.Command_error.t -> Diff_versioned.Diff_error.t = function","counters":[]},{"line":"      | Invalid_nonce _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Invalid_nonce","counters":[]},{"line":"      | Insufficient_funds _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Insufficient_funds","counters":[]},{"line":"      | Insufficient_replace_fee _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Insufficient_replace_fee","counters":[]},{"line":"      | Overflow ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Overflow","counters":[]},{"line":"      | Bad_token ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Bad_token","counters":[]},{"line":"      | Unwanted_fee_token _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Unwanted_fee_token","counters":[]},{"line":"      | Expired _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Expired","counters":[]},{"line":"","counters":[]},{"line":"    let indexed_pool_error_metadata = function","counters":[]},{"line":"      | Indexed_pool.Command_error.Invalid_nonce (`Between (low, hi), nonce) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let nonce_json = Account.Nonce.to_yojson in","counters":[]},{"line":"          [ ( \"between\"","counters":[]},{"line":"            , `Assoc [ (\"low\", nonce_json low); (\"hi\", nonce_json hi) ] )","counters":[{"col_start":40,"col_end":40,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"          ; (\"nonce\", nonce_json nonce)","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"          ]","counters":[]},{"line":"      | Invalid_nonce (`Expected enonce, nonce) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let nonce_json = Account.Nonce.to_yojson in","counters":[]},{"line":"          [ (\"expected_nonce\", nonce_json enonce); (\"nonce\", nonce_json nonce) ]","counters":[{"col_start":40,"col_end":40,"count":0},{"col_start":70,"col_end":70,"count":0}]},{"line":"      | Insufficient_funds (`Balance bal, amt) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let amt_json = Currency.Amount.to_yojson in","counters":[]},{"line":"","counters":[]},{"line":"          [ (\"balance\", amt_json bal); (\"amount\", amt_json amt) ]","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"      | Insufficient_replace_fee (`Replace_fee rfee, fee) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let fee_json = Currency.Fee.to_yojson in","counters":[]},{"line":"          [ (\"replace_fee\", fee_json rfee); (\"fee\", fee_json fee) ]","counters":[{"col_start":35,"col_end":35,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"      | Overflow ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          []","counters":[]},{"line":"      | Bad_token ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          []","counters":[]},{"line":"      | Unwanted_fee_token fee_token ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          [ (\"fee_token\", Token_id.to_yojson fee_token) ]","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"      | Expired","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ( `Valid_until valid_until","counters":[]},{"line":"          , `Global_slot_since_genesis global_slot_since_genesis ) ->","counters":[]},{"line":"          [ (\"valid_until\", Mina_numbers.Global_slot.to_yojson valid_until)","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"          ; ( \"current_global_slot\"","counters":[]},{"line":"            , Mina_numbers.Global_slot.to_yojson global_slot_since_genesis )","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"          ]","counters":[]},{"line":"      | Expired","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ( `Timestamp_predicate expiry_ns","counters":[]},{"line":"          , `Global_slot_since_genesis global_slot_since_genesis ) ->","counters":[]},{"line":"          [ (\"expiry_ns\", `String expiry_ns)","counters":[]},{"line":"          ; ( \"current_global_slot\"","counters":[]},{"line":"            , Mina_numbers.Global_slot.to_yojson global_slot_since_genesis )","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"          ]","counters":[]},{"line":"","counters":[]},{"line":"    let indexed_pool_error_log_info e =","counters":[]},{"line":"      ( Diff_versioned.Diff_error.to_string_name","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"          (diff_error_of_indexed_pool_error e)","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"      , indexed_pool_error_metadata e )","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"","counters":[]},{"line":"    let handle_transition_frontier_diff","counters":[]},{"line":"        ( ({ new_commands; removed_commands; reorg_best_tip = _ } :","counters":[]},{"line":"            Transition_frontier.best_tip_diff )","counters":[]},{"line":"        , best_tip_ledger ) t =","counters":[]},{"line":"      (* This runs whenever the best tip changes. The simple case is when the","counters":[]},{"line":"         new best tip is an extension of the old one. There, we just remove any","counters":[]},{"line":"         user commands that were included in it from the transaction pool.","counters":[]},{"line":"         Dealing with a fork is more intricate. In general we want to remove any","counters":[]},{"line":"         commands from the pool that are included in the new best tip; and add","counters":[]},{"line":"         any commands to the pool that were included in the old one but not the","counters":[]},{"line":"         new one, provided they are still valid against the ledger of the best","counters":[]},{"line":"         tip. The goal is that transactions are carried from losing forks to","counters":[]},{"line":"         winning ones as much as possible.","counters":[]},{"line":"","counters":[]},{"line":"         The locally generated commands need to move from","counters":[]},{"line":"         locally_generated_uncommitted to locally_generated_committed and vice","counters":[]},{"line":"         versa so those hashtables remain in sync with reality.","counters":[]},{"line":"      *)","counters":[]},{"line":"      let global_slot = Indexed_pool.global_slot_since_genesis t.pool in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      t.best_tip_ledger <- Some best_tip_ledger ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let pool_max_size = t.config.pool_max_size in","counters":[]},{"line":"      let log_indexed_pool_error error_str ~metadata cmd =","counters":[]},{"line":"        [%log' debug t.logger]","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"          \"Couldn't re-add locally generated command $cmd, not valid against \\","counters":[]},{"line":"           new ledger. Error: $error\"","counters":[]},{"line":"          ~metadata:","counters":[]},{"line":"            ( [ ( \"cmd\"","counters":[]},{"line":"                , Transaction_hash.User_command_with_valid_signature.to_yojson","counters":[{"col_start":77,"col_end":77,"count":0}]},{"line":"                    cmd )","counters":[]},{"line":"              ; (\"error\", `String error_str)","counters":[]},{"line":"              ]","counters":[]},{"line":"            @ metadata )","counters":[]},{"line":"      in","counters":[]},{"line":"      [%log' trace t.logger]","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"        ~metadata:","counters":[]},{"line":"          [ ( \"removed\"","counters":[]},{"line":"            , `List","counters":[]},{"line":"                (List.map removed_commands","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                   ~f:(With_status.to_yojson User_command.Valid.to_yojson) ) )","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"          ; ( \"added\"","counters":[]},{"line":"            , `List","counters":[]},{"line":"                (List.map new_commands","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                   ~f:(With_status.to_yojson User_command.Valid.to_yojson) ) )","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"          ]","counters":[]},{"line":"        \"Diff: removed: $removed added: $added from best tip\" ;","counters":[]},{"line":"      let pool', dropped_backtrack =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        List.fold (List.rev removed_commands) ~init:(t.pool, Sequence.empty)","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"          ~f:(fun (pool, dropped_so_far) unhashed_cmd ->","counters":[]},{"line":"            let cmd =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Transaction_hash.User_command_with_valid_signature.create","counters":[]},{"line":"                unhashed_cmd.data","counters":[]},{"line":"            in","counters":[]},{"line":"            ( match","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"                Hashtbl.find_and_remove t.locally_generated_committed cmd","counters":[]},{"line":"              with","counters":[]},{"line":"            | None ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ()","counters":[]},{"line":"            | Some time_added ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                [%log' info t.logger]","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"                  \"Locally generated command $cmd committed in a block!\"","counters":[]},{"line":"                  ~metadata:","counters":[]},{"line":"                    [ ( \"cmd\"","counters":[]},{"line":"                      , With_status.to_yojson User_command.Valid.to_yojson","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"                          unhashed_cmd )","counters":[]},{"line":"                    ] ;","counters":[]},{"line":"                Hashtbl.add_exn t.locally_generated_uncommitted ~key:cmd","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"                  ~data:time_added ) ;","counters":[]},{"line":"            let pool', dropped_seq =","counters":[]},{"line":"              match cmd |> Indexed_pool.add_from_backtrack pool with","counters":[]},{"line":"              | Error e ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  let error_str, metadata = indexed_pool_error_log_info e in","counters":[]},{"line":"                  log_indexed_pool_error error_str ~metadata cmd ;","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  (pool, Sequence.empty)","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"              | Ok indexed_pool ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  drop_until_below_max_size ~pool_max_size indexed_pool","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"            in","counters":[]},{"line":"            (pool', Sequence.append dropped_so_far dropped_seq) )","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"      in","counters":[]},{"line":"      (* Track what locally generated commands were removed from the pool","counters":[]},{"line":"         during backtracking due to the max size constraint. *)","counters":[]},{"line":"      let locally_generated_dropped =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Sequence.filter dropped_backtrack","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"          ~f:(Hashtbl.mem t.locally_generated_uncommitted)","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"        |> Sequence.to_list_rev","counters":[]},{"line":"      in","counters":[]},{"line":"      if not (List.is_empty locally_generated_dropped) then","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"        [%log' debug t.logger]","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"          \"Dropped locally generated commands $cmds during backtracking to \\","counters":[]},{"line":"           maintain max size. Will attempt to re-add after forwardtracking.\"","counters":[]},{"line":"          ~metadata:","counters":[]},{"line":"            [ ( \"cmds\"","counters":[]},{"line":"              , `List","counters":[]},{"line":"                  (List.map","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                     ~f:","counters":[]},{"line":"                       Transaction_hash.User_command_with_valid_signature","counters":[]},{"line":"                       .to_yojson locally_generated_dropped ) )","counters":[]},{"line":"            ] ;","counters":[]},{"line":"      let pool'', dropped_commands =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let accounts_to_check =","counters":[]},{"line":"          List.fold (new_commands @ removed_commands) ~init:Account_id.Set.empty","counters":[]},{"line":"            ~f:(fun set cmd ->","counters":[]},{"line":"              let set' =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                With_status.data cmd |> User_command.forget_check","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"                |> User_command.accounts_referenced |> Account_id.Set.of_list","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"              in","counters":[]},{"line":"              Set.union set set' )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"        in","counters":[]},{"line":"        let get_account =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let account_state (account : Account.t) =","counters":[]},{"line":"            ( account.nonce","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            , Currency.Amount.of_uint64","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"              @@ Currency.Balance.to_uint64 account.balance )","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"          in","counters":[]},{"line":"          let empty_state = (Account.Nonce.zero, Currency.Amount.zero) in","counters":[]},{"line":"          let existing_account_states_by_id =","counters":[]},{"line":"            preload_accounts best_tip_ledger accounts_to_check","counters":[]},{"line":"          in","counters":[]},{"line":"          fun id ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            match Map.find existing_account_states_by_id id with","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            | Some account ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                account_state account","counters":[]},{"line":"            | None ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                if Set.mem accounts_to_check id then empty_state","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"                else","counters":[]},{"line":"                  failwith","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    \"did not expect Indexed_pool.revalidate to call \\","counters":[]},{"line":"                     get_account on account not in accounts_to_check\"","counters":[]},{"line":"        in","counters":[]},{"line":"        Indexed_pool.revalidate pool' ~logger:t.logger","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"          (`Subset accounts_to_check) get_account","counters":[]},{"line":"      in","counters":[]},{"line":"      let committed_commands, dropped_commit_conflicts =","counters":[]},{"line":"        let command_hashes =","counters":[]},{"line":"          List.fold_left new_commands ~init:Transaction_hash.Set.empty","counters":[]},{"line":"            ~f:(fun set cmd ->","counters":[]},{"line":"              let cmd_hash =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                With_status.data cmd","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                |> Transaction_hash.User_command_with_valid_signature.create","counters":[{"col_start":75,"col_end":75,"count":0}]},{"line":"                |> Transaction_hash.User_command_with_valid_signature.hash","counters":[]},{"line":"              in","counters":[]},{"line":"              Set.add set cmd_hash )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"        in","counters":[]},{"line":"        Sequence.to_list dropped_commands","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"        |> List.partition_tf ~f:(fun cmd ->","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"               Set.mem command_hashes","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                 (Transaction_hash.User_command_with_valid_signature.hash cmd) )","counters":[{"col_start":72,"col_end":72,"count":0}]},{"line":"      in","counters":[]},{"line":"      List.iter committed_commands ~f:(fun cmd ->","counters":[]},{"line":"          Hashtbl.find_and_remove t.locally_generated_uncommitted cmd","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"          |> Option.iter ~f:(fun data ->","counters":[]},{"line":"                 Hashtbl.add_exn t.locally_generated_committed ~key:cmd ~data ) ) ;","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"      let commit_conflicts_locally_generated =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        List.filter dropped_commit_conflicts ~f:(fun cmd ->","counters":[]},{"line":"            Hashtbl.find_and_remove t.locally_generated_uncommitted cmd","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"            |> Option.is_some )","counters":[]},{"line":"      in","counters":[]},{"line":"      if not @@ List.is_empty commit_conflicts_locally_generated then","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"        [%log' info t.logger]","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"          \"Locally generated commands $cmds dropped because they conflicted \\","counters":[]},{"line":"           with a committed command.\"","counters":[]},{"line":"          ~metadata:","counters":[]},{"line":"            [ ( \"cmds\"","counters":[]},{"line":"              , `List","counters":[]},{"line":"                  (List.map commit_conflicts_locally_generated","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                     ~f:","counters":[]},{"line":"                       Transaction_hash.User_command_with_valid_signature","counters":[]},{"line":"                       .to_yojson ) )","counters":[]},{"line":"            ] ;","counters":[]},{"line":"      [%log' debug t.logger]","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"        !\"Finished handling diff. Old pool size %i, new pool size %i. Dropped \\","counters":[]},{"line":"          %i commands during backtracking to maintain max size.\"","counters":[]},{"line":"        (Indexed_pool.size t.pool) (Indexed_pool.size pool'')","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"        (Sequence.length dropped_backtrack) ;","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"      Mina_metrics.(","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Gauge.set Transaction_pool.pool_size","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"          (Float.of_int (Indexed_pool.size pool''))) ;","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"      t.pool <- pool'' ;","counters":[]},{"line":"      List.iter locally_generated_dropped ~f:(fun cmd ->","counters":[]},{"line":"          (* If the dropped transaction was included in the winning chain, it'll","counters":[]},{"line":"             be in locally_generated_committed. If it wasn't, try re-adding to","counters":[]},{"line":"             the pool. *)","counters":[]},{"line":"          let remove_cmd () =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            assert (","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"              Option.is_some","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"              @@ Hashtbl.find_and_remove t.locally_generated_uncommitted cmd )","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"          in","counters":[]},{"line":"          let log_and_remove ?(metadata = []) error_str =","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"            log_indexed_pool_error error_str ~metadata cmd ;","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            remove_cmd ()","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          in","counters":[]},{"line":"          if not (Hashtbl.mem t.locally_generated_committed cmd) then","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"            if","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              not","counters":[]},{"line":"                (has_sufficient_fee t.pool","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"                   (Transaction_hash.User_command_with_valid_signature.command","counters":[{"col_start":77,"col_end":77,"count":0}]},{"line":"                      cmd )","counters":[]},{"line":"                   ~pool_max_size )","counters":[]},{"line":"            then (","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"              [%log' info t.logger]","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"                \"Not re-adding locally generated command $cmd to pool, \\","counters":[]},{"line":"                 insufficient fee\"","counters":[]},{"line":"                ~metadata:","counters":[]},{"line":"                  [ ( \"cmd\"","counters":[]},{"line":"                    , Transaction_hash.User_command_with_valid_signature","counters":[]},{"line":"                      .to_yojson cmd )","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                  ] ;","counters":[]},{"line":"              remove_cmd () )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"            else","counters":[]},{"line":"              let unchecked =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Transaction_hash.User_command_with_valid_signature.command cmd","counters":[]},{"line":"              in","counters":[]},{"line":"              match","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Option.bind","counters":[]},{"line":"                  (Base_ledger.location_of_account best_tip_ledger","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"                     (User_command.fee_payer unchecked) )","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"                  ~f:(Base_ledger.get best_tip_ledger)","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"              with","counters":[]},{"line":"              | Some acct -> (","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  match","counters":[]},{"line":"                    Indexed_pool.add_from_gossip_exn t.pool cmd acct.nonce","counters":[]},{"line":"                      ( Account.liquid_balance_at_slot ~global_slot acct","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"                      |> Currency.Balance.to_amount )","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                  with","counters":[]},{"line":"                  | Error e ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      let error_str, metadata = indexed_pool_error_log_info e in","counters":[]},{"line":"                      log_and_remove error_str","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        ~metadata:","counters":[]},{"line":"                          ( (\"user_command\", User_command.to_yojson unchecked)","counters":[{"col_start":66,"col_end":66,"count":0}]},{"line":"                          :: metadata )","counters":[]},{"line":"                  | Ok (_, pool''', _) ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      [%log' debug t.logger]","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"                        \"re-added locally generated command $cmd to \\","counters":[]},{"line":"                         transaction pool after reorg\"","counters":[]},{"line":"                        ~metadata:","counters":[]},{"line":"                          [ ( \"cmd\"","counters":[]},{"line":"                            , Transaction_hash.User_command_with_valid_signature","counters":[]},{"line":"                              .to_yojson cmd )","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"                          ] ;","counters":[]},{"line":"                      Mina_metrics.(","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        Gauge.set Transaction_pool.pool_size","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                          (Float.of_int (Indexed_pool.size pool'''))) ;","counters":[{"col_start":38,"col_end":38,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"                      t.pool <- pool''' )","counters":[]},{"line":"              | None ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  log_and_remove \"Fee_payer_account not found\"","counters":[]},{"line":"                    ~metadata:","counters":[]},{"line":"                      [ (\"user_command\", User_command.to_yojson unchecked) ] ) ;","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"      (*Remove any expired user commands*)","counters":[]},{"line":"      let expired_commands, pool = Indexed_pool.remove_expired t.pool in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Sequence.iter expired_commands ~f:(fun cmd ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          [%log' debug t.logger]","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"            \"Dropping expired user command from the pool $cmd\"","counters":[]},{"line":"            ~metadata:","counters":[]},{"line":"              [ ( \"cmd\"","counters":[]},{"line":"                , Transaction_hash.User_command_with_valid_signature.to_yojson","counters":[{"col_start":77,"col_end":77,"count":0}]},{"line":"                    cmd )","counters":[]},{"line":"              ] ;","counters":[]},{"line":"          ignore","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ( Hashtbl.find_and_remove t.locally_generated_uncommitted cmd","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"              : (Time.t * [ `Batch of int ]) option ) ) ;","counters":[]},{"line":"      Mina_metrics.(","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Gauge.set Transaction_pool.pool_size","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"          (Float.of_int (Indexed_pool.size pool))) ;","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"      t.pool <- pool ;","counters":[]},{"line":"      Deferred.unit","counters":[]},{"line":"","counters":[]},{"line":"    let create ~constraint_constants ~consensus_constants ~time_controller","counters":[]},{"line":"        ~expiry_ns ~frontier_broadcast_pipe ~config ~logger ~tf_diff_writer =","counters":[]},{"line":"      let t =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { pool =","counters":[]},{"line":"            Indexed_pool.empty ~constraint_constants ~consensus_constants","counters":[]},{"line":"              ~time_controller ~expiry_ns","counters":[]},{"line":"        ; locally_generated_uncommitted =","counters":[]},{"line":"            Hashtbl.create","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"              ( module Transaction_hash.User_command_with_valid_signature.Stable","counters":[]},{"line":"                       .Latest )","counters":[]},{"line":"        ; locally_generated_committed =","counters":[]},{"line":"            Hashtbl.create","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"              ( module Transaction_hash.User_command_with_valid_signature.Stable","counters":[]},{"line":"                       .Latest )","counters":[]},{"line":"        ; current_batch = 0","counters":[]},{"line":"        ; remaining_in_batch = max_per_15_seconds","counters":[]},{"line":"        ; config","counters":[]},{"line":"        ; logger","counters":[]},{"line":"        ; batcher = Batcher.create config.verifier","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"        ; best_tip_diff_relay = None","counters":[]},{"line":"        ; recently_seen = Lru_cache.Q.create ()","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"        ; best_tip_ledger = None","counters":[]},{"line":"        }","counters":[]},{"line":"      in","counters":[]},{"line":"      don't_wait_for","counters":[]},{"line":"        (Broadcast_pipe.Reader.iter frontier_broadcast_pipe","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"           ~f:(fun frontier_opt ->","counters":[]},{"line":"             match frontier_opt with","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"             | None -> (","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                 [%log debug] \"no frontier\" ;","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                 t.best_tip_ledger <- None ;","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                 (* Sanity check: the view pipe should have been closed before","counters":[]},{"line":"                    the frontier was destroyed. *)","counters":[]},{"line":"                 match t.best_tip_diff_relay with","counters":[]},{"line":"                 | None ->","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"                     Deferred.unit","counters":[]},{"line":"                 | Some hdl ->","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"                     let is_finished = ref false in","counters":[]},{"line":"                     Deferred.any_unit","counters":[]},{"line":"                       [ (let%map () = hdl in","counters":[]},{"line":"                          t.best_tip_diff_relay <- None ;","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                          is_finished := true )","counters":[]},{"line":"                       ; (let%map () = Async.after (Time.Span.of_sec 5.) in","counters":[{"col_start":49,"col_end":49,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"                          if not !is_finished then (","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"                            [%log fatal]","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"                              \"Transition frontier closed without first \\","counters":[]},{"line":"                               closing best tip view pipe\" ;","counters":[]},{"line":"                            assert false )","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                          else () )","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                       ] )","counters":[]},{"line":"             | Some frontier ->","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                 [%log debug] \"Got frontier!\" ;","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                 let validation_ledger = get_best_tip_ledger frontier in","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                 (* update our cache *)","counters":[]},{"line":"                 t.best_tip_ledger <- Some validation_ledger ;","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                 (* The frontier has changed, so transactions in the pool may","counters":[]},{"line":"                    not be valid against the current best tip. *)","counters":[]},{"line":"                 let global_slot =","counters":[]},{"line":"                   Indexed_pool.global_slot_since_genesis t.pool","counters":[]},{"line":"                 in","counters":[]},{"line":"                 let new_pool, dropped =","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                   Indexed_pool.revalidate t.pool ~logger:t.logger `Entire_pool","counters":[]},{"line":"                     (fun sender ->","counters":[]},{"line":"                       match","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                         Base_ledger.location_of_account validation_ledger","counters":[]},{"line":"                           sender","counters":[]},{"line":"                       with","counters":[]},{"line":"                       | None ->","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                           (Account.Nonce.zero, Currency.Amount.zero)","counters":[]},{"line":"                       | Some loc ->","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                           let acc =","counters":[]},{"line":"                             Option.value_exn","counters":[]},{"line":"                               ~message:","counters":[]},{"line":"                                 \"Somehow a public key has a location but no \\","counters":[]},{"line":"                                  account\"","counters":[]},{"line":"                               (Base_ledger.get validation_ledger loc)","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"                           in","counters":[]},{"line":"                           ( acc.nonce","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                           , Account.liquid_balance_at_slot ~global_slot acc","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"                             |> Currency.Balance.to_amount ) )","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"                 in","counters":[]},{"line":"                 let dropped_locally_generated =","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                   Sequence.filter dropped ~f:(fun cmd ->","counters":[]},{"line":"                       let find_remove_bool tbl =","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                         Hashtbl.find_and_remove tbl cmd |> Option.is_some","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"                       in","counters":[]},{"line":"                       let dropped_committed =","counters":[]},{"line":"                         find_remove_bool t.locally_generated_committed","counters":[]},{"line":"                       in","counters":[]},{"line":"                       let dropped_uncommitted =","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                         find_remove_bool t.locally_generated_uncommitted","counters":[]},{"line":"                       in","counters":[]},{"line":"                       (* Nothing should be in both tables. *)","counters":[]},{"line":"                       assert (not (dropped_committed && dropped_uncommitted)) ;","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"                       dropped_committed || dropped_uncommitted )","counters":[{"col_start":39,"col_end":39,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"                 in","counters":[]},{"line":"                 (* In this situation we don't know whether the commands aren't","counters":[]},{"line":"                    valid against the new ledger because they were already","counters":[]},{"line":"                    committed or because they conflict with others,","counters":[]},{"line":"                    unfortunately. *)","counters":[]},{"line":"                 if not (Sequence.is_empty dropped_locally_generated) then","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"                   [%log info]","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"                     \"Dropped locally generated commands $cmds from pool when \\","counters":[]},{"line":"                      transition frontier was recreated.\"","counters":[]},{"line":"                     ~metadata:","counters":[]},{"line":"                       [ ( \"cmds\"","counters":[]},{"line":"                         , `List","counters":[]},{"line":"                             (List.map","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                                (Sequence.to_list dropped_locally_generated)","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"                                ~f:","counters":[]},{"line":"                                  Transaction_hash","counters":[]},{"line":"                                  .User_command_with_valid_signature","counters":[]},{"line":"                                  .to_yojson ) )","counters":[]},{"line":"                       ] ;","counters":[]},{"line":"                 [%log debug]","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"                   !\"Re-validated transaction pool after restart: dropped %i \\","counters":[]},{"line":"                     of %i previously in pool\"","counters":[]},{"line":"                   (Sequence.length dropped) (Indexed_pool.size t.pool) ;","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"                 Mina_metrics.(","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                   Gauge.set Transaction_pool.pool_size","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                     (Float.of_int (Indexed_pool.size new_pool))) ;","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"                 t.pool <- new_pool ;","counters":[]},{"line":"                 t.best_tip_diff_relay <-","counters":[]},{"line":"                   Some","counters":[]},{"line":"                     (Broadcast_pipe.Reader.iter","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"                        (Transition_frontier.best_tip_diff_pipe frontier)","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"                        ~f:(fun diff ->","counters":[]},{"line":"                          Strict_pipe.Writer.write tf_diff_writer","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"                            (diff, get_best_tip_ledger frontier)","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"                          |> Deferred.don't_wait_for ;","counters":[]},{"line":"                          Deferred.unit ) ) ;","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                 Deferred.unit ) ) ;","counters":[]},{"line":"      t","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    type pool = t","counters":[]},{"line":"","counters":[]},{"line":"    module Diff = struct","counters":[]},{"line":"      type t = User_command.t list [@@deriving sexp, yojson]","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"","counters":[]},{"line":"      type _unused = unit constraint t = Diff_versioned.t","counters":[]},{"line":"","counters":[]},{"line":"      module Diff_error = struct","counters":[]},{"line":"        type t = Diff_versioned.Diff_error.t =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (*Indexed_pool*)","counters":[]},{"line":"          | Insufficient_replace_fee","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          (*apply*)","counters":[]},{"line":"          | Duplicate","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          (*Indexed_pool*)","counters":[]},{"line":"          | Invalid_nonce","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          (*Indexed_pool*)","counters":[]},{"line":"          | Insufficient_funds","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          (*Indexed_pool*)","counters":[]},{"line":"          | Overflow","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          (*Indexed_pool*)","counters":[]},{"line":"          | Bad_token","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          (*Indexed_pool*)","counters":[]},{"line":"          | Unwanted_fee_token","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          (*Indexed_pool*)","counters":[]},{"line":"          | Expired","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          (*Sink*)","counters":[]},{"line":"          | Overloaded","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          (*apply*)","counters":[]},{"line":"          | Fee_payer_account_not_found","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | Fee_payer_not_permitted_to_send","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        [@@deriving sexp, yojson, compare]","counters":[]},{"line":"","counters":[]},{"line":"        let to_string_hum = Diff_versioned.Diff_error.to_string_hum","counters":[]},{"line":"","counters":[]},{"line":"        let grounds_for_diff_rejection = function","counters":[]},{"line":"          | Expired","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          | Invalid_nonce","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          | Insufficient_funds","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          | Insufficient_replace_fee","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          | Duplicate","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          | Overloaded","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          | Fee_payer_account_not_found","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          | Fee_payer_not_permitted_to_send ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              false","counters":[]},{"line":"          | Overflow | Bad_token | Unwanted_fee_token ->","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"              true","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      module Rejected = struct","counters":[]},{"line":"        type t = (User_command.t * Diff_error.t) list","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":46,"col_end":46,"count":0},{"col_start":49,"col_end":49,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"        [@@deriving sexp, yojson, compare]","counters":[]},{"line":"","counters":[]},{"line":"        type _unused = unit constraint t = Diff_versioned.Rejected.t","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      type rejected = Rejected.t [@@deriving sexp, yojson, compare]","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"      type verified = Diff_versioned.verified [@@deriving sexp, to_yojson]","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"      let reject_overloaded_diff (diff : verified) : rejected =","counters":[]},{"line":"        List.map diff ~f:(fun cmd ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            ( Transaction_hash.User_command_with_valid_signature.command cmd","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"            , Diff_error.Overloaded ) )","counters":[]},{"line":"","counters":[]},{"line":"      let empty = []","counters":[]},{"line":"","counters":[]},{"line":"      let size = List.length","counters":[]},{"line":"","counters":[]},{"line":"      let score x = Int.max 1 (List.length x)","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"","counters":[]},{"line":"      let max_per_15_seconds = max_per_15_seconds","counters":[]},{"line":"","counters":[]},{"line":"      let summary t =","counters":[]},{"line":"        Printf.sprintf \"Transaction diff of length %d\" (List.length t)","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"","counters":[]},{"line":"      let is_empty t = List.is_empty t","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"      let log_and_punish ?(punish = true) t d e =","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"        let sender = Envelope.Incoming.sender d in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let trust_record =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Trust_system.record_envelope_sender t.config.trust_system t.logger","counters":[]},{"line":"            sender","counters":[]},{"line":"        in","counters":[]},{"line":"        let is_local = Envelope.Sender.(equal Local sender) in","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"        let metadata =","counters":[]},{"line":"          [ (\"error\", Error_json.error_to_yojson e)","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"          ; (\"sender\", Envelope.Sender.to_yojson sender)","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"          ]","counters":[]},{"line":"        in","counters":[]},{"line":"        [%log' error t.logger] ~metadata","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"          \"Error verifying transaction pool diff from $sender: $error\" ;","counters":[]},{"line":"        if punish && not is_local then","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"          (* TODO: Make this error more specific (could also be a bad signature). *)","counters":[]},{"line":"          trust_record","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ( Trust_system.Actions.Sent_invalid_proof","counters":[]},{"line":"            , Some (\"Error verifying transaction pool diff: $error\", metadata)","counters":[]},{"line":"            )","counters":[]},{"line":"        else Deferred.return ()","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"      let of_indexed_pool_error e =","counters":[]},{"line":"        (diff_error_of_indexed_pool_error e, indexed_pool_error_metadata e)","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"","counters":[]},{"line":"      let report_command_error ~logger ~is_sender_local tx","counters":[]},{"line":"          (e : Indexed_pool.Command_error.t) =","counters":[]},{"line":"        let diff_err, error_extra = of_indexed_pool_error e in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        if is_sender_local then","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          [%str_log error]","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"            (Rejecting_command_for_reason","counters":[]},{"line":"               { command = tx; reason = diff_err; error_extra } ) ;","counters":[]},{"line":"        let log = if is_sender_local then [%log error] else [%log debug] in","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":42,"col_end":42,"count":0},{"col_start":53,"col_end":53,"count":0},{"col_start":60,"col_end":60,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"        match e with","counters":[]},{"line":"        | Insufficient_replace_fee (`Replace_fee rfee, fee) ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            log","counters":[]},{"line":"              \"rejecting $cmd because of insufficient replace fee ($rfee > \\","counters":[]},{"line":"               $fee)\"","counters":[]},{"line":"              ~metadata:","counters":[]},{"line":"                [ (\"cmd\", User_command.to_yojson tx)","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"                ; (\"rfee\", Currency.Fee.to_yojson rfee)","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"                ; (\"fee\", Currency.Fee.to_yojson fee)","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"                ]","counters":[]},{"line":"        | Unwanted_fee_token fee_token ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            log \"rejecting $cmd because we don't accept fees in $token\"","counters":[]},{"line":"              ~metadata:","counters":[]},{"line":"                [ (\"cmd\", User_command.to_yojson tx)","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"                ; (\"token\", Token_id.to_yojson fee_token)","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"                ]","counters":[]},{"line":"        | _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ()","counters":[]},{"line":"","counters":[]},{"line":"      let verify (t : pool) (diff : t Envelope.Incoming.t) :","counters":[]},{"line":"          verified Envelope.Incoming.t Deferred.Or_error.t =","counters":[]},{"line":"        let open Deferred.Or_error.Let_syntax in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let ok_if_true cond ~error =","counters":[]},{"line":"          Deferred.return","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (Result.ok_if_true cond ~error:(Error.of_string error))","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"        in","counters":[]},{"line":"        let is_sender_local =","counters":[]},{"line":"          Envelope.Sender.(equal Local) (Envelope.Incoming.sender diff)","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"        in","counters":[]},{"line":"        let%bind () =","counters":[]},{"line":"          (* TODO: we should probably remove this -- the libp2p gossip cache should cover this already (#11704) *)","counters":[]},{"line":"          let (`Already_mem already_mem) =","counters":[]},{"line":"            Lru_cache.add t.recently_seen (Lru_cache.T.hash diff.data)","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"          in","counters":[]},{"line":"          ok_if_true","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"            (not (already_mem && not is_sender_local))","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"            ~error:\"Recently seen\"","counters":[]},{"line":"        in","counters":[]},{"line":"        let%bind () =","counters":[]},{"line":"          let cmds_with_insufficient_fees =","counters":[]},{"line":"            List.filter","counters":[]},{"line":"              (Envelope.Incoming.data diff)","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"              ~f:User_command.has_insufficient_fee","counters":[]},{"line":"          in","counters":[]},{"line":"          List.iter cmds_with_insufficient_fees ~f:(fun cmd ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              [%log' debug t.logger]","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"                \"User command $cmd from $sender has insufficient fee.\"","counters":[]},{"line":"                ~metadata:","counters":[]},{"line":"                  [ (\"cmd\", User_command.to_yojson cmd)","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"                  ; ( \"sender\"","counters":[]},{"line":"                    , Envelope.(Sender.to_yojson (Incoming.sender diff)) )","counters":[{"col_start":47,"col_end":47,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"                  ] ) ;","counters":[]},{"line":"          let too_big_cmds =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            List.filter (Envelope.Incoming.data diff) ~f:(fun cmd ->","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"                let size_validity =","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  User_command.valid_size","counters":[]},{"line":"                    ~genesis_constants:t.config.genesis_constants cmd","counters":[]},{"line":"                in","counters":[]},{"line":"                match size_validity with","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                | Ok () ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    false","counters":[]},{"line":"                | Error err ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    [%log' debug t.logger] \"User command is too big\"","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"                      ~metadata:","counters":[]},{"line":"                        [ (\"cmd\", User_command.to_yojson cmd)","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"                        ; ( \"sender\"","counters":[]},{"line":"                          , Envelope.(Sender.to_yojson (Incoming.sender diff))","counters":[{"col_start":53,"col_end":53,"count":0},{"col_start":70,"col_end":70,"count":0}]},{"line":"                          )","counters":[]},{"line":"                        ; (\"size_violation\", Error_json.error_to_yojson err)","counters":[{"col_start":70,"col_end":70,"count":0}]},{"line":"                        ] ;","counters":[]},{"line":"                    true )","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"          in","counters":[]},{"line":"          let sufficient_fees = List.is_empty cmds_with_insufficient_fees in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let valid_sizes = List.is_empty too_big_cmds in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          match (sufficient_fees, valid_sizes) with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | true, true ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Deferred.Or_error.return ()","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"          | false, true ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Deferred.Or_error.fail","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"              @@ Error.of_string \"Some commands have an insufficient fee\"","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"          | true, false ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Deferred.Or_error.fail","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"              @@ Error.of_string \"Some commands are too big\"","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"          | false, false ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Deferred.Or_error.fail","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"              @@ Error.of_string","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                   \"Some commands have an insufficient fee, and some are too \\","counters":[]},{"line":"                    big\"","counters":[]},{"line":"        in","counters":[]},{"line":"        (* TODO: batch `to_verifiable` (#11705) *)","counters":[]},{"line":"        let%bind ledger =","counters":[]},{"line":"          match t.best_tip_ledger with","counters":[]},{"line":"          | Some ledger ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              return ledger","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Deferred.Or_error.error_string","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"                \"We don't have a transition frontier at the moment, so we're \\","counters":[]},{"line":"                 unable to verify any transactions.\"","counters":[]},{"line":"        in","counters":[]},{"line":"        let diff' =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          O1trace.sync_thread \"convert_transactions_to_verifiable\" (fun () ->","counters":[]},{"line":"              Envelope.Incoming.map diff","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ~f:","counters":[]},{"line":"                  (List.map","counters":[]},{"line":"                     ~f:","counters":[]},{"line":"                       (User_command.to_verifiable ~ledger ~get:Base_ledger.get","counters":[]},{"line":"                          ~location_of_account:Base_ledger.location_of_account ) ) )","counters":[]},{"line":"        in","counters":[]},{"line":"        match%bind.Deferred","counters":[]},{"line":"          O1trace.thread \"batching_transaction_verification\" (fun () ->","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"              Batcher.verify t.batcher diff' )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"        with","counters":[]},{"line":"        | Error e ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            [%log' error t.logger] \"Transaction verification error: $error\"","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"              ~metadata:[ (\"error\", `String (Error.to_string_hum e)) ] ;","counters":[{"col_start":63,"col_end":63,"count":0}]},{"line":"            [%log' debug t.logger]","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"              \"Failed to batch verify $transaction_pool_diff\"","counters":[]},{"line":"              ~metadata:","counters":[]},{"line":"                [ ( \"transaction_pool_diff\"","counters":[]},{"line":"                  , Diff_versioned.to_yojson (Envelope.Incoming.data diff) )","counters":[{"col_start":43,"col_end":43,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"                ] ;","counters":[]},{"line":"            Deferred.return (Error (Error.tag e ~tag:\"Internal_error\"))","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"        | Ok (Error invalid) ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let msg = Verifier.invalid_to_string invalid in","counters":[]},{"line":"            [%log' error t.logger]","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"              \"Batch verification failed when adding from gossip\"","counters":[]},{"line":"              ~metadata:[ (\"error\", `String msg) ] ;","counters":[]},{"line":"            let%map.Deferred () =","counters":[]},{"line":"              Trust_system.record_envelope_sender t.config.trust_system t.logger","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"                (Envelope.Incoming.sender diff)","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"                ( Trust_system.Actions.Sent_useless_gossip","counters":[]},{"line":"                , Some","counters":[]},{"line":"                    ( \"rejecting command because had invalid signature or proof\"","counters":[]},{"line":"                    , [] ) )","counters":[]},{"line":"            in","counters":[]},{"line":"            Error Error.(tag (of_string msg) ~tag:\"Verification_failed\")","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"        | Ok (Ok commands) ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (* TODO: avoid duplicate hashing (#11706) *)","counters":[]},{"line":"            O1trace.sync_thread \"hashing_transactions_after_verification\"","counters":[]},{"line":"              (fun () ->","counters":[]},{"line":"                Deferred.return","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  (Ok","counters":[]},{"line":"                     { diff with","counters":[]},{"line":"                       data =","counters":[]},{"line":"                         List.map commands","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                           ~f:","counters":[]},{"line":"                             Transaction_hash.User_command_with_valid_signature","counters":[]},{"line":"                             .create","counters":[]},{"line":"                     } ) )","counters":[]},{"line":"","counters":[]},{"line":"      let register_locally_generated t txn =","counters":[]},{"line":"        Hashtbl.update t.locally_generated_uncommitted txn ~f:(function","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          | Some (_, `Batch batch_num) ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (* Use the existing [batch_num] on a re-issue, to avoid splitting","counters":[]},{"line":"                 existing batches.","counters":[]},{"line":"              *)","counters":[]},{"line":"              (Time.now (), `Batch batch_num)","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let batch_num =","counters":[]},{"line":"                if t.remaining_in_batch > 0 then (","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"                  t.remaining_in_batch <- t.remaining_in_batch - 1 ;","counters":[]},{"line":"                  t.current_batch )","counters":[]},{"line":"                else (","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                  t.remaining_in_batch <- max_per_15_seconds - 1 ;","counters":[]},{"line":"                  t.current_batch <- t.current_batch + 1 ;","counters":[]},{"line":"                  t.current_batch )","counters":[]},{"line":"              in","counters":[]},{"line":"              (Time.now (), `Batch batch_num) )","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"      let apply t (diff : verified Envelope.Incoming.t) =","counters":[]},{"line":"        let open Or_error.Let_syntax in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let is_sender_local =","counters":[]},{"line":"          Envelope.Sender.(equal Local) (Envelope.Incoming.sender diff)","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"        in","counters":[]},{"line":"        let pool_size_before = Indexed_pool.size t.pool in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        (* preload fee payer accounts from the best tip ledger *)","counters":[]},{"line":"        let%map ledger =","counters":[]},{"line":"          match t.best_tip_ledger with","counters":[]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Or_error.error_string","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"                \"Got transaction pool diff when transitin frontier is \\","counters":[]},{"line":"                 unavailable, ignoring.\"","counters":[]},{"line":"          | Some ledger ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              return ledger","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"        in","counters":[]},{"line":"        let fee_payer_account_ids =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          List.map (Envelope.Incoming.data diff) ~f:(fun cmd ->","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"              Transaction_hash.User_command_with_valid_signature.command cmd","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"              |> User_command.fee_payer )","counters":[]},{"line":"          |> Account_id.Set.of_list","counters":[]},{"line":"        in","counters":[]},{"line":"        let fee_payer_accounts =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          preload_accounts ledger fee_payer_account_ids","counters":[]},{"line":"        in","counters":[]},{"line":"        (* add new commands to the pool *)","counters":[]},{"line":"        let fee_payer =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Fn.compose User_command.fee_payer","counters":[]},{"line":"            Transaction_hash.User_command_with_valid_signature.command","counters":[]},{"line":"        in","counters":[]},{"line":"        let check_command pool cmd =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          if","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Indexed_pool.member pool","counters":[]},{"line":"              (Transaction_hash.User_command.of_checked cmd)","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"          then Error Diff_error.Duplicate","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"          else","counters":[]},{"line":"            match Map.find fee_payer_accounts (fee_payer cmd) with","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"            | None ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Error Diff_error.Fee_payer_account_not_found","counters":[]},{"line":"            | Some account ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                if not (Account.has_permission ~to_:`Send account) then","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"                  Error Diff_error.Fee_payer_not_permitted_to_send","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                else Ok ()","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"        in","counters":[]},{"line":"        let pool, add_results =","counters":[]},{"line":"          List.fold_map (Envelope.Incoming.data diff) ~init:t.pool","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"            ~f:(fun pool cmd ->","counters":[]},{"line":"              let result =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                let%bind.Result () = check_command pool cmd in","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"                let global_slot =","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Indexed_pool.global_slot_since_genesis t.pool","counters":[]},{"line":"                in","counters":[]},{"line":"                let account = Map.find_exn fee_payer_accounts (fee_payer cmd) in","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"                match","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Indexed_pool.add_from_gossip_exn pool cmd account.nonce","counters":[]},{"line":"                    ( Account.liquid_balance_at_slot ~global_slot account","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                    |> Currency.Balance.to_amount )","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"                with","counters":[]},{"line":"                | Ok x ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    Ok x","counters":[]},{"line":"                | Error err ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    report_command_error ~logger:t.logger ~is_sender_local","counters":[]},{"line":"                      (Transaction_hash.User_command_with_valid_signature","counters":[]},{"line":"                       .command cmd )","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                      err ;","counters":[]},{"line":"                    Error (diff_error_of_indexed_pool_error err)","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"              in","counters":[]},{"line":"              match result with","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              | Ok (cmd', pool', dropped) ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  (pool', Ok (cmd', dropped))","counters":[]},{"line":"              | Error err ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  (pool, Error (cmd, err)) )","counters":[]},{"line":"        in","counters":[]},{"line":"        let dropped_for_add =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          List.filter_map add_results ~f:(function","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"            | Ok (_, dropped) ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Some (Sequence.to_list dropped)","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"            | Error _ ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                None )","counters":[]},{"line":"          |> List.concat","counters":[]},{"line":"        in","counters":[]},{"line":"        (* drop commands from the pool to retain max size *)","counters":[]},{"line":"        let pool, dropped_for_size =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let pool, dropped =","counters":[]},{"line":"            drop_until_below_max_size pool ~pool_max_size:t.config.pool_max_size","counters":[]},{"line":"          in","counters":[]},{"line":"          (pool, Sequence.to_list dropped)","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"        in","counters":[]},{"line":"        (* handle drops of locally generated commands *)","counters":[]},{"line":"        let all_dropped_cmds = dropped_for_add @ dropped_for_size in","counters":[]},{"line":"        let all_dropped_cmd_hashes =","counters":[]},{"line":"          List.map all_dropped_cmds","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"            ~f:Transaction_hash.User_command_with_valid_signature.hash","counters":[]},{"line":"          |> Transaction_hash.Set.of_list","counters":[]},{"line":"        in","counters":[]},{"line":"        [%log' debug t.logger]","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"          \"Dropping $num_for_add commands from pool while adding new commands, \\","counters":[]},{"line":"           and $num_for_size commands due to pool size\"","counters":[]},{"line":"          ~metadata:","counters":[]},{"line":"            [ (\"num_for_add\", `Int (List.length dropped_for_add))","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"            ; (\"num_for_size\", `Int (List.length dropped_for_size))","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"            ] ;","counters":[]},{"line":"        let locally_generated_dropped =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          List.filter all_dropped_cmds ~f:(fun cmd ->","counters":[]},{"line":"              Hashtbl.find_and_remove t.locally_generated_uncommitted cmd","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"              |> Option.is_some )","counters":[]},{"line":"        in","counters":[]},{"line":"        if not (List.is_empty locally_generated_dropped) then","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"          [%log' info t.logger]","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"            \"Dropped locally generated commands $cmds from transaction pool \\","counters":[]},{"line":"             due to replacement or max size\"","counters":[]},{"line":"            ~metadata:","counters":[]},{"line":"              [ ( \"cmds\"","counters":[]},{"line":"                , `List","counters":[]},{"line":"                    (List.map","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                       ~f:","counters":[]},{"line":"                         Transaction_hash.User_command_with_valid_signature","counters":[]},{"line":"                         .to_yojson locally_generated_dropped ) )","counters":[]},{"line":"              ] ;","counters":[]},{"line":"        (* register locally generated commands *)","counters":[]},{"line":"        if is_sender_local then","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          List.iter add_results ~f:(function","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"            | Ok (cmd, _dropped) ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                if","counters":[]},{"line":"                  not","counters":[]},{"line":"                    (Set.mem all_dropped_cmd_hashes","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                       (Transaction_hash.User_command_with_valid_signature.hash","counters":[{"col_start":78,"col_end":78,"count":0}]},{"line":"                          cmd ) )","counters":[]},{"line":"                then register_locally_generated t cmd","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"            | Error _ ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                () ) ;","counters":[]},{"line":"        (* finalize the update to the pool *)","counters":[]},{"line":"        t.pool <- pool ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let pool_size_after = Indexed_pool.size pool in","counters":[]},{"line":"        Mina_metrics.(","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Gauge.set Transaction_pool.pool_size (Float.of_int pool_size_after) ;","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"          List.iter","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"            (List.init (max 0 (pool_size_after - pool_size_before)) ~f:Fn.id)","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"            ~f:(fun _ ->","counters":[]},{"line":"              Counter.inc_one Transaction_pool.transactions_added_to_pool )) ;","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"        (* partition the results *)","counters":[]},{"line":"        let accepted, rejected =","counters":[]},{"line":"          List.partition_map add_results ~f:(function","counters":[]},{"line":"            | Ok (cmd, _dropped) ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Either.First cmd","counters":[]},{"line":"            | Error (cmd, error) ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Either.Second (cmd, error) )","counters":[]},{"line":"        in","counters":[]},{"line":"        (* determine if we should re-broadcast this diff *)","counters":[]},{"line":"        let decision =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          if","counters":[]},{"line":"            List.exists rejected ~f:(fun (_, error) ->","counters":[]},{"line":"                Diff_error.grounds_for_diff_rejection error )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"          then `Reject","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"          else `Accept","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"        in","counters":[]},{"line":"        (decision, accepted, rejected)","counters":[]},{"line":"","counters":[]},{"line":"      let unsafe_apply' (t : pool) (diff : verified Envelope.Incoming.t) :","counters":[]},{"line":"          ([ `Accept | `Reject ] * t * rejected, _) Result.t =","counters":[]},{"line":"        match apply t diff with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | Ok (decision, accepted, rejected) ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ( if not (List.is_empty accepted) then","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"              Mina_metrics.(","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Gauge.set Transaction_pool.useful_transactions_received_time_sec","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                  (let x =","counters":[]},{"line":"                     Time.(now () |> to_span_since_epoch |> Span.to_sec)","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":55,"col_end":55,"count":0},{"col_start":70,"col_end":70,"count":0}]},{"line":"                   in","counters":[]},{"line":"                   x -. Mina_metrics.time_offset_sec )) ) ;","counters":[]},{"line":"            let forget_cmd =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Transaction_hash.User_command_with_valid_signature.command","counters":[]},{"line":"            in","counters":[]},{"line":"            Ok","counters":[]},{"line":"              ( decision","counters":[]},{"line":"              , List.map ~f:forget_cmd accepted","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"              , List.map ~f:(Tuple2.map_fst ~f:forget_cmd) rejected )","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"        | Error e ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Error (`Other e)","counters":[]},{"line":"","counters":[]},{"line":"      let unsafe_apply t diff = Deferred.return (unsafe_apply' t diff)","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"","counters":[]},{"line":"      type Structured_log_events.t +=","counters":[]},{"line":"        | Transactions_received of { txns : t; sender : Envelope.Sender.t }","counters":[{"col_start":44,"col_end":44,"count":0},{"col_start":56,"col_end":56,"count":0},{"col_start":72,"col_end":72,"count":0}]},{"line":"        [@@deriving","counters":[]},{"line":"          register_event","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":23,"col_end":23,"count":3}]},{"line":"            { msg = \"Received transaction-pool diff $txns from $sender\" }]","counters":[]},{"line":"","counters":[]},{"line":"      let update_metrics envelope valid_cb gossip_heard_logger_option =","counters":[]},{"line":"        Mina_metrics.(Counter.inc_one Network.gossip_messages_received) ;","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"        Mina_metrics.(Gauge.inc_one Network.transaction_pool_diff_received) ;","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"        let diff = Envelope.Incoming.data envelope in","counters":[]},{"line":"        Option.iter gossip_heard_logger_option ~f:(fun logger ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            [%str_log debug]","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"              (Transactions_received","counters":[]},{"line":"                 { txns = diff; sender = Envelope.Incoming.sender envelope } ) ) ;","counters":[{"col_start":64,"col_end":64,"count":0}]},{"line":"        Mina_net2.Validation_callback.set_message_type valid_cb `Transaction ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Mina_metrics.(Counter.inc_one Network.Transaction.received)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    let get_rebroadcastable (t : t) ~has_timed_out =","counters":[]},{"line":"      let metadata ~key ~time =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [ ( \"cmd\"","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          , Transaction_hash.User_command_with_valid_signature.to_yojson key )","counters":[{"col_start":71,"col_end":71,"count":0}]},{"line":"        ; (\"time\", `String (Time.to_string_abs ~zone:Time.Zone.utc time))","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"        ]","counters":[]},{"line":"      in","counters":[]},{"line":"      let added_str =","counters":[]},{"line":"        \"it was added at $time and its rebroadcast period is now expired.\"","counters":[]},{"line":"      in","counters":[]},{"line":"      let logger = t.logger in","counters":[]},{"line":"      Hashtbl.filteri_inplace t.locally_generated_uncommitted","counters":[]},{"line":"        ~f:(fun ~key ~data:(time, `Batch _) ->","counters":[]},{"line":"          match has_timed_out time with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | `Timed_out ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              [%log info]","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                \"No longer rebroadcasting uncommitted command $cmd, %s\"","counters":[]},{"line":"                added_str ~metadata:(metadata ~key ~time) ;","counters":[]},{"line":"              false","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"          | `Ok ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              true ) ;","counters":[]},{"line":"      Hashtbl.filteri_inplace t.locally_generated_committed","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ~f:(fun ~key ~data:(time, `Batch _) ->","counters":[]},{"line":"          match has_timed_out time with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | `Timed_out ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              [%log debug]","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                \"Removing committed locally generated command $cmd from \\","counters":[]},{"line":"                 possible rebroadcast pool, %s\"","counters":[]},{"line":"                added_str ~metadata:(metadata ~key ~time) ;","counters":[]},{"line":"              false","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"          | `Ok ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              true ) ;","counters":[]},{"line":"      (* Important to maintain ordering here *)","counters":[]},{"line":"      let rebroadcastable_txs =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Hashtbl.to_alist t.locally_generated_uncommitted","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"        |> List.sort","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"             ~compare:(fun (txn1, (_, `Batch batch1)) (txn2, (_, `Batch batch2))","counters":[]},{"line":"                      ->","counters":[]},{"line":"               let cmp = compare batch1 batch2 in","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"               let get_hash =","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                 Transaction_hash.User_command_with_valid_signature.hash","counters":[]},{"line":"               in","counters":[]},{"line":"               let get_nonce txn =","counters":[]},{"line":"                 Transaction_hash.User_command_with_valid_signature.command txn","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":74,"col_end":74,"count":0}]},{"line":"                 |> User_command.applicable_at_nonce","counters":[]},{"line":"               in","counters":[]},{"line":"               if cmp <> 0 then cmp","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"               else","counters":[]},{"line":"                 let cmp =","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                   Mina_numbers.Account_nonce.compare (get_nonce txn1)","counters":[{"col_start":63,"col_end":63,"count":0}]},{"line":"                     (get_nonce txn2)","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                 in","counters":[]},{"line":"                 if cmp <> 0 then cmp","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"                 else Transaction_hash.compare (get_hash txn1) (get_hash txn2) )","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":55,"col_end":55,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"        |> List.group","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"             ~break:(fun (_, (_, `Batch batch1)) (_, (_, `Batch batch2)) ->","counters":[]},{"line":"               batch1 <> batch2 )","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"        |> List.map","counters":[]},{"line":"             ~f:","counters":[]},{"line":"               (List.map ~f:(fun (txn, _) ->","counters":[]},{"line":"                    Transaction_hash.User_command_with_valid_signature.command","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      txn ) )","counters":[]},{"line":"      in","counters":[]},{"line":"      rebroadcastable_txs","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  include Network_pool_base.Make (Transition_frontier) (Resource_pool)","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(* Use this one in downstream consumers *)","counters":[]},{"line":"module Make (Staged_ledger : sig","counters":[]},{"line":"  type t","counters":[]},{"line":"","counters":[]},{"line":"  val ledger : t -> Mina_ledger.Ledger.t","counters":[]},{"line":"end)","counters":[]},{"line":"(Transition_frontier : Transition_frontier_intf","counters":[]},{"line":"                         with type staged_ledger := Staged_ledger.t) :","counters":[]},{"line":"  S with type transition_frontier := Transition_frontier.t =","counters":[]},{"line":"  Make0 (Mina_ledger.Ledger) (Staged_ledger) (Transition_frontier)","counters":[]},{"line":"","counters":[]},{"line":"(* TODO: defunctor or remove monkey patching (#3731) *)","counters":[]},{"line":"include","counters":[]},{"line":"  Make","counters":[]},{"line":"    (Staged_ledger)","counters":[]},{"line":"    (struct","counters":[]},{"line":"      include Transition_frontier","counters":[]},{"line":"","counters":[]},{"line":"      type best_tip_diff = Extensions.Best_tip_diff.view =","counters":[]},{"line":"        { new_commands : User_command.Valid.t With_status.t list","counters":[]},{"line":"        ; removed_commands : User_command.Valid.t With_status.t list","counters":[]},{"line":"        ; reorg_best_tip : bool","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"      let best_tip_diff_pipe t =","counters":[]},{"line":"        Extensions.(get_view_pipe (extensions t) Best_tip_diff)","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"    end)","counters":[]},{"line":"","counters":[]},{"line":"let%test_module _ =","counters":[]},{"line":"  ( module struct","counters":[]},{"line":"    open Signature_lib","counters":[]},{"line":"    module Mock_base_ledger = Mocks.Base_ledger","counters":[]},{"line":"    module Mock_staged_ledger = Mocks.Staged_ledger","counters":[]},{"line":"","counters":[]},{"line":"    let () =","counters":[]},{"line":"      Core.Backtrace.elide := false ;","counters":[]},{"line":"      Async.Scheduler.set_record_backtraces true","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"","counters":[]},{"line":"    let num_test_keys = 10","counters":[]},{"line":"","counters":[]},{"line":"    (* keys for accounts in the ledger *)","counters":[]},{"line":"    let test_keys =","counters":[]},{"line":"      Array.init num_test_keys ~f:(fun _ -> Signature_lib.Keypair.create ())","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"    let num_extra_keys = 30","counters":[]},{"line":"","counters":[]},{"line":"    (* keys that can be used when generating new accounts *)","counters":[]},{"line":"    let extra_keys =","counters":[]},{"line":"      Array.init num_extra_keys ~f:(fun _ -> Signature_lib.Keypair.create ())","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"","counters":[]},{"line":"    let precomputed_values = Lazy.force Precomputed_values.for_unit_tests","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"","counters":[]},{"line":"    let constraint_constants = precomputed_values.constraint_constants","counters":[]},{"line":"","counters":[]},{"line":"    let consensus_constants = precomputed_values.consensus_constants","counters":[]},{"line":"","counters":[]},{"line":"    let proof_level = precomputed_values.proof_level","counters":[]},{"line":"","counters":[]},{"line":"    let minimum_fee =","counters":[]},{"line":"      Currency.Fee.to_int Mina_compile_config.minimum_user_command_fee","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"","counters":[]},{"line":"    let logger = Logger.create ()","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"    let time_controller = Block_time.Controller.basic ~logger","counters":[]},{"line":"","counters":[]},{"line":"    let expiry_ns =","counters":[]},{"line":"      Time_ns.Span.of_hr","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"        (Float.of_int precomputed_values.genesis_constants.transaction_expiry_hr)","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"","counters":[]},{"line":"    let verifier =","counters":[]},{"line":"      Async.Thread_safe.block_on_async_exn (fun () ->","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"          Verifier.create ~logger ~proof_level ~constraint_constants","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ~conf_dir:None","counters":[]},{"line":"            ~pids:(Child_processes.Termination.create_pid_table ()) )","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"","counters":[]},{"line":"    let `VK vk, `Prover prover =","counters":[]},{"line":"      Transaction_snark.For_tests.create_trivial_snapp ~constraint_constants ()","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"","counters":[]},{"line":"    let dummy_state_view =","counters":[]},{"line":"      let state_body =","counters":[]},{"line":"        let consensus_constants =","counters":[]},{"line":"          let genesis_constants = Genesis_constants.for_unit_tests in","counters":[]},{"line":"          Consensus.Constants.create ~constraint_constants","counters":[]},{"line":"            ~protocol_constants:genesis_constants.protocol","counters":[]},{"line":"        in","counters":[]},{"line":"        let compile_time_genesis =","counters":[]},{"line":"          (*not using Precomputed_values.for_unit_test because of dependency cycle*)","counters":[]},{"line":"          Mina_state.Genesis_protocol_state.t","counters":[]},{"line":"            ~genesis_ledger:Genesis_ledger.(Packed.t for_unit_tests)","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"            ~genesis_epoch_data:Consensus.Genesis_epoch_data.for_unit_tests","counters":[]},{"line":"            ~constraint_constants ~consensus_constants","counters":[]},{"line":"            ~genesis_body_reference:Staged_ledger_diff.genesis_body_reference","counters":[]},{"line":"        in","counters":[]},{"line":"        compile_time_genesis.data |> Mina_state.Protocol_state.body","counters":[{"col_start":66,"col_end":66,"count":0}]},{"line":"      in","counters":[]},{"line":"      { (Mina_state.Protocol_state.Body.view state_body) with","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"        global_slot_since_genesis = Mina_numbers.Global_slot.zero","counters":[]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    module Mock_transition_frontier = struct","counters":[]},{"line":"      module Breadcrumb = struct","counters":[]},{"line":"        type t = Mock_staged_ledger.t","counters":[]},{"line":"","counters":[]},{"line":"        let staged_ledger = Fn.id","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      type best_tip_diff =","counters":[]},{"line":"        { new_commands : User_command.Valid.t With_status.t list","counters":[]},{"line":"        ; removed_commands : User_command.Valid.t With_status.t list","counters":[]},{"line":"        ; reorg_best_tip : bool","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"      type t = best_tip_diff Broadcast_pipe.Reader.t * Breadcrumb.t ref","counters":[]},{"line":"","counters":[]},{"line":"      let create : unit -> t * best_tip_diff Broadcast_pipe.Writer.t =","counters":[]},{"line":"       fun () ->","counters":[]},{"line":"        let zkappify_account (account : Account.t) : Account.t =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let zkapp =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Some { Zkapp_account.default with verification_key = Some vk }","counters":[]},{"line":"          in","counters":[]},{"line":"          { account with zkapp }","counters":[]},{"line":"        in","counters":[]},{"line":"        let pipe_r, pipe_w =","counters":[]},{"line":"          Broadcast_pipe.create","counters":[]},{"line":"            { new_commands = []; removed_commands = []; reorg_best_tip = false }","counters":[]},{"line":"        in","counters":[]},{"line":"        let initial_balance =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Currency.Balance.of_formatted_string \"900000000.0\"","counters":[]},{"line":"        in","counters":[]},{"line":"        let ledger = Mina_ledger.Ledger.create_ephemeral ~depth:10 () in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Array.iteri test_keys ~f:(fun i kp ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            let account_id =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Account_id.create","counters":[]},{"line":"                (Public_key.compress kp.public_key)","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                Token_id.default","counters":[]},{"line":"            in","counters":[]},{"line":"            let _tag, account, loc =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Or_error.ok_exn","counters":[]},{"line":"              @@ Mina_ledger.Ledger.Ledger_inner.get_or_create ledger account_id","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"            in","counters":[]},{"line":"            (* set the account balance *)","counters":[]},{"line":"            let account = { account with balance = initial_balance } in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            (* zkappify every other account *)","counters":[]},{"line":"            let account =","counters":[]},{"line":"              if i mod 2 = 0 then account else zkappify_account account","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":47,"col_end":47,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"            in","counters":[]},{"line":"            Mina_ledger.Ledger.Ledger_inner.set ledger loc account ) ;","counters":[]},{"line":"        ((pipe_r, ref ledger), pipe_w)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      let best_tip (_, best_tip) = !best_tip","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"      let best_tip_diff_pipe (pipe, _) = pipe","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Test =","counters":[]},{"line":"      Make0 (Mock_base_ledger) (Mock_staged_ledger) (Mock_transition_frontier)","counters":[]},{"line":"","counters":[]},{"line":"    type test =","counters":[]},{"line":"      { txn_pool : Test.Resource_pool.t","counters":[]},{"line":"      ; best_tip_diff_w :","counters":[]},{"line":"          Mock_transition_frontier.best_tip_diff Broadcast_pipe.Writer.t","counters":[]},{"line":"      ; best_tip_ref : Mina_ledger.Ledger.t ref","counters":[]},{"line":"      ; frontier_pipe_w :","counters":[]},{"line":"          Mock_transition_frontier.t option Broadcast_pipe.Writer.t","counters":[]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    let pool_max_size = 25","counters":[]},{"line":"","counters":[]},{"line":"    let assert_user_command_sets_equal cs1 cs2 =","counters":[]},{"line":"      let index cs =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let decompose c =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ( Transaction_hash.User_command.hash c","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"          , Transaction_hash.User_command.command c )","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"        in","counters":[]},{"line":"        List.map cs ~f:decompose |> Transaction_hash.Map.of_alist_exn","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"      in","counters":[]},{"line":"      let index1 = index cs1 in","counters":[]},{"line":"      let index2 = index cs2 in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let set1 = Transaction_hash.Set.of_list @@ Map.keys index1 in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"      let set2 = Transaction_hash.Set.of_list @@ Map.keys index2 in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"      if not (Set.equal set1 set2) then (","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"        let additional1, additional2 =","counters":[]},{"line":"          Set.symmetric_diff set1 set2","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"          |> Sequence.map","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"               ~f:","counters":[]},{"line":"                 (Either.map ~first:(Map.find_exn index1)","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"                    ~second:(Map.find_exn index2) )","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"          |> Sequence.to_list","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"          |> List.partition_map ~f:Fn.id","counters":[]},{"line":"        in","counters":[]},{"line":"        assert (List.length additional1 + List.length additional2 > 0) ;","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"        let report_additional commands a b =","counters":[]},{"line":"          Core.Printf.printf \"%s user commands not in %s:\\n\" a b ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          List.iter commands ~f:(fun c ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              Core.Printf.printf !\"  %{Sexp}\\n\" (User_command.sexp_of_t c) )","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":70,"col_end":70,"count":0}]},{"line":"        in","counters":[]},{"line":"        if List.length additional1 > 0 then","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"          report_additional additional1 \"actual\" \"expected\" ;","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"        if List.length additional2 > 0 then","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"          report_additional additional2 \"expected\" \"actual\" ) ;","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"      [%test_eq: Transaction_hash.Set.t] set1 set2","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"","counters":[]},{"line":"    let replace_valid_zkapp_command_authorizations ~keymap ~ledger valid_cmds :","counters":[]},{"line":"        User_command.Valid.t list Deferred.t =","counters":[]},{"line":"      Deferred.List.map","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (valid_cmds : User_command.Valid.t list)","counters":[]},{"line":"        ~f:(function","counters":[]},{"line":"          | Zkapp_command zkapp_command_dummy_auths ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let%map zkapp_command =","counters":[]},{"line":"                Zkapp_command_builder.replace_authorizations ~keymap ~prover","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"                  (Zkapp_command.Valid.forget zkapp_command_dummy_auths)","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"              in","counters":[]},{"line":"              let valid_zkapp_command =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                let open Mina_ledger.Ledger in","counters":[]},{"line":"                match","counters":[]},{"line":"                  Zkapp_command.Valid.to_valid ~ledger ~get ~location_of_account","counters":[]},{"line":"                    zkapp_command","counters":[]},{"line":"                with","counters":[]},{"line":"                | Some ps ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    ps","counters":[]},{"line":"                | None ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    failwith \"Could not create Zkapp_command.Valid.t\"","counters":[]},{"line":"              in","counters":[]},{"line":"              User_command.Zkapp_command valid_zkapp_command","counters":[]},{"line":"          | Signed_command _ ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              failwith \"Expected Zkapp_command valid user command\" )","counters":[]},{"line":"","counters":[]},{"line":"    (** Assert the invariants of the locally generated command tracking system. *)","counters":[]},{"line":"    let assert_locally_generated (pool : Test.Resource_pool.t) =","counters":[]},{"line":"      ignore","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ( Hashtbl.merge pool.locally_generated_committed","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"            pool.locally_generated_uncommitted ~f:(fun ~key -> function","counters":[]},{"line":"            | `Both ((committed, _), (uncommitted, _)) ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                failwithf","counters":[]},{"line":"                  !\"Command \\","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"                    %{sexp:Transaction_hash.User_command_with_valid_signature.t} \\","counters":[]},{"line":"                    in both locally generated committed and uncommitted with \\","counters":[]},{"line":"                    times %s and %s\"","counters":[]},{"line":"                  key (Time.to_string committed)","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"                  (Time.to_string uncommitted)","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                  ()","counters":[]},{"line":"            | `Left cmd ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Some cmd","counters":[]},{"line":"            | `Right cmd ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (* Locally generated uncommitted transactions should be in the","counters":[]},{"line":"                   pool, so long as we're not in the middle of updating it. *)","counters":[]},{"line":"                assert (","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                  Indexed_pool.member pool.pool","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"                    (Transaction_hash.User_command.of_checked key) ) ;","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"                Some cmd )","counters":[]},{"line":"          : ( Transaction_hash.User_command_with_valid_signature.t","counters":[]},{"line":"            , Time.t * [ `Batch of int ] )","counters":[]},{"line":"            Hashtbl.t )","counters":[]},{"line":"","counters":[]},{"line":"    let assert_fee_wu_ordering (pool : Test.Resource_pool.t) =","counters":[]},{"line":"      let txns = Test.Resource_pool.transactions pool |> Sequence.to_list in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"      let compare txn1 txn2 =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let open Transaction_hash.User_command_with_valid_signature in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let cmd1 = command txn1 in","counters":[]},{"line":"        let cmd2 = command txn2 in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        (* ascending order of nonces, if same fee payer *)","counters":[]},{"line":"        if","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Account_id.equal","counters":[]},{"line":"            (User_command.fee_payer cmd1)","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"            (User_command.fee_payer cmd2)","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"        then","counters":[]},{"line":"          Account.Nonce.compare","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (User_command.applicable_at_nonce cmd1)","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"            (User_command.applicable_at_nonce cmd2)","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"        else","counters":[]},{"line":"          let get_fee_wu cmd = User_command.fee_per_wu cmd in","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"          (* descending order of fee/weight *)","counters":[]},{"line":"          Currency.Fee_rate.compare (get_fee_wu cmd2) (get_fee_wu cmd1)","counters":[{"col_start":46,"col_end":46,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"      in","counters":[]},{"line":"      assert (List.is_sorted txns ~compare)","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"","counters":[]},{"line":"    let assert_pool_txs test txs =","counters":[]},{"line":"      Indexed_pool.For_tests.assert_invariants test.txn_pool.pool ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      assert_locally_generated test.txn_pool ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      assert_fee_wu_ordering test.txn_pool ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      assert_user_command_sets_equal","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ( Sequence.to_list","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"        @@ Sequence.map ~f:Transaction_hash.User_command.of_checked","counters":[{"col_start":66,"col_end":66,"count":0}]},{"line":"        @@ Test.Resource_pool.transactions test.txn_pool )","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"        (List.map","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"           ~f:","counters":[]},{"line":"             (Fn.compose Transaction_hash.User_command.create","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                User_command.forget_check )","counters":[]},{"line":"           txs )","counters":[]},{"line":"","counters":[]},{"line":"    let setup_test ?expiry () =","counters":[]},{"line":"      let frontier, best_tip_diff_w = Mock_transition_frontier.create () in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let _, best_tip_ref = frontier in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let frontier_pipe_r, frontier_pipe_w =","counters":[]},{"line":"        Broadcast_pipe.create @@ Some frontier","counters":[]},{"line":"      in","counters":[]},{"line":"      let trust_system = Trust_system.null () in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let config =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Test.Resource_pool.make_config ~trust_system ~pool_max_size ~verifier","counters":[]},{"line":"          ~genesis_constants:Genesis_constants.compiled","counters":[]},{"line":"      in","counters":[]},{"line":"      let expiry_ns = match expiry with None -> expiry_ns | Some t -> t in","counters":[{"col_start":40,"col_end":40,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"      let pool_, _, _ =","counters":[]},{"line":"        Test.create ~config ~logger ~constraint_constants ~consensus_constants","counters":[]},{"line":"          ~time_controller ~expiry_ns ~frontier_broadcast_pipe:frontier_pipe_r","counters":[]},{"line":"          ~log_gossip_heard:false ~on_remote_push:(Fn.const Deferred.unit)","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"      in","counters":[]},{"line":"      let txn_pool = Test.resource_pool pool_ in","counters":[]},{"line":"      let%map () = Async.Scheduler.yield_until_no_jobs_remain () in","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"      { txn_pool; best_tip_diff_w; best_tip_ref; frontier_pipe_w }","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let independent_cmds : User_command.Valid.t list =","counters":[]},{"line":"      let rec go n cmds =","counters":[]},{"line":"        let open Quickcheck.Generator.Let_syntax in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        if n < Array.length test_keys then","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"          let%bind cmd =","counters":[]},{"line":"            let sender = test_keys.(n) in","counters":[]},{"line":"            User_command.Valid.Gen.payment ~sign_type:`Real","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"              ~key_gen:","counters":[]},{"line":"                (Quickcheck.Generator.tuple2 (return sender)","counters":[{"col_start":43,"col_end":43,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"                   (Quickcheck_lib.of_array test_keys) )","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"              ~max_amount:1_000_000_000 ~fee_range:1_000_000_000 ()","counters":[]},{"line":"          in","counters":[]},{"line":"          go (n + 1) (cmd :: cmds)","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        else Quickcheck.Generator.return @@ List.rev cmds","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"      in","counters":[]},{"line":"      Quickcheck.random_value ~seed:(`Deterministic \"constant\") (go 0 [])","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"","counters":[]},{"line":"    let mk_payment' ?valid_until ~sender_idx ~receiver_idx ~fee ~nonce ~amount","counters":[]},{"line":"        () =","counters":[]},{"line":"      let get_pk idx = Public_key.compress test_keys.(idx).public_key in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"      Signed_command.sign test_keys.(sender_idx)","counters":[]},{"line":"        (Signed_command_payload.create ~fee:(Currency.Fee.of_int fee)","counters":[{"col_start":63,"col_end":63,"count":0}]},{"line":"           ~fee_payer_pk:(get_pk sender_idx) ~valid_until","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"           ~nonce:(Account.Nonce.of_int nonce)","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"           ~memo:(Signed_command_memo.create_by_digesting_string_exn \"foo\")","counters":[{"col_start":67,"col_end":67,"count":0}]},{"line":"           ~body:","counters":[]},{"line":"             (Signed_command_payload.Body.Payment","counters":[]},{"line":"                { source_pk = get_pk sender_idx","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                ; receiver_pk = get_pk receiver_idx","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                ; amount = Currency.Amount.of_int amount","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"                } ) )","counters":[]},{"line":"","counters":[]},{"line":"    let mk_transfer_zkapp_command ?valid_period ?fee_payer_idx ~sender_idx","counters":[]},{"line":"        ~receiver_idx ~fee ~nonce ~amount () =","counters":[]},{"line":"      let sender_kp = test_keys.(sender_idx) in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let sender_nonce = Account.Nonce.of_int nonce in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let sender = (sender_kp, sender_nonce) in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let amount = Currency.Amount.of_int amount in","counters":[]},{"line":"      let receiver_kp = test_keys.(receiver_idx) in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let receiver =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        receiver_kp.public_key |> Signature_lib.Public_key.compress","counters":[]},{"line":"      in","counters":[]},{"line":"      let fee_payer =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        match fee_payer_idx with","counters":[]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            None","counters":[]},{"line":"        | Some (idx, nonce) ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let fee_payer_kp = test_keys.(idx) in","counters":[]},{"line":"            let fee_payer_nonce = Account.Nonce.of_int nonce in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            Some (fee_payer_kp, fee_payer_nonce)","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"      in","counters":[]},{"line":"      let fee = Currency.Fee.of_int fee in","counters":[]},{"line":"      let protocol_state_precondition =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        match valid_period with","counters":[]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Zkapp_precondition.Protocol_state.accept","counters":[]},{"line":"        | Some time ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Zkapp_precondition.Protocol_state.valid_until time","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"      in","counters":[]},{"line":"      let test_spec : Transaction_snark.For_tests.Multiple_transfers_spec.t =","counters":[]},{"line":"        { sender","counters":[]},{"line":"        ; fee_payer","counters":[]},{"line":"        ; fee","counters":[]},{"line":"        ; receivers = [ (receiver, amount) ]","counters":[]},{"line":"        ; amount","counters":[]},{"line":"        ; zkapp_account_keypairs = []","counters":[]},{"line":"        ; memo = Signed_command_memo.create_from_string_exn \"expiry tests\"","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"        ; new_zkapp_account = false","counters":[]},{"line":"        ; snapp_update = Account_update.Update.dummy","counters":[]},{"line":"        ; call_data = Snark_params.Tick.Field.zero","counters":[]},{"line":"        ; events = []","counters":[]},{"line":"        ; sequence_events = []","counters":[]},{"line":"        ; preconditions =","counters":[]},{"line":"            Some","counters":[]},{"line":"              { Account_update.Preconditions.network =","counters":[]},{"line":"                  protocol_state_precondition","counters":[]},{"line":"              ; account =","counters":[]},{"line":"                  Account_update.Account_precondition.Nonce","counters":[]},{"line":"                    ( if Option.is_none fee_payer then","counters":[]},{"line":"                      Account.Nonce.succ sender_nonce","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"                    else sender_nonce )","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"              }","counters":[]},{"line":"        }","counters":[]},{"line":"      in","counters":[]},{"line":"      let zkapp_command =","counters":[]},{"line":"        Transaction_snark.For_tests.multiple_transfers test_spec","counters":[]},{"line":"      in","counters":[]},{"line":"      let zkapp_command =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Option.value_exn","counters":[]},{"line":"          (Zkapp_command.Valid.to_valid ~ledger:()","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"             ~get:(fun _ _ -> failwith \"Not expecting proof zkapp_command\")","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"             ~location_of_account:(fun _ _ ->","counters":[]},{"line":"               failwith \"Not expecting proof zkapp_command\" )","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"             zkapp_command )","counters":[]},{"line":"      in","counters":[]},{"line":"      User_command.Zkapp_command zkapp_command","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let mk_payment ?valid_until ~sender_idx ~receiver_idx ~fee ~nonce ~amount ()","counters":[]},{"line":"        =","counters":[]},{"line":"      User_command.Signed_command","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (mk_payment' ?valid_until ~sender_idx ~fee ~nonce ~receiver_idx ~amount","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"           () )","counters":[]},{"line":"","counters":[]},{"line":"    let mk_zkapp_command_cmds (pool : Test.Resource_pool.t) :","counters":[]},{"line":"        User_command.Valid.t list Deferred.t =","counters":[]},{"line":"      let num_cmds = 7 in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      assert (num_cmds < Array.length test_keys - 1) ;","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"      let best_tip_ledger = Option.value_exn pool.best_tip_ledger in","counters":[]},{"line":"      let keymap =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Array.fold (Array.append test_keys extra_keys)","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"          ~init:Public_key.Compressed.Map.empty","counters":[]},{"line":"          ~f:(fun map { public_key; private_key } ->","counters":[]},{"line":"            let key = Public_key.compress public_key in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            Public_key.Compressed.Map.add_exn map ~key ~data:private_key )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"      in","counters":[]},{"line":"      let account_state_tbl =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        List.take (Array.to_list test_keys) num_cmds","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"        |> List.map ~f:(fun kp ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"               let id =","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                 Account_id.create","counters":[]},{"line":"                   (Public_key.compress kp.public_key)","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"                   Token_id.default","counters":[]},{"line":"               in","counters":[]},{"line":"               let state =","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                 Option.value_exn","counters":[]},{"line":"                   (let%bind.Option loc =","counters":[]},{"line":"                      Mina_ledger.Ledger.location_of_account best_tip_ledger id","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"                    in","counters":[]},{"line":"                    Mina_ledger.Ledger.get best_tip_ledger loc )","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"               in","counters":[]},{"line":"               (id, (state, `Fee_payer)) )","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"        |> Account_id.Table.of_alist_exn","counters":[]},{"line":"      in","counters":[]},{"line":"      let rec go n cmds =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let open Quickcheck.Generator.Let_syntax in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        if n < num_cmds then","counters":[]},{"line":"          let%bind cmd =","counters":[]},{"line":"            let fee_payer_keypair = test_keys.(n) in","counters":[]},{"line":"            let%map (zkapp_command : Zkapp_command.t) =","counters":[]},{"line":"              Mina_generators.Zkapp_command_generators.gen_zkapp_command_from","counters":[{"col_start":76,"col_end":76,"count":0}]},{"line":"                ~max_token_updates:1 ~keymap ~account_state_tbl","counters":[]},{"line":"                ~fee_payer_keypair ~ledger:best_tip_ledger ()","counters":[]},{"line":"            in","counters":[]},{"line":"            let zkapp_command =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              { zkapp_command with","counters":[]},{"line":"                account_updates =","counters":[]},{"line":"                  Zkapp_command.Call_forest.map zkapp_command.account_updates","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"                    ~f:(fun (p : Account_update.t) ->","counters":[]},{"line":"                      { p with","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        body =","counters":[]},{"line":"                          { p.body with","counters":[]},{"line":"                            preconditions =","counters":[]},{"line":"                              { p.body.preconditions with","counters":[]},{"line":"                                account =","counters":[]},{"line":"                                  ( match p.body.preconditions.account with","counters":[]},{"line":"                                  | Account_update.Account_precondition.Full","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"                                      { nonce =","counters":[]},{"line":"                                          Zkapp_basic.Or_ignore.Check n as c","counters":[]},{"line":"                                      ; _","counters":[]},{"line":"                                      }","counters":[]},{"line":"                                    when Zkapp_precondition.Numeric.(","counters":[]},{"line":"                                           is_constant Tc.nonce c) ->","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"                                      Account_update.Account_precondition.Nonce","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"                                        n.lower","counters":[]},{"line":"                                  | Account_update.Account_precondition.Full _","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"                                    ->","counters":[]},{"line":"                                      Account_update.Account_precondition.Accept","counters":[]},{"line":"                                  | pre ->","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"                                      pre )","counters":[]},{"line":"                              }","counters":[]},{"line":"                          }","counters":[]},{"line":"                      } )","counters":[]},{"line":"              }","counters":[]},{"line":"            in","counters":[]},{"line":"            let zkapp_command =","counters":[]},{"line":"              Option.value_exn","counters":[]},{"line":"                (Zkapp_command.Valid.to_valid ~ledger:best_tip_ledger","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"                   ~get:Mina_ledger.Ledger.get","counters":[]},{"line":"                   ~location_of_account:Mina_ledger.Ledger.location_of_account","counters":[]},{"line":"                   zkapp_command )","counters":[]},{"line":"            in","counters":[]},{"line":"            User_command.Zkapp_command zkapp_command","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          in","counters":[]},{"line":"          go (n + 1) (cmd :: cmds)","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        else Quickcheck.Generator.return @@ List.rev cmds","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"      in","counters":[]},{"line":"      let result =","counters":[]},{"line":"        Quickcheck.random_value ~seed:(`Deterministic \"zkapp_command\") (go 0 [])","counters":[{"col_start":73,"col_end":73,"count":0}]},{"line":"      in","counters":[]},{"line":"      replace_valid_zkapp_command_authorizations ~keymap ~ledger:best_tip_ledger","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        result","counters":[]},{"line":"","counters":[]},{"line":"    type pool_apply = (User_command.t list, [ `Other of Error.t ]) Result.t","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":56,"col_end":56,"count":0},{"col_start":62,"col_end":62,"count":0},{"col_start":64,"col_end":64,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"    [@@deriving sexp, compare]","counters":[]},{"line":"","counters":[]},{"line":"    let canonicalize t =","counters":[]},{"line":"      Result.map t ~f:(List.sort ~compare:User_command.compare)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let compare_pool_apply (t1 : pool_apply) (t2 : pool_apply) =","counters":[]},{"line":"      compare_pool_apply (canonicalize t1) (canonicalize t2)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"","counters":[]},{"line":"    let assert_pool_apply expected_commands result =","counters":[]},{"line":"      let accepted_commands =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Result.map result ~f:(fun (_, accepted, _) -> accepted)","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"      in","counters":[]},{"line":"      [%test_eq: pool_apply] accepted_commands","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"        (Ok (List.map ~f:User_command.forget_check expected_commands))","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"","counters":[]},{"line":"    let mk_with_status (cmd : User_command.Valid.t) =","counters":[]},{"line":"      { With_status.data = cmd; status = Applied }","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let add_commands ?(local = true) test cs =","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"      let sender =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        if local then Envelope.Sender.Local","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"        else","counters":[]},{"line":"          Envelope.Sender.Remote","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (Peer.create","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"               (Unix.Inet_addr.of_string \"1.2.3.4\")","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"               ~peer_id:","counters":[]},{"line":"                 (Peer.Id.unsafe_of_string \"contents should be irrelevant\")","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"               ~libp2p_port:8302 )","counters":[]},{"line":"      in","counters":[]},{"line":"      let tm0 = Time.now () in","counters":[]},{"line":"      let%bind verified =","counters":[]},{"line":"        Test.Resource_pool.Diff.verify test.txn_pool","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"          (Envelope.Incoming.wrap","counters":[]},{"line":"             ~data:(List.map ~f:User_command.forget_check cs)","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"             ~sender )","counters":[]},{"line":"        >>| Or_error.ok_exn","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"      in","counters":[]},{"line":"      let%map result =","counters":[]},{"line":"        Test.Resource_pool.Diff.unsafe_apply test.txn_pool verified","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"      in","counters":[]},{"line":"      let tm1 = Time.now () in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      [%log' info test.txn_pool.logger] \"Time for add_commands: %0.04f sec\"","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"        (Time.diff tm1 tm0 |> Time.Span.to_sec) ;","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"      ( match result with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Ok (`Accept, _, rejects) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          List.iter rejects ~f:(fun (cmd, err) ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"              Core.Printf.printf","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                !\"command was rejected because %s: %{Yojson.Safe}\\n%!\"","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                (Diff_versioned.Diff_error.to_string_name err)","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"                (User_command.to_yojson cmd) )","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"      | Ok (`Reject, _, _) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          failwith \"diff was rejected during application\"","counters":[]},{"line":"      | Error (`Other err) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Core.Printf.printf","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"            !\"failed to apply diff to pool: %s\\n%!\"","counters":[]},{"line":"            (Error.to_string_hum err) ) ;","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"      result","counters":[]},{"line":"","counters":[]},{"line":"    let add_commands' ?local test cs =","counters":[]},{"line":"      add_commands ?local test cs >>| assert_pool_apply cs","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"","counters":[]},{"line":"    let reorg ?(reorg_best_tip = false) test new_commands removed_commands =","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"      let%bind () =","counters":[]},{"line":"        Broadcast_pipe.Writer.write test.best_tip_diff_w","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"          { Mock_transition_frontier.new_commands =","counters":[]},{"line":"              List.map ~f:mk_with_status new_commands","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"          ; removed_commands = List.map ~f:mk_with_status removed_commands","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"          ; reorg_best_tip","counters":[]},{"line":"          }","counters":[]},{"line":"      in","counters":[]},{"line":"      Async.Scheduler.yield_until_no_jobs_remain ()","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let commit_commands test cs =","counters":[]},{"line":"      let ledger = Option.value_exn test.txn_pool.best_tip_ledger in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      List.iter cs ~f:(fun c ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          match User_command.forget_check c with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | User_command.Signed_command c -> (","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let (`If_this_is_used_it_should_have_a_comment_justifying_it valid)","counters":[]},{"line":"                  =","counters":[]},{"line":"                Signed_command.to_valid_unsafe c","counters":[]},{"line":"              in","counters":[]},{"line":"              let applied =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Or_error.ok_exn","counters":[]},{"line":"                @@ Mina_ledger.Ledger.apply_user_command ~constraint_constants","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"                     ~txn_global_slot:Mina_numbers.Global_slot.zero ledger valid","counters":[]},{"line":"              in","counters":[]},{"line":"              match applied.body with","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              | Failed ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  failwith \"failed to apply user command to ledger\"","counters":[]},{"line":"              | _ ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  () )","counters":[]},{"line":"          | User_command.Zkapp_command p -> (","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let applied, _ =","counters":[]},{"line":"                Or_error.ok_exn","counters":[]},{"line":"                @@ Mina_ledger.Ledger.apply_zkapp_command_unchecked","counters":[{"col_start":66,"col_end":66,"count":0}]},{"line":"                     ~constraint_constants ~state_view:dummy_state_view ledger p","counters":[]},{"line":"              in","counters":[]},{"line":"              match With_status.status applied.command with","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              | Failed failures ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  failwithf","counters":[]},{"line":"                    \"failed to apply zkapp_command transaction to ledger: [%s]\"","counters":[]},{"line":"                    ( String.concat ~sep:\", \"","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"                    @@ List.bind","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                         ~f:(List.map ~f:Transaction_status.Failure.to_string)","counters":[]},{"line":"                         failures )","counters":[]},{"line":"                    ()","counters":[]},{"line":"              | Applied ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  () ) )","counters":[]},{"line":"","counters":[]},{"line":"    let commit_commands' test cs =","counters":[]},{"line":"      let open Mina_ledger in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let ledger = Option.value_exn test.txn_pool.best_tip_ledger in","counters":[]},{"line":"      test.best_tip_ref :=","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Ledger.Maskable.register_mask","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"          (Ledger.Any_ledger.cast (module Mina_ledger.Ledger) ledger)","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"          (Ledger.Mask.create ~depth:(Ledger.depth ledger) ()) ;","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"      let%map () = reorg test [] [] in","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"      commit_commands test cs ; ledger","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"","counters":[]},{"line":"    let advance_chain test cs = commit_commands test cs ; reorg test cs []","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"","counters":[]},{"line":"    (* TODO: remove this (all of these test should be expressed by committing txns to the ledger, not mutating accounts *)","counters":[]},{"line":"    let modify_ledger ledger ~idx ~balance ~nonce =","counters":[]},{"line":"      let id =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Account_id.create","counters":[]},{"line":"          (Signature_lib.Public_key.compress test_keys.(idx).public_key)","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"          Token_id.default","counters":[]},{"line":"      in","counters":[]},{"line":"      let loc =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Option.value_exn @@ Mina_ledger.Ledger.location_of_account ledger id","counters":[{"col_start":65,"col_end":65,"count":0}]},{"line":"      in","counters":[]},{"line":"      let account = Option.value_exn @@ Mina_ledger.Ledger.get ledger loc in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"      Mina_ledger.Ledger.set ledger loc","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { account with","counters":[]},{"line":"          balance = Currency.Balance.of_int balance","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"        ; nonce = Account.Nonce.of_int nonce","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"    let mk_linear_case_test t cmds =","counters":[]},{"line":"      assert_pool_txs t [] ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%bind () = add_commands' t cmds in","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"      let%bind () = advance_chain t (List.take independent_cmds 1) in","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"      assert_pool_txs t (List.drop cmds 1) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"      let%bind () =","counters":[]},{"line":"        advance_chain t (List.take (List.drop independent_cmds 1) 2)","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"      in","counters":[]},{"line":"      assert_pool_txs t (List.drop cmds 3) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"      Deferred.unit","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"transactions are removed in linear case (user cmds)\" =","counters":[]},{"line":"      Thread_safe.block_on_async_exn (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          let%bind test = setup_test () in","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"          mk_linear_case_test test independent_cmds )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"transactions are removed in linear case (zkapps)\" =","counters":[]},{"line":"      Thread_safe.block_on_async_exn (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          let%bind test = setup_test () in","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"          mk_zkapp_command_cmds test.txn_pool >>= mk_linear_case_test test )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"","counters":[]},{"line":"    let mk_remove_and_add_test t cmds =","counters":[]},{"line":"      assert_pool_txs t [] ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      (* omit the 1st (0-based) command *)","counters":[]},{"line":"      let%bind () = add_commands' t (List.hd_exn cmds :: List.drop cmds 2) in","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":47,"col_end":47,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"      commit_commands t (List.take cmds 1) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"      let%bind () = reorg t (List.take cmds 1) (List.slice cmds 1 2) in","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"      assert_pool_txs t (List.tl_exn cmds) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"      Deferred.unit","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"Transactions are removed and added back in fork changes \\","counters":[]},{"line":"                   (user cmds)\" =","counters":[]},{"line":"      Thread_safe.block_on_async_exn (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          let%bind test = setup_test () in","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"          mk_remove_and_add_test test independent_cmds )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"Transactions are removed and added back in fork changes \\","counters":[]},{"line":"                   (zkapps)\" =","counters":[]},{"line":"      Thread_safe.block_on_async_exn (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          let%bind test = setup_test () in","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"          mk_zkapp_command_cmds test.txn_pool >>= mk_remove_and_add_test test )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"","counters":[]},{"line":"    let mk_invalid_test t cmds =","counters":[]},{"line":"      assert_pool_txs t [] ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%bind () = advance_chain t (List.take cmds 2) in","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"      let%bind () =","counters":[]},{"line":"        add_commands t cmds >>| assert_pool_apply (List.drop cmds 2)","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":48,"col_end":48,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"      in","counters":[]},{"line":"      assert_pool_txs t (List.drop cmds 2) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"      Deferred.unit","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"invalid transactions are not accepted (user cmds)\" =","counters":[]},{"line":"      Thread_safe.block_on_async_exn (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          let%bind test = setup_test () in","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"          mk_invalid_test test independent_cmds )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"invalid transactions are not accepted (zkapps)\" =","counters":[]},{"line":"      Thread_safe.block_on_async_exn (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          let%bind test = setup_test () in","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"          mk_zkapp_command_cmds test.txn_pool >>= mk_invalid_test test )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"","counters":[]},{"line":"    let current_global_slot () =","counters":[]},{"line":"      let current_time = Block_time.now time_controller in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Consensus.Data.Consensus_time.(","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        of_time_exn ~constants:consensus_constants current_time","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"        |> to_global_slot)","counters":[]},{"line":"","counters":[]},{"line":"    let mk_now_invalid_test t _cmds ~mk_command =","counters":[]},{"line":"      let cmd1 =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        mk_command ~sender_idx:0 ~receiver_idx:5 ~fee:minimum_fee ~nonce:0","counters":[]},{"line":"          ~amount:99_999_999_999 ()","counters":[]},{"line":"      in","counters":[]},{"line":"      let cmd2 =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        mk_command ~sender_idx:0 ~receiver_idx:5 ~fee:minimum_fee ~nonce:0","counters":[]},{"line":"          ~amount:999_000_000_000 ()","counters":[]},{"line":"      in","counters":[]},{"line":"      assert_pool_txs t [] ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%bind () = add_commands' t [ cmd1 ] in","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"      assert_pool_txs t [ cmd1 ] ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%bind () = advance_chain t [ cmd2 ] in","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"      assert_pool_txs t [] ; Deferred.unit","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"Now-invalid transactions are removed from the pool on fork \\","counters":[]},{"line":"                   changes (user cmds)\" =","counters":[]},{"line":"      Thread_safe.block_on_async_exn (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          let%bind test = setup_test () in","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"          mk_now_invalid_test test independent_cmds","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ~mk_command:(mk_payment ?valid_until:None) )","counters":[]},{"line":"","counters":[]},{"line":"    let%test_unit \"Now-invalid transactions are removed from the pool on fork \\","counters":[]},{"line":"                   changes (zkapps)\" =","counters":[]},{"line":"      Thread_safe.block_on_async_exn (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          let%bind test = setup_test () in","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"          mk_zkapp_command_cmds test.txn_pool","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"          >>= mk_now_invalid_test test","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                ~mk_command:","counters":[]},{"line":"                  (mk_transfer_zkapp_command ?valid_period:None","counters":[]},{"line":"                     ?fee_payer_idx:None ) )","counters":[]},{"line":"","counters":[]},{"line":"    let mk_expired_not_accepted_test t ~padding cmds =","counters":[]},{"line":"      assert_pool_txs t [] ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%bind () =","counters":[]},{"line":"        let current_time = Block_time.now time_controller in","counters":[]},{"line":"        let slot_end =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Consensus.Data.Consensus_time.(","counters":[]},{"line":"            of_time_exn ~constants:consensus_constants current_time","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"            |> end_time ~constants:consensus_constants)","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"        in","counters":[]},{"line":"        at (Block_time.to_time_exn slot_end)","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"      in","counters":[]},{"line":"      let curr_slot = current_global_slot () in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let slot_padding = Mina_numbers.Global_slot.of_int padding in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let curr_slot_plus_padding =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Mina_numbers.Global_slot.add curr_slot slot_padding","counters":[]},{"line":"      in","counters":[]},{"line":"      let valid_command =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        mk_payment ~valid_until:curr_slot_plus_padding ~sender_idx:1","counters":[]},{"line":"          ~fee:minimum_fee ~nonce:1 ~receiver_idx:7 ~amount:1_000_000_000 ()","counters":[]},{"line":"      in","counters":[]},{"line":"      let expired_commands =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [ mk_payment ~valid_until:curr_slot ~sender_idx:0 ~fee:minimum_fee","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"            ~nonce:1 ~receiver_idx:9 ~amount:1_000_000_000 ()","counters":[]},{"line":"        ; mk_payment ~sender_idx:0 ~fee:minimum_fee ~nonce:2 ~receiver_idx:9","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"            ~amount:1_000_000_000 ()","counters":[]},{"line":"        ]","counters":[]},{"line":"      in","counters":[]},{"line":"      (* Wait till global slot increases by 1 which invalidates","counters":[]},{"line":"         the commands with valid_until = curr_slot","counters":[]},{"line":"      *)","counters":[]},{"line":"      let%bind () =","counters":[]},{"line":"        after","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          (Block_time.Span.to_time_span","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"             consensus_constants.block_window_duration_ms )","counters":[]},{"line":"      in","counters":[]},{"line":"      let all_valid_commands = cmds @ [ valid_command ] in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%bind () =","counters":[]},{"line":"        add_commands t (all_valid_commands @ expired_commands)","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"        >>| assert_pool_apply all_valid_commands","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"      in","counters":[]},{"line":"      assert_pool_txs t all_valid_commands ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Deferred.unit","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"expired transactions are not accepted (user cmds)\" =","counters":[]},{"line":"      Thread_safe.block_on_async_exn (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          let%bind test = setup_test () in","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"          mk_expired_not_accepted_test test ~padding:10 independent_cmds )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"expired transactions are not accepted (zkapps)\" =","counters":[]},{"line":"      Thread_safe.block_on_async_exn (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          let%bind test = setup_test () in","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"          mk_zkapp_command_cmds test.txn_pool","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"          >>= mk_expired_not_accepted_test test ~padding:55 )","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"Expired transactions that are already in the pool are \\","counters":[]},{"line":"                   removed from the pool when best tip changes (user commands)\"","counters":[]},{"line":"        =","counters":[]},{"line":"      Thread_safe.block_on_async_exn (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          let%bind t = setup_test () in","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"          assert_pool_txs t [] ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let curr_slot = current_global_slot () in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let curr_slot_plus_three =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Mina_numbers.Global_slot.(add curr_slot (of_int 3))","counters":[{"col_start":40,"col_end":40,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"          in","counters":[]},{"line":"          let curr_slot_plus_seven =","counters":[]},{"line":"            Mina_numbers.Global_slot.(add curr_slot (of_int 7))","counters":[{"col_start":40,"col_end":40,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"          in","counters":[]},{"line":"          let few_now =","counters":[]},{"line":"            List.take independent_cmds (List.length independent_cmds / 2)","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"          in","counters":[]},{"line":"          let expires_later1 =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            mk_payment ~valid_until:curr_slot_plus_three ~sender_idx:0","counters":[]},{"line":"              ~fee:minimum_fee ~nonce:1 ~receiver_idx:9 ~amount:10_000_000_000","counters":[]},{"line":"              ()","counters":[]},{"line":"          in","counters":[]},{"line":"          let expires_later2 =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            mk_payment ~valid_until:curr_slot_plus_seven ~sender_idx:0","counters":[]},{"line":"              ~fee:minimum_fee ~nonce:2 ~receiver_idx:9 ~amount:10_000_000_000","counters":[]},{"line":"              ()","counters":[]},{"line":"          in","counters":[]},{"line":"          let valid_commands = few_now @ [ expires_later1; expires_later2 ] in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let%bind () = add_commands' t valid_commands in","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"          assert_pool_txs t valid_commands ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          (* new commands from best tip diff should be removed from the pool *)","counters":[]},{"line":"          (* update the nonce to be consistent with the commands in the block *)","counters":[]},{"line":"          modify_ledger !(t.best_tip_ref) ~idx:0 ~balance:1_000_000_000_000_000","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ~nonce:2 ;","counters":[]},{"line":"          let%bind () = reorg t [ List.nth_exn few_now 0; expires_later1 ] [] in","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"          let%bind () = Async.Scheduler.yield_until_no_jobs_remain () in","counters":[{"col_start":65,"col_end":65,"count":0}]},{"line":"          assert_pool_txs t (expires_later2 :: List.drop few_now 1) ;","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"          (* Add new commands, remove old commands some of which are now expired *)","counters":[]},{"line":"          let expired_command =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            mk_payment ~valid_until:curr_slot ~sender_idx:9 ~fee:minimum_fee","counters":[]},{"line":"              ~nonce:0 ~receiver_idx:5 ~amount:1_000_000_000 ()","counters":[]},{"line":"          in","counters":[]},{"line":"          let unexpired_command =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            mk_payment ~valid_until:curr_slot_plus_seven ~sender_idx:8","counters":[]},{"line":"              ~fee:minimum_fee ~nonce:0 ~receiver_idx:9 ~amount:1_000_000_000 ()","counters":[]},{"line":"          in","counters":[]},{"line":"          let valid_forever = List.nth_exn few_now 0 in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let removed_commands =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            [ valid_forever","counters":[]},{"line":"            ; expires_later1","counters":[]},{"line":"            ; expired_command","counters":[]},{"line":"            ; unexpired_command","counters":[]},{"line":"            ]","counters":[]},{"line":"          in","counters":[]},{"line":"          let n_block_times n =","counters":[]},{"line":"            Int64.(","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Block_time.Span.to_ms consensus_constants.block_window_duration_ms","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"              * n)","counters":[]},{"line":"            |> Block_time.Span.of_ms","counters":[]},{"line":"          in","counters":[]},{"line":"          let%bind () =","counters":[]},{"line":"            after (Block_time.Span.to_time_span (n_block_times 3L))","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":46,"col_end":46,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"          in","counters":[]},{"line":"          modify_ledger !(t.best_tip_ref) ~idx:0 ~balance:1_000_000_000_000_000","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ~nonce:1 ;","counters":[]},{"line":"          let%bind _ = reorg t [ valid_forever ] removed_commands in","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"          (* expired_command should not be in the pool because they are expired","counters":[]},{"line":"             and (List.nth few_now 0) because it was committed in a block","counters":[]},{"line":"          *)","counters":[]},{"line":"          assert_pool_txs t","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ( expires_later1 :: expires_later2 :: unexpired_command","counters":[]},{"line":"            :: List.drop few_now 1 ) ;","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"          (* after 5 block times there should be no expired transactions *)","counters":[]},{"line":"          let%bind () =","counters":[]},{"line":"            after (Block_time.Span.to_time_span (n_block_times 5L))","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":46,"col_end":46,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%bind _ = reorg t [] [] in","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"          assert_pool_txs t (List.drop few_now 1) ;","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"          Deferred.unit )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"Expired transactions that are already in the pool are \\","counters":[]},{"line":"                   removed from the pool when best tip changes (zkapps)\" =","counters":[]},{"line":"      Thread_safe.block_on_async_exn (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          let eight_block_time =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Int64.(","counters":[]},{"line":"              Block_time.Span.to_ms consensus_constants.block_window_duration_ms","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"              * 8L)","counters":[]},{"line":"            |> Int64.to_int |> Option.value_exn |> Time_ns.Span.of_int_ms","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"          in","counters":[]},{"line":"          (* Since expiration for zkapp and transaction_pool uses the same constant, so I use the duration_of_the_test which is 8_slot + 1 sec as the expiration, so that the transaction won't be expired before the test is over. *)","counters":[]},{"line":"          let expiry = Time_ns.Span.(eight_block_time + of_sec 1.) in","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"          let eight_block =","counters":[]},{"line":"            Block_time.Span.of_time_span","counters":[]},{"line":"            @@ Time_ns.Span.to_span_float_round_nearest eight_block_time","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%bind t = setup_test ~expiry () in","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"          assert_pool_txs t [] ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let curr_time =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Block_time.sub (Block_time.of_time (Time.now ())) eight_block","counters":[{"col_start":45,"col_end":45,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"          in","counters":[]},{"line":"          let n_block_times n =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Int64.(","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Block_time.Span.to_ms consensus_constants.block_window_duration_ms","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"              * n)","counters":[]},{"line":"            |> Block_time.Span.of_ms","counters":[]},{"line":"          in","counters":[]},{"line":"          let three_slot = n_block_times 3L in","counters":[]},{"line":"          let seven_slot = n_block_times 7L in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let curr_time_plus_three = Block_time.add curr_time three_slot in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let curr_time_plus_seven = Block_time.add curr_time seven_slot in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let few_now =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            List.take independent_cmds (List.length independent_cmds / 2)","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"          in","counters":[]},{"line":"          let expires_later1 =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            mk_transfer_zkapp_command","counters":[]},{"line":"              ~valid_period:{ lower = curr_time; upper = curr_time_plus_three }","counters":[]},{"line":"              ~fee_payer_idx:(0, 1) ~sender_idx:1 ~receiver_idx:9","counters":[]},{"line":"              ~fee:minimum_fee ~amount:10_000_000_000 ~nonce:1 ()","counters":[]},{"line":"          in","counters":[]},{"line":"          let expires_later2 =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            mk_transfer_zkapp_command","counters":[]},{"line":"              ~valid_period:{ lower = curr_time; upper = curr_time_plus_seven }","counters":[]},{"line":"              ~fee_payer_idx:(0, 2) ~sender_idx:1 ~receiver_idx:9","counters":[]},{"line":"              ~fee:minimum_fee ~amount:10_000_000_000 ~nonce:2 ()","counters":[]},{"line":"          in","counters":[]},{"line":"          let valid_commands = few_now @ [ expires_later1; expires_later2 ] in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let%bind () = add_commands' t valid_commands in","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"          assert_pool_txs t valid_commands ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          (* new commands from best tip diff should be removed from the pool *)","counters":[]},{"line":"          (* update the nonce to be consistent with the commands in the block *)","counters":[]},{"line":"          modify_ledger !(t.best_tip_ref) ~idx:0 ~balance:1_000_000_000_000_000","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ~nonce:2 ;","counters":[]},{"line":"          modify_ledger !(t.best_tip_ref) ~idx:1 ~balance:1_000_000_000_000_000","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ~nonce:2 ;","counters":[]},{"line":"          let%bind () = reorg t (List.take few_now 2 @ [ expires_later1 ]) [] in","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"          assert_pool_txs t (expires_later2 :: List.drop few_now 2) ;","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"          (* Add new commands, remove old commands some of which are now expired *)","counters":[]},{"line":"          let expired_zkapp =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            mk_transfer_zkapp_command","counters":[]},{"line":"              ~valid_period:{ lower = curr_time; upper = curr_time }","counters":[]},{"line":"              ~fee_payer_idx:(9, 0) ~sender_idx:1 ~fee:minimum_fee ~nonce:3","counters":[]},{"line":"              ~receiver_idx:5 ~amount:1_000_000_000 ()","counters":[]},{"line":"          in","counters":[]},{"line":"          let unexpired_zkapp =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            mk_transfer_zkapp_command","counters":[]},{"line":"              ~valid_period:{ lower = curr_time; upper = curr_time_plus_seven }","counters":[]},{"line":"              ~fee_payer_idx:(8, 0) ~sender_idx:1 ~fee:minimum_fee ~nonce:4","counters":[]},{"line":"              ~receiver_idx:9 ~amount:1_000_000_000 ()","counters":[]},{"line":"          in","counters":[]},{"line":"          let valid_forever = List.nth_exn few_now 0 in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let removed_commands =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            [ valid_forever; expires_later1; expired_zkapp; unexpired_zkapp ]","counters":[]},{"line":"          in","counters":[]},{"line":"          let n_block_times n =","counters":[]},{"line":"            Int64.(","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Block_time.Span.to_ms consensus_constants.block_window_duration_ms","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"              * n)","counters":[]},{"line":"            |> Block_time.Span.of_ms","counters":[]},{"line":"          in","counters":[]},{"line":"          let%bind () =","counters":[]},{"line":"            after (Block_time.Span.to_time_span (n_block_times 3L))","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":46,"col_end":46,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"          in","counters":[]},{"line":"          modify_ledger !(t.best_tip_ref) ~idx:0 ~balance:1_000_000_000_000_000","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ~nonce:1 ;","counters":[]},{"line":"          modify_ledger !(t.best_tip_ref) ~idx:1 ~balance:1_000_000_000_000_000","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ~nonce:1 ;","counters":[]},{"line":"          let%bind () = reorg t [ valid_forever ] removed_commands in","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"          (* expired_command should not be in the pool because they are expired","counters":[]},{"line":"             and (List.nth few_now 0) because it was committed in a block","counters":[]},{"line":"          *)","counters":[]},{"line":"          assert_pool_txs t","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ( expires_later1 :: expires_later2 :: unexpired_zkapp","counters":[]},{"line":"            :: List.drop few_now 2 ) ;","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"          (* after 5 block times there should be no expired transactions *)","counters":[]},{"line":"          let%bind () =","counters":[]},{"line":"            after (Block_time.Span.to_time_span (n_block_times 5L))","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":46,"col_end":46,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%bind () = reorg t [] [] in","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"          assert_pool_txs t (List.drop few_now 2) ;","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"          Deferred.unit )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"Aged-based expiry (zkapps)\" =","counters":[]},{"line":"      Thread_safe.block_on_async_exn (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          let expiry = Time_ns.Span.of_sec 1. in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let%bind t = setup_test ~expiry () in","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"          assert_pool_txs t [] ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let account_update_transfer =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            mk_transfer_zkapp_command ~fee_payer_idx:(0, 0) ~sender_idx:1","counters":[]},{"line":"              ~receiver_idx:9 ~fee:minimum_fee ~amount:10_000_000_000 ~nonce:0","counters":[]},{"line":"              ()","counters":[]},{"line":"          in","counters":[]},{"line":"          let valid_commands = [ account_update_transfer ] in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let%bind () = add_commands' t valid_commands in","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"          assert_pool_txs t valid_commands ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let%bind () = after (Time.Span.of_sec 2.) in","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"          let%bind () = reorg t [] [] in","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"          assert_pool_txs t [] ; Deferred.unit )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"Now-invalid transactions are removed from the pool when the \\","counters":[]},{"line":"                   transition frontier is recreated (user cmds)\" =","counters":[]},{"line":"      Thread_safe.block_on_async_exn (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          (* Set up initial frontier *)","counters":[]},{"line":"          let%bind t = setup_test () in","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"          assert_pool_txs t [] ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let%bind _ = add_commands t independent_cmds in","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"          assert_pool_txs t independent_cmds ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          (* Destroy initial frontier *)","counters":[]},{"line":"          Broadcast_pipe.Writer.close t.best_tip_diff_w ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let%bind _ = Broadcast_pipe.Writer.write t.frontier_pipe_w None in","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"          (* Set up second frontier *)","counters":[]},{"line":"          let ((_, ledger_ref2) as frontier2), _best_tip_diff_w2 =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Mock_transition_frontier.create ()","counters":[]},{"line":"          in","counters":[]},{"line":"          modify_ledger !ledger_ref2 ~idx:0 ~balance:20_000_000_000_000 ~nonce:5 ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          modify_ledger !ledger_ref2 ~idx:1 ~balance:0 ~nonce:0 ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          modify_ledger !ledger_ref2 ~idx:2 ~balance:0 ~nonce:1 ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let%bind _ =","counters":[]},{"line":"            Broadcast_pipe.Writer.write t.frontier_pipe_w (Some frontier2)","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"          in","counters":[]},{"line":"          assert_pool_txs t (List.drop independent_cmds 3) ;","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"          Deferred.unit )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"transaction replacement works\" =","counters":[]},{"line":"      Thread_safe.block_on_async_exn","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      @@ fun () ->","counters":[]},{"line":"      let%bind t = setup_test () in","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"      let set_sender idx (tx : Signed_command.t) =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let sender_kp = test_keys.(idx) in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let sender_pk = Public_key.compress sender_kp.public_key in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let payload : Signed_command.Payload.t =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          match tx.payload with","counters":[]},{"line":"          | { common; body = Payment payload } ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              { common = { common with fee_payer_pk = sender_pk }","counters":[]},{"line":"              ; body = Payment { payload with source_pk = sender_pk }","counters":[]},{"line":"              }","counters":[]},{"line":"          | { common; body = Stake_delegation (Set_delegate payload) } ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              { common = { common with fee_payer_pk = sender_pk }","counters":[]},{"line":"              ; body =","counters":[]},{"line":"                  Stake_delegation","counters":[]},{"line":"                    (Set_delegate { payload with delegator = sender_pk })","counters":[]},{"line":"              }","counters":[]},{"line":"        in","counters":[]},{"line":"        User_command.Signed_command (Signed_command.sign sender_kp payload)","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"      in","counters":[]},{"line":"      let txs0 =","counters":[]},{"line":"        [ mk_payment' ~sender_idx:0 ~fee:minimum_fee ~nonce:0 ~receiver_idx:9","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"            ~amount:20_000_000_000 ()","counters":[]},{"line":"        ; mk_payment' ~sender_idx:0 ~fee:minimum_fee ~nonce:1 ~receiver_idx:9","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"            ~amount:12_000_000_000 ()","counters":[]},{"line":"        ; mk_payment' ~sender_idx:0 ~fee:minimum_fee ~nonce:2 ~receiver_idx:9","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"            ~amount:500_000_000_000 ()","counters":[]},{"line":"        ]","counters":[]},{"line":"      in","counters":[]},{"line":"      let txs0' = List.map txs0 ~f:Signed_command.forget_check in","counters":[]},{"line":"      let txs1 = List.map ~f:(set_sender 1) txs0' in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"      let txs2 = List.map ~f:(set_sender 2) txs0' in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"      let txs3 = List.map ~f:(set_sender 3) txs0' in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"      let txs_all =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        List.map ~f:(fun x -> User_command.Signed_command x) txs0","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"        @ txs1 @ txs2 @ txs3","counters":[]},{"line":"      in","counters":[]},{"line":"      Core.Printf.printf !\"PHASE 1\\n%!\" ;","counters":[]},{"line":"      let%bind () = add_commands' t txs_all in","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"      assert_pool_txs t txs_all ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let replace_txs =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [ (* sufficient fee *)","counters":[]},{"line":"          mk_payment ~sender_idx:0","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"            ~fee:(minimum_fee + Currency.Fee.to_int Indexed_pool.replace_fee)","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"            ~nonce:0 ~receiver_idx:1 ~amount:440_000_000_000 ()","counters":[]},{"line":"        ; (* insufficient fee *)","counters":[]},{"line":"          mk_payment ~sender_idx:1 ~fee:minimum_fee ~nonce:0 ~receiver_idx:1","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"            ~amount:788_000_000_000 ()","counters":[]},{"line":"        ; (* sufficient *)","counters":[]},{"line":"          mk_payment ~sender_idx:2","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"            ~fee:(minimum_fee + Currency.Fee.to_int Indexed_pool.replace_fee)","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"            ~nonce:1 ~receiver_idx:4 ~amount:721_000_000_000 ()","counters":[]},{"line":"        ; (* insufficient *)","counters":[]},{"line":"          (let amount = 927_000_000_000 in","counters":[]},{"line":"           let fee =","counters":[]},{"line":"             let ledger = !(t.best_tip_ref) in","counters":[]},{"line":"             let sender_kp = test_keys.(3) in","counters":[]},{"line":"             let sender_pk = Public_key.compress sender_kp.public_key in","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"             let sender_aid = Account_id.create sender_pk Token_id.default in","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"             let location =","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"               Mock_base_ledger.location_of_account ledger sender_aid","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"               |> Option.value_exn","counters":[]},{"line":"             in","counters":[]},{"line":"             (* Spend all of the tokens in the account. Should fail because the","counters":[]},{"line":"                command with nonce=0 will already have spent some.","counters":[]},{"line":"             *)","counters":[]},{"line":"             let account =","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"               Mock_base_ledger.get ledger location |> Option.value_exn","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"             in","counters":[]},{"line":"             Currency.Balance.to_int account.balance - amount","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"           in","counters":[]},{"line":"           mk_payment ~sender_idx:3 ~fee ~nonce:1 ~receiver_idx:4 ~amount () )","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"        ]","counters":[]},{"line":"      in","counters":[]},{"line":"      Core.Printf.printf !\"PHASE 2\\n%!\" ;","counters":[]},{"line":"      add_commands t replace_txs","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"      >>| assert_pool_apply","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"            [ List.nth_exn replace_txs 0; List.nth_exn replace_txs 2 ]","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"it drops queued transactions if a committed one makes there \\","counters":[]},{"line":"                   be insufficient funds\" =","counters":[]},{"line":"      Thread_safe.block_on_async_exn","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      @@ fun () ->","counters":[]},{"line":"      let%bind t = setup_test () in","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"      let txs =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [ mk_payment ~sender_idx:0 ~fee:minimum_fee ~nonce:0 ~receiver_idx:9","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"            ~amount:20_000_000_000 ()","counters":[]},{"line":"        ; mk_payment ~sender_idx:0 ~fee:minimum_fee ~nonce:1 ~receiver_idx:5","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"            ~amount:77_000_000_000 ()","counters":[]},{"line":"        ; mk_payment ~sender_idx:0 ~fee:minimum_fee ~nonce:2 ~receiver_idx:3","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"            ~amount:891_000_000_000 ()","counters":[]},{"line":"        ]","counters":[]},{"line":"      in","counters":[]},{"line":"      let committed_tx =","counters":[]},{"line":"        mk_payment ~sender_idx:0 ~fee:minimum_fee ~nonce:0 ~receiver_idx:2","counters":[]},{"line":"          ~amount:25_000_000_000 ()","counters":[]},{"line":"      in","counters":[]},{"line":"      let%bind () = add_commands' t txs in","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"      assert_pool_txs t txs ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      modify_ledger !(t.best_tip_ref) ~idx:0 ~balance:970_000_000_000 ~nonce:1 ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%bind () = reorg t [ committed_tx ] [] in","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"      assert_pool_txs t [ List.nth_exn txs 1 ] ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"      Deferred.unit","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"max size is maintained\" =","counters":[]},{"line":"      Quickcheck.test ~trials:500","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"        let%bind init_ledger_state =","counters":[]},{"line":"          Mina_ledger.Ledger.gen_initial_ledger_state","counters":[]},{"line":"        in","counters":[]},{"line":"        let%bind cmds_count = Int.gen_incl pool_max_size (pool_max_size * 2) in","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"        let%bind cmds =","counters":[]},{"line":"          User_command.Valid.Gen.sequence ~sign_type:`Real ~length:cmds_count","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"            init_ledger_state","counters":[]},{"line":"        in","counters":[]},{"line":"        return (init_ledger_state, cmds))","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        ~f:(fun (init_ledger_state, cmds) ->","counters":[]},{"line":"          Thread_safe.block_on_async_exn (fun () ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              let%bind t = setup_test () in","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"              let new_ledger =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Mina_ledger.Ledger.create_ephemeral","counters":[]},{"line":"                  ~depth:(Mina_ledger.Ledger.depth !(t.best_tip_ref))","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"                  ()","counters":[]},{"line":"              in","counters":[]},{"line":"              Mina_ledger.Ledger.apply_initial_ledger_state new_ledger","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                init_ledger_state ;","counters":[]},{"line":"              t.best_tip_ref := new_ledger ;","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              let%bind () = reorg ~reorg_best_tip:true t [] [] in","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"              let cmds1, cmds2 = List.split_n cmds pool_max_size in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              let%bind apply_res1 = add_commands t cmds1 in","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"              assert (Result.is_ok apply_res1) ;","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"              [%test_eq: int] pool_max_size (Indexed_pool.size t.txn_pool.pool) ;","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"              let%map _apply_res2 = add_commands t cmds2 in","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"              (* N.B. Adding a transaction when the pool is full may drop > 1","counters":[]},{"line":"                 command, so the size now is not necessarily the maximum.","counters":[]},{"line":"                 Applying the diff may also return an error if none of the new","counters":[]},{"line":"                 commands have higher fee than the lowest one already in the","counters":[]},{"line":"                 pool.","counters":[]},{"line":"              *)","counters":[]},{"line":"              assert (Indexed_pool.size t.txn_pool.pool <= pool_max_size) ) )","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"","counters":[]},{"line":"    let assert_rebroadcastable test cmds =","counters":[]},{"line":"      let expected =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        if List.is_empty cmds then []","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"        else","counters":[]},{"line":"          [ List.map cmds","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"              ~f:","counters":[]},{"line":"                (Fn.compose Transaction_hash.User_command.create","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                   User_command.forget_check )","counters":[]},{"line":"          ]","counters":[]},{"line":"      in","counters":[]},{"line":"      let actual =","counters":[]},{"line":"        Test.Resource_pool.get_rebroadcastable test.txn_pool","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"          ~has_timed_out:(Fn.const `Ok)","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"        |> List.map ~f:(List.map ~f:Transaction_hash.User_command.create)","counters":[]},{"line":"      in","counters":[]},{"line":"      if List.length actual > 1 then","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"        failwith \"unexpected number of rebroadcastable diffs\" ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      List.iter (List.zip_exn actual expected) ~f:(fun (a, b) ->","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"          assert_user_command_sets_equal a b )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"    let mk_rebroadcastable_test t cmds =","counters":[]},{"line":"      assert_pool_txs t [] ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      assert_rebroadcastable t [] ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      (* Locally generated transactions are rebroadcastable *)","counters":[]},{"line":"      let%bind () = add_commands' ~local:true t (List.take cmds 2) in","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"      assert_pool_txs t (List.take cmds 2) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"      assert_rebroadcastable t (List.take cmds 2) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"      (* Adding non-locally-generated transactions doesn't affect","counters":[]},{"line":"         rebroadcastable pool *)","counters":[]},{"line":"      let%bind () = add_commands' ~local:false t (List.slice cmds 2 5) in","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"      assert_pool_txs t (List.take cmds 5) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"      assert_rebroadcastable t (List.take cmds 2) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"      (* When locally generated transactions are committed they are no","counters":[]},{"line":"         longer rebroadcastable *)","counters":[]},{"line":"      let%bind () = add_commands' ~local:true t (List.slice cmds 5 7) in","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"      let%bind checkpoint_1 = commit_commands' t (List.take cmds 1) in","counters":[{"col_start":45,"col_end":45,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"      let%bind checkpoint_2 = commit_commands' t (List.slice cmds 1 5) in","counters":[{"col_start":45,"col_end":45,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"      let%bind () = reorg t (List.take cmds 5) [] in","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"      assert_pool_txs t (List.slice cmds 5 7) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"      assert_rebroadcastable t (List.slice cmds 5 7) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"      (* Reorgs put locally generated transactions back into the","counters":[]},{"line":"         rebroadcastable pool, if they were removed and not re-added *)","counters":[]},{"line":"      (* restore up to after the application of the first command *)","counters":[]},{"line":"      t.best_tip_ref := checkpoint_2 ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      (* reorge both removes and re-adds the first command (which is local) *)","counters":[]},{"line":"      let%bind () = reorg t (List.take cmds 1) (List.take cmds 5) in","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"      assert_pool_txs t (List.slice cmds 1 7) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"      assert_rebroadcastable t (List.nth_exn cmds 1 :: List.slice cmds 5 7) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":43,"col_end":43,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"      (* Committing them again removes them from the pool again. *)","counters":[]},{"line":"      commit_commands t (List.slice cmds 1 7) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"      let%bind () = reorg t (List.slice cmds 1 7) [] in","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"      assert_pool_txs t [] ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      assert_rebroadcastable t [] ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      (* When transactions expire from rebroadcast pool they are gone. This","counters":[]},{"line":"         doesn't affect the main pool.","counters":[]},{"line":"      *)","counters":[]},{"line":"      t.best_tip_ref := checkpoint_1 ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%bind () = reorg t [] (List.take cmds 7) in","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"      assert_pool_txs t (List.take cmds 7) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"      assert_rebroadcastable t (List.take cmds 2 @ List.slice cmds 5 7) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"      ignore","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ( Test.Resource_pool.get_rebroadcastable t.txn_pool","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"            ~has_timed_out:(Fn.const `Timed_out)","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"          : User_command.t list list ) ;","counters":[]},{"line":"      assert_rebroadcastable t [] ;","counters":[]},{"line":"      Deferred.unit","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"rebroadcastable transaction behavior (user cmds)\" =","counters":[]},{"line":"      Thread_safe.block_on_async_exn (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          let%bind test = setup_test () in","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"          mk_rebroadcastable_test test independent_cmds )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"rebroadcastable transaction behavior (zkapps)\" =","counters":[]},{"line":"      Thread_safe.block_on_async_exn (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          let%bind test = setup_test () in","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"          mk_zkapp_command_cmds test.txn_pool >>= mk_rebroadcastable_test test )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":72,"col_end":72,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"apply user cmds and zkapps\" =","counters":[]},{"line":"      Thread_safe.block_on_async_exn (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          let%bind t = setup_test () in","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"          let num_cmds = Array.length test_keys in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          (* the user cmds and snapp cmds are taken from the same list of keys,","counters":[]},{"line":"             so splitting by the order from that list makes sure that they","counters":[]},{"line":"             don't share fee payer keys","counters":[]},{"line":"             therefore, the original nonces in the accounts are valid","counters":[]},{"line":"          *)","counters":[]},{"line":"          let take_len = num_cmds / 2 in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let%bind snapp_cmds =","counters":[]},{"line":"            let%map cmds = mk_zkapp_command_cmds t.txn_pool in","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"            List.take cmds take_len","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          in","counters":[]},{"line":"          let user_cmds = List.drop independent_cmds take_len in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let all_cmds = snapp_cmds @ user_cmds in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          assert_pool_txs t [] ;","counters":[]},{"line":"          let%bind () = add_commands' t all_cmds in","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"          assert_pool_txs t all_cmds ; Deferred.unit )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"  end )","counters":[{"col_start":6,"col_end":6,"count":1}]}]}