{"filename":"src/lib/allocation_functor/table.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"(** immutable, serializable statistics derived from allocation data *)","counters":[]},{"line":"module Allocation_statistics = struct","counters":[]},{"line":"  (* times represented in ms *)","counters":[]},{"line":"  type quartiles = { q1 : float; q2 : float; q3 : float; q4 : float }","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":42,"col_end":42,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":50,"col_end":50,"count":0},{"col_start":54,"col_end":54,"count":0},{"col_start":57,"col_end":57,"count":0},{"col_start":62,"col_end":62,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"  [@@deriving yojson]","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"","counters":[]},{"line":"  let make_quartiles n = { q1 = n; q2 = n; q3 = n; q4 = n }","counters":[{"col_start":25,"col_end":25,"count":4}]},{"line":"","counters":[]},{"line":"  let empty_quartiles = make_quartiles 0.0","counters":[{"col_start":37,"col_end":37,"count":1}]},{"line":"","counters":[]},{"line":"  type t = { count : int; lifetimes : quartiles } [@@deriving yojson]","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":46,"col_end":46,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"","counters":[]},{"line":"  let write_metrics { count; lifetimes } object_id =","counters":[]},{"line":"    let open Mina_metrics in","counters":[{"col_start":4,"col_end":4,"count":4}]},{"line":"    let open Mina_metrics.Object_lifetime_statistics in","counters":[]},{"line":"    let { q1; q2; q3; q4 } = lifetimes in","counters":[]},{"line":"    let q x = lifetime_quartile_ms ~name:object_id ~quartile:x in","counters":[{"col_start":14,"col_end":14,"count":16}]},{"line":"    Gauge.set (live_count ~name:object_id) (Int.to_float count) ;","counters":[{"col_start":55,"col_end":55,"count":4}]},{"line":"    Gauge.set (q `Q1) q1 ;","counters":[{"col_start":4,"col_end":4,"count":4},{"col_start":15,"col_end":15,"count":4}]},{"line":"    Gauge.set (q `Q2) q2 ;","counters":[{"col_start":4,"col_end":4,"count":4},{"col_start":15,"col_end":15,"count":4}]},{"line":"    Gauge.set (q `Q3) q3 ;","counters":[{"col_start":4,"col_end":4,"count":4},{"col_start":15,"col_end":15,"count":4}]},{"line":"    Gauge.set (q `Q4) q4","counters":[{"col_start":4,"col_end":4,"count":4},{"col_start":15,"col_end":15,"count":4}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(** mutable data for an object we track allocations of (one exists per object type) *)","counters":[]},{"line":"module Allocation_data = struct","counters":[]},{"line":"  (* stops being unique after 2^{30,62} values; perhaps we should use guids instead *)","counters":[]},{"line":"  type allocation_id = int","counters":[]},{"line":"","counters":[]},{"line":"  let initial_allocation_id = Int.min_value","counters":[]},{"line":"","counters":[]},{"line":"  (* indexed queue data structure would be more effecient here, but keeping this simple for now *)","counters":[]},{"line":"  type t =","counters":[]},{"line":"    { allocation_times : (allocation_id * Time.t) Queue.t","counters":[]},{"line":"    ; mutable next_allocation_id : allocation_id","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let create () =","counters":[]},{"line":"    { allocation_times = Queue.create ()","counters":[{"col_start":4,"col_end":4,"count":2},{"col_start":36,"col_end":36,"count":2}]},{"line":"    ; next_allocation_id = initial_allocation_id","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let register_allocation data =","counters":[]},{"line":"    let id = data.next_allocation_id in","counters":[{"col_start":4,"col_end":4,"count":3}]},{"line":"    Queue.enqueue data.allocation_times (id, Time.now ()) ;","counters":[{"col_start":52,"col_end":52,"count":3}]},{"line":"    data.next_allocation_id <- data.next_allocation_id + 1 ;","counters":[{"col_start":4,"col_end":4,"count":3}]},{"line":"    id","counters":[]},{"line":"","counters":[]},{"line":"  (* currently O(n) wrt queue size *)","counters":[]},{"line":"  let unregister_allocation data id =","counters":[]},{"line":"    Queue.filter_inplace data.allocation_times ~f:(fun (id', _) -> id = id')","counters":[{"col_start":4,"col_end":4,"count":1},{"col_start":67,"col_end":67,"count":1}]},{"line":"","counters":[]},{"line":"  let compute_statistics { allocation_times; _ } =","counters":[]},{"line":"    let now = Time.now () in","counters":[{"col_start":4,"col_end":4,"count":4}]},{"line":"    let count = Queue.length allocation_times in","counters":[{"col_start":4,"col_end":4,"count":4}]},{"line":"    let lifetime_ms_of_time time = Time.Span.to_ms (Time.diff now time) in","counters":[{"col_start":4,"col_end":4,"count":4},{"col_start":35,"col_end":35,"count":8},{"col_start":60,"col_end":60,"count":8}]},{"line":"    let get_lifetime_ms i =","counters":[]},{"line":"      lifetime_ms_of_time (snd @@ Queue.get allocation_times i)","counters":[{"col_start":6,"col_end":6,"count":8},{"col_start":29,"col_end":29,"count":8},{"col_start":42,"col_end":42,"count":8}]},{"line":"    in","counters":[]},{"line":"    let mean_indices max_len =","counters":[]},{"line":"      let m = max_len - 1 in","counters":[{"col_start":6,"col_end":6,"count":3}]},{"line":"      if m mod 2 = 0 then [ m / 2 ] else [ m / 2; (m / 2) + 1 ]","counters":[{"col_start":26,"col_end":26,"count":2},{"col_start":41,"col_end":41,"count":1}]},{"line":"    in","counters":[]},{"line":"    let mean offset length =","counters":[]},{"line":"      let indices =","counters":[{"col_start":6,"col_end":6,"count":3}]},{"line":"        mean_indices length |> List.filter ~f:(fun x -> x < count)","counters":[{"col_start":19,"col_end":19,"count":3},{"col_start":56,"col_end":56,"count":4}]},{"line":"      in","counters":[]},{"line":"      let sum =","counters":[{"col_start":6,"col_end":6,"count":3}]},{"line":"        List.fold_left indices ~init:0.0 ~f:(fun acc i ->","counters":[]},{"line":"            acc +. get_lifetime_ms (count - 1 - (i + offset)) )","counters":[{"col_start":12,"col_end":12,"count":4},{"col_start":33,"col_end":33,"count":4}]},{"line":"      in","counters":[]},{"line":"      sum /. Int.to_float (List.length indices)","counters":[{"col_start":6,"col_end":6,"count":3},{"col_start":24,"col_end":24,"count":3},{"col_start":37,"col_end":37,"count":3}]},{"line":"    in","counters":[]},{"line":"    let lifetimes =","counters":[]},{"line":"      match count with","counters":[]},{"line":"      | 0 ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Allocation_statistics.empty_quartiles","counters":[]},{"line":"      | 1 ->","counters":[{"col_start":8,"col_end":8,"count":3}]},{"line":"          Allocation_statistics.make_quartiles (get_lifetime_ms 0)","counters":[{"col_start":45,"col_end":45,"count":3},{"col_start":62,"col_end":62,"count":3}]},{"line":"      | _ ->","counters":[{"col_start":8,"col_end":8,"count":1}]},{"line":"          let q1 = mean 0 (count / 2) in","counters":[]},{"line":"          let q2 = mean 0 count in","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"          let q3_offset = if count mod 2 = 0 then 0 else 1 in","counters":[{"col_start":10,"col_end":10,"count":1},{"col_start":50,"col_end":50,"count":1},{"col_start":57,"col_end":57,"count":0}]},{"line":"          let q3 = mean ((count / 2) + q3_offset) (count / 2) in","counters":[]},{"line":"          let q4 = get_lifetime_ms 0 in","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"          Allocation_statistics.{ q1; q2; q3; q4 }","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"    in","counters":[]},{"line":"    Allocation_statistics.{ count; lifetimes }","counters":[]},{"line":"","counters":[]},{"line":"  let compute_statistics t =","counters":[]},{"line":"    try compute_statistics t","counters":[{"col_start":4,"col_end":4,"count":4},{"col_start":25,"col_end":25,"count":4}]},{"line":"    with _ ->","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"      Allocation_statistics.","counters":[]},{"line":"        { count = 0; lifetimes = Allocation_statistics.make_quartiles 0. }","counters":[{"col_start":68,"col_end":68,"count":0}]},{"line":"","counters":[]},{"line":"  let%test_module \"Allocation_data unit tests\" =","counters":[]},{"line":"    ( module struct","counters":[]},{"line":"      open Allocation_statistics","counters":[]},{"line":"","counters":[]},{"line":"      module Float_compare = Float.Robust_compare.Make (struct","counters":[]},{"line":"        let robust_comparison_tolerance = 0.04","counters":[]},{"line":"      end)","counters":[]},{"line":"","counters":[]},{"line":"      type robust_float = float [@@deriving sexp]","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"      let compare_robust_float = Float_compare.robustly_compare","counters":[]},{"line":"","counters":[]},{"line":"      (* time_offsets passed in here should be ordered monotonically (to match real world behavior) *)","counters":[]},{"line":"      let run_test time_offsets expected_quartiles =","counters":[]},{"line":"        let now = Time.now () in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        (* ids do not need to be unique in this test *)","counters":[]},{"line":"        let data =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          { allocation_times =","counters":[]},{"line":"              Queue.of_list","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"              @@ List.map (List.rev time_offsets) ~f:(fun offset ->","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"                     (0, Time.sub now (Time.Span.of_ms offset)) )","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"          ; next_allocation_id = 0","counters":[]},{"line":"          }","counters":[]},{"line":"        in","counters":[]},{"line":"        let stats = compute_statistics data in","counters":[]},{"line":"        [%test_eq: int] stats.count (List.length time_offsets) ;","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"        [%test_eq: robust_float] stats.lifetimes.q1 expected_quartiles.q1 ;","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"        [%test_eq: robust_float] stats.lifetimes.q2 expected_quartiles.q2 ;","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"        [%test_eq: robust_float] stats.lifetimes.q3 expected_quartiles.q3 ;","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"        [%test_eq: robust_float] stats.lifetimes.q4 expected_quartiles.q4","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"","counters":[]},{"line":"      let%test_unit \"quartiles of empty list\" =","counters":[]},{"line":"        run_test [] { q1 = 0.0; q2 = 0.0; q3 = 0.0; q4 = 0.0 }","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      let%test_unit \"quartiles of singleton list\" =","counters":[]},{"line":"        run_test [ 1.0 ] { q1 = 1.0; q2 = 1.0; q3 = 1.0; q4 = 1.0 }","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      let%test_unit \"quartiles of 2 element list\" =","counters":[]},{"line":"        run_test [ 1.0; 2.0 ] { q1 = 1.0; q2 = 1.5; q3 = 2.0; q4 = 2.0 }","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      let%test_unit \"quartiles of 3 element list\" =","counters":[]},{"line":"        run_test [ 1.0; 2.0; 3.0 ] { q1 = 1.0; q2 = 2.0; q3 = 3.0; q4 = 3.0 }","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      let%test_unit \"quartiles of even list (> 3)\" =","counters":[]},{"line":"        run_test","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          [ 1.0; 2.0; 3.0; 4.0; 5.0; 6.0 ]","counters":[]},{"line":"          { q1 = 2.0; q2 = 3.5; q3 = 5.0; q4 = 6.0 }","counters":[]},{"line":"","counters":[]},{"line":"      let%test_unit \"quartiles of odd list with even split (> 3)\" =","counters":[]},{"line":"        run_test","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          [ 1.0; 2.0; 3.0; 4.0; 5.0; 6.0; 7.0 ]","counters":[]},{"line":"          { q1 = 2.0; q2 = 4.0; q3 = 6.0; q4 = 7.0 }","counters":[]},{"line":"","counters":[]},{"line":"      let%test_unit \"quartiles of odd list with odd split (> 3)\" =","counters":[]},{"line":"        run_test","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          [ 1.0; 2.0; 3.0; 4.0; 5.0; 6.0; 7.0; 8.0; 9.0 ]","counters":[]},{"line":"          { q1 = 2.5; q2 = 5.0; q3 = 7.5; q4 = 9.0 }","counters":[]},{"line":"    end )","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(** correlation of allocation data and derived statistics *)","counters":[]},{"line":"module Allocation_info = struct","counters":[]},{"line":"  type t = { statistics : Allocation_statistics.t; data : Allocation_data.t }","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let table = String.Table.create ()","counters":[{"col_start":30,"col_end":30,"count":1}]},{"line":"","counters":[]},{"line":"let capture object_id =","counters":[]},{"line":"  let open Allocation_info in","counters":[{"col_start":2,"col_end":2,"count":3}]},{"line":"  let info_opt = String.Table.find table object_id in","counters":[]},{"line":"  let data_opt = Option.map info_opt ~f:(fun { data; _ } -> data) in","counters":[{"col_start":2,"col_end":2,"count":3},{"col_start":60,"col_end":60,"count":1}]},{"line":"  let data =","counters":[{"col_start":2,"col_end":2,"count":3}]},{"line":"    Lazy.(","counters":[]},{"line":"      force","counters":[{"col_start":10,"col_end":10,"count":3}]},{"line":"      @@ Option.value_map data_opt","counters":[{"col_start":24,"col_end":24,"count":3}]},{"line":"           ~default:(lazy (Allocation_data.create ()))","counters":[{"col_start":26,"col_end":26,"count":2}]},{"line":"           ~f:Lazy.return)","counters":[]},{"line":"  in","counters":[]},{"line":"  let allocation_id = Allocation_data.register_allocation data in","counters":[]},{"line":"  let statistics = Allocation_data.compute_statistics data in","counters":[{"col_start":2,"col_end":2,"count":3}]},{"line":"  String.Table.set table ~key:object_id ~data:{ data; statistics } ;","counters":[{"col_start":2,"col_end":2,"count":3}]},{"line":"  Allocation_statistics.write_metrics statistics object_id ;","counters":[{"col_start":2,"col_end":2,"count":3}]},{"line":"  Mina_metrics.(","counters":[{"col_start":2,"col_end":2,"count":3}]},{"line":"    Counter.inc_one (Object_lifetime_statistics.allocated_count ~name:object_id)) ;","counters":[{"col_start":18,"col_end":18,"count":3}]},{"line":"  allocation_id","counters":[]},{"line":"","counters":[]},{"line":"(* release is currently O(n), where n = number of active allocations for this object type; this can be improved by implementing indexed queues (with decent random delete computational complexity) in ocaml *)","counters":[]},{"line":"let release ~object_id ~allocation_id =","counters":[]},{"line":"  let open Allocation_info in","counters":[{"col_start":2,"col_end":2,"count":1}]},{"line":"  let info = String.Table.find_exn table object_id in","counters":[]},{"line":"  Allocation_data.unregister_allocation info.data allocation_id ;","counters":[{"col_start":2,"col_end":2,"count":1}]},{"line":"  let statistics = Allocation_data.compute_statistics info.data in","counters":[{"col_start":2,"col_end":2,"count":1}]},{"line":"  String.Table.set table ~key:object_id ~data:{ info with statistics } ;","counters":[{"col_start":2,"col_end":2,"count":1}]},{"line":"  Allocation_statistics.write_metrics statistics object_id ;","counters":[{"col_start":2,"col_end":2,"count":1}]},{"line":"  Mina_metrics.(","counters":[{"col_start":2,"col_end":2,"count":1}]},{"line":"    Counter.inc_one (Object_lifetime_statistics.collected_count ~name:object_id))","counters":[]},{"line":"","counters":[]},{"line":"let attach_finalizer object_id obj =","counters":[]},{"line":"  let allocation_id = capture object_id in","counters":[{"col_start":2,"col_end":2,"count":3}]},{"line":"  Gc.Expert.add_finalizer_exn obj (fun _ -> release ~object_id ~allocation_id) ;","counters":[{"col_start":2,"col_end":2,"count":3},{"col_start":44,"col_end":44,"count":1}]},{"line":"  obj","counters":[{"col_start":2,"col_end":2,"count":3}]},{"line":"","counters":[]},{"line":"let dump () =","counters":[]},{"line":"  let open Allocation_info in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let entries =","counters":[]},{"line":"    String.Table.to_alist table","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"    |> List.Assoc.map ~f:(fun { statistics; _ } ->","counters":[]},{"line":"           Allocation_statistics.to_yojson statistics )","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"  in","counters":[]},{"line":"  `Assoc entries","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":15,"col_end":15,"count":2}]}]}