{"filename":"src/lib/unsigned_extended/unsigned_extended.ml","lines":[{"line":"(* unsigned_extended.ml *)","counters":[]},{"line":"","counters":[{"col_start":0,"col_end":0,"count":1}]},{"line":"open Core_kernel","counters":[]},{"line":"include Intf","counters":[]},{"line":"open Snark_params","counters":[]},{"line":"open Tick","counters":[]},{"line":"","counters":[]},{"line":"module type Unsigned_intf = Unsigned.S","counters":[]},{"line":"","counters":[]},{"line":"module Extend","counters":[]},{"line":"    (Unsigned : Unsigned.S) (M : sig","counters":[]},{"line":"      val length : int","counters":[]},{"line":"    end) : S with type t = Unsigned.t = struct","counters":[]},{"line":"  assert (M.length < Field.size_in_bits - 3)","counters":[{"col_start":9,"col_end":9,"count":2}]},{"line":"","counters":[]},{"line":"  let length_in_bits = M.length","counters":[]},{"line":"","counters":[]},{"line":"  module T = struct","counters":[]},{"line":"    include Sexpable.Of_stringable (Unsigned)","counters":[]},{"line":"","counters":[]},{"line":"    type t = Unsigned.t","counters":[]},{"line":"","counters":[]},{"line":"    let compare = Unsigned.compare","counters":[]},{"line":"","counters":[]},{"line":"    let hash_fold_t s t = Int64.hash_fold_t s (Unsigned.to_int64 t)","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"","counters":[]},{"line":"    let hash t = Int64.hash (Unsigned.to_int64 t)","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"","counters":[]},{"line":"    let to_bigint t =","counters":[]},{"line":"      let i64 = Unsigned.to_int64 t in","counters":[{"col_start":6,"col_end":6,"count":2}]},{"line":"      if Int64.(i64 >= 0L) then Bignum_bigint.of_int64 i64","counters":[{"col_start":6,"col_end":6,"count":2},{"col_start":32,"col_end":32,"count":2}]},{"line":"      else","counters":[]},{"line":"        Bignum_bigint.(","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          of_int64 i64 - of_int64 Int64.min_value + of_int64 Int64.max_value","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"          + one)","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  include T","counters":[]},{"line":"  include Hashable.Make (T)","counters":[]},{"line":"","counters":[]},{"line":"  include (Unsigned : Unsigned_intf with type t := t)","counters":[]},{"line":"","counters":[]},{"line":"  (* serializes to and from json as strings since bit lengths > 32 cannot be represented in json *)","counters":[]},{"line":"  let to_yojson n = `String (to_string n)","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"  let of_yojson = function","counters":[]},{"line":"    | `String s ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Ok (of_string s)","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"    | _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Error \"expected string\"","counters":[]},{"line":"","counters":[]},{"line":"  let ( < ) x y = compare x y < 0","counters":[{"col_start":18,"col_end":18,"count":10},{"col_start":24,"col_end":24,"count":10}]},{"line":"","counters":[]},{"line":"  let ( > ) x y = compare x y > 0","counters":[{"col_start":18,"col_end":18,"count":8},{"col_start":24,"col_end":24,"count":8}]},{"line":"","counters":[]},{"line":"  let ( = ) x y = compare x y = 0","counters":[{"col_start":18,"col_end":18,"count":2886},{"col_start":24,"col_end":24,"count":2886}]},{"line":"","counters":[]},{"line":"  let ( <= ) x y = compare x y <= 0","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"  let ( >= ) x y = compare x y >= 0","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module UInt64 = struct","counters":[]},{"line":"  module M =","counters":[]},{"line":"    Extend","counters":[]},{"line":"      (Unsigned.UInt64)","counters":[]},{"line":"      (struct","counters":[]},{"line":"        let length = 64","counters":[]},{"line":"      end)","counters":[]},{"line":"","counters":[]},{"line":"  (* this module allows use to generate With_all_version_tags from the","counters":[]},{"line":"     Binable.Of_binable functor below, needed to decode transaction ids","counters":[]},{"line":"     for V1 signed commands; it does not add any tags","counters":[]},{"line":"  *)","counters":[]},{"line":"  module Int64_for_version_tags = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      [@@@no_toplevel_latest_type]","counters":[]},{"line":"","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type t = (Int64.t[@version_asserted])","counters":[{"col_start":8,"col_end":8,"count":2},{"col_start":13,"col_end":13,"count":1},{"col_start":44,"col_end":44,"count":5}]},{"line":"","counters":[]},{"line":"        let to_latest = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"        module With_all_version_tags = struct","counters":[]},{"line":"          type typ = t [@@deriving bin_io_unversioned]","counters":[{"col_start":10,"col_end":10,"count":1},{"col_start":17,"col_end":17,"count":1},{"col_start":53,"col_end":53,"count":4}]},{"line":"","counters":[]},{"line":"          type t = typ [@@deriving bin_io_unversioned]","counters":[{"col_start":10,"col_end":10,"count":1},{"col_start":15,"col_end":15,"count":1},{"col_start":53,"col_end":53,"count":4}]},{"line":"        end","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  [%%versioned_binable","counters":[]},{"line":"  module Stable = struct","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"    [@@@no_toplevel_latest_type]","counters":[]},{"line":"","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      [@@@with_all_version_tags]","counters":[]},{"line":"","counters":[]},{"line":"      type t = Unsigned.UInt64.t","counters":[{"col_start":6,"col_end":6,"count":2},{"col_start":31,"col_end":31,"count":7}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"      (* these are defined in the Extend functor, rather than derived, so import them *)","counters":[]},{"line":"      [%%define_locally","counters":[]},{"line":"      M.","counters":[]},{"line":"        ( equal","counters":[]},{"line":"        , compare","counters":[]},{"line":"        , hash","counters":[]},{"line":"        , hash_fold_t","counters":[]},{"line":"        , sexp_of_t","counters":[]},{"line":"        , t_of_sexp","counters":[]},{"line":"        , to_yojson","counters":[]},{"line":"        , of_yojson )]","counters":[]},{"line":"","counters":[]},{"line":"      module M = struct","counters":[]},{"line":"        type t = Unsigned.UInt64.t","counters":[]},{"line":"","counters":[]},{"line":"        let to_binable = Unsigned.UInt64.to_int64","counters":[]},{"line":"","counters":[]},{"line":"        let of_binable = Unsigned.UInt64.of_int64","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      include Binable.Of_binable (Int64_for_version_tags.Stable.V1) (M)","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  include M","counters":[]},{"line":"","counters":[]},{"line":"  let dhall_type = Ppx_dhall_type.Dhall_type.Text","counters":[]},{"line":"","counters":[]},{"line":"  let to_uint64 : t -> uint64 = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"  let of_uint64 : uint64 -> t = Fn.id","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module UInt32 = struct","counters":[]},{"line":"  module M =","counters":[]},{"line":"    Extend","counters":[]},{"line":"      (Unsigned.UInt32)","counters":[]},{"line":"      (struct","counters":[]},{"line":"        let length = 32","counters":[]},{"line":"      end)","counters":[]},{"line":"","counters":[]},{"line":"  (* this module allows use to generate With_all_version_tags from the","counters":[]},{"line":"     Binable.Of_binable functor below, needed to decode transaction ids","counters":[]},{"line":"     for V1 signed commands; it does not add any tags","counters":[]},{"line":"  *)","counters":[]},{"line":"  module Int32_for_version_tags = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      [@@@no_toplevel_latest_type]","counters":[]},{"line":"","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type t = (Int32.t[@version_asserted])","counters":[{"col_start":8,"col_end":8,"count":2},{"col_start":13,"col_end":13,"count":1},{"col_start":44,"col_end":44,"count":5}]},{"line":"","counters":[]},{"line":"        let to_latest = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"        module With_all_version_tags = struct","counters":[]},{"line":"          type typ = t [@@deriving bin_io_unversioned]","counters":[{"col_start":10,"col_end":10,"count":1},{"col_start":17,"col_end":17,"count":1},{"col_start":53,"col_end":53,"count":4}]},{"line":"","counters":[]},{"line":"          type t = typ [@@deriving bin_io_unversioned]","counters":[{"col_start":10,"col_end":10,"count":1},{"col_start":15,"col_end":15,"count":1},{"col_start":53,"col_end":53,"count":4}]},{"line":"        end","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  [%%versioned_binable","counters":[]},{"line":"  module Stable = struct","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"    [@@@no_toplevel_latest_type]","counters":[]},{"line":"","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      [@@@with_all_version_tags]","counters":[]},{"line":"","counters":[]},{"line":"      type t = Unsigned.UInt32.t","counters":[{"col_start":6,"col_end":6,"count":2},{"col_start":31,"col_end":31,"count":7}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"      (* these are defined in the Extend functor, rather than derived, so import them *)","counters":[]},{"line":"      [%%define_locally","counters":[]},{"line":"      M.","counters":[]},{"line":"        ( equal","counters":[]},{"line":"        , compare","counters":[]},{"line":"        , hash","counters":[]},{"line":"        , hash_fold_t","counters":[]},{"line":"        , sexp_of_t","counters":[]},{"line":"        , t_of_sexp","counters":[]},{"line":"        , to_yojson","counters":[]},{"line":"        , of_yojson )]","counters":[]},{"line":"","counters":[]},{"line":"      module M = struct","counters":[]},{"line":"        type t = Unsigned.UInt32.t","counters":[]},{"line":"","counters":[]},{"line":"        let to_binable = Unsigned.UInt32.to_int32","counters":[]},{"line":"","counters":[]},{"line":"        let of_binable = Unsigned.UInt32.of_int32","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      include Binable.Of_binable (Int32_for_version_tags.Stable.V1) (M)","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  include M","counters":[]},{"line":"","counters":[]},{"line":"  let to_uint32 : t -> uint32 = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"  let of_uint32 : uint32 -> t = Fn.id","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":1}]}]}