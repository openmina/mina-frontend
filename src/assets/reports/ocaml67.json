{"filename":"src/lib/pipe_lib/broadcast_pipe.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Async_kernel","counters":[]},{"line":"","counters":[]},{"line":"type 'a t =","counters":[]},{"line":"  { root_pipe : 'a Pipe.Writer.t","counters":[]},{"line":"  ; mutable cache : 'a","counters":[]},{"line":"  ; mutable reader_id : int","counters":[]},{"line":"  ; pipes : 'a Pipe.Writer.t Int.Table.t","counters":[]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"let create a =","counters":[]},{"line":"  let root_r, root_w = Pipe.create () in","counters":[{"col_start":2,"col_end":2,"count":1}]},{"line":"  let t =","counters":[{"col_start":2,"col_end":2,"count":1}]},{"line":"    { root_pipe = root_w","counters":[]},{"line":"    ; cache = a","counters":[]},{"line":"    ; reader_id = 0","counters":[]},{"line":"    ; pipes = Int.Table.create ()","counters":[{"col_start":29,"col_end":29,"count":1}]},{"line":"    }","counters":[]},{"line":"  in","counters":[]},{"line":"  let downstream_flushed_v : unit Ivar.t ref = ref @@ Ivar.create () in","counters":[{"col_start":49,"col_end":49,"count":1},{"col_start":64,"col_end":64,"count":1}]},{"line":"  let consumer =","counters":[]},{"line":"    Pipe.add_consumer root_r ~downstream_flushed:(fun () ->","counters":[]},{"line":"        let%map () = Ivar.read !downstream_flushed_v in","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"        (* Sub-pipes are never closed without closing the master pipe. *)","counters":[]},{"line":"        `Ok )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"  in","counters":[]},{"line":"  don't_wait_for","counters":[{"col_start":2,"col_end":2,"count":1}]},{"line":"    (Pipe.iter ~flushed:(Consumer consumer) root_r ~f:(fun v ->","counters":[{"col_start":13,"col_end":13,"count":1}]},{"line":"         downstream_flushed_v := Ivar.create () ;","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"         let inner_pipes = Int.Table.data t.pipes in","counters":[]},{"line":"         let%bind () =","counters":[]},{"line":"           Deferred.List.iter ~how:`Parallel inner_pipes ~f:(fun p ->","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"               Pipe.write p v )","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"         in","counters":[]},{"line":"         Pipe.Consumer.values_sent_downstream consumer ;","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"         let%bind () =","counters":[]},{"line":"           Deferred.List.iter ~how:`Parallel inner_pipes ~f:(fun p ->","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"               Deferred.ignore_m @@ Pipe.downstream_flushed p )","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"         in","counters":[]},{"line":"         if Ivar.is_full !downstream_flushed_v then","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"           [%log' error (Logger.create ())] \"Ivar.fill bug is here 555!\" ;","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"         Ivar.fill !downstream_flushed_v () ;","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"         Deferred.unit ) ) ;","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"  (t, t)","counters":[{"col_start":2,"col_end":2,"count":1}]},{"line":"","counters":[]},{"line":"exception Already_closed of string","counters":[]},{"line":"","counters":[]},{"line":"let if_closed t ~then_ ~else_ =","counters":[]},{"line":"  if Pipe.is_closed t.root_pipe then then_ () else else_ ()","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"","counters":[]},{"line":"let guard_already_closed ~context t f =","counters":[]},{"line":"  if_closed t ~then_:(fun () -> raise (Already_closed context)) ~else_:f","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"","counters":[]},{"line":"module Reader = struct","counters":[]},{"line":"  type nonrec 'a t = 'a t","counters":[]},{"line":"","counters":[]},{"line":"  let peek t = guard_already_closed ~context:\"Reader.peek\" t (fun () -> t.cache)","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":72,"col_end":72,"count":0}]},{"line":"","counters":[]},{"line":"  let fresh_reader_id t =","counters":[]},{"line":"    t.reader_id <- t.reader_id + 1 ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    t.reader_id","counters":[]},{"line":"","counters":[]},{"line":"  let prepare_pipe t ~default_value ~f =","counters":[]},{"line":"    if_closed t","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ~then_:(Fn.const (Deferred.return default_value))","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"      ~else_:(fun () ->","counters":[]},{"line":"        let r, w = Pipe.create () in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Pipe.write_without_pushback w (peek t) ;","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"        let reader_id = fresh_reader_id t in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Int.Table.add_exn t.pipes ~key:reader_id ~data:w ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let d =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let%map b = f r in","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"          Int.Table.remove t.pipes reader_id ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          b","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        in","counters":[]},{"line":"        d )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"  (* The sub-pipes have no downstream consumer, so the downstream flushed should","counters":[]},{"line":"     always be determined and return `Ok. *)","counters":[]},{"line":"  let add_trivial_consumer p =","counters":[]},{"line":"    Pipe.add_consumer p ~downstream_flushed:(fun () -> Deferred.return `Ok)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"","counters":[]},{"line":"  let fold t ~init ~f =","counters":[]},{"line":"    prepare_pipe t ~default_value:init ~f:(fun r ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        let consumer = add_trivial_consumer r in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Pipe.fold r ~init ~f:(fun acc v ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            let%map res = f acc v in","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"            Pipe.Consumer.values_sent_downstream consumer ;","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            res ) )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"","counters":[]},{"line":"  let iter t ~f =","counters":[]},{"line":"    prepare_pipe t ~default_value:() ~f:(fun r ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        let consumer = add_trivial_consumer r in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Pipe.iter ~flushed:(Consumer consumer) r ~f:(fun v ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            let%map () = f v in","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"            Pipe.Consumer.values_sent_downstream consumer ) )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"","counters":[]},{"line":"  let iter_until t ~f =","counters":[]},{"line":"    let rec loop ~consumer reader =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      match%bind Pipe.read ~consumer reader with","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"      | `Eof ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          return ()","counters":[]},{"line":"      | `Ok v ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let%bind b = f v in","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"          Pipe.Consumer.values_sent_downstream consumer ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          if b then return () else loop ~consumer reader","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"    in","counters":[]},{"line":"    prepare_pipe t ~default_value:() ~f:(fun reader ->","counters":[]},{"line":"        let consumer = add_trivial_consumer reader in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        loop ~consumer reader )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Writer = struct","counters":[]},{"line":"  type nonrec 'a t = 'a t","counters":[]},{"line":"","counters":[]},{"line":"  let write t x =","counters":[]},{"line":"    guard_already_closed ~context:\"Writer.write\" t (fun () ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        t.cache <- x ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let%bind () = Pipe.write t.root_pipe x in","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"        let%bind _ = Pipe.downstream_flushed t.root_pipe in","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"        Deferred.unit )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"  let close t =","counters":[]},{"line":"    guard_already_closed ~context:\"Writer.close\" t (fun () ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        Pipe.close t.root_pipe ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Int.Table.iter t.pipes ~f:(fun w -> Pipe.close w) ;","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"        Int.Table.clear t.pipes )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let map t ~f =","counters":[]},{"line":"  let r, w = create (f (Reader.peek t)) in","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"  don't_wait_for (Reader.iter t ~f:(fun x -> Writer.write w (f x))) ;","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"  r","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"(*","counters":[]},{"line":" * 1. Cached value is keeping peek working","counters":[]},{"line":" * 2. Multiple listeners receive the first mvar value","counters":[]},{"line":" * 3. Multiple listeners receive updates after changes","counters":[]},{"line":" * 4. Peek sees the latest value","counters":[]},{"line":" * 5. If we close the broadcast pipe, all listeners stop","counters":[]},{"line":" *)","counters":[]},{"line":"let%test_unit \"listeners properly receive updates\" =","counters":[]},{"line":"  let expect_pipe t expected =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    let got_rev =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Reader.fold t ~init:[] ~f:(fun acc a1 -> return @@ (a1 :: acc))","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"    in","counters":[]},{"line":"    let%map got = got_rev >>| List.rev in","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"    [%test_result: int list]","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"      ~message:\"Expected the following values from the pipe\" ~expect:expected","counters":[]},{"line":"      got","counters":[]},{"line":"  in","counters":[]},{"line":"  Run_in_thread.block_on_async_exn (fun () ->","counters":[]},{"line":"      let initial = 0 in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let r, w = create initial in","counters":[]},{"line":"      (*1*)","counters":[]},{"line":"      [%test_result: int] ~message:\"Initial value not observed when peeking\"","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"        ~expect:initial (Reader.peek r) ;","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"      (* 2-3 *)","counters":[]},{"line":"      let d1 = expect_pipe r [ 0; 1; 2 ] in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let d2 = expect_pipe r [ 0; 1; 2 ] in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      don't_wait_for d1 ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      don't_wait_for d2 ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let next_value = 1 in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      (*3*)","counters":[]},{"line":"      let%bind () = Writer.write w next_value in","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"      (*4*)","counters":[]},{"line":"      let next_value = 2 in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%bind () = Writer.write w next_value in","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"      (*5*)","counters":[]},{"line":"      [%test_result: int] ~message:\"Latest value is observed when peeking\"","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"        ~expect:next_value (Reader.peek r) ;","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"      (*6*)","counters":[]},{"line":"      Writer.close w ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Deferred.both d1 d2 >>| Fn.ignore )","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"","counters":[]},{"line":"let%test_module _ =","counters":[]},{"line":"  ( module struct","counters":[]},{"line":"    type iter_counts =","counters":[]},{"line":"      { mutable immediate_iterations : int; mutable deferred_iterations : int }","counters":[]},{"line":"","counters":[]},{"line":"    let zero_counts () = { immediate_iterations = 0; deferred_iterations = 0 }","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"    let assert_immediate counts expected =","counters":[]},{"line":"      [%test_eq: int] counts.immediate_iterations expected","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"","counters":[]},{"line":"    let assert_deferred counts expected =","counters":[]},{"line":"      [%test_eq: int] counts.deferred_iterations expected","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"","counters":[]},{"line":"    let assert_both counts expected =","counters":[]},{"line":"      assert_immediate counts expected ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      assert_deferred counts expected","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let%test \"Writing is synchronous\" =","counters":[]},{"line":"      Run_in_thread.block_on_async_exn (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          Core_kernel.Backtrace.elide := false ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let pipe_r, pipe_w = create () in","counters":[]},{"line":"          let counts1, counts2 = (zero_counts (), zero_counts ()) in","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"          let setup_reader counts =","counters":[]},{"line":"            don't_wait_for","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            @@ Reader.iter pipe_r ~f:(fun () ->","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                   counts.immediate_iterations <-","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"                     counts.immediate_iterations + 1 ;","counters":[]},{"line":"                   let%map () = after @@ Time_ns.Span.of_sec 1. in","counters":[{"col_start":36,"col_end":36,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"                   counts.deferred_iterations <- counts.deferred_iterations + 1 )","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"          in","counters":[]},{"line":"          setup_reader counts1 ;","counters":[]},{"line":"          (* The reader doesn't run until we yield. *)","counters":[]},{"line":"          assert_both counts1 0 ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          (* Once we yield, the reader has run, but has returned to the","counters":[]},{"line":"             scheduler before setting deferred_iterations. *)","counters":[]},{"line":"          let%bind () = after @@ Time_ns.Span.of_sec 0.1 in","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"          assert_immediate counts1 1 ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          assert_deferred counts1 0 ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          (* After we yield for long enough, deferred_iterations has been","counters":[]},{"line":"             set. *)","counters":[]},{"line":"          let%bind () = after @@ Time_ns.Span.of_sec 1.1 in","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"          assert_both counts1 1 ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          (* Writing to the pipe blocks until the reader is finished. *)","counters":[]},{"line":"          let%bind () = Writer.write pipe_w () in","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"          assert_both counts1 2 ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          (* A second reader gets the current value, and all values written","counters":[]},{"line":"             after its creation. *)","counters":[]},{"line":"          setup_reader counts2 ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          assert_both counts2 0 ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let%bind () = after @@ Time_ns.Span.of_sec 0.1 in","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"          assert_immediate counts2 1 ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          assert_deferred counts2 0 ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let%bind () = Writer.write pipe_w () in","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"          assert_both counts1 3 ; assert_both counts2 2 ; Deferred.return true )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"  end )","counters":[{"col_start":6,"col_end":6,"count":2}]}]}