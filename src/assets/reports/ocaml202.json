{"filename":"src/lib/consensus/body_reference.ml","lines":[{"line":"(* This module defines how a block header refers to the body of its block.","counters":[]},{"line":"    At the moment, this is merely a hash of the body. But in an upcoming","counters":[]},{"line":"    hard fork, we will be updating this to reference to point to the root","counters":[]},{"line":"    \"Bitswap block\" CID along with a signature attesting to ownership over","counters":[]},{"line":"    this association (for punishment and manipuluation prevention). This will","counters":[]},{"line":"    allow us to upgrade block gossip to happen over Bitswap in a future","counters":[]},{"line":"    soft fork release. *)","counters":[]},{"line":"","counters":[{"col_start":0,"col_end":0,"count":1}]},{"line":"open Core_kernel","counters":[]},{"line":"open Snark_params.Tick","counters":[]},{"line":"open Fold_lib","counters":[]},{"line":"open Mina_base_util","counters":[]},{"line":"","counters":[]},{"line":"[%%versioned","counters":[]},{"line":"module Stable = struct","counters":[]},{"line":"  module V1 = struct","counters":[]},{"line":"    type t = Blake2.Stable.V1.t [@@deriving sexp, yojson, hash, equal, compare]","counters":[{"col_start":4,"col_end":4,"count":2},{"col_start":9,"col_end":9,"count":1},{"col_start":13,"col_end":13,"count":0},{"col_start":78,"col_end":78,"count":5}]},{"line":"","counters":[]},{"line":"    let to_latest = Fn.id","counters":[]},{"line":"  end","counters":[]},{"line":"end]","counters":[]},{"line":"","counters":[]},{"line":"type t = Stable.Latest.t","counters":[]},{"line":"","counters":[]},{"line":"[%%define_locally Stable.Latest.(t_of_sexp, sexp_of_t, to_yojson, of_yojson)]","counters":[]},{"line":"","counters":[]},{"line":"type var = Boolean.var list","counters":[]},{"line":"","counters":[]},{"line":"let fold t = Fold.string_bits (Blake2.to_raw_string t)","counters":[{"col_start":13,"col_end":13,"count":5},{"col_start":50,"col_end":50,"count":5}]},{"line":"","counters":[]},{"line":"let var_of_t t : var = List.map (Fold.to_list @@ fold t) ~f:Boolean.var_of_value","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"","counters":[]},{"line":"let to_input t =","counters":[]},{"line":"  let open Random_oracle.Input.Chunked in","counters":[{"col_start":2,"col_end":2,"count":5}]},{"line":"  Array.reduce_exn ~f:append","counters":[]},{"line":"    (Array.of_list_map","counters":[{"col_start":21,"col_end":21,"count":5}]},{"line":"       (Fold.to_list (fold t))","counters":[{"col_start":19,"col_end":19,"count":5},{"col_start":25,"col_end":25,"count":5}]},{"line":"       ~f:(fun b -> packed (field_of_bool b, 1)) )","counters":[{"col_start":20,"col_end":20,"count":1280},{"col_start":40,"col_end":40,"count":1280}]},{"line":"","counters":[]},{"line":"let var_to_input (t : var) =","counters":[]},{"line":"  let open Random_oracle.Input.Chunked in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  Array.reduce_exn ~f:append","counters":[]},{"line":"    (Array.of_list_map t ~f:(fun b -> packed ((b :> Field.Var.t), 1)))","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"","counters":[]},{"line":"let typ : (var, t) Typ.t =","counters":[]},{"line":"  Typ.transport","counters":[{"col_start":14,"col_end":14,"count":1}]},{"line":"    (Typ.list ~length:256 Boolean.typ)","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"    ~there:(Fn.compose Fold.to_list fold)","counters":[{"col_start":21,"col_end":21,"count":1}]},{"line":"    ~back:","counters":[]},{"line":"      (Fn.compose Blake2.of_raw_string","counters":[{"col_start":16,"col_end":16,"count":1}]},{"line":"         (Fn.compose Fold.bool_t_to_string Fold.of_list) )","counters":[{"col_start":19,"col_end":19,"count":1}]},{"line":"","counters":[]},{"line":"let to_hex = Blake2.to_hex","counters":[]},{"line":"","counters":[]},{"line":"let of_hex_exn = Blake2.of_hex","counters":[]},{"line":"","counters":[]},{"line":"let to_raw_string = Blake2.to_raw_string","counters":[{"col_start":39,"col_end":39,"count":1}]}]}