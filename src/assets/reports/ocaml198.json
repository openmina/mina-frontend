{"filename":"src/lib/test_util/test_util.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Fold_lib","counters":[]},{"line":"","counters":[]},{"line":"module Make (Impl : Snarky_backendless.Snark_intf.S) = struct","counters":[]},{"line":"  let triple_string trips =","counters":[]},{"line":"    let to_string b = if b then \"1\" else \"0\" in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"    String.concat ~sep:\" \"","counters":[]},{"line":"      (List.map trips ~f:(fun (b1, b2, b3) ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"           to_string b1 ^ to_string b2 ^ to_string b3 ) )","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"","counters":[]},{"line":"  let checked_to_unchecked typ1 typ2 checked input =","counters":[]},{"line":"    let open Impl in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let checked_result =","counters":[]},{"line":"      run_and_check","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"        (let%bind input = exists typ1 ~compute:(As_prover.return input) in","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"         let%map result = checked input in","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"         As_prover.read typ2 result )","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"      |> Or_error.ok_exn","counters":[]},{"line":"    in","counters":[]},{"line":"    checked_result","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let test_to_triples typ fold var_to_triples input =","counters":[]},{"line":"    let open Impl in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let checked =","counters":[]},{"line":"      run_and_check","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"        (let%bind input = exists typ ~compute:(As_prover.return input) in","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"         let%map result = var_to_triples input in","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"         As_prover.all","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"           (List.map result","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"              ~f:","counters":[]},{"line":"                (As_prover.read","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                   (Typ.tuple3 Boolean.typ Boolean.typ Boolean.typ) ) ) )","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"      |> Or_error.ok_exn","counters":[]},{"line":"    in","counters":[]},{"line":"    let unchecked = Fold.to_list (fold input) in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"    if not ([%equal: (bool * bool * bool) list] checked unchecked) then","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"      failwithf","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        !\"Got %s (%d)\\nexpected %s (%d)\"","counters":[]},{"line":"        (triple_string checked) (List.length checked) (triple_string unchecked)","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":43,"col_end":43,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"        (List.length unchecked) ()","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"","counters":[]},{"line":"  let test_equal ?(equal = Poly.( = )) typ1 typ2 checked unchecked input =","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"    let checked_result = checked_to_unchecked typ1 typ2 checked input in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    assert (equal checked_result (unchecked input))","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":11,"col_end":11,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"","counters":[]},{"line":"  let arbitrary_string ~len =","counters":[]},{"line":"    String.init (Random.int len) ~f:(fun _ ->","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"        Char.of_int_exn (Random.int_incl 0 255) )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"  let with_randomness r f =","counters":[]},{"line":"    let s = Caml.Random.get_state () in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Random.init r ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    try","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let x = f () in","counters":[]},{"line":"      Caml.Random.set_state s ; x","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"    with e -> Caml.Random.set_state s ; raise e","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"  (** utility function to print digests to put in tests, see `check_serialization' below *)","counters":[]},{"line":"  let print_digest digest = printf \"\\\"\" ; printf \"%s\" digest ; printf \"\\\"\\n%!\"","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":42,"col_end":42,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"","counters":[]},{"line":"  (** use this function to test Bin_prot serialization of types *)","counters":[]},{"line":"  let check_serialization (type t) (module M : Binable.S with type t = t)","counters":[]},{"line":"      (t : t) known_good_digest =","counters":[]},{"line":"    (* serialize value *)","counters":[]},{"line":"    let sz = M.bin_size_t t in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let buf = Bin_prot.Common.create_buf sz in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    ignore (M.bin_write_t buf ~pos:0 t : int) ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"    let bytes = Bytes.create sz in","counters":[]},{"line":"    Bin_prot.Common.blit_buf_bytes buf bytes ~len:sz ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    (* compute MD5 digest of serialization *)","counters":[]},{"line":"    let digest = Md5.digest_bytes bytes |> Md5.to_hex in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"    let result = String.equal digest known_good_digest in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    if not result then (","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"      printf \"Expected digest: \" ;","counters":[]},{"line":"      print_digest known_good_digest ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      printf \"Got digest:      \" ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      print_digest digest ) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"    result","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"include Make (Snark_params.Tick)","counters":[{"col_start":31,"col_end":31,"count":2}]}]}