{"filename":"src/lib/merkle_address/merkle_address.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Bitstring","counters":[]},{"line":"","counters":[]},{"line":"let depth = bitstring_length","counters":[]},{"line":"","counters":[]},{"line":"let add_padding path =","counters":[]},{"line":"  let length = depth path in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  if length mod 8 = 0 then path","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"  else concat [ path; zeroes_bitstring (8 - (length mod 8)) ]","counters":[{"col_start":7,"col_end":7,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"let slice = subbitstring","counters":[]},{"line":"","counters":[]},{"line":"let to_string path : string =","counters":[]},{"line":"  let len = depth path in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let bytes = Bytes.create len in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  for i = 0 to len - 1 do","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    let ch = if is_clear path i then '0' else '1' in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"    Bytes.set bytes i ch","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"  done ;","counters":[]},{"line":"  Bytes.to_string bytes","counters":[]},{"line":"","counters":[]},{"line":"let of_directions dirs =","counters":[]},{"line":"  let path = create_bitstring (List.length dirs) in","counters":[{"col_start":2,"col_end":2,"count":254},{"col_start":41,"col_end":41,"count":254}]},{"line":"  let rec loop i = function","counters":[{"col_start":2,"col_end":2,"count":254}]},{"line":"    | [] ->","counters":[{"col_start":6,"col_end":6,"count":254}]},{"line":"        ()","counters":[]},{"line":"    | h :: t ->","counters":[{"col_start":6,"col_end":6,"count":3040}]},{"line":"        if Direction.to_bool h then set path i ;","counters":[{"col_start":36,"col_end":36,"count":485},{"col_start":38,"col_end":38,"count":485}]},{"line":"        loop (i + 1) t","counters":[{"col_start":8,"col_end":8,"count":3040}]},{"line":"  in","counters":[]},{"line":"  loop 0 dirs ; path","counters":[{"col_start":16,"col_end":16,"count":254}]},{"line":"","counters":[]},{"line":"let of_string buf =","counters":[]},{"line":"  String.to_list buf","counters":[{"col_start":2,"col_end":2,"count":254},{"col_start":15,"col_end":15,"count":254}]},{"line":"  |> List.map ~f:(fun c -> Char.to_int c - 48)","counters":[{"col_start":12,"col_end":12,"count":254},{"col_start":27,"col_end":27,"count":3040},{"col_start":37,"col_end":37,"count":3040}]},{"line":"  |> List.map ~f:Direction.of_int_exn","counters":[{"col_start":12,"col_end":12,"count":254}]},{"line":"  |> of_directions","counters":[]},{"line":"","counters":[]},{"line":"let to_yojson t = `String (to_string t)","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"let to_tuple path =","counters":[]},{"line":"  let length = depth path in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let padded_bitstring = add_padding path in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  (length, string_of_bitstring padded_bitstring)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"let of_tuple (length, string) = slice (bitstring_of_string string) 0 length","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"","counters":[]},{"line":"module Binable_arg = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    [@@@no_toplevel_latest_type]","counters":[]},{"line":"","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type t = int * string","counters":[{"col_start":6,"col_end":6,"count":2},{"col_start":11,"col_end":11,"count":1},{"col_start":26,"col_end":26,"count":5}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"[%%versioned_binable","counters":[]},{"line":"module Stable = struct","counters":[]},{"line":"  module V1 = struct","counters":[]},{"line":"    type t = Bitstring.t","counters":[{"col_start":4,"col_end":4,"count":1},{"col_start":23,"col_end":23,"count":1}]},{"line":"","counters":[]},{"line":"    let to_latest = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"    include","counters":[]},{"line":"      Binable.Of_binable_without_uuid","counters":[]},{"line":"        (Binable_arg.Stable.V1)","counters":[]},{"line":"        (struct","counters":[]},{"line":"          type nonrec t = t","counters":[]},{"line":"","counters":[]},{"line":"          let to_binable = to_tuple","counters":[]},{"line":"","counters":[]},{"line":"          let of_binable = of_tuple","counters":[]},{"line":"        end)","counters":[]},{"line":"","counters":[]},{"line":"    let sexp_of_t = Fn.compose sexp_of_string to_string","counters":[{"col_start":29,"col_end":29,"count":1}]},{"line":"","counters":[]},{"line":"    let t_of_sexp =","counters":[]},{"line":"      let of_string buf =","counters":[]},{"line":"        String.to_list buf","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"        |> List.map ~f:(Fn.compose Direction.of_int_exn Char.to_int)","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"        |> of_directions","counters":[]},{"line":"      in","counters":[]},{"line":"      Fn.compose of_string string_of_sexp","counters":[{"col_start":15,"col_end":15,"count":1}]},{"line":"","counters":[]},{"line":"    let hash = Fn.compose [%hash: int * string] to_tuple","counters":[{"col_start":24,"col_end":24,"count":1}]},{"line":"","counters":[]},{"line":"    let hash_fold_t hash_state t =","counters":[]},{"line":"      [%hash_fold: int * string] hash_state (to_tuple t)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"","counters":[]},{"line":"    [%%define_from_scope compare, to_yojson]","counters":[]},{"line":"","counters":[]},{"line":"    let equal = equals","counters":[]},{"line":"  end","counters":[]},{"line":"end]","counters":[]},{"line":"","counters":[]},{"line":"let byte_count_of_bits n = (n / 8) + min 1 (n % 8)","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"","counters":[]},{"line":"let height ~ledger_depth path = ledger_depth - depth path","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"","counters":[]},{"line":"let get = get","counters":[]},{"line":"","counters":[]},{"line":"[%%define_locally","counters":[]},{"line":"Stable.Latest.(t_of_sexp, sexp_of_t, to_yojson, compare, equal)]","counters":[]},{"line":"","counters":[]},{"line":"include Hashable.Make_binable (Stable.Latest)","counters":[]},{"line":"","counters":[]},{"line":"let of_byte_string = bitstring_of_string","counters":[]},{"line":"","counters":[]},{"line":"let pp (fmt : Format.formatter) : t -> unit =","counters":[]},{"line":"  Fn.compose (Format.pp_print_string fmt) to_string","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"let copy (path : t) : t =","counters":[]},{"line":"  let%bitstring path = {| path: -1: bitstring |} in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  path","counters":[{"col_start":5,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"(* returns a slice of the original path, so the returned key needs to be","counters":[]},{"line":"       copied before mutating the path *)","counters":[]},{"line":"let parent (path : t) =","counters":[]},{"line":"  if bitstring_length path = 0 then","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":20,"col_end":20,"count":0}]},{"line":"    Or_error.error_string \"Address length should be nonzero\"","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  else Or_error.return (slice path 0 (bitstring_length path - 1))","counters":[{"col_start":7,"col_end":7,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"","counters":[]},{"line":"let parent_exn = Fn.compose Or_error.ok_exn parent","counters":[{"col_start":26,"col_end":26,"count":1}]},{"line":"","counters":[]},{"line":"let is_leaf ~ledger_depth path = bitstring_length path >= ledger_depth","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"","counters":[]},{"line":"let child ~ledger_depth (path : t) dir : t Or_error.t =","counters":[]},{"line":"  if is_leaf ~ledger_depth path then","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Or_error.error_string \"The address length cannot be greater than depth\"","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  else","counters":[]},{"line":"    let dir_bit = Direction.to_bool dir in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let%bitstring path = {| path: -1: bitstring; dir_bit: 1|} in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Or_error.return path","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"let child_exn ~ledger_depth (path : t) dir : t =","counters":[]},{"line":"  child ~ledger_depth path dir |> Or_error.ok_exn","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"let to_int (path : t) : int =","counters":[]},{"line":"  Sequence.range 0 (depth path)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"  |> Sequence.fold ~init:0 ~f:(fun acc i ->","counters":[]},{"line":"         let index = depth path - 1 - i in","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"         acc + ((if get path index <> 0 then 1 else 0) lsl i) )","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"","counters":[]},{"line":"let of_int_exn ~ledger_depth index =","counters":[]},{"line":"  if index >= 1 lsl ledger_depth then failwith \"Index is too large\"","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"  else","counters":[]},{"line":"    let buf = create_bitstring ledger_depth in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    ignore","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ( Sequence.range ~stride:(-1) ~start:`inclusive ~stop:`inclusive","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"          (ledger_depth - 1) 0","counters":[]},{"line":"        |> Sequence.fold ~init:index ~f:(fun i pos ->","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"               Bitstring.put buf pos (i % 2) ;","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"               i / 2 )","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"        : int ) ;","counters":[]},{"line":"    buf","counters":[]},{"line":"","counters":[]},{"line":"let dirs_from_root t =","counters":[]},{"line":"  List.init (depth t) ~f:(fun pos -> Direction.of_bool (is_set t pos))","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"","counters":[]},{"line":"let root () = create_bitstring 0","counters":[{"col_start":14,"col_end":14,"count":1}]},{"line":"","counters":[]},{"line":"let sibling (path : t) : t =","counters":[]},{"line":"  let path = copy path in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let last_bit_index = depth path - 1 in","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"  let last_bit = if get path last_bit_index = 0 then 1 else 0 in","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":53,"col_end":53,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"  put path last_bit_index last_bit ;","counters":[]},{"line":"  path","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let next (path : t) : t Option.t =","counters":[]},{"line":"  let open Option.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let path = copy path in","counters":[]},{"line":"  let len = depth path in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let rec find_rightmost_clear_bit i =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    if i < 0 then None","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"    else if is_clear path i then Some i","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"    else find_rightmost_clear_bit (i - 1)","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"  in","counters":[]},{"line":"  let rec clear_bits i =","counters":[]},{"line":"    if i >= len then ()","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"    else (","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"      clear path i ;","counters":[]},{"line":"      clear_bits (i + 1) )","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%map rightmost_clear_index = find_rightmost_clear_bit (len - 1) in","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"  set path rightmost_clear_index ;","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  clear_bits (rightmost_clear_index + 1) ;","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  path","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let prev (path : t) : t Option.t =","counters":[]},{"line":"  let open Option.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let path = copy path in","counters":[]},{"line":"  let len = depth path in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let rec find_rightmost_one_bit i =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    if i < 0 then None","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"    else if is_set path i then Some i","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"    else find_rightmost_one_bit (i - 1)","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"  in","counters":[]},{"line":"  let rec set_bits i =","counters":[]},{"line":"    if i >= len then ()","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"    else (","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"      set path i ;","counters":[]},{"line":"      set_bits (i + 1) )","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%map rightmost_clear_index = find_rightmost_one_bit (len - 1) in","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"  clear path rightmost_clear_index ;","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  set_bits (rightmost_clear_index + 1) ;","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  path","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let serialize ~ledger_depth path =","counters":[]},{"line":"  let path = add_padding path in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let path_len = depth path in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let required_bits = 8 * byte_count_of_bits ledger_depth in","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"  assert (path_len <= required_bits) ;","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"  let required_padding = required_bits - path_len in","counters":[]},{"line":"  Bigstring.of_string @@ string_of_bitstring","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"  @@ concat [ path; zeroes_bitstring required_padding ]","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"let is_parent_of parent ~maybe_child = Bitstring.is_prefix maybe_child parent","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"module Range = struct","counters":[]},{"line":"  type nonrec t = t * t","counters":[]},{"line":"","counters":[]},{"line":"  let rec fold_exl (first, last) ~init ~f =","counters":[]},{"line":"    let comparison = compare first last in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    if comparison > 0 then","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      raise (Invalid_argument \"first address needs to precede last address\")","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    else if comparison = 0 then init","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"    else fold_exl (next first |> Option.value_exn, last) ~init:(f first init) ~f","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":48,"col_end":48,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"","counters":[]},{"line":"  let fold_incl (first, last) ~init ~f =","counters":[]},{"line":"    f last @@ fold_exl (first, last) ~init ~f","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"","counters":[]},{"line":"  let fold ?(stop = `Inclusive) (first, last) ~init ~f =","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"    assert (depth first = depth last) ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":11,"col_end":11,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"    match stop with","counters":[]},{"line":"    | `Inclusive ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        fold_incl (first, last) ~init ~f","counters":[]},{"line":"    | `Exclusive ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        fold_exl (first, last) ~init ~f","counters":[]},{"line":"","counters":[]},{"line":"  let subtree_range ~ledger_depth address =","counters":[]},{"line":"    let first_node =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      concat [ address; zeroes_bitstring @@ height ~ledger_depth address ]","counters":[{"col_start":39,"col_end":39,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"    in","counters":[]},{"line":"    let last_node =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      concat [ address; ones_bitstring @@ height ~ledger_depth address ]","counters":[{"col_start":37,"col_end":37,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"    in","counters":[]},{"line":"    (first_node, last_node)","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let subtree_range_seq ~ledger_depth address =","counters":[]},{"line":"    let first_node, last_node = subtree_range ~ledger_depth address in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Sequence.unfold","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ~init:(first_node, `Don't_stop)","counters":[]},{"line":"      ~f:(function","counters":[]},{"line":"        | _, `Stop ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            None","counters":[]},{"line":"        | current_node, `Don't_stop ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            if compare current_node last_node = 0 then","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"              Some (current_node, (current_node, `Stop))","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"            else","counters":[]},{"line":"              Option.map (next current_node) ~f:(fun next_node ->","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"                  (current_node, (next_node, `Don't_stop)) ) )","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make_test (Input : sig","counters":[]},{"line":"  val depth : int","counters":[]},{"line":"end) =","counters":[]},{"line":"struct","counters":[]},{"line":"  let%test \"the merkle root should have no path\" =","counters":[]},{"line":"    List.is_empty (dirs_from_root (root ()))","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"","counters":[]},{"line":"  let%test_unit \"parent_exn(child_exn(node)) = node\" =","counters":[]},{"line":"    Quickcheck.test ~sexp_of:[%sexp_of: Direction.t List.t * Direction.t]","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (Quickcheck.Generator.tuple2","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"         (Direction.gen_var_length_list Input.depth)","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"         Direction.gen )","counters":[]},{"line":"      ~f:(fun (path, direction) ->","counters":[]},{"line":"        let address = of_directions path in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        [%test_eq: t]","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"          (parent_exn (child_exn ~ledger_depth:Input.depth address direction))","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"          address )","counters":[]},{"line":"","counters":[]},{"line":"  let%test_unit \"to_index(of_index_exn(i)) = i\" =","counters":[]},{"line":"    Quickcheck.test ~sexp_of:[%sexp_of: int]","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (Int.gen_incl 0 ((1 lsl Input.depth) - 1))","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"      ~f:(fun index ->","counters":[]},{"line":"        [%test_result: int] ~expect:index","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"          (to_int @@ of_int_exn ~ledger_depth:Input.depth index) )","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"","counters":[]},{"line":"  let%test_unit \"of_index_exn(to_index(addr)) = addr\" =","counters":[]},{"line":"    Quickcheck.test ~sexp_of:[%sexp_of: Direction.t list]","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (Direction.gen_list Input.depth) ~f:(fun directions ->","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"        let address = of_directions directions in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        [%test_result: t] ~expect:address","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"          (of_int_exn ~ledger_depth:Input.depth @@ to_int address) )","counters":[{"col_start":46,"col_end":46,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"","counters":[]},{"line":"  let%test_unit \"nonempty(addr): sibling(sibling(addr)) = addr\" =","counters":[]},{"line":"    Quickcheck.test ~sexp_of:[%sexp_of: Direction.t list]","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (Direction.gen_var_length_list ~start:1 Input.depth) ~f:(fun directions ->","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"        let address = of_directions directions in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        [%test_result: t] ~expect:address (sibling @@ sibling address) )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":49,"col_end":49,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"","counters":[]},{"line":"  let%test_unit \"prev(next(addr)) = addr\" =","counters":[]},{"line":"    Quickcheck.test ~sexp_of:[%sexp_of: Direction.t list]","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (Direction.gen_list Input.depth) ~f:(fun directions ->","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"        let address = of_directions directions in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        match next address with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ()","counters":[]},{"line":"        | Some addr' ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            [%test_result: t option] ~expect:(Some address) (prev addr') )","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let%test_module \"Address\" =","counters":[]},{"line":"  ( module struct","counters":[]},{"line":"    module Test4 = Make_test (struct","counters":[]},{"line":"      let depth = 4","counters":[]},{"line":"    end)","counters":[]},{"line":"","counters":[]},{"line":"    module Test16 = Make_test (struct","counters":[]},{"line":"      let depth = 16","counters":[]},{"line":"    end)","counters":[]},{"line":"","counters":[]},{"line":"    module Test30 = Make_test (struct","counters":[]},{"line":"      let depth = 30","counters":[]},{"line":"    end)","counters":[]},{"line":"  end )","counters":[{"col_start":6,"col_end":6,"count":2}]}]}