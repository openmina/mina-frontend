{"filename":"src/lib/pickles_types/vector.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"module type Nat_intf = Nat.Intf","counters":[]},{"line":"","counters":[]},{"line":"type z = Nat.z","counters":[]},{"line":"","counters":[]},{"line":"type 'a s = 'a Nat.s","counters":[]},{"line":"","counters":[]},{"line":"module T = struct","counters":[]},{"line":"  type ('a, _) t = [] : ('a, z) t | ( :: ) : 'a * ('a, 'n) t -> ('a, 'n s) t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"include T","counters":[]},{"line":"","counters":[]},{"line":"let unsingleton (type a) ([ x ] : (a, z s) t) : a = x","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"","counters":[]},{"line":"let rec iter : type a n. (a, n) t -> f:(a -> unit) -> unit =","counters":[]},{"line":" fun t ~f -> match t with [] -> () | x :: xs -> f x ; iter xs ~f","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"","counters":[]},{"line":"let rec iter2 : type a b n. (a, n) t -> (b, n) t -> f:(a -> b -> unit) -> unit =","counters":[]},{"line":" fun t1 t2 ~f ->","counters":[]},{"line":"  match (t1, t2) with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | [], [] ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ()","counters":[]},{"line":"  | x :: xs, y :: ys ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      f x y ; iter2 xs ys ~f","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"","counters":[]},{"line":"let rec map2 : type a b c n. (a, n) t -> (b, n) t -> f:(a -> b -> c) -> (c, n) t","counters":[]},{"line":"    =","counters":[]},{"line":" fun t1 t2 ~f ->","counters":[]},{"line":"  match (t1, t2) with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | [], [] ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      []","counters":[]},{"line":"  | x :: xs, y :: ys ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      f x y :: map2 xs ys ~f","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"","counters":[]},{"line":"let rec hhead_off :","counters":[]},{"line":"    type xs n.","counters":[]},{"line":"    (xs, n s) Hlist0.H1_1(T).t -> xs Hlist0.HlistId.t * (xs, n) Hlist0.H1_1(T).t","counters":[]},{"line":"    =","counters":[]},{"line":" fun xss ->","counters":[]},{"line":"  match xss with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | [] ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ([], [])","counters":[]},{"line":"  | (x :: xs) :: xss ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let hds, tls = hhead_off xss in","counters":[]},{"line":"      (x :: hds, xs :: tls)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"let rec mapn :","counters":[]},{"line":"    type xs y n.","counters":[]},{"line":"    (xs, n) Hlist0.H1_1(T).t -> f:(xs Hlist0.HlistId.t -> y) -> (y, n) t =","counters":[]},{"line":" fun xss ~f ->","counters":[]},{"line":"  match xss with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | [] :: _xss ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      []","counters":[]},{"line":"  | (_ :: _) :: _ ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let hds, tls = hhead_off xss in","counters":[]},{"line":"      let y = f hds in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let ys = mapn tls ~f in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      y :: ys","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  | [] ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      failwith \"mapn: Empty args\"","counters":[]},{"line":"","counters":[]},{"line":"let zip xs ys = map2 xs ys ~f:(fun x y -> (x, y))","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"","counters":[]},{"line":"let rec to_list : type a n. (a, n) t -> a list =","counters":[]},{"line":" fun t -> match t with [] -> [] | x :: xs -> x :: to_list xs","counters":[{"col_start":10,"col_end":10,"count":230},{"col_start":23,"col_end":23,"count":37},{"col_start":34,"col_end":34,"count":193},{"col_start":56,"col_end":56,"count":193}]},{"line":"","counters":[]},{"line":"let sexp_of_t a _ v = List.sexp_of_t a (to_list v)","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"","counters":[]},{"line":"let to_array t = Array.of_list (to_list t)","counters":[{"col_start":17,"col_end":17,"count":2},{"col_start":38,"col_end":38,"count":2}]},{"line":"","counters":[]},{"line":"let rec length : type a n. (a, n) t -> n Nat.t = function","counters":[]},{"line":"  | [] ->","counters":[{"col_start":4,"col_end":4,"count":4}]},{"line":"      Z","counters":[]},{"line":"  | _ :: xs ->","counters":[{"col_start":4,"col_end":4,"count":4}]},{"line":"      S (length xs)","counters":[{"col_start":14,"col_end":14,"count":4}]},{"line":"","counters":[]},{"line":"let rec init : type a n. int -> n Nat.t -> f:(int -> a) -> (a, n) t =","counters":[]},{"line":" fun i n ~f -> match n with Z -> [] | S n -> f i :: init (i + 1) n ~f","counters":[{"col_start":15,"col_end":15,"count":325},{"col_start":28,"col_end":28,"count":31},{"col_start":38,"col_end":38,"count":294},{"col_start":45,"col_end":45,"count":294},{"col_start":55,"col_end":55,"count":294}]},{"line":"","counters":[]},{"line":"let init n ~f = init 0 n ~f","counters":[{"col_start":16,"col_end":16,"count":31}]},{"line":"","counters":[]},{"line":"let rec _fold_map :","counters":[]},{"line":"    type acc a b n.","counters":[]},{"line":"    (a, n) t -> f:(acc -> a -> acc * b) -> init:acc -> acc * (b, n) t =","counters":[]},{"line":" fun t ~f ~init ->","counters":[]},{"line":"  match t with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | [] ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (init, [])","counters":[]},{"line":"  | x :: xs ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let acc, y = f init x in","counters":[]},{"line":"      let res, ys = _fold_map xs ~f ~init:acc in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      (res, y :: ys)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"let rec map : type a b n. (a, n) t -> f:(a -> b) -> (b, n) t =","counters":[]},{"line":" fun t ~f -> match t with [] -> [] | x :: xs -> f x :: map xs ~f","counters":[{"col_start":13,"col_end":13,"count":97},{"col_start":26,"col_end":26,"count":8},{"col_start":37,"col_end":37,"count":89},{"col_start":48,"col_end":48,"count":89},{"col_start":57,"col_end":57,"count":89}]},{"line":"","counters":[]},{"line":"let mapi (type a b m) (t : (a, m) t) ~(f : int -> a -> b) =","counters":[]},{"line":"  let rec go : type n. int -> (a, n) t -> (b, n) t =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"   fun i t -> match t with [] -> [] | x :: xs -> f i x :: go (i + 1) xs","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":49,"col_end":49,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"  in","counters":[]},{"line":"  go 0 t","counters":[]},{"line":"","counters":[]},{"line":"let unzip ts = (map ts ~f:fst, map ts ~f:snd)","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"","counters":[]},{"line":"type _ e = T : ('a, 'n) t -> 'a e","counters":[]},{"line":"","counters":[]},{"line":"let rec of_list : type a. a list -> a e = function","counters":[]},{"line":"  | [] ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      T []","counters":[]},{"line":"  | x :: xs ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let (T xs) = of_list xs in","counters":[]},{"line":"      T (x :: xs)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"let rec of_list_and_length_exn : type a n. a list -> n Nat.t -> (a, n) t =","counters":[]},{"line":" fun xs n ->","counters":[]},{"line":"  match (xs, n) with","counters":[{"col_start":2,"col_end":2,"count":93}]},{"line":"  | [], Z ->","counters":[{"col_start":4,"col_end":4,"count":31}]},{"line":"      []","counters":[]},{"line":"  | x :: xs, S n ->","counters":[{"col_start":4,"col_end":4,"count":62}]},{"line":"      x :: of_list_and_length_exn xs n","counters":[{"col_start":32,"col_end":32,"count":62}]},{"line":"  | [], S _ | _ :: _, Z ->","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":14,"col_end":14,"count":0}]},{"line":"      failwith \"Vector: Length mismatch\"","counters":[]},{"line":"","counters":[]},{"line":"let of_array_and_length_exn : type a n. a array -> n Nat.t -> (a, n) t =","counters":[]},{"line":" fun xs n ->","counters":[]},{"line":"  if Array.length xs <> Nat.to_int n then","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"    failwithf \"of_array_and_length_exn: got %d (expected %d)\" (Array.length xs)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":12,"col_end":12,"count":0},{"col_start":74,"col_end":74,"count":0}]},{"line":"      (Nat.to_int n) () ;","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"  init n ~f:(Array.get xs)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"","counters":[]},{"line":"let rec _take_from_list : type a n. a list -> n Nat.t -> (a, n) t =","counters":[]},{"line":" fun xs n ->","counters":[]},{"line":"  match (xs, n) with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | _, Z ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      []","counters":[]},{"line":"  | x :: xs, S n ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      x :: _take_from_list xs n","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"  | [], S _ ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      failwith \"take_from_list: Not enough to take\"","counters":[]},{"line":"","counters":[]},{"line":"let rec fold : type acc a n. (a, n) t -> f:(acc -> a -> acc) -> init:acc -> acc","counters":[]},{"line":"    =","counters":[]},{"line":" fun t ~f ~init ->","counters":[]},{"line":"  match t with","counters":[{"col_start":2,"col_end":2,"count":34}]},{"line":"  | [] ->","counters":[{"col_start":4,"col_end":4,"count":6}]},{"line":"      init","counters":[]},{"line":"  | x :: xs ->","counters":[{"col_start":4,"col_end":4,"count":28}]},{"line":"      let acc = f init x in","counters":[]},{"line":"      fold xs ~f ~init:acc","counters":[{"col_start":6,"col_end":6,"count":28}]},{"line":"","counters":[]},{"line":"let for_all : type a n. (a, n) t -> f:(a -> bool) -> bool =","counters":[]},{"line":" fun v ~f ->","counters":[]},{"line":"  with_return (fun { return } ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      iter v ~f:(fun x -> if not (f x) then return false) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"      true )","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"let foldi t ~f ~init =","counters":[]},{"line":"  snd (fold t ~f:(fun (i, acc) x -> (i + 1, f i acc x)) ~init:(0, init))","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":10,"col_end":10,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"let reduce_exn (type n) (t : (_, n) t) ~f =","counters":[]},{"line":"  match t with","counters":[{"col_start":2,"col_end":2,"count":6}]},{"line":"  | [] ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      failwith \"reduce_exn: empty list\"","counters":[]},{"line":"  | init :: xs ->","counters":[{"col_start":4,"col_end":4,"count":6}]},{"line":"      fold xs ~f ~init","counters":[]},{"line":"","counters":[]},{"line":"module L = struct","counters":[]},{"line":"  type 'a t = 'a list [@@deriving yojson]","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":14,"col_end":14,"count":0},{"col_start":20,"col_end":20,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make = struct","counters":[]},{"line":"  module Cata (F : sig","counters":[]},{"line":"    type _ t","counters":[]},{"line":"","counters":[]},{"line":"    val pair : 'a t -> 'b t -> ('a * 'b) t","counters":[]},{"line":"","counters":[]},{"line":"    val cnv : ('a -> 'b) -> ('b -> 'a) -> 'b t -> 'a t","counters":[]},{"line":"","counters":[]},{"line":"    val unit : unit t","counters":[]},{"line":"  end) =","counters":[]},{"line":"  struct","counters":[]},{"line":"    let rec f : type n a. n Nat.t -> a F.t -> (a, n) t F.t =","counters":[]},{"line":"     fun n tc ->","counters":[]},{"line":"      match n with","counters":[{"col_start":6,"col_end":6,"count":448}]},{"line":"      | Z ->","counters":[{"col_start":8,"col_end":8,"count":52}]},{"line":"          F.cnv (function [] -> ()) (fun () -> []) F.unit","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":47,"col_end":47,"count":156}]},{"line":"      | S n ->","counters":[{"col_start":8,"col_end":8,"count":396}]},{"line":"          let tl = f n tc in","counters":[]},{"line":"          F.cnv","counters":[{"col_start":10,"col_end":10,"count":396}]},{"line":"            (function x :: xs -> (x, xs))","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"            (fun (x, xs) -> x :: xs)","counters":[{"col_start":28,"col_end":28,"count":518}]},{"line":"            (F.pair tc tl)","counters":[{"col_start":18,"col_end":18,"count":396}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Sexpable (N : Nat_intf) : Sexpable.S1 with type 'a t := ('a, N.n) t =","counters":[]},{"line":"  struct","counters":[]},{"line":"    let sexp_of_t f t = List.sexp_of_t f (to_list t)","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"","counters":[]},{"line":"    let t_of_sexp f s = of_list_and_length_exn (List.t_of_sexp f s) N.n","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Yojson (N : Nat_intf) :","counters":[]},{"line":"    Sigs.Jsonable.S1 with type 'a t := ('a, N.n) t = struct","counters":[]},{"line":"    let to_yojson f t = L.to_yojson f (to_list t)","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"","counters":[]},{"line":"    let of_yojson f s =","counters":[]},{"line":"      Result.map (L.of_yojson f s) ~f:(Fn.flip of_list_and_length_exn N.n)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Binable (N : Nat_intf) : Binable.S1 with type 'a t := ('a, N.n) t =","counters":[]},{"line":"  struct","counters":[]},{"line":"    open Bin_prot","counters":[]},{"line":"","counters":[]},{"line":"    module Tc = Cata (struct","counters":[]},{"line":"      type 'a t = 'a Type_class.t","counters":[]},{"line":"","counters":[]},{"line":"      let pair = Type_class.bin_pair","counters":[]},{"line":"","counters":[]},{"line":"      let cnv t = Type_class.cnv Fn.id t","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"","counters":[]},{"line":"      let unit = Type_class.bin_unit","counters":[]},{"line":"    end)","counters":[]},{"line":"","counters":[]},{"line":"    module Shape = Cata (struct","counters":[]},{"line":"      type _ t = Shape.t","counters":[]},{"line":"","counters":[]},{"line":"      let pair = Shape.bin_shape_pair","counters":[]},{"line":"","counters":[]},{"line":"      let cnv _ _ = Fn.id","counters":[{"col_start":20,"col_end":20,"count":140}]},{"line":"","counters":[]},{"line":"      let unit = Shape.bin_shape_unit","counters":[]},{"line":"    end)","counters":[]},{"line":"","counters":[]},{"line":"    module Size = Cata (struct","counters":[]},{"line":"      type 'a t = 'a Size.sizer","counters":[]},{"line":"","counters":[]},{"line":"      let pair = Size.bin_size_pair","counters":[]},{"line":"","counters":[]},{"line":"      let cnv a_to_b _b_to_a b_sizer a = b_sizer (a_to_b a)","counters":[{"col_start":41,"col_end":41,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"","counters":[]},{"line":"      let unit = Size.bin_size_unit","counters":[]},{"line":"    end)","counters":[]},{"line":"","counters":[]},{"line":"    module Write = Cata (struct","counters":[]},{"line":"      type 'a t = 'a Write.writer","counters":[]},{"line":"","counters":[]},{"line":"      let pair = Write.bin_write_pair","counters":[]},{"line":"","counters":[]},{"line":"      let cnv a_to_b _b_to_a b_writer buf ~pos a = b_writer buf ~pos (a_to_b a)","counters":[{"col_start":51,"col_end":51,"count":0},{"col_start":75,"col_end":75,"count":0}]},{"line":"","counters":[]},{"line":"      let unit = Write.bin_write_unit","counters":[]},{"line":"    end)","counters":[]},{"line":"","counters":[]},{"line":"    module Writer = Cata (struct","counters":[]},{"line":"      type 'a t = 'a Type_class.writer","counters":[]},{"line":"","counters":[]},{"line":"      let pair = Type_class.bin_writer_pair","counters":[]},{"line":"","counters":[]},{"line":"      let cnv a_to_b _b_to_a b_writer = Type_class.cnv_writer a_to_b b_writer","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"      let unit = Type_class.bin_writer_unit","counters":[]},{"line":"    end)","counters":[]},{"line":"","counters":[]},{"line":"    module Reader = Cata (struct","counters":[]},{"line":"      type 'a t = 'a Type_class.reader","counters":[]},{"line":"","counters":[]},{"line":"      let pair = Type_class.bin_reader_pair","counters":[]},{"line":"","counters":[]},{"line":"      let cnv _a_to_b b_to_a b_reader = Type_class.cnv_reader b_to_a b_reader","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"      let unit = Type_class.bin_reader_unit","counters":[]},{"line":"    end)","counters":[]},{"line":"","counters":[]},{"line":"    module Read = Cata (struct","counters":[]},{"line":"      type 'a t = 'a Read.reader","counters":[]},{"line":"","counters":[]},{"line":"      let pair = Read.bin_read_pair","counters":[]},{"line":"","counters":[]},{"line":"      let cnv _a_to_b b_to_a b_reader buf ~pos_ref =","counters":[]},{"line":"        b_to_a (b_reader buf ~pos_ref)","counters":[{"col_start":8,"col_end":8,"count":674},{"col_start":23,"col_end":23,"count":674}]},{"line":"","counters":[]},{"line":"      let unit = Read.bin_read_unit","counters":[]},{"line":"    end)","counters":[]},{"line":"","counters":[]},{"line":"    let bin_shape_t sh = Shape.f N.n sh","counters":[{"col_start":25,"col_end":25,"count":18}]},{"line":"","counters":[]},{"line":"    let bin_size_t sz = Size.f N.n sz","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"","counters":[]},{"line":"    let bin_write_t wr = Write.f N.n wr","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"    let bin_writer_t wr = Writer.f N.n wr","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"","counters":[]},{"line":"    let bin_t tc = Tc.f N.n tc","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"","counters":[]},{"line":"    let bin_reader_t re = Reader.f N.n re","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"","counters":[]},{"line":"    let bin_read_t re = Read.f N.n re","counters":[{"col_start":24,"col_end":24,"count":34}]},{"line":"","counters":[]},{"line":"    let __bin_read_t__ _f _buf ~pos_ref _vint =","counters":[]},{"line":"      Common.raise_variant_wrong_type \"vector\" !pos_ref","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"type ('a, 'n) vec = ('a, 'n) t","counters":[]},{"line":"","counters":[]},{"line":"module With_length (N : Nat.Intf) = struct","counters":[]},{"line":"  type 'a t = ('a, N.n) vec","counters":[]},{"line":"","counters":[]},{"line":"  let compare c t1 t2 = Base.List.compare c (to_list t1) (to_list t2)","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":51,"col_end":51,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"","counters":[]},{"line":"  let hash_fold_t f s v = List.hash_fold_t f s (to_list v)","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"","counters":[]},{"line":"  let equal f t1 t2 = List.equal f (to_list t1) (to_list t2)","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":42,"col_end":42,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"","counters":[]},{"line":"  include Make.Yojson (N)","counters":[]},{"line":"  include Make.Sexpable (N)","counters":[]},{"line":"","counters":[]},{"line":"  let map (t : 'a t) = map t","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"  let of_list_exn : 'a list -> 'a t = fun ls -> of_list_and_length_exn ls N.n","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"","counters":[]},{"line":"  let to_list : 'a t -> 'a list = to_list","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let rec typ' :","counters":[]},{"line":"    type f var value n.","counters":[]},{"line":"       ((var, value, f) Snarky_backendless.Typ.t, n) t","counters":[]},{"line":"    -> ((var, n) t, (value, n) t, f) Snarky_backendless.Typ.t =","counters":[]},{"line":"  let open Snarky_backendless.Typ in","counters":[]},{"line":"  fun elts ->","counters":[]},{"line":"    match elts with","counters":[{"col_start":4,"col_end":4,"count":64}]},{"line":"    | elt :: elts ->","counters":[{"col_start":6,"col_end":6,"count":57}]},{"line":"        let tl = typ' elts in","counters":[]},{"line":"        let there = function x :: xs -> (x, xs) in","counters":[{"col_start":8,"col_end":8,"count":57},{"col_start":29,"col_end":29,"count":0}]},{"line":"        let back (x, xs) = x :: xs in","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"        transport (elt * tl) ~there ~back |> transport_var ~there ~back","counters":[{"col_start":16,"col_end":16,"count":57}]},{"line":"    | [] ->","counters":[{"col_start":6,"col_end":6,"count":7}]},{"line":"        let there [] = () in","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"        let back () = [] in","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"        transport (unit ()) ~there ~back |> transport_var ~there ~back","counters":[{"col_start":16,"col_end":16,"count":7},{"col_start":22,"col_end":22,"count":7}]},{"line":"","counters":[]},{"line":"let typ elt n = typ' (init n ~f:(fun _ -> elt))","counters":[{"col_start":16,"col_end":16,"count":7},{"col_start":25,"col_end":25,"count":7},{"col_start":42,"col_end":42,"count":57}]},{"line":"","counters":[]},{"line":"let rec append :","counters":[]},{"line":"    type n m n_m a. (a, n) t -> (a, m) t -> (n, m, n_m) Nat.Adds.t -> (a, n_m) t","counters":[]},{"line":"    =","counters":[]},{"line":" fun t1 t2 adds ->","counters":[]},{"line":"  match (t1, adds) with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | [], Z ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      t2","counters":[]},{"line":"  | x :: t1, S adds ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      x :: append t1 t2 adds","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"","counters":[]},{"line":"(* TODO: Make more efficient *)","counters":[]},{"line":"let rev (type a n) (xs : (a, n) t) : (a, n) t =","counters":[]},{"line":"  of_list_and_length_exn","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    (fold ~init:[] ~f:(fun acc x -> List.cons x acc) xs)","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"    (length xs)","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"let rec _last : type a n. (a, n s) t -> a = function","counters":[]},{"line":"  | [ x ] ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      x","counters":[]},{"line":"  | _ :: (_ :: _ as xs) ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      _last xs","counters":[]},{"line":"","counters":[]},{"line":"let rec split :","counters":[]},{"line":"    type n m n_m a. (a, n_m) t -> (n, m, n_m) Nat.Adds.t -> (a, n) t * (a, m) t","counters":[]},{"line":"    =","counters":[]},{"line":" fun t adds ->","counters":[]},{"line":"  match (t, adds) with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | [], Z ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ([], [])","counters":[]},{"line":"  | _ :: _, Z ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ([], t)","counters":[]},{"line":"  | x :: t1, S adds ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let xs, ys = split t1 adds in","counters":[]},{"line":"      (x :: xs, ys)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"let rec transpose : type a n m. ((a, n) t, m) t -> ((a, m) t, n) t =","counters":[]},{"line":" fun xss ->","counters":[]},{"line":"  match xss with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | [] ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      failwith \"transpose: empty list\"","counters":[]},{"line":"  | [] :: _ ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      []","counters":[]},{"line":"  | (_ :: _) :: _ ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let heads, tails = unzip (map xss ~f:(fun (x :: xs) -> (x, xs))) in","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"      heads :: transpose tails","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"let rec trim : type a n m. (a, m) t -> (n, m) Nat.Lte.t -> (a, n) t =","counters":[]},{"line":" fun v p -> match (v, p) with _, Z -> [] | x :: xs, S p -> x :: trim xs p","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":43,"col_end":43,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"","counters":[]},{"line":"let rec extend_exn : type n m a. (a, n) t -> m Nat.t -> a -> (a, m) t =","counters":[]},{"line":" fun v m default ->","counters":[]},{"line":"  match (v, m) with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | [], Z ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      []","counters":[]},{"line":"  | [], S n ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      default :: extend_exn [] n default","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"  | _x :: _xs, Z ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      failwith \"extend_exn: list too long\"","counters":[]},{"line":"  | x :: xs, S m ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let extended = extend_exn xs m default in","counters":[]},{"line":"      x :: extended","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"let rec extend :","counters":[]},{"line":"    type a n m. (a, n) t -> (n, m) Nat.Lte.t -> m Nat.t -> a -> (a, m) t =","counters":[]},{"line":" fun v p m default ->","counters":[]},{"line":"  match (v, p, m) with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | _, Z, Z ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      []","counters":[]},{"line":"  | _, Z, S m ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      default :: extend [] Z m default","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"  | x :: xs, S p, S m ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      x :: extend xs p m default","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"","counters":[]},{"line":"module type S = sig","counters":[]},{"line":"  type 'a t [@@deriving compare, yojson, sexp, hash, equal]","counters":[]},{"line":"","counters":[]},{"line":"  val map : 'a t -> f:('a -> 'b) -> 'b t","counters":[]},{"line":"","counters":[]},{"line":"  val of_list_exn : 'a list -> 'a t","counters":[]},{"line":"","counters":[]},{"line":"  val to_list : 'a t -> 'a list","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type VECTOR = sig","counters":[]},{"line":"  type 'a t","counters":[]},{"line":"","counters":[]},{"line":"  include S with type 'a t := 'a t","counters":[]},{"line":"","counters":[]},{"line":"  module Stable : sig","counters":[]},{"line":"    module V1 : sig","counters":[]},{"line":"      include S with type 'a t = 'a t","counters":[]},{"line":"","counters":[]},{"line":"      include Sigs.Binable.S1 with type 'a t = 'a t","counters":[]},{"line":"","counters":[]},{"line":"      include Sigs.VERSIONED","counters":[]},{"line":"    end","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module With_version (N : Nat.Intf) = struct","counters":[]},{"line":"  module type S = sig","counters":[]},{"line":"    [%%versioned:","counters":[]},{"line":"    module Stable : sig","counters":[]},{"line":"      module V1 : sig","counters":[]},{"line":"        type 'a t = ('a, N.n) vec","counters":[]},{"line":"        [@@deriving compare, yojson, sexp, hash, equal]","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    val map : 'a t -> f:('a -> 'b) -> 'b t","counters":[]},{"line":"","counters":[]},{"line":"    val of_list_exn : 'a list -> 'a t","counters":[]},{"line":"","counters":[]},{"line":"    val to_list : 'a t -> 'a list","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Vector_2 = struct","counters":[]},{"line":"  module T = With_length (Nat.N2)","counters":[]},{"line":"","counters":[]},{"line":"  [%%versioned_binable","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    [@@@no_toplevel_latest_type]","counters":[]},{"line":"","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type 'a t = ('a, Nat.N2.n) vec","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"      include Make.Binable (Nat.N2)","counters":[]},{"line":"","counters":[]},{"line":"      include (T : module type of T with type 'a t := 'a t)","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  include T","counters":[]},{"line":"","counters":[]},{"line":"  let () =","counters":[]},{"line":"    let _f : type a. unit -> (a t, a Stable.Latest.t) Type_equal.t =","counters":[]},{"line":"     fun () -> Type_equal.T","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"    in","counters":[]},{"line":"    ()","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Vector_4 = struct","counters":[]},{"line":"  module T = With_length (Nat.N4)","counters":[]},{"line":"","counters":[]},{"line":"  [%%versioned_binable","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    [@@@no_toplevel_latest_type]","counters":[]},{"line":"","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type 'a t = ('a, Nat.N4.n) vec","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"      include Make.Binable (Nat.N4)","counters":[]},{"line":"","counters":[]},{"line":"      include (T : module type of T with type 'a t := 'a t)","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  include T","counters":[]},{"line":"","counters":[]},{"line":"  let () =","counters":[]},{"line":"    let _f : type a. unit -> (a t, a Stable.Latest.t) Type_equal.t =","counters":[]},{"line":"     fun () -> Type_equal.T","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"    in","counters":[]},{"line":"    ()","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Vector_5 = struct","counters":[]},{"line":"  module T = With_length (Nat.N5)","counters":[]},{"line":"","counters":[]},{"line":"  [%%versioned_binable","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    [@@@no_toplevel_latest_type]","counters":[]},{"line":"","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type 'a t = ('a, Nat.N5.n) vec","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"      include Make.Binable (Nat.N5)","counters":[]},{"line":"","counters":[]},{"line":"      include (T : module type of T with type 'a t := 'a t)","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  include T","counters":[]},{"line":"","counters":[]},{"line":"  let () =","counters":[]},{"line":"    let _f : type a. unit -> (a t, a Stable.Latest.t) Type_equal.t =","counters":[]},{"line":"     fun () -> Type_equal.T","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"    in","counters":[]},{"line":"    ()","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Vector_6 = struct","counters":[]},{"line":"  module T = With_length (Nat.N6)","counters":[]},{"line":"","counters":[]},{"line":"  [%%versioned_binable","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    [@@@no_toplevel_latest_type]","counters":[]},{"line":"","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type 'a t = ('a, Nat.N6.n) vec","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"      include Make.Binable (Nat.N6)","counters":[]},{"line":"","counters":[]},{"line":"      include (T : module type of T with type 'a t := 'a t)","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  include T","counters":[]},{"line":"","counters":[]},{"line":"  let () =","counters":[]},{"line":"    let _f : type a. unit -> (a t, a Stable.Latest.t) Type_equal.t =","counters":[]},{"line":"     fun () -> Type_equal.T","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"    in","counters":[]},{"line":"    ()","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Vector_7 = struct","counters":[]},{"line":"  module T = With_length (Nat.N7)","counters":[]},{"line":"","counters":[]},{"line":"  [%%versioned_binable","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    [@@@no_toplevel_latest_type]","counters":[]},{"line":"","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type 'a t = ('a, Nat.N7.n) vec","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"      include Make.Binable (Nat.N7)","counters":[]},{"line":"","counters":[]},{"line":"      include (T : module type of T with type 'a t := 'a t)","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  include T","counters":[]},{"line":"","counters":[]},{"line":"  let () =","counters":[]},{"line":"    let _f : type a. unit -> (a t, a Stable.Latest.t) Type_equal.t =","counters":[]},{"line":"     fun () -> Type_equal.T","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"    in","counters":[]},{"line":"    ()","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Vector_8 = struct","counters":[]},{"line":"  module T = With_length (Nat.N8)","counters":[]},{"line":"","counters":[]},{"line":"  [%%versioned_binable","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    [@@@no_toplevel_latest_type]","counters":[]},{"line":"","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type 'a t = ('a, Nat.N8.n) vec","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"      include Make.Binable (Nat.N8)","counters":[]},{"line":"","counters":[]},{"line":"      include (T : module type of T with type 'a t := 'a t)","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  include T","counters":[]},{"line":"","counters":[]},{"line":"  let () =","counters":[]},{"line":"    let _f : type a. unit -> (a t, a Stable.Latest.t) Type_equal.t =","counters":[]},{"line":"     fun () -> Type_equal.T","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"    in","counters":[]},{"line":"    ()","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Vector_15 = struct","counters":[]},{"line":"  module T = With_length (Nat.N15)","counters":[]},{"line":"","counters":[]},{"line":"  [%%versioned_binable","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    [@@@no_toplevel_latest_type]","counters":[]},{"line":"","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type 'a t = ('a, Nat.N15.n) vec","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"      include Make.Binable (Nat.N15)","counters":[]},{"line":"","counters":[]},{"line":"      include (T : module type of T with type 'a t := 'a t)","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  include T","counters":[]},{"line":"","counters":[]},{"line":"  let () =","counters":[]},{"line":"    let _f : type a. unit -> (a t, a Stable.Latest.t) Type_equal.t =","counters":[]},{"line":"     fun () -> Type_equal.T","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"    in","counters":[]},{"line":"    ()","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Vector_16 = struct","counters":[]},{"line":"  module T = With_length (Nat.N16)","counters":[]},{"line":"","counters":[]},{"line":"  [%%versioned_binable","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    [@@@no_toplevel_latest_type]","counters":[]},{"line":"","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type 'a t = ('a, Nat.N16.n) vec","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"      include Make.Binable (Nat.N16)","counters":[]},{"line":"","counters":[]},{"line":"      include (T : module type of T with type 'a t := 'a t)","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  include T","counters":[]},{"line":"","counters":[]},{"line":"  let () =","counters":[]},{"line":"    let _f : type a. unit -> (a t, a Stable.Latest.t) Type_equal.t =","counters":[]},{"line":"     fun () -> Type_equal.T","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"    in","counters":[]},{"line":"    ()","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}