{"filename":"src/lib/secrets/hardware_wallets.ml","lines":[{"line":"open Snark_params","counters":[]},{"line":"open Core","counters":[]},{"line":"open Signature_lib","counters":[]},{"line":"open Mina_base","counters":[]},{"line":"open Async","counters":[]},{"line":"","counters":[]},{"line":"let create_hd_account_summary =","counters":[]},{"line":"  \"Create an account with hardware wallet - this will let the hardware wallet \\","counters":[]},{"line":"   generate a keypair corresponds to the HD-index you give and store this \\","counters":[]},{"line":"   HD-index and the generated public key in the daemon. Calling this command \\","counters":[]},{"line":"   with the same HD-index and the same hardware wallet will always generate \\","counters":[]},{"line":"   the same keypair.\"","counters":[]},{"line":"","counters":[]},{"line":"let hardware_wallet_script = \"codaledgercli\"","counters":[]},{"line":"","counters":[]},{"line":"module type Tick_intf = sig","counters":[]},{"line":"  type field","counters":[]},{"line":"","counters":[]},{"line":"  module Bigint : sig","counters":[]},{"line":"    type t","counters":[]},{"line":"","counters":[]},{"line":"    val of_bignum_bigint : Bigint.t -> t","counters":[]},{"line":"","counters":[]},{"line":"    val to_field : t -> field","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let decode_field (type field) (module Tick : Tick_intf with type field = field)","counters":[]},{"line":"    : string -> field =","counters":[]},{"line":" fun field ->","counters":[{"col_start":1,"col_end":1,"count":0}]},{"line":"  Bytes.of_string field","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":16,"col_end":16,"count":0}]},{"line":"  |> B58.decode Base58_check.mina_alphabet","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"  |> Bytes.to_list |> List.rev |> Bytes.of_char_list |> Bytes.to_string","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":51,"col_end":51,"count":0},{"col_start":70,"col_end":70,"count":0}]},{"line":"  |> String.foldi ~init:Bigint.zero ~f:(fun i acc byte ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"         Bigint.(acc lor (of_int (Char.to_int byte) lsl Int.( * ) 8 i)) )","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"  |> Tick.Bigint.of_bignum_bigint |> Tick.Bigint.to_field","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"","counters":[]},{"line":"type public_key = { status : string; x : string; y : string }","counters":[{"col_start":0,"col_end":0,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":46,"col_end":46,"count":0},{"col_start":49,"col_end":49,"count":0},{"col_start":53,"col_end":53,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"[@@deriving yojson]","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"","counters":[]},{"line":"let decode_status_code ~f = function","counters":[]},{"line":"  | \"Ok\" ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Ok (f ())","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"  | \"Hardware_wallet_not_found\" ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Error \"Hardware wallet not found. Is the device plugged in and activated?\"","counters":[]},{"line":"  | \"Computation_aborted\" ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Error \"An internal error happens in hardware wallet.\"","counters":[]},{"line":"  | s ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Error (sprintf !\"Unknown status code returned by hardware wallet: %s\" s)","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"","counters":[]},{"line":"let report_json_error s =","counters":[]},{"line":"  sprintf !\"Failed to parse the json returned by hardware wallet: %s\" s","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let report_process_error e =","counters":[]},{"line":"  sprintf","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    !\"Failed to communicate with hardware wallet program %s: %s.\\n\\","counters":[]},{"line":"      Do you have the auxiliary dependencies required for using the hardware \\","counters":[]},{"line":"      wallet?\"","counters":[]},{"line":"    hardware_wallet_script (Error.to_string_hum e)","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"","counters":[]},{"line":"let decode_public_key : string -> (Public_key.t, string) Result.t =","counters":[]},{"line":" fun public_key ->","counters":[]},{"line":"  Yojson.Safe.from_string public_key","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"  |> public_key_of_yojson","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"  |> Result.map_error ~f:report_json_error","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"  |> Result.bind ~f:(fun { status; x; y } ->","counters":[]},{"line":"         decode_status_code status ~f:(fun () ->","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"             ( decode_field (module Snark_params.Tick) x","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"             , decode_field (module Snark_params.Tick) y ) ) )","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"","counters":[]},{"line":"type signature = { status : string; field : string; scalar : string }","counters":[{"col_start":0,"col_end":0,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":49,"col_end":49,"count":0},{"col_start":52,"col_end":52,"count":0},{"col_start":61,"col_end":61,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"[@@deriving yojson]","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"","counters":[]},{"line":"let decode_signature : string -> (Signature.t, string) Result.t =","counters":[]},{"line":" fun signature ->","counters":[]},{"line":"  Yojson.Safe.from_string signature","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"  |> signature_of_yojson","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"  |> Result.map_error ~f:report_json_error","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"  |> Result.bind ~f:(fun { status; field; scalar } ->","counters":[]},{"line":"         decode_status_code status ~f:(fun () ->","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"             ( decode_field (module Snark_params.Tick) field","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"             , decode_field (module Snark_params.Tock) scalar ) ) )","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"","counters":[]},{"line":"let compute_public_key ~hd_index =","counters":[]},{"line":"  let prog, args =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    ( \"python3\"","counters":[]},{"line":"    , [ \"-m\" ^ hardware_wallet_script","counters":[]},{"line":"      ; \"--request=publickey\"","counters":[]},{"line":"      ; \"--nonce=\" ^ Mina_numbers.Hd_index.to_string hd_index","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"      ] )","counters":[]},{"line":"  in","counters":[]},{"line":"  Process.run ~prog ~args ()","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"  |> Deferred.Result.map_error ~f:report_process_error","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"  |> Deferred.map ~f:(Result.bind ~f:decode_public_key)","counters":[]},{"line":"","counters":[]},{"line":"let sign ~hd_index ~public_key ~user_command_payload :","counters":[]},{"line":"    (Signed_command.With_valid_signature.t, string) Deferred.Result.t =","counters":[]},{"line":"  let open Deferred.Result.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let input =","counters":[]},{"line":"    Transaction_union_payload.to_input_legacy","counters":[]},{"line":"    @@ Transaction_union_payload.of_user_command_payload user_command_payload","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"  in","counters":[]},{"line":"  let fields = Random_oracle.Legacy.pack_input input in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let messages =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Array.map fields ~f:(fun field -> Tick.Field.to_string field)","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"  in","counters":[]},{"line":"  if Array.length messages <> 2 then","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":16,"col_end":16,"count":0}]},{"line":"    Deferred.Result.fail \"Malformed user command\"","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  else","counters":[]},{"line":"    let prog, args =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ( \"python3\"","counters":[]},{"line":"      , [ \"-m\" ^ hardware_wallet_script","counters":[]},{"line":"        ; \"--request=sign\"","counters":[]},{"line":"        ; \"--msgx=\" ^ messages.(0)","counters":[]},{"line":"        ; \"--msgm=\" ^ messages.(1)","counters":[]},{"line":"        ; \"--nonce=\" ^ Mina_numbers.Hd_index.to_string hd_index","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"        ] )","counters":[]},{"line":"    in","counters":[]},{"line":"    let%bind signature_str =","counters":[]},{"line":"      Process.run ~prog ~args ()","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"      |> Deferred.Result.map_error ~f:report_process_error","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"    in","counters":[]},{"line":"    let%bind signature = decode_signature signature_str |> Deferred.return in","counters":[{"col_start":40,"col_end":40,"count":0},{"col_start":73,"col_end":73,"count":0}]},{"line":"    match","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Signed_command.create_with_signature_checked signature","counters":[]},{"line":"        (Public_key.compress public_key)","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"        user_command_payload","counters":[]},{"line":"    with","counters":[]},{"line":"    | Some signed_command ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        return signed_command","counters":[]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let%bind computed_public_key = compute_public_key ~hd_index in","counters":[]},{"line":"        if Public_key.equal computed_public_key public_key then","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Deferred.Result.fail","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            \"Failed to verify signature returned by hardware wallet.\"","counters":[]},{"line":"        else","counters":[]},{"line":"          Deferred.Result.fail","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            \"The cached public doesn't match the one that is computed by the \\","counters":[]},{"line":"             hardware wallet. Possible reason could be you are using a \\","counters":[]},{"line":"             different hardware wallet or you reinitialized your hardware \\","counters":[]},{"line":"             wallet using a different seed. If you want to use your new \\","counters":[]},{"line":"             ledger, please first create an account by 'coda account \\","counters":[]},{"line":"             create-hd' command\"","counters":[]},{"line":"","counters":[]},{"line":"let write_exn ~hd_index ~index_path : unit Deferred.t =","counters":[]},{"line":"  let%bind index_file = Writer.open_file index_path in","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"  Writer.write_line index_file (Mina_numbers.Hd_index.to_string hd_index) ;","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"  Writer.close index_file","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":24,"col_end":24,"count":2}]}]}