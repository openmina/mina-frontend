{"filename":"src/lib/snark_work_lib/work.ml","lines":[{"line":"(* TODO: remove type generalizations #2594 *)","counters":[]},{"line":"","counters":[{"col_start":0,"col_end":0,"count":1}]},{"line":"open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"module Single = struct","counters":[]},{"line":"  module Spec = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      [@@@no_toplevel_latest_type]","counters":[]},{"line":"","counters":[]},{"line":"      module V2 = struct","counters":[]},{"line":"        type ('witness, 'ledger_proof) t =","counters":[{"col_start":8,"col_end":8,"count":4},{"col_start":39,"col_end":39,"count":5}]},{"line":"          | Transition of Transaction_snark.Statement.Stable.V2.t * 'witness","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":64,"col_end":64,"count":0},{"col_start":75,"col_end":75,"count":0}]},{"line":"          | Merge of","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              Transaction_snark.Statement.Stable.V2.t","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"              * 'ledger_proof","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"              * 'ledger_proof","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"        [@@deriving sexp, to_yojson]","counters":[{"col_start":35,"col_end":35,"count":9}]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    type ('witness, 'ledger_proof) t =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"          ('witness, 'ledger_proof) Stable.Latest.t =","counters":[]},{"line":"      | Transition of Transaction_snark.Statement.t * 'witness","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":50,"col_end":50,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"      | Merge of Transaction_snark.Statement.t * 'ledger_proof * 'ledger_proof","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":61,"col_end":61,"count":0},{"col_start":77,"col_end":77,"count":0}]},{"line":"    [@@deriving sexp, to_yojson]","counters":[]},{"line":"","counters":[]},{"line":"    let witness (t : (_, _) t) =","counters":[]},{"line":"      match t with Transition (_, witness) -> Some witness | Merge _ -> None","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"","counters":[]},{"line":"    let statement = function Transition (s, _) -> s | Merge (s, _, _) -> s","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"","counters":[]},{"line":"    let gen :","counters":[]},{"line":"           'witness Quickcheck.Generator.t","counters":[]},{"line":"        -> 'ledger_proof Quickcheck.Generator.t","counters":[]},{"line":"        -> ('witness, 'ledger_proof) t Quickcheck.Generator.t =","counters":[]},{"line":"     fun gen_witness gen_proof ->","counters":[]},{"line":"      let open Quickcheck.Generator in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let gen_transition =","counters":[]},{"line":"        let open Let_syntax in","counters":[]},{"line":"        let%bind statement = Transaction_snark.Statement.gen in","counters":[]},{"line":"        let%map witness = gen_witness in","counters":[]},{"line":"        Transition (statement, witness)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      in","counters":[]},{"line":"      let gen_merge =","counters":[]},{"line":"        let open Let_syntax in","counters":[]},{"line":"        let%bind statement = Transaction_snark.Statement.gen in","counters":[]},{"line":"        let%map p1, p2 = tuple2 gen_proof gen_proof in","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"        Merge (statement, p1, p2)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      in","counters":[]},{"line":"      union [ gen_transition; gen_merge ]","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Spec = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    [@@@no_toplevel_latest_type]","counters":[]},{"line":"","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type 'single t =","counters":[{"col_start":6,"col_end":6,"count":3},{"col_start":19,"col_end":19,"count":4}]},{"line":"        { instances : 'single One_or_two.Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"        ; fee : Currency.Fee.Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":12,"col_end":12,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"        }","counters":[]},{"line":"      [@@deriving fields, sexp, to_yojson]","counters":[{"col_start":41,"col_end":41,"count":7}]},{"line":"","counters":[]},{"line":"      let to_latest single_latest { instances; fee } =","counters":[]},{"line":"        { instances = One_or_two.Stable.V1.to_latest single_latest instances","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"        ; fee","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"      let of_latest single_latest { instances; fee } =","counters":[]},{"line":"        let open Result.Let_syntax in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let%map instances =","counters":[]},{"line":"          One_or_two.Stable.V1.of_latest single_latest instances","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"        in","counters":[]},{"line":"        { instances; fee }","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  type 'single t = 'single Stable.Latest.t =","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"    { instances : 'single One_or_two.t; fee : Currency.Fee.t }","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":14,"col_end":14,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":42,"col_end":42,"count":0},{"col_start":46,"col_end":46,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"  [@@deriving fields, sexp, to_yojson]","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Result = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type ('spec, 'single) t =","counters":[{"col_start":6,"col_end":6,"count":1},{"col_start":28,"col_end":28,"count":5}]},{"line":"        { proofs : 'single One_or_two.Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        ; metrics :","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (Core.Time.Stable.Span.V1.t * [ `Transition | `Merge ])","counters":[]},{"line":"            One_or_two.Stable.V1.t","counters":[]},{"line":"        ; spec : 'spec","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        ; prover : Signature_lib.Public_key.Compressed.Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        }","counters":[]},{"line":"      [@@deriving fields]","counters":[{"col_start":24,"col_end":24,"count":3}]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}