{"filename":"src/lib/mina_base/sparse_ledger_base.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Mina_base_import","counters":[]},{"line":"open Snark_params.Tick","counters":[]},{"line":"","counters":[]},{"line":"[%%versioned","counters":[]},{"line":"module Stable = struct","counters":[]},{"line":"  module V2 = struct","counters":[]},{"line":"    type t =","counters":[{"col_start":4,"col_end":4,"count":2},{"col_start":9,"col_end":9,"count":1}]},{"line":"      ( Ledger_hash.Stable.V1.t","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":8,"col_end":8,"count":0}]},{"line":"      , Account_id.Stable.V2.t","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      , Account.Stable.V2.t )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      Sparse_ledger_lib.Sparse_ledger.T.Stable.V2.t","counters":[]},{"line":"    [@@deriving yojson, sexp]","counters":[{"col_start":28,"col_end":28,"count":5}]},{"line":"","counters":[]},{"line":"    let to_latest = Fn.id","counters":[]},{"line":"  end","counters":[]},{"line":"end]","counters":[]},{"line":"","counters":[]},{"line":"type sparse_ledger = t [@@deriving sexp, to_yojson]","counters":[{"col_start":0,"col_end":0,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"","counters":[]},{"line":"module Hash = struct","counters":[]},{"line":"  include Ledger_hash","counters":[]},{"line":"","counters":[]},{"line":"  let merge = Ledger_hash.merge","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Account = struct","counters":[]},{"line":"  include Account","counters":[]},{"line":"","counters":[]},{"line":"  let data_hash = Fn.compose Ledger_hash.of_digest Account.digest","counters":[{"col_start":27,"col_end":27,"count":1}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Global_state = struct","counters":[]},{"line":"  type t =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    { ledger : sparse_ledger","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":11,"col_end":11,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"    ; fee_excess : Currency.Amount.Signed.t","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"    ; supply_increase : Currency.Amount.Signed.t","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"    ; protocol_state : Zkapp_precondition.Protocol_state.View.t","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"    }","counters":[]},{"line":"  [@@deriving sexp, to_yojson]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module M = Sparse_ledger_lib.Sparse_ledger.Make (Hash) (Account_id) (Account)","counters":[]},{"line":"","counters":[]},{"line":"type account_state = [ `Added | `Existed ] [@@deriving equal]","counters":[{"col_start":0,"col_end":0,"count":0}]},{"line":"","counters":[]},{"line":"(** Create a new 'empty' ledger.","counters":[]},{"line":"    This ledger has an invalid root hash, and cannot be used except as a","counters":[]},{"line":"    placeholder.","counters":[]},{"line":"*)","counters":[]},{"line":"let empty ~depth () = M.of_hash ~depth Outside_hash_image.t","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"module L = struct","counters":[]},{"line":"  type t = M.t ref","counters":[]},{"line":"","counters":[]},{"line":"  type location = int","counters":[]},{"line":"","counters":[]},{"line":"  let get : t -> location -> Account.t option =","counters":[]},{"line":"   fun t loc ->","counters":[]},{"line":"    Option.try_with (fun () ->","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"        let account = M.get_exn !t loc in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        if Public_key.Compressed.(equal empty account.public_key) then None","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"        else Some account )","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"    |> Option.bind ~f:Fn.id","counters":[]},{"line":"","counters":[]},{"line":"  let location_of_account : t -> Account_id.t -> location option =","counters":[]},{"line":"   fun t id ->","counters":[]},{"line":"    try","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let loc = M.find_index_exn !t id in","counters":[]},{"line":"      let account = M.get_exn !t loc in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      if Public_key.Compressed.(equal empty account.public_key) then None","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"      else Some loc","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"    with _ -> None","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"  let set : t -> location -> Account.t -> unit =","counters":[]},{"line":"   fun t loc a -> t := M.set_exn !t loc a","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"","counters":[]},{"line":"  let get_or_create_exn :","counters":[]},{"line":"      t -> Account_id.t -> account_state * Account.t * location =","counters":[]},{"line":"   fun t id ->","counters":[]},{"line":"    let loc = M.find_index_exn !t id in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let account = M.get_exn !t loc in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    if Public_key.Compressed.(equal empty account.public_key) then (","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"      let public_key = Account_id.public_key id in","counters":[]},{"line":"      let account' : Account.t =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { account with","counters":[]},{"line":"          delegate = Some public_key","counters":[]},{"line":"        ; public_key","counters":[]},{"line":"        ; token_id = Account_id.token_id id","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"        }","counters":[]},{"line":"      in","counters":[]},{"line":"      set t loc account' ;","counters":[]},{"line":"      (`Added, account', loc) )","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    else (`Existed, account, loc)","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"  let get_or_create t id = Or_error.try_with (fun () -> get_or_create_exn t id)","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"","counters":[]},{"line":"  let get_or_create_account :","counters":[]},{"line":"      t -> Account_id.t -> Account.t -> (account_state * location) Or_error.t =","counters":[]},{"line":"   fun t id to_set ->","counters":[]},{"line":"    Or_error.try_with (fun () ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        let loc = M.find_index_exn !t id in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let a = M.get_exn !t loc in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        if Public_key.Compressed.(equal empty a.public_key) then (","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"          set t loc to_set ;","counters":[]},{"line":"          (`Added, loc) )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        else (`Existed, loc) )","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"  let create_new_account t id to_set =","counters":[]},{"line":"    get_or_create_account t id to_set |> Or_error.map ~f:ignore","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"","counters":[]},{"line":"  let remove_accounts_exn : t -> Account_id.t list -> unit =","counters":[]},{"line":"   fun _t _xs -> failwith \"remove_accounts_exn: not implemented\"","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"","counters":[]},{"line":"  let merkle_root : t -> Ledger_hash.t = fun t -> M.merkle_root !t","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"","counters":[]},{"line":"  let with_ledger : depth:int -> f:(t -> 'a) -> 'a =","counters":[]},{"line":"   fun ~depth:_ ~f:_ -> failwith \"with_ledger: not implemented\"","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"","counters":[]},{"line":"  (** Create a new ledger mask 'on top of' the given ledger.","counters":[]},{"line":"","counters":[]},{"line":"      Warning: For technical reasons, this mask cannot be applied directly to","counters":[]},{"line":"      the parent ledger; instead, use","counters":[]},{"line":"      [apply_mask parent_ledger ~masked:this_ledger] to update the parent","counters":[]},{"line":"      ledger as necessary.","counters":[]},{"line":"  *)","counters":[]},{"line":"  let create_masked t = ref !t","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"","counters":[]},{"line":"  (** [apply_mask ledger ~masked] applies any updates in [masked] to the ledger","counters":[]},{"line":"      [ledger]. [masked] should be created by calling [create_masked ledger].","counters":[]},{"line":"","counters":[]},{"line":"      Warning: This function may behave unexpectedly if [ledger] was modified","counters":[]},{"line":"      after calling [create_masked], or the given [ledger] was not used to","counters":[]},{"line":"      create [masked].","counters":[]},{"line":"  *)","counters":[]},{"line":"  let apply_mask t ~masked = t := !masked","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"  (** Create a new 'empty' ledger.","counters":[]},{"line":"      This ledger has an invalid root hash, and cannot be used except as a","counters":[]},{"line":"      placeholder.","counters":[]},{"line":"  *)","counters":[]},{"line":"  let empty ~depth () = ref (empty ~depth ())","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"[%%define_locally","counters":[]},{"line":"M.","counters":[]},{"line":"  ( of_hash","counters":[]},{"line":"  , to_yojson","counters":[]},{"line":"  , get_exn","counters":[]},{"line":"  , path_exn","counters":[]},{"line":"  , set_exn","counters":[]},{"line":"  , find_index_exn","counters":[]},{"line":"  , add_path","counters":[]},{"line":"  , merkle_root","counters":[]},{"line":"  , iteri )]","counters":[]},{"line":"","counters":[]},{"line":"let of_root ~depth (h : Ledger_hash.t) =","counters":[]},{"line":"  of_hash ~depth (Ledger_hash.of_digest (h :> Random_oracle.Digest.t))","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"","counters":[]},{"line":"let get_or_initialize_exn account_id t idx =","counters":[]},{"line":"  let account = get_exn t idx in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  if Public_key.Compressed.(equal empty account.public_key) then","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"    let public_key = Account_id.public_key account_id in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let token_id = Account_id.token_id account_id in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let delegate =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (* Only allow delegation if this account is for the default token. *)","counters":[]},{"line":"      if Token_id.(equal default) token_id then Some public_key else None","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":48,"col_end":48,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"    in","counters":[]},{"line":"    ( `Added","counters":[]},{"line":"    , { account with","counters":[]},{"line":"        delegate","counters":[]},{"line":"      ; public_key","counters":[]},{"line":"      ; token_id = Account_id.token_id account_id","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"      } )","counters":[]},{"line":"  else (`Existed, account)","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"","counters":[]},{"line":"let has_locked_tokens_exn ~global_slot ~account_id t =","counters":[]},{"line":"  let idx = find_index_exn t account_id in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let _, account = get_or_initialize_exn account_id t idx in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  Account.has_locked_tokens ~global_slot account","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let merkle_root t = Ledger_hash.of_hash (merkle_root t :> Random_oracle.Digest.t)","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"","counters":[]},{"line":"let depth t = M.depth t","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"","counters":[]},{"line":"let handler t =","counters":[]},{"line":"  let ledger = ref t in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let path_exn idx =","counters":[]},{"line":"    List.map (path_exn !ledger idx) ~f:(function `Left h -> h | `Right h -> h)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":49,"col_end":49,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"  in","counters":[]},{"line":"  stage (fun (With { request; respond }) ->","counters":[]},{"line":"      match request with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Ledger_hash.Get_element idx ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let elt = get_exn !ledger idx in","counters":[]},{"line":"          let path = (path_exn idx :> Random_oracle.Digest.t list) in","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"          respond (Provide (elt, path))","counters":[]},{"line":"      | Ledger_hash.Get_path idx ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let path = (path_exn idx :> Random_oracle.Digest.t list) in","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"          respond (Provide path)","counters":[]},{"line":"      | Ledger_hash.Set (idx, account) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ledger := set_exn !ledger idx account ;","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"          respond (Provide ())","counters":[]},{"line":"      | Ledger_hash.Find_index pk ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let index = find_index_exn !ledger pk in","counters":[]},{"line":"          respond (Provide index)","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"      | _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          unhandled )","counters":[{"col_start":20,"col_end":20,"count":1}]}]}