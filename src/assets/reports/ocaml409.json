{"filename":"src/lib/ppx_dhall_type/dhall_type.ml","lines":[{"line":"(* dhall_type.ml -- derive a Dhall type from an OCaml type *)","counters":[]},{"line":"","counters":[]},{"line":"open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"(* based on https://github.com/dhall-lang/dhall-lang/blob/master/standard/type-inference.md *)","counters":[]},{"line":"type t =","counters":[]},{"line":"  | Bool","counters":[]},{"line":"  | Natural","counters":[]},{"line":"  | Text","counters":[]},{"line":"  | Integer","counters":[]},{"line":"  | Double","counters":[]},{"line":"  | Optional of t","counters":[]},{"line":"  | List of t","counters":[]},{"line":"  | Record of (string * t) list","counters":[]},{"line":"  | Union of (string * t option) list","counters":[]},{"line":"  | Function of t * t","counters":[]},{"line":"","counters":[]},{"line":"let rec to_string = function","counters":[]},{"line":"  | Bool ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      \"Bool\"","counters":[]},{"line":"  | Integer ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      \"Integer\"","counters":[]},{"line":"  | Natural ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      \"Natural\"","counters":[]},{"line":"  | Text ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      \"Text\"","counters":[]},{"line":"  | Double ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      \"Double\"","counters":[]},{"line":"  | Optional t ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      \"Optional (\" ^ to_string t ^ \")\"","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"  | List t ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      \"List (\" ^ to_string t ^ \")\"","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"  | Record fields ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let field_to_string (nm, ty) = nm ^ \" : \" ^ to_string ty in","counters":[{"col_start":37,"col_end":37,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"      let formatted_fields =","counters":[]},{"line":"        String.concat ~sep:\", \" (List.map fields ~f:field_to_string)","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"      in","counters":[]},{"line":"      \"{ \" ^ formatted_fields ^ \" }\"","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  | Union alts ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let alt_to_string (nm, ty_opt) =","counters":[]},{"line":"        match ty_opt with None -> nm | Some ty -> nm ^ \" : \" ^ to_string ty","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"      in","counters":[]},{"line":"      let formatted_alts =","counters":[]},{"line":"        String.concat ~sep:\" | \" (List.map alts ~f:alt_to_string)","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"      in","counters":[]},{"line":"      \"< \" ^ formatted_alts ^ \" >\"","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  | Function (t_in, t_out) ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      to_string t_in ^ \" -> \" ^ to_string t_out","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":40,"col_end":40,"count":0}]}]}