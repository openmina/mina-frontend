{"filename":"src/lib/block_producer/block_producer.ml","lines":[{"line":"open Core","counters":[]},{"line":"open Async","counters":[]},{"line":"open Pipe_lib","counters":[]},{"line":"open Mina_base","counters":[]},{"line":"open Mina_transaction","counters":[]},{"line":"open Mina_state","counters":[]},{"line":"open Mina_block","counters":[]},{"line":"","counters":[]},{"line":"module type CONTEXT = sig","counters":[]},{"line":"  val logger : Logger.t","counters":[]},{"line":"","counters":[]},{"line":"  val precomputed_values : Precomputed_values.t","counters":[]},{"line":"","counters":[]},{"line":"  val constraint_constants : Genesis_constants.Constraint_constants.t","counters":[]},{"line":"","counters":[]},{"line":"  val consensus_constants : Consensus.Constants.t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"type Structured_log_events.t += Block_produced","counters":[]},{"line":"  [@@deriving register_event { msg = \"Successfully produced a new block\" }]","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":27,"col_end":27,"count":3}]},{"line":"","counters":[]},{"line":"module Singleton_supervisor : sig","counters":[]},{"line":"  type ('data, 'a) t","counters":[]},{"line":"","counters":[]},{"line":"  val create :","counters":[]},{"line":"    task:(unit Ivar.t -> 'data -> ('a, unit) Interruptible.t) -> ('data, 'a) t","counters":[]},{"line":"","counters":[]},{"line":"  val cancel : (_, _) t -> unit","counters":[]},{"line":"","counters":[]},{"line":"  val dispatch : ('data, 'a) t -> 'data -> ('a, unit) Interruptible.t","counters":[]},{"line":"end = struct","counters":[]},{"line":"  type ('data, 'a) t =","counters":[]},{"line":"    { mutable task : (unit Ivar.t * ('a, unit) Interruptible.t) option","counters":[]},{"line":"    ; f : unit Ivar.t -> 'data -> ('a, unit) Interruptible.t","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let create ~task = { task = None; f = task }","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"","counters":[]},{"line":"  let cancel t =","counters":[]},{"line":"    match t.task with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Some (ivar, _) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        if Ivar.is_full ivar then","counters":[]},{"line":"          [%log' error (Logger.create ())] \"Ivar.fill bug is here MMM !\" ;","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"        Ivar.fill ivar () ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        t.task <- None","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ()","counters":[]},{"line":"","counters":[]},{"line":"  let dispatch t data =","counters":[]},{"line":"    cancel t ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let ivar = Ivar.create () in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let interruptible =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let open Interruptible.Let_syntax in","counters":[]},{"line":"      t.f ivar data","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      >>| fun x ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      t.task <- None ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      x","counters":[]},{"line":"    in","counters":[]},{"line":"    t.task <- Some (ivar, interruptible) ;","counters":[]},{"line":"    interruptible","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let time_to_ms = Fn.compose Block_time.Span.to_ms Block_time.to_span_since_epoch","counters":[{"col_start":26,"col_end":26,"count":1}]},{"line":"","counters":[]},{"line":"let time_of_ms = Fn.compose Block_time.of_span_since_epoch Block_time.Span.of_ms","counters":[{"col_start":26,"col_end":26,"count":1}]},{"line":"","counters":[]},{"line":"let lift_sync f =","counters":[]},{"line":"  Interruptible.uninterruptible","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    (Deferred.create (fun ivar ->","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"         if Ivar.is_full ivar then","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"           [%log' error (Logger.create ())] \"Ivar.fill bug is here NNN !\" ;","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"         Ivar.fill ivar (f ()) ) )","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"module Singleton_scheduler : sig","counters":[]},{"line":"  type t","counters":[]},{"line":"","counters":[]},{"line":"  val create : Block_time.Controller.t -> t","counters":[]},{"line":"","counters":[]},{"line":"  (** If you reschedule when already scheduled, take the min of the two schedulings *)","counters":[]},{"line":"  val schedule : t -> Block_time.t -> f:(unit -> unit) -> unit","counters":[]},{"line":"end = struct","counters":[]},{"line":"  type t =","counters":[]},{"line":"    { mutable timeout : unit Block_time.Timeout.t option","counters":[]},{"line":"    ; time_controller : Block_time.Controller.t","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let create time_controller = { time_controller; timeout = None }","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"","counters":[]},{"line":"  let cancel t =","counters":[]},{"line":"    match t.timeout with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Some timeout ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Block_time.Timeout.cancel t.time_controller timeout () ;","counters":[]},{"line":"        t.timeout <- None","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ()","counters":[]},{"line":"","counters":[]},{"line":"  let schedule t time ~f =","counters":[]},{"line":"    let remaining_time =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Option.map t.timeout ~f:Block_time.Timeout.remaining_time","counters":[]},{"line":"    in","counters":[]},{"line":"    cancel t ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let span_till_time =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Block_time.diff time (Block_time.now t.time_controller)","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"    in","counters":[]},{"line":"    let wait_span =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      match remaining_time with","counters":[]},{"line":"      | Some remaining","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        when Block_time.Span.(remaining > Block_time.Span.of_ms Int64.zero) ->","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"          let min a b = if Block_time.Span.(a < b) then a else b in","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":56,"col_end":56,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"          min remaining span_till_time","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"      | None | Some _ ->","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"          span_till_time","counters":[]},{"line":"    in","counters":[]},{"line":"    let timeout =","counters":[]},{"line":"      Block_time.Timeout.create t.time_controller wait_span ~f:(fun _ ->","counters":[]},{"line":"          t.timeout <- None ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          f () )","counters":[]},{"line":"    in","counters":[]},{"line":"    t.timeout <- Some timeout","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(** Sends an error to the reporting service containing as many failed transactions as we can fit. *)","counters":[]},{"line":"let report_transaction_inclusion_failures ~logger failed_txns =","counters":[]},{"line":"  let num_failures = List.length failed_txns in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let count_size = Fn.compose String.length Yojson.Safe.to_string in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let wrap_error failed_txns_json =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    `Assoc","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      [ ( \"message\"","counters":[]},{"line":"        , `String","counters":[]},{"line":"            \"Some transactions failed to apply to the ledger when creating the \\","counters":[]},{"line":"             staged ledger diff\" )","counters":[]},{"line":"      ; (\"num_failures\", `Int num_failures)","counters":[]},{"line":"      ; (\"sampled_failures\", failed_txns_json)","counters":[]},{"line":"      ]","counters":[]},{"line":"  in","counters":[]},{"line":"  let rec generate_errors failures available_bytes =","counters":[]},{"line":"    if available_bytes <= 0 then []","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"    else","counters":[]},{"line":"      match failures with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | [] ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          []","counters":[]},{"line":"      | (txn, error) :: remaining_failures ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let element =","counters":[]},{"line":"            `Assoc","counters":[]},{"line":"              [ (\"transaction\", User_command.Valid.to_yojson txn)","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"              ; (\"error\", Error_json.error_to_yojson error)","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"              ]","counters":[]},{"line":"          in","counters":[]},{"line":"          let element_size = count_size element in","counters":[]},{"line":"          (* subtract an additional byte for each element here to account for commas *)","counters":[]},{"line":"          element","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          :: generate_errors remaining_failures","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"               (available_bytes - element_size - 1)","counters":[]},{"line":"  in","counters":[]},{"line":"  Node_error_service.send_dynamic_report ~logger","counters":[]},{"line":"    ~generate_error:(fun available_bytes ->","counters":[]},{"line":"      (* subtract 2 bytes to account for empty string *)","counters":[]},{"line":"      let base_error_size = count_size (wrap_error (`String \"\")) - 2 in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"      (* subtract 2 bytes to account for list brackets that wrap failed_txns *)","counters":[]},{"line":"      let leftover_bytes = available_bytes - base_error_size - 2 in","counters":[]},{"line":"      wrap_error (`List (generate_errors failed_txns leftover_bytes)) )","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"let generate_next_state ~constraint_constants ~previous_protocol_state","counters":[]},{"line":"    ~time_controller ~staged_ledger ~transactions ~get_completed_work ~logger","counters":[]},{"line":"    ~(block_data : Consensus.Data.Block_data.t) ~winner_pk ~scheduled_time","counters":[]},{"line":"    ~log_block_creation ~block_reward_threshold =","counters":[]},{"line":"  let open Interruptible.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let previous_protocol_state_body_hash =","counters":[]},{"line":"    Protocol_state.body previous_protocol_state |> Protocol_state.Body.hash","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"  in","counters":[]},{"line":"  let previous_protocol_state_hash =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    (Protocol_state.hashes_with_body","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"       ~body_hash:previous_protocol_state_body_hash previous_protocol_state )","counters":[]},{"line":"      .state_hash","counters":[]},{"line":"  in","counters":[]},{"line":"  let previous_state_view =","counters":[]},{"line":"    Protocol_state.body previous_protocol_state","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"    |> Mina_state.Protocol_state.Body.view","counters":[]},{"line":"  in","counters":[]},{"line":"  let supercharge_coinbase =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    let epoch_ledger = Consensus.Data.Block_data.epoch_ledger block_data in","counters":[]},{"line":"    let global_slot =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Consensus.Data.Block_data.global_slot_since_genesis block_data","counters":[]},{"line":"    in","counters":[]},{"line":"    Staged_ledger.can_apply_supercharged_coinbase_exn ~winner:winner_pk","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ~epoch_ledger ~global_slot","counters":[]},{"line":"  in","counters":[]},{"line":"  let%bind res =","counters":[]},{"line":"    Interruptible.uninterruptible","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"      (let open Deferred.Let_syntax in","counters":[]},{"line":"      let coinbase_receiver =","counters":[]},{"line":"        Consensus.Data.Block_data.coinbase_receiver block_data","counters":[]},{"line":"      in","counters":[]},{"line":"","counters":[]},{"line":"      let diff =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        O1trace.sync_thread \"create_staged_ledger_diff\" (fun () ->","counters":[]},{"line":"            (* TODO: handle transaction inclusion failures here *)","counters":[]},{"line":"            let diff_result =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Staged_ledger.create_diff ~constraint_constants staged_ledger","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"                ~coinbase_receiver ~logger","counters":[]},{"line":"                ~current_state_view:previous_state_view","counters":[]},{"line":"                ~transactions_by_fee:transactions ~get_completed_work","counters":[]},{"line":"                ~log_block_creation ~supercharge_coinbase","counters":[]},{"line":"              |> Result.map ~f:(fun (diff, failed_txns) ->","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                     if not (List.is_empty failed_txns) then","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"                       don't_wait_for","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"                         (report_transaction_inclusion_failures ~logger","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"                            failed_txns ) ;","counters":[]},{"line":"                     diff )","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"              |> Result.map_error ~f:(fun err ->","counters":[]},{"line":"                     Staged_ledger.Staged_ledger_error.Pre_diff err )","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"            in","counters":[]},{"line":"            match (diff_result, block_reward_threshold) with","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            | Ok diff, Some threshold ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                let net_return =","counters":[]},{"line":"                  Option.value ~default:Currency.Amount.zero","counters":[]},{"line":"                    (Staged_ledger_diff.net_return ~constraint_constants","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"                       ~supercharge_coinbase","counters":[]},{"line":"                       (Staged_ledger_diff.forget diff) )","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"                in","counters":[]},{"line":"                if Currency.Amount.(net_return >= threshold) then diff_result","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"                else (","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                  [%log info]","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                    \"Block reward $reward is less than the min-block-reward \\","counters":[]},{"line":"                     $threshold, creating empty block\"","counters":[]},{"line":"                    ~metadata:","counters":[]},{"line":"                      [ (\"threshold\", Currency.Amount.to_yojson threshold)","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"                      ; (\"reward\", Currency.Amount.to_yojson net_return)","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"                      ] ;","counters":[]},{"line":"                  Ok","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    Staged_ledger_diff.With_valid_signatures_and_proofs","counters":[]},{"line":"                    .empty_diff )","counters":[]},{"line":"            | _ ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                diff_result )","counters":[]},{"line":"      in","counters":[]},{"line":"      match%map","counters":[]},{"line":"        let%bind.Deferred.Result diff = return diff in","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"        Staged_ledger.apply_diff_unchecked staged_ledger ~constraint_constants","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          diff ~logger ~current_state_view:previous_state_view","counters":[]},{"line":"          ~state_and_body_hash:","counters":[]},{"line":"            (previous_protocol_state_hash, previous_protocol_state_body_hash)","counters":[]},{"line":"          ~coinbase_receiver ~supercharge_coinbase","counters":[]},{"line":"      with","counters":[]},{"line":"      | Ok","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ( `Hash_after_applying next_staged_ledger_hash","counters":[]},{"line":"          , `Ledger_proof ledger_proof_opt","counters":[]},{"line":"          , `Staged_ledger transitioned_staged_ledger","counters":[]},{"line":"          , `Pending_coinbase_update (is_new_stack, pending_coinbase_update) )","counters":[]},{"line":"        ->","counters":[]},{"line":"          (*staged_ledger remains unchanged and transitioned_staged_ledger is discarded because the external transtion created out of this diff will be applied in Transition_frontier*)","counters":[]},{"line":"          ignore","counters":[]},{"line":"          @@ Mina_ledger.Ledger.unregister_mask_exn ~loc:__LOC__","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"               (Staged_ledger.ledger transitioned_staged_ledger) ;","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"          Some","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ( (match diff with Ok diff -> diff | Error _ -> assert false)","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"            , next_staged_ledger_hash","counters":[]},{"line":"            , ledger_proof_opt","counters":[]},{"line":"            , is_new_stack","counters":[]},{"line":"            , pending_coinbase_update )","counters":[]},{"line":"      | Error (Staged_ledger.Staged_ledger_error.Unexpected e) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          [%log error] \"Failed to apply the diff: $error\"","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"            ~metadata:[ (\"error\", Error_json.error_to_yojson e) ] ;","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"          None","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"      | Error e ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ( match diff with","counters":[]},{"line":"          | Ok diff ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              [%log error]","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                ~metadata:","counters":[]},{"line":"                  [ ( \"error\"","counters":[]},{"line":"                    , `String (Staged_ledger.Staged_ledger_error.to_string e) )","counters":[{"col_start":73,"col_end":73,"count":0}]},{"line":"                  ; ( \"diff\"","counters":[]},{"line":"                    , Staged_ledger_diff.With_valid_signatures_and_proofs","counters":[]},{"line":"                      .to_yojson diff )","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                  ]","counters":[]},{"line":"                \"Error applying the diff $diff: $error\"","counters":[]},{"line":"          | Error e ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              [%log error] \"Error building the diff: $error\"","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                ~metadata:","counters":[]},{"line":"                  [ ( \"error\"","counters":[]},{"line":"                    , `String (Staged_ledger.Staged_ledger_error.to_string e) )","counters":[{"col_start":73,"col_end":73,"count":0}]},{"line":"                  ] ) ;","counters":[]},{"line":"          None)","counters":[]},{"line":"  in","counters":[]},{"line":"  match res with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | None ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Interruptible.return None","counters":[]},{"line":"  | Some","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ( diff","counters":[]},{"line":"      , next_staged_ledger_hash","counters":[]},{"line":"      , ledger_proof_opt","counters":[]},{"line":"      , is_new_stack","counters":[]},{"line":"      , pending_coinbase_update ) ->","counters":[]},{"line":"      let%bind protocol_state, consensus_transition_data =","counters":[]},{"line":"        lift_sync (fun () ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"            let previous_ledger_hash =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              previous_protocol_state |> Protocol_state.blockchain_state","counters":[{"col_start":71,"col_end":71,"count":0}]},{"line":"              |> Blockchain_state.snarked_ledger_hash","counters":[]},{"line":"            in","counters":[]},{"line":"            let next_registers =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              match ledger_proof_opt with","counters":[]},{"line":"              | Some (proof, _) ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  { ( Ledger_proof.statement proof","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"                    |> Ledger_proof.statement_target )","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                    with","counters":[]},{"line":"                    pending_coinbase_stack = ()","counters":[]},{"line":"                  }","counters":[]},{"line":"              | None ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  previous_protocol_state |> Protocol_state.blockchain_state","counters":[{"col_start":75,"col_end":75,"count":0}]},{"line":"                  |> Blockchain_state.registers","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"            in","counters":[]},{"line":"            let genesis_ledger_hash =","counters":[]},{"line":"              previous_protocol_state |> Protocol_state.blockchain_state","counters":[{"col_start":71,"col_end":71,"count":0}]},{"line":"              |> Blockchain_state.genesis_ledger_hash","counters":[]},{"line":"            in","counters":[]},{"line":"            let supply_increase =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Option.value_map ledger_proof_opt","counters":[]},{"line":"                ~f:(fun (proof, _) ->","counters":[]},{"line":"                  (Ledger_proof.statement proof).supply_increase )","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"                ~default:Currency.Amount.Signed.zero","counters":[]},{"line":"            in","counters":[]},{"line":"            let body_reference =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Staged_ledger_diff.Body.compute_reference","counters":[]},{"line":"                (Body.create @@ Staged_ledger_diff.forget diff)","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"            in","counters":[]},{"line":"            let blockchain_state =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (* We use the time of the beginning of the slot because if things","counters":[]},{"line":"                 are slower than expected, we may have entered the next slot and","counters":[]},{"line":"                 putting the **current** timestamp rather than the expected one","counters":[]},{"line":"                 will screw things up.","counters":[]},{"line":"","counters":[]},{"line":"                 [generate_transition] will log an error if the [current_time]","counters":[]},{"line":"                 has a different slot from the [scheduled_time]","counters":[]},{"line":"              *)","counters":[]},{"line":"              Blockchain_state.create_value ~timestamp:scheduled_time","counters":[]},{"line":"                ~registers:next_registers ~genesis_ledger_hash","counters":[]},{"line":"                ~staged_ledger_hash:next_staged_ledger_hash ~body_reference","counters":[]},{"line":"            in","counters":[]},{"line":"            let current_time =","counters":[]},{"line":"              Block_time.now time_controller","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"              |> Block_time.to_span_since_epoch |> Block_time.Span.to_ms","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"            in","counters":[]},{"line":"            O1trace.sync_thread \"generate_consensus_transition\" (fun () ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"                Consensus_state_hooks.generate_transition","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  ~previous_protocol_state ~blockchain_state ~current_time","counters":[]},{"line":"                  ~block_data ~supercharge_coinbase","counters":[]},{"line":"                  ~snarked_ledger_hash:previous_ledger_hash ~genesis_ledger_hash","counters":[]},{"line":"                  ~supply_increase ~logger ~constraint_constants ) )","counters":[]},{"line":"      in","counters":[]},{"line":"      lift_sync (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          let snark_transition =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            O1trace.sync_thread \"generate_snark_transition\" (fun () ->","counters":[]},{"line":"                Snark_transition.create_value","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  ~blockchain_state:","counters":[]},{"line":"                    (Protocol_state.blockchain_state protocol_state)","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                  ~consensus_transition:consensus_transition_data","counters":[]},{"line":"                  ~pending_coinbase_update () )","counters":[]},{"line":"          in","counters":[]},{"line":"          let internal_transition =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            O1trace.sync_thread \"generate_internal_transition\" (fun () ->","counters":[]},{"line":"                Internal_transition.create ~snark_transition","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  ~prover_state:","counters":[]},{"line":"                    (Consensus.Data.Block_data.prover_state block_data)","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"                  ~staged_ledger_diff:(Staged_ledger_diff.forget diff)","counters":[{"col_start":63,"col_end":63,"count":0}]},{"line":"                  ~ledger_proof:","counters":[]},{"line":"                    (Option.map ledger_proof_opt ~f:(fun (proof, _) -> proof)) )","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"          in","counters":[]},{"line":"          let witness =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            { Pending_coinbase_witness.pending_coinbases =","counters":[]},{"line":"                Staged_ledger.pending_coinbase_collection staged_ledger","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"            ; is_new_stack","counters":[]},{"line":"            }","counters":[]},{"line":"          in","counters":[]},{"line":"          Some (protocol_state, internal_transition, witness) )","counters":[]},{"line":"","counters":[]},{"line":"module Precomputed = struct","counters":[]},{"line":"  type t = Precomputed.t =","counters":[]},{"line":"    { scheduled_time : Block_time.t","counters":[]},{"line":"    ; protocol_state : Protocol_state.value","counters":[]},{"line":"    ; protocol_state_proof : Proof.t","counters":[]},{"line":"    ; staged_ledger_diff : Staged_ledger_diff.t","counters":[]},{"line":"    ; delta_transition_chain_proof :","counters":[]},{"line":"        Frozen_ledger_hash.t * Frozen_ledger_hash.t list","counters":[]},{"line":"    ; accounts_accessed : (int * Account.t) list","counters":[]},{"line":"    ; accounts_created : (Account_id.t * Currency.Fee.t) list","counters":[]},{"line":"    ; tokens_used : (Token_id.t * Account_id.t option) list","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let sexp_of_t = Precomputed.sexp_of_t","counters":[]},{"line":"","counters":[]},{"line":"  let t_of_sexp = Precomputed.t_of_sexp","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let handle_block_production_errors ~logger ~rejected_blocks_logger","counters":[]},{"line":"    ~time_taken:span ~previous_protocol_state ~protocol_state x =","counters":[]},{"line":"  let transition_error_msg_prefix = \"Validation failed: \" in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let transition_reason_for_failure =","counters":[]},{"line":"    \" One possible reason could be a ledger-catchup is triggered before we \\","counters":[]},{"line":"     produce a proof for the produced transition.\"","counters":[]},{"line":"  in","counters":[]},{"line":"  let exn_breadcrumb err =","counters":[]},{"line":"    Error.tag err ~tag:\"Error building breadcrumb from produced transition\"","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":12,"col_end":12,"count":0}]},{"line":"    |> Error.raise","counters":[]},{"line":"  in","counters":[]},{"line":"  let time_metadata =","counters":[]},{"line":"    (\"time\", `Int (Block_time.Span.to_ms span |> Int64.to_int_exn))","counters":[{"col_start":39,"col_end":39,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"  in","counters":[]},{"line":"  let state_metadata =","counters":[]},{"line":"    (\"protocol_state\", Protocol_state.Value.to_yojson protocol_state)","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"  in","counters":[]},{"line":"  match x with","counters":[]},{"line":"  | Ok x ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      return x","counters":[]},{"line":"  | Error","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (`Prover_error","counters":[]},{"line":"        ( err","counters":[]},{"line":"        , ( previous_protocol_state_proof","counters":[]},{"line":"          , internal_transition","counters":[]},{"line":"          , pending_coinbase_witness ) ) ) ->","counters":[]},{"line":"      let msg : (_, unit, string, unit) format4 =","counters":[]},{"line":"        \"Prover failed to prove freshly generated transition: $error\"","counters":[]},{"line":"      in","counters":[]},{"line":"      let metadata =","counters":[]},{"line":"        [ (\"error\", Error_json.error_to_yojson err)","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"        ; (\"prev_state\", Protocol_state.value_to_yojson previous_protocol_state)","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"        ; (\"prev_state_proof\", Proof.to_yojson previous_protocol_state_proof)","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"        ; (\"next_state\", Protocol_state.value_to_yojson protocol_state)","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"        ; ( \"internal_transition\"","counters":[]},{"line":"          , Internal_transition.to_yojson internal_transition )","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"        ; ( \"pending_coinbase_witness\"","counters":[]},{"line":"          , Pending_coinbase_witness.to_yojson pending_coinbase_witness )","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"        ; time_metadata","counters":[]},{"line":"        ]","counters":[]},{"line":"      in","counters":[]},{"line":"      [%log error] ~metadata msg ;","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"      [%log' debug rejected_blocks_logger] ~metadata msg ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"      return ()","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  | Error `Invalid_genesis_protocol_state ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let state_yojson =","counters":[]},{"line":"        Fn.compose State_hash.to_yojson Protocol_state.genesis_state_hash","counters":[]},{"line":"      in","counters":[]},{"line":"      let msg : (_, unit, string, unit) format4 =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        \"Produced transition has invalid genesis state hash\"","counters":[]},{"line":"      in","counters":[]},{"line":"      let metadata =","counters":[]},{"line":"        [ (\"expected\", state_yojson previous_protocol_state)","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"        ; (\"got\", state_yojson protocol_state)","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"        ]","counters":[]},{"line":"      in","counters":[]},{"line":"      [%log warn] ~metadata msg ;","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"      [%log' debug rejected_blocks_logger]","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"        ~metadata:([ time_metadata; state_metadata ] @ metadata)","counters":[]},{"line":"        msg ;","counters":[]},{"line":"      return ()","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  | Error `Already_in_frontier ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let metadata = [ time_metadata; state_metadata ] in","counters":[]},{"line":"      [%log error] ~metadata \"%sproduced transition is already in frontier\"","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"        transition_error_msg_prefix ;","counters":[]},{"line":"      [%log' debug rejected_blocks_logger]","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"        ~metadata \"%sproduced transition is already in frontier\"","counters":[]},{"line":"        transition_error_msg_prefix ;","counters":[]},{"line":"      return ()","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  | Error `Not_selected_over_frontier_root ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let metadata = [ time_metadata; state_metadata ] in","counters":[]},{"line":"      [%log warn] ~metadata","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"        \"%sproduced transition is not selected over the root of transition \\","counters":[]},{"line":"         frontier.%s\"","counters":[]},{"line":"        transition_error_msg_prefix transition_reason_for_failure ;","counters":[]},{"line":"      [%log' debug rejected_blocks_logger]","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"        ~metadata","counters":[]},{"line":"        \"%sproduced transition is not selected over the root of transition \\","counters":[]},{"line":"         frontier.%s\"","counters":[]},{"line":"        transition_error_msg_prefix transition_reason_for_failure ;","counters":[]},{"line":"      return ()","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  | Error `Parent_missing_from_frontier ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let metadata = [ time_metadata; state_metadata ] in","counters":[]},{"line":"      [%log warn] ~metadata","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"        \"%sparent of produced transition is missing from the frontier.%s\"","counters":[]},{"line":"        transition_error_msg_prefix transition_reason_for_failure ;","counters":[]},{"line":"      [%log' debug rejected_blocks_logger]","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"        ~metadata","counters":[]},{"line":"        \"%sparent of produced transition is missing from the frontier.%s\"","counters":[]},{"line":"        transition_error_msg_prefix transition_reason_for_failure ;","counters":[]},{"line":"      return ()","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  | Error (`Fatal_error e) ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      exn_breadcrumb (Error.tag ~tag:\"Fatal error\" (Error.of_exn e))","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"  | Error (`Invalid_staged_ledger_hash e) ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      exn_breadcrumb (Error.tag ~tag:\"Invalid staged ledger hash\" e)","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"  | Error (`Invalid_staged_ledger_diff (e, staged_ledger_diff)) ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let msg : (_, unit, string, unit) format4 =","counters":[]},{"line":"        \"Unable to build breadcrumb from produced transition due to invalid \\","counters":[]},{"line":"         staged ledger diff: $error\"","counters":[]},{"line":"      in","counters":[]},{"line":"      let metadata =","counters":[]},{"line":"        [ (\"error\", Error_json.error_to_yojson e)","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"        ; (\"diff\", Staged_ledger_diff.to_yojson staged_ledger_diff)","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"        ]","counters":[]},{"line":"      in","counters":[]},{"line":"      [%log error] ~metadata msg ;","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"      [%log' debug rejected_blocks_logger]","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"        ~metadata:([ time_metadata; state_metadata ] @ metadata)","counters":[]},{"line":"        msg ;","counters":[]},{"line":"      return ()","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"let time ~logger ~time_controller label f =","counters":[]},{"line":"  let open Deferred.Result.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let t0 = Block_time.now time_controller in","counters":[]},{"line":"  let%map x = f () in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"  let span = Block_time.diff (Block_time.now time_controller) t0 in","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"  [%log info]","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":12,"col_end":12,"count":0}]},{"line":"    ~metadata:","counters":[]},{"line":"      [ (\"time\", `Int (Block_time.Span.to_ms span |> Int64.to_int_exn)) ]","counters":[{"col_start":43,"col_end":43,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"    !\"%s: $time %!\" label ;","counters":[]},{"line":"  x","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let retry ?(max = 3) ~logger ~error_message f =","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"  let rec go n =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    if n >= max then failwith error_message","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"    else","counters":[]},{"line":"      match%bind f () with","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"      | Error e ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          [%log error] \"%s : $error. Trying again\" error_message","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"            ~metadata:[ (\"error\", `String (Error.to_string_hum e)) ] ;","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"          go (n + 1)","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"      | Ok res ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          return res","counters":[]},{"line":"  in","counters":[]},{"line":"  go 0","counters":[]},{"line":"","counters":[]},{"line":"module Vrf_evaluation_state = struct","counters":[]},{"line":"  type status = At of Mina_numbers.Global_slot.t | Start | Completed","counters":[]},{"line":"","counters":[]},{"line":"  type t =","counters":[]},{"line":"    { queue : Consensus.Data.Slot_won.t Queue.t","counters":[]},{"line":"    ; mutable vrf_evaluator_status : status","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let poll_vrf_evaluator ~logger vrf_evaluator =","counters":[]},{"line":"    let f () =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      O1trace.thread \"query_vrf_evaluator\" (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          Vrf_evaluator.slots_won_so_far vrf_evaluator )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    in","counters":[]},{"line":"    retry ~logger ~error_message:\"Error fetching slots from the VRF evaluator\" f","counters":[]},{"line":"","counters":[]},{"line":"  let create () = { queue = Core.Queue.create (); vrf_evaluator_status = Start }","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"  let finished t =","counters":[]},{"line":"    match t.vrf_evaluator_status with Completed -> true | _ -> false","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"","counters":[]},{"line":"  let evaluator_status t = t.vrf_evaluator_status","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"","counters":[]},{"line":"  let update_status t (vrf_status : Vrf_evaluator.Evaluator_status.t) =","counters":[]},{"line":"    match vrf_status with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | At global_slot ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        t.vrf_evaluator_status <- At global_slot","counters":[]},{"line":"    | Completed ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        t.vrf_evaluator_status <- Completed","counters":[]},{"line":"","counters":[]},{"line":"  let poll ~vrf_evaluator ~logger t =","counters":[]},{"line":"    [%log info] \"Polling VRF evaluator process\" ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":14,"col_end":14,"count":0}]},{"line":"    let%bind vrf_result = poll_vrf_evaluator vrf_evaluator ~logger in","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"    let%map vrf_result =","counters":[]},{"line":"      match (vrf_result.evaluator_status, vrf_result.slots_won) with","counters":[]},{"line":"      | At _, [] ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (*try again*)","counters":[]},{"line":"          let%bind () =","counters":[]},{"line":"            Async.after","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"              (Time.Span.of_ms","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                 (Mina_compile_config.vrf_poll_interval_ms |> Int.to_float) )","counters":[{"col_start":73,"col_end":73,"count":0}]},{"line":"          in","counters":[]},{"line":"          poll_vrf_evaluator vrf_evaluator ~logger","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"      | _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          return vrf_result","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"    in","counters":[]},{"line":"    Queue.enqueue_all t.queue vrf_result.slots_won ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    update_status t vrf_result.evaluator_status ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    [%log info]","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":14,"col_end":14,"count":0}]},{"line":"      !\"New global slots won: $slots\"","counters":[]},{"line":"      ~metadata:","counters":[]},{"line":"        [ ( \"slots\"","counters":[]},{"line":"          , `List","counters":[]},{"line":"              (List.map vrf_result.slots_won ~f:(fun s ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                   Mina_numbers.Global_slot.to_yojson s.global_slot ) ) )","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"        ]","counters":[]},{"line":"","counters":[]},{"line":"  let update_epoch_data ~vrf_evaluator ~logger ~epoch_data_for_vrf t =","counters":[]},{"line":"    let set_epoch_data () =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let f () =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        O1trace.thread \"set_vrf_evaluator_epoch_state\" (fun () ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            Vrf_evaluator.set_new_epoch_state vrf_evaluator ~epoch_data_for_vrf )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"      in","counters":[]},{"line":"      retry ~logger","counters":[]},{"line":"        ~error_message:\"Error setting epoch state of the VRF evaluator\" f","counters":[]},{"line":"    in","counters":[]},{"line":"    [%log info] \"Sending data for VRF evaluations for epoch $epoch\"","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"      ~metadata:","counters":[]},{"line":"        [ (\"epoch\", Mina_numbers.Length.to_yojson epoch_data_for_vrf.epoch) ] ;","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"    t.vrf_evaluator_status <- Start ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let%bind () = set_epoch_data () in","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"    poll ~logger ~vrf_evaluator t","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let run ~context:(module Context : CONTEXT) ~vrf_evaluator ~prover ~verifier","counters":[]},{"line":"    ~trust_system ~get_completed_work ~transaction_resource_pool","counters":[]},{"line":"    ~time_controller ~consensus_local_state ~coinbase_receiver ~frontier_reader","counters":[]},{"line":"    ~transition_writer ~set_next_producer_timing ~log_block_creation","counters":[]},{"line":"    ~block_reward_threshold ~block_produced_bvar =","counters":[]},{"line":"  let open Context in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  O1trace.sync_thread \"produce_blocks\" (fun () ->","counters":[]},{"line":"      let genesis_breadcrumb =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let started = ref false in","counters":[]},{"line":"        let genesis_breadcrumb_ivar = Ivar.create () in","counters":[]},{"line":"        fun () ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          if !started then Ivar.read genesis_breadcrumb_ivar","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"          else (","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"            started := true ;","counters":[]},{"line":"            let max_num_retries = 3 in","counters":[]},{"line":"            let rec go retries =","counters":[]},{"line":"              [%log info]","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"                \"Generating genesis proof ($attempts_remaining / $max_attempts)\"","counters":[]},{"line":"                ~metadata:","counters":[]},{"line":"                  [ (\"attempts_remaining\", `Int retries)","counters":[]},{"line":"                  ; (\"max_attempts\", `Int max_num_retries)","counters":[]},{"line":"                  ] ;","counters":[]},{"line":"              match%bind","counters":[]},{"line":"                Prover.create_genesis_block prover","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"                  (Genesis_proof.to_inputs precomputed_values)","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"              with","counters":[]},{"line":"              | Ok res ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Ivar.fill genesis_breadcrumb_ivar (Ok res) ;","counters":[]},{"line":"                  return (Ok res)","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"              | Error err ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  [%log error] \"Failed to generate genesis breadcrumb: $error\"","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                    ~metadata:[ (\"error\", Error_json.error_to_yojson err) ] ;","counters":[{"col_start":67,"col_end":67,"count":0}]},{"line":"                  if retries > 0 then go (retries - 1)","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"                  else (","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                    Ivar.fill genesis_breadcrumb_ivar (Error err) ;","counters":[]},{"line":"                    return (Error err) )","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"            in","counters":[]},{"line":"            go max_num_retries )","counters":[]},{"line":"      in","counters":[]},{"line":"      let rejected_blocks_logger =","counters":[]},{"line":"        Logger.create ~id:Logger.Logger_id.rejected_blocks ()","counters":[]},{"line":"      in","counters":[]},{"line":"      let log_bootstrap_mode () =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [%log info] \"Pausing block production while bootstrapping\"","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"      in","counters":[]},{"line":"      let module Breadcrumb = Transition_frontier.Breadcrumb in","counters":[]},{"line":"      let produce ivar (scheduled_time, block_data, winner_pubkey) =","counters":[]},{"line":"        let open Interruptible.Let_syntax in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        match Broadcast_pipe.Reader.peek frontier_reader with","counters":[]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            log_bootstrap_mode () ; Interruptible.return ()","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"        | Some frontier -> (","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let open Transition_frontier.Extensions in","counters":[]},{"line":"            let transition_registry =","counters":[]},{"line":"              get_extension","counters":[]},{"line":"                (Transition_frontier.extensions frontier)","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"                Transition_registry","counters":[]},{"line":"            in","counters":[]},{"line":"            let crumb = Transition_frontier.best_tip frontier in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let crumb =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let crumb_global_slot_since_genesis =","counters":[]},{"line":"                Breadcrumb.protocol_state crumb","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"                |> Protocol_state.consensus_state","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"                |> Consensus.Data.Consensus_state.global_slot_since_genesis","counters":[]},{"line":"              in","counters":[]},{"line":"              let block_global_slot_since_genesis =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Consensus.Proof_of_stake.Data.Block_data","counters":[]},{"line":"                .global_slot_since_genesis block_data","counters":[]},{"line":"              in","counters":[]},{"line":"              if","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Mina_numbers.Global_slot.equal crumb_global_slot_since_genesis","counters":[]},{"line":"                  block_global_slot_since_genesis","counters":[]},{"line":"              then","counters":[]},{"line":"                (* We received a block for this slot over the network before","counters":[]},{"line":"                   attempting to produce our own. Build upon its parent instead","counters":[]},{"line":"                   of attempting (and failing) to build upon the block itself.","counters":[]},{"line":"                *)","counters":[]},{"line":"                Transition_frontier.find_exn frontier","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"                  (Breadcrumb.parent_hash crumb)","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"              else crumb","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"            in","counters":[]},{"line":"            let start = Block_time.now time_controller in","counters":[]},{"line":"            [%log info]","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"              ~metadata:[ (\"breadcrumb\", Breadcrumb.to_yojson crumb) ]","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"              \"Producing new block with parent $breadcrumb%!\" ;","counters":[]},{"line":"            let previous_transition = Breadcrumb.block_with_hash crumb in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let previous_protocol_state =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Header.protocol_state","counters":[]},{"line":"              @@ Mina_block.header (With_hash.data previous_transition)","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"            in","counters":[]},{"line":"            let%bind previous_protocol_state_proof =","counters":[]},{"line":"              if","counters":[]},{"line":"                Consensus.Data.Consensus_state.is_genesis_state","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"                  (Protocol_state.consensus_state previous_protocol_state)","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"                && Option.is_none precomputed_values.proof_data","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"              then (","counters":[]},{"line":"                match%bind","counters":[]},{"line":"                  Interruptible.uninterruptible (genesis_breadcrumb ())","counters":[{"col_start":46,"col_end":46,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"                with","counters":[]},{"line":"                | Ok block ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    let proof = Blockchain_snark.Blockchain.proof block in","counters":[]},{"line":"                    Interruptible.lift (Deferred.return proof)","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"                      (Deferred.never ())","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"                | Error _ ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    [%log error]","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                      \"Aborting block production: cannot generate a genesis \\","counters":[]},{"line":"                       proof\" ;","counters":[]},{"line":"                    Interruptible.lift (Deferred.never ()) (Deferred.return ())","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":53,"col_end":53,"count":0},{"col_start":74,"col_end":74,"count":0}]},{"line":"                )","counters":[]},{"line":"              else","counters":[]},{"line":"                return","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"                  ( Header.protocol_state_proof","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"                  @@ Mina_block.header (With_hash.data previous_transition) )","counters":[{"col_start":37,"col_end":37,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"            in","counters":[]},{"line":"            let transactions =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Network_pool.Transaction_pool.Resource_pool.transactions","counters":[{"col_start":69,"col_end":69,"count":0}]},{"line":"                transaction_resource_pool","counters":[]},{"line":"              |> Sequence.map","counters":[]},{"line":"                   ~f:Transaction_hash.User_command_with_valid_signature.data","counters":[]},{"line":"            in","counters":[]},{"line":"            let%bind () =","counters":[]},{"line":"              Interruptible.lift (Deferred.return ()) (Ivar.read ivar)","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":48,"col_end":48,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"            in","counters":[]},{"line":"            let%bind next_state_opt =","counters":[]},{"line":"              generate_next_state ~constraint_constants ~scheduled_time","counters":[]},{"line":"                ~block_data ~previous_protocol_state ~time_controller","counters":[]},{"line":"                ~staged_ledger:(Breadcrumb.staged_ledger crumb)","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"                ~transactions ~get_completed_work ~logger ~log_block_creation","counters":[]},{"line":"                ~winner_pk:winner_pubkey ~block_reward_threshold","counters":[]},{"line":"            in","counters":[]},{"line":"            match next_state_opt with","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            | None ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Interruptible.return ()","counters":[]},{"line":"            | Some","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (protocol_state, internal_transition, pending_coinbase_witness)","counters":[]},{"line":"              ->","counters":[]},{"line":"                let protocol_state_hashes =","counters":[]},{"line":"                  Protocol_state.hashes protocol_state","counters":[]},{"line":"                in","counters":[]},{"line":"                let consensus_state_with_hashes =","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  { With_hash.hash = protocol_state_hashes","counters":[]},{"line":"                  ; data = Protocol_state.consensus_state protocol_state","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"                  }","counters":[]},{"line":"                in","counters":[]},{"line":"                Debug_assert.debug_assert (fun () ->","counters":[]},{"line":"                    [%test_result: [ `Take | `Keep ]]","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"                      (Consensus.Hooks.select","counters":[]},{"line":"                         ~context:(module Context)","counters":[]},{"line":"                         ~existing:","counters":[]},{"line":"                           (With_hash.map ~f:Mina_block.consensus_state","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"                              previous_transition )","counters":[]},{"line":"                         ~candidate:consensus_state_with_hashes )","counters":[]},{"line":"                      ~expect:`Take","counters":[]},{"line":"                      ~message:","counters":[]},{"line":"                        \"newly generated consensus states should be selected \\","counters":[]},{"line":"                         over their parent\" ;","counters":[]},{"line":"                    let root_consensus_state_with_hashes =","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      Transition_frontier.root frontier","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"                      |> Breadcrumb.consensus_state_with_hashes","counters":[]},{"line":"                    in","counters":[]},{"line":"                    [%test_result: [ `Take | `Keep ]]","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"                      (Consensus.Hooks.select","counters":[]},{"line":"                         ~context:(module Context)","counters":[]},{"line":"                         ~existing:root_consensus_state_with_hashes","counters":[]},{"line":"                         ~candidate:consensus_state_with_hashes )","counters":[]},{"line":"                      ~expect:`Take","counters":[]},{"line":"                      ~message:","counters":[]},{"line":"                        \"newly generated consensus states should be selected \\","counters":[]},{"line":"                         over the tf root\" ) ;","counters":[]},{"line":"                Interruptible.uninterruptible","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  (let open Deferred.Let_syntax in","counters":[]},{"line":"                  let emit_breadcrumb () =","counters":[]},{"line":"                    let open Deferred.Result.Let_syntax in","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                    let%bind protocol_state_proof =","counters":[]},{"line":"                      time ~logger ~time_controller","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                        \"Protocol_state_proof proving time(ms)\" (fun () ->","counters":[]},{"line":"                          O1trace.thread \"dispatch_block_proving\" (fun () ->","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"                              Prover.prove prover","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                                ~prev_state:previous_protocol_state","counters":[]},{"line":"                                ~prev_state_proof:previous_protocol_state_proof","counters":[]},{"line":"                                ~next_state:protocol_state internal_transition","counters":[]},{"line":"                                pending_coinbase_witness )","counters":[]},{"line":"                          |> Deferred.Result.map_error ~f:(fun err ->","counters":[]},{"line":"                                 `Prover_error","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"                                   ( err","counters":[]},{"line":"                                   , ( previous_protocol_state_proof","counters":[]},{"line":"                                     , internal_transition","counters":[]},{"line":"                                     , pending_coinbase_witness ) ) ) )","counters":[]},{"line":"                    in","counters":[]},{"line":"                    let staged_ledger_diff =","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      Internal_transition.staged_ledger_diff internal_transition","counters":[]},{"line":"                    in","counters":[]},{"line":"                    let previous_state_hash =","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      (Protocol_state.hashes previous_protocol_state).state_hash","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"                    in","counters":[]},{"line":"                    let delta_block_chain_proof =","counters":[]},{"line":"                      Transition_chain_prover.prove","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                        ~length:","counters":[]},{"line":"                          (Mina_numbers.Length.to_int consensus_constants.delta)","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"                        ~frontier previous_state_hash","counters":[]},{"line":"                      |> Option.value_exn","counters":[]},{"line":"                    in","counters":[]},{"line":"                    let%bind transition =","counters":[]},{"line":"                      let open Result.Let_syntax in","counters":[]},{"line":"                      Validation.wrap","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"                        { With_hash.hash = protocol_state_hashes","counters":[]},{"line":"                        ; data =","counters":[]},{"line":"                            (let body = Body.create staged_ledger_diff in","counters":[]},{"line":"                             Mina_block.create ~body","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                               ~header:","counters":[]},{"line":"                                 (Header.create ~protocol_state","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"                                    ~protocol_state_proof","counters":[]},{"line":"                                    ~delta_block_chain_proof () ) )","counters":[]},{"line":"                        }","counters":[]},{"line":"                      |> Validation.skip_time_received_validation","counters":[{"col_start":64,"col_end":64,"count":0}]},{"line":"                           `This_block_was_not_received_via_gossip","counters":[]},{"line":"                      |> Validation.skip_protocol_versions_validation","counters":[{"col_start":68,"col_end":68,"count":0}]},{"line":"                           `This_block_has_valid_protocol_versions","counters":[]},{"line":"                      |> Validation.validate_genesis_protocol_state","counters":[{"col_start":66,"col_end":66,"count":0}]},{"line":"                           ~genesis_state_hash:","counters":[]},{"line":"                             (Protocol_state.genesis_state_hash","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"                                ~state_hash:(Some previous_state_hash)","counters":[]},{"line":"                                previous_protocol_state )","counters":[]},{"line":"                      >>| Validation.skip_proof_validation","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"                            `This_block_was_generated_internally","counters":[]},{"line":"                      >>| Validation.skip_delta_block_chain_validation","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"                            `This_block_was_not_received_via_gossip","counters":[]},{"line":"                      >>= Validation.validate_frontier_dependencies","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                            ~context:(module Context)","counters":[]},{"line":"                            ~root_block:","counters":[]},{"line":"                              ( Transition_frontier.root frontier","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"                              |> Breadcrumb.block_with_hash )","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"                            ~get_block_by_hash:","counters":[]},{"line":"                              (Fn.compose","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"                                 (Option.map ~f:Breadcrumb.block_with_hash)","counters":[]},{"line":"                                 (Transition_frontier.find frontier) )","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"                      |> Deferred.return","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"                    in","counters":[]},{"line":"                    let transition_receipt_time = Some (Time.now ()) in","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"                    let%bind breadcrumb =","counters":[]},{"line":"                      time ~logger ~time_controller","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                        \"Build breadcrumb on produced block\" (fun () ->","counters":[]},{"line":"                          Breadcrumb.build ~logger ~precomputed_values ~verifier","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            ~trust_system ~parent:crumb ~transition","counters":[]},{"line":"                            ~sender:None (* Consider skipping `All here *)","counters":[]},{"line":"                            ~skip_staged_ledger_verification:`Proofs","counters":[]},{"line":"                            ~transition_receipt_time () )","counters":[]},{"line":"                      |> Deferred.Result.map_error ~f:(function","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"                           | `Invalid_staged_ledger_diff e ->","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                               `Invalid_staged_ledger_diff","counters":[]},{"line":"                                 (e, staged_ledger_diff)","counters":[]},{"line":"                           | ( `Fatal_error _","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                             | `Invalid_genesis_protocol_state","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                             | `Invalid_staged_ledger_hash _","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                             | `Not_selected_over_frontier_root","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                             | `Parent_missing_from_frontier","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                             | `Prover_error _ ) as err ->","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                               err )","counters":[]},{"line":"                    in","counters":[]},{"line":"                    [%str_log info]","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"                      ~metadata:","counters":[]},{"line":"                        [ (\"breadcrumb\", Breadcrumb.to_yojson breadcrumb) ]","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"                      Block_produced ;","counters":[]},{"line":"                    (* let uptime service (and any other waiters) know about breadcrumb *)","counters":[]},{"line":"                    Bvar.broadcast block_produced_bvar breadcrumb ;","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                    Mina_metrics.(","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      Counter.inc_one Block_producer.blocks_produced) ;","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"                    Mina_metrics.Block_producer.(","counters":[]},{"line":"                      Block_production_delay_histogram.observe","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"                        block_production_delay","counters":[]},{"line":"                        Time.(","counters":[]},{"line":"                          Span.to_ms","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                          @@ diff (now ())","counters":[{"col_start":37,"col_end":37,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"                          @@ Block_time.to_time_exn scheduled_time)) ;","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                    let%bind.Async.Deferred () =","counters":[]},{"line":"                      Strict_pipe.Writer.write transition_writer breadcrumb","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"                    in","counters":[]},{"line":"                    let metadata =","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      [ ( \"state_hash\"","counters":[]},{"line":"                        , State_hash.to_yojson protocol_state_hashes.state_hash","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"                        )","counters":[]},{"line":"                      ]","counters":[]},{"line":"                    in","counters":[]},{"line":"                    [%log debug] ~metadata","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                      \"Waiting for block $state_hash to be inserted into \\","counters":[]},{"line":"                       frontier\" ;","counters":[]},{"line":"                    Deferred.choose","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"                      [ Deferred.choice","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"                          (Transition_registry.register transition_registry","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"                             protocol_state_hashes.state_hash )","counters":[]},{"line":"                          (Fn.const (Ok `Transition_accepted))","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"                      ; Deferred.choice","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"                          ( Block_time.Timeout.create time_controller","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"                              (* We allow up to 20 seconds for the transition","counters":[]},{"line":"                                 to make its way from the transition_writer to","counters":[]},{"line":"                                 the frontier.","counters":[]},{"line":"                                 This value is chosen to be reasonably","counters":[]},{"line":"                                 generous. In theory, this should not take","counters":[]},{"line":"                                 terribly long. But long cycles do happen in","counters":[]},{"line":"                                 our system, and with medium curves those long","counters":[]},{"line":"                                 cycles can be substantial.","counters":[]},{"line":"                              *)","counters":[]},{"line":"                              (Block_time.Span.of_ms 20000L)","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                              ~f:(Fn.const ())","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"                          |> Block_time.Timeout.to_deferred )","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"                          (Fn.const (Ok `Timed_out))","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"                      ]","counters":[]},{"line":"                    >>= function","counters":[]},{"line":"                    | `Transition_accepted ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        [%log info] ~metadata","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"                          \"Generated transition $state_hash was accepted into \\","counters":[]},{"line":"                           transition frontier\" ;","counters":[]},{"line":"                        return ()","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                    | `Timed_out ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        (* FIXME #3167: this should be fatal, and more","counters":[]},{"line":"                           importantly, shouldn't happen.","counters":[]},{"line":"                        *)","counters":[]},{"line":"                        let msg : (_, unit, string, unit) format4 =","counters":[]},{"line":"                          \"Timed out waiting for generated transition \\","counters":[]},{"line":"                           $state_hash to enter transition frontier. \\","counters":[]},{"line":"                           Continuing to produce new blocks anyway. This may \\","counters":[]},{"line":"                           mean your CPU is overloaded. Consider disabling \\","counters":[]},{"line":"                           `-run-snark-worker` if it's configured.\"","counters":[]},{"line":"                        in","counters":[]},{"line":"                        let span =","counters":[]},{"line":"                          Block_time.diff (Block_time.now time_controller) start","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"                        in","counters":[]},{"line":"                        let metadata =","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          [ ( \"time\"","counters":[]},{"line":"                            , `Int","counters":[]},{"line":"                                (Block_time.Span.to_ms span |> Int64.to_int_exn)","counters":[{"col_start":53,"col_end":53,"count":0},{"col_start":78,"col_end":78,"count":0}]},{"line":"                            )","counters":[]},{"line":"                          ; ( \"protocol_state\"","counters":[]},{"line":"                            , Protocol_state.Value.to_yojson protocol_state )","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"                          ]","counters":[]},{"line":"                          @ metadata","counters":[]},{"line":"                        in","counters":[]},{"line":"                        [%log' debug rejected_blocks_logger] ~metadata msg ;","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"                        [%log fatal] ~metadata msg ;","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"                        return ()","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                  in","counters":[]},{"line":"                  let%bind res = emit_breadcrumb () in","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"                  let span =","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    Block_time.diff (Block_time.now time_controller) start","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                  in","counters":[]},{"line":"                  handle_block_production_errors ~logger ~rejected_blocks_logger","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    ~time_taken:span ~previous_protocol_state ~protocol_state","counters":[]},{"line":"                    res) )","counters":[]},{"line":"      in","counters":[]},{"line":"      let production_supervisor = Singleton_supervisor.create ~task:produce in","counters":[]},{"line":"      let scheduler = Singleton_scheduler.create time_controller in","counters":[]},{"line":"      let vrf_evaluation_state = Vrf_evaluation_state.create () in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let rec check_next_block_timing slot i () =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        O1trace.sync_thread \"check_next_block_timing\" (fun () ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            (* Begin checking for the ability to produce a block *)","counters":[]},{"line":"            match Broadcast_pipe.Reader.peek frontier_reader with","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            | None ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                log_bootstrap_mode () ;","counters":[]},{"line":"                don't_wait_for","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  (let%map () =","counters":[]},{"line":"                     Broadcast_pipe.Reader.iter_until frontier_reader","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"                       ~f:(Fn.compose Deferred.return Option.is_some)","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"                   in","counters":[]},{"line":"                   check_next_block_timing slot i () )","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"            | Some transition_frontier ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                let consensus_state =","counters":[]},{"line":"                  Transition_frontier.best_tip transition_frontier","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"                  |> Breadcrumb.consensus_state","counters":[]},{"line":"                in","counters":[]},{"line":"                let now = Block_time.now time_controller in","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                let epoch_data_for_vrf, ledger_snapshot =","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  O1trace.sync_thread \"get_epoch_data_for_vrf\" (fun () ->","counters":[]},{"line":"                      Consensus.Hooks.get_epoch_data_for_vrf","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        ~constants:consensus_constants (time_to_ms now)","counters":[{"col_start":65,"col_end":65,"count":0}]},{"line":"                        consensus_state ~local_state:consensus_local_state","counters":[]},{"line":"                        ~logger )","counters":[]},{"line":"                in","counters":[]},{"line":"                let i' = Mina_numbers.Length.succ epoch_data_for_vrf.epoch in","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                let new_global_slot = epoch_data_for_vrf.global_slot in","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                let generate_genesis_proof_if_needed () =","counters":[]},{"line":"                  match Broadcast_pipe.Reader.peek frontier_reader with","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  | Some transition_frontier ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      let consensus_state =","counters":[]},{"line":"                        Transition_frontier.best_tip transition_frontier","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                        |> Breadcrumb.consensus_state","counters":[]},{"line":"                      in","counters":[]},{"line":"                      if","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        Consensus.Data.Consensus_state.is_genesis_state","counters":[]},{"line":"                          consensus_state","counters":[]},{"line":"                      then genesis_breadcrumb () |> Deferred.ignore_m","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"                      else Deferred.return ()","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                  | None ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      Deferred.return ()","counters":[]},{"line":"                in","counters":[]},{"line":"                (* TODO: Re-enable this assertion when it doesn't fail dev demos","counters":[]},{"line":"                 *       (see #5354)","counters":[]},{"line":"                 * assert (","counters":[]},{"line":"                   Consensus.Hooks.required_local_state_sync","counters":[]},{"line":"                    ~constants:consensus_constants ~consensus_state","counters":[]},{"line":"                    ~local_state:consensus_local_state","counters":[]},{"line":"                   = None ) ; *)","counters":[]},{"line":"                don't_wait_for","counters":[]},{"line":"                  (let%bind () =","counters":[]},{"line":"                     if Mina_numbers.Length.(i' > i) then","counters":[]},{"line":"                       Vrf_evaluation_state.update_epoch_data ~vrf_evaluator","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"                         ~epoch_data_for_vrf ~logger vrf_evaluation_state","counters":[]},{"line":"                     else Deferred.unit","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                   in","counters":[]},{"line":"                   let%bind () =","counters":[]},{"line":"                     (*Poll once every slot if the evaluation for the epoch is not completed or the evaluation is completed*)","counters":[]},{"line":"                     if","counters":[]},{"line":"                       Mina_numbers.Global_slot.(new_global_slot > slot)","counters":[]},{"line":"                       && not","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            (Vrf_evaluation_state.finished vrf_evaluation_state)","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"                     then","counters":[]},{"line":"                       Vrf_evaluation_state.poll ~vrf_evaluator ~logger","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"                         vrf_evaluation_state","counters":[]},{"line":"                     else Deferred.unit","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                   in","counters":[]},{"line":"                   match Core.Queue.dequeue vrf_evaluation_state.queue with","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"                   | None -> (","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                       (*Keep trying until we get some slots*)","counters":[]},{"line":"                       let poll () =","counters":[]},{"line":"                         let%bind () =","counters":[]},{"line":"                           Async.after","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                             (Time.Span.of_ms","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"                                ( Mina_compile_config.vrf_poll_interval_ms","counters":[]},{"line":"                                |> Int.to_float ) )","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"                         in","counters":[]},{"line":"                         let%map () =","counters":[]},{"line":"                           Vrf_evaluation_state.poll ~vrf_evaluator ~logger","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                             vrf_evaluation_state","counters":[]},{"line":"                         in","counters":[]},{"line":"                         Singleton_scheduler.schedule scheduler","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                           (Block_time.now time_controller)","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"                           ~f:(check_next_block_timing new_global_slot i')","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"                       in","counters":[]},{"line":"                       match","counters":[]},{"line":"                         Vrf_evaluation_state.evaluator_status","counters":[]},{"line":"                           vrf_evaluation_state","counters":[]},{"line":"                       with","counters":[]},{"line":"                       | Completed ->","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                           let epoch_end_time =","counters":[]},{"line":"                             Consensus.Hooks.epoch_end_time","counters":[]},{"line":"                               ~constants:consensus_constants","counters":[]},{"line":"                               epoch_data_for_vrf.epoch","counters":[]},{"line":"                           in","counters":[]},{"line":"                           set_next_producer_timing","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                             (`Check_again epoch_end_time) consensus_state ;","counters":[]},{"line":"                           [%log info] \"No more slots won in this epoch\" ;","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"                           return","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                             (Singleton_scheduler.schedule scheduler","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"                                epoch_end_time","counters":[]},{"line":"                                ~f:(check_next_block_timing new_global_slot i') )","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"                       | At last_slot ->","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                           set_next_producer_timing (`Evaluating_vrf last_slot)","counters":[]},{"line":"                             consensus_state ;","counters":[]},{"line":"                           poll ()","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                       | Start ->","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                           set_next_producer_timing","counters":[]},{"line":"                             (`Evaluating_vrf new_global_slot) consensus_state ;","counters":[]},{"line":"                           poll () )","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                   | Some slot_won -> (","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                       let winning_global_slot = slot_won.global_slot in","counters":[]},{"line":"                       let slot, epoch =","counters":[]},{"line":"                         let t =","counters":[]},{"line":"                           Consensus.Data.Consensus_time.of_global_slot","counters":[]},{"line":"                             winning_global_slot ~constants:consensus_constants","counters":[]},{"line":"                         in","counters":[]},{"line":"                         Consensus.Data.Consensus_time.(slot t, epoch t)","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":59,"col_end":59,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"                       in","counters":[]},{"line":"                       [%log info]","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"                         \"Block producer won slot $slot in epoch $epoch\"","counters":[]},{"line":"                         ~metadata:","counters":[]},{"line":"                           [ (\"slot\", Mina_numbers.Global_slot.to_yojson slot)","counters":[{"col_start":71,"col_end":71,"count":0}]},{"line":"                           ; (\"epoch\", Mina_numbers.Length.to_yojson epoch)","counters":[{"col_start":67,"col_end":67,"count":0}]},{"line":"                           ] ;","counters":[]},{"line":"                       let now = Block_time.now time_controller in","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                       let curr_global_slot =","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                         Consensus.Data.Consensus_time.(","counters":[]},{"line":"                           of_time_exn ~constants:consensus_constants now","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                           |> to_global_slot)","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"                       in","counters":[]},{"line":"                       let winner_pk = fst slot_won.delegator in","counters":[]},{"line":"                       let data =","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                         Consensus.Hooks.get_block_data ~slot_won","counters":[]},{"line":"                           ~ledger_snapshot","counters":[]},{"line":"                           ~coinbase_receiver:!coinbase_receiver","counters":[]},{"line":"                       in","counters":[]},{"line":"                       if","counters":[]},{"line":"                         Mina_numbers.Global_slot.(","counters":[]},{"line":"                           curr_global_slot = winning_global_slot)","counters":[]},{"line":"                       then (","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                         (*produce now*)","counters":[]},{"line":"                         [%log info] \"Producing a block now\" ;","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                         set_next_producer_timing","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                           (`Produce_now (data, winner_pk))","counters":[]},{"line":"                           consensus_state ;","counters":[]},{"line":"                         Mina_metrics.(Counter.inc_one Block_producer.slots_won) ;","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"                         let%map () = generate_genesis_proof_if_needed () in","counters":[{"col_start":69,"col_end":69,"count":0}]},{"line":"                         ignore","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                           ( Interruptible.finally","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"                               (Singleton_supervisor.dispatch","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"                                  production_supervisor (now, data, winner_pk) )","counters":[]},{"line":"                               ~f:(check_next_block_timing new_global_slot i')","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"                             : (_, _) Interruptible.t ) )","counters":[]},{"line":"                       else","counters":[]},{"line":"                         match","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                           Mina_numbers.Global_slot.sub winning_global_slot","counters":[]},{"line":"                             curr_global_slot","counters":[]},{"line":"                         with","counters":[]},{"line":"                         | None ->","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                             [%log warn]","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"                               \"Skipping block production for global slot \\","counters":[]},{"line":"                                $slot_won because it has passed. Current \\","counters":[]},{"line":"                                global slot is $curr_slot\"","counters":[]},{"line":"                               ~metadata:","counters":[]},{"line":"                                 [ ( \"slot_won\"","counters":[]},{"line":"                                   , Mina_numbers.Global_slot.to_yojson","counters":[{"col_start":70,"col_end":70,"count":0}]},{"line":"                                       winning_global_slot )","counters":[]},{"line":"                                 ; ( \"curr_slot\"","counters":[]},{"line":"                                   , Mina_numbers.Global_slot.to_yojson","counters":[{"col_start":70,"col_end":70,"count":0}]},{"line":"                                       curr_global_slot )","counters":[]},{"line":"                                 ] ;","counters":[]},{"line":"                             return","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                               (check_next_block_timing new_global_slot i' ())","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"                         | Some slot_diff ->","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                             [%log info] \"Producing a block in $slots slots\"","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"                               ~metadata:","counters":[]},{"line":"                                 [ ( \"slots\"","counters":[]},{"line":"                                   , Mina_numbers.Global_slot.to_yojson","counters":[{"col_start":70,"col_end":70,"count":0}]},{"line":"                                       slot_diff )","counters":[]},{"line":"                                 ] ;","counters":[]},{"line":"                             let time =","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                               Consensus.Data.Consensus_time.(","counters":[]},{"line":"                                 start_time ~constants:consensus_constants","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"                                   (of_global_slot","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"                                      ~constants:consensus_constants","counters":[]},{"line":"                                      winning_global_slot ))","counters":[]},{"line":"                               |> Block_time.to_span_since_epoch","counters":[{"col_start":63,"col_end":63,"count":0}]},{"line":"                               |> Block_time.Span.to_ms","counters":[]},{"line":"                             in","counters":[]},{"line":"                             set_next_producer_timing","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                               (`Produce (time, data, winner_pk))","counters":[]},{"line":"                               consensus_state ;","counters":[]},{"line":"                             Mina_metrics.(","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                               Counter.inc_one Block_producer.slots_won) ;","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"                             let scheduled_time = time_of_ms time in","counters":[]},{"line":"                             don't_wait_for","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                               ((* Attempt to generate a genesis proof in the slot","counters":[]},{"line":"                                   immediately before we'll actually need it, so that","counters":[]},{"line":"                                   it isn't limiting our block production time in the","counters":[]},{"line":"                                   won slot.","counters":[]},{"line":"                                   This also allows non-genesis blocks to be received","counters":[]},{"line":"                                   in the meantime and alleviate the need to produce","counters":[]},{"line":"                                   one at all, if this won't have block height 1.","counters":[]},{"line":"                                *)","counters":[]},{"line":"                                let scheduled_genesis_time =","counters":[]},{"line":"                                  time_of_ms","counters":[]},{"line":"                                    Int64.(","counters":[]},{"line":"                                      time","counters":[]},{"line":"                                      - of_int","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"                                          constraint_constants","counters":[]},{"line":"                                            .block_window_duration_ms)","counters":[]},{"line":"                                in","counters":[]},{"line":"                                let span_till_time =","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                                  Block_time.diff scheduled_genesis_time","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"                                    (Block_time.now time_controller)","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                                  |> Block_time.Span.to_time_span","counters":[]},{"line":"                                in","counters":[]},{"line":"                                let%bind () = after span_till_time in","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                                generate_genesis_proof_if_needed () ) ;","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                             Singleton_scheduler.schedule scheduler","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                               scheduled_time ~f:(fun () ->","counters":[]},{"line":"                                 ignore","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"                                   ( Interruptible.finally","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"                                       (Singleton_supervisor.dispatch","counters":[{"col_start":68,"col_end":68,"count":0}]},{"line":"                                          production_supervisor","counters":[]},{"line":"                                          (scheduled_time, data, winner_pk) )","counters":[]},{"line":"                                       ~f:","counters":[]},{"line":"                                         (check_next_block_timing","counters":[{"col_start":64,"col_end":64,"count":0}]},{"line":"                                            new_global_slot i' )","counters":[]},{"line":"                                     : (_, _) Interruptible.t ) ) ;","counters":[]},{"line":"                             Deferred.return () ) ) )","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"      in","counters":[]},{"line":"      let start () =","counters":[]},{"line":"        check_next_block_timing Mina_numbers.Global_slot.zero","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Mina_numbers.Length.zero ()","counters":[]},{"line":"      in","counters":[]},{"line":"      let genesis_state_timestamp =","counters":[]},{"line":"        consensus_constants.genesis_state_timestamp","counters":[]},{"line":"      in","counters":[]},{"line":"      (* if the producer starts before genesis, sleep until genesis *)","counters":[]},{"line":"      let now = Block_time.now time_controller in","counters":[]},{"line":"      if Block_time.( >= ) now genesis_state_timestamp then start ()","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"      else","counters":[]},{"line":"        let time_till_genesis = Block_time.diff genesis_state_timestamp now in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        [%log warn]","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"          ~metadata:","counters":[]},{"line":"            [ ( \"time_till_genesis\"","counters":[]},{"line":"              , `Int","counters":[]},{"line":"                  (Int64.to_int_exn (Block_time.Span.to_ms time_till_genesis))","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"              )","counters":[]},{"line":"            ]","counters":[]},{"line":"          \"Node started before genesis: waiting $time_till_genesis \\","counters":[]},{"line":"           milliseconds before starting block producer\" ;","counters":[]},{"line":"        ignore","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ( Block_time.Timeout.create time_controller time_till_genesis","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"              ~f:(fun _ -> start ())","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"            : unit Block_time.Timeout.t ) )","counters":[]},{"line":"","counters":[]},{"line":"let run_precomputed ~context:(module Context : CONTEXT) ~verifier ~trust_system","counters":[]},{"line":"    ~time_controller ~frontier_reader ~transition_writer ~precomputed_blocks =","counters":[]},{"line":"  let open Context in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let log_bootstrap_mode () =","counters":[]},{"line":"    [%log info] \"Pausing block production while bootstrapping\"","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":14,"col_end":14,"count":0}]},{"line":"  in","counters":[]},{"line":"  let rejected_blocks_logger =","counters":[]},{"line":"    Logger.create ~id:Logger.Logger_id.rejected_blocks ()","counters":[]},{"line":"  in","counters":[]},{"line":"  let start = Block_time.now time_controller in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let module Breadcrumb = Transition_frontier.Breadcrumb in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  (* accounts_accessed, accounts_created, tokens_used are unused here","counters":[]},{"line":"     those fields are in precomputed blocks to add to the","counters":[]},{"line":"     archive db, they're not needed for replaying blocks","counters":[]},{"line":"  *)","counters":[]},{"line":"  let produce","counters":[]},{"line":"      { Precomputed.scheduled_time","counters":[]},{"line":"      ; protocol_state","counters":[]},{"line":"      ; protocol_state_proof","counters":[]},{"line":"      ; staged_ledger_diff","counters":[]},{"line":"      ; delta_transition_chain_proof = delta_block_chain_proof","counters":[]},{"line":"      ; accounts_accessed = _","counters":[]},{"line":"      ; accounts_created = _","counters":[]},{"line":"      ; tokens_used = _","counters":[]},{"line":"      } =","counters":[]},{"line":"    let protocol_state_hashes = Protocol_state.hashes protocol_state in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let consensus_state_with_hashes =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      { With_hash.hash = protocol_state_hashes","counters":[]},{"line":"      ; data = Protocol_state.consensus_state protocol_state","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"      }","counters":[]},{"line":"    in","counters":[]},{"line":"    match Broadcast_pipe.Reader.peek frontier_reader with","counters":[]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        log_bootstrap_mode () ; return ()","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"    | Some frontier ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let open Transition_frontier.Extensions in","counters":[]},{"line":"        let transition_registry =","counters":[]},{"line":"          get_extension","counters":[]},{"line":"            (Transition_frontier.extensions frontier)","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"            Transition_registry","counters":[]},{"line":"        in","counters":[]},{"line":"        let crumb = Transition_frontier.best_tip frontier in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        [%log trace]","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"          ~metadata:[ (\"breadcrumb\", Breadcrumb.to_yojson crumb) ]","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"          \"Emitting precomputed block with parent $breadcrumb%!\" ;","counters":[]},{"line":"        let previous_transition = Breadcrumb.block_with_hash crumb in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let previous_protocol_state =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Header.protocol_state","counters":[]},{"line":"          @@ Mina_block.header (With_hash.data previous_transition)","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"        in","counters":[]},{"line":"        Debug_assert.debug_assert (fun () ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            [%test_result: [ `Take | `Keep ]]","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"              (Consensus.Hooks.select","counters":[]},{"line":"                 ~context:(module Context)","counters":[]},{"line":"                 ~existing:","counters":[]},{"line":"                   (With_hash.map ~f:Mina_block.consensus_state","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                      previous_transition )","counters":[]},{"line":"                 ~candidate:consensus_state_with_hashes )","counters":[]},{"line":"              ~expect:`Take","counters":[]},{"line":"              ~message:","counters":[]},{"line":"                \"newly generated consensus states should be selected over \\","counters":[]},{"line":"                 their parent\" ;","counters":[]},{"line":"            let root_consensus_state_with_hashes =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Transition_frontier.root frontier","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"              |> Breadcrumb.consensus_state_with_hashes","counters":[]},{"line":"            in","counters":[]},{"line":"            [%test_result: [ `Take | `Keep ]]","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"              (Consensus.Hooks.select","counters":[]},{"line":"                 ~context:(module Context)","counters":[]},{"line":"                 ~existing:root_consensus_state_with_hashes","counters":[]},{"line":"                 ~candidate:consensus_state_with_hashes )","counters":[]},{"line":"              ~expect:`Take","counters":[]},{"line":"              ~message:","counters":[]},{"line":"                \"newly generated consensus states should be selected over the \\","counters":[]},{"line":"                 tf root\" ) ;","counters":[]},{"line":"        let emit_breadcrumb () =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let open Deferred.Result.Let_syntax in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let previous_protocol_state_hash =","counters":[]},{"line":"            State_hash.With_state_hashes.state_hash previous_transition","counters":[]},{"line":"          in","counters":[]},{"line":"          let%bind transition =","counters":[]},{"line":"            let open Result.Let_syntax in","counters":[]},{"line":"            Validation.wrap","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"              { With_hash.hash = protocol_state_hashes","counters":[]},{"line":"              ; data =","counters":[]},{"line":"                  (let body = Body.create staged_ledger_diff in","counters":[]},{"line":"                   Mina_block.create ~body","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"                     ~header:","counters":[]},{"line":"                       (Header.create ~protocol_state ~protocol_state_proof","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"                          ~delta_block_chain_proof () ) )","counters":[]},{"line":"              }","counters":[]},{"line":"            |> Validation.skip_time_received_validation","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"                 `This_block_was_not_received_via_gossip","counters":[]},{"line":"            |> Validation.skip_protocol_versions_validation","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"                 `This_block_has_valid_protocol_versions","counters":[]},{"line":"            |> Validation.skip_proof_validation","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"                 `This_block_was_generated_internally","counters":[]},{"line":"            |> Validation.skip_delta_block_chain_validation","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"                 `This_block_was_not_received_via_gossip","counters":[]},{"line":"            |> Validation.validate_genesis_protocol_state","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"                 ~genesis_state_hash:","counters":[]},{"line":"                   (Protocol_state.genesis_state_hash","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"                      ~state_hash:(Some previous_protocol_state_hash)","counters":[]},{"line":"                      previous_protocol_state )","counters":[]},{"line":"            >>= Validation.validate_frontier_dependencies","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                  ~context:(module Context)","counters":[]},{"line":"                  ~root_block:","counters":[]},{"line":"                    ( Transition_frontier.root frontier","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"                    |> Breadcrumb.block_with_hash )","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"                  ~get_block_by_hash:","counters":[]},{"line":"                    (Fn.compose","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                       (Option.map ~f:Breadcrumb.block_with_hash)","counters":[]},{"line":"                       (Transition_frontier.find frontier) )","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"            |> Deferred.return","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"          in","counters":[]},{"line":"          let transition_receipt_time = None in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let%bind breadcrumb =","counters":[]},{"line":"            time ~logger ~time_controller","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"              \"Build breadcrumb on produced block (precomputed)\" (fun () ->","counters":[]},{"line":"                Breadcrumb.build ~logger ~precomputed_values ~verifier","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"                  ~trust_system ~parent:crumb ~transition ~sender:None","counters":[]},{"line":"                  ~skip_staged_ledger_verification:`Proofs","counters":[]},{"line":"                  ~transition_receipt_time ()","counters":[]},{"line":"                |> Deferred.Result.map_error ~f:(function","counters":[]},{"line":"                     | `Invalid_staged_ledger_diff e ->","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                         `Invalid_staged_ledger_diff (e, staged_ledger_diff)","counters":[]},{"line":"                     | ( `Fatal_error _","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                       | `Invalid_genesis_protocol_state","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                       | `Invalid_staged_ledger_hash _","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                       | `Not_selected_over_frontier_root","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                       | `Parent_missing_from_frontier ) as err ->","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                         err ) )","counters":[]},{"line":"          in","counters":[]},{"line":"          [%str_log trace]","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"            ~metadata:[ (\"breadcrumb\", Breadcrumb.to_yojson breadcrumb) ]","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"            Block_produced ;","counters":[]},{"line":"          let metadata =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            [ ( \"state_hash\"","counters":[]},{"line":"              , State_hash.to_yojson protocol_state_hashes.state_hash )","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"            ]","counters":[]},{"line":"          in","counters":[]},{"line":"          Mina_metrics.(Counter.inc_one Block_producer.blocks_produced) ;","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"          Mina_metrics.Block_producer.(","counters":[]},{"line":"            Block_production_delay_histogram.observe block_production_delay","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"              Time.(","counters":[]},{"line":"                Span.to_ms","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                @@ diff (now ())","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"                @@ Block_time.to_time_exn scheduled_time)) ;","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"          let%bind.Async.Deferred () =","counters":[]},{"line":"            Strict_pipe.Writer.write transition_writer breadcrumb","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"          in","counters":[]},{"line":"          [%log debug] ~metadata","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"            \"Waiting for block $state_hash to be inserted into frontier\" ;","counters":[]},{"line":"          Deferred.choose","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"            [ Deferred.choice","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                (Transition_registry.register transition_registry","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"                   protocol_state_hashes.state_hash )","counters":[]},{"line":"                (Fn.const (Ok `Transition_accepted))","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"            ; Deferred.choice","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                ( Block_time.Timeout.create time_controller","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"                    (Block_time.Span.of_ms 20000L)","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"                    ~f:(Fn.const ())","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                |> Block_time.Timeout.to_deferred )","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"                (Fn.const (Ok `Timed_out))","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"            ]","counters":[]},{"line":"          >>= function","counters":[]},{"line":"          | `Transition_accepted ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              [%log info] ~metadata","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                \"Generated transition $state_hash was accepted into transition \\","counters":[]},{"line":"                 frontier\" ;","counters":[]},{"line":"              return ()","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"          | `Timed_out ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (* FIXME #3167: this should be fatal, and more importantly,","counters":[]},{"line":"                 shouldn't happen.","counters":[]},{"line":"              *)","counters":[]},{"line":"              [%log fatal] ~metadata","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                \"Timed out waiting for generated transition $state_hash to \\","counters":[]},{"line":"                 enter transition frontier. Continuing to produce new blocks \\","counters":[]},{"line":"                 anyway. This may mean your CPU is overloaded. Consider \\","counters":[]},{"line":"                 disabling `-run-snark-worker` if it's configured.\" ;","counters":[]},{"line":"              return ()","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"        in","counters":[]},{"line":"        let%bind res = emit_breadcrumb () in","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"        let span = Block_time.diff (Block_time.now time_controller) start in","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"        handle_block_production_errors ~logger ~rejected_blocks_logger","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ~time_taken:span ~previous_protocol_state ~protocol_state res","counters":[]},{"line":"  in","counters":[]},{"line":"  let rec emit_next_block precomputed_blocks =","counters":[]},{"line":"    (* Begin checking for the ability to produce a block *)","counters":[]},{"line":"    match Broadcast_pipe.Reader.peek frontier_reader with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        log_bootstrap_mode () ;","counters":[]},{"line":"        let%bind () =","counters":[]},{"line":"          Broadcast_pipe.Reader.iter_until frontier_reader","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"            ~f:(Fn.compose Deferred.return Option.is_some)","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"        in","counters":[]},{"line":"        emit_next_block precomputed_blocks","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    | Some _transition_frontier -> (","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        match Sequence.next precomputed_blocks with","counters":[]},{"line":"        | Some (precomputed_block, precomputed_blocks) ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let new_time_offset =","counters":[]},{"line":"              Time.diff (Time.now ())","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                (Block_time.to_time_exn","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"                   precomputed_block.Precomputed.scheduled_time )","counters":[]},{"line":"            in","counters":[]},{"line":"            [%log info]","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"              \"Changing time offset from $old_time_offset to $new_time_offset\"","counters":[]},{"line":"              ~metadata:","counters":[]},{"line":"                [ ( \"old_time_offset\"","counters":[]},{"line":"                  , `String","counters":[]},{"line":"                      (Time.Span.to_string_hum","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"                         (Block_time.Controller.get_time_offset ~logger) ) )","counters":[]},{"line":"                ; ( \"new_time_offset\"","counters":[]},{"line":"                  , `String (Time.Span.to_string_hum new_time_offset) )","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                ] ;","counters":[]},{"line":"            Block_time.Controller.set_time_offset new_time_offset ;","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let%bind () = produce precomputed_block in","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"            emit_next_block precomputed_blocks","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            return () )","counters":[]},{"line":"  in","counters":[]},{"line":"  emit_next_block precomputed_blocks","counters":[{"col_start":35,"col_end":35,"count":2}]}]}