{"filename":"src/lib/pickles_types/pcs_batch.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"type ('a, 'n, 'm) t =","counters":[]},{"line":"  { without_degree_bound : 'n Nat.t; with_degree_bound : ('a, 'm) Vector.t }","counters":[]},{"line":"","counters":[]},{"line":"let map t ~f = { t with with_degree_bound = Vector.map t.with_degree_bound ~f }","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"","counters":[]},{"line":"let num_bits n = Int.floor_log2 n + 1","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"","counters":[]},{"line":"let%test_unit \"num_bits\" =","counters":[]},{"line":"  let naive n =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    let rec go k =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (* [Invalid_argument] represents an overflow, which is certainly bigger","counters":[]},{"line":"         than any given value.","counters":[]},{"line":"      *)","counters":[]},{"line":"      let n_lt_2k = try n < Int.pow 2 k with Invalid_argument _ -> true in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"      if n_lt_2k then k else go (k + 1)","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"    in","counters":[]},{"line":"    go 0","counters":[]},{"line":"  in","counters":[]},{"line":"  Quickcheck.test (Int.gen_uniform_incl 0 Int.max_value) ~f:(fun n ->","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"      [%test_eq: int] (num_bits n) (naive n) )","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"let pow ~one ~mul x n =","counters":[]},{"line":"  assert (n >= 0) ;","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":9,"col_end":9,"count":0}]},{"line":"  let k = num_bits n in","counters":[]},{"line":"  let rec go acc i =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    if i < 0 then acc","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"    else","counters":[]},{"line":"      let acc = mul acc acc in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let b = (n lsr i) land 1 = 1 in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let acc = if b then mul x acc else acc in","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"      go acc (i - 1)","counters":[]},{"line":"  in","counters":[]},{"line":"  go one (k - 1)","counters":[]},{"line":"","counters":[]},{"line":"let create ~without_degree_bound ~with_degree_bound =","counters":[]},{"line":"  { without_degree_bound; with_degree_bound }","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let combine_commitments _t ~scale ~add ~xi (type n)","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"    (without_degree_bound : (_, n) Vector.t) with_degree_bound =","counters":[]},{"line":"  match without_degree_bound with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | [] ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      failwith \"combine_commitments: empty list\"","counters":[]},{"line":"  | init :: without_degree_bound ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let polys =","counters":[]},{"line":"        Vector.to_list without_degree_bound","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"        @ List.concat_map (Vector.to_list with_degree_bound)","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"            ~f:(fun (unshifted, shifted) -> [ unshifted; shifted ])","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"      in","counters":[]},{"line":"      List.fold_left polys ~init ~f:(fun acc p -> add p (scale acc xi))","counters":[{"col_start":50,"col_end":50,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"","counters":[]},{"line":"let combine_evaluations' (type a n m)","counters":[]},{"line":"    ({ without_degree_bound = _; with_degree_bound } : (a, n Nat.s, m) t)","counters":[]},{"line":"    ~shifted_pow ~mul ~add ~one:_ ~evaluation_point ~xi","counters":[]},{"line":"    (init :: evals0 : (_, n Nat.s) Vector.t) (evals1 : (_, m) Vector.t) =","counters":[]},{"line":"  let evals =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Vector.to_list evals0","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"    @ List.concat","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"        (Vector.to_list","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"           (Vector.map2 with_degree_bound evals1 ~f:(fun deg fx ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                [ fx; mul (shifted_pow deg evaluation_point) fx ] ) ) )","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"  in","counters":[]},{"line":"  List.fold_left evals ~init ~f:(fun acc fx -> add fx (mul acc xi))","counters":[{"col_start":47,"col_end":47,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"","counters":[]},{"line":"let[@warning \"-45\"] combine_evaluations' (type n) (t : (_, n, _) t) ~shifted_pow","counters":[]},{"line":"    ~mul ~add ~one ~evaluation_point ~xi (evals0 : (_, n) Vector.t) evals1 =","counters":[]},{"line":"  match evals0 with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | Vector.[] ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      failwith \"Empty evals0\"","counters":[]},{"line":"  | _ :: _ ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      combine_evaluations' t ~shifted_pow ~mul ~add ~one ~evaluation_point ~xi","counters":[]},{"line":"        evals0 evals1","counters":[]},{"line":"","counters":[]},{"line":"let combine_evaluations (type f) t ~crs_max_degree ~(mul : f -> f -> f) ~add","counters":[]},{"line":"    ~one ~evaluation_point ~xi evals0 evals1 =","counters":[]},{"line":"  let pow = pow ~one ~mul in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  combine_evaluations' t evals0 evals1","counters":[]},{"line":"    ~shifted_pow:(fun deg x -> pow x (crs_max_degree - deg))","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"    ~mul ~add ~one ~evaluation_point ~xi","counters":[]},{"line":"","counters":[]},{"line":"open Plonk_types.Poly_comm","counters":[]},{"line":"","counters":[]},{"line":"let combine_split_commitments _t ~scale_and_add ~init:i ~xi (type n)","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"    (without_degree_bound : (_, n) Vector.t) with_degree_bound =","counters":[]},{"line":"  let flat =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    List.concat_map (Vector.to_list without_degree_bound) ~f:Array.to_list","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"    @ List.concat_map (Vector.to_list with_degree_bound)","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"        ~f:(fun { With_degree_bound.unshifted; shifted } ->","counters":[]},{"line":"          Array.to_list unshifted @ [ shifted ] )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"  in","counters":[]},{"line":"  match List.rev flat with","counters":[]},{"line":"  | [] ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      failwith \"combine_split_commitments: empty\"","counters":[]},{"line":"  | init :: comms ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      List.fold_left comms ~init:(i init) ~f:(fun acc p ->","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"          scale_and_add ~acc ~xi p )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"let combine_split_evaluations (type f f')","counters":[]},{"line":"    ~(mul_and_add : acc:f' -> xi:f' -> f -> f') ~init:(i : f -> f') ~(xi : f')","counters":[]},{"line":"    (evals0 : f array list) : f' =","counters":[]},{"line":"  let flat = List.concat_map evals0 ~f:Array.to_list in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  match List.rev flat with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | [] ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      failwith \"combine_split_evaluations: empty\"","counters":[]},{"line":"  | init :: es ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      List.fold_left es ~init:(i init) ~f:(fun acc fx ->","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"          mul_and_add ~acc ~xi fx )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":34,"col_end":34,"count":2}]}]}