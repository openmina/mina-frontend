{"filename":"src/lib/transaction_snark/transaction_snark_intf.ml","lines":[{"line":"module type Full = sig","counters":[]},{"line":"  open Core","counters":[]},{"line":"  open Mina_base","counters":[]},{"line":"  open Mina_transaction","counters":[]},{"line":"  open Snark_params","counters":[]},{"line":"  open Mina_state","counters":[]},{"line":"  open Currency","counters":[]},{"line":"  module Transaction_validator = Transaction_validator","counters":[]},{"line":"","counters":[]},{"line":"  (** For debugging. Logs to stderr the inputs to the top hash. *)","counters":[]},{"line":"  val with_top_hash_logging : (unit -> 'a) -> 'a","counters":[]},{"line":"","counters":[]},{"line":"  module Pending_coinbase_stack_state : sig","counters":[]},{"line":"    module Init_stack : sig","counters":[]},{"line":"      [%%versioned:","counters":[]},{"line":"      module Stable : sig","counters":[]},{"line":"        module V1 : sig","counters":[]},{"line":"          type t =","counters":[]},{"line":"            | Base of Pending_coinbase.Stack_versioned.Stable.V1.t","counters":[]},{"line":"            | Merge","counters":[]},{"line":"          [@@deriving sexp, hash, compare, equal, yojson]","counters":[]},{"line":"        end","counters":[]},{"line":"      end]","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Poly : sig","counters":[]},{"line":"      [%%versioned:","counters":[]},{"line":"      module Stable : sig","counters":[]},{"line":"        module V1 : sig","counters":[]},{"line":"          type 'pending_coinbase t =","counters":[]},{"line":"            { source : 'pending_coinbase; target : 'pending_coinbase }","counters":[]},{"line":"          [@@deriving compare, equal, fields, hash, sexp, yojson]","counters":[]},{"line":"","counters":[]},{"line":"          val to_latest :","counters":[]},{"line":"               ('pending_coinbase -> 'pending_coinbase')","counters":[]},{"line":"            -> 'pending_coinbase t","counters":[]},{"line":"            -> 'pending_coinbase' t","counters":[]},{"line":"        end","counters":[]},{"line":"      end]","counters":[]},{"line":"","counters":[]},{"line":"      val typ :","counters":[]},{"line":"           ('pending_coinbase_var, 'pending_coinbase) Tick.Typ.t","counters":[]},{"line":"        -> ('pending_coinbase_var t, 'pending_coinbase t) Tick.Typ.t","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    type 'pending_coinbase poly = 'pending_coinbase Poly.t =","counters":[]},{"line":"      { source : 'pending_coinbase; target : 'pending_coinbase }","counters":[]},{"line":"    [@@deriving sexp, hash, compare, equal, fields, yojson]","counters":[]},{"line":"","counters":[]},{"line":"    [%%versioned:","counters":[]},{"line":"    module Stable : sig","counters":[]},{"line":"      module V1 : sig","counters":[]},{"line":"        type t = Pending_coinbase.Stack_versioned.Stable.V1.t Poly.Stable.V1.t","counters":[]},{"line":"        [@@deriving compare, equal, hash, sexp, yojson]","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    type var = Pending_coinbase.Stack.var Poly.t","counters":[]},{"line":"","counters":[]},{"line":"    open Tick","counters":[]},{"line":"","counters":[]},{"line":"    val typ : (var, t) Typ.t","counters":[]},{"line":"","counters":[]},{"line":"    val to_input : t -> Field.t Random_oracle.Input.Chunked.t","counters":[]},{"line":"","counters":[]},{"line":"    val var_to_input : var -> Field.Var.t Random_oracle.Input.Chunked.t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Statement : sig","counters":[]},{"line":"    module Poly : sig","counters":[]},{"line":"      [%%versioned:","counters":[]},{"line":"      module Stable : sig","counters":[]},{"line":"        module V2 : sig","counters":[]},{"line":"          type ( 'ledger_hash","counters":[]},{"line":"               , 'amount","counters":[]},{"line":"               , 'pending_coinbase","counters":[]},{"line":"               , 'fee_excess","counters":[]},{"line":"               , 'sok_digest","counters":[]},{"line":"               , 'local_state )","counters":[]},{"line":"               t =","counters":[]},{"line":"            { source :","counters":[]},{"line":"                ( 'ledger_hash","counters":[]},{"line":"                , 'pending_coinbase","counters":[]},{"line":"                , 'local_state )","counters":[]},{"line":"                Registers.Stable.V1.t","counters":[]},{"line":"            ; target :","counters":[]},{"line":"                ( 'ledger_hash","counters":[]},{"line":"                , 'pending_coinbase","counters":[]},{"line":"                , 'local_state )","counters":[]},{"line":"                Registers.Stable.V1.t","counters":[]},{"line":"            ; supply_increase : 'amount","counters":[]},{"line":"            ; fee_excess : 'fee_excess","counters":[]},{"line":"            ; sok_digest : 'sok_digest","counters":[]},{"line":"            }","counters":[]},{"line":"          [@@deriving compare, equal, hash, sexp, yojson, hlist]","counters":[]},{"line":"        end","counters":[]},{"line":"      end]","counters":[]},{"line":"","counters":[]},{"line":"      val with_empty_local_state :","counters":[]},{"line":"           supply_increase:'amount","counters":[]},{"line":"        -> fee_excess:'fee_excess","counters":[]},{"line":"        -> sok_digest:'sok_digest","counters":[]},{"line":"        -> source:'ledger_hash","counters":[]},{"line":"        -> target:'ledger_hash","counters":[]},{"line":"        -> pending_coinbase_stack_state:","counters":[]},{"line":"             'pending_coinbase Pending_coinbase_stack_state.poly","counters":[]},{"line":"        -> ( 'ledger_hash","counters":[]},{"line":"           , 'amount","counters":[]},{"line":"           , 'pending_coinbase","counters":[]},{"line":"           , 'fee_excess","counters":[]},{"line":"           , 'sok_digest","counters":[]},{"line":"           , Mina_transaction_logic.Zkapp_command_logic.Local_state.Value.t )","counters":[]},{"line":"           t","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    type ( 'ledger_hash","counters":[]},{"line":"         , 'amount","counters":[]},{"line":"         , 'pending_coinbase","counters":[]},{"line":"         , 'fee_excess","counters":[]},{"line":"         , 'sok_digest","counters":[]},{"line":"         , 'local_state )","counters":[]},{"line":"         poly =","counters":[]},{"line":"          ( 'ledger_hash","counters":[]},{"line":"          , 'amount","counters":[]},{"line":"          , 'pending_coinbase","counters":[]},{"line":"          , 'fee_excess","counters":[]},{"line":"          , 'sok_digest","counters":[]},{"line":"          , 'local_state )","counters":[]},{"line":"          Poly.t =","counters":[]},{"line":"      { source : ('ledger_hash, 'pending_coinbase, 'local_state) Registers.t","counters":[]},{"line":"      ; target : ('ledger_hash, 'pending_coinbase, 'local_state) Registers.t","counters":[]},{"line":"      ; supply_increase : 'amount","counters":[]},{"line":"      ; fee_excess : 'fee_excess","counters":[]},{"line":"      ; sok_digest : 'sok_digest","counters":[]},{"line":"      }","counters":[]},{"line":"    [@@deriving compare, equal, hash, sexp, yojson]","counters":[]},{"line":"","counters":[]},{"line":"    [%%versioned:","counters":[]},{"line":"    module Stable : sig","counters":[]},{"line":"      module V2 : sig","counters":[]},{"line":"        type t =","counters":[]},{"line":"          ( Frozen_ledger_hash.Stable.V1.t","counters":[]},{"line":"          , (Amount.Stable.V1.t, Sgn.Stable.V1.t) Signed_poly.Stable.V1.t","counters":[]},{"line":"          , Pending_coinbase.Stack_versioned.Stable.V1.t","counters":[]},{"line":"          , Fee_excess.Stable.V1.t","counters":[]},{"line":"          , unit","counters":[]},{"line":"          , Local_state.Stable.V1.t )","counters":[]},{"line":"          Poly.Stable.V2.t","counters":[]},{"line":"        [@@deriving compare, equal, hash, sexp, yojson]","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    module With_sok : sig","counters":[]},{"line":"      [%%versioned:","counters":[]},{"line":"      module Stable : sig","counters":[]},{"line":"        module V2 : sig","counters":[]},{"line":"          type t =","counters":[]},{"line":"            ( Frozen_ledger_hash.Stable.V1.t","counters":[]},{"line":"            , (Amount.Stable.V1.t, Sgn.Stable.V1.t) Signed_poly.Stable.V1.t","counters":[]},{"line":"            , Pending_coinbase.Stack_versioned.Stable.V1.t","counters":[]},{"line":"            , Fee_excess.Stable.V1.t","counters":[]},{"line":"            , Sok_message.Digest.Stable.V1.t","counters":[]},{"line":"            , Local_state.Stable.V1.t )","counters":[]},{"line":"            Poly.Stable.V2.t","counters":[]},{"line":"          [@@deriving compare, equal, hash, sexp, yojson]","counters":[]},{"line":"        end","counters":[]},{"line":"      end]","counters":[]},{"line":"","counters":[]},{"line":"      type var =","counters":[]},{"line":"        ( Frozen_ledger_hash.var","counters":[]},{"line":"        , Amount.Signed.var","counters":[]},{"line":"        , Pending_coinbase.Stack.var","counters":[]},{"line":"        , Fee_excess.var","counters":[]},{"line":"        , Sok_message.Digest.Checked.t","counters":[]},{"line":"        , Local_state.Checked.t )","counters":[]},{"line":"        Poly.t","counters":[]},{"line":"","counters":[]},{"line":"      open Tick","counters":[]},{"line":"","counters":[]},{"line":"      val typ : (var, t) Typ.t","counters":[]},{"line":"","counters":[]},{"line":"      val to_input : t -> Field.t Random_oracle.Input.Chunked.t","counters":[]},{"line":"","counters":[]},{"line":"      val to_field_elements : t -> Field.t array","counters":[]},{"line":"","counters":[]},{"line":"      module Checked : sig","counters":[]},{"line":"        type t = var","counters":[]},{"line":"","counters":[]},{"line":"        val to_input :","counters":[]},{"line":"          var -> Field.Var.t Random_oracle.Input.Chunked.t Checked.t","counters":[]},{"line":"","counters":[]},{"line":"        (* This is actually a checked function. *)","counters":[]},{"line":"        val to_field_elements : var -> Field.Var.t array","counters":[]},{"line":"      end","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    val gen : t Quickcheck.Generator.t","counters":[]},{"line":"","counters":[]},{"line":"    val merge : t -> t -> t Or_error.t","counters":[]},{"line":"","counters":[]},{"line":"    include Hashable.S_binable with type t := t","counters":[]},{"line":"","counters":[]},{"line":"    include Comparable.S with type t := t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  [%%versioned:","counters":[]},{"line":"  module Stable : sig","counters":[]},{"line":"    module V2 : sig","counters":[]},{"line":"      type t [@@deriving compare, equal, sexp, yojson, hash]","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  val create : statement:Statement.With_sok.t -> proof:Mina_base.Proof.t -> t","counters":[]},{"line":"","counters":[]},{"line":"  val proof : t -> Mina_base.Proof.t","counters":[]},{"line":"","counters":[]},{"line":"  val statement : t -> Statement.t","counters":[]},{"line":"","counters":[]},{"line":"  val sok_digest : t -> Sok_message.Digest.t","counters":[]},{"line":"","counters":[]},{"line":"  open Pickles_types","counters":[]},{"line":"","counters":[]},{"line":"  type tag =","counters":[]},{"line":"    ( Statement.With_sok.Checked.t","counters":[]},{"line":"    , Statement.With_sok.t","counters":[]},{"line":"    , Nat.N2.n","counters":[]},{"line":"    , Nat.N5.n )","counters":[]},{"line":"    Pickles.Tag.t","counters":[]},{"line":"","counters":[]},{"line":"  val verify :","counters":[]},{"line":"       (t * Sok_message.t) list","counters":[]},{"line":"    -> key:Pickles.Verification_key.t","counters":[]},{"line":"    -> bool Async.Deferred.t","counters":[]},{"line":"","counters":[]},{"line":"  module Verification : sig","counters":[]},{"line":"    module type S = sig","counters":[]},{"line":"      val tag : tag","counters":[]},{"line":"","counters":[]},{"line":"      val verify : (t * Sok_message.t) list -> bool Async.Deferred.t","counters":[]},{"line":"","counters":[]},{"line":"      val id : Pickles.Verification_key.Id.t Lazy.t","counters":[]},{"line":"","counters":[]},{"line":"      val verification_key : Pickles.Verification_key.t Lazy.t","counters":[]},{"line":"","counters":[]},{"line":"      val verify_against_digest : t -> bool Async.Deferred.t","counters":[]},{"line":"","counters":[]},{"line":"      val constraint_system_digests : (string * Md5_lib.t) list Lazy.t","counters":[]},{"line":"    end","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  val check_transaction :","counters":[]},{"line":"       ?preeval:bool","counters":[]},{"line":"    -> constraint_constants:Genesis_constants.Constraint_constants.t","counters":[]},{"line":"    -> sok_message:Sok_message.t","counters":[]},{"line":"    -> source:Frozen_ledger_hash.t","counters":[]},{"line":"    -> target:Frozen_ledger_hash.t","counters":[]},{"line":"    -> init_stack:Pending_coinbase.Stack.t","counters":[]},{"line":"    -> pending_coinbase_stack_state:Pending_coinbase_stack_state.t","counters":[]},{"line":"    -> zkapp_account1:Zkapp_account.t option","counters":[]},{"line":"    -> zkapp_account2:Zkapp_account.t option","counters":[]},{"line":"    -> supply_increase:Amount.Signed.t","counters":[]},{"line":"    -> Transaction.Valid.t Transaction_protocol_state.t","counters":[]},{"line":"    -> Tick.Handler.t","counters":[]},{"line":"    -> unit","counters":[]},{"line":"","counters":[]},{"line":"  val check_user_command :","counters":[]},{"line":"       constraint_constants:Genesis_constants.Constraint_constants.t","counters":[]},{"line":"    -> sok_message:Sok_message.t","counters":[]},{"line":"    -> source:Frozen_ledger_hash.t","counters":[]},{"line":"    -> target:Frozen_ledger_hash.t","counters":[]},{"line":"    -> init_stack:Pending_coinbase.Stack.t","counters":[]},{"line":"    -> pending_coinbase_stack_state:Pending_coinbase_stack_state.t","counters":[]},{"line":"    -> supply_increase:Amount.Signed.t","counters":[]},{"line":"    -> Signed_command.With_valid_signature.t Transaction_protocol_state.t","counters":[]},{"line":"    -> Tick.Handler.t","counters":[]},{"line":"    -> unit","counters":[]},{"line":"","counters":[]},{"line":"  val generate_transaction_witness :","counters":[]},{"line":"       ?preeval:bool","counters":[]},{"line":"    -> constraint_constants:Genesis_constants.Constraint_constants.t","counters":[]},{"line":"    -> sok_message:Sok_message.t","counters":[]},{"line":"    -> source:Frozen_ledger_hash.t","counters":[]},{"line":"    -> target:Frozen_ledger_hash.t","counters":[]},{"line":"    -> init_stack:Pending_coinbase.Stack.t","counters":[]},{"line":"    -> pending_coinbase_stack_state:Pending_coinbase_stack_state.t","counters":[]},{"line":"    -> zkapp_account1:Zkapp_account.t option","counters":[]},{"line":"    -> zkapp_account2:Zkapp_account.t option","counters":[]},{"line":"    -> supply_increase:Amount.Signed.t","counters":[]},{"line":"    -> Transaction.Valid.t Transaction_protocol_state.t","counters":[]},{"line":"    -> Tick.Handler.t","counters":[]},{"line":"    -> unit","counters":[]},{"line":"","counters":[]},{"line":"  module Zkapp_command_segment : sig","counters":[]},{"line":"    module Spec : sig","counters":[]},{"line":"      type single =","counters":[]},{"line":"        { auth_type : Control.Tag.t","counters":[]},{"line":"        ; is_start : [ `Yes | `No | `Compute_in_circuit ]","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"      type t = single list","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Witness = Transaction_witness.Zkapp_command_segment_witness","counters":[]},{"line":"","counters":[]},{"line":"    module Basic : sig","counters":[]},{"line":"      [%%versioned:","counters":[]},{"line":"      module Stable : sig","counters":[]},{"line":"        module V1 : sig","counters":[]},{"line":"          type t = Opt_signed_opt_signed | Opt_signed | Proved","counters":[]},{"line":"          [@@deriving sexp, yojson]","counters":[]},{"line":"        end","counters":[]},{"line":"      end]","counters":[]},{"line":"","counters":[]},{"line":"      val to_single_list : t -> Spec.single list","counters":[]},{"line":"    end","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module type S = sig","counters":[]},{"line":"    include Verification.S","counters":[]},{"line":"","counters":[]},{"line":"    val constraint_constants : Genesis_constants.Constraint_constants.t","counters":[]},{"line":"","counters":[]},{"line":"    val cache_handle : Pickles.Cache_handle.t","counters":[]},{"line":"","counters":[]},{"line":"    val of_non_zkapp_command_transaction :","counters":[]},{"line":"         statement:Statement.With_sok.t","counters":[]},{"line":"      -> init_stack:Pending_coinbase.Stack.t","counters":[]},{"line":"      -> Transaction.Valid.t Transaction_protocol_state.t","counters":[]},{"line":"      -> Tick.Handler.t","counters":[]},{"line":"      -> t Async.Deferred.t","counters":[]},{"line":"","counters":[]},{"line":"    val of_user_command :","counters":[]},{"line":"         statement:Statement.With_sok.t","counters":[]},{"line":"      -> init_stack:Pending_coinbase.Stack.t","counters":[]},{"line":"      -> Signed_command.With_valid_signature.t Transaction_protocol_state.t","counters":[]},{"line":"      -> Tick.Handler.t","counters":[]},{"line":"      -> t Async.Deferred.t","counters":[]},{"line":"","counters":[]},{"line":"    val of_fee_transfer :","counters":[]},{"line":"         statement:Statement.With_sok.t","counters":[]},{"line":"      -> init_stack:Pending_coinbase.Stack.t","counters":[]},{"line":"      -> Fee_transfer.t Transaction_protocol_state.t","counters":[]},{"line":"      -> Tick.Handler.t","counters":[]},{"line":"      -> t Async.Deferred.t","counters":[]},{"line":"","counters":[]},{"line":"    val of_zkapp_command_segment_exn :","counters":[]},{"line":"         statement:Statement.With_sok.t","counters":[]},{"line":"      -> witness:Zkapp_command_segment.Witness.t","counters":[]},{"line":"      -> spec:Zkapp_command_segment.Basic.t","counters":[]},{"line":"      -> t Async.Deferred.t","counters":[]},{"line":"","counters":[]},{"line":"    val merge :","counters":[]},{"line":"      t -> t -> sok_digest:Sok_message.Digest.t -> t Async.Deferred.Or_error.t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  (** [zkapp_command_witnesses_exn ledger zkapp_commands] generates the zkapp_command segment witnesses","counters":[]},{"line":"      and corresponding statements needed to prove the application of each","counters":[]},{"line":"      zkapp_command transaction in [zkapp_commands] on top of ledger. If multiple zkapp_command are","counters":[]},{"line":"      given, they are applied in order and grouped together to minimise the","counters":[]},{"line":"      number of transaction proofs that would be required.","counters":[]},{"line":"      There must be at least one zkapp_command transaction in [zkapp_command].","counters":[]},{"line":"","counters":[]},{"line":"      The returned value is a list of tuples, each corresponding to a single","counters":[]},{"line":"      proof for some parts of some zkapp_command transactions, comprising:","counters":[]},{"line":"      * the witness information for the segment, to be passed to the prover","counters":[]},{"line":"      * the segment kind, identifying the type of proof that will be generated","counters":[]},{"line":"      * the proof statement, describing the transition between the states before","counters":[]},{"line":"      and after the segment","counters":[]},{"line":"      * the list of calculated 'snapp statements', corresponding to the expected","counters":[]},{"line":"      public input of any snapp zkapp_command in the current segment.","counters":[]},{"line":"","counters":[]},{"line":"      WARNING: This function calls the transaction logic internally, and thus may","counters":[]},{"line":"      raise an exception if the transaction logic would also do so. This function","counters":[]},{"line":"      should only be used on zkapp_command that are already known to pass transaction","counters":[]},{"line":"      logic without an exception.","counters":[]},{"line":"   *)","counters":[]},{"line":"  val zkapp_command_witnesses_exn :","counters":[]},{"line":"       constraint_constants:Genesis_constants.Constraint_constants.t","counters":[]},{"line":"    -> state_body:Transaction_protocol_state.Block_data.t","counters":[]},{"line":"    -> fee_excess:Currency.Amount.Signed.t","counters":[]},{"line":"    -> [ `Ledger of Mina_ledger.Ledger.t","counters":[]},{"line":"       | `Sparse_ledger of Mina_ledger.Sparse_ledger.t ]","counters":[]},{"line":"    -> ( [ `Pending_coinbase_init_stack of Pending_coinbase.Stack.t ]","counters":[]},{"line":"       * [ `Pending_coinbase_of_statement of Pending_coinbase_stack_state.t ]","counters":[]},{"line":"       * Zkapp_command.t )","counters":[]},{"line":"       list","counters":[]},{"line":"    -> ( Zkapp_command_segment.Witness.t","counters":[]},{"line":"       * Zkapp_command_segment.Basic.t","counters":[]},{"line":"       * Statement.With_sok.t )","counters":[]},{"line":"       list","counters":[]},{"line":"       * Mina_ledger.Sparse_ledger.t","counters":[]},{"line":"","counters":[]},{"line":"  module Make (Inputs : sig","counters":[]},{"line":"    val constraint_constants : Genesis_constants.Constraint_constants.t","counters":[]},{"line":"","counters":[]},{"line":"    val proof_level : Genesis_constants.Proof_level.t","counters":[]},{"line":"  end) : S","counters":[]},{"line":"  [@@warning \"-67\"]","counters":[]},{"line":"","counters":[]},{"line":"  val constraint_system_digests :","counters":[]},{"line":"       constraint_constants:Genesis_constants.Constraint_constants.t","counters":[]},{"line":"    -> unit","counters":[]},{"line":"    -> (string * Md5.t) list","counters":[]},{"line":"","counters":[]},{"line":"  (* Every circuit must have at least 1 of each type of constraint.","counters":[]},{"line":"     This function can be used to add the missing constraints *)","counters":[]},{"line":"  val dummy_constraints : unit -> unit Tick.Checked.t","counters":[]},{"line":"","counters":[]},{"line":"  module Base : sig","counters":[]},{"line":"    val check_timing :","counters":[]},{"line":"         balance_check:(Tick.Boolean.var -> unit Tick.Checked.t)","counters":[]},{"line":"      -> timed_balance_check:(Tick.Boolean.var -> unit Tick.Checked.t)","counters":[]},{"line":"      -> account:","counters":[]},{"line":"           ( 'b","counters":[]},{"line":"           , 'c","counters":[]},{"line":"           , 'd","counters":[]},{"line":"           , 'e","counters":[]},{"line":"           , Currency.Balance.var","counters":[]},{"line":"           , 'f","counters":[]},{"line":"           , 'g","counters":[]},{"line":"           , 'h","counters":[]},{"line":"           , 'i","counters":[]},{"line":"           , ( Tick.Boolean.var","counters":[]},{"line":"             , Mina_numbers.Global_slot.Checked.var","counters":[]},{"line":"             , Currency.Balance.var","counters":[]},{"line":"             , Currency.Amount.var )","counters":[]},{"line":"             Account_timing.As_record.t","counters":[]},{"line":"           , 'j","counters":[]},{"line":"           , 'k )","counters":[]},{"line":"           Account.Poly.t","counters":[]},{"line":"      -> txn_amount:Currency.Amount.var option","counters":[]},{"line":"      -> txn_global_slot:Mina_numbers.Global_slot.Checked.var","counters":[]},{"line":"      -> ( [> `Min_balance of Currency.Balance.var ]","counters":[]},{"line":"         * ( Tick.Boolean.var","counters":[]},{"line":"           , Mina_numbers.Global_slot.Checked.var","counters":[]},{"line":"           , Currency.Balance.var","counters":[]},{"line":"           , Currency.Amount.var )","counters":[]},{"line":"           Account_timing.As_record.t )","counters":[]},{"line":"         Tick.Checked.t","counters":[]},{"line":"","counters":[]},{"line":"    module Zkapp_command_snark : sig","counters":[]},{"line":"      val main :","counters":[]},{"line":"           ?witness:Zkapp_command_segment.Witness.t","counters":[]},{"line":"        -> Zkapp_command_segment.Spec.t","counters":[]},{"line":"        -> constraint_constants:Genesis_constants.Constraint_constants.t","counters":[]},{"line":"        -> Statement.With_sok.var","counters":[]},{"line":"        -> Zkapp_statement.Checked.t option","counters":[]},{"line":"    end","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module For_tests : sig","counters":[]},{"line":"    module Deploy_snapp_spec : sig","counters":[]},{"line":"      type t =","counters":[]},{"line":"        { fee : Currency.Fee.t","counters":[]},{"line":"        ; sender : Signature_lib.Keypair.t * Mina_base.Account.Nonce.t","counters":[]},{"line":"        ; fee_payer :","counters":[]},{"line":"            (Signature_lib.Keypair.t * Mina_base.Account.Nonce.t) option","counters":[]},{"line":"        ; amount : Currency.Amount.t","counters":[]},{"line":"        ; zkapp_account_keypairs : Signature_lib.Keypair.t list","counters":[]},{"line":"        ; memo : Signed_command_memo.t","counters":[]},{"line":"        ; new_zkapp_account : bool","counters":[]},{"line":"        ; snapp_update : Account_update.Update.t","counters":[]},{"line":"              (* Authorization for the update being performed *)","counters":[]},{"line":"        ; preconditions : Account_update.Preconditions.t option","counters":[]},{"line":"        ; authorization_kind : Account_update.Authorization_kind.t","counters":[]},{"line":"        }","counters":[]},{"line":"      [@@deriving sexp]","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    val deploy_snapp :","counters":[]},{"line":"         ?no_auth:bool","counters":[]},{"line":"      -> constraint_constants:Genesis_constants.Constraint_constants.t","counters":[]},{"line":"      -> Deploy_snapp_spec.t","counters":[]},{"line":"      -> Zkapp_command.t","counters":[]},{"line":"","counters":[]},{"line":"    module Update_states_spec : sig","counters":[]},{"line":"      type t =","counters":[]},{"line":"        { fee : Currency.Fee.t","counters":[]},{"line":"        ; sender : Signature_lib.Keypair.t * Mina_base.Account.Nonce.t","counters":[]},{"line":"        ; fee_payer :","counters":[]},{"line":"            (Signature_lib.Keypair.t * Mina_base.Account.Nonce.t) option","counters":[]},{"line":"        ; receivers :","counters":[]},{"line":"            (Signature_lib.Public_key.Compressed.t * Currency.Amount.t) list","counters":[]},{"line":"        ; amount : Currency.Amount.t","counters":[]},{"line":"        ; zkapp_account_keypairs : Signature_lib.Keypair.t list","counters":[]},{"line":"        ; memo : Signed_command_memo.t","counters":[]},{"line":"        ; new_zkapp_account : bool","counters":[]},{"line":"        ; snapp_update : Account_update.Update.t","counters":[]},{"line":"              (* Authorization for the update being performed *)","counters":[]},{"line":"        ; current_auth : Permissions.Auth_required.t","counters":[]},{"line":"        ; sequence_events : Tick.Field.t array list","counters":[]},{"line":"        ; events : Tick.Field.t array list","counters":[]},{"line":"        ; call_data : Tick.Field.t","counters":[]},{"line":"        ; preconditions : Account_update.Preconditions.t option","counters":[]},{"line":"        }","counters":[]},{"line":"      [@@deriving sexp]","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    val update_states :","counters":[]},{"line":"         ?zkapp_prover:","counters":[]},{"line":"           ( unit","counters":[]},{"line":"           , unit","counters":[]},{"line":"           , unit","counters":[]},{"line":"           , Zkapp_statement.t","counters":[]},{"line":"           , (unit * unit * (Nat.N2.n, Nat.N2.n) Pickles.Proof.t)","counters":[]},{"line":"             Async.Deferred.t )","counters":[]},{"line":"           Pickles.Prover.t","counters":[]},{"line":"      -> constraint_constants:Genesis_constants.Constraint_constants.t","counters":[]},{"line":"      -> Update_states_spec.t","counters":[]},{"line":"      -> Zkapp_command.t Async.Deferred.t","counters":[]},{"line":"","counters":[]},{"line":"    val create_trivial_predicate_snapp :","counters":[]},{"line":"         constraint_constants:Genesis_constants.Constraint_constants.t","counters":[]},{"line":"      -> ?protocol_state_predicate:Zkapp_precondition.Protocol_state.t","counters":[]},{"line":"      -> snapp_kp:Signature_lib.Keypair.t","counters":[]},{"line":"      -> Mina_transaction_logic.For_tests.Transaction_spec.t","counters":[]},{"line":"      -> Mina_ledger.Ledger.t","counters":[]},{"line":"      -> Zkapp_command.t Async.Deferred.t","counters":[]},{"line":"","counters":[]},{"line":"    val trivial_zkapp_account :","counters":[]},{"line":"         ?permissions:Permissions.t","counters":[]},{"line":"      -> vk:(Side_loaded_verification_key.t, Tick.Field.t) With_hash.t","counters":[]},{"line":"      -> Account.key","counters":[]},{"line":"      -> Account.t","counters":[]},{"line":"","counters":[]},{"line":"    val create_trivial_zkapp_account :","counters":[]},{"line":"         ?permissions:Permissions.t","counters":[]},{"line":"      -> vk:(Side_loaded_verification_key.t, Tick.Field.t) With_hash.t","counters":[]},{"line":"      -> ledger:Mina_ledger.Ledger.t","counters":[]},{"line":"      -> Account.key","counters":[]},{"line":"      -> unit","counters":[]},{"line":"","counters":[]},{"line":"    val create_trivial_snapp :","counters":[]},{"line":"         constraint_constants:Genesis_constants.Constraint_constants.t","counters":[]},{"line":"      -> unit","counters":[]},{"line":"      -> [> `VK of (Side_loaded_verification_key.t, Tick.Field.t) With_hash.t ]","counters":[]},{"line":"         * [> `Prover of","counters":[]},{"line":"              ( unit","counters":[]},{"line":"              , unit","counters":[]},{"line":"              , unit","counters":[]},{"line":"              , Zkapp_statement.t","counters":[]},{"line":"              , (unit * unit * (Nat.N2.n, Nat.N2.n) Pickles.Proof.t)","counters":[]},{"line":"                Async.Deferred.t )","counters":[]},{"line":"              Pickles.Prover.t ]","counters":[]},{"line":"","counters":[]},{"line":"    module Multiple_transfers_spec : sig","counters":[]},{"line":"      type t =","counters":[]},{"line":"        { fee : Currency.Fee.t","counters":[]},{"line":"        ; sender : Signature_lib.Keypair.t * Mina_base.Account.Nonce.t","counters":[]},{"line":"        ; fee_payer :","counters":[]},{"line":"            (Signature_lib.Keypair.t * Mina_base.Account.Nonce.t) option","counters":[]},{"line":"        ; receivers :","counters":[]},{"line":"            (Signature_lib.Public_key.Compressed.t * Currency.Amount.t) list","counters":[]},{"line":"        ; amount : Currency.Amount.t","counters":[]},{"line":"        ; zkapp_account_keypairs : Signature_lib.Keypair.t list","counters":[]},{"line":"        ; memo : Signed_command_memo.t","counters":[]},{"line":"        ; new_zkapp_account : bool","counters":[]},{"line":"        ; snapp_update : Account_update.Update.t","counters":[]},{"line":"              (* Authorization for the update being performed *)","counters":[]},{"line":"        ; sequence_events : Tick.Field.t array list","counters":[]},{"line":"        ; events : Tick.Field.t array list","counters":[]},{"line":"        ; call_data : Tick.Field.t","counters":[]},{"line":"        ; preconditions : Account_update.Preconditions.t option","counters":[]},{"line":"        }","counters":[]},{"line":"      [@@deriving sexp]","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    val multiple_transfers : Multiple_transfers_spec.t -> Zkapp_command.t","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}