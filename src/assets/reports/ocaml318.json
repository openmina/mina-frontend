{"filename":"src/lib/trust_system/peer_trust.ml","lines":[{"line":"open Core","counters":[]},{"line":"open Async_kernel","counters":[]},{"line":"open Pipe_lib","counters":[]},{"line":"","counters":[]},{"line":"let tmp_bans_are_disabled = false","counters":[]},{"line":"","counters":[]},{"line":"module Trust_response = struct","counters":[]},{"line":"  type t = Insta_ban | Trust_increase of float | Trust_decrease of float","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type Action_intf = sig","counters":[]},{"line":"  type t","counters":[]},{"line":"","counters":[]},{"line":"  val to_trust_response : t -> Trust_response.t","counters":[]},{"line":"","counters":[]},{"line":"  val to_log : t -> string * (string, Yojson.Safe.t) List.Assoc.t","counters":[]},{"line":"","counters":[]},{"line":"  val is_reason_for_heartbeat : t -> bool","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let max_rate secs =","counters":[]},{"line":"  let interval = 1. /. secs in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  (* The amount of trust that decays in `interval` seconds, when we're at the","counters":[]},{"line":"     ban threshold (-1) *)","counters":[]},{"line":"  1. -. (Record.decay_rate ** interval)","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"","counters":[]},{"line":"module type Input_intf = sig","counters":[]},{"line":"  module Peer_id : sig","counters":[]},{"line":"    type t [@@deriving sexp, to_yojson]","counters":[]},{"line":"","counters":[]},{"line":"    val ip : t -> Unix.Inet_addr.Blocking_sexp.t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Now : sig","counters":[]},{"line":"    val now : unit -> Time.t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Config : sig","counters":[]},{"line":"    type t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Db :","counters":[]},{"line":"    Key_value_database.Intf.Ident","counters":[]},{"line":"      with type key := Peer_id.t","counters":[]},{"line":"       and type value := Record.t","counters":[]},{"line":"       and type config := Config.t","counters":[]},{"line":"","counters":[]},{"line":"  module Action : Action_intf","counters":[]},{"line":"","counters":[]},{"line":"  type Structured_log_events.t +=","counters":[]},{"line":"    | Peer_banned of","counters":[]},{"line":"        { sender_id : Peer_id.t; expiration : Time.t; action : string }","counters":[]},{"line":"    [@@deriving register_event]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Time_with_json = struct","counters":[]},{"line":"  include Time","counters":[]},{"line":"","counters":[]},{"line":"  let to_yojson expiration =","counters":[]},{"line":"    `String (Time.to_string_abs expiration ~zone:Time.Zone.utc)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"","counters":[]},{"line":"  let of_yojson = function","counters":[]},{"line":"    | `String time ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Ok","counters":[]},{"line":"          (Time.of_string_gen ~if_no_timezone:(`Use_this_one Time.Zone.utc) time)","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"    | _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Error \"Trust_system.Peer_trust: Could not parse time\"","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let ban_message =","counters":[]},{"line":"  if tmp_bans_are_disabled then","counters":[]},{"line":"    \"Would ban peer $sender_id until $expiration due to $action, refusing due \\","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"     to trust system being disabled\"","counters":[]},{"line":"  else \"Banning peer $sender_id until $expiration due to $action\"","counters":[{"col_start":7,"col_end":7,"count":1}]},{"line":"","counters":[]},{"line":"module Log_events = struct","counters":[]},{"line":"  (* TODO: Split per action. *)","counters":[]},{"line":"  type Structured_log_events.t +=","counters":[]},{"line":"    | Peer_banned of","counters":[]},{"line":"        { sender_id : Network_peer.Peer.t","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"        ; expiration : Time_with_json.t","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"        ; action : string","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"        }","counters":[]},{"line":"    [@@deriving register_event { msg = ban_message }]","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":29,"col_end":29,"count":4}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"include Log_events","counters":[]},{"line":"","counters":[]},{"line":"module Make0 (Inputs : Input_intf) = struct","counters":[]},{"line":"  open Inputs","counters":[]},{"line":"","counters":[]},{"line":"  type upcall_msg_t = [ `Ban of Peer_id.t * Time.t | `Heartbeat of Peer_id.t ]","counters":[]},{"line":"","counters":[]},{"line":"  type t =","counters":[]},{"line":"    { db : Db.t option","counters":[]},{"line":"          (* This is an option to allow using a fake trust system in tests. This is","counters":[]},{"line":"             ugly, but the alternative is functoring half of Coda over the trust","counters":[]},{"line":"             system. *)","counters":[]},{"line":"    ; upcall_reader : upcall_msg_t Strict_pipe.Reader.t","counters":[]},{"line":"    ; upcall_writer :","counters":[]},{"line":"        ( upcall_msg_t","counters":[]},{"line":"        , Strict_pipe.synchronous","counters":[]},{"line":"        , unit Deferred.t )","counters":[]},{"line":"        Strict_pipe.Writer.t","counters":[]},{"line":"    ; mutable actions_writers : (Action.t * Peer_id.t) Pipe.Writer.t list","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  module Record_inst = Record.Make (Now)","counters":[]},{"line":"","counters":[]},{"line":"  let create db_dir =","counters":[]},{"line":"    let reader, writer = Strict_pipe.create Strict_pipe.Synchronous in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    { db = Some (Db.create db_dir)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"    ; upcall_reader = reader","counters":[]},{"line":"    ; upcall_writer = writer","counters":[]},{"line":"    ; actions_writers = []","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let null : unit -> t =","counters":[]},{"line":"   fun () ->","counters":[]},{"line":"    let upcall_reader, upcall_writer =","counters":[{"col_start":4,"col_end":4,"count":1}]},{"line":"      Strict_pipe.create Strict_pipe.Synchronous","counters":[]},{"line":"    in","counters":[]},{"line":"    { db = None; upcall_reader; upcall_writer; actions_writers = [] }","counters":[{"col_start":4,"col_end":4,"count":1}]},{"line":"","counters":[]},{"line":"  let upcall_pipe { upcall_reader; _ } = upcall_reader","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"","counters":[]},{"line":"  let get_db { db; _ } peer =","counters":[]},{"line":"    Option.bind db ~f:(fun db' -> Db.get db' ~key:peer)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"","counters":[]},{"line":"  let peer_statuses { db; _ } =","counters":[]},{"line":"    Option.value_map db ~default:[] ~f:(fun db' ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        Db.to_alist db'","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        |> List.map ~f:(fun (peer, record) ->","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"               (peer, Record_inst.to_peer_status record) ) )","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"","counters":[]},{"line":"  let lookup_ip t ip =","counters":[]},{"line":"    List.filter (peer_statuses t) ~f:(fun (p, _status) ->","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"        Unix.Inet_addr.equal (Peer_id.ip p) ip )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"  let reset_ip ({ db; _ } as t) ip =","counters":[]},{"line":"    Option.value_map db ~default:() ~f:(fun db' ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        List.map","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ~f:(fun (id, _status) -> Db.remove db' ~key:id)","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"          (lookup_ip t ip)","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"        |> ignore ) ;","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"    lookup_ip t ip","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let close { db; upcall_writer; _ } =","counters":[]},{"line":"    Option.iter db ~f:Db.close ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Strict_pipe.Writer.close upcall_writer","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let record ({ db; upcall_writer; _ } as t) logger peer action =","counters":[]},{"line":"    t.actions_writers <-","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      List.filter t.actions_writers ~f:(Fn.compose not Pipe.is_closed) ;","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"    List.iter t.actions_writers","counters":[]},{"line":"      ~f:(Fn.flip Pipe.write_without_pushback (action, peer)) ;","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"    let old_record =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      match get_db t peer with","counters":[]},{"line":"      | None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Record_inst.init ()","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"      | Some trust_record ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          trust_record","counters":[]},{"line":"    in","counters":[]},{"line":"    let%bind () =","counters":[]},{"line":"      if Action.is_reason_for_heartbeat action then","counters":[]},{"line":"        Strict_pipe.Writer.write upcall_writer (`Heartbeat peer)","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"      else Deferred.unit","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"    in","counters":[]},{"line":"    let new_record =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      match Action.to_trust_response action with","counters":[]},{"line":"      | Insta_ban ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Record_inst.ban old_record","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"      | Trust_increase incr ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          if Float.is_positive incr then Record_inst.add_trust old_record incr","counters":[{"col_start":41,"col_end":41,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"          else old_record","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"      | Trust_decrease incr ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (* TODO: Sometimes this is NaN for why we don't know *)","counters":[]},{"line":"          if Float.is_positive incr then","counters":[]},{"line":"            Record_inst.add_trust old_record (-.incr)","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"          else old_record","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"    in","counters":[]},{"line":"    let simple_old = Record_inst.to_peer_status old_record in","counters":[]},{"line":"    let simple_new = Record_inst.to_peer_status new_record in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let action_fmt, action_metadata = Action.to_log action in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let log_trust_change () =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let verb =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        if Float.(simple_new.trust > simple_old.trust) then \"Increasing\"","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"        else \"Decreasing\"","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"      in","counters":[]},{"line":"      [%log debug]","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"        ~metadata:([ (\"sender_id\", Peer_id.to_yojson peer) ] @ action_metadata)","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"        \"%s trust for peer $sender_id due to %s. New trust is %f.\" verb","counters":[]},{"line":"        action_fmt simple_new.trust","counters":[]},{"line":"    in","counters":[]},{"line":"    let%map () =","counters":[]},{"line":"      match (simple_old.banned, simple_new.banned) with","counters":[]},{"line":"      | Unbanned, Banned_until expiration ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          [%str_log faulty_peer_without_punishment] ~metadata:action_metadata","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"            (Peer_banned { sender_id = peer; expiration; action = action_fmt }) ;","counters":[]},{"line":"          if Option.is_some db then (","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"            Mina_metrics.Gauge.inc_one Mina_metrics.Trust_system.banned_peers ;","counters":[]},{"line":"            if tmp_bans_are_disabled then Deferred.unit","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"            else Strict_pipe.Writer.write upcall_writer (`Ban (peer, expiration))","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"            )","counters":[]},{"line":"          else Deferred.unit","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"      | Banned_until _, Unbanned ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Mina_metrics.Gauge.dec_one Mina_metrics.Trust_system.banned_peers ;","counters":[]},{"line":"          log_trust_change () ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          Deferred.unit","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"      | _, _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          log_trust_change () ; Deferred.unit","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"    in","counters":[]},{"line":"    Option.iter db ~f:(fun db' -> Db.set db' ~key:peer ~data:new_record)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"","counters":[]},{"line":"  module For_tests = struct","counters":[]},{"line":"    let get_action_pipe : t -> (Action.t * Peer_id.t) Pipe.Reader.t =","counters":[]},{"line":"     fun t ->","counters":[]},{"line":"      let reader, writer = Pipe.create () in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      t.actions_writers <- writer :: t.actions_writers ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      reader","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let%test_module \"peer_trust\" =","counters":[]},{"line":"  ( module struct","counters":[]},{"line":"    (* Mock the current time *)","counters":[]},{"line":"    module Mock_now = struct","counters":[]},{"line":"      let current_time = ref Time.epoch","counters":[]},{"line":"","counters":[]},{"line":"      let now () = !current_time","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"","counters":[]},{"line":"      let advance span = current_time := Time.add !current_time span","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Mock_record = Record.Make (Mock_now)","counters":[]},{"line":"    module Db = Key_value_database.Make_mock (Int) (Record)","counters":[]},{"line":"","counters":[]},{"line":"    module Peer_id = struct","counters":[]},{"line":"      type t = int [@@deriving sexp, yojson]","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"","counters":[]},{"line":"      let ip t = Unix.Inet_addr.of_string (sprintf \"127.0.0.%d\" t)","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Action = struct","counters":[]},{"line":"      type t = Insta_ban | Slow_punish | Slow_credit | Big_credit","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"      [@@deriving compare, sexp, yojson]","counters":[]},{"line":"","counters":[]},{"line":"      let to_trust_response t =","counters":[]},{"line":"        match t with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | Insta_ban ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Trust_response.Insta_ban","counters":[]},{"line":"        | Slow_punish ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Trust_response.Trust_decrease (max_rate 1.)","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"        | Slow_credit ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Trust_response.Trust_increase (max_rate 1.)","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"        | Big_credit ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Trust_response.Trust_increase 0.2","counters":[]},{"line":"","counters":[]},{"line":"      let to_log t = (string_of_sexp @@ sexp_of_t t, [])","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"","counters":[]},{"line":"      let is_reason_for_heartbeat _ = false","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Peer_trust_test = Make0 (struct","counters":[]},{"line":"      module Peer_id = Peer_id","counters":[]},{"line":"      module Now = Mock_now","counters":[]},{"line":"      module Config = Unit","counters":[]},{"line":"      module Db = Db","counters":[]},{"line":"      module Action = Action","counters":[]},{"line":"","counters":[]},{"line":"      type Structured_log_events.t +=","counters":[]},{"line":"        | Peer_banned of","counters":[]},{"line":"            { sender_id : Peer_id.t","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"            ; expiration : Time_with_json.t","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"            ; action : string","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"            }","counters":[]},{"line":"        [@@deriving register_event { msg = \"Peer banned\" }]","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"    end)","counters":[]},{"line":"","counters":[]},{"line":"    (* We want to check the output of the pipe in these tests, but it's","counters":[]},{"line":"       synchronous, so we need to read from it in a different \"thread\",","counters":[]},{"line":"       otherwise it would hang. *)","counters":[]},{"line":"    let upcall_pipe_out = ref []","counters":[]},{"line":"","counters":[]},{"line":"    let assert_upcall_pipe expected =","counters":[]},{"line":"      [%test_eq: int list] expected","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"        (List.map !upcall_pipe_out ~f:(fun (peer, _banned_until) -> peer)) ;","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"      upcall_pipe_out := []","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let setup_mock_db () =","counters":[]},{"line":"      let res = Peer_trust_test.create () in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      don't_wait_for","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      @@ Strict_pipe.Reader.iter_without_pushback res.upcall_reader","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"           ~f:(fun v_ext ->","counters":[]},{"line":"             match v_ext with","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"             | `Ban v ->","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                 upcall_pipe_out := v :: !upcall_pipe_out","counters":[]},{"line":"             | _ ->","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                 failwith \"unexpected case in setup_mock_db\" ) ;","counters":[]},{"line":"      res","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let nolog = Logger.null ()","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"","counters":[]},{"line":"    let ip_of_id id = Unix.Inet_addr.of_string (sprintf \"127.0.0.%d\" id)","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"","counters":[]},{"line":"    let peer0 = ip_of_id 0","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"    let%test \"Peers are not present in the db on initialization and have no \\","counters":[]},{"line":"              statuss\" =","counters":[]},{"line":"      let db = setup_mock_db () in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      match Peer_trust_test.lookup_ip db peer0 with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | [] ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          assert_upcall_pipe [] ; true","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"      | _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          false","counters":[]},{"line":"","counters":[]},{"line":"    let%test \"Insta-bans actually do so\" =","counters":[]},{"line":"      if tmp_bans_are_disabled then true","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"      else","counters":[]},{"line":"        Run_in_thread.block_on_async_exn (fun () ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            let db = setup_mock_db () in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let%map () = Peer_trust_test.record db nolog 0 Insta_ban in","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"            match Peer_trust_test.lookup_ip db peer0 with","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            | [ (_, { trust = -1.0; banned = Banned_until time }) ] ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                [%test_eq: Time.t] time","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                @@ Time.add !Mock_now.current_time Time.Span.day ;","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                assert_upcall_pipe [ 0 ] ;","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                true","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"            | _ ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                false )","counters":[]},{"line":"","counters":[]},{"line":"    let%test \"trust decays by half in 24 hours\" =","counters":[]},{"line":"      Run_in_thread.block_on_async_exn (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          let db = setup_mock_db () in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let%map () = Peer_trust_test.record db nolog 0 Action.Big_credit in","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"          match Peer_trust_test.lookup_ip db peer0 with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | [ (_, { trust = start_trust; banned = Unbanned }) ] -> (","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Mock_now.advance Time.Span.day ;","counters":[]},{"line":"              assert_upcall_pipe [] ;","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              match Peer_trust_test.lookup_ip db peer0 with","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              | [ (_, { trust = decayed_trust; banned = Unbanned }) ] ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  (* N.b. the floating point equality operator has a built in","counters":[]},{"line":"                     tolerance i.e. it's approximate equality.","counters":[]},{"line":"                  *)","counters":[]},{"line":"                  Float.(decayed_trust =. start_trust /. 2.0)","counters":[]},{"line":"              | _ ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  false )","counters":[]},{"line":"          | _ ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              false )","counters":[]},{"line":"","counters":[]},{"line":"    let do_constant_rate rate f =","counters":[]},{"line":"      (* Simulate running the function at the specified rate, in actions/sec,","counters":[]},{"line":"         for a week. *)","counters":[]},{"line":"      let instances = Float.to_int @@ (60. *. 60. *. 24. *. 7. *. rate) in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let rec go n =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        if n < instances then (","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let%bind () = f () in","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"          Mock_now.advance Time.Span.(second / rate) ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          go (n + 1) )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        else Deferred.unit","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"      in","counters":[]},{"line":"      go 0","counters":[]},{"line":"","counters":[]},{"line":"    let act_constant_rate db rate act =","counters":[]},{"line":"      (* simulate performing an action at the specified rate for a week *)","counters":[]},{"line":"      do_constant_rate rate (fun () -> Peer_trust_test.record db nolog 0 act)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"    let%test \"peers don't get banned for acting at the maximum rate\" =","counters":[]},{"line":"      Run_in_thread.block_on_async_exn (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          let db = setup_mock_db () in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let%map () = act_constant_rate db 1. Action.Slow_punish in","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"          match Peer_trust_test.lookup_ip db peer0 with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | [ (_, { banned = Banned_until _; _ }) ] ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              false","counters":[]},{"line":"          | [ (_, { banned = Unbanned; _ }) ] ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              assert_upcall_pipe [] ; true","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"          | _ ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              false )","counters":[]},{"line":"","counters":[]},{"line":"    let%test \"peers do get banned for acting faster than the maximum rate\" =","counters":[]},{"line":"      if tmp_bans_are_disabled then true","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"      else","counters":[]},{"line":"        Run_in_thread.block_on_async_exn (fun () ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            let db = setup_mock_db () in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let%map () = act_constant_rate db 1.1 Action.Slow_punish in","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"            match Peer_trust_test.lookup_ip db peer0 with","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            | [ (_, { banned = Banned_until _; _ }) ] ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                assert_upcall_pipe [ 0 ] ;","counters":[]},{"line":"                true","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"            | [ (_, { banned = Unbanned; _ }) ] ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                false","counters":[]},{"line":"            | _ ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                false )","counters":[]},{"line":"","counters":[]},{"line":"    let%test \"good cancels bad\" =","counters":[]},{"line":"      Run_in_thread.block_on_async_exn (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          let db = setup_mock_db () in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let%map () =","counters":[]},{"line":"            do_constant_rate 1.1 (fun () ->","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                let%bind () =","counters":[]},{"line":"                  Peer_trust_test.record db nolog 0 Action.Slow_punish","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"                in","counters":[]},{"line":"                Peer_trust_test.record db nolog 0 Action.Slow_credit )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"          in","counters":[]},{"line":"          match Peer_trust_test.lookup_ip db peer0 with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | [ (_, { banned = Banned_until _; _ }) ] ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              false","counters":[]},{"line":"          | [ (_, { banned = Unbanned; _ }) ] ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              assert_upcall_pipe [] ; true","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"          | _ ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              false )","counters":[]},{"line":"","counters":[]},{"line":"    let%test \"insta-bans ignore positive trust\" =","counters":[]},{"line":"      if tmp_bans_are_disabled then true","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"      else","counters":[]},{"line":"        Run_in_thread.block_on_async_exn (fun () ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            let db = setup_mock_db () in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let%bind () = act_constant_rate db 1. Action.Big_credit in","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"            ( match Peer_trust_test.lookup_ip db peer0 with","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            | [ (_, { trust; banned = Unbanned }) ] ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                assert (Float.(trust > 0.99)) ;","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                assert_upcall_pipe []","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"            | [ (_, { banned = Banned_until _; _ }) ] ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                failwith \"Peer is banned after credits\"","counters":[]},{"line":"            | _ ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                failwith \"unexpected amount of peers\" ) ;","counters":[]},{"line":"            let%map () = Peer_trust_test.record db nolog 0 Action.Insta_ban in","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"            match Peer_trust_test.lookup_ip db peer0 with","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            | [ (_, { trust = -1.0; banned = Banned_until _ }) ] ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                assert_upcall_pipe [ 0 ] ;","counters":[]},{"line":"                true","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"            | [ (_, { banned = Banned_until _; _ }) ] ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                failwith \"Trust not set to -1\"","counters":[]},{"line":"            | [ (_, { banned = Unbanned; _ }) ] ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                failwith \"Peer not banned\"","counters":[]},{"line":"            | _ ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                false )","counters":[]},{"line":"","counters":[]},{"line":"    let%test \"multiple peers getting banned causes multiple ban events\" =","counters":[]},{"line":"      if tmp_bans_are_disabled then true","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"      else","counters":[]},{"line":"        Run_in_thread.block_on_async_exn (fun () ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            let db = setup_mock_db () in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let%bind () = Peer_trust_test.record db nolog 0 Action.Insta_ban in","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"            let%map () = Peer_trust_test.record db nolog 1 Action.Insta_ban in","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"            assert_upcall_pipe [ 1; 0 ]","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            (* Reverse order since it's a snoc list. *) ;","counters":[]},{"line":"            true )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"actions are written to the pipe\" =","counters":[]},{"line":"      Run_in_thread.block_on_async_exn (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          let db = setup_mock_db () in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let pipe = Peer_trust_test.For_tests.get_action_pipe db in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let%bind () = Peer_trust_test.record db nolog 0 Action.Insta_ban in","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"          let%bind () = Peer_trust_test.record db nolog 1 Action.Big_credit in","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"          let%bind () = Peer_trust_test.record db nolog 1 Action.Slow_credit in","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"          match%bind Pipe.read_exactly pipe ~num_values:3 with","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"          | `Exactly queue ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              [%test_eq: (Action.t * int) list]","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"                Action.[ (Insta_ban, 0); (Big_credit, 1); (Slow_credit, 1) ]","counters":[]},{"line":"                (Queue.to_list queue) ;","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"              Pipe.close_read pipe ;","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              let%bind () =","counters":[]},{"line":"                Peer_trust_test.record db nolog 2 Action.Insta_ban","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"              in","counters":[]},{"line":"              assert (List.is_empty db.actions_writers) ;","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"              Deferred.unit","counters":[]},{"line":"          | _ ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              failwith \"wrong number of actions written to pipe\" )","counters":[]},{"line":"  end )","counters":[]},{"line":"","counters":[]},{"line":"module Make (Action : Action_intf) = Make0 (struct","counters":[]},{"line":"  module Peer_id = Network_peer.Peer","counters":[]},{"line":"","counters":[]},{"line":"  module Now = struct","counters":[]},{"line":"    let now = Time.now","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Config = String","counters":[]},{"line":"  module Db =","counters":[]},{"line":"    Rocksdb.Serializable.Make","counters":[]},{"line":"      (Network_peer.Peer.Stable.Latest)","counters":[]},{"line":"      (Record.Stable.Latest)","counters":[]},{"line":"  module Action = Action","counters":[]},{"line":"  include Log_events","counters":[]},{"line":"end)","counters":[{"col_start":3,"col_end":3,"count":1}]}]}