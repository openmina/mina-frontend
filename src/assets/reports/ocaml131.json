{"filename":"src/lib/pickles/reduced_messages_for_next_proof_over_same_field.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Import","counters":[]},{"line":"open Pickles_types","counters":[]},{"line":"open Types","counters":[]},{"line":"open Common","counters":[]},{"line":"open Backend","counters":[]},{"line":"","counters":[]},{"line":"(* The step-proof \"reduced\" me-only contains the data of the standard me-only","counters":[]},{"line":"   but without the wrap verification key. The purpose of this type is for sending","counters":[]},{"line":"   step me-onlys on the wire. There is no need to send the wrap-key since everyone","counters":[]},{"line":"   knows it. *)","counters":[]},{"line":"module Step = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type ('s, 'challenge_polynomial_commitments, 'bpcs) t =","counters":[{"col_start":6,"col_end":6,"count":10},{"col_start":58,"col_end":58,"count":6}]},{"line":"            ( 's","counters":[]},{"line":"            , 'challenge_polynomial_commitments","counters":[]},{"line":"            , 'bpcs )","counters":[]},{"line":"            Mina_wire_types","counters":[]},{"line":"            .Pickles_reduced_messages_for_next_proof_over_same_field","counters":[]},{"line":"            .Step","counters":[]},{"line":"            .V1","counters":[]},{"line":"            .t =","counters":[]},{"line":"        { app_state : 's","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"        ; challenge_polynomial_commitments : 'challenge_polynomial_commitments","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":77,"col_end":77,"count":0}]},{"line":"        ; old_bulletproof_challenges : 'bpcs","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"        }","counters":[]},{"line":"      [@@deriving sexp, yojson, sexp, compare, hash, equal]","counters":[{"col_start":58,"col_end":58,"count":5}]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  let prepare ~dlog_plonk_index","counters":[]},{"line":"      { app_state","counters":[]},{"line":"      ; challenge_polynomial_commitments","counters":[]},{"line":"      ; old_bulletproof_challenges","counters":[]},{"line":"      } =","counters":[]},{"line":"    { Types.Step.Proof_state.Messages_for_next_step_proof.app_state","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    ; challenge_polynomial_commitments","counters":[]},{"line":"    ; dlog_plonk_index","counters":[]},{"line":"    ; old_bulletproof_challenges =","counters":[]},{"line":"        Vector.map ~f:Ipa.Step.compute_challenges old_bulletproof_challenges","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"    }","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Wrap = struct","counters":[]},{"line":"  module Challenges_vector = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      [@@@no_toplevel_latest_type]","counters":[]},{"line":"","counters":[]},{"line":"      module V2 = struct","counters":[]},{"line":"        type t =","counters":[{"col_start":8,"col_end":8,"count":6},{"col_start":13,"col_end":13,"count":1}]},{"line":"          Limb_vector.Constant.Hex64.Stable.V1.t Vector.Vector_2.Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"          Scalar_challenge.Stable.V2.t","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          Bulletproof_challenge.Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          Wrap_bp_vec.Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        [@@deriving sexp, compare, yojson, hash, equal]","counters":[{"col_start":54,"col_end":54,"count":5}]},{"line":"","counters":[]},{"line":"        let to_latest = Fn.id","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    type t =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Challenge.Constant.t Scalar_challenge.t Bulletproof_challenge.t","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"      Wrap_bp_vec.t","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    [@@deriving sexp, compare, yojson, hash, equal]","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"","counters":[]},{"line":"    let () =","counters":[]},{"line":"      let _f : unit -> (t, Stable.Latest.t) Type_equal.t =","counters":[]},{"line":"       fun () -> Type_equal.T","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"      in","counters":[]},{"line":"      ()","counters":[]},{"line":"","counters":[]},{"line":"    module Prepared = struct","counters":[]},{"line":"      type t = (Tock.Field.t, Tock.Rounds.n) Vector.t","counters":[]},{"line":"    end","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  type 'max_local_max_proofs_verified t =","counters":[]},{"line":"    ( Tock.Inner_curve.Affine.t","counters":[]},{"line":"    , (Challenges_vector.t, 'max_local_max_proofs_verified) Vector.t )","counters":[]},{"line":"    Types.Wrap.Proof_state.Messages_for_next_wrap_proof.t","counters":[]},{"line":"","counters":[]},{"line":"  module Prepared = struct","counters":[]},{"line":"    type 'max_local_max_proofs_verified t =","counters":[]},{"line":"      ( Tock.Inner_curve.Affine.t","counters":[]},{"line":"      , (Challenges_vector.Prepared.t, 'max_local_max_proofs_verified) Vector.t","counters":[]},{"line":"      )","counters":[]},{"line":"      Types.Wrap.Proof_state.Messages_for_next_wrap_proof.t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let prepare","counters":[]},{"line":"      ({ challenge_polynomial_commitment; old_bulletproof_challenges } : _ t) =","counters":[]},{"line":"    { Types.Wrap.Proof_state.Messages_for_next_wrap_proof","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      .challenge_polynomial_commitment","counters":[]},{"line":"    ; old_bulletproof_challenges =","counters":[]},{"line":"        Vector.map ~f:Ipa.Wrap.compute_challenges old_bulletproof_challenges","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"    }","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}