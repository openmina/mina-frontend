{"filename":"src/lib/mina_base/coinbase.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Mina_base_import","counters":[]},{"line":"","counters":[]},{"line":"(** See documentation of the {!Mina_wire_types} library *)","counters":[]},{"line":"module Wire_types = Mina_wire_types.Mina_base.Coinbase","counters":[]},{"line":"","counters":[]},{"line":"module Make_sig (A : Wire_types.Types.S) = struct","counters":[]},{"line":"  module type S = Coinbase_intf.Full with type Stable.V1.t = A.V1.t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make_str (A : Wire_types.Concrete) = struct","counters":[]},{"line":"  module Fee_transfer = Coinbase_fee_transfer","counters":[]},{"line":"","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type t = A.V1.t =","counters":[{"col_start":6,"col_end":6,"count":2},{"col_start":11,"col_end":11,"count":2}]},{"line":"        { receiver : Public_key.Compressed.Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"        ; amount : Currency.Amount.Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"        ; fee_transfer : Fee_transfer.Stable.V1.t option","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":48,"col_end":48,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"        }","counters":[]},{"line":"      [@@deriving sexp, compare, equal, hash, yojson]","counters":[{"col_start":52,"col_end":52,"count":5}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"      let description = \"Coinbase\"","counters":[]},{"line":"","counters":[]},{"line":"      let version_byte = Base58_check.Version_bytes.coinbase","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  module Base58_check = Codable.Make_base58_check (Stable.Latest)","counters":[]},{"line":"","counters":[]},{"line":"  [%%define_locally","counters":[]},{"line":"  Base58_check.(to_base58_check, of_base58_check, of_base58_check_exn)]","counters":[]},{"line":"","counters":[]},{"line":"  let receiver_pk t = t.receiver","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"  let receiver t = Account_id.create t.receiver Token_id.default","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"","counters":[]},{"line":"  (* This must match [Transaction_union].","counters":[]},{"line":"     TODO: enforce this.","counters":[]},{"line":"  *)","counters":[]},{"line":"  let fee_payer_pk cb =","counters":[]},{"line":"    match cb.fee_transfer with None -> cb.receiver | Some ft -> ft.receiver_pk","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"","counters":[]},{"line":"  let amount t = t.amount","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"","counters":[]},{"line":"  let fee_transfer t = t.fee_transfer","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"  let accounts_accessed t =","counters":[]},{"line":"    receiver t","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":11,"col_end":11,"count":0}]},{"line":"    :: List.map ~f:Fee_transfer.receiver (Option.to_list t.fee_transfer)","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"","counters":[]},{"line":"  let is_valid { amount; fee_transfer; _ } =","counters":[]},{"line":"    match fee_transfer with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        true","counters":[]},{"line":"    | Some { fee; _ } ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Currency.Amount.(of_fee fee <= amount)","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"","counters":[]},{"line":"  let create ~amount ~receiver ~fee_transfer =","counters":[]},{"line":"    let t = { receiver; amount; fee_transfer } in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    if is_valid t then","counters":[]},{"line":"      let adjusted_fee_transfer =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Option.bind fee_transfer ~f:(fun fee_transfer ->","counters":[]},{"line":"            Option.some_if","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (not","counters":[]},{"line":"                 (Public_key.Compressed.equal receiver","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"                    (Fee_transfer.receiver_pk fee_transfer) ) )","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"              fee_transfer )","counters":[]},{"line":"      in","counters":[]},{"line":"      Ok { t with fee_transfer = adjusted_fee_transfer }","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    else Or_error.error_string \"Coinbase.create: invalid coinbase\"","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"  let expected_supply_increase { receiver = _; amount; fee_transfer } =","counters":[]},{"line":"    match fee_transfer with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Ok amount","counters":[]},{"line":"    | Some { fee; _ } ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Currency.Amount.sub amount (Currency.Amount.of_fee fee)","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"        |> Option.value_map","counters":[]},{"line":"             ~f:(fun _ -> Ok amount)","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"             ~default:(Or_error.error_string \"Coinbase underflow\")","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"","counters":[]},{"line":"  let fee_excess t =","counters":[]},{"line":"    Or_error.map (expected_supply_increase t) ~f:(fun _increase ->","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"        Fee_excess.empty )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"  module Gen = struct","counters":[]},{"line":"    let gen ~(constraint_constants : Genesis_constants.Constraint_constants.t) =","counters":[]},{"line":"      let open Quickcheck.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%bind receiver = Public_key.Compressed.gen in","counters":[]},{"line":"      let%bind supercharged_coinbase = Quickcheck.Generator.bool in","counters":[]},{"line":"      let%bind amount =","counters":[]},{"line":"        let max_amount = constraint_constants.coinbase_amount in","counters":[]},{"line":"        (* amount should be at least the account creation fee to pay for the creation of coinbase receiver and the fee transfer receiver below *)","counters":[]},{"line":"        let min_amount =","counters":[]},{"line":"          Option.value_exn","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"            (Currency.Fee.scale constraint_constants.account_creation_fee 2)","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"          |> Currency.Amount.of_fee","counters":[]},{"line":"        in","counters":[]},{"line":"        let%map amount = Currency.Amount.(gen_incl min_amount max_amount) in","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"        if supercharged_coinbase then","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Option.value_exn","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (Currency.Amount.scale amount","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"               constraint_constants.supercharged_coinbase_factor )","counters":[]},{"line":"        else amount","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"      in","counters":[]},{"line":"      (* keep account-creation fee for the coinbase-receiver *)","counters":[]},{"line":"      let max_fee =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Option.value_exn","counters":[]},{"line":"          (Currency.Fee.sub","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"             (Currency.Amount.to_fee amount)","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"             constraint_constants.account_creation_fee )","counters":[]},{"line":"      in","counters":[]},{"line":"      let min_fee = constraint_constants.account_creation_fee in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%map fee_transfer =","counters":[]},{"line":"        Option.quickcheck_generator (Fee_transfer.Gen.gen ~min_fee max_fee)","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"      in","counters":[]},{"line":"      let fee_transfer =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        match fee_transfer with","counters":[]},{"line":"        | Some { Fee_transfer.receiver_pk; _ }","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          when Public_key.Compressed.equal receiver receiver_pk ->","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"            (* Erase fee transfer, to mirror [create]. *)","counters":[]},{"line":"            None","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"        | _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            fee_transfer","counters":[]},{"line":"      in","counters":[]},{"line":"      ( { receiver; amount; fee_transfer }","counters":[]},{"line":"      , `Supercharged_coinbase supercharged_coinbase )","counters":[]},{"line":"","counters":[]},{"line":"    let with_random_receivers ~keys ~min_amount ~max_amount ~fee_transfer =","counters":[]},{"line":"      let open Quickcheck.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%bind receiver =","counters":[]},{"line":"        let open Signature_lib in","counters":[]},{"line":"        Quickcheck_lib.of_array keys","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"        >>| fun keypair -> Public_key.compress keypair.Keypair.public_key","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"      and amount =","counters":[]},{"line":"        Int.gen_incl min_amount max_amount >>| Currency.Amount.of_int","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"      in","counters":[]},{"line":"      let%map fee_transfer =","counters":[]},{"line":"        Option.quickcheck_generator (fee_transfer ~coinbase_amount:amount)","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"      in","counters":[]},{"line":"      let fee_transfer =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        match fee_transfer with","counters":[]},{"line":"        | Some { Fee_transfer.receiver_pk; _ }","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          when Public_key.Compressed.equal receiver receiver_pk ->","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"            (* Erase fee transfer, to mirror [create]. *)","counters":[]},{"line":"            None","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"        | _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            fee_transfer","counters":[]},{"line":"      in","counters":[]},{"line":"      { receiver; amount; fee_transfer }","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"include Wire_types.Make (Make_sig) (Make_str)","counters":[{"col_start":44,"col_end":44,"count":1}]}]}