{"filename":"src/lib/transition_frontier/persistent_frontier/database.ml","lines":[{"line":"open Async_kernel","counters":[]},{"line":"open Core","counters":[]},{"line":"open Mina_base","counters":[]},{"line":"open Mina_block","counters":[]},{"line":"open Frontier_base","counters":[]},{"line":"","counters":[]},{"line":"(* TODO: cache state body hashes in db to avoid re-hashing on load (#10293) *)","counters":[]},{"line":"","counters":[]},{"line":"(* TODO: bundle together with other writes by sharing batch requests between","counters":[]},{"line":" * function calls in this module (#3738) *)","counters":[]},{"line":"","counters":[]},{"line":"let rec deferred_list_result_iter ls ~f =","counters":[]},{"line":"  let open Deferred.Result.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  match ls with","counters":[]},{"line":"  | [] ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      return ()","counters":[]},{"line":"  | h :: t ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let%bind () = f h in","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"      deferred_list_result_iter t ~f","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"(* TODO: should debug assert garbage checks be added? *)","counters":[]},{"line":"open Result.Let_syntax","counters":[]},{"line":"","counters":[]},{"line":"(* TODO: implement versions with module versioning. For","counters":[]},{"line":" * now, this is just stubbed so we can add db migrations","counters":[]},{"line":" * later. (#3736) *)","counters":[]},{"line":"let version = 2","counters":[]},{"line":"","counters":[]},{"line":"module Schema = struct","counters":[]},{"line":"  module Keys = struct","counters":[]},{"line":"    module String = String","counters":[]},{"line":"","counters":[]},{"line":"    module Prefixed_state_hash = struct","counters":[]},{"line":"      [%%versioned","counters":[]},{"line":"      module Stable = struct","counters":[]},{"line":"        [@@@no_toplevel_latest_type]","counters":[]},{"line":"","counters":[]},{"line":"        module V1 = struct","counters":[]},{"line":"          type t = string * State_hash.Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":2},{"col_start":15,"col_end":15,"count":1},{"col_start":49,"col_end":49,"count":5}]},{"line":"","counters":[]},{"line":"          let to_latest = Fn.id","counters":[]},{"line":"        end","counters":[]},{"line":"      end]","counters":[]},{"line":"    end","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  type _ t =","counters":[]},{"line":"    | Db_version : int t","counters":[]},{"line":"    | Transition : State_hash.Stable.V1.t -> Mina_block.Stable.V2.t t","counters":[]},{"line":"    | Arcs : State_hash.Stable.V1.t -> State_hash.Stable.V1.t list t","counters":[]},{"line":"    | Root : Root_data.Minimal.Stable.V2.t t","counters":[]},{"line":"    | Best_tip : State_hash.Stable.V1.t t","counters":[]},{"line":"    | Protocol_states_for_root_scan_state","counters":[]},{"line":"        : Mina_state.Protocol_state.Value.Stable.V2.t list t","counters":[]},{"line":"","counters":[]},{"line":"  let to_string : type a. a t -> string = function","counters":[]},{"line":"    | Db_version ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        \"Db_version\"","counters":[]},{"line":"    | Transition _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        \"Transition _\"","counters":[]},{"line":"    | Arcs _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        \"Arcs _\"","counters":[]},{"line":"    | Root ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        \"Root\"","counters":[]},{"line":"    | Best_tip ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        \"Best_tip\"","counters":[]},{"line":"    | Protocol_states_for_root_scan_state ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        \"Protocol_states_for_root_scan_state\"","counters":[]},{"line":"","counters":[]},{"line":"  let binable_data_type (type a) : a t -> a Bin_prot.Type_class.t = function","counters":[]},{"line":"    | Db_version ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [%bin_type_class: int]","counters":[]},{"line":"    | Transition _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [%bin_type_class: Mina_block.Stable.Latest.t]","counters":[]},{"line":"    | Arcs _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [%bin_type_class: State_hash.Stable.Latest.t list]","counters":[]},{"line":"    | Root ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [%bin_type_class: Root_data.Minimal.Stable.Latest.t]","counters":[]},{"line":"    | Best_tip ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [%bin_type_class: State_hash.Stable.Latest.t]","counters":[]},{"line":"    | Protocol_states_for_root_scan_state ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [%bin_type_class: Mina_state.Protocol_state.Value.Stable.Latest.t list]","counters":[]},{"line":"","counters":[]},{"line":"  (* HACK: a simple way to derive Bin_prot.Type_class.t for each case of a GADT *)","counters":[]},{"line":"  let gadt_input_type_class (type data a) :","counters":[]},{"line":"         (module Binable.S with type t = data)","counters":[]},{"line":"      -> to_gadt:(data -> a t)","counters":[]},{"line":"      -> of_gadt:(a t -> data)","counters":[]},{"line":"      -> a t Bin_prot.Type_class.t =","counters":[]},{"line":"   fun (module M) ~to_gadt ~of_gadt ->","counters":[]},{"line":"    let ({ shape; writer = { size; write }; reader = { read; vtag_read } }","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"          : data Bin_prot.Type_class.t ) =","counters":[]},{"line":"      [%bin_type_class: M.t]","counters":[]},{"line":"    in","counters":[]},{"line":"    { shape","counters":[]},{"line":"    ; writer =","counters":[]},{"line":"        { size = Fn.compose size of_gadt","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"        ; write = (fun buffer ~pos gadt -> write buffer ~pos (of_gadt gadt))","counters":[{"col_start":43,"col_end":43,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"        }","counters":[]},{"line":"    ; reader =","counters":[]},{"line":"        { read = (fun buffer ~pos_ref -> to_gadt (read buffer ~pos_ref))","counters":[{"col_start":41,"col_end":41,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"        ; vtag_read =","counters":[]},{"line":"            (fun buffer ~pos_ref number ->","counters":[]},{"line":"              to_gadt (vtag_read buffer ~pos_ref number) )","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  (* HACK: The OCaml compiler thought the pattern matching in of_gadts was","counters":[]},{"line":"     non-exhaustive. However, it should not be since I constrained the","counters":[]},{"line":"     polymorphic type *)","counters":[]},{"line":"  let[@warning \"-8\"] binable_key_type (type a) :","counters":[]},{"line":"      a t -> a t Bin_prot.Type_class.t = function","counters":[]},{"line":"    | Db_version ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        gadt_input_type_class","counters":[]},{"line":"          (module Keys.String)","counters":[]},{"line":"          ~to_gadt:(fun _ -> Db_version)","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"          ~of_gadt:(fun Db_version -> \"db_version\")","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"    | Transition _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        gadt_input_type_class","counters":[]},{"line":"          (module Keys.Prefixed_state_hash.Stable.Latest)","counters":[]},{"line":"          ~to_gadt:(fun (_, hash) -> Transition hash)","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"          ~of_gadt:(fun (Transition hash) -> (\"transition\", hash))","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"    | Arcs _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        gadt_input_type_class","counters":[]},{"line":"          (module Keys.Prefixed_state_hash.Stable.Latest)","counters":[]},{"line":"          ~to_gadt:(fun (_, hash) -> Arcs hash)","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"          ~of_gadt:(fun (Arcs hash) -> (\"arcs\", hash))","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"    | Root ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        gadt_input_type_class","counters":[]},{"line":"          (module Keys.String)","counters":[]},{"line":"          ~to_gadt:(fun _ -> Root)","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"          ~of_gadt:(fun Root -> \"root\")","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"    | Best_tip ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        gadt_input_type_class","counters":[]},{"line":"          (module Keys.String)","counters":[]},{"line":"          ~to_gadt:(fun _ -> Best_tip)","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"          ~of_gadt:(fun Best_tip -> \"best_tip\")","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"    | Protocol_states_for_root_scan_state ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        gadt_input_type_class","counters":[]},{"line":"          (module Keys.String)","counters":[]},{"line":"          ~to_gadt:(fun _ -> Protocol_states_for_root_scan_state)","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"          ~of_gadt:(fun Protocol_states_for_root_scan_state ->","counters":[]},{"line":"            \"protocol_states_in_root_scan_state\" )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Error = struct","counters":[]},{"line":"  type not_found_member =","counters":[]},{"line":"    [ `Root","counters":[]},{"line":"    | `Best_tip","counters":[]},{"line":"    | `Frontier_hash","counters":[]},{"line":"    | `Root_transition","counters":[]},{"line":"    | `Best_tip_transition","counters":[]},{"line":"    | `Parent_transition of State_hash.t","counters":[]},{"line":"    | `New_root_transition","counters":[]},{"line":"    | `Old_root_transition","counters":[]},{"line":"    | `Transition of State_hash.t","counters":[]},{"line":"    | `Arcs of State_hash.t","counters":[]},{"line":"    | `Protocol_states_for_root_scan_state ]","counters":[]},{"line":"","counters":[]},{"line":"  type not_found = [ `Not_found of not_found_member ]","counters":[]},{"line":"","counters":[]},{"line":"  type raised = [ `Raised of Error.t ]","counters":[]},{"line":"","counters":[]},{"line":"  type t = [ not_found | raised | `Invalid_version ]","counters":[]},{"line":"","counters":[]},{"line":"  let not_found_message (`Not_found member) =","counters":[]},{"line":"    let member_name, member_id =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      match member with","counters":[]},{"line":"      | `Root ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (\"root\", None)","counters":[]},{"line":"      | `Best_tip ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (\"best tip\", None)","counters":[]},{"line":"      | `Frontier_hash ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (\"frontier hash\", None)","counters":[]},{"line":"      | `Root_transition ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (\"root transition\", None)","counters":[]},{"line":"      | `Best_tip_transition ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (\"best tip transition\", None)","counters":[]},{"line":"      | `Parent_transition hash ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (\"parent transition\", Some hash)","counters":[]},{"line":"      | `New_root_transition ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (\"new root transition\", None)","counters":[]},{"line":"      | `Old_root_transition ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (\"old root transition\", None)","counters":[]},{"line":"      | `Transition hash ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (\"transition\", Some hash)","counters":[]},{"line":"      | `Arcs hash ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (\"arcs\", Some hash)","counters":[]},{"line":"      | `Protocol_states_for_root_scan_state ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (\"protocol states in root scan state\", None)","counters":[]},{"line":"    in","counters":[]},{"line":"    let additional_context =","counters":[]},{"line":"      Option.map member_id ~f:(fun id ->","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"          Printf.sprintf \" (hash = %s)\" (State_hash.raw_hash_bytes id) )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"      |> Option.value ~default:\"\"","counters":[]},{"line":"    in","counters":[]},{"line":"    Printf.sprintf \"%s not found%s\" member_name additional_context","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let message = function","counters":[]},{"line":"    | `Invalid_version ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        \"invalid version\"","counters":[]},{"line":"    | `Not_found _ as err ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        not_found_message err","counters":[]},{"line":"    | `Raised err ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        sprintf \"Raised %s\" (Error.to_string_hum err)","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Rocks = Rocksdb.Serializable.GADT.Make (Schema)","counters":[]},{"line":"","counters":[]},{"line":"type t = { directory : string; logger : Logger.t; db : Rocks.t }","counters":[]},{"line":"","counters":[]},{"line":"let create ~logger ~directory =","counters":[]},{"line":"  if not (Result.is_ok (Unix.access directory [ `Exists ])) then","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"    Unix.mkdir ~perm:0o766 directory ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":13,"col_end":13,"count":0}]},{"line":"  { directory; logger; db = Rocks.create directory }","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"let close t = Rocks.close t.db","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"","counters":[]},{"line":"open Schema","counters":[]},{"line":"open Rocks","counters":[]},{"line":"","counters":[]},{"line":"let mem db ~key = Option.is_some (get db ~key)","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"","counters":[]},{"line":"let get_if_exists db ~default ~key =","counters":[]},{"line":"  match get db ~key with Some x -> x | None -> default","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"let get db ~key ~error =","counters":[]},{"line":"  match get db ~key with Some x -> Ok x | None -> Error error","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"","counters":[]},{"line":"(* TODO: check that best tip is connected to root *)","counters":[]},{"line":"(* TODO: check for garbage *)","counters":[]},{"line":"let check t ~genesis_state_hash =","counters":[]},{"line":"  Or_error.try_with (fun () ->","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"      let check_version () =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        match get_if_exists t.db ~key:Db_version ~default:0 with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | 0 ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Error `Not_initialized","counters":[]},{"line":"        | v when v = version ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Ok ()","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"        | _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Error `Invalid_version","counters":[]},{"line":"      in","counters":[]},{"line":"      (* checks the pointers, frontier hash, and checks pointer references *)","counters":[]},{"line":"      let check_base () =","counters":[]},{"line":"        let%bind root =","counters":[]},{"line":"          get t.db ~key:Root ~error:(`Corrupt (`Not_found `Root))","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"        in","counters":[]},{"line":"        let root_hash = Root_data.Minimal.hash root in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let%bind best_tip =","counters":[]},{"line":"          get t.db ~key:Best_tip ~error:(`Corrupt (`Not_found `Best_tip))","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"        in","counters":[]},{"line":"        let%bind root_transition =","counters":[]},{"line":"          get t.db ~key:(Transition root_hash)","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            ~error:(`Corrupt (`Not_found `Root_transition))","counters":[]},{"line":"        in","counters":[]},{"line":"        let%bind _ =","counters":[]},{"line":"          get t.db ~key:Protocol_states_for_root_scan_state","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            ~error:(`Corrupt (`Not_found `Protocol_states_for_root_scan_state))","counters":[]},{"line":"        in","counters":[]},{"line":"        let%map _ =","counters":[]},{"line":"          get t.db ~key:(Transition best_tip)","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            ~error:(`Corrupt (`Not_found `Best_tip_transition))","counters":[]},{"line":"        in","counters":[]},{"line":"        (root_hash, root_transition)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      in","counters":[]},{"line":"      let rec check_arcs pred_hash =","counters":[]},{"line":"        let%bind successors =","counters":[]},{"line":"          get t.db ~key:(Arcs pred_hash)","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            ~error:(`Corrupt (`Not_found (`Arcs pred_hash)))","counters":[]},{"line":"        in","counters":[]},{"line":"        List.fold successors ~init:(Ok ()) ~f:(fun acc succ_hash ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            let%bind () = acc in","counters":[]},{"line":"            let%bind _ =","counters":[]},{"line":"              get t.db ~key:(Transition succ_hash)","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                ~error:(`Corrupt (`Not_found (`Transition succ_hash)))","counters":[]},{"line":"            in","counters":[]},{"line":"            check_arcs succ_hash )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"      in","counters":[]},{"line":"      let%bind () = check_version () in","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"      let%bind root_hash, root_block = check_base () in","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"      let root_protocol_state =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        root_block |> Mina_block.header |> Mina_block.Header.protocol_state","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"      in","counters":[]},{"line":"      let%bind () =","counters":[]},{"line":"        let persisted_genesis_state_hash =","counters":[]},{"line":"          Mina_state.Protocol_state.genesis_state_hash root_protocol_state","counters":[]},{"line":"        in","counters":[]},{"line":"        if State_hash.equal persisted_genesis_state_hash genesis_state_hash then","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Ok ()","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        else Error (`Genesis_state_mismatch persisted_genesis_state_hash)","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"      in","counters":[]},{"line":"      let%map () = check_arcs root_hash in","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"      root_block |> Mina_block.header |> Header.protocol_state","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"      |> Mina_state.Protocol_state.blockchain_state","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"      |> Mina_state.Blockchain_state.snarked_ledger_hash )","counters":[]},{"line":"  |> Result.map_error ~f:(fun err -> `Corrupt (`Raised err))","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"  |> Result.join","counters":[]},{"line":"","counters":[]},{"line":"let initialize t ~root_data =","counters":[]},{"line":"  let open Root_data.Limited in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let root_state_hash, root_transition =","counters":[]},{"line":"    let t = Mina_block.Validated.forget (transition root_data) in","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"    ( State_hash.With_state_hashes.state_hash t","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"    , State_hash.With_state_hashes.data t )","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"  in","counters":[]},{"line":"  [%log' trace t.logger]","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"    ~metadata:[ (\"root_data\", Root_data.Limited.to_yojson root_data) ]","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"    \"Initializing persistent frontier database with $root_data\" ;","counters":[]},{"line":"  Batch.with_batch t.db ~f:(fun batch ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      Batch.set batch ~key:Db_version ~data:version ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Batch.set batch ~key:(Transition root_state_hash) ~data:root_transition ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Batch.set batch ~key:(Arcs root_state_hash) ~data:[] ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Batch.set batch ~key:Root ~data:(Root_data.Minimal.of_limited root_data) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"      Batch.set batch ~key:Best_tip ~data:root_state_hash ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Batch.set batch ~key:Protocol_states_for_root_scan_state","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ~data:(protocol_states root_data |> List.map ~f:With_hash.data) )","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"","counters":[]},{"line":"let add t ~transition =","counters":[]},{"line":"  let transition = Mina_block.Validated.forget transition in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let hash = State_hash.With_state_hashes.state_hash transition in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let parent_hash =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    With_hash.data transition |> Mina_block.header |> Header.protocol_state","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":49,"col_end":49,"count":0},{"col_start":74,"col_end":74,"count":0}]},{"line":"    |> Mina_state.Protocol_state.previous_state_hash","counters":[]},{"line":"  in","counters":[]},{"line":"  let%bind () =","counters":[]},{"line":"    Result.ok_if_true","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"      (mem t.db ~key:(Transition parent_hash))","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"      ~error:(`Not_found (`Parent_transition parent_hash))","counters":[]},{"line":"  in","counters":[]},{"line":"  let%map parent_arcs =","counters":[]},{"line":"    get t.db ~key:(Arcs parent_hash) ~error:(`Not_found (`Arcs parent_hash))","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  in","counters":[]},{"line":"  Batch.with_batch t.db ~f:(fun batch ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      Batch.set batch ~key:(Transition hash) ~data:(With_hash.data transition) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"      Batch.set batch ~key:(Arcs hash) ~data:[] ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Batch.set batch ~key:(Arcs parent_hash) ~data:(hash :: parent_arcs) )","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"let move_root t ~new_root ~garbage =","counters":[]},{"line":"  let open Root_data.Limited in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%bind () =","counters":[]},{"line":"    Result.ok_if_true","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"      (mem t.db ~key:(Transition (hashes new_root).state_hash))","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"      ~error:(`Not_found `New_root_transition)","counters":[]},{"line":"  in","counters":[]},{"line":"  let%map old_root =","counters":[]},{"line":"    get t.db ~key:Root ~error:(`Not_found `Old_root_transition)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  in","counters":[]},{"line":"  let old_root_hash = Root_data.Minimal.hash old_root in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  (* TODO: Result compatible rocksdb batch transaction *)","counters":[]},{"line":"  Batch.with_batch t.db ~f:(fun batch ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      Batch.set batch ~key:Root ~data:(Root_data.Minimal.of_limited new_root) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"      Batch.set batch ~key:Protocol_states_for_root_scan_state","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ~data:(List.map ~f:With_hash.data (protocol_states new_root)) ;","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"      List.iter (old_root_hash :: garbage) ~f:(fun node_hash ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          (* because we are removing entire forks of the tree, there is","counters":[]},{"line":"           * no need to have extra logic to any remove arcs to the node","counters":[]},{"line":"           * we are deleting since there we are deleting all of a node's","counters":[]},{"line":"           * parents as well","counters":[]},{"line":"           *)","counters":[]},{"line":"          Batch.remove batch ~key:(Transition node_hash) ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          Batch.remove batch ~key:(Arcs node_hash) ) ) ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"  old_root_hash","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let get_transition t hash =","counters":[]},{"line":"  let%map transition =","counters":[]},{"line":"    get t.db ~key:(Transition hash) ~error:(`Not_found (`Transition hash))","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  in","counters":[]},{"line":"  let block =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    { With_hash.data = transition","counters":[]},{"line":"    ; hash =","counters":[]},{"line":"        { State_hash.State_hashes.state_hash = hash; state_body_hash = None }","counters":[]},{"line":"    }","counters":[]},{"line":"  in","counters":[]},{"line":"  let parent_hash =","counters":[]},{"line":"    block |> With_hash.data |> Mina_block.header","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"    |> Mina_block.Header.protocol_state","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"    |> Mina_state.Protocol_state.previous_state_hash","counters":[]},{"line":"  in","counters":[]},{"line":"  (* TODO: the delta transition chain proof is incorrect (same behavior the daemon used to have, but we should probably fix this?) *)","counters":[]},{"line":"  Mina_block.Validated.unsafe_of_trusted_block","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    ~delta_block_chain_proof:(Non_empty_list.singleton parent_hash)","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"    (`This_block_is_trusted_to_be_safe block)","counters":[]},{"line":"","counters":[]},{"line":"let get_arcs t hash = get t.db ~key:(Arcs hash) ~error:(`Not_found (`Arcs hash))","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"let get_root t = get t.db ~key:Root ~error:(`Not_found `Root)","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"","counters":[]},{"line":"let get_protocol_states_for_root_scan_state t =","counters":[]},{"line":"  get t.db ~key:Protocol_states_for_root_scan_state","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    ~error:(`Not_found `Protocol_states_for_root_scan_state)","counters":[]},{"line":"","counters":[]},{"line":"let get_root_hash t =","counters":[]},{"line":"  let%map root = get_root t in","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"  Root_data.Minimal.hash root","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let get_best_tip t = get t.db ~key:Best_tip ~error:(`Not_found `Best_tip)","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"","counters":[]},{"line":"let set_best_tip t hash =","counters":[]},{"line":"  let%map old_best_tip_hash = get_best_tip t in","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"  (* no need to batch because we only do one operation *)","counters":[]},{"line":"  set t.db ~key:Best_tip ~data:hash ;","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  old_best_tip_hash","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let rec crawl_successors t hash ~init ~f =","counters":[]},{"line":"  let open Deferred.Result.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%bind successors = Deferred.return (get_arcs t hash) in","counters":[{"col_start":38,"col_end":38,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"  deferred_list_result_iter successors ~f:(fun succ_hash ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      let%bind transition = Deferred.return (get_transition t succ_hash) in","counters":[{"col_start":42,"col_end":42,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"      let%bind init' =","counters":[]},{"line":"        Deferred.map (f init transition)","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"          ~f:(Result.map_error ~f:(fun err -> `Crawl_error err))","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"      in","counters":[]},{"line":"      crawl_successors t succ_hash ~init:init' ~f )","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":50,"col_end":50,"count":2}]}]}