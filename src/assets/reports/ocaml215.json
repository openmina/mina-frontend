{"filename":"src/lib/o1trace/thread.ml","lines":[{"line":"open Core","counters":[]},{"line":"open Async","counters":[]},{"line":"","counters":[]},{"line":"type t = { name : string; mutable state : Univ_map.t } [@@deriving sexp_of]","counters":[{"col_start":0,"col_end":0,"count":0},{"col_start":11,"col_end":11,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"","counters":[]},{"line":"type thread = t [@@deriving sexp_of]","counters":[{"col_start":0,"col_end":0,"count":0}]},{"line":"","counters":[]},{"line":"module Graph = struct","counters":[]},{"line":"  module G = Graph.Imperative.Digraph.Concrete (struct","counters":[]},{"line":"    include String","counters":[]},{"line":"","counters":[]},{"line":"    let hash = Hash.Builtin.hash_string","counters":[]},{"line":"  end)","counters":[]},{"line":"","counters":[]},{"line":"  include G","counters":[]},{"line":"","counters":[]},{"line":"  include Graph.Graphviz.Dot (struct","counters":[]},{"line":"    include G","counters":[]},{"line":"","counters":[]},{"line":"    let graph_attributes _ = [ `Rankdir `LeftToRight ]","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"    let default_vertex_attributes _ = []","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"","counters":[]},{"line":"    let vertex_name = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"    let vertex_attributes _ = []","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"","counters":[]},{"line":"    let get_subgraph _ = None","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"    let default_edge_attributes _ = []","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"","counters":[]},{"line":"    let edge_attributes _ = []","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"  end)","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(* TODO: could combine these into a single data structure with custom thread comparator, but I don't care enough *)","counters":[]},{"line":"let graph = Graph.create ()","counters":[{"col_start":23,"col_end":23,"count":1}]},{"line":"","counters":[]},{"line":"let threads : t String.Table.t = String.Table.create ()","counters":[{"col_start":51,"col_end":51,"count":1}]},{"line":"","counters":[]},{"line":"let register name =","counters":[]},{"line":"  match Hashtbl.find threads name with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | Some thread ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      thread","counters":[]},{"line":"  | None ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let thread = { name; state = Univ_map.empty } in","counters":[]},{"line":"      Hashtbl.set threads ~key:name ~data:thread ;","counters":[]},{"line":"      Graph.add_vertex graph name ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      thread","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"let name { name; _ } = name","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"let load_state thread id = Univ_map.find thread.state id","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"","counters":[]},{"line":"let set_state thread id value =","counters":[]},{"line":"  thread.state <- Univ_map.set thread.state id value","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"let iter_threads ~f = Hashtbl.iter threads ~f","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"let dump_thread_graph () =","counters":[]},{"line":"  let buf = Stdlib.Buffer.create 1024 in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  Graph.fprint_graph (Format.formatter_of_buffer buf) graph ;","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"  Stdlib.Buffer.to_bytes buf","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"module Fiber = struct","counters":[]},{"line":"  include Hashable.Make (struct","counters":[]},{"line":"    type t = string list [@@deriving compare, hash, sexp]","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":20,"col_end":20,"count":0}]},{"line":"  end)","counters":[]},{"line":"","counters":[]},{"line":"  let next_id = ref 1","counters":[]},{"line":"","counters":[]},{"line":"  type t = { id : int; parent : t option; thread : thread } [@@deriving sexp_of]","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"","counters":[]},{"line":"  let ctx_id : t Type_equal.Id.t = Type_equal.Id.create ~name:\"fiber\" sexp_of_t","counters":[{"col_start":54,"col_end":54,"count":1}]},{"line":"","counters":[]},{"line":"  let fibers : t Table.t = Table.create ()","counters":[{"col_start":38,"col_end":38,"count":1}]},{"line":"","counters":[]},{"line":"  let rec fiber_key name parent =","counters":[]},{"line":"    name","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    :: Option.value_map parent ~default:[] ~f:(fun p ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"           fiber_key p.thread.name p.parent )","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"","counters":[]},{"line":"  let register name parent =","counters":[]},{"line":"    let key = fiber_key name parent in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    match Hashtbl.find fibers key with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Some fiber ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        fiber","counters":[]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let thread = register name in","counters":[]},{"line":"        let fiber = { id = !next_id; parent; thread } in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        incr next_id ;","counters":[]},{"line":"        Hashtbl.set fibers ~key ~data:fiber ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Option.iter parent ~f:(fun p -> Graph.add_edge graph p.thread.name name) ;","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"        fiber","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"  let apply_to_context t ctx =","counters":[]},{"line":"    let ctx = Execution_context.with_tid ctx t.id in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Execution_context.with_local ctx ctx_id (Some t)","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let of_context ctx = Execution_context.find_local ctx ctx_id","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let of_context ctx =","counters":[]},{"line":"  let%map.Option fiber = Fiber.of_context ctx in","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"  fiber.thread","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":13,"col_end":13,"count":2}]}]}