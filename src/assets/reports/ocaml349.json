{"filename":"src/lib/mina_base/staged_ledger_hash.ml","lines":[{"line":"[%%import \"/src/config.mlh\"]","counters":[]},{"line":"","counters":[{"col_start":0,"col_end":0,"count":1}]},{"line":"open Core_kernel","counters":[]},{"line":"open Mina_base_util","counters":[]},{"line":"open Fold_lib","counters":[]},{"line":"open Snark_params.Tick","counters":[]},{"line":"module Wire_types = Mina_wire_types.Mina_base.Staged_ledger_hash","counters":[]},{"line":"","counters":[]},{"line":"module Make_sig (A : Wire_types.Types.S) = struct","counters":[]},{"line":"  module type S =","counters":[]},{"line":"    Staged_ledger_hash_intf.Full","counters":[]},{"line":"      with type Aux_hash.t = A.Aux_hash.t","counters":[]},{"line":"       and type Pending_coinbase_aux.t = A.Pending_coinbase_aux.V1.t","counters":[]},{"line":"       and type t = A.V1.t","counters":[]},{"line":"       and type Stable.V1.t = A.V1.t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make_str (A : Wire_types.Concrete) = struct","counters":[]},{"line":"  module Aux_hash = struct","counters":[]},{"line":"    let length_in_bits = 256","counters":[]},{"line":"","counters":[]},{"line":"    let length_in_bytes = length_in_bits / 8","counters":[]},{"line":"","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type t = string [@@deriving sexp, equal, compare, hash]","counters":[{"col_start":8,"col_end":8,"count":2},{"col_start":13,"col_end":13,"count":1},{"col_start":62,"col_end":62,"count":5}]},{"line":"","counters":[]},{"line":"        let to_latest = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"        module Base58_check = Base58_check.Make (struct","counters":[]},{"line":"          let description = \"Aux hash\"","counters":[]},{"line":"","counters":[]},{"line":"          let version_byte =","counters":[]},{"line":"            Base58_check.Version_bytes.staged_ledger_hash_aux_hash","counters":[]},{"line":"        end)","counters":[]},{"line":"","counters":[]},{"line":"        let to_base58_check s = Base58_check.encode s","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"","counters":[]},{"line":"        let of_base58_check_exn s = Base58_check.decode_exn s","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"","counters":[]},{"line":"        let to_yojson s = `String (to_base58_check s)","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"","counters":[]},{"line":"        let of_yojson = function","counters":[]},{"line":"          | `String s -> (","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              match Base58_check.decode s with","counters":[]},{"line":"              | Error e ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Error","counters":[]},{"line":"                    (sprintf \"Aux_hash.of_yojson, bad Base58Check:%s\"","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                       (Error.to_string_hum e) )","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"              | Ok x ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Ok x )","counters":[]},{"line":"          | _ ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Error \"Aux_hash.of_yojson expected `String\"","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    [%%define_locally","counters":[]},{"line":"    Stable.Latest.","counters":[]},{"line":"      ( to_yojson","counters":[]},{"line":"      , of_yojson","counters":[]},{"line":"      , to_base58_check","counters":[]},{"line":"      , of_base58_check_exn","counters":[]},{"line":"      , compare","counters":[]},{"line":"      , sexp_of_t )]","counters":[]},{"line":"","counters":[]},{"line":"    let of_bytes = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"    let to_bytes = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"    let dummy : t = String.init length_in_bytes ~f:(fun _ -> '\\000')","counters":[{"col_start":30,"col_end":30,"count":1},{"col_start":61,"col_end":61,"count":32}]},{"line":"","counters":[]},{"line":"    let of_sha256 : Digestif.SHA256.t -> t =","counters":[]},{"line":"      Fn.compose of_bytes Digestif.SHA256.to_raw_string","counters":[{"col_start":15,"col_end":15,"count":1}]},{"line":"","counters":[]},{"line":"    let gen : t Quickcheck.Generator.t =","counters":[]},{"line":"      let char_generator =","counters":[]},{"line":"        Base_quickcheck.Generator.of_list","counters":[]},{"line":"          [ '0'","counters":[]},{"line":"          ; '1'","counters":[]},{"line":"          ; '2'","counters":[]},{"line":"          ; '3'","counters":[]},{"line":"          ; '4'","counters":[]},{"line":"          ; '5'","counters":[]},{"line":"          ; '6'","counters":[]},{"line":"          ; '7'","counters":[]},{"line":"          ; '8'","counters":[]},{"line":"          ; '9'","counters":[]},{"line":"          ; 'A'","counters":[]},{"line":"          ; 'B'","counters":[]},{"line":"          ; 'C'","counters":[]},{"line":"          ; 'D'","counters":[]},{"line":"          ; 'E'","counters":[]},{"line":"          ; 'F'","counters":[]},{"line":"          ]","counters":[]},{"line":"      in","counters":[]},{"line":"      String.gen_with_length (length_in_bytes * 2) char_generator","counters":[{"col_start":6,"col_end":6,"count":1},{"col_start":27,"col_end":27,"count":1}]},{"line":"      |> Quickcheck.Generator.map","counters":[{"col_start":32,"col_end":32,"count":1}]},{"line":"           ~f:(Fn.compose of_sha256 Digestif.SHA256.of_hex)","counters":[{"col_start":24,"col_end":24,"count":1}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Pending_coinbase_aux = struct","counters":[]},{"line":"    let length_in_bits = 256","counters":[]},{"line":"","counters":[]},{"line":"    let length_in_bytes = length_in_bits / 8","counters":[]},{"line":"","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type t = string [@@deriving sexp, equal, compare, hash]","counters":[{"col_start":8,"col_end":8,"count":2},{"col_start":13,"col_end":13,"count":1},{"col_start":62,"col_end":62,"count":5}]},{"line":"","counters":[]},{"line":"        let to_latest = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"        module Base58_check = Base58_check.Make (struct","counters":[]},{"line":"          let description = \"Pending coinbase aux\"","counters":[]},{"line":"","counters":[]},{"line":"          let version_byte =","counters":[]},{"line":"            Base58_check.Version_bytes.staged_ledger_hash_pending_coinbase_aux","counters":[]},{"line":"        end)","counters":[]},{"line":"","counters":[]},{"line":"        let to_base58_check s = Base58_check.encode s","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"","counters":[]},{"line":"        let of_base58_check_exn s = Base58_check.decode_exn s","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"","counters":[]},{"line":"        let to_yojson s = `String (to_base58_check s)","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"","counters":[]},{"line":"        let of_yojson = function","counters":[]},{"line":"          | `String s -> (","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              match Base58_check.decode s with","counters":[]},{"line":"              | Ok x ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Ok x","counters":[]},{"line":"              | Error e ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Error","counters":[]},{"line":"                    (sprintf","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                       \"Pending_coinbase_aux.of_yojson, bad Base58Check:%s\"","counters":[]},{"line":"                       (Error.to_string_hum e) ) )","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"          | _ ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Error \"Pending_coinbase_aux.of_yojson expected `String\"","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    [%%define_locally","counters":[]},{"line":"    Stable.Latest.(to_yojson, of_yojson, to_base58_check, of_base58_check_exn)]","counters":[]},{"line":"","counters":[]},{"line":"    let dummy : t = String.init length_in_bytes ~f:(fun _ -> '\\000')","counters":[{"col_start":30,"col_end":30,"count":1},{"col_start":61,"col_end":61,"count":32}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Non_snark = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type t = A.Non_snark.V1.t =","counters":[{"col_start":8,"col_end":8,"count":2},{"col_start":13,"col_end":13,"count":2}]},{"line":"          { ledger_hash : Ledger_hash.Stable.V1.t","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"          ; aux_hash : Aux_hash.Stable.V1.t","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"          ; pending_coinbase_aux : Pending_coinbase_aux.Stable.V1.t","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"          }","counters":[]},{"line":"        [@@deriving sexp, equal, compare, hash, yojson, fields]","counters":[{"col_start":62,"col_end":62,"count":5}]},{"line":"","counters":[]},{"line":"        let to_latest = Fn.id","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    type value = t [@@deriving sexp, compare, hash, yojson]","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"","counters":[]},{"line":"    let dummy : t Lazy.t =","counters":[]},{"line":"      lazy","counters":[]},{"line":"        { ledger_hash = Ledger_hash.empty_hash","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        ; aux_hash = Aux_hash.dummy","counters":[]},{"line":"        ; pending_coinbase_aux = Pending_coinbase_aux.dummy","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"    let genesis ~genesis_ledger_hash : t =","counters":[]},{"line":"      { ledger_hash = genesis_ledger_hash","counters":[{"col_start":6,"col_end":6,"count":4}]},{"line":"      ; aux_hash = Aux_hash.dummy","counters":[]},{"line":"      ; pending_coinbase_aux = Pending_coinbase_aux.dummy","counters":[]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    type var = Boolean.var list","counters":[]},{"line":"","counters":[]},{"line":"    let length_in_bits = 256","counters":[]},{"line":"","counters":[]},{"line":"    let digest ({ ledger_hash; aux_hash; pending_coinbase_aux } : t) =","counters":[]},{"line":"      let h = Digestif.SHA256.init () in","counters":[{"col_start":6,"col_end":6,"count":5}]},{"line":"      let h =","counters":[{"col_start":6,"col_end":6,"count":5}]},{"line":"        Digestif.SHA256.feed_string h (Ledger_hash.to_bytes ledger_hash)","counters":[{"col_start":58,"col_end":58,"count":5}]},{"line":"      in","counters":[]},{"line":"      let h = Digestif.SHA256.feed_string h aux_hash in","counters":[{"col_start":6,"col_end":6,"count":5}]},{"line":"      let h = Digestif.SHA256.feed_string h pending_coinbase_aux in","counters":[{"col_start":6,"col_end":6,"count":5}]},{"line":"      Digestif.SHA256.(get h |> to_raw_string)","counters":[{"col_start":6,"col_end":6,"count":5},{"col_start":25,"col_end":25,"count":5}]},{"line":"","counters":[]},{"line":"    let fold t = Fold.string_bits (digest t)","counters":[{"col_start":17,"col_end":17,"count":5},{"col_start":40,"col_end":40,"count":5}]},{"line":"","counters":[]},{"line":"    let to_input t =","counters":[]},{"line":"      let open Random_oracle.Input.Chunked in","counters":[{"col_start":6,"col_end":6,"count":5}]},{"line":"      Array.reduce_exn ~f:append","counters":[]},{"line":"        (Array.of_list_map","counters":[{"col_start":25,"col_end":25,"count":5}]},{"line":"           (Fold.to_list (fold t))","counters":[{"col_start":23,"col_end":23,"count":5},{"col_start":29,"col_end":29,"count":5}]},{"line":"           ~f:(fun b -> packed (field_of_bool b, 1)) )","counters":[{"col_start":24,"col_end":24,"count":1280},{"col_start":44,"col_end":44,"count":1280}]},{"line":"","counters":[]},{"line":"    let ledger_hash ({ ledger_hash; _ } : t) = ledger_hash","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"","counters":[]},{"line":"    let aux_hash ({ aux_hash; _ } : t) = aux_hash","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"","counters":[]},{"line":"    let of_ledger_aux_coinbase_hash aux_hash ledger_hash pending_coinbase_aux :","counters":[]},{"line":"        t =","counters":[]},{"line":"      { aux_hash; ledger_hash; pending_coinbase_aux }","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let var_to_input (t : var) =","counters":[]},{"line":"      let open Random_oracle.Input.Chunked in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Array.reduce_exn ~f:append","counters":[]},{"line":"        (Array.of_list_map t ~f:(fun b -> packed ((b :> Field.Var.t), 1)))","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"","counters":[]},{"line":"    let var_of_t t : var =","counters":[]},{"line":"      List.map (Fold.to_list @@ fold t) ~f:Boolean.var_of_value","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"    [%%if proof_level = \"check\"]","counters":[]},{"line":"","counters":[]},{"line":"    let warn_improper_transport () = ()","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"    [%%else]","counters":[]},{"line":"","counters":[]},{"line":"    let warn_improper_transport () =","counters":[]},{"line":"      printf \"WARNING: improperly transporting staged-ledger-hash\\n\"","counters":[]},{"line":"","counters":[]},{"line":"    [%%endif]","counters":[]},{"line":"","counters":[]},{"line":"    let typ : (var, value) Typ.t =","counters":[]},{"line":"      Typ.transport (Typ.list ~length:length_in_bits Boolean.typ)","counters":[{"col_start":18,"col_end":18,"count":1},{"col_start":28,"col_end":28,"count":1}]},{"line":"        ~there:(Fn.compose Fold.to_list fold) ~back:(fun _ ->","counters":[{"col_start":25,"col_end":25,"count":1}]},{"line":"          (* If we put a failwith here, we lose the ability to printf-inspect","counters":[]},{"line":"             * anything that uses staged-ledger-hashes from within Checked","counters":[]},{"line":"             * computations. It's useful when debugging to dump the protocol state","counters":[]},{"line":"             * and so we can just lie here instead. *)","counters":[]},{"line":"          warn_improper_transport () ; Lazy.force dummy )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Poly = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type ('non_snark, 'pending_coinbase_hash) t =","counters":[{"col_start":8,"col_end":8,"count":1},{"col_start":50,"col_end":50,"count":5}]},{"line":"              ('non_snark, 'pending_coinbase_hash) A.Poly.V1.t =","counters":[]},{"line":"          { non_snark : 'non_snark","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"          ; pending_coinbase_hash : 'pending_coinbase_hash","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"          }","counters":[]},{"line":"        [@@deriving sexp, equal, compare, hash, yojson, hlist]","counters":[{"col_start":61,"col_end":61,"count":3}]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      (** Staged ledger hash has two parts","counters":[]},{"line":"      1) merkle root of the pending coinbases","counters":[]},{"line":"      2) ledger hash, aux hash, and the FIFO order of the coinbase stacks(Non snark).","counters":[]},{"line":"      Only part 1 is required for blockchain snark computation and therefore the remaining fields of the staged ledger are grouped together as \"Non_snark\"","counters":[]},{"line":"      *)","counters":[]},{"line":"      type t =","counters":[{"col_start":6,"col_end":6,"count":2},{"col_start":11,"col_end":11,"count":1}]},{"line":"        ( Non_snark.Stable.V1.t","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":10,"col_end":10,"count":0}]},{"line":"        , Pending_coinbase.Hash_versioned.Stable.V1.t )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        Poly.Stable.V1.t","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      [@@deriving sexp, equal, compare, hash, yojson]","counters":[{"col_start":52,"col_end":52,"count":5}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  type ('a, 'b) t_ = ('a, 'b) Poly.t","counters":[]},{"line":"","counters":[]},{"line":"  type value = t [@@deriving sexp, equal, compare, hash]","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"  type var = (Non_snark.var, Pending_coinbase.Hash.var) t_","counters":[]},{"line":"","counters":[]},{"line":"  include Hashable.Make (Stable.Latest)","counters":[]},{"line":"","counters":[]},{"line":"  let ledger_hash ({ non_snark; _ } : t) = Non_snark.ledger_hash non_snark","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"","counters":[]},{"line":"  let aux_hash ({ non_snark; _ } : t) = Non_snark.aux_hash non_snark","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"  let pending_coinbase_aux ({ non_snark; _ } : t) =","counters":[]},{"line":"    Non_snark.pending_coinbase_aux non_snark","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let pending_coinbase_hash ({ pending_coinbase_hash; _ } : t) =","counters":[]},{"line":"    pending_coinbase_hash","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let pending_coinbase_hash_var ({ pending_coinbase_hash; _ } : var) =","counters":[]},{"line":"    pending_coinbase_hash","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let of_aux_ledger_and_coinbase_hash aux_hash ledger_hash pending_coinbase : t","counters":[]},{"line":"      =","counters":[]},{"line":"    { non_snark =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        Non_snark.of_ledger_aux_coinbase_hash aux_hash ledger_hash","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"          (Pending_coinbase.hash_extra pending_coinbase)","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"    ; pending_coinbase_hash = Pending_coinbase.merkle_root pending_coinbase","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let genesis ~(constraint_constants : Genesis_constants.Constraint_constants.t)","counters":[]},{"line":"      ~genesis_ledger_hash : t =","counters":[]},{"line":"    let pending_coinbase =","counters":[{"col_start":4,"col_end":4,"count":4}]},{"line":"      Pending_coinbase.create ~depth:constraint_constants.pending_coinbase_depth","counters":[{"col_start":28,"col_end":28,"count":4}]},{"line":"        ()","counters":[]},{"line":"      |> Or_error.ok_exn","counters":[]},{"line":"    in","counters":[]},{"line":"    { non_snark = Non_snark.genesis ~genesis_ledger_hash","counters":[{"col_start":4,"col_end":4,"count":4}]},{"line":"    ; pending_coinbase_hash = Pending_coinbase.merkle_root pending_coinbase","counters":[{"col_start":57,"col_end":57,"count":4}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let var_of_t ({ pending_coinbase_hash; non_snark } : t) : var =","counters":[]},{"line":"    let non_snark = Non_snark.var_of_t non_snark in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let pending_coinbase_hash =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Pending_coinbase.Hash.var_of_t pending_coinbase_hash","counters":[]},{"line":"    in","counters":[]},{"line":"    { non_snark; pending_coinbase_hash }","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let to_input ({ non_snark; pending_coinbase_hash } : t) =","counters":[]},{"line":"    Random_oracle.Input.Chunked.(","counters":[{"col_start":4,"col_end":4,"count":5}]},{"line":"      append","counters":[]},{"line":"        (Non_snark.to_input non_snark)","counters":[{"col_start":26,"col_end":26,"count":5}]},{"line":"        (field (pending_coinbase_hash :> Field.t)))","counters":[{"col_start":13,"col_end":13,"count":5}]},{"line":"","counters":[]},{"line":"  let var_to_input ({ non_snark; pending_coinbase_hash } : var) =","counters":[]},{"line":"    Random_oracle.Input.Chunked.(","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      append","counters":[]},{"line":"        (Non_snark.var_to_input non_snark)","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"        (field (Pending_coinbase.Hash.var_to_hash_packed pending_coinbase_hash)))","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"","counters":[]},{"line":"  let typ : (var, t) Typ.t =","counters":[]},{"line":"    Typ.of_hlistable","counters":[{"col_start":19,"col_end":19,"count":1}]},{"line":"      [ Non_snark.typ; Pending_coinbase.Hash.typ ]","counters":[]},{"line":"      ~var_to_hlist:Poly.to_hlist ~var_of_hlist:Poly.of_hlist","counters":[]},{"line":"      ~value_to_hlist:Poly.to_hlist ~value_of_hlist:Poly.of_hlist","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"include Wire_types.Make (Make_sig) (Make_str)","counters":[{"col_start":44,"col_end":44,"count":1}]}]}