{"filename":"src/lib/pickles/wrap.ml","lines":[{"line":"module SC = Scalar_challenge","counters":[]},{"line":"module P = Proof","counters":[]},{"line":"open Pickles_types","counters":[]},{"line":"open Hlist","counters":[]},{"line":"open Tuple_lib","counters":[]},{"line":"open Common","counters":[]},{"line":"open Core_kernel","counters":[]},{"line":"open Async_kernel","counters":[]},{"line":"open Import","counters":[]},{"line":"open Types","counters":[]},{"line":"open Backend","counters":[]},{"line":"","counters":[]},{"line":"(* This contains the \"wrap\" prover *)","counters":[]},{"line":"","counters":[]},{"line":"let challenge_polynomial =","counters":[]},{"line":"  Tick.Field.(Wrap_verifier.challenge_polynomial ~add ~mul ~one)","counters":[]},{"line":"","counters":[]},{"line":"module Plonk_checks = struct","counters":[]},{"line":"  include Plonk_checks","counters":[]},{"line":"","counters":[]},{"line":"  module Type1 =","counters":[]},{"line":"    Plonk_checks.Make","counters":[]},{"line":"      (Shifted_value.Type1)","counters":[]},{"line":"      (struct","counters":[]},{"line":"        let constant_term = Plonk_checks.Scalars.Tick.constant_term","counters":[]},{"line":"","counters":[]},{"line":"        let index_terms = Plonk_checks.Scalars.Tick_with_lookup.index_terms","counters":[]},{"line":"      end)","counters":[]},{"line":"","counters":[]},{"line":"  module Type2 =","counters":[]},{"line":"    Plonk_checks.Make (Shifted_value.Type2) (Plonk_checks.Scalars.Tock)","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let vector_of_list (type a t)","counters":[]},{"line":"    (module V : Snarky_intf.Vector.S with type elt = a and type t = t)","counters":[]},{"line":"    (xs : a list) : t =","counters":[]},{"line":"  let r = V.create () in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  List.iter xs ~f:(V.emplace_back r) ;","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"  r","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let tick_rounds = Nat.to_int Tick.Rounds.n","counters":[{"col_start":27,"col_end":27,"count":1}]},{"line":"","counters":[]},{"line":"let combined_inner_product (type actual_proofs_verified) ~env ~domain ~ft_eval1","counters":[]},{"line":"    ~actual_proofs_verified:","counters":[]},{"line":"      (module AB : Nat.Add.Intf with type n = actual_proofs_verified)","counters":[]},{"line":"    (e : _ Plonk_types.All_evals.With_public_input.t)","counters":[]},{"line":"    ~(old_bulletproof_challenges : (_, actual_proofs_verified) Vector.t) ~r","counters":[]},{"line":"    ~plonk ~xi ~zeta ~zetaw =","counters":[]},{"line":"  let combined_evals =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Plonk_checks.evals_of_split_evals ~zeta ~zetaw","counters":[]},{"line":"      (module Tick.Field)","counters":[]},{"line":"      ~rounds:tick_rounds e.evals","counters":[]},{"line":"  in","counters":[]},{"line":"  let ft_eval0 : Tick.Field.t =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Plonk_checks.Type1.ft_eval0","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"      (module Tick.Field)","counters":[]},{"line":"      plonk ~env ~domain","counters":[]},{"line":"      (Plonk_types.Evals.to_in_circuit combined_evals)","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"      (fst e.public_input)","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"      ~lookup_constant_term_part:","counters":[]},{"line":"        (Option.map plonk.joint_combiner ~f:(fun _ ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"             Plonk_checks.tick_lookup_constant_term_part ) )","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"  in","counters":[]},{"line":"  let T = AB.eq in","counters":[]},{"line":"  let challenge_polys =","counters":[]},{"line":"    Vector.map","counters":[]},{"line":"      ~f:(fun chals -> unstage (challenge_polynomial (Vector.to_array chals)))","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":51,"col_end":51,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"      old_bulletproof_challenges","counters":[]},{"line":"  in","counters":[]},{"line":"  let a = Plonk_types.Evals.to_list e.evals in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let combine ~which_eval ~ft pt =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    let f (x, y) = match which_eval with `Fst -> x | `Snd -> y in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"    let a = List.map ~f a in","counters":[]},{"line":"    let v : Tick.Field.t array list =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      List.append","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"        (List.map (Vector.to_list challenge_polys) ~f:(fun f -> [| f pt |]))","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":64,"col_end":64,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"        ([| f e.public_input |] :: [| ft |] :: a)","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"    in","counters":[]},{"line":"    let open Tick.Field in","counters":[]},{"line":"    Pcs_batch.combine_split_evaluations ~xi ~init:Fn.id","counters":[]},{"line":"      ~mul_and_add:(fun ~acc ~xi fx -> fx + (xi * acc))","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"      v","counters":[]},{"line":"  in","counters":[]},{"line":"  let open Tick.Field in","counters":[]},{"line":"  combine ~which_eval:`Fst ~ft:ft_eval0 zeta","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"  + (r * combine ~which_eval:`Snd ~ft:ft_eval1 zetaw)","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"","counters":[]},{"line":"module Deferred_values = Types.Wrap.Proof_state.Deferred_values","counters":[]},{"line":"","counters":[]},{"line":"let%test_unit \"scalars consistency\" =","counters":[]},{"line":"  let module E = struct","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    type t =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      | Add of t * t","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"      | Mul of t * t","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"      | Sub of t * t","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"      | Pow of t * int","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"      | Double of t","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Square of t","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Constant of string","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Var of Plonk_checks.Scalars.Column.t * Plonk_checks.Scalars.curr_or_next","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"      | Mds of int * int","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"      | Cell of t","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Alpha_pow of int","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Unnormalized_lagrange_basis of int","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    [@@deriving sexp, compare]","counters":[]},{"line":"  end in","counters":[]},{"line":"  let open E in","counters":[]},{"line":"  let env : E.t Plonk_checks.Scalars.Env.t =","counters":[]},{"line":"    { add = (fun x y -> Add (x, y))","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"    ; sub = (fun x y -> Sub (x, y))","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"    ; mul = (fun x y -> Mul (x, y))","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"    ; pow = (fun (x, y) -> Pow (x, y))","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"    ; square = (fun x -> Square x)","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"    ; double = (fun x -> Double x)","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"    ; var = (fun (x, y) -> Var (x, y))","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"    ; field = (fun x -> Constant x)","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"    ; mds = (fun (x, y) -> Mds (x, y))","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"    ; cell = (fun x -> Cell x)","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"    ; alpha_pow = (fun x -> Alpha_pow x)","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"    ; zk_polynomial = Constant \"zk_polynomial\"","counters":[]},{"line":"    ; omega_to_minus_3 = Constant \"omega_to_minus_3\"","counters":[]},{"line":"    ; zeta_to_n_minus_1 = Constant \"zeta_to_n_minus_1\"","counters":[]},{"line":"    ; vanishes_on_last_4_rows = Constant \"vanishes_on_last_4_rows\"","counters":[]},{"line":"    ; joint_combiner = Constant \"joint_combiner\"","counters":[]},{"line":"    ; beta = Constant \"beta\"","counters":[]},{"line":"    ; gamma = Constant \"gamma\"","counters":[]},{"line":"    ; endo_coefficient = Constant \"endo_coefficient\"","counters":[]},{"line":"    ; srs_length_log2 = Nat.to_int Backend.Tick.Rounds.n","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"    ; unnormalized_lagrange_basis = (fun x -> Unnormalized_lagrange_basis x)","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"    }","counters":[]},{"line":"  in","counters":[]},{"line":"  let lookup_terms = Plonk_checks.Scalars.Tick_with_lookup.index_terms env in","counters":[]},{"line":"  Hashtbl.iteri (Plonk_checks.Scalars.Tick.index_terms env)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"    ~f:(fun ~key ~data ->","counters":[]},{"line":"      [%test_eq: t] (Lazy.force data)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"        (Lazy.force (Hashtbl.find_exn lookup_terms key)) )","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"","counters":[]},{"line":"type scalar_challenge_constant = Challenge.Constant.t Scalar_challenge.t","counters":[]},{"line":"","counters":[]},{"line":"type deferred_values_and_hints =","counters":[]},{"line":"  { x_hat_evals : Backend.Tick.Field.t * Backend.Tick.Field.t","counters":[]},{"line":"  ; sponge_digest_before_evaluations : Tick.Field.t","counters":[]},{"line":"  ; deferred_values :","counters":[]},{"line":"      ( ( Challenge.Constant.t","counters":[]},{"line":"        , scalar_challenge_constant","counters":[]},{"line":"        , Backend.Tick.Field.t Pickles_types.Shifted_value.Type1.t","counters":[]},{"line":"        , ( ( scalar_challenge_constant","counters":[]},{"line":"            , Tick.Field.t Shifted_value.Type1.t )","counters":[]},{"line":"            Deferred_values.Plonk.In_circuit.Lookup.t","counters":[]},{"line":"          , bool )","counters":[]},{"line":"          Opt.t )","counters":[]},{"line":"        Deferred_values.Plonk.In_circuit.t","counters":[]},{"line":"      , scalar_challenge_constant","counters":[]},{"line":"      , Tick.Field.t Shifted_value.Type1.t","counters":[]},{"line":"      , Challenge.Constant.t Scalar_challenge.t Bulletproof_challenge.t","counters":[]},{"line":"        Step_bp_vec.t","counters":[]},{"line":"      , Branch_data.t )","counters":[]},{"line":"      Deferred_values.t","counters":[]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"let deferred_values (type n) ~(sgs : (Backend.Tick.Curve.Affine.t, n) Vector.t)","counters":[]},{"line":"    ~(prev_challenges : ((Backend.Tick.Field.t, _) Vector.t, n) Vector.t)","counters":[]},{"line":"    ~(step_vk : Kimchi_bindings.Protocol.VerifierIndex.Fp.t)","counters":[]},{"line":"    ~(public_input : Backend.Tick.Field.t list) ~(proof : Backend.Tick.Proof.t)","counters":[]},{"line":"    ~(actual_proofs_verified : n Nat.t) : deferred_values_and_hints =","counters":[]},{"line":"  let module O = Tick.Oracles in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let o =","counters":[]},{"line":"    O.create step_vk","counters":[]},{"line":"      Vector.(","counters":[]},{"line":"        map2 sgs prev_challenges ~f:(fun commitment cs ->","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"            { Tick.Proof.Challenge_polynomial.commitment","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            ; challenges = Vector.to_array cs","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"            } )","counters":[]},{"line":"        |> to_list)","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"      public_input proof","counters":[]},{"line":"  in","counters":[]},{"line":"  let x_hat = O.(p_eval_1 o, p_eval_2 o) in","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"  let scalar_chal f =","counters":[]},{"line":"    Scalar_challenge.map ~f:Challenge.Constant.of_tick_field (f o)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"  in","counters":[]},{"line":"  let plonk0 =","counters":[]},{"line":"    { Types.Wrap.Proof_state.Deferred_values.Plonk.Minimal.alpha =","counters":[]},{"line":"        scalar_chal O.alpha","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"    ; beta = O.beta o","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"    ; gamma = O.gamma o","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"    ; zeta = scalar_chal O.zeta","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"    ; joint_combiner =","counters":[]},{"line":"        (* TODO: Needs to be changed when lookups are fully implemented *)","counters":[]},{"line":"        Option.map (O.joint_combiner_chal o)","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"          ~f:(Scalar_challenge.map ~f:Challenge.Constant.of_tick_field)","counters":[]},{"line":"    }","counters":[]},{"line":"  in","counters":[]},{"line":"  let r = scalar_chal O.u in","counters":[]},{"line":"  let xi = scalar_chal O.v in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let module As_field = struct","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    let to_field =","counters":[]},{"line":"      SC.to_field_constant","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"        (module Tick.Field)","counters":[]},{"line":"        ~endo:Endo.Wrap_inner_curve.scalar","counters":[]},{"line":"","counters":[]},{"line":"    let r = to_field r","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"","counters":[]},{"line":"    let xi = to_field xi","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"","counters":[]},{"line":"    let zeta = to_field plonk0.zeta","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"    let alpha = to_field plonk0.alpha","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"    let joint_combiner = Option.map ~f:to_field plonk0.joint_combiner","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"  end in","counters":[]},{"line":"  let domain = Domain.Pow_2_roots_of_unity step_vk.domain.log_size_of_group in","counters":[]},{"line":"  let zetaw = Tick.Field.mul As_field.zeta step_vk.domain.group_gen in","counters":[]},{"line":"  let tick_plonk_minimal =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    { plonk0 with","counters":[]},{"line":"      zeta = As_field.zeta","counters":[]},{"line":"    ; alpha = As_field.alpha","counters":[]},{"line":"    ; joint_combiner = As_field.joint_combiner","counters":[]},{"line":"    }","counters":[]},{"line":"  in","counters":[]},{"line":"  let tick_combined_evals =","counters":[]},{"line":"    Plonk_checks.evals_of_split_evals","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"      (module Tick.Field)","counters":[]},{"line":"      proof.openings.evals ~rounds:(Nat.to_int Tick.Rounds.n)","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"      ~zeta:As_field.zeta ~zetaw","counters":[]},{"line":"    |> Plonk_types.Evals.to_in_circuit","counters":[]},{"line":"  in","counters":[]},{"line":"  let tick_domain =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Plonk_checks.domain","counters":[]},{"line":"      (module Tick.Field)","counters":[]},{"line":"      domain ~shifts:Common.tick_shifts","counters":[]},{"line":"      ~domain_generator:Backend.Tick.Field.domain_generator","counters":[]},{"line":"  in","counters":[]},{"line":"  let tick_env =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Plonk_checks.scalars_env","counters":[]},{"line":"      (module Tick.Field)","counters":[]},{"line":"      ~endo:Endo.Step_inner_curve.base ~mds:Tick_field_sponge.params.mds","counters":[]},{"line":"      ~srs_length_log2:Common.Max_degree.step_log2","counters":[]},{"line":"      ~field_of_hex:(fun s ->","counters":[]},{"line":"        Kimchi_pasta.Pasta.Bigint256.of_hex_string s","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"        |> Kimchi_pasta.Pasta.Fp.of_bigint )","counters":[]},{"line":"      ~domain:tick_domain tick_plonk_minimal tick_combined_evals","counters":[]},{"line":"  in","counters":[]},{"line":"  let plonk =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Plonk_checks.Type1.derive_plonk","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"      (module Tick.Field)","counters":[]},{"line":"      ~shift:Shifts.tick1 ~env:tick_env tick_plonk_minimal tick_combined_evals","counters":[]},{"line":"  and new_bulletproof_challenges, b =","counters":[]},{"line":"    let prechals =","counters":[]},{"line":"      Array.map (O.opening_prechallenges o) ~f:(fun x ->","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"          Scalar_challenge.map ~f:Challenge.Constant.of_tick_field x )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    in","counters":[]},{"line":"    let chals = Array.map prechals ~f:(fun x -> Ipa.Step.compute_challenge x) in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"    let challenge_poly = unstage (challenge_polynomial chals) in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"    let open As_field in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let b =","counters":[]},{"line":"      let open Tick.Field in","counters":[]},{"line":"      challenge_poly zeta + (r * challenge_poly zetaw)","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"    in","counters":[]},{"line":"    let prechals =","counters":[]},{"line":"      Array.map prechals ~f:(fun x ->","counters":[]},{"line":"          { Bulletproof_challenge.prechallenge = x } )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    in","counters":[]},{"line":"    (prechals, b)","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  in","counters":[]},{"line":"  let shift_value =","counters":[]},{"line":"    Shifted_value.Type1.of_field (module Tick.Field) ~shift:Shifts.tick1","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"  and chal = Challenge.Constant.of_tick_field in","counters":[]},{"line":"  { deferred_values =","counters":[]},{"line":"      { Types.Wrap.Proof_state.Deferred_values.xi","counters":[]},{"line":"      ; b = shift_value b","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"      ; bulletproof_challenges =","counters":[]},{"line":"          Vector.of_array_and_length_exn new_bulletproof_challenges","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"            Tick.Rounds.n","counters":[]},{"line":"      ; combined_inner_product =","counters":[]},{"line":"          shift_value","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"            As_field.(","counters":[]},{"line":"              combined_inner_product (* Note: We do not pad here. *)","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                ~actual_proofs_verified:(Nat.Add.create actual_proofs_verified)","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"                { evals = proof.openings.evals; public_input = x_hat }","counters":[]},{"line":"                ~r ~xi ~zeta ~zetaw ~old_bulletproof_challenges:prev_challenges","counters":[]},{"line":"                ~env:tick_env ~domain:tick_domain","counters":[]},{"line":"                ~ft_eval1:proof.openings.ft_eval1 ~plonk:tick_plonk_minimal)","counters":[]},{"line":"      ; branch_data =","counters":[]},{"line":"          { proofs_verified =","counters":[]},{"line":"              ( match actual_proofs_verified with","counters":[]},{"line":"              | Z ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Branch_data.Proofs_verified.N0","counters":[]},{"line":"              | S Z ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  N1","counters":[]},{"line":"              | S (S Z) ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  N2","counters":[]},{"line":"              | _ ->","counters":[]},{"line":"                  assert false )","counters":[]},{"line":"          ; domain_log2 =","counters":[]},{"line":"              Branch_data.Domain_log2.of_int_exn","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"                step_vk.domain.log_size_of_group","counters":[]},{"line":"          }","counters":[]},{"line":"      ; plonk =","counters":[]},{"line":"          { plonk with","counters":[]},{"line":"            zeta = plonk0.zeta","counters":[]},{"line":"          ; alpha = plonk0.alpha","counters":[]},{"line":"          ; beta = chal plonk0.beta","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"          ; gamma = chal plonk0.gamma","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"          ; lookup =","counters":[]},{"line":"              Opt.map plonk.lookup ~f:(fun l ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                  { l with","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    joint_combiner = Option.value_exn plonk0.joint_combiner","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"                  } )","counters":[]},{"line":"          }","counters":[]},{"line":"      }","counters":[]},{"line":"  ; x_hat_evals = x_hat","counters":[]},{"line":"  ; sponge_digest_before_evaluations = O.digest_before_evaluations o","counters":[{"col_start":65,"col_end":65,"count":0}]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"let%test \"lookup finalization\" =","counters":[]},{"line":"  let constant (Typ typ : _ Snarky_backendless.Typ.t) x =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    let xs, aux = typ.value_to_fields x in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    typ.var_of_fields (Array.map xs ~f:Impls.Step.Field.constant, aux)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"  in","counters":[]},{"line":"  let srs =","counters":[]},{"line":"    Kimchi_bindings.Protocol.SRS.Fp.create (1 lsl Common.Max_degree.step_log2)","counters":[]},{"line":"  in","counters":[]},{"line":"  let index, public_input, proof =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Kimchi_bindings.Protocol.Proof.Fp.example_with_lookup srs true","counters":[]},{"line":"  in","counters":[]},{"line":"  let vk = Kimchi_bindings.Protocol.VerifierIndex.Fp.create index in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let proof = Backend.Tick.Proof.of_backend proof in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let { deferred_values; x_hat_evals; sponge_digest_before_evaluations } =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    deferred_values ~sgs:[] ~prev_challenges:[] ~step_vk:vk","counters":[]},{"line":"      ~public_input:[ public_input ] ~proof ~actual_proofs_verified:Nat.N0.n","counters":[]},{"line":"  in","counters":[]},{"line":"  let deferred_values_typ =","counters":[]},{"line":"    let open Impls.Step in","counters":[]},{"line":"    let open Step_main_inputs in","counters":[]},{"line":"    let open Step_verifier in","counters":[]},{"line":"    Wrap.Proof_state.Deferred_values.In_circuit.typ","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"      (module Impls.Step)","counters":[]},{"line":"      ~challenge:Challenge.typ ~scalar_challenge:Challenge.typ ~lookup:Maybe","counters":[]},{"line":"      ~dummy_scalar:(Shifted_value.Type1.Shifted_value Field.Constant.zero)","counters":[]},{"line":"      ~dummy_scalar_challenge:","counters":[]},{"line":"        (Kimchi_backend_common.Scalar_challenge.create","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"           Limb_vector.Challenge.Constant.zero )","counters":[]},{"line":"      (Shifted_value.Type1.typ Field.typ)","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"      (Branch_data.typ","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"         (module Impl)","counters":[]},{"line":"         ~assert_16_bits:(Step_verifier.assert_n_bits ~n:16) )","counters":[]},{"line":"  in","counters":[]},{"line":"  let deferred_values =","counters":[]},{"line":"    constant deferred_values_typ","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"      { deferred_values with","counters":[]},{"line":"        plonk =","counters":[]},{"line":"          { deferred_values.plonk with","counters":[]},{"line":"            lookup = Opt.to_option deferred_values.plonk.lookup","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"          }","counters":[]},{"line":"      }","counters":[]},{"line":"  and evals =","counters":[]},{"line":"    constant","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"      (Plonk_types.All_evals.typ","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"         (module Impls.Step)","counters":[]},{"line":"         { lookup = Maybe; runtime = Maybe } )","counters":[]},{"line":"      { evals = { public_input = x_hat_evals; evals = proof.openings.evals }","counters":[]},{"line":"      ; ft_eval1 = proof.openings.ft_eval1","counters":[]},{"line":"      }","counters":[]},{"line":"  in","counters":[]},{"line":"  Impls.Step.run_and_check (fun () ->","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"      let res, _chals =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let sponge =","counters":[]},{"line":"          let open Step_main_inputs in","counters":[]},{"line":"          let sponge = Sponge.create sponge_params in","counters":[]},{"line":"          Sponge.absorb sponge","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (`Field (Impl.Field.constant sponge_digest_before_evaluations)) ;","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"          sponge","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        in","counters":[]},{"line":"        Step_verifier.finalize_other_proof","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"          (module Nat.N0)","counters":[]},{"line":"          ~step_uses_lookup:Maybe","counters":[]},{"line":"          ~step_domains:","counters":[]},{"line":"            (`Known [ { h = Pow_2_roots_of_unity vk.domain.log_size_of_group } ])","counters":[]},{"line":"          ~sponge ~prev_challenges:[] deferred_values evals","counters":[]},{"line":"      in","counters":[]},{"line":"      Impls.Step.(As_prover.(fun () -> read Boolean.typ res)) )","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"  |> Or_error.ok_exn","counters":[]},{"line":"","counters":[]},{"line":"module Step_acc = Tock.Inner_curve.Affine","counters":[]},{"line":"","counters":[]},{"line":"(* The prover for wrapping a proof *)","counters":[]},{"line":"let wrap","counters":[]},{"line":"    (type actual_proofs_verified max_proofs_verified","counters":[]},{"line":"    max_local_max_proofs_verifieds )","counters":[]},{"line":"    ~(max_proofs_verified : max_proofs_verified Nat.t)","counters":[]},{"line":"    (module Max_local_max_proof_verifieds : Hlist.Maxes.S","counters":[]},{"line":"      with type ns = max_local_max_proofs_verifieds","counters":[]},{"line":"       and type length = max_proofs_verified )","counters":[]},{"line":"    (( module","counters":[]},{"line":"      Req ) :","counters":[]},{"line":"      (max_proofs_verified, max_local_max_proofs_verifieds) Requests.Wrap.t )","counters":[]},{"line":"    ~dlog_plonk_index wrap_main ~(typ : _ Impls.Step.Typ.t) ~step_vk","counters":[]},{"line":"    ~actual_wrap_domains ~step_plonk_indices pk","counters":[]},{"line":"    ({ statement = prev_statement; prev_evals; proof; index = which_index } :","counters":[]},{"line":"      ( _","counters":[]},{"line":"      , _","counters":[]},{"line":"      , (_, actual_proofs_verified) Vector.t","counters":[]},{"line":"      , (_, actual_proofs_verified) Vector.t","counters":[]},{"line":"      , max_local_max_proofs_verifieds","counters":[]},{"line":"        H1.T(P.Base.Messages_for_next_proof_over_same_field.Wrap).t","counters":[]},{"line":"      , ( (Tock.Field.t, Tock.Field.t array) Plonk_types.All_evals.t","counters":[]},{"line":"        , max_proofs_verified )","counters":[]},{"line":"        Vector.t )","counters":[]},{"line":"      P.Base.Step.t ) =","counters":[]},{"line":"  let messages_for_next_wrap_proof =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    let module M =","counters":[]},{"line":"      H1.Map","counters":[]},{"line":"        (P.Base.Messages_for_next_proof_over_same_field.Wrap)","counters":[]},{"line":"        (P.Base.Messages_for_next_proof_over_same_field.Wrap.Prepared)","counters":[]},{"line":"        (struct","counters":[]},{"line":"          let f = P.Base.Messages_for_next_proof_over_same_field.Wrap.prepare","counters":[]},{"line":"        end)","counters":[]},{"line":"    in","counters":[]},{"line":"    M.f prev_statement.messages_for_next_wrap_proof","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  in","counters":[]},{"line":"  let prev_statement_with_hashes : _ Types.Step.Statement.t =","counters":[]},{"line":"    { proof_state =","counters":[]},{"line":"        { prev_statement.proof_state with","counters":[]},{"line":"          messages_for_next_step_proof =","counters":[]},{"line":"            (let to_field_elements =","counters":[]},{"line":"               let (Typ typ) = typ in","counters":[]},{"line":"               fun x -> fst (typ.value_to_fields x)","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"             in","counters":[]},{"line":"             (* TODO: Careful here... the length of","counters":[]},{"line":"                old_buletproof_challenges inside the messages_for_next_step_proof","counters":[]},{"line":"                might not be correct *)","counters":[]},{"line":"             Common.hash_messages_for_next_step_proof","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"               ~app_state:to_field_elements","counters":[]},{"line":"               (P.Base.Messages_for_next_proof_over_same_field.Step.prepare","counters":[{"col_start":74,"col_end":74,"count":0}]},{"line":"                  ~dlog_plonk_index","counters":[]},{"line":"                  prev_statement.proof_state.messages_for_next_step_proof ) )","counters":[]},{"line":"        }","counters":[]},{"line":"    ; messages_for_next_wrap_proof =","counters":[]},{"line":"        (let module M =","counters":[]},{"line":"           H1.Map","counters":[]},{"line":"             (P.Base.Messages_for_next_proof_over_same_field.Wrap.Prepared)","counters":[]},{"line":"             (E01 (Digest.Constant))","counters":[]},{"line":"             (struct","counters":[]},{"line":"               let f (type n)","counters":[]},{"line":"                   (m :","counters":[]},{"line":"                     n","counters":[]},{"line":"                     P.Base.Messages_for_next_proof_over_same_field.Wrap","counters":[]},{"line":"                     .Prepared","counters":[]},{"line":"                     .t ) =","counters":[]},{"line":"                 Wrap_hack.hash_messages_for_next_wrap_proof","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                   (Vector.length m.old_bulletproof_challenges)","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                   m","counters":[]},{"line":"             end)","counters":[]},{"line":"         in","counters":[]},{"line":"        let module V = H1.To_vector (Digest.Constant) in","counters":[]},{"line":"        V.f Max_local_max_proof_verifieds.length","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          (M.f messages_for_next_wrap_proof) )","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"    }","counters":[]},{"line":"  in","counters":[]},{"line":"  let handler (Snarky_backendless.Request.With { request; respond }) =","counters":[]},{"line":"    let open Req in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let k x = respond (Provide x) in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"    match request with","counters":[]},{"line":"    | Evals ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        k prev_evals","counters":[]},{"line":"    | Step_accs ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let module M =","counters":[]},{"line":"          H1.Map","counters":[]},{"line":"            (P.Base.Messages_for_next_proof_over_same_field.Wrap.Prepared)","counters":[]},{"line":"            (E01 (Step_acc))","counters":[]},{"line":"            (struct","counters":[]},{"line":"              let f :","counters":[]},{"line":"                  type a.","counters":[]},{"line":"                     a","counters":[]},{"line":"                     P.Base.Messages_for_next_proof_over_same_field.Wrap.Prepared","counters":[]},{"line":"                     .t","counters":[]},{"line":"                  -> Step_acc.t =","counters":[]},{"line":"               fun t -> t.challenge_polynomial_commitment","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"            end)","counters":[]},{"line":"        in","counters":[]},{"line":"        let module V = H1.To_vector (Step_acc) in","counters":[]},{"line":"        k","counters":[]},{"line":"          (V.f Max_local_max_proof_verifieds.length","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"             (M.f messages_for_next_wrap_proof) )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"    | Old_bulletproof_challenges ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let module M =","counters":[]},{"line":"          H1.Map","counters":[]},{"line":"            (P.Base.Messages_for_next_proof_over_same_field.Wrap.Prepared)","counters":[]},{"line":"            (Challenges_vector.Constant)","counters":[]},{"line":"            (struct","counters":[]},{"line":"              let f","counters":[]},{"line":"                  (t :","counters":[]},{"line":"                    _","counters":[]},{"line":"                    P.Base.Messages_for_next_proof_over_same_field.Wrap.Prepared","counters":[]},{"line":"                    .t ) =","counters":[]},{"line":"                t.old_bulletproof_challenges","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"            end)","counters":[]},{"line":"        in","counters":[]},{"line":"        k (M.f messages_for_next_wrap_proof)","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"    | Messages ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        k proof.messages","counters":[]},{"line":"    | Openings_proof ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        k proof.openings.proof","counters":[]},{"line":"    | Proof_state ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        k prev_statement_with_hashes.proof_state","counters":[]},{"line":"    | Which_branch ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        k which_index","counters":[]},{"line":"    | Wrap_domain_indices ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let all_possible_domains = Wrap_verifier.all_possible_domains () in","counters":[]},{"line":"        let wrap_domain_indices =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Vector.map actual_wrap_domains ~f:(fun domain_size ->","counters":[]},{"line":"              let domain_index =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Vector.foldi ~init:0 all_possible_domains","counters":[]},{"line":"                  ~f:(fun j acc (Pow_2_roots_of_unity domain) ->","counters":[]},{"line":"                    if Int.equal domain domain_size then j else acc )","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":57,"col_end":57,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"              in","counters":[]},{"line":"              Tock.Field.of_int domain_index )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"        in","counters":[]},{"line":"        k","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (Vector.extend_exn wrap_domain_indices max_proofs_verified","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"             Tock.Field.one )","counters":[]},{"line":"    | _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Snarky_backendless.Request.unhandled","counters":[]},{"line":"  in","counters":[]},{"line":"  let module O = Tick.Oracles in","counters":[]},{"line":"  let public_input =","counters":[]},{"line":"    tick_public_input_of_statement ~max_proofs_verified","counters":[]},{"line":"      prev_statement_with_hashes ~uses_lookup:No","counters":[]},{"line":"  in","counters":[]},{"line":"  let prev_challenges =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Vector.map ~f:Ipa.Step.compute_challenges","counters":[]},{"line":"      prev_statement.proof_state.messages_for_next_step_proof","counters":[]},{"line":"        .old_bulletproof_challenges","counters":[]},{"line":"  in","counters":[]},{"line":"  let actual_proofs_verified = Vector.length prev_challenges in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let lte =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Nat.lte_exn actual_proofs_verified","counters":[]},{"line":"      (Length.to_nat Max_local_max_proof_verifieds.length)","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"  in","counters":[]},{"line":"  let sgs =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    let module M =","counters":[]},{"line":"      H1.Map","counters":[]},{"line":"        (P.Base.Messages_for_next_proof_over_same_field.Wrap.Prepared)","counters":[]},{"line":"        (E01 (Tick.Curve.Affine))","counters":[]},{"line":"        (struct","counters":[]},{"line":"          let f :","counters":[]},{"line":"              type n.","counters":[]},{"line":"                 n P.Base.Messages_for_next_proof_over_same_field.Wrap.Prepared.t","counters":[]},{"line":"              -> _ =","counters":[]},{"line":"           fun t -> t.challenge_polynomial_commitment","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"        end)","counters":[]},{"line":"    in","counters":[]},{"line":"    let module V = H1.To_vector (Tick.Curve.Affine) in","counters":[]},{"line":"    Vector.trim","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"      (V.f Max_local_max_proof_verifieds.length","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"         (M.f messages_for_next_wrap_proof) )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"      lte","counters":[]},{"line":"  in","counters":[]},{"line":"  let { deferred_values; x_hat_evals; sponge_digest_before_evaluations } =","counters":[]},{"line":"    deferred_values ~sgs ~prev_challenges ~step_vk ~public_input ~proof","counters":[]},{"line":"      ~actual_proofs_verified","counters":[]},{"line":"  in","counters":[]},{"line":"  let next_statement : _ Types.Wrap.Statement.In_circuit.t =","counters":[]},{"line":"    let messages_for_next_wrap_proof :","counters":[]},{"line":"        _ P.Base.Messages_for_next_proof_over_same_field.Wrap.t =","counters":[]},{"line":"      { challenge_polynomial_commitment =","counters":[]},{"line":"          proof.openings.proof.challenge_polynomial_commitment","counters":[]},{"line":"      ; old_bulletproof_challenges =","counters":[]},{"line":"          Vector.map prev_statement.proof_state.unfinalized_proofs ~f:(fun t ->","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"              t.deferred_values.bulletproof_challenges )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"      }","counters":[]},{"line":"    in","counters":[]},{"line":"    { proof_state =","counters":[]},{"line":"        { deferred_values","counters":[]},{"line":"        ; sponge_digest_before_evaluations =","counters":[]},{"line":"            Digest.Constant.of_tick_field sponge_digest_before_evaluations","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"        ; messages_for_next_wrap_proof","counters":[]},{"line":"        }","counters":[]},{"line":"    ; messages_for_next_step_proof =","counters":[]},{"line":"        prev_statement.proof_state.messages_for_next_step_proof","counters":[]},{"line":"    }","counters":[]},{"line":"  in","counters":[]},{"line":"  let messages_for_next_wrap_proof_prepared =","counters":[]},{"line":"    P.Base.Messages_for_next_proof_over_same_field.Wrap.prepare","counters":[]},{"line":"      next_statement.proof_state.messages_for_next_wrap_proof","counters":[]},{"line":"  in","counters":[]},{"line":"  let%map.Promise next_proof =","counters":[]},{"line":"    let (T (input, conv, _conv_inv)) = Impls.Wrap.input () in","counters":[]},{"line":"    Common.time \"wrap proof\" (fun () ->","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":14,"col_end":14,"count":0}]},{"line":"        Impls.Wrap.generate_witness_conv","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ~f:(fun { Impls.Wrap.Proof_inputs.auxiliary_inputs; public_inputs } () ->","counters":[]},{"line":"            Backend.Tock.Proof.create_async ~primary:public_inputs","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              ~auxiliary:auxiliary_inputs pk","counters":[]},{"line":"              ~message:","counters":[]},{"line":"                ( Vector.map2","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                    (Vector.extend_exn","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                       prev_statement.proof_state.messages_for_next_step_proof","counters":[]},{"line":"                         .challenge_polynomial_commitments max_proofs_verified","counters":[]},{"line":"                       (Lazy.force Dummy.Ipa.Wrap.sg) )","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"                    messages_for_next_wrap_proof_prepared","counters":[]},{"line":"                      .old_bulletproof_challenges","counters":[]},{"line":"                    ~f:(fun sg chals ->","counters":[]},{"line":"                      { Tock.Proof.Challenge_polynomial.commitment = sg","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                      ; challenges = Vector.to_array chals","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                      } )","counters":[]},{"line":"                |> Wrap_hack.pad_accumulator ) )","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"          ~input_typ:input","counters":[]},{"line":"          ~return_typ:(Snarky_backendless.Typ.unit ())","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"          (fun x () : unit ->","counters":[]},{"line":"            Impls.Wrap.handle (fun () : unit -> wrap_main (conv x)) handler )","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":48,"col_end":48,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"          { messages_for_next_step_proof =","counters":[]},{"line":"              prev_statement_with_hashes.proof_state","counters":[]},{"line":"                .messages_for_next_step_proof","counters":[]},{"line":"          ; proof_state =","counters":[]},{"line":"              { next_statement.proof_state with","counters":[]},{"line":"                messages_for_next_wrap_proof =","counters":[]},{"line":"                  Wrap_hack.hash_messages_for_next_wrap_proof","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"                    max_proofs_verified messages_for_next_wrap_proof_prepared","counters":[]},{"line":"              ; deferred_values =","counters":[]},{"line":"                  { next_statement.proof_state.deferred_values with","counters":[]},{"line":"                    plonk =","counters":[]},{"line":"                      { next_statement.proof_state.deferred_values.plonk with","counters":[]},{"line":"                        lookup =","counters":[]},{"line":"                          (* TODO: This assumes wrap circuits do not use lookup *)","counters":[]},{"line":"                          None","counters":[]},{"line":"                      }","counters":[]},{"line":"                  }","counters":[]},{"line":"              }","counters":[]},{"line":"          } )","counters":[]},{"line":"  in","counters":[]},{"line":"  ( { proof = next_proof","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    ; statement =","counters":[]},{"line":"        Types.Wrap.Statement.to_minimal next_statement ~to_option:Opt.to_option","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"    ; prev_evals =","counters":[]},{"line":"        { Plonk_types.All_evals.evals =","counters":[]},{"line":"            { public_input = x_hat_evals; evals = proof.openings.evals }","counters":[]},{"line":"        ; ft_eval1 = proof.openings.ft_eval1","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"    : _ P.Base.Wrap.t )","counters":[{"col_start":22,"col_end":22,"count":2}]}]}