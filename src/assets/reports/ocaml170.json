{"filename":"src/lib/pickles/verify.ml","lines":[{"line":"module SC = Scalar_challenge","counters":[]},{"line":"open Core_kernel","counters":[]},{"line":"open Async_kernel","counters":[]},{"line":"open Pickles_types","counters":[]},{"line":"open Common","counters":[]},{"line":"open Import","counters":[]},{"line":"open Backend","counters":[]},{"line":"open Tuple_lib","counters":[]},{"line":"","counters":[]},{"line":"module Instance = struct","counters":[]},{"line":"  type t =","counters":[]},{"line":"    | T :","counters":[]},{"line":"        (module Nat.Intf with type n = 'n)","counters":[]},{"line":"        * (module Intf.Statement_value with type t = 'a)","counters":[]},{"line":"        * Verification_key.t","counters":[]},{"line":"        * 'a","counters":[]},{"line":"        * ('n, 'n) Proof.t","counters":[]},{"line":"        -> t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(* TODO: Just stick this in plonk_checks.ml *)","counters":[]},{"line":"module Plonk_checks = struct","counters":[]},{"line":"  include Plonk_checks","counters":[]},{"line":"  module Type1 =","counters":[]},{"line":"    Plonk_checks.Make (Shifted_value.Type1) (Plonk_checks.Scalars.Tick)","counters":[]},{"line":"  module Type2 =","counters":[]},{"line":"    Plonk_checks.Make (Shifted_value.Type2) (Plonk_checks.Scalars.Tock)","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let verify_heterogenous (ts : Instance.t list) =","counters":[]},{"line":"  let module Plonk = Types.Wrap.Proof_state.Deferred_values.Plonk in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let module Tick_field = Backend.Tick.Field in","counters":[]},{"line":"  let tick_field : _ Plonk_checks.field = (module Tick_field) in","counters":[]},{"line":"  let check, result =","counters":[]},{"line":"    let r = ref [] in","counters":[]},{"line":"    let result () =","counters":[]},{"line":"      match !r with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | [] ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Ok ()","counters":[]},{"line":"      | _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Error","counters":[]},{"line":"            (String.concat ~sep:\"\\n\"","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"               (List.map !r ~f:(fun lab -> Lazy.force lab)) )","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"    in","counters":[]},{"line":"    ((fun (lab, b) -> if not b then r := lab :: !r), result)","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"  in","counters":[]},{"line":"  let in_circuit_plonks, computed_bp_chals =","counters":[]},{"line":"    List.map ts","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"      ~f:(fun","counters":[]},{"line":"           (T","counters":[]},{"line":"             ( _max_proofs_verified","counters":[]},{"line":"             , _statement","counters":[]},{"line":"             , key","counters":[]},{"line":"             , app_state","counters":[]},{"line":"             , T","counters":[]},{"line":"                 { statement","counters":[]},{"line":"                   (* TODO","counters":[]},{"line":"                      ; prev_x_hat = (x_hat1, _) as prev_x_hat","counters":[]},{"line":"                   *)","counters":[]},{"line":"                 ; prev_evals = evals","counters":[]},{"line":"                 } ) )","counters":[]},{"line":"         ->","counters":[]},{"line":"        Timer.start __LOC__ ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let statement =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          { statement with","counters":[]},{"line":"            messages_for_next_step_proof =","counters":[]},{"line":"              { statement.messages_for_next_step_proof with app_state }","counters":[]},{"line":"          }","counters":[]},{"line":"        in","counters":[]},{"line":"        let open Types.Wrap.Proof_state in","counters":[]},{"line":"        let sc =","counters":[]},{"line":"          SC.to_field_constant tick_field ~endo:Endo.Wrap_inner_curve.scalar","counters":[]},{"line":"        in","counters":[]},{"line":"        Timer.clock __LOC__ ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let { Deferred_values.xi","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            ; plonk = plonk0","counters":[]},{"line":"            ; combined_inner_product","counters":[]},{"line":"            ; branch_data","counters":[]},{"line":"            ; bulletproof_challenges","counters":[]},{"line":"            ; b","counters":[]},{"line":"            } =","counters":[]},{"line":"          Deferred_values.map_challenges ~f:Challenge.Constant.to_tick_field","counters":[]},{"line":"            ~scalar:sc statement.proof_state.deferred_values","counters":[]},{"line":"        in","counters":[]},{"line":"        let zeta = sc plonk0.zeta in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let alpha = sc plonk0.alpha in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let step_domain = Branch_data.domain branch_data in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        check","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ( lazy \"domain size is small enough\"","counters":[]},{"line":"          , Domain.log2_size step_domain <= Nat.to_int Backend.Tick.Rounds.n ) ;","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"        let w =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Tick.Field.domain_generator ~log2_size:(Domain.log2_size step_domain)","counters":[{"col_start":65,"col_end":65,"count":0}]},{"line":"        in","counters":[]},{"line":"        let zetaw = Tick.Field.mul zeta w in","counters":[]},{"line":"        let tick_plonk_minimal :","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            _ Composition_types.Wrap.Proof_state.Deferred_values.Plonk.Minimal.t","counters":[]},{"line":"            =","counters":[]},{"line":"          let chal = Challenge.Constant.to_tick_field in","counters":[]},{"line":"          { zeta","counters":[]},{"line":"          ; alpha","counters":[]},{"line":"          ; beta = chal plonk0.beta","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"          ; gamma = chal plonk0.gamma","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"          ; joint_combiner = Option.map ~f:sc plonk0.joint_combiner","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"          }","counters":[]},{"line":"        in","counters":[]},{"line":"        let tick_combined_evals =","counters":[]},{"line":"          Plonk_checks.evals_of_split_evals","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"            (module Tick.Field)","counters":[]},{"line":"            evals.evals.evals ~rounds:(Nat.to_int Tick.Rounds.n) ~zeta ~zetaw","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"          |> Plonk_types.Evals.to_in_circuit","counters":[]},{"line":"        in","counters":[]},{"line":"        let tick_domain =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Plonk_checks.domain","counters":[]},{"line":"            (module Tick.Field)","counters":[]},{"line":"            step_domain ~shifts:Common.tick_shifts","counters":[]},{"line":"            ~domain_generator:Backend.Tick.Field.domain_generator","counters":[]},{"line":"        in","counters":[]},{"line":"        let tick_env =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Plonk_checks.scalars_env","counters":[]},{"line":"            (module Tick.Field)","counters":[]},{"line":"            ~endo:Endo.Step_inner_curve.base ~mds:Tick_field_sponge.params.mds","counters":[]},{"line":"            ~srs_length_log2:Common.Max_degree.step_log2","counters":[]},{"line":"            ~field_of_hex:(fun s ->","counters":[]},{"line":"              Kimchi_pasta.Pasta.Bigint256.of_hex_string s","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"              |> Kimchi_pasta.Pasta.Fp.of_bigint )","counters":[]},{"line":"            ~domain:tick_domain tick_plonk_minimal tick_combined_evals","counters":[]},{"line":"        in","counters":[]},{"line":"        let plonk =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let p =","counters":[]},{"line":"            Plonk_checks.Type1.derive_plonk","counters":[]},{"line":"              (module Tick.Field)","counters":[]},{"line":"              ~shift:Shifts.tick1 ~env:tick_env tick_plonk_minimal","counters":[]},{"line":"              tick_combined_evals","counters":[]},{"line":"          in","counters":[]},{"line":"          { p with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            zeta = plonk0.zeta","counters":[]},{"line":"          ; alpha = plonk0.alpha","counters":[]},{"line":"          ; beta = plonk0.beta","counters":[]},{"line":"          ; gamma = plonk0.gamma","counters":[]},{"line":"          ; lookup =","counters":[]},{"line":"              Option.map (Plonk_types.Opt.to_option p.lookup) ~f:(fun l ->","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"                  { Types.Wrap.Proof_state.Deferred_values.Plonk.In_circuit","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    .Lookup","counters":[]},{"line":"                    .lookup_gate = l.lookup_gate","counters":[]},{"line":"                  ; joint_combiner = Option.value_exn plonk0.joint_combiner","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"                  } )","counters":[]},{"line":"          }","counters":[]},{"line":"        in","counters":[]},{"line":"        Timer.clock __LOC__ ;","counters":[]},{"line":"        let absorb, squeeze =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let open Tick_field_sponge.Bits in","counters":[]},{"line":"          let sponge =","counters":[]},{"line":"            let s = create Tick_field_sponge.params in","counters":[]},{"line":"            absorb s","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (Digest.Constant.to_tick_field","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"                 statement.proof_state.sponge_digest_before_evaluations ) ;","counters":[]},{"line":"            s","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          in","counters":[]},{"line":"          let squeeze () =","counters":[]},{"line":"            let underlying =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Challenge.Constant.of_bits","counters":[]},{"line":"                (squeeze sponge ~length:Challenge.Constant.length)","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"            in","counters":[]},{"line":"            sc (Scalar_challenge.create underlying)","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"          in","counters":[]},{"line":"          (absorb sponge, squeeze)","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"        in","counters":[]},{"line":"        let old_bulletproof_challenges =","counters":[]},{"line":"          Vector.map ~f:Ipa.Step.compute_challenges","counters":[]},{"line":"            statement.messages_for_next_step_proof.old_bulletproof_challenges","counters":[]},{"line":"        in","counters":[]},{"line":"        (let challenges_digest =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"           let open Tick_field_sponge.Field in","counters":[]},{"line":"           let sponge = create Tick_field_sponge.params in","counters":[]},{"line":"           Vector.iter old_bulletproof_challenges","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"             ~f:(Vector.iter ~f:(absorb sponge)) ;","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"           squeeze sponge","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"         in","counters":[]},{"line":"         absorb challenges_digest ;","counters":[]},{"line":"         absorb evals.ft_eval1 ;","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"         let xs = Plonk_types.Evals.to_absorption_sequence evals.evals.evals in","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"         let x1, x2 = evals.evals.public_input in","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"         absorb x1 ;","counters":[]},{"line":"         absorb x2 ;","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"         List.iter xs ~f:(fun (x1, x2) ->","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"             Array.iter ~f:absorb x1 ; Array.iter ~f:absorb x2 ) ) ;","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"        let xi_actual = squeeze () in","counters":[]},{"line":"        let r_actual = squeeze () in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Timer.clock __LOC__ ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        (* TODO: The deferred values \"bulletproof_challenges\" should get routed","counters":[]},{"line":"           into a \"batch dlog Tick acc verifier\" *)","counters":[]},{"line":"        let actual_proofs_verified = Vector.length old_bulletproof_challenges in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Timer.clock __LOC__ ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let combined_inner_product_actual =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Wrap.combined_inner_product ~env:tick_env ~plonk:tick_plonk_minimal","counters":[]},{"line":"            ~domain:tick_domain ~ft_eval1:evals.ft_eval1","counters":[]},{"line":"            ~actual_proofs_verified:(Nat.Add.create actual_proofs_verified)","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"            evals.evals ~old_bulletproof_challenges ~r:r_actual ~xi ~zeta ~zetaw","counters":[]},{"line":"        in","counters":[]},{"line":"        let check_eq lab x y =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          check","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ( lazy","counters":[]},{"line":"                (sprintf","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                   !\"%s: %{sexp:Tick_field.t} != %{sexp:Tick_field.t}\"","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                   lab x y )","counters":[]},{"line":"            , Tick_field.equal x y )","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"        in","counters":[]},{"line":"        Timer.clock __LOC__ ;","counters":[]},{"line":"        let bulletproof_challenges =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Ipa.Step.compute_challenges bulletproof_challenges","counters":[]},{"line":"        in","counters":[]},{"line":"        Timer.clock __LOC__ ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let shifted_value =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Shifted_value.Type1.to_field (module Tick.Field) ~shift:Shifts.tick1","counters":[]},{"line":"        in","counters":[]},{"line":"        let b_actual =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let challenge_poly =","counters":[]},{"line":"            unstage","counters":[]},{"line":"              (Wrap.challenge_polynomial","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"                 (Vector.to_array bulletproof_challenges) )","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"          in","counters":[]},{"line":"          Tick.Field.(challenge_poly zeta + (r_actual * challenge_poly zetaw))","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"        in","counters":[]},{"line":"        let () =","counters":[]},{"line":"          let [ Pow_2_roots_of_unity greatest_wrap_domain","counters":[]},{"line":"              ; _","counters":[]},{"line":"              ; Pow_2_roots_of_unity least_wrap_domain","counters":[]},{"line":"              ] =","counters":[]},{"line":"            Wrap_verifier.all_possible_domains ()","counters":[]},{"line":"          in","counters":[]},{"line":"          let actual_wrap_domain = key.index.domain.log_size_of_group in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          check","counters":[]},{"line":"            ( lazy","counters":[]},{"line":"                (sprintf !\"wrap_domain: %i > %i\" actual_wrap_domain","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                   least_wrap_domain )","counters":[]},{"line":"            , Int.( <= ) actual_wrap_domain least_wrap_domain ) ;","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"          check","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":14,"col_end":14,"count":0}]},{"line":"            ( lazy","counters":[]},{"line":"                (sprintf !\"wrap_domain: %i < %i\" actual_wrap_domain","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                   greatest_wrap_domain )","counters":[]},{"line":"            , Int.( >= ) actual_wrap_domain greatest_wrap_domain )","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"        in","counters":[]},{"line":"        List.iter","counters":[]},{"line":"          ~f:(fun (s, x, y) -> check_eq s x y)","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"          (* Both these values can actually be omitted from the proof on the wire since we recompute them","counters":[]},{"line":"             anyway. *)","counters":[]},{"line":"          [ (\"xi\", xi, xi_actual)","counters":[]},{"line":"          ; ( \"combined_inner_product\"","counters":[]},{"line":"            , shifted_value combined_inner_product","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"            , combined_inner_product_actual )","counters":[]},{"line":"          ; (\"b\", shifted_value b, b_actual)","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"          ] ;","counters":[]},{"line":"        (plonk, bulletproof_challenges) )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    |> List.unzip","counters":[]},{"line":"  in","counters":[]},{"line":"  let open Backend.Tock.Proof in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let open Promise.Let_syntax in","counters":[]},{"line":"  let%bind accumulator_check =","counters":[]},{"line":"    Ipa.Step.accumulator_check","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"      (List.map ts ~f:(fun (T (_, _, _, _, T t)) ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"           ( t.statement.proof_state.messages_for_next_wrap_proof","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"               .challenge_polynomial_commitment","counters":[]},{"line":"           , Ipa.Step.compute_challenges","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"               t.statement.proof_state.deferred_values.bulletproof_challenges ) )","counters":[]},{"line":"      )","counters":[]},{"line":"  in","counters":[]},{"line":"  Common.time \"batch_step_dlog_check\" (fun () ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      check (lazy \"batch_step_dlog_check\", accumulator_check) ) ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  let%map dlog_check =","counters":[]},{"line":"    batch_verify","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"      (List.map2_exn ts in_circuit_plonks","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"         ~f:(fun","counters":[]},{"line":"              (T","counters":[]},{"line":"                ( (module Max_proofs_verified)","counters":[]},{"line":"                , (module A_value)","counters":[]},{"line":"                , key","counters":[]},{"line":"                , app_state","counters":[]},{"line":"                , T t ) )","counters":[]},{"line":"              plonk","counters":[]},{"line":"            ->","counters":[]},{"line":"           let prepared_statement : _ Types.Wrap.Statement.In_circuit.t =","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"             { messages_for_next_step_proof =","counters":[]},{"line":"                 Common.hash_messages_for_next_step_proof","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"                   ~app_state:A_value.to_field_elements","counters":[]},{"line":"                   (Reduced_messages_for_next_proof_over_same_field.Step.prepare","counters":[{"col_start":79,"col_end":79,"count":0}]},{"line":"                      ~dlog_plonk_index:key.commitments","counters":[]},{"line":"                      { t.statement.messages_for_next_step_proof with","counters":[]},{"line":"                        app_state","counters":[]},{"line":"                      } )","counters":[]},{"line":"             ; proof_state =","counters":[]},{"line":"                 { t.statement.proof_state with","counters":[]},{"line":"                   deferred_values =","counters":[]},{"line":"                     { t.statement.proof_state.deferred_values with plonk }","counters":[]},{"line":"                 ; messages_for_next_wrap_proof =","counters":[]},{"line":"                     Wrap_hack.hash_messages_for_next_wrap_proof","counters":[{"col_start":63,"col_end":63,"count":0}]},{"line":"                       Max_proofs_verified.n","counters":[]},{"line":"                       (Reduced_messages_for_next_proof_over_same_field.Wrap","counters":[]},{"line":"                        .prepare","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                          t.statement.proof_state.messages_for_next_wrap_proof )","counters":[]},{"line":"                 }","counters":[]},{"line":"             }","counters":[]},{"line":"           in","counters":[]},{"line":"           let input =","counters":[]},{"line":"             tock_unpadded_public_input_of_statement prepared_statement","counters":[]},{"line":"           in","counters":[]},{"line":"           ( key.index","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"           , t.proof","counters":[]},{"line":"           , input","counters":[]},{"line":"           , Some","counters":[]},{"line":"               (Wrap_hack.pad_accumulator","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"                  (Vector.map2","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                     ~f:(fun g cs ->","counters":[]},{"line":"                       { Challenge_polynomial.challenges =","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                           Vector.to_array (Ipa.Wrap.compute_challenges cs)","counters":[{"col_start":41,"col_end":41,"count":0},{"col_start":70,"col_end":70,"count":0}]},{"line":"                       ; commitment = g","counters":[]},{"line":"                       } )","counters":[]},{"line":"                     (Vector.extend_exn","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"                        t.statement.messages_for_next_step_proof","counters":[]},{"line":"                          .challenge_polynomial_commitments","counters":[]},{"line":"                        Max_proofs_verified.n","counters":[]},{"line":"                        (Lazy.force Dummy.Ipa.Wrap.sg) )","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"                     t.statement.proof_state.messages_for_next_wrap_proof","counters":[]},{"line":"                       .old_bulletproof_challenges ) ) ) ) )","counters":[]},{"line":"  in","counters":[]},{"line":"  Common.time \"dlog_check\" (fun () -> check (lazy \"dlog_check\", dlog_check)) ;","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"  match result () with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | Ok () ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      true","counters":[]},{"line":"  | Error e ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      eprintf !\"bad verify: %s\\n%!\" e ;","counters":[]},{"line":"      false","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"let verify (type a return_typ n)","counters":[]},{"line":"    (max_proofs_verified : (module Nat.Intf with type n = n))","counters":[]},{"line":"    (a_value : (module Intf.Statement_value with type t = a))","counters":[]},{"line":"    (key : Verification_key.t) (ts : (a * (n, n) Proof.t) list) =","counters":[]},{"line":"  verify_heterogenous","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    (List.map ts ~f:(fun (x, p) ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"         Instance.T (max_proofs_verified, a_value, key, x, p) ) )","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":64,"col_end":64,"count":2}]}]}