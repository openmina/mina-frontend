{"filename":"src/lib/rocksdb/serializable.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"module Make (Key : Binable.S) (Value : Binable.S) :","counters":[]},{"line":"  Key_value_database.Intf.S","counters":[]},{"line":"    with module M := Key_value_database.Monad.Ident","counters":[]},{"line":"     and type key := Key.t","counters":[]},{"line":"     and type value := Value.t","counters":[]},{"line":"     and type config := string = struct","counters":[]},{"line":"  type t = Database.t","counters":[]},{"line":"","counters":[]},{"line":"  let create directory = Database.create directory","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"  let close = Database.close","counters":[]},{"line":"","counters":[]},{"line":"  let get t ~key =","counters":[]},{"line":"    let open Option.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let%map serialized_value =","counters":[]},{"line":"      Database.get t ~key:(Binable.to_bigstring (module Key) key)","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"    in","counters":[]},{"line":"    Binable.of_bigstring (module Value) serialized_value","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let get_batch t ~keys =","counters":[]},{"line":"    Database.get_batch t","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"      ~keys:(List.map keys ~f:(Binable.to_bigstring (module Key)))","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"    |> List.map ~f:(Option.map ~f:(Binable.of_bigstring (module Value)))","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"","counters":[]},{"line":"  let set t ~key ~data =","counters":[]},{"line":"    Database.set t","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ~key:(Binable.to_bigstring (module Key) key)","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"      ~data:(Binable.to_bigstring (module Value) data)","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"","counters":[]},{"line":"  let set_batch t ?(remove_keys = []) ~update_pairs =","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"    let key_data_pairs =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      List.map update_pairs ~f:(fun (key, data) ->","counters":[]},{"line":"          ( Binable.to_bigstring (module Key) key","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"          , Binable.to_bigstring (module Value) data ) )","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"    in","counters":[]},{"line":"    let remove_keys =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      List.map remove_keys ~f:(Binable.to_bigstring (module Key))","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"    in","counters":[]},{"line":"    Database.set_batch t ~remove_keys ~key_data_pairs","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let remove t ~key =","counters":[]},{"line":"    Database.remove t ~key:(Binable.to_bigstring (module Key) key)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"","counters":[]},{"line":"  let to_alist t =","counters":[]},{"line":"    List.map (Database.to_alist t) ~f:(fun (key, value) ->","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"        ( Binable.of_bigstring (module Key) key","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"        , Binable.of_bigstring (module Value) value ) )","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(** Database Interface for storing heterogeneous key-value pairs. Similar to","counters":[]},{"line":"    Janestreet's Core.Univ_map *)","counters":[]},{"line":"module GADT = struct","counters":[]},{"line":"  module type Database_intf = sig","counters":[]},{"line":"    type t","counters":[]},{"line":"","counters":[]},{"line":"    type 'a g","counters":[]},{"line":"","counters":[]},{"line":"    val set : t -> key:'a g -> data:'a -> unit","counters":[]},{"line":"","counters":[]},{"line":"    val set_raw : t -> key:'a g -> data:Bigstring.t -> unit","counters":[]},{"line":"","counters":[]},{"line":"    val remove : t -> key:'a g -> unit","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module type S = sig","counters":[]},{"line":"    include Database_intf","counters":[]},{"line":"","counters":[]},{"line":"    module T : sig","counters":[]},{"line":"      type nonrec t = t","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    val create : string -> t","counters":[]},{"line":"","counters":[]},{"line":"    val close : t -> unit","counters":[]},{"line":"","counters":[]},{"line":"    val get : t -> key:'a g -> 'a option","counters":[]},{"line":"","counters":[]},{"line":"    val get_raw : t -> key:'a g -> Bigstring.t option","counters":[]},{"line":"","counters":[]},{"line":"    module Batch : sig","counters":[]},{"line":"      include Database_intf with type 'a g := 'a g","counters":[]},{"line":"","counters":[]},{"line":"      val with_batch : T.t -> f:(t -> 'a) -> 'a","counters":[]},{"line":"    end","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module type Key_intf = sig","counters":[]},{"line":"    type 'a t","counters":[]},{"line":"","counters":[]},{"line":"    val to_string : 'a t -> string","counters":[]},{"line":"","counters":[]},{"line":"    val binable_key_type : 'a t -> 'a t Bin_prot.Type_class.t","counters":[]},{"line":"","counters":[]},{"line":"    val binable_data_type : 'a t -> 'a Bin_prot.Type_class.t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Make (Key : Key_intf) : S with type 'a g := 'a Key.t = struct","counters":[]},{"line":"    let bin_key_dump (key : 'a Key.t) =","counters":[]},{"line":"      Bin_prot.Utils.bin_dump (Key.binable_key_type key).writer key","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"","counters":[]},{"line":"    let bin_data_dump (key : 'a Key.t) (data : 'a) =","counters":[]},{"line":"      Bin_prot.Utils.bin_dump (Key.binable_data_type key).writer data","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"","counters":[]},{"line":"    module Make_Serializer (Database : sig","counters":[]},{"line":"      type t","counters":[]},{"line":"","counters":[]},{"line":"      val set : t -> key:Bigstring.t -> data:Bigstring.t -> unit","counters":[]},{"line":"","counters":[]},{"line":"      val remove : t -> key:Bigstring.t -> unit","counters":[]},{"line":"    end) =","counters":[]},{"line":"    struct","counters":[]},{"line":"      type t = Database.t","counters":[]},{"line":"","counters":[]},{"line":"      let set_raw t ~(key : 'a Key.t) ~(data : Bigstring.t) : unit =","counters":[]},{"line":"        Database.set t ~key:(bin_key_dump key) ~data","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"      let set t ~(key : 'a Key.t) ~(data : 'a) : unit =","counters":[]},{"line":"        set_raw t ~key ~data:(bin_data_dump key data)","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"","counters":[]},{"line":"      let remove t ~(key : 'a Key.t) = Database.remove t ~key:(bin_key_dump key)","counters":[{"col_start":39,"col_end":39,"count":0},{"col_start":74,"col_end":74,"count":0}]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    let create directory = Database.create directory","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"","counters":[]},{"line":"    let close = Database.close","counters":[]},{"line":"","counters":[]},{"line":"    module T = Make_Serializer (Database)","counters":[]},{"line":"    include T","counters":[]},{"line":"","counters":[]},{"line":"    let get_raw t ~(key : 'a Key.t) = Database.get t ~key:(bin_key_dump key)","counters":[{"col_start":38,"col_end":38,"count":0},{"col_start":70,"col_end":70,"count":0}]},{"line":"","counters":[]},{"line":"    let get t ~(key : 'a Key.t) =","counters":[]},{"line":"      let open Option.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%map serialized_value = Database.get t ~key:(bin_key_dump key) in","counters":[{"col_start":44,"col_end":44,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"      let bin_key = Key.binable_data_type key in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      bin_key.reader.read serialized_value ~pos_ref:(ref 0)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    module Batch = struct","counters":[]},{"line":"      include Make_Serializer (Database.Batch)","counters":[]},{"line":"","counters":[]},{"line":"      let with_batch = Database.Batch.with_batch","counters":[]},{"line":"    end","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}