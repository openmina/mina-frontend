{"filename":"src/lib/work_selector/work_lib.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Currency","counters":[]},{"line":"open Async","counters":[]},{"line":"","counters":[]},{"line":"module Make (Inputs : Intf.Inputs_intf) = struct","counters":[]},{"line":"  module Work_spec = Snark_work_lib.Work.Single.Spec","counters":[]},{"line":"","counters":[]},{"line":"  module Job_status = struct","counters":[]},{"line":"    type t = Assigned of Time.t","counters":[]},{"line":"","counters":[]},{"line":"    let is_old (Assigned at_time) ~now ~reassignment_wait =","counters":[]},{"line":"      let max_age = Time.Span.of_ms (Float.of_int reassignment_wait) in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"      let delta = Time.diff now at_time in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Time.Span.( > ) delta max_age","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module State = struct","counters":[]},{"line":"    module Seen_key = struct","counters":[]},{"line":"      module T = struct","counters":[]},{"line":"        type t = Transaction_snark.Statement.t One_or_two.t","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"        [@@deriving compare, sexp, to_yojson, hash]","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      include T","counters":[]},{"line":"      include Comparable.Make (T)","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    type t =","counters":[]},{"line":"      { mutable available_jobs :","counters":[]},{"line":"          (Inputs.Transaction_witness.t, Inputs.Ledger_proof.t) Work_spec.t","counters":[]},{"line":"          One_or_two.t","counters":[]},{"line":"          list","counters":[]},{"line":"      ; jobs_seen : (Seen_key.t, Job_status.t) Hashtbl.t","counters":[]},{"line":"      ; reassignment_wait : int","counters":[]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    let init :","counters":[]},{"line":"           reassignment_wait:int","counters":[]},{"line":"        -> frontier_broadcast_pipe:","counters":[]},{"line":"             Inputs.Transition_frontier.t option","counters":[]},{"line":"             Pipe_lib.Broadcast_pipe.Reader.t","counters":[]},{"line":"        -> logger:Logger.t","counters":[]},{"line":"        -> t =","counters":[]},{"line":"     fun ~reassignment_wait ~frontier_broadcast_pipe ~logger ->","counters":[]},{"line":"      let t =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { available_jobs = []","counters":[]},{"line":"        ; jobs_seen = Hashtbl.create (module Seen_key)","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"        ; reassignment_wait","counters":[]},{"line":"        }","counters":[]},{"line":"      in","counters":[]},{"line":"      Pipe_lib.Broadcast_pipe.Reader.iter frontier_broadcast_pipe","counters":[]},{"line":"        ~f:(fun frontier_opt ->","counters":[]},{"line":"          ( match frontier_opt with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              [%log debug] \"No frontier, setting available work to be empty\" ;","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"              t.available_jobs <- []","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"          | Some frontier ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Pipe_lib.Broadcast_pipe.Reader.iter","counters":[]},{"line":"                (Inputs.Transition_frontier.best_tip_pipe frontier) ~f:(fun _ ->","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"                  let best_tip_staged_ledger =","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    Inputs.Transition_frontier.best_tip_staged_ledger frontier","counters":[]},{"line":"                  in","counters":[]},{"line":"                  let start_time = Time.now () in","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  ( match","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                      Inputs.Staged_ledger.all_work_pairs best_tip_staged_ledger","counters":[]},{"line":"                        ~get_state:","counters":[]},{"line":"                          (Inputs.Transition_frontier.get_protocol_state","counters":[{"col_start":71,"col_end":71,"count":0}]},{"line":"                             frontier )","counters":[]},{"line":"                    with","counters":[]},{"line":"                  | Error e ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      [%log fatal]","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"                        \"Error occured when updating available work: $error\"","counters":[]},{"line":"                        ~metadata:[ (\"error\", Error_json.error_to_yojson e) ]","counters":[{"col_start":71,"col_end":71,"count":0}]},{"line":"                  | Ok new_available_jobs ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      let end_time = Time.now () in","counters":[]},{"line":"                      [%log info] \"Updating new available work took $time ms\"","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"                        ~metadata:","counters":[]},{"line":"                          [ ( \"time\"","counters":[]},{"line":"                            , `Float","counters":[]},{"line":"                                ( Time.diff end_time start_time","counters":[]},{"line":"                                |> Time.Span.to_ms ) )","counters":[{"col_start":35,"col_end":35,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"                          ] ;","counters":[]},{"line":"                      t.available_jobs <- new_available_jobs ) ;","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                  Deferred.unit )","counters":[]},{"line":"              |> Deferred.don't_wait_for ) ;","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"          Deferred.unit )","counters":[]},{"line":"      |> Deferred.don't_wait_for ;","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"      t","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let all_unseen_works t =","counters":[]},{"line":"      List.filter t.available_jobs ~f:(fun js ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          not","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          @@ Hashtbl.mem t.jobs_seen (One_or_two.map ~f:Work_spec.statement js) )","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"","counters":[]},{"line":"    let remove_old_assignments t ~logger =","counters":[]},{"line":"      let now = Time.now () in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Hashtbl.filteri_inplace t.jobs_seen ~f:(fun ~key:work ~data:status ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          if","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Job_status.is_old status ~now ~reassignment_wait:t.reassignment_wait","counters":[]},{"line":"          then (","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"            [%log info]","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"              ~metadata:[ (\"work\", Seen_key.to_yojson work) ]","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"              \"Waited too long to get work for $work. Ready to be reassigned\" ;","counters":[]},{"line":"            Mina_metrics.(Counter.inc_one Snark_work.snark_work_timed_out_rpc) ;","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"            false )","counters":[]},{"line":"          else true )","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"","counters":[]},{"line":"    let remove t x =","counters":[]},{"line":"      Hashtbl.remove t.jobs_seen (One_or_two.map ~f:Work_spec.statement x)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"","counters":[]},{"line":"    let set t x =","counters":[]},{"line":"      Hashtbl.set t.jobs_seen","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ~key:(One_or_two.map ~f:Work_spec.statement x)","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"        ~data:(Job_status.Assigned (Time.now ()))","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let does_not_have_better_fee ~snark_pool ~fee","counters":[]},{"line":"      (statements : Inputs.Transaction_snark_work.Statement.t) : bool =","counters":[]},{"line":"    Option.value_map ~default:true","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (Inputs.Snark_pool.get_completed_work snark_pool statements)","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"      ~f:(fun priced_proof ->","counters":[]},{"line":"        let competing_fee = Inputs.Transaction_snark_work.fee priced_proof in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Fee.compare fee competing_fee < 0 )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"","counters":[]},{"line":"  module For_tests = struct","counters":[]},{"line":"    let does_not_have_better_fee = does_not_have_better_fee","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let get_expensive_work ~snark_pool ~fee","counters":[]},{"line":"      (jobs : ('a, 'b) Work_spec.t One_or_two.t list) :","counters":[]},{"line":"      ('a, 'b) Work_spec.t One_or_two.t list =","counters":[]},{"line":"    List.filter jobs ~f:(fun job ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        does_not_have_better_fee ~snark_pool ~fee","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (One_or_two.map job ~f:Work_spec.statement) )","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"","counters":[]},{"line":"  let all_pending_work ~snark_pool statements =","counters":[]},{"line":"    List.filter statements ~f:(fun st ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        Option.is_none (Inputs.Snark_pool.get_completed_work snark_pool st) )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"","counters":[]},{"line":"  (*Seen/Unseen jobs that are not in the snark pool yet*)","counters":[]},{"line":"  let pending_work_statements ~snark_pool ~fee_opt (state : State.t) =","counters":[]},{"line":"    let all_todo_statements =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      List.map state.available_jobs ~f:(One_or_two.map ~f:Work_spec.statement)","counters":[]},{"line":"    in","counters":[]},{"line":"    let expensive_work statements ~fee =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      List.filter statements ~f:(does_not_have_better_fee ~snark_pool ~fee)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    in","counters":[]},{"line":"    match fee_opt with","counters":[]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        all_pending_work ~snark_pool all_todo_statements","counters":[]},{"line":"    | Some fee ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        expensive_work all_todo_statements ~fee","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":1}]}]}