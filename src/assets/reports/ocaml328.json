{"filename":"src/lib/child_processes/child_processes.ml","lines":[{"line":"(* child_processes.ml -- management of starting, tracking, and killing child processes. *)","counters":[]},{"line":"","counters":[{"col_start":0,"col_end":0,"count":1}]},{"line":"open Inline_test_quiet_logs","counters":[]},{"line":"open Core","counters":[]},{"line":"open Async","counters":[]},{"line":"open Pipe_lib","counters":[]},{"line":"module Termination = Termination","counters":[]},{"line":"","counters":[]},{"line":"exception Child_died","counters":[]},{"line":"","counters":[]},{"line":"type t =","counters":[]},{"line":"  { process : Process.t","counters":[]},{"line":"  ; stdout_pipe : string Strict_pipe.Reader.t","counters":[]},{"line":"  ; stderr_pipe : string Strict_pipe.Reader.t","counters":[]},{"line":"  ; stdin : Writer.t","counters":[]},{"line":"  ; terminated_ivar : Unix.Exit_or_signal.t Or_error.t Ivar.t","counters":[]},{"line":"  ; mutable killing : bool","counters":[]},{"line":"  ; mutable termination_response :","counters":[]},{"line":"      [ `Always_raise","counters":[]},{"line":"      | `Raise_on_failure","counters":[]},{"line":"      | `Handler of","counters":[]},{"line":"           killed:bool","counters":[]},{"line":"        -> Process.t","counters":[]},{"line":"        -> Unix.Exit_or_signal.t Or_error.t","counters":[]},{"line":"        -> unit Deferred.t","counters":[]},{"line":"      | `Ignore ]","counters":[]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"let stdout : t -> string Strict_pipe.Reader.t = fun t -> t.stdout_pipe","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"","counters":[]},{"line":"let stderr : t -> string Strict_pipe.Reader.t = fun t -> t.stderr_pipe","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"","counters":[]},{"line":"let stdin : t -> Writer.t = fun t -> t.stdin","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"let pid : t -> Pid.t = fun t -> Process.pid t.process","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"","counters":[]},{"line":"let termination_status : t -> Unix.Exit_or_signal.t Or_error.t option =","counters":[]},{"line":" fun t -> Ivar.peek t.terminated_ivar","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"(* Try running [f] until it returns [Ok], returning the first [Ok] or [Error]","counters":[]},{"line":"   if all attempts fail. *)","counters":[]},{"line":"let keep_trying :","counters":[]},{"line":"    f:('a -> 'b Deferred.Or_error.t) -> 'a list -> 'b Deferred.Or_error.t =","counters":[]},{"line":" fun ~f xs ->","counters":[]},{"line":"  let open Deferred.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let rec go e xs : 'b Deferred.Or_error.t =","counters":[]},{"line":"    match xs with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | [] ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        return e","counters":[]},{"line":"    | x :: xs -> (","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        match%bind f x with Ok r -> return (Ok r) | Error e -> go (Error e) xs )","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"  in","counters":[]},{"line":"  go (Or_error.error_string \"empty input\") xs","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"","counters":[]},{"line":"(* Unfortunately, `dune runtest` runs in a pwd deep inside the build directory.","counters":[]},{"line":"   This hack finds the project root by recursively looking for the dune-project","counters":[]},{"line":"   file. *)","counters":[]},{"line":"let get_project_root () =","counters":[]},{"line":"  let open Filename in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let rec go dir =","counters":[]},{"line":"    if Core.Sys.file_exists_exn @@ dir ^/ \"src/dune-project\" then Some dir","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"    else if String.equal dir \"/\" then None","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"    else go @@ fst @@ split dir","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"  in","counters":[]},{"line":"  go @@ realpath current_dir_name","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"","counters":[]},{"line":"(* This snippet was taken from our fork of RPC Parallel. Would be nice to have a","counters":[]},{"line":"   shared utility, but this is easiest for now. *)","counters":[]},{"line":"(* To get the currently running executable:","counters":[]},{"line":"   On Darwin:","counters":[]},{"line":"   Use _NSGetExecutablePath via Ctypes","counters":[]},{"line":"","counters":[]},{"line":"   On Linux:","counters":[]},{"line":"   Use /proc/PID/exe","counters":[]},{"line":"   - argv[0] might have been deleted (this is quite common with jenga)","counters":[]},{"line":"   - `cp /proc/PID/exe dst` works as expected while `cp /proc/self/exe dst` does","counters":[]},{"line":"     not *)","counters":[]},{"line":"let get_mina_binary () =","counters":[]},{"line":"  let open Async in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let open Deferred.Or_error.Let_syntax in","counters":[]},{"line":"  let%bind os = Process.run ~prog:\"uname\" ~args:[ \"-s\" ] () in","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"  if String.equal os \"Darwin\\n\" then","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    let open Ctypes in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let ns_get_executable_path =","counters":[]},{"line":"      Foreign.foreign \"_NSGetExecutablePath\"","counters":[]},{"line":"        (ptr char @-> ptr uint32_t @-> returning int)","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"    in","counters":[]},{"line":"    let path_max = Syslimits.path_max () in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let buf = Ctypes.allocate_n char ~count:path_max in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let count = Ctypes.allocate uint32_t (Unsigned.UInt32.of_int path_max) in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"    let%map () =","counters":[]},{"line":"      Deferred.return","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"        (Result.ok_if_true","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"           (ns_get_executable_path buf count = 0)","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"           ~error:","counters":[]},{"line":"             (Error.of_string \"call to _NSGetExecutablePath failed unexpectedly\") )","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"    in","counters":[]},{"line":"    let s = string_from_ptr buf ~length:(!@count |> Unsigned.UInt32.to_int) in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":42,"col_end":42,"count":0},{"col_start":73,"col_end":73,"count":0}]},{"line":"    List.hd_exn @@ String.split s ~on:(Char.of_int 0 |> Option.value_exn)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":49,"col_end":49,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"  else","counters":[]},{"line":"    (* FIXME for finding the executable relative to the install path this should","counters":[]},{"line":"       deference the symlink if possible. *)","counters":[]},{"line":"    Deferred.Or_error.return","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (Unix.getpid () |> Pid.to_int |> sprintf \"/proc/%d/exe\")","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"","counters":[]},{"line":"(* Check the PID file, and if it exists and corresponds to a currently running","counters":[]},{"line":"   process, kill that process. This runs when the daemon starts, and should","counters":[]},{"line":"   *not* be used to kill a process that was started during this run of the","counters":[]},{"line":"   daemon.","counters":[]},{"line":"*)","counters":[]},{"line":"let maybe_kill_and_unlock : string -> Filename.t -> Logger.t -> unit Deferred.t","counters":[]},{"line":"    =","counters":[]},{"line":" fun name lockpath logger ->","counters":[]},{"line":"  let open Deferred.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  match%bind Sys.file_exists lockpath with","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"  | `Yes -> (","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let%bind pid_str = Reader.file_contents lockpath in","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"      let pid = Pid.of_string pid_str in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      [%log debug] \"Found PID file for %s %s with contents %s\" name lockpath","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"        pid_str ;","counters":[]},{"line":"      let%bind () =","counters":[]},{"line":"        match Signal.send Signal.term (`Pid pid) with","counters":[]},{"line":"        | `No_such_process ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            [%log debug] \"Couldn't kill %s with PID %s, does not exist\" name","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"              pid_str ;","counters":[]},{"line":"            Deferred.unit","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"        | `Ok -> (","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            [%log debug] \"Successfully sent TERM signal to %s (%s)\" name pid_str ;","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"            let%bind () = after (Time.Span.of_sec 0.5) in","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"            match Signal.send Signal.kill (`Pid pid) with","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            | `No_such_process ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Deferred.unit","counters":[]},{"line":"            | `Ok ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                [%log error]","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                  \"helper process %s (%s) didn't die after being sent TERM, \\","counters":[]},{"line":"                   KILLed it\"","counters":[]},{"line":"                  name pid_str ;","counters":[]},{"line":"                Deferred.unit )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"      in","counters":[]},{"line":"      match%bind Sys.file_exists lockpath with","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"      | `Yes | `Unknown -> (","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"          match%bind try_with (fun () -> Sys.remove lockpath) with","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"          | Ok () ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Deferred.unit","counters":[]},{"line":"          | Error exn ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              [%log warn]","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                !\"Couldn't delete lock file for %s (pid $childPid) after \\","counters":[]},{"line":"                  killing it. If another Mina daemon was already running it \\","counters":[]},{"line":"                  may have cleaned it up for us. ($exn)\"","counters":[]},{"line":"                name","counters":[]},{"line":"                ~metadata:","counters":[]},{"line":"                  [ (\"childPid\", `Int (Pid.to_int pid))","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"                  ; (\"exn\", `String (Exn.to_string exn))","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"                  ] ;","counters":[]},{"line":"              Deferred.unit )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"      | `No ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Deferred.unit )","counters":[]},{"line":"  | `Unknown | `No ->","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"      [%log debug] \"No PID file for %s\" name ;","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"      Deferred.unit","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"type output_type = [ `Chunks | `Lines ]","counters":[]},{"line":"","counters":[]},{"line":"(* Convert a Async.Reader.t into a Strict_pipe.Reader.t *)","counters":[]},{"line":"let reader_to_strict_pipe reader output_type =","counters":[]},{"line":"  let pipe =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    match output_type with","counters":[]},{"line":"    | `Chunks ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Reader.pipe reader","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"    | `Lines ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Reader.lines reader","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"  in","counters":[]},{"line":"  Strict_pipe.Reader.of_linear_pipe { pipe; has_reader = false }","counters":[]},{"line":"","counters":[]},{"line":"let start_custom :","counters":[]},{"line":"       logger:Logger.t","counters":[]},{"line":"    -> name:string","counters":[]},{"line":"    -> git_root_relative_path:string","counters":[]},{"line":"    -> conf_dir:string","counters":[]},{"line":"    -> args:string list","counters":[]},{"line":"    -> stdout:output_type","counters":[]},{"line":"    -> stderr:output_type","counters":[]},{"line":"    -> termination:","counters":[]},{"line":"         [ `Always_raise","counters":[]},{"line":"         | `Raise_on_failure","counters":[]},{"line":"         | `Handler of","counters":[]},{"line":"              killed:bool","counters":[]},{"line":"           -> Process.t","counters":[]},{"line":"           -> Unix.Exit_or_signal.t Or_error.t","counters":[]},{"line":"           -> unit Deferred.t","counters":[]},{"line":"         | `Ignore ]","counters":[]},{"line":"    -> t Deferred.Or_error.t =","counters":[]},{"line":" fun ~logger ~name ~git_root_relative_path ~conf_dir ~args ~stdout ~stderr","counters":[]},{"line":"     ~termination ->","counters":[]},{"line":"  let open Deferred.Or_error.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%bind () =","counters":[]},{"line":"    Sys.is_directory conf_dir","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"    |> Deferred.bind ~f:(function","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"         | `Yes ->","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"             Deferred.Or_error.return ()","counters":[]},{"line":"         | _ ->","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"             Deferred.Or_error.errorf \"Config directory %s does not exist\"","counters":[]},{"line":"               conf_dir )","counters":[]},{"line":"  in","counters":[]},{"line":"  let lock_path = conf_dir ^/ name ^ \".lock\" in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%bind () =","counters":[]},{"line":"    Deferred.map ~f:Or_error.return","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"    @@ maybe_kill_and_unlock name lock_path logger","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"  in","counters":[]},{"line":"  [%log debug] \"Starting custom child process $name with args $args\"","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":13,"col_end":13,"count":0}]},{"line":"    ~metadata:","counters":[]},{"line":"      [ (\"name\", `String name)","counters":[]},{"line":"      ; (\"args\", `List (List.map args ~f:(fun a -> `String a)))","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"      ] ;","counters":[]},{"line":"  let%bind mina_binary_path = get_mina_binary () in","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"  let relative_to_root =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    get_project_root ()","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"    |> Option.map ~f:(fun root -> root ^/ git_root_relative_path)","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%bind process =","counters":[]},{"line":"    keep_trying","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"      (* TODO: remove coda-, eventually *)","counters":[]},{"line":"      (List.filter_opt","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"         [ Unix.getenv @@ \"MINA_\" ^ String.uppercase name ^ \"_PATH\"","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"         ; relative_to_root","counters":[]},{"line":"         ; Some (Filename.dirname mina_binary_path ^/ name)","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"         ; Some (\"mina-\" ^ name)","counters":[]},{"line":"         ; Some (\"coda-\" ^ name)","counters":[]},{"line":"         ] )","counters":[]},{"line":"      ~f:(fun prog -> Process.create ~stdin:\"\" ~prog ~args ())","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"  in","counters":[]},{"line":"  [%log info] \"Custom child process $name started with pid $pid\"","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":12,"col_end":12,"count":0}]},{"line":"    ~metadata:","counters":[]},{"line":"      [ (\"name\", `String name)","counters":[]},{"line":"      ; (\"args\", `List (List.map args ~f:(fun a -> `String a)))","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"      ; (\"pid\", `Int (Process.pid process |> Pid.to_int))","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"      ] ;","counters":[]},{"line":"  Termination.wait_for_process_log_errors ~logger process ~module_:__MODULE__","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    ~location:__LOC__ ~here:[%here] ;","counters":[]},{"line":"  let%bind () =","counters":[]},{"line":"    Deferred.map ~f:Or_error.return","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"    @@ Async.Writer.save lock_path","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"         ~contents:(Pid.to_string @@ Process.pid process)","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"  in","counters":[]},{"line":"  let terminated_ivar = Ivar.create () in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let stdout_pipe = reader_to_strict_pipe (Process.stdout process) stdout in","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"  let stderr_pipe = reader_to_strict_pipe (Process.stderr process) stderr in","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"  let t =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    { process","counters":[]},{"line":"    ; stdout_pipe","counters":[]},{"line":"    ; stderr_pipe","counters":[]},{"line":"    ; stdin = Process.stdin process","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"    ; terminated_ivar","counters":[]},{"line":"    ; killing = false","counters":[]},{"line":"    ; termination_response = termination","counters":[]},{"line":"    }","counters":[]},{"line":"  in","counters":[]},{"line":"  don't_wait_for","counters":[]},{"line":"    (let open Deferred.Let_syntax in","counters":[]},{"line":"    let%bind termination_status =","counters":[]},{"line":"      Deferred.Or_error.try_with ~here:[%here] (fun () -> Process.wait process)","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"    in","counters":[]},{"line":"    [%log trace] \"child process %s died\" name ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"    don't_wait_for","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (let%bind () = after (Time.Span.of_sec 1.) in","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"       let%bind () = Writer.close @@ Process.stdin process in","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"       let%bind () = Reader.close @@ Process.stdout process in","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"       Reader.close @@ Process.stderr process ) ;","counters":[{"col_start":7,"col_end":7,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"    let%bind () = Sys.remove lock_path in","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"    Ivar.fill terminated_ivar termination_status ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let log_bad_termination () =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let exit_or_signal =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        match termination_status with","counters":[]},{"line":"        | Ok termination_status ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            `String (Unix.Exit_or_signal.to_string_hum termination_status)","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"        | Error err ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Error_json.error_to_yojson err","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"      in","counters":[]},{"line":"      [%log fatal] \"Process died unexpectedly: $exit_or_signal\"","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"        ~metadata:[ (\"exit_or_signal\", exit_or_signal) ] ;","counters":[]},{"line":"      raise Child_died","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    in","counters":[]},{"line":"    match (t.termination_response, termination_status) with","counters":[]},{"line":"    | `Ignore, _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Deferred.unit","counters":[]},{"line":"    | `Always_raise, _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        log_bad_termination ()","counters":[]},{"line":"    | `Raise_on_failure, (Error _ | Ok (Error _)) ->","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"        log_bad_termination ()","counters":[]},{"line":"    | `Raise_on_failure, Ok (Ok ()) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Deferred.unit","counters":[]},{"line":"    | `Handler f, _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        f ~killed:t.killing process termination_status) ;","counters":[]},{"line":"  Deferred.Or_error.return t","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let kill : t -> Unix.Exit_or_signal.t Deferred.Or_error.t =","counters":[]},{"line":" fun t ->","counters":[]},{"line":"  match Ivar.peek t.terminated_ivar with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | None | Some (Error _) ->","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":11,"col_end":11,"count":0}]},{"line":"      (* The [Error] termination status indicates that we were not able to","counters":[]},{"line":"         monitor this process, and it may still be running. In these cases, it","counters":[]},{"line":"         is reasonable to call [kill], and we should attempt to end the process","counters":[]},{"line":"         if it is running.","counters":[]},{"line":"      *)","counters":[]},{"line":"      if t.killing then Ivar.read t.terminated_ivar","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"      else (","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"        t.killing <- true ;","counters":[]},{"line":"        ( match t.termination_response with","counters":[]},{"line":"        | `Handler _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ()","counters":[]},{"line":"        | _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            t.termination_response <- `Ignore ) ;","counters":[]},{"line":"        match Signal.send Signal.term (`Pid (Process.pid t.process)) with","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"        | `Ok ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Ivar.read t.terminated_ivar","counters":[]},{"line":"        | `No_such_process ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Deferred.Or_error.error_string","counters":[]},{"line":"              \"No such process running. This should be impossible.\" )","counters":[]},{"line":"  | Some _ ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Deferred.Or_error.error_string \"already terminated\"","counters":[]},{"line":"","counters":[]},{"line":"let register_process (termination : Termination.t) (process : t) kind =","counters":[]},{"line":"  Termination.register_process termination process.process kind","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let%test_module _ =","counters":[]},{"line":"  ( module struct","counters":[]},{"line":"    let logger = Logger.create ()","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"    let async_with_temp_dir f =","counters":[]},{"line":"      Async.Thread_safe.block_on_async_exn (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          File_system.with_temp_dir","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (Filename.temp_dir_name ^/ \"child-processes\")","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"            ~f )","counters":[]},{"line":"","counters":[]},{"line":"    let name = \"tester.sh\"","counters":[]},{"line":"","counters":[]},{"line":"    let git_root_relative_path = \"src/lib/child_processes/tester.sh\"","counters":[]},{"line":"","counters":[]},{"line":"    let process_wait_timeout = Time.Span.of_sec 2.1","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"can launch and get stdout\" =","counters":[]},{"line":"      async_with_temp_dir (fun conf_dir ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          let open Deferred.Let_syntax in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let%bind process =","counters":[]},{"line":"            start_custom ~logger ~name ~git_root_relative_path ~conf_dir","counters":[]},{"line":"              ~args:[ \"exit\" ] ~stdout:`Chunks ~stderr:`Chunks","counters":[]},{"line":"              ~termination:`Raise_on_failure","counters":[]},{"line":"            |> Deferred.map ~f:Or_error.ok_exn","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%bind () =","counters":[]},{"line":"            Strict_pipe.Reader.iter (stdout process) ~f:(fun line ->","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"                [%test_eq: string] \"hello\\n\" line ;","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"                Deferred.unit )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"          in","counters":[]},{"line":"          (* Pipe will be closed before the ivar is filled, so we need to wait a","counters":[]},{"line":"             bit. *)","counters":[]},{"line":"          let%bind () = after process_wait_timeout in","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"          [%test_eq: Unix.Exit_or_signal.t Or_error.t option] (Some (Ok (Ok ())))","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":43,"col_end":43,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"            (termination_status process) ;","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"          Deferred.unit )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"killing works\" =","counters":[]},{"line":"      async_with_temp_dir (fun conf_dir ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          let open Deferred.Let_syntax in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let%bind process =","counters":[]},{"line":"            start_custom ~logger ~name ~git_root_relative_path ~conf_dir","counters":[]},{"line":"              ~args:[ \"loop\" ] ~stdout:`Lines ~stderr:`Lines","counters":[]},{"line":"              ~termination:`Always_raise","counters":[]},{"line":"            |> Deferred.map ~f:Or_error.ok_exn","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"          in","counters":[]},{"line":"          let lock_exists () =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Deferred.map","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (Sys.file_exists (conf_dir ^/ name ^ \".lock\"))","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"              ~f:(function `Yes -> true | _ -> false)","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"          in","counters":[]},{"line":"          let assert_lock_exists () =","counters":[]},{"line":"            Deferred.map (lock_exists ()) ~f:(fun exists -> assert exists)","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"          in","counters":[]},{"line":"          let assert_lock_does_not_exist () =","counters":[]},{"line":"            Deferred.map (lock_exists ()) ~f:(fun exists -> assert (not exists))","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%bind () = assert_lock_exists () in","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"          let output = ref [] in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let rec go () =","counters":[]},{"line":"            match%bind Strict_pipe.Reader.read (stdout process) with","counters":[{"col_start":45,"col_end":45,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"            | `Eof ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                failwith \"pipe closed when process should've run forever\"","counters":[]},{"line":"            | `Ok line ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                output := line :: !output ;","counters":[]},{"line":"                if List.length !output = 10 then Deferred.unit else go ()","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":49,"col_end":49,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%bind () = go () in","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"          [%test_eq: string list] !output (List.init 10 ~f:(fun _ -> \"hello\")) ;","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":51,"col_end":51,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"          let%bind () = after process_wait_timeout in","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"          assert (Option.is_none @@ termination_status process) ;","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"          let%bind kill_res = kill process in","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"          let%bind () = assert_lock_does_not_exist () in","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"          let exit_or_signal = Or_error.ok_exn kill_res in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          [%test_eq: Unix.Exit_or_signal.t] exit_or_signal","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"            (Error (`Signal Signal.term)) ;","counters":[]},{"line":"          assert (Option.is_some @@ termination_status process) ;","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"          Deferred.unit )","counters":[]},{"line":"","counters":[]},{"line":"    let%test_unit \"if you spawn two processes it kills the earlier one\" =","counters":[]},{"line":"      async_with_temp_dir (fun conf_dir ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          let open Deferred.Let_syntax in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let mk_process () =","counters":[]},{"line":"            start_custom ~logger ~name ~git_root_relative_path ~conf_dir","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              ~args:[ \"loop\" ] ~stdout:`Chunks ~stderr:`Chunks","counters":[]},{"line":"              ~termination:`Ignore","counters":[]},{"line":"          in","counters":[]},{"line":"          let%bind process1 =","counters":[]},{"line":"            mk_process () |> Deferred.map ~f:Or_error.ok_exn","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%bind process2 =","counters":[]},{"line":"            mk_process () |> Deferred.map ~f:Or_error.ok_exn","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%bind () = after process_wait_timeout in","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"          [%test_eq: Unix.Exit_or_signal.t Or_error.t option]","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":43,"col_end":43,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"            (termination_status process1)","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"            (Some (Ok (Error (`Signal Core.Signal.term)))) ;","counters":[]},{"line":"          [%test_eq: Unix.Exit_or_signal.t Or_error.t option]","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":43,"col_end":43,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"            (termination_status process2)","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"            None ;","counters":[]},{"line":"          let%bind _ = kill process2 in","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"          Deferred.unit )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"if the lockfile already exists, then it would be cleaned\" =","counters":[]},{"line":"      async_with_temp_dir (fun conf_dir ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          let open Deferred.Let_syntax in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let lock_path = conf_dir ^/ name ^ \".lock\" in","counters":[]},{"line":"          let%bind () = Async.Writer.save lock_path ~contents:\"123\" in","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"          let%bind process =","counters":[]},{"line":"            start_custom ~logger ~name ~git_root_relative_path ~conf_dir","counters":[]},{"line":"              ~args:[ \"exit\" ] ~stdout:`Chunks ~stderr:`Chunks","counters":[]},{"line":"              ~termination:`Raise_on_failure","counters":[]},{"line":"            |> Deferred.map ~f:Or_error.ok_exn","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%bind () =","counters":[]},{"line":"            Strict_pipe.Reader.iter (stdout process) ~f:(fun line ->","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"                [%test_eq: string] \"hello\\n\" line ;","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"                Deferred.unit )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%bind () = after process_wait_timeout in","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"          [%test_eq: Unix.Exit_or_signal.t Or_error.t option] (Some (Ok (Ok ())))","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":43,"col_end":43,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"            (termination_status process) ;","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"          Deferred.unit )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"  end )","counters":[{"col_start":6,"col_end":6,"count":1}]}]}