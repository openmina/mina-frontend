{"filename":"src/lib/transaction_snark_scan_state/transaction_snark_scan_state.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Async","counters":[]},{"line":"open Mina_base","counters":[]},{"line":"open Mina_transaction","counters":[]},{"line":"open Currency","counters":[]},{"line":"module Ledger = Mina_ledger.Ledger","counters":[]},{"line":"module Sparse_ledger = Mina_ledger.Sparse_ledger","counters":[]},{"line":"","counters":[]},{"line":"let map2_or_error xs ys ~f =","counters":[]},{"line":"  let rec go xs ys acc =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    match (xs, ys) with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | [], [] ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Ok (List.rev acc)","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"    | x :: xs, y :: ys -> (","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        match f x y with Error e -> Error e | Ok z -> go xs ys (z :: acc) )","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"    | _, _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Or_error.error_string \"Length mismatch\"","counters":[]},{"line":"  in","counters":[]},{"line":"  go xs ys []","counters":[]},{"line":"","counters":[]},{"line":"module type Monad_with_Or_error_intf = sig","counters":[]},{"line":"  type 'a t","counters":[]},{"line":"","counters":[]},{"line":"  include Monad.S with type 'a t := 'a t","counters":[]},{"line":"","counters":[]},{"line":"  module Or_error : sig","counters":[]},{"line":"    type nonrec 'a t = 'a Or_error.t t","counters":[]},{"line":"","counters":[]},{"line":"    include Monad.S with type 'a t := 'a t","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Transaction_with_witness = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V2 = struct","counters":[]},{"line":"      (* TODO: The statement is redundant here - it can be computed from the","counters":[]},{"line":"         witness and the transaction","counters":[]},{"line":"      *)","counters":[]},{"line":"      type t =","counters":[{"col_start":6,"col_end":6,"count":2},{"col_start":11,"col_end":11,"count":2}]},{"line":"        { transaction_with_info :","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"            Mina_transaction_logic.Transaction_applied.Stable.V2.t","counters":[]},{"line":"        ; state_hash : State_hash.Stable.V1.t * State_body_hash.Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":74,"col_end":74,"count":0}]},{"line":"        ; statement : Transaction_snark.Statement.Stable.V2.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"        ; init_stack :","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"            Transaction_snark.Pending_coinbase_stack_state.Init_stack.Stable.V1","counters":[]},{"line":"            .t","counters":[]},{"line":"        ; ledger_witness : Mina_ledger.Sparse_ledger.Stable.V2.t [@sexp.opaque]","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"        }","counters":[]},{"line":"      [@@deriving sexp]","counters":[{"col_start":22,"col_end":22,"count":5}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Ledger_proof_with_sok_message = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V2 = struct","counters":[]},{"line":"      type t = Ledger_proof.Stable.V2.t * Sok_message.Stable.V1.t","counters":[{"col_start":6,"col_end":6,"count":2},{"col_start":11,"col_end":11,"count":1},{"col_start":15,"col_end":15,"count":0}]},{"line":"      [@@deriving sexp]","counters":[{"col_start":22,"col_end":22,"count":5}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Available_job = struct","counters":[]},{"line":"  type t =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    ( Ledger_proof_with_sok_message.t","counters":[]},{"line":"    , Transaction_with_witness.t )","counters":[]},{"line":"    Parallel_scan.Available_job.t","counters":[]},{"line":"  [@@deriving sexp]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Space_partition = Parallel_scan.Space_partition","counters":[]},{"line":"","counters":[]},{"line":"module Job_view = struct","counters":[]},{"line":"  type t = Transaction_snark.Statement.t Parallel_scan.Job_view.t","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  [@@deriving sexp]","counters":[]},{"line":"","counters":[]},{"line":"  let to_yojson ({ value; position } : t) : Yojson.Safe.t =","counters":[]},{"line":"    let module R = struct","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      type t =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ( Frozen_ledger_hash.t","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":10,"col_end":10,"count":0}]},{"line":"        , Pending_coinbase.Stack_versioned.t","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        , Mina_state.Local_state.t )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        Mina_state.Registers.t","counters":[]},{"line":"      [@@deriving to_yojson]","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"    end in","counters":[]},{"line":"    let statement_to_yojson (s : Transaction_snark.Statement.t) =","counters":[]},{"line":"      `Assoc","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [ (\"Work_id\", `Int (Transaction_snark.Statement.hash s))","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"        ; (\"Source\", R.to_yojson s.source)","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"        ; (\"Target\", R.to_yojson s.target)","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"        ; ( \"Fee Excess\"","counters":[]},{"line":"          , `List","counters":[]},{"line":"              [ `Assoc","counters":[]},{"line":"                  [ (\"token\", Token_id.to_yojson s.fee_excess.fee_token_l)","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"                  ; (\"amount\", Fee.Signed.to_yojson s.fee_excess.fee_excess_l)","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                  ]","counters":[]},{"line":"              ; `Assoc","counters":[]},{"line":"                  [ (\"token\", Token_id.to_yojson s.fee_excess.fee_token_r)","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"                  ; (\"amount\", Fee.Signed.to_yojson s.fee_excess.fee_excess_r)","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                  ]","counters":[]},{"line":"              ] )","counters":[]},{"line":"        ; (\"Supply Increase\", Currency.Amount.Signed.to_yojson s.supply_increase)","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"        ]","counters":[]},{"line":"    in","counters":[]},{"line":"    let job_to_yojson =","counters":[]},{"line":"      match value with","counters":[]},{"line":"      | BEmpty ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          `Assoc [ (\"B\", `List []) ]","counters":[]},{"line":"      | MEmpty ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          `Assoc [ (\"M\", `List []) ]","counters":[]},{"line":"      | MPart x ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          `Assoc [ (\"M\", `List [ statement_to_yojson x ]) ]","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"      | MFull (x, y, { seq_no; status }) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          `Assoc","counters":[]},{"line":"            [ ( \"M\"","counters":[]},{"line":"              , `List","counters":[]},{"line":"                  [ statement_to_yojson x","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"                  ; statement_to_yojson y","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"                  ; `Int seq_no","counters":[]},{"line":"                  ; `Assoc","counters":[]},{"line":"                      [ ( \"Status\"","counters":[]},{"line":"                        , `String (Parallel_scan.Job_status.to_string status) )","counters":[{"col_start":68,"col_end":68,"count":0}]},{"line":"                      ]","counters":[]},{"line":"                  ] )","counters":[]},{"line":"            ]","counters":[]},{"line":"      | BFull (x, { seq_no; status }) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          `Assoc","counters":[]},{"line":"            [ ( \"B\"","counters":[]},{"line":"              , `List","counters":[]},{"line":"                  [ statement_to_yojson x","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"                  ; `Int seq_no","counters":[]},{"line":"                  ; `Assoc","counters":[]},{"line":"                      [ ( \"Status\"","counters":[]},{"line":"                        , `String (Parallel_scan.Job_status.to_string status) )","counters":[{"col_start":68,"col_end":68,"count":0}]},{"line":"                      ]","counters":[]},{"line":"                  ] )","counters":[]},{"line":"            ]","counters":[]},{"line":"    in","counters":[]},{"line":"    `List [ `Int position; job_to_yojson ]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"type job = Available_job.t [@@deriving sexp]","counters":[{"col_start":0,"col_end":0,"count":0}]},{"line":"","counters":[]},{"line":"[%%versioned","counters":[]},{"line":"module Stable = struct","counters":[]},{"line":"  module V2 = struct","counters":[]},{"line":"    type t =","counters":[{"col_start":4,"col_end":4,"count":2},{"col_start":9,"col_end":9,"count":1}]},{"line":"      ( Ledger_proof_with_sok_message.Stable.V2.t","counters":[]},{"line":"      , Transaction_with_witness.Stable.V2.t )","counters":[]},{"line":"      Parallel_scan.State.Stable.V1.t","counters":[]},{"line":"    [@@deriving sexp]","counters":[{"col_start":20,"col_end":20,"count":5}]},{"line":"","counters":[]},{"line":"    let to_latest = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"    let hash (t : t) =","counters":[]},{"line":"      let state_hash =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Parallel_scan.State.hash t","counters":[]},{"line":"          (Binable.to_string (module Ledger_proof_with_sok_message.Stable.V2))","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"          (Binable.to_string (module Transaction_with_witness.Stable.V2))","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"      in","counters":[]},{"line":"      Staged_ledger_hash.Aux_hash.of_sha256 state_hash","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  end","counters":[]},{"line":"end]","counters":[]},{"line":"","counters":[]},{"line":"[%%define_locally Stable.Latest.(hash)]","counters":[]},{"line":"","counters":[]},{"line":"(**********Helpers*************)","counters":[]},{"line":"","counters":[]},{"line":"let create_expected_statement ~constraint_constants","counters":[]},{"line":"    ~(get_state : State_hash.t -> Mina_state.Protocol_state.value Or_error.t)","counters":[]},{"line":"    { Transaction_with_witness.transaction_with_info","counters":[]},{"line":"    ; state_hash","counters":[]},{"line":"    ; ledger_witness","counters":[]},{"line":"    ; init_stack","counters":[]},{"line":"    ; statement","counters":[]},{"line":"    } =","counters":[]},{"line":"  let open Or_error.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let source_merkle_root =","counters":[]},{"line":"    Frozen_ledger_hash.of_ledger_hash","counters":[]},{"line":"    @@ Sparse_ledger.merkle_root ledger_witness","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"  in","counters":[]},{"line":"  let { With_status.data = transaction; status = _ } =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Ledger.Transaction_applied.transaction transaction_with_info","counters":[]},{"line":"  in","counters":[]},{"line":"  let%bind protocol_state = get_state (fst state_hash) in","counters":[{"col_start":36,"col_end":36,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"  let state_view = Mina_state.Protocol_state.Body.view protocol_state.body in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let empty_local_state = Mina_state.Local_state.empty () in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%bind after, applied_transaction =","counters":[]},{"line":"    Or_error.try_with (fun () ->","counters":[]},{"line":"        Sparse_ledger.apply_transaction ~constraint_constants","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ~txn_state_view:state_view ledger_witness transaction )","counters":[]},{"line":"    |> Or_error.join","counters":[{"col_start":7,"col_end":7,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"  in","counters":[]},{"line":"  let target_merkle_root =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Sparse_ledger.merkle_root after |> Frozen_ledger_hash.of_ledger_hash","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%bind pending_coinbase_before =","counters":[]},{"line":"    match init_stack with","counters":[]},{"line":"    | Base source ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Ok source","counters":[]},{"line":"    | Merge ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Or_error.errorf","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"          !\"Invalid init stack in Pending coinbase stack state . Expected Base \\","counters":[]},{"line":"            found Merge\"","counters":[]},{"line":"  in","counters":[]},{"line":"  let pending_coinbase_after =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    let state_body_hash = snd state_hash in","counters":[]},{"line":"    let pending_coinbase_with_state =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Pending_coinbase.Stack.push_state state_body_hash pending_coinbase_before","counters":[]},{"line":"    in","counters":[]},{"line":"    match transaction with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Coinbase c ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Pending_coinbase.Stack.push_coinbase c pending_coinbase_with_state","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"    | _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        pending_coinbase_with_state","counters":[]},{"line":"  in","counters":[]},{"line":"  let%bind fee_excess = Transaction.fee_excess transaction in","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"  let%map supply_increase =","counters":[]},{"line":"    Ledger.Transaction_applied.supply_increase applied_transaction","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"  in","counters":[]},{"line":"  { Transaction_snark.Statement.source =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      { ledger = source_merkle_root","counters":[]},{"line":"      ; pending_coinbase_stack = statement.source.pending_coinbase_stack","counters":[]},{"line":"      ; local_state = empty_local_state","counters":[]},{"line":"      }","counters":[]},{"line":"  ; target =","counters":[]},{"line":"      { ledger = target_merkle_root","counters":[]},{"line":"      ; pending_coinbase_stack = pending_coinbase_after","counters":[]},{"line":"      ; local_state = empty_local_state","counters":[]},{"line":"      }","counters":[]},{"line":"  ; fee_excess","counters":[]},{"line":"  ; supply_increase","counters":[]},{"line":"  ; sok_digest = ()","counters":[]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"let completed_work_to_scanable_work (job : job) (fee, current_proof, prover) :","counters":[]},{"line":"    Ledger_proof_with_sok_message.t Or_error.t =","counters":[]},{"line":"  let sok_digest = Ledger_proof.sok_digest current_proof","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"  and proof = Ledger_proof.underlying_proof current_proof in","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"  match job with","counters":[]},{"line":"  | Base { statement; _ } ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let ledger_proof = Ledger_proof.create ~statement ~sok_digest ~proof in","counters":[]},{"line":"      Ok (ledger_proof, Sok_message.create ~fee ~prover)","counters":[]},{"line":"  | Merge ((p, _), (p', _)) ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let open Or_error.Let_syntax in","counters":[]},{"line":"      (*","counters":[]},{"line":"      let%map statement =","counters":[]},{"line":"        Transaction_snark.Statement.merge (Ledger_proof.statement p)","counters":[]},{"line":"          (Ledger_proof.statement p')","counters":[]},{"line":"      in *)","counters":[]},{"line":"      let s = Ledger_proof.statement p and s' = Ledger_proof.statement p' in","counters":[{"col_start":35,"col_end":35,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"      let option lab =","counters":[]},{"line":"        Option.value_map ~default:(Or_error.error_string lab) ~f:(fun x -> Ok x)","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":55,"col_end":55,"count":0},{"col_start":75,"col_end":75,"count":0}]},{"line":"      in","counters":[]},{"line":"      let%map fee_excess = Fee_excess.combine s.fee_excess s'.fee_excess","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"      and supply_increase =","counters":[]},{"line":"        Amount.Signed.add s.supply_increase s'.supply_increase","counters":[]},{"line":"        |> option \"Error adding supply_increases\"","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":16,"col_end":16,"count":0}]},{"line":"      and _valid_pending_coinbase_stack =","counters":[]},{"line":"        if","counters":[]},{"line":"          Pending_coinbase.Stack.equal s.target.pending_coinbase_stack","counters":[]},{"line":"            s'.source.pending_coinbase_stack","counters":[]},{"line":"        then Ok ()","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"        else Or_error.error_string \"Invalid pending coinbase stack state\"","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"      in","counters":[]},{"line":"      let statement : Transaction_snark.Statement.t =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { source = s.source","counters":[]},{"line":"        ; target = s'.target","counters":[]},{"line":"        ; supply_increase","counters":[]},{"line":"        ; fee_excess","counters":[]},{"line":"        ; sok_digest = ()","counters":[]},{"line":"        }","counters":[]},{"line":"      in","counters":[]},{"line":"      ( Ledger_proof.create ~statement ~sok_digest ~proof","counters":[]},{"line":"      , Sok_message.create ~fee ~prover )","counters":[]},{"line":"","counters":[]},{"line":"let total_proofs (works : Transaction_snark_work.t list) =","counters":[]},{"line":"  List.sum (module Int) works ~f:(fun w -> One_or_two.length w.proofs)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"","counters":[]},{"line":"(*************exposed functions*****************)","counters":[]},{"line":"","counters":[]},{"line":"module P = struct","counters":[]},{"line":"  type t = Ledger_proof_with_sok_message.t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make_statement_scanner (Verifier : sig","counters":[]},{"line":"  type t","counters":[]},{"line":"","counters":[]},{"line":"  val verify : verifier:t -> P.t list -> bool Deferred.Or_error.t","counters":[]},{"line":"end) =","counters":[]},{"line":"struct","counters":[]},{"line":"  module Fold = Parallel_scan.State.Make_foldable (Deferred)","counters":[]},{"line":"","counters":[]},{"line":"  let logger = lazy (Logger.create ())","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"","counters":[]},{"line":"  module Timer = struct","counters":[]},{"line":"    module Info = struct","counters":[]},{"line":"      module Time_span = struct","counters":[]},{"line":"        type t = Time.Span.t","counters":[]},{"line":"","counters":[]},{"line":"        let to_yojson t = `Float (Time.Span.to_ms t)","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      type t =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { total : Time_span.t","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"        ; count : int","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":20,"col_end":20,"count":0}]},{"line":"        ; min : Time_span.t","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"        ; max : Time_span.t","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"        }","counters":[]},{"line":"      [@@deriving to_yojson]","counters":[]},{"line":"","counters":[]},{"line":"      let singleton time = { total = time; count = 1; max = time; min = time }","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"","counters":[]},{"line":"      let update (t : t) time =","counters":[]},{"line":"        { total = Time.Span.( + ) t.total time","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"        ; count = t.count + 1","counters":[]},{"line":"        ; min = Time.Span.min t.min time","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"        ; max = Time.Span.max t.max time","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"        }","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    type t = Info.t String.Table.t","counters":[]},{"line":"","counters":[]},{"line":"    let create () : t = String.Table.create ()","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"","counters":[]},{"line":"    let time (t : t) label f =","counters":[]},{"line":"      let start = Time.now () in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let x = f () in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let elapsed = Time.(diff (now ()) start) in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"      Hashtbl.update t label ~f:(function","counters":[]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Info.singleton elapsed","counters":[]},{"line":"        | Some acc ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Info.update acc elapsed ) ;","counters":[]},{"line":"      x","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let log label (t : t) =","counters":[]},{"line":"      let logger = Lazy.force logger in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      [%log debug]","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"        ~metadata:","counters":[]},{"line":"          (List.map (Hashtbl.to_alist t) ~f:(fun (k, info) ->","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"               (k, Info.to_yojson info) ) )","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"        \"%s timing\" label","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  (*TODO: fold over the pending_coinbase tree and validate the statements?*)","counters":[]},{"line":"  let scan_statement ~constraint_constants tree ~statement_check ~verifier :","counters":[]},{"line":"      ( Transaction_snark.Statement.t","counters":[]},{"line":"      , [ `Error of Error.t | `Empty ] )","counters":[]},{"line":"      Deferred.Result.t =","counters":[]},{"line":"    let open Deferred.Or_error.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let timer = Timer.create () in","counters":[]},{"line":"    let yield_occasionally =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let f = Staged.unstage (Async.Scheduler.yield_every ~n:50) in","counters":[]},{"line":"      fun () -> f () |> Deferred.map ~f:Or_error.return","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"    in","counters":[]},{"line":"    let yield_always () =","counters":[]},{"line":"      Async.Scheduler.yield () |> Deferred.map ~f:Or_error.return","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"    in","counters":[]},{"line":"    let module Acc = struct","counters":[]},{"line":"      type t = (Transaction_snark.Statement.t * P.t list) option","counters":[]},{"line":"    end in","counters":[]},{"line":"    let write_error description =","counters":[]},{"line":"      sprintf !\"Staged_ledger.scan_statement: %s\\n\" description","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    in","counters":[]},{"line":"    let with_error ~f message =","counters":[]},{"line":"      let result = f () in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Deferred.Result.map_error result ~f:(fun e ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          Error.createf !\"%s: %{sexp:Error.t}\" (write_error message) e )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"    in","counters":[]},{"line":"    let merge_acc ~proofs (acc : Acc.t) s2 : Acc.t Deferred.Or_error.t =","counters":[]},{"line":"      Timer.time timer (sprintf \"merge_acc:%s\" __LOC__) (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"          with_error \"Bad merge proof\" ~f:(fun () ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              match acc with","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              | None ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  return (Some (s2, proofs))","counters":[]},{"line":"              | Some (s1, ps) ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  let%bind merged_statement =","counters":[]},{"line":"                    Deferred.return (Transaction_snark.Statement.merge s1 s2)","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"                  in","counters":[]},{"line":"                  let%map () = yield_occasionally () in","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"                  Some (merged_statement, proofs @ ps) ) )","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"    in","counters":[]},{"line":"    let merge_pc (acc : Transaction_snark.Statement.t option) s2 :","counters":[]},{"line":"        Transaction_snark.Statement.t option Or_error.t =","counters":[]},{"line":"      let open Or_error.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      match acc with","counters":[]},{"line":"      | None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Ok (Some s2)","counters":[]},{"line":"      | Some s1 ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let%map () =","counters":[]},{"line":"            if","counters":[]},{"line":"              Pending_coinbase.Stack.connected","counters":[]},{"line":"                ~prev:(Some s1.source.pending_coinbase_stack)","counters":[]},{"line":"                ~first:s1.target.pending_coinbase_stack","counters":[]},{"line":"                ~second:s2.source.pending_coinbase_stack ()","counters":[]},{"line":"            then return ()","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"            else","counters":[]},{"line":"              Or_error.errorf","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"                !\"Base merge proof: invalid pending coinbase transition s1: \\","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                  %{sexp: Transaction_snark.Statement.t} s2: %{sexp: \\","counters":[]},{"line":"                  Transaction_snark.Statement.t}\"","counters":[]},{"line":"                s1 s2","counters":[]},{"line":"          in","counters":[]},{"line":"          Some s2","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    in","counters":[]},{"line":"    let fold_step_a (acc_statement, acc_pc) job =","counters":[]},{"line":"      match job with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Parallel_scan.Merge.Job.Part (proof, message) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let statement = Ledger_proof.statement proof in","counters":[]},{"line":"          let%map acc_stmt =","counters":[]},{"line":"            merge_acc ~proofs:[ (proof, message) ] acc_statement statement","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"          in","counters":[]},{"line":"          (acc_stmt, acc_pc)","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"      | Empty | Full { status = Parallel_scan.Job_status.Done; _ } ->","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":16,"col_end":16,"count":0}]},{"line":"          return (acc_statement, acc_pc)","counters":[]},{"line":"      | Full { left = proof_1, message_1; right = proof_2, message_2; _ } ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let stmt1 = Ledger_proof.statement proof_1 in","counters":[]},{"line":"          let stmt2 = Ledger_proof.statement proof_2 in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let%bind merged_statement =","counters":[]},{"line":"            Timer.time timer (sprintf \"merge:%s\" __LOC__) (fun () ->","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"                Deferred.return (Transaction_snark.Statement.merge stmt1 stmt2) )","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%map acc_stmt =","counters":[]},{"line":"            merge_acc acc_statement merged_statement","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"              ~proofs:[ (proof_1, message_1); (proof_2, message_2) ]","counters":[]},{"line":"          in","counters":[]},{"line":"          (acc_stmt, acc_pc)","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    in","counters":[]},{"line":"    let fold_step_d (acc_statement, acc_pc) job =","counters":[]},{"line":"      match job with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Parallel_scan.Base.Job.Empty ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          return (acc_statement, acc_pc)","counters":[]},{"line":"      | Full","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          { status = Parallel_scan.Job_status.Done","counters":[]},{"line":"          ; job = (transaction : Transaction_with_witness.t)","counters":[]},{"line":"          ; _","counters":[]},{"line":"          } ->","counters":[]},{"line":"          let%map acc_pc =","counters":[]},{"line":"            Deferred.return (merge_pc acc_pc transaction.statement)","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"          in","counters":[]},{"line":"          (acc_statement, acc_pc)","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"      | Full { job = transaction; _ } ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          with_error \"Bad base statement\" ~f:(fun () ->","counters":[]},{"line":"              let%bind expected_statement =","counters":[]},{"line":"                match statement_check with","counters":[]},{"line":"                | `Full get_state ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    let%bind result =","counters":[]},{"line":"                      Timer.time timer","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                        (sprintf \"create_expected_statement:%s\" __LOC__)","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                        (fun () ->","counters":[]},{"line":"                          Deferred.return","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            (create_expected_statement ~constraint_constants","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"                               ~get_state transaction ) )","counters":[]},{"line":"                    in","counters":[]},{"line":"                    let%map () = yield_always () in","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"                    result","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                | `Partial ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    return transaction.statement","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"              in","counters":[]},{"line":"              let%bind () = yield_always () in","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"              if","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Transaction_snark.Statement.equal transaction.statement","counters":[]},{"line":"                  expected_statement","counters":[]},{"line":"              then","counters":[]},{"line":"                let%bind acc_stmt =","counters":[]},{"line":"                  merge_acc ~proofs:[] acc_statement transaction.statement","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                in","counters":[]},{"line":"                let%map acc_pc =","counters":[]},{"line":"                  merge_pc acc_pc transaction.statement |> Deferred.return","counters":[{"col_start":59,"col_end":59,"count":0},{"col_start":73,"col_end":73,"count":0}]},{"line":"                in","counters":[]},{"line":"                (acc_stmt, acc_pc)","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"              else","counters":[]},{"line":"                Deferred.Or_error.error_string","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  (sprintf","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                     !\"Bad base statement expected: \\","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                       %{sexp:Transaction_snark.Statement.t} got: \\","counters":[]},{"line":"                       %{sexp:Transaction_snark.Statement.t}\"","counters":[]},{"line":"                     transaction.statement expected_statement ) )","counters":[]},{"line":"    in","counters":[]},{"line":"    let%bind.Deferred res =","counters":[]},{"line":"      Fold.fold_chronological_until tree ~init:(None, None)","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"        ~f_merge:(fun acc (_weight, job) ->","counters":[]},{"line":"          let open Container.Continue_or_stop in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          match%map.Deferred fold_step_a acc job with","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"          | Ok next ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Continue next","counters":[]},{"line":"          | e ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Stop e )","counters":[]},{"line":"        ~f_base:(fun acc (_weight, job) ->","counters":[]},{"line":"          let open Container.Continue_or_stop in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          match%map.Deferred fold_step_d acc job with","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"          | Ok next ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Continue next","counters":[]},{"line":"          | e ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Stop e )","counters":[]},{"line":"        ~finish:return","counters":[]},{"line":"    in","counters":[]},{"line":"    Timer.log \"scan_statement\" timer ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    match res with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Ok (None, _) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Deferred.return (Error `Empty)","counters":[]},{"line":"    | Ok (Some (res, proofs), _) -> (","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        match%map.Deferred Verifier.verify ~verifier proofs with","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"        | Ok true ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Ok res","counters":[]},{"line":"        | Ok false ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Error (`Error (Error.of_string \"Bad proofs\"))","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"        | Error e ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Error (`Error e) )","counters":[]},{"line":"    | Error e ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Deferred.return (Error (`Error e))","counters":[]},{"line":"","counters":[]},{"line":"  let check_invariants t ~constraint_constants ~statement_check ~verifier","counters":[]},{"line":"      ~error_prefix","counters":[]},{"line":"      ~(registers_begin :","counters":[]},{"line":"         ( Frozen_ledger_hash.t","counters":[]},{"line":"         , Pending_coinbase.Stack.t","counters":[]},{"line":"         , Mina_state.Local_state.t )","counters":[]},{"line":"         Mina_state.Registers.t","counters":[]},{"line":"         option )","counters":[]},{"line":"      ~(registers_end :","counters":[]},{"line":"         ( Frozen_ledger_hash.t","counters":[]},{"line":"         , Pending_coinbase.Stack.t","counters":[]},{"line":"         , Mina_state.Local_state.t )","counters":[]},{"line":"         Mina_state.Registers.t ) =","counters":[]},{"line":"    let clarify_error cond err =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      if not cond then Or_error.errorf \"%s : %s\" error_prefix err else Ok ()","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"    in","counters":[]},{"line":"    let check_registers (reg1 : _ Mina_state.Registers.t)","counters":[]},{"line":"        (reg2 : _ Mina_state.Registers.t) =","counters":[]},{"line":"      let open Or_error.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%map () =","counters":[]},{"line":"        clarify_error","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"          (Frozen_ledger_hash.equal reg1.ledger reg2.ledger)","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"          \"did not connect with snarked ledger hash\"","counters":[]},{"line":"      and () =","counters":[]},{"line":"        clarify_error","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"          (Pending_coinbase.Stack.connected ~first:reg1.pending_coinbase_stack","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"             ~second:reg2.pending_coinbase_stack () )","counters":[]},{"line":"          \"did not connect with pending-coinbase stack\"","counters":[]},{"line":"      and () =","counters":[]},{"line":"        clarify_error","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"          (Mina_transaction_logic.Zkapp_command_logic.Local_state.Value.equal","counters":[{"col_start":76,"col_end":76,"count":0}]},{"line":"             reg1.local_state reg2.local_state )","counters":[]},{"line":"          \"did not connect with local state\"","counters":[]},{"line":"      in","counters":[]},{"line":"      ()","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    in","counters":[]},{"line":"    match%map","counters":[]},{"line":"      O1trace.sync_thread \"validate_transaction_snark_scan_state\" (fun () ->","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"          scan_statement t ~constraint_constants ~statement_check ~verifier )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    with","counters":[]},{"line":"    | Error (`Error e) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Error e","counters":[]},{"line":"    | Error `Empty ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Option.value_map ~default:(Ok ()) registers_begin","counters":[]},{"line":"          ~f:(fun registers_begin ->","counters":[]},{"line":"            check_registers registers_begin registers_end )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"    | Ok","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { fee_excess = { fee_token_l; fee_excess_l; fee_token_r; fee_excess_r }","counters":[]},{"line":"        ; source","counters":[]},{"line":"        ; target","counters":[]},{"line":"        ; supply_increase = _","counters":[]},{"line":"        ; sok_digest = ()","counters":[]},{"line":"        } ->","counters":[]},{"line":"        let open Or_error.Let_syntax in","counters":[]},{"line":"        let%map () =","counters":[]},{"line":"          Option.value_map ~default:(Ok ()) registers_begin","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"            ~f:(fun registers_begin -> check_registers registers_begin source)","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"        and () = check_registers registers_end target","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"        and () =","counters":[]},{"line":"          clarify_error","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"            (Fee.Signed.equal Fee.Signed.zero fee_excess_l)","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"            \"nonzero fee excess\"","counters":[]},{"line":"        and () =","counters":[]},{"line":"          clarify_error","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"            (Fee.Signed.equal Fee.Signed.zero fee_excess_r)","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"            \"nonzero fee excess\"","counters":[]},{"line":"        and () =","counters":[]},{"line":"          clarify_error","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"            (Token_id.equal Token_id.default fee_token_l)","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"            \"nondefault fee token\"","counters":[]},{"line":"        and () =","counters":[]},{"line":"          clarify_error","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"            (Token_id.equal Token_id.default fee_token_r)","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"            \"nondefault fee token\"","counters":[]},{"line":"        in","counters":[]},{"line":"        ()","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let statement_of_job : job -> Transaction_snark.Statement.t option = function","counters":[]},{"line":"  | Base { statement; _ } ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Some statement","counters":[]},{"line":"  | Merge ((p1, _), (p2, _)) ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Transaction_snark.Statement.merge","counters":[]},{"line":"        (Ledger_proof.statement p1)","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"        (Ledger_proof.statement p2)","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"      |> Result.ok","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"let create ~work_delay ~transaction_capacity_log_2 =","counters":[]},{"line":"  let k = Int.pow 2 transaction_capacity_log_2 in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  Parallel_scan.empty ~delay:work_delay ~max_base_jobs:k","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let empty ~(constraint_constants : Genesis_constants.Constraint_constants.t) ()","counters":[]},{"line":"    =","counters":[]},{"line":"  create ~work_delay:constraint_constants.work_delay","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    ~transaction_capacity_log_2:constraint_constants.transaction_capacity_log_2","counters":[]},{"line":"","counters":[]},{"line":"let extract_txns txns_with_witnesses =","counters":[]},{"line":"  (* TODO: This type checks, but are we actually pulling the inverse txn here? *)","counters":[]},{"line":"  List.map txns_with_witnesses","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    ~f:(fun (txn_with_witness : Transaction_with_witness.t) ->","counters":[]},{"line":"      let txn =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Ledger.Transaction_applied.transaction","counters":[]},{"line":"          txn_with_witness.transaction_with_info","counters":[]},{"line":"      in","counters":[]},{"line":"      let state_hash = fst txn_with_witness.state_hash in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      (txn, state_hash) )","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"let latest_ledger_proof t =","counters":[]},{"line":"  let open Option.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%map proof, txns_with_witnesses = Parallel_scan.last_emitted_value t in","counters":[{"col_start":70,"col_end":70,"count":0}]},{"line":"  (proof, extract_txns txns_with_witnesses)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"","counters":[]},{"line":"let free_space = Parallel_scan.free_space","counters":[]},{"line":"","counters":[]},{"line":"(*This needs to be grouped like in work_to_do function. Group of two jobs per list and not group of two jobs after concatenating the lists*)","counters":[]},{"line":"let all_jobs = Parallel_scan.all_jobs","counters":[]},{"line":"","counters":[]},{"line":"let next_on_new_tree = Parallel_scan.next_on_new_tree","counters":[]},{"line":"","counters":[]},{"line":"let base_jobs_on_latest_tree = Parallel_scan.base_jobs_on_latest_tree","counters":[]},{"line":"","counters":[]},{"line":"let base_jobs_on_earlier_tree = Parallel_scan.base_jobs_on_earlier_tree","counters":[]},{"line":"","counters":[]},{"line":"(*All the transactions in the order in which they were applied*)","counters":[]},{"line":"let staged_transactions t =","counters":[]},{"line":"  List.map ~f:(fun (t : Transaction_with_witness.t) ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      t.transaction_with_info |> Ledger.Transaction_applied.transaction )","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  @@ Parallel_scan.pending_data t","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"","counters":[]},{"line":"let staged_transactions_with_protocol_states t","counters":[]},{"line":"    ~(get_state : State_hash.t -> Mina_state.Protocol_state.value Or_error.t) =","counters":[]},{"line":"  let open Or_error.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  List.map ~f:(fun (t : Transaction_with_witness.t) ->","counters":[]},{"line":"      let txn =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        t.transaction_with_info |> Ledger.Transaction_applied.transaction","counters":[]},{"line":"      in","counters":[]},{"line":"      let%map protocol_state = get_state (fst t.state_hash) in","counters":[{"col_start":39,"col_end":39,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"      (txn, protocol_state) )","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  @@ Parallel_scan.pending_data t","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"  |> Or_error.all","counters":[{"col_start":5,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"let partition_if_overflowing t =","counters":[]},{"line":"  let bundle_count work_count = (work_count + 1) / 2 in","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"  let { Space_partition.first = slots, job_count; second } =","counters":[]},{"line":"    Parallel_scan.partition_if_overflowing t","counters":[]},{"line":"  in","counters":[]},{"line":"  { Space_partition.first = (slots, bundle_count job_count)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"  ; second =","counters":[]},{"line":"      Option.map second ~f:(fun (slots, job_count) ->","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"          (slots, bundle_count job_count) )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"let extract_from_job (job : job) =","counters":[]},{"line":"  match job with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | Parallel_scan.Available_job.Base d ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      First","counters":[]},{"line":"        ( d.transaction_with_info","counters":[]},{"line":"        , d.statement","counters":[]},{"line":"        , d.state_hash","counters":[]},{"line":"        , d.ledger_witness","counters":[]},{"line":"        , d.init_stack )","counters":[]},{"line":"  | Merge ((p1, _), (p2, _)) ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Second (p1, p2)","counters":[]},{"line":"","counters":[]},{"line":"let snark_job_list_json t =","counters":[]},{"line":"  let all_jobs : Job_view.t list list =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    let fa (a : Ledger_proof_with_sok_message.t) =","counters":[]},{"line":"      Ledger_proof.statement (fst a)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"    in","counters":[]},{"line":"    let fd (d : Transaction_with_witness.t) = d.statement in","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"    Parallel_scan.view_jobs_with_position t fa fd","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"  in","counters":[]},{"line":"  Yojson.Safe.to_string","counters":[]},{"line":"    (`List","counters":[]},{"line":"      (List.map all_jobs ~f:(fun tree ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"           `List (List.map tree ~f:Job_view.to_yojson) ) ) )","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"(*Always the same pairing of jobs*)","counters":[]},{"line":"let all_work_statements_exn t : Transaction_snark_work.Statement.t list =","counters":[]},{"line":"  let work_seqs = all_jobs t in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  List.concat_map work_seqs ~f:(fun work_seq ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      One_or_two.group_list","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (List.map work_seq ~f:(fun job ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"             match statement_of_job job with","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"             | None ->","counters":[]},{"line":"                 assert false","counters":[]},{"line":"             | Some stmt ->","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                 stmt ) ) )","counters":[]},{"line":"","counters":[]},{"line":"let required_work_pairs t ~slots =","counters":[]},{"line":"  let work_list = Parallel_scan.jobs_for_slots t ~slots in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  List.concat_map work_list ~f:(fun works -> One_or_two.group_list works)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"","counters":[]},{"line":"let k_work_pairs_for_new_diff t ~k =","counters":[]},{"line":"  let work_list = Parallel_scan.jobs_for_next_update t in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  List.(","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    take (concat_map work_list ~f:(fun works -> One_or_two.group_list works)) k)","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"","counters":[]},{"line":"(*Always the same pairing of jobs*)","counters":[]},{"line":"let work_statements_for_new_diff t : Transaction_snark_work.Statement.t list =","counters":[]},{"line":"  let work_list = Parallel_scan.jobs_for_next_update t in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  List.concat_map work_list ~f:(fun work_seq ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      One_or_two.group_list","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (List.map work_seq ~f:(fun job ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"             match statement_of_job job with","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"             | None ->","counters":[]},{"line":"                 assert false","counters":[]},{"line":"             | Some stmt ->","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                 stmt ) ) )","counters":[]},{"line":"","counters":[]},{"line":"let all_work_pairs t","counters":[]},{"line":"    ~(get_state : State_hash.t -> Mina_state.Protocol_state.value Or_error.t) :","counters":[]},{"line":"    (Transaction_witness.t, Ledger_proof.t) Snark_work_lib.Work.Single.Spec.t","counters":[]},{"line":"    One_or_two.t","counters":[]},{"line":"    list","counters":[]},{"line":"    Or_error.t =","counters":[]},{"line":"  let all_jobs = all_jobs t in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let module A = Available_job in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let open Or_error.Let_syntax in","counters":[]},{"line":"  let single_spec (job : job) =","counters":[]},{"line":"    match extract_from_job job with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | First","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ( transaction_with_info","counters":[]},{"line":"        , statement","counters":[]},{"line":"        , state_hash","counters":[]},{"line":"        , ledger_witness","counters":[]},{"line":"        , init_stack ) ->","counters":[]},{"line":"        let%map witness =","counters":[]},{"line":"          let { With_status.data = transaction; status } =","counters":[]},{"line":"            Mina_transaction_logic.Transaction_applied.transaction_with_status","counters":[]},{"line":"              transaction_with_info","counters":[]},{"line":"          in","counters":[]},{"line":"          let%bind protocol_state_body =","counters":[]},{"line":"            let%map state = get_state (fst state_hash) in","counters":[{"col_start":36,"col_end":36,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"            Mina_state.Protocol_state.body state","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%map init_stack =","counters":[]},{"line":"            match init_stack with","counters":[]},{"line":"            | Base x ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Ok x","counters":[]},{"line":"            | Merge ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Or_error.error_string \"init_stack was Merge\"","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"          in","counters":[]},{"line":"          { Transaction_witness.ledger = ledger_witness","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          ; transaction","counters":[]},{"line":"          ; protocol_state_body","counters":[]},{"line":"          ; init_stack","counters":[]},{"line":"          ; status","counters":[]},{"line":"          }","counters":[]},{"line":"        in","counters":[]},{"line":"        Snark_work_lib.Work.Single.Spec.Transition (statement, witness)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    | Second (p1, p2) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let%map merged =","counters":[]},{"line":"          Transaction_snark.Statement.merge","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"            (Ledger_proof.statement p1)","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"            (Ledger_proof.statement p2)","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"        in","counters":[]},{"line":"        Snark_work_lib.Work.Single.Spec.Merge (merged, p1, p2)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"  in","counters":[]},{"line":"  List.fold_until all_jobs ~init:[]","counters":[]},{"line":"    ~finish:(fun lst -> Ok lst)","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"    ~f:(fun acc jobs ->","counters":[]},{"line":"      let specs_list : 'a One_or_two.t list Or_error.t =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        List.fold ~init:(Ok []) (One_or_two.group_list jobs)","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"          ~f:(fun acc' pair ->","counters":[]},{"line":"            let%bind acc' = acc' in","counters":[]},{"line":"            let%map spec = One_or_two.Or_error.map ~f:single_spec pair in","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"            spec :: acc' )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"      in","counters":[]},{"line":"      match specs_list with","counters":[]},{"line":"      | Ok list ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Continue (acc @ List.rev list)","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"      | Error e ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Stop (Error e) )","counters":[]},{"line":"","counters":[]},{"line":"let update_metrics = Parallel_scan.update_metrics","counters":[]},{"line":"","counters":[]},{"line":"let fill_work_and_enqueue_transactions t transactions work =","counters":[]},{"line":"  let open Or_error.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let fill_in_transaction_snark_work t (works : Transaction_snark_work.t list) :","counters":[]},{"line":"      (Ledger_proof.t * Sok_message.t) list Or_error.t =","counters":[]},{"line":"    let next_jobs =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      List.(","counters":[]},{"line":"        take","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"          (concat @@ Parallel_scan.jobs_for_next_update t)","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"          (total_proofs works))","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"    in","counters":[]},{"line":"    map2_or_error next_jobs","counters":[]},{"line":"      (List.concat_map works","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"         ~f:(fun { Transaction_snark_work.fee; proofs; prover } ->","counters":[]},{"line":"           One_or_two.map proofs ~f:(fun proof -> (fee, proof, prover))","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"           |> One_or_two.to_list ) )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"      ~f:completed_work_to_scanable_work","counters":[]},{"line":"  in","counters":[]},{"line":"  let old_proof = Parallel_scan.last_emitted_value t in","counters":[]},{"line":"  let%bind work_list = fill_in_transaction_snark_work t work in","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"  let%bind proof_opt, updated_scan_state =","counters":[]},{"line":"    Parallel_scan.update t ~completed_jobs:work_list ~data:transactions","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%map result_opt =","counters":[]},{"line":"    Option.value_map ~default:(Ok None) proof_opt","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"      ~f:(fun ((proof, _), txns_with_witnesses) ->","counters":[]},{"line":"        let curr_source = (Ledger_proof.statement proof).source in","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"        (*TODO: get genesis ledger hash if the old_proof is none*)","counters":[]},{"line":"        let prev_target =","counters":[]},{"line":"          Option.value_map ~default:curr_source old_proof","counters":[]},{"line":"            ~f:(fun ((p', _), _) -> (Ledger_proof.statement p').target)","counters":[{"col_start":36,"col_end":36,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"        in","counters":[]},{"line":"        (*prev_target is connected to curr_source- Order of the arguments is","counters":[]},{"line":"          important here*)","counters":[]},{"line":"        if Mina_state.Registers.Value.connected prev_target curr_source then","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Ok (Some (proof, extract_txns txns_with_witnesses))","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"        else Or_error.error_string \"Unexpected ledger proof emitted\" )","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"  in","counters":[]},{"line":"  (result_opt, updated_scan_state)","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let required_state_hashes t =","counters":[]},{"line":"  List.fold ~init:State_hash.Set.empty","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    ~f:(fun acc (t : Transaction_with_witness.t) ->","counters":[]},{"line":"      Set.add acc (fst t.state_hash) )","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"    (Parallel_scan.pending_data t)","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"","counters":[]},{"line":"let check_required_protocol_states t ~protocol_states =","counters":[]},{"line":"  let open Or_error.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let required_state_hashes = required_state_hashes t in","counters":[]},{"line":"  let check_length states =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    let required = State_hash.Set.length required_state_hashes in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let received = List.length states in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    if required = received then Or_error.return ()","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"    else","counters":[]},{"line":"      Or_error.errorf","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        !\"Required %d protocol states but received %d\"","counters":[]},{"line":"        required received","counters":[]},{"line":"  in","counters":[]},{"line":"  (*Don't check further if the lengths dont match*)","counters":[]},{"line":"  let%bind () = check_length protocol_states in","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"  let received_state_map =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    List.fold protocol_states ~init:Mina_base.State_hash.Map.empty","counters":[]},{"line":"      ~f:(fun m ps ->","counters":[]},{"line":"        State_hash.Map.set m","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ~key:(State_hash.With_state_hashes.state_hash ps)","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"          ~data:ps )","counters":[]},{"line":"  in","counters":[]},{"line":"  let protocol_states_assoc =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    List.filter_map","counters":[]},{"line":"      (State_hash.Set.to_list required_state_hashes)","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"      ~f:(State_hash.Map.find received_state_map)","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%map () = check_length protocol_states_assoc in","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"  protocol_states_assoc","counters":[{"col_start":2,"col_end":2,"count":0}]}]}