{"filename":"src/lib/rosetta_coding/coding.ml","lines":[{"line":"(* coding.ml -- hex encoding/decoding for Rosetta *)","counters":[]},{"line":"","counters":[]},{"line":"[%%import \"/src/config.mlh\"]","counters":[]},{"line":"","counters":[{"col_start":0,"col_end":0,"count":1}]},{"line":"open Core_kernel","counters":[]},{"line":"module Field = Snark_params.Tick.Field","counters":[]},{"line":"module Scalar = Snark_params.Tick.Inner_curve.Scalar","counters":[]},{"line":"open Signature_lib","counters":[]},{"line":"","counters":[]},{"line":"(* see RFC 0038, section \"marshal-keys\" for a specification *)","counters":[]},{"line":"","counters":[]},{"line":"let hex_char_to_bits4 = function","counters":[]},{"line":"  | '0' ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      [ false; false; false; false ]","counters":[]},{"line":"  | '1' ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      [ false; false; false; true ]","counters":[]},{"line":"  | '2' ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      [ false; false; true; false ]","counters":[]},{"line":"  | '3' ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      [ false; false; true; true ]","counters":[]},{"line":"  | '4' ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      [ false; true; false; false ]","counters":[]},{"line":"  | '5' ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      [ false; true; false; true ]","counters":[]},{"line":"  | '6' ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      [ false; true; true; false ]","counters":[]},{"line":"  | '7' ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      [ false; true; true; true ]","counters":[]},{"line":"  | '8' ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      [ true; false; false; false ]","counters":[]},{"line":"  | '9' ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      [ true; false; false; true ]","counters":[]},{"line":"  | 'A' | 'a' ->","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":10,"col_end":10,"count":0}]},{"line":"      [ true; false; true; false ]","counters":[]},{"line":"  | 'B' | 'b' ->","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":10,"col_end":10,"count":0}]},{"line":"      [ true; false; true; true ]","counters":[]},{"line":"  | 'C' | 'c' ->","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":10,"col_end":10,"count":0}]},{"line":"      [ true; true; false; false ]","counters":[]},{"line":"  | 'D' | 'd' ->","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":10,"col_end":10,"count":0}]},{"line":"      [ true; true; false; true ]","counters":[]},{"line":"  | 'E' | 'e' ->","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":10,"col_end":10,"count":0}]},{"line":"      [ true; true; true; false ]","counters":[]},{"line":"  | 'F' | 'f' ->","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":10,"col_end":10,"count":0}]},{"line":"      [ true; true; true; true ]","counters":[]},{"line":"  | _ ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      failwith \"Expected hex character\"","counters":[]},{"line":"","counters":[]},{"line":"let bits4_to_hex_char bits =","counters":[]},{"line":"  List.mapi bits ~f:(fun i bit -> if bit then Int.pow 2 (3 - i) else 0)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":46,"col_end":46,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"  |> List.fold ~init:0 ~f:( + )","counters":[{"col_start":5,"col_end":5,"count":0}]},{"line":"  |> fun n ->","counters":[{"col_start":5,"col_end":5,"count":0}]},{"line":"  let s = sprintf \"%0X\" n in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  s.[0]","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"module type Packed = sig","counters":[]},{"line":"  type t","counters":[]},{"line":"","counters":[]},{"line":"  val unpack : t -> bool list","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(* break of the bits byte by byte *)","counters":[]},{"line":"let bits_by_n n bits =","counters":[]},{"line":"  let rec go bits acc =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    if List.is_empty bits then List.rev acc","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"    else","counters":[]},{"line":"      let bitsn, rest = List.split_n bits n in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      go rest (bitsn :: acc)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  in","counters":[]},{"line":"  go bits []","counters":[]},{"line":"","counters":[]},{"line":"let bits_by_4s = bits_by_n 4","counters":[{"col_start":25,"col_end":25,"count":1}]},{"line":"","counters":[]},{"line":"let bits_by_8s = bits_by_n 8","counters":[{"col_start":25,"col_end":25,"count":1}]},{"line":"","counters":[]},{"line":"let of_unpackable (type t) (module M : Packed with type t = t)","counters":[]},{"line":"    ?(padding_bit = false) (packed : t) =","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"  let bits0 = M.unpack packed |> List.rev in","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"  assert (Mina_stdlib.List.Length.Compare.(bits0 = 255)) ;","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":9,"col_end":9,"count":0}]},{"line":"  (* field elements, scalars are 255 bits, left-pad to get 32 bytes *)","counters":[]},{"line":"  let bits = padding_bit :: bits0 in","counters":[]},{"line":"  (* break of the bits byte by byte *)","counters":[]},{"line":"  (* In our encoding, we want highest bytes at the end and lowest at the","counters":[]},{"line":"     beginning. *)","counters":[]},{"line":"  let bytes = bits_by_8s bits in","counters":[]},{"line":"  let bytes' = List.rev bytes in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let bits' = List.concat bytes' in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let cs = List.map (bits_by_4s bits') ~f:bits4_to_hex_char in","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"  String.of_char_list cs","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let of_field = of_unpackable (module Field)","counters":[{"col_start":27,"col_end":27,"count":1}]},{"line":"","counters":[]},{"line":"let of_scalar = of_unpackable (module Scalar)","counters":[{"col_start":28,"col_end":28,"count":1}]},{"line":"","counters":[]},{"line":"module type Unpacked = sig","counters":[]},{"line":"  type t","counters":[]},{"line":"","counters":[]},{"line":"  val project : bool list -> t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let pack (type t) (module M : Unpacked with type t = t) (raw : string) :","counters":[]},{"line":"    bool * t =","counters":[]},{"line":"  (* 256 bits = 64 hex chars *)","counters":[]},{"line":"  assert (Int.equal (String.length raw) 64) ;","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":9,"col_end":9,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"  let bits =","counters":[]},{"line":"    String.to_list raw |> List.map ~f:hex_char_to_bits4 |> List.concat","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"  in","counters":[]},{"line":"  (* In our encoding, we have highest bytes at the end and lowest at the","counters":[]},{"line":"     beginning. *)","counters":[]},{"line":"  let bytes = bits_by_8s bits in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let bytes_rev = List.rev bytes in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let bits' = List.concat bytes_rev in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"  let padding_bit = List.hd_exn bits' in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  (* remove padding bit *)","counters":[]},{"line":"  let bits'' = List.tl_exn bits' |> List.rev in","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"  (padding_bit, M.project bits'')","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"","counters":[]},{"line":"let to_field hex = pack (module Field) hex |> snd","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"","counters":[]},{"line":"let to_scalar hex = pack (module Scalar) hex |> snd","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"","counters":[]},{"line":"let of_public_key_compressed pk =","counters":[]},{"line":"  let { Public_key.Compressed.Poly.x; is_odd } = pk in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  of_field ~padding_bit:is_odd x","counters":[]},{"line":"","counters":[]},{"line":"let of_public_key pk = of_public_key_compressed (Public_key.compress pk)","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"","counters":[]},{"line":"let to_public_key_compressed raw =","counters":[]},{"line":"  let is_odd, x = pack (module Field) raw in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  { Public_key.Compressed.Poly.x; is_odd }","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let to_public_key raw =","counters":[]},{"line":"  to_public_key_compressed raw |> Public_key.decompress_exn","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"","counters":[]},{"line":"(* inline tests hard-to-impossible to setup with JS *)","counters":[]},{"line":"","counters":[]},{"line":"let field_hex_roundtrip_test () =","counters":[]},{"line":"  let field0 = Field.of_int 123123 in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let hex = of_field field0 in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let field1 = to_field hex in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  Field.equal field0 field1","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let pk_roundtrip_test () =","counters":[]},{"line":"  let pk =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    { Public_key.Compressed.Poly.x = Field.of_int 123123; is_odd = true }","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"  in","counters":[]},{"line":"  let hex = of_public_key_compressed pk in","counters":[]},{"line":"  let pk' = to_public_key_compressed hex in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  Public_key.Compressed.equal pk pk'","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let hex_key_odd =","counters":[]},{"line":"  \"fad1d3e31aede102793fb2cce62b4f1e71a214c94ce18ad5756eba67ef398390\"","counters":[]},{"line":"","counters":[]},{"line":"let hex_key_even =","counters":[]},{"line":"  \"7e406ca640115a8c44ece6ef5d0c56af343b1a993d8c871648ab7980ecaf8230\"","counters":[]},{"line":"","counters":[]},{"line":"let pk_compressed_roundtrip_test hex_key () =","counters":[]},{"line":"  let pk = to_public_key hex_key in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let hex' = of_public_key pk in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  String.equal (String.lowercase hex_key) (String.lowercase hex')","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"","counters":[]},{"line":"let%test \"field_hex round-trip\" = field_hex_roundtrip_test ()","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"","counters":[]},{"line":"let%test \"public key round-trip\" = pk_roundtrip_test ()","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"let%test \"public key compressed roundtrip odd\" =","counters":[]},{"line":"  pk_compressed_roundtrip_test hex_key_odd ()","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let%test \"public key compressed roundtrip even\" =","counters":[]},{"line":"  pk_compressed_roundtrip_test hex_key_even ()","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"(* for running tests from JS *)","counters":[]},{"line":"","counters":[]},{"line":"let unit_tests =","counters":[]},{"line":"  [ (\"field-hex round-trip\", field_hex_roundtrip_test)","counters":[]},{"line":"  ; (\"public key round-trip\", pk_roundtrip_test)","counters":[]},{"line":"  ; ( \"public key compressed round-trip odd\"","counters":[]},{"line":"    , pk_compressed_roundtrip_test hex_key_odd )","counters":[{"col_start":33,"col_end":33,"count":1}]},{"line":"  ; ( \"public key compressed round-trip even\"","counters":[]},{"line":"    , pk_compressed_roundtrip_test hex_key_even )","counters":[{"col_start":33,"col_end":33,"count":1}]},{"line":"  ]","counters":[]},{"line":"","counters":[]},{"line":"let run_unit_tests () =","counters":[]},{"line":"  List.iter unit_tests ~f:(fun (name, test) ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      printf \"Running %s test\\n%!\" name ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      assert (test ()) )","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":23,"col_end":23,"count":1}]}]}