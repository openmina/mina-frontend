{"filename":"src/scan_state/currency.rs","lines":[{"line":"use std::cmp::Ordering::{Equal, Greater, Less};","counters":[]},{"line":"","counters":[]},{"line":"#[derive(Copy, Clone, Debug, PartialEq, Eq)]","counters":[{"col_start":15,"col_end":20,"count":0},{"col_start":22,"col_end":23,"count":0},{"col_start":26,"col_end":27,"count":0},{"col_start":29,"col_end":38,"count":0}]},{"line":"pub enum Sgn {","counters":[]},{"line":"    Pos,","counters":[]},{"line":"    Neg,","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Sgn {","counters":[]},{"line":"    fn negate(&self) -> Self {","counters":[{"col_start":4,"col_end":30,"count":0}]},{"line":"        match self {","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"            Sgn::Pos => Sgn::Neg,","counters":[{"col_start":24,"col_end":32,"count":0}]},{"line":"            Sgn::Neg => Sgn::Pos,","counters":[{"col_start":24,"col_end":32,"count":0}]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"pub trait Magnitude","counters":[]},{"line":"where","counters":[]},{"line":"    Self: Sized + PartialOrd + Copy,","counters":[]},{"line":"{","counters":[]},{"line":"    fn abs_diff(&self, rhs: &Self) -> Self;","counters":[]},{"line":"    fn wrapping_add(&self, rhs: &Self) -> Self;","counters":[]},{"line":"    fn wrapping_mul(&self, rhs: &Self) -> Self;","counters":[]},{"line":"    fn wrapping_sub(&self, rhs: &Self) -> Self;","counters":[]},{"line":"    fn checked_add(&self, rhs: &Self) -> Option<Self>;","counters":[]},{"line":"    fn checked_mul(&self, rhs: &Self) -> Option<Self>;","counters":[]},{"line":"    fn checked_sub(&self, rhs: &Self) -> Option<Self>;","counters":[]},{"line":"","counters":[]},{"line":"    fn is_zero(&self) -> bool;","counters":[]},{"line":"    fn zero() -> Self;","counters":[]},{"line":"","counters":[]},{"line":"    fn add_flagged(&self, rhs: &Self) -> (Self, bool) {","counters":[{"col_start":4,"col_end":55,"count":0}]},{"line":"        let z = self.wrapping_add(rhs);","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"        (z, z < *self)","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn sub_flagged(&self, rhs: &Self) -> (Self, bool) {","counters":[{"col_start":4,"col_end":55,"count":0}]},{"line":"        (self.wrapping_sub(rhs), self < rhs)","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"/// Trait used for default values with `ClosedInterval`","counters":[]},{"line":"pub trait MinMax {","counters":[]},{"line":"    fn min() -> Self;","counters":[]},{"line":"    fn max() -> Self;","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"#[derive(Copy, Clone, Debug, PartialEq, Eq)]","counters":[{"col_start":15,"col_end":20,"count":0},{"col_start":22,"col_end":27,"count":0},{"col_start":29,"col_end":30,"count":4107187},{"col_start":37,"col_end":38,"count":4107187}]},{"line":"pub struct Signed<T: Magnitude> {","counters":[]},{"line":"    pub magnitude: T,","counters":[]},{"line":"    pub sgn: Sgn,","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl<T> Signed<T>","counters":[]},{"line":"where","counters":[]},{"line":"    T: Magnitude + PartialOrd + Ord + Clone,","counters":[]},{"line":"{","counters":[]},{"line":"    pub fn create(magnitude: T, sgn: Sgn) -> Self {","counters":[{"col_start":4,"col_end":51,"count":0}]},{"line":"        Self { magnitude, sgn }","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn of_unsigned(magnitude: T) -> Self {","counters":[{"col_start":4,"col_end":46,"count":0}]},{"line":"        Self::create(magnitude, Sgn::Pos)","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn negate(&self) -> Self {","counters":[{"col_start":4,"col_end":34,"count":0}]},{"line":"        if self.magnitude.is_zero() {","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"            Self::zero()","counters":[{"col_start":12,"col_end":24,"count":10}]},{"line":"        } else {","counters":[]},{"line":"            Self {","counters":[{"col_start":12,"col_end":18,"count":0}]},{"line":"                magnitude: self.magnitude,","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"                sgn: self.sgn.negate(),","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn is_pos(&self) -> bool {","counters":[{"col_start":4,"col_end":33,"count":0}]},{"line":"        matches!(self.sgn, Sgn::Pos)","counters":[{"col_start":8,"col_end":16,"count":0},{"col_start":17,"col_end":25,"count":0}]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/currency/currency.ml#L441","counters":[]},{"line":"    pub fn zero() -> Self {","counters":[{"col_start":4,"col_end":27,"count":0}]},{"line":"        Self {","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"            magnitude: T::zero(),","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"            sgn: Sgn::Pos,","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn is_zero(&self) -> bool {","counters":[{"col_start":4,"col_end":35,"count":0}]},{"line":"        self.magnitude.is_zero() && matches!(self.sgn, Sgn::Pos)","counters":[{"col_start":0,"col_end":32,"count":0},{"col_start":36,"col_end":44,"count":0},{"col_start":45,"col_end":53,"count":0}]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    // TODO: is it safe to remove the sign check of is_zero()?","counters":[]},{"line":"    pub fn is_zero2(&self) -> bool {","counters":[{"col_start":4,"col_end":36,"count":0}]},{"line":"        self.magnitude.is_zero()","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/currency/currency.ml#L460","counters":[]},{"line":"    pub fn add(&self, rhs: &Self) -> Option<Self> {","counters":[{"col_start":4,"col_end":50,"count":0}]},{"line":"        let (magnitude, sgn) = if self.sgn == rhs.sgn {","counters":[{"col_start":13,"col_end":27,"count":48},{"col_start":34,"col_end":53,"count":0}]},{"line":"            let magnitude = self.magnitude.checked_add(&rhs.magnitude)?;","counters":[{"col_start":16,"col_end":25,"count":48},{"col_start":28,"col_end":70,"count":0},{"col_start":70,"col_end":71,"count":2}]},{"line":"            let sgn = self.sgn;","counters":[{"col_start":16,"col_end":31,"count":48}]},{"line":"","counters":[]},{"line":"            (magnitude, sgn)","counters":[{"col_start":0,"col_end":28,"count":48}]},{"line":"        } else {","counters":[]},{"line":"            let sgn = match self.magnitude.cmp(&rhs.magnitude) {","counters":[{"col_start":16,"col_end":19,"count":0},{"col_start":28,"col_end":62,"count":0}]},{"line":"                Less => rhs.sgn,","counters":[{"col_start":24,"col_end":31,"count":0}]},{"line":"                Greater => self.sgn,","counters":[{"col_start":27,"col_end":35,"count":0}]},{"line":"                Equal => return Some(Self::zero()),","counters":[{"col_start":32,"col_end":50,"count":0}]},{"line":"            };","counters":[]},{"line":"            let magnitude = self.magnitude.abs_diff(&rhs.magnitude);","counters":[{"col_start":16,"col_end":68,"count":0}]},{"line":"","counters":[]},{"line":"            (magnitude, sgn)","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        Some(Self { magnitude, sgn })","counters":[{"col_start":8,"col_end":37,"count":48}]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":48}]},{"line":"","counters":[]},{"line":"    pub fn add_flagged(&self, rhs: Self) -> (Self, bool) {","counters":[]},{"line":"        match (self.sgn, rhs.sgn) {","counters":[{"col_start":15,"col_end":32,"count":2}]},{"line":"            (Sgn::Neg, sgn @ Sgn::Neg) | (Sgn::Pos, sgn @ Sgn::Pos) => {","counters":[{"col_start":23,"col_end":26,"count":0},{"col_start":52,"col_end":55,"count":0}]},{"line":"                let (magnitude, overflow) = self.magnitude.add_flagged(&rhs.magnitude);","counters":[{"col_start":21,"col_end":87,"count":0}]},{"line":"                (Self { magnitude, sgn }, overflow)","counters":[{"col_start":0,"col_end":51,"count":0}]},{"line":"            }","counters":[]},{"line":"            (Sgn::Pos, Sgn::Neg) | (Sgn::Neg, Sgn::Pos) => {","counters":[]},{"line":"                let sgn = match self.magnitude.cmp(&rhs.magnitude) {","counters":[{"col_start":20,"col_end":23,"count":5637969},{"col_start":32,"col_end":66,"count":0}]},{"line":"                    Less => rhs.sgn,","counters":[{"col_start":28,"col_end":35,"count":5637969}]},{"line":"                    Greater => self.sgn,","counters":[{"col_start":31,"col_end":39,"count":0}]},{"line":"                    Equal => Sgn::Pos,","counters":[{"col_start":29,"col_end":37,"count":0}]},{"line":"                };","counters":[]},{"line":"                let magnitude = self.magnitude.abs_diff(&rhs.magnitude);","counters":[{"col_start":20,"col_end":72,"count":5637969}]},{"line":"                (Self { magnitude, sgn }, false)","counters":[{"col_start":0,"col_end":48,"count":5637969}]},{"line":"            }","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":5637969}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Amount {","counters":[]},{"line":"    pub fn of_fee(fee: &Fee) -> Self {","counters":[{"col_start":4,"col_end":38,"count":0}]},{"line":"        Self(fee.0)","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn add_signed_flagged(&self, rhs: Signed<Self>) -> (Self, bool) {","counters":[{"col_start":4,"col_end":73,"count":0}]},{"line":"        if let Sgn::Pos = rhs.sgn {","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"            self.add_flagged(&rhs.magnitude)","counters":[{"col_start":12,"col_end":44,"count":-26768}]},{"line":"        } else {","counters":[]},{"line":"            self.sub_flagged(&rhs.magnitude)","counters":[{"col_start":12,"col_end":44,"count":26768}]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Balance {","counters":[]},{"line":"    pub fn sub_amount(&self, amount: Amount) -> Option<Self> {","counters":[{"col_start":4,"col_end":62,"count":2094}]},{"line":"        self.0.checked_sub(amount.0).map(Self)","counters":[{"col_start":0,"col_end":46,"count":2094}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":2094}]},{"line":"","counters":[]},{"line":"    pub fn add_amount(&self, amount: Amount) -> Option<Self> {","counters":[{"col_start":4,"col_end":62,"count":0}]},{"line":"        self.0.checked_add(amount.0).map(Self)","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn add_signed_flagged(&self, rhs: Signed<Self>) -> (Self, bool) {","counters":[{"col_start":4,"col_end":73,"count":14296794}]},{"line":"        if let Sgn::Pos = rhs.sgn {","counters":[{"col_start":0,"col_end":33,"count":14296794}]},{"line":"            self.add_flagged(&rhs.magnitude)","counters":[{"col_start":12,"col_end":44,"count":11655658}]},{"line":"        } else {","counters":[]},{"line":"            self.sub_flagged(&rhs.magnitude)","counters":[{"col_start":12,"col_end":44,"count":2641136}]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":14296794}]},{"line":"","counters":[]},{"line":"    pub fn add_signed_amount_flagged(&self, rhs: Signed<Amount>) -> (Self, bool) {","counters":[{"col_start":4,"col_end":82,"count":0}]},{"line":"        let rhs = Signed {","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"            magnitude: Balance::from_u64(rhs.magnitude.0),","counters":[{"col_start":0,"col_end":58,"count":0}]},{"line":"            sgn: rhs.sgn,","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"        };","counters":[{"col_start":0,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"        if let Sgn::Pos = rhs.sgn {","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"            self.add_flagged(&rhs.magnitude)","counters":[{"col_start":12,"col_end":44,"count":0}]},{"line":"        } else {","counters":[]},{"line":"            self.sub_flagged(&rhs.magnitude)","counters":[{"col_start":12,"col_end":44,"count":0}]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn to_amount(self) -> Amount {","counters":[{"col_start":4,"col_end":38,"count":0}]},{"line":"        Amount(self.0)","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Index {","counters":[]},{"line":"    // TODO: Not sure if OCaml wraps around here","counters":[]},{"line":"    pub fn incr(&self) -> Self {","counters":[{"col_start":4,"col_end":32,"count":0}]},{"line":"        Self(self.0.wrapping_add(1))","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Nonce {","counters":[]},{"line":"    // TODO: Not sure if OCaml wraps around here","counters":[]},{"line":"    pub fn incr(&self) -> Self {","counters":[{"col_start":4,"col_end":32,"count":0}]},{"line":"        Self(self.0.wrapping_add(1))","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn succ(&self) -> Self {","counters":[{"col_start":4,"col_end":32,"count":0}]},{"line":"        self.incr()","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn add_signed_flagged(&self, rhs: Signed<Self>) -> (Self, bool) {","counters":[{"col_start":4,"col_end":73,"count":0}]},{"line":"        if let Sgn::Pos = rhs.sgn {","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"            self.add_flagged(&rhs.magnitude)","counters":[{"col_start":12,"col_end":44,"count":0}]},{"line":"        } else {","counters":[]},{"line":"            self.sub_flagged(&rhs.magnitude)","counters":[{"col_start":12,"col_end":44,"count":0}]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl BlockTime {","counters":[]},{"line":"    pub fn add(&self, span: BlockTimeSpan) -> Self {","counters":[{"col_start":4,"col_end":52,"count":0}]},{"line":"        Self(self.0.checked_add(span.0).unwrap())","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn sub(&self, span: BlockTimeSpan) -> Self {","counters":[{"col_start":4,"col_end":52,"count":0}]},{"line":"        Self(self.0.checked_sub(span.0).unwrap())","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl BlockTimeSpan {","counters":[]},{"line":"    pub fn of_ms(ms: u64) -> Self {","counters":[{"col_start":4,"col_end":35,"count":0}]},{"line":"        Self(ms)","counters":[{"col_start":0,"col_end":16,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"macro_rules! impl_number {","counters":[]},{"line":"    (32: { $($name32:ident,)* }, 64: { $($name64:ident,)* },) => {","counters":[]},{"line":"        $(impl_number!({$name32, u32, as_u32, from_u32, next_u32, append_u32},);)+","counters":[]},{"line":"        $(impl_number!({$name64, u64, as_u64, from_u64, next_u64, append_u64},);)+","counters":[]},{"line":"    };","counters":[]},{"line":"    ($({ $name:ident, $inner:ty, $as_name:ident, $from_name:ident, $next_name:ident, $append_name:ident },)*) => ($(","counters":[]},{"line":"        #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]","counters":[{"col_start":23,"col_end":28,"count":0},{"col_start":30,"col_end":39,"count":3626},{"col_start":45,"col_end":55,"count":274},{"col_start":57,"col_end":60,"count":0}]},{"line":"        pub struct $name(pub(super) $inner);","counters":[]},{"line":"","counters":[]},{"line":"        impl std::fmt::Debug for $name {","counters":[]},{"line":"            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {","counters":[{"col_start":12,"col_end":80,"count":39127}]},{"line":"                f.write_fmt(format_args!(\"{}({:?})\", stringify!($name), self.0))","counters":[{"col_start":0,"col_end":80,"count":39127}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":39127}]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        impl Magnitude for $name {","counters":[]},{"line":"            fn zero() -> Self {","counters":[{"col_start":12,"col_end":31,"count":274}]},{"line":"                Self(0)","counters":[{"col_start":0,"col_end":23,"count":274}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":274}]},{"line":"","counters":[]},{"line":"            fn is_zero(&self) -> bool {","counters":[{"col_start":12,"col_end":39,"count":274}]},{"line":"                self.0 == 0","counters":[{"col_start":0,"col_end":27,"count":274}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":274}]},{"line":"","counters":[]},{"line":"            fn wrapping_add(&self, rhs: &Self) -> Self {","counters":[{"col_start":12,"col_end":56,"count":1}]},{"line":"                Self(self.0.wrapping_add(rhs.0))","counters":[{"col_start":0,"col_end":48,"count":1}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":1}]},{"line":"","counters":[]},{"line":"            fn wrapping_mul(&self, rhs: &Self) -> Self {","counters":[{"col_start":12,"col_end":56,"count":1}]},{"line":"                Self(self.0.wrapping_mul(rhs.0))","counters":[{"col_start":0,"col_end":48,"count":1}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":1}]},{"line":"","counters":[]},{"line":"            fn wrapping_sub(&self, rhs: &Self) -> Self {","counters":[{"col_start":12,"col_end":56,"count":1}]},{"line":"                Self(self.0.wrapping_sub(rhs.0))","counters":[{"col_start":0,"col_end":48,"count":1}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":1}]},{"line":"","counters":[]},{"line":"            fn checked_add(&self, rhs: &Self) -> Option<Self> {","counters":[{"col_start":12,"col_end":63,"count":1}]},{"line":"                self.0.checked_add(rhs.0).map(Self)","counters":[{"col_start":0,"col_end":51,"count":1}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":1}]},{"line":"","counters":[]},{"line":"            fn checked_mul(&self, rhs: &Self) -> Option<Self> {","counters":[{"col_start":12,"col_end":63,"count":1}]},{"line":"                self.0.checked_mul(rhs.0).map(Self)","counters":[{"col_start":0,"col_end":51,"count":1}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":1}]},{"line":"","counters":[]},{"line":"            fn checked_sub(&self, rhs: &Self) -> Option<Self> {","counters":[{"col_start":12,"col_end":63,"count":0}]},{"line":"                self.0.checked_sub(rhs.0).map(Self)","counters":[{"col_start":0,"col_end":51,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"            fn abs_diff(&self, rhs: &Self) -> Self {","counters":[{"col_start":12,"col_end":52,"count":0}]},{"line":"                Self(self.0.abs_diff(rhs.0))","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        impl MinMax for $name {","counters":[]},{"line":"            fn min() -> Self { Self(0) }","counters":[{"col_start":12,"col_end":40,"count":0}]},{"line":"            fn max() -> Self { Self(<$inner>::MAX) }","counters":[{"col_start":12,"col_end":52,"count":0}]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        impl $name {","counters":[]},{"line":"            pub fn $as_name(&self) -> $inner {","counters":[{"col_start":12,"col_end":46,"count":0}]},{"line":"                self.0","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"            pub const fn $from_name(value: $inner) -> Self {","counters":[{"col_start":12,"col_end":60,"count":0}]},{"line":"                Self(value)","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"            /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/currency/currency.ml#L379","counters":[]},{"line":"            pub const fn scale(&self, n: $inner) -> Option<Self> {","counters":[{"col_start":12,"col_end":66,"count":0}]},{"line":"                match self.0.checked_mul(n) {","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"                    Some(n) => Some(Self(n)),","counters":[{"col_start":25,"col_end":44,"count":0}]},{"line":"                    None => None","counters":[{"col_start":28,"col_end":32,"count":0}]},{"line":"                }","counters":[]},{"line":"            }","counters":[{"col_start":12,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"            pub fn min() -> Self {","counters":[{"col_start":12,"col_end":34,"count":0}]},{"line":"                <Self as MinMax>::min()","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"            pub fn max() -> Self {","counters":[{"col_start":12,"col_end":34,"count":0}]},{"line":"                <Self as MinMax>::max()","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"            /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/currency/currency.ml#L118","counters":[]},{"line":"            pub fn of_formatted_string(input: &str) -> Self {","counters":[{"col_start":12,"col_end":61,"count":0}]},{"line":"                const PRECISION: usize = 9;","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"","counters":[]},{"line":"                let mut s = String::with_capacity(input.len() + 9);","counters":[{"col_start":0,"col_end":67,"count":0}]},{"line":"","counters":[]},{"line":"                if !input.contains('.') {","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"                    let append = \"000000000\";","counters":[{"col_start":24,"col_end":45,"count":0}]},{"line":"                    assert_eq!(append.len(), PRECISION);","counters":[{"col_start":0,"col_end":55,"count":0}]},{"line":"","counters":[]},{"line":"                    s.push_str(append);","counters":[{"col_start":20,"col_end":38,"count":0}]},{"line":"                } else {","counters":[]},{"line":"                    let (whole, decimal) = {","counters":[{"col_start":25,"col_end":39,"count":0}]},{"line":"                        let mut splitted = input.split('.');","counters":[{"col_start":28,"col_end":60,"count":0}]},{"line":"                        let whole = splitted.next().unwrap();","counters":[{"col_start":0,"col_end":61,"count":0}]},{"line":"                        let decimal = splitted.next().unwrap();","counters":[{"col_start":0,"col_end":63,"count":0}]},{"line":"                        assert!(splitted.next().is_none(), \"Currency.of_formatted_string: Invalid currency input\");","counters":[{"col_start":0,"col_end":57,"count":0},{"col_start":59,"col_end":113,"count":0}]},{"line":"                        (whole, decimal)","counters":[{"col_start":24,"col_end":40,"count":0}]},{"line":"                    };","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"                    let decimal_length = decimal.len();","counters":[{"col_start":0,"col_end":55,"count":0}]},{"line":"","counters":[]},{"line":"                    if decimal_length > PRECISION {","counters":[{"col_start":0,"col_end":49,"count":0},{"col_start":50,"col_end":51,"count":0}]},{"line":"                        s.push_str(whole);","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"                        s.push_str(&decimal[0..PRECISION]);","counters":[{"col_start":0,"col_end":59,"count":0}]},{"line":"                    } else {","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"                        s.push_str(whole);","counters":[{"col_start":24,"col_end":42,"count":0}]},{"line":"                        s.push_str(decimal);","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"                        for _ in 0..PRECISION - decimal_length {","counters":[{"col_start":0,"col_end":62,"count":0},{"col_start":63,"col_end":64,"count":0}]},{"line":"                            s.push('0');","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"                        }","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"                    }","counters":[]},{"line":"                }","counters":[]},{"line":"","counters":[]},{"line":"                let n = s.parse::<$inner>().unwrap();","counters":[{"col_start":20,"col_end":53,"count":0}]},{"line":"                Self(n)","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        impl rand::distributions::Distribution<$name> for rand::distributions::Standard {","counters":[]},{"line":"            fn sample<R: rand::Rng + ?Sized>(&self, rng: &mut R) -> $name {","counters":[{"col_start":12,"col_end":75,"count":0}]},{"line":"                $name(rng.$next_name())","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        impl crate::ToInputs for $name {","counters":[]},{"line":"            fn to_inputs(&self, inputs: &mut crate::Inputs) {","counters":[{"col_start":12,"col_end":61,"count":0}]},{"line":"                inputs.$append_name(self.0);","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"    )+)","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl_number!(","counters":[]},{"line":"    32: { Length, Slot, Nonce, Index, },","counters":[]},{"line":"    64: { Amount, Balance, Fee, BlockTime, BlockTimeSpan, },","counters":[]},{"line":");","counters":[]}]}