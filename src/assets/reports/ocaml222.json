{"filename":"src/lib/mina_base/pending_coinbase_intf.ml","lines":[{"line":"(** Pending_coinbase is to keep track of all the coinbase transactions that have been applied to the ledger but for which there is no ledger proof yet. Every ledger proof corresponds to a sequence of coinbase transactions which is part of all the transactions it proves. Each of these sequences[Stack] are stored using the merkle tree representation. The stacks are operated in a FIFO manner by keeping track of its positions in the merkle tree. Whenever a ledger proof is emitted, the oldest stack is removed from the tree and when a new coinbase is applied, the latest stack is updated with the new coinbase.","counters":[]},{"line":"    The operations on the merkle tree of coinbase stacks include:","counters":[]},{"line":"    1) adding a new singleton stack","counters":[]},{"line":"    2) updating the latest stack when a new coinbase is added to it","counters":[]},{"line":"    2) deleting the oldest stack","counters":[]},{"line":"","counters":[]},{"line":"    A stack can be either be created or modified by pushing a coinbase on to it.","counters":[]},{"line":"","counters":[]},{"line":"    This module also provides an interface for the checked computations required required to prove it in snark","counters":[]},{"line":"","counters":[]},{"line":"    Stack operations are done for transaction snarks and tree operations are done for the blockchain snark*)","counters":[]},{"line":"","counters":[{"col_start":0,"col_end":0,"count":1}]},{"line":"open Core_kernel","counters":[]},{"line":"open Snark_params","counters":[]},{"line":"open Snarky_backendless","counters":[]},{"line":"open Tick","counters":[]},{"line":"open Signature_lib","counters":[]},{"line":"open Currency","counters":[]},{"line":"","counters":[]},{"line":"module type S = sig","counters":[]},{"line":"  type t [@@deriving sexp, to_yojson]","counters":[]},{"line":"","counters":[]},{"line":"  module Stable : sig","counters":[]},{"line":"    module V2 : sig","counters":[]},{"line":"      type nonrec t = t [@@deriving bin_io, sexp, to_yojson, version]","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Latest = V2","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Coinbase_data : sig","counters":[]},{"line":"    module Stable : sig","counters":[]},{"line":"      module V1 : sig","counters":[]},{"line":"        type t = Public_key.Compressed.Stable.V1.t * Amount.Stable.V1.t","counters":[]},{"line":"        [@@deriving sexp, bin_io, to_yojson]","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      module Latest = V1","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    type t = Stable.Latest.t [@@deriving sexp, to_yojson]","counters":[]},{"line":"","counters":[]},{"line":"    type var = Public_key.Compressed.var * Amount.var","counters":[]},{"line":"","counters":[]},{"line":"    val typ : (var, t) Typ.t","counters":[]},{"line":"","counters":[]},{"line":"    val empty : t","counters":[]},{"line":"","counters":[]},{"line":"    val of_coinbase : Coinbase.t -> t","counters":[]},{"line":"","counters":[]},{"line":"    val genesis : t","counters":[]},{"line":"","counters":[]},{"line":"    val var_of_t : t -> var","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module type Data_hash_intf = sig","counters":[]},{"line":"    type t = private Field.t [@@deriving sexp, compare, equal, yojson, hash]","counters":[]},{"line":"","counters":[]},{"line":"    type var","counters":[]},{"line":"","counters":[]},{"line":"    val var_of_t : t -> var","counters":[]},{"line":"","counters":[]},{"line":"    val typ : (var, t) Typ.t","counters":[]},{"line":"","counters":[]},{"line":"    val var_to_hash_packed : var -> Field.Var.t","counters":[]},{"line":"","counters":[]},{"line":"    val equal_var : var -> var -> Boolean.var Tick.Checked.t","counters":[]},{"line":"","counters":[]},{"line":"    val to_bytes : t -> string","counters":[]},{"line":"","counters":[]},{"line":"    val to_bits : t -> bool list","counters":[]},{"line":"","counters":[]},{"line":"    val to_base58_check : t -> string","counters":[]},{"line":"","counters":[]},{"line":"    val of_base58_check_exn : string -> t","counters":[]},{"line":"","counters":[]},{"line":"    val gen : t Quickcheck.Generator.t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module rec Hash : sig","counters":[]},{"line":"    include Data_hash_intf","counters":[]},{"line":"","counters":[]},{"line":"    val merge : height:int -> t -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"    val empty_hash : t","counters":[]},{"line":"","counters":[]},{"line":"    val of_digest : Random_oracle.Digest.t -> t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Hash_versioned : sig","counters":[]},{"line":"    [%%versioned:","counters":[]},{"line":"    module Stable : sig","counters":[]},{"line":"      module V1 : sig","counters":[]},{"line":"        type nonrec t = Hash.t [@@deriving sexp, compare, equal, yojson, hash]","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Stack_versioned : sig","counters":[]},{"line":"    [%%versioned:","counters":[]},{"line":"    module Stable : sig","counters":[]},{"line":"      module V1 : sig","counters":[]},{"line":"        type nonrec t [@@deriving sexp, compare, equal, yojson, hash]","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Stack : sig","counters":[]},{"line":"    type t = Stack_versioned.t [@@deriving sexp, compare, equal, yojson, hash]","counters":[]},{"line":"","counters":[]},{"line":"    type var","counters":[]},{"line":"","counters":[]},{"line":"    val data_hash : t -> Hash.t","counters":[]},{"line":"","counters":[]},{"line":"    val var_of_t : t -> var","counters":[]},{"line":"","counters":[]},{"line":"    val typ : (var, t) Typ.t","counters":[]},{"line":"","counters":[]},{"line":"    val gen : t Quickcheck.Generator.t","counters":[]},{"line":"","counters":[]},{"line":"    val to_input : t -> Field.t Random_oracle.Input.Chunked.t","counters":[]},{"line":"","counters":[]},{"line":"    val to_bits : t -> bool list","counters":[]},{"line":"","counters":[]},{"line":"    val to_bytes : t -> string","counters":[]},{"line":"","counters":[]},{"line":"    val equal_var : var -> var -> Boolean.var Tick.Checked.t","counters":[]},{"line":"","counters":[]},{"line":"    val var_to_input : var -> Field.Var.t Random_oracle.Input.Chunked.t","counters":[]},{"line":"","counters":[]},{"line":"    val empty : t","counters":[]},{"line":"","counters":[]},{"line":"    (** Creates a new stack with the state stack from an existing stack*)","counters":[]},{"line":"    val create_with : t -> t","counters":[]},{"line":"","counters":[]},{"line":"    val equal_data : t -> t -> bool","counters":[]},{"line":"","counters":[]},{"line":"    val equal_state_hash : t -> t -> bool","counters":[]},{"line":"","counters":[]},{"line":"    (** The two stacks are connected. This should be used instead of `equal` to","counters":[]},{"line":"    check one transaction snark statement follow the other.*)","counters":[]},{"line":"    val connected : ?prev:t option -> first:t -> second:t -> unit -> bool","counters":[]},{"line":"","counters":[]},{"line":"    val push_coinbase : Coinbase.t -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"    val push_state : State_body_hash.t -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"    module Checked : sig","counters":[]},{"line":"      type t = var","counters":[]},{"line":"","counters":[]},{"line":"      val push_coinbase : Coinbase_data.var -> t -> t Tick.Checked.t","counters":[]},{"line":"","counters":[]},{"line":"      val push_state : State_body_hash.var -> t -> t Tick.Checked.t","counters":[]},{"line":"","counters":[]},{"line":"      val if_ : Boolean.var -> then_:t -> else_:t -> t Tick.Checked.t","counters":[]},{"line":"","counters":[]},{"line":"      val check_merge :","counters":[]},{"line":"        transition1:t * t -> transition2:t * t -> Boolean.var Tick.Checked.t","counters":[]},{"line":"","counters":[]},{"line":"      val empty : t","counters":[]},{"line":"","counters":[]},{"line":"      val create_with : t -> t","counters":[]},{"line":"    end","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module State_stack : sig","counters":[]},{"line":"    [%%versioned:","counters":[]},{"line":"    module Stable : sig","counters":[]},{"line":"      module V1 : sig","counters":[]},{"line":"        type t","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Update : sig","counters":[]},{"line":"    module Action : sig","counters":[]},{"line":"      [%%versioned:","counters":[]},{"line":"      module Stable : sig","counters":[]},{"line":"        module V1 : sig","counters":[]},{"line":"          type t =","counters":[]},{"line":"            | Update_none","counters":[]},{"line":"            | Update_one","counters":[]},{"line":"            | Update_two_coinbase_in_first","counters":[]},{"line":"            | Update_two_coinbase_in_second","counters":[]},{"line":"          [@@deriving sexp, to_yojson]","counters":[]},{"line":"        end","counters":[]},{"line":"      end]","counters":[]},{"line":"","counters":[]},{"line":"      type var = Boolean.var * Boolean.var","counters":[]},{"line":"","counters":[]},{"line":"      val typ : (var, t) Typ.t","counters":[]},{"line":"","counters":[]},{"line":"      val var_of_t : t -> var","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Poly : sig","counters":[]},{"line":"      [%%versioned:","counters":[]},{"line":"      module Stable : sig","counters":[]},{"line":"        module V1 : sig","counters":[]},{"line":"          type ('action, 'coinbase_amount) t =","counters":[]},{"line":"            { action : 'action; coinbase_amount : 'coinbase_amount }","counters":[]},{"line":"          [@@deriving sexp]","counters":[]},{"line":"        end","counters":[]},{"line":"      end]","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    [%%versioned:","counters":[]},{"line":"    module Stable : sig","counters":[]},{"line":"      module V1 : sig","counters":[]},{"line":"        type t = (Action.Stable.V1.t, Amount.Stable.V1.t) Poly.Stable.V1.t","counters":[]},{"line":"        [@@deriving sexp, to_yojson]","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    type var = (Action.var, Amount.var) Poly.t","counters":[]},{"line":"","counters":[]},{"line":"    val genesis : t","counters":[]},{"line":"","counters":[]},{"line":"    val typ : (var, t) Typ.t","counters":[]},{"line":"","counters":[]},{"line":"    val var_of_t : t -> var","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  val create : depth:int -> unit -> t Or_error.t","counters":[]},{"line":"","counters":[]},{"line":"  (** Delete the oldest stack*)","counters":[]},{"line":"  val remove_coinbase_stack : depth:int -> t -> (Stack.t * t) Or_error.t","counters":[]},{"line":"","counters":[]},{"line":"  (** Root of the merkle tree that has stacks as leaves*)","counters":[]},{"line":"  val merkle_root : t -> Hash.t","counters":[]},{"line":"","counters":[]},{"line":"  val handler :","counters":[]},{"line":"    depth:int -> t -> is_new_stack:bool -> (request -> response) Staged.t","counters":[]},{"line":"","counters":[]},{"line":"  (** Update the current working stack or if [is_new_stack] add as the new working stack*)","counters":[]},{"line":"  val update_coinbase_stack :","counters":[]},{"line":"    depth:int -> t -> Stack.t -> is_new_stack:bool -> t Or_error.t","counters":[]},{"line":"","counters":[]},{"line":"  (** Stack that is currently being updated. if [is_new_stack] then a new stack is returned*)","counters":[]},{"line":"  val latest_stack : t -> is_new_stack:bool -> Stack.t Or_error.t","counters":[]},{"line":"","counters":[]},{"line":"  (** The stack that corresponds to the next ledger proof that is to be generated*)","counters":[]},{"line":"  val oldest_stack : t -> Stack.t Or_error.t","counters":[]},{"line":"","counters":[]},{"line":"  (** Hash of the auxiliary data (everything except the merkle root (Hash.t))*)","counters":[]},{"line":"  val hash_extra : t -> string","counters":[]},{"line":"","counters":[]},{"line":"  module Checked : sig","counters":[]},{"line":"    type var = Hash.var","counters":[]},{"line":"","counters":[]},{"line":"    type path","counters":[]},{"line":"","counters":[]},{"line":"    module Address : sig","counters":[]},{"line":"      type value","counters":[]},{"line":"","counters":[]},{"line":"      type var","counters":[]},{"line":"","counters":[]},{"line":"      val typ : depth:int -> (var, value) Typ.t","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    type _ Request.t +=","counters":[]},{"line":"      | Coinbase_stack_path : Address.value -> path Request.t","counters":[]},{"line":"      | Get_coinbase_stack : Address.value -> (Stack.t * path) Request.t","counters":[]},{"line":"      | Set_coinbase_stack : Address.value * Stack.t -> unit Request.t","counters":[]},{"line":"      | Set_oldest_coinbase_stack : Address.value * Stack.t -> unit Request.t","counters":[]},{"line":"      | Find_index_of_newest_stacks :","counters":[]},{"line":"          Update.Action.t","counters":[]},{"line":"          -> (Address.value * Address.value) Request.t","counters":[]},{"line":"      | Find_index_of_oldest_stack : Address.value Request.t","counters":[]},{"line":"      | Get_previous_stack : State_stack.t Request.t","counters":[]},{"line":"","counters":[]},{"line":"    val get : depth:int -> var -> Address.var -> Stack.var Tick.Checked.t","counters":[]},{"line":"","counters":[]},{"line":"    (**","counters":[]},{"line":"       [update_stack t ~is_new_stack updated_stack] implements the following spec:","counters":[]},{"line":"       - gets the address[addr] of the latest stack or a new stack","counters":[]},{"line":"       - finds a coinbase stack in [t] at path [addr] and pushes the coinbase_data on to the stack","counters":[]},{"line":"       - returns a root [t'] of the tree","counters":[]},{"line":"    *)","counters":[]},{"line":"    val add_coinbase :","counters":[]},{"line":"         constraint_constants:Genesis_constants.Constraint_constants.t","counters":[]},{"line":"      -> var","counters":[]},{"line":"      -> Update.var","counters":[]},{"line":"      -> coinbase_receiver:Public_key.Compressed.var","counters":[]},{"line":"      -> supercharge_coinbase:Boolean.var","counters":[]},{"line":"      -> State_body_hash.var","counters":[]},{"line":"      -> var Tick.Checked.t","counters":[]},{"line":"","counters":[]},{"line":"    (**","counters":[]},{"line":"       [pop_coinbases t pk updated_stack] implements the following spec:","counters":[]},{"line":"","counters":[]},{"line":"       - gets the address[addr] of the oldest stack.","counters":[]},{"line":"       - finds a coinbase stack in [t] at path [addr] and replaces it with empty stack if a [proof_emitted] is true","counters":[]},{"line":"       - returns a root [t'] of the tree","counters":[]},{"line":"    *)","counters":[]},{"line":"    val pop_coinbases :","counters":[]},{"line":"         constraint_constants:Genesis_constants.Constraint_constants.t","counters":[]},{"line":"      -> var","counters":[]},{"line":"      -> proof_emitted:Boolean.var","counters":[]},{"line":"      -> (var * Stack.var) Tick.Checked.t","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":1}]}]}