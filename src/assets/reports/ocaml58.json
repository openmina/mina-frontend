{"filename":"src/lib/pipe_lib/strict_pipe.ml","lines":[{"line":"open Async_kernel","counters":[]},{"line":"open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"exception Overflow of string","counters":[]},{"line":"","counters":[]},{"line":"exception Multiple_reads_attempted of string","counters":[]},{"line":"","counters":[]},{"line":"type crash = Overflow_behavior_crash","counters":[]},{"line":"","counters":[]},{"line":"type drop_head = Overflow_behavior_drop_head","counters":[]},{"line":"","counters":[]},{"line":"type call = Overflow_behavior_call","counters":[]},{"line":"","counters":[]},{"line":"type (_, _, _) overflow_behavior =","counters":[]},{"line":"  | Crash : ('a, crash, unit) overflow_behavior","counters":[]},{"line":"  | Drop_head : ('a -> unit) -> ('a, drop_head, unit) overflow_behavior","counters":[]},{"line":"  | Call : ('a -> 'r) -> ('a, call, 'r option) overflow_behavior","counters":[]},{"line":"","counters":[]},{"line":"type synchronous = Type_synchronous","counters":[]},{"line":"","counters":[]},{"line":"type _ buffered = Type_buffered","counters":[]},{"line":"","counters":[]},{"line":"type (_, _, _) type_ =","counters":[]},{"line":"  | Synchronous : ('a, synchronous, unit Deferred.t) type_","counters":[]},{"line":"  | Buffered :","counters":[]},{"line":"      [ `Capacity of int ] * [ `Overflow of ('a, 'b, 'r) overflow_behavior ]","counters":[]},{"line":"      -> ('a, 'b buffered, 'r) type_","counters":[]},{"line":"","counters":[]},{"line":"let value_or_empty = Option.value ~default:\"<unnamed>\"","counters":[]},{"line":"","counters":[]},{"line":"module Reader0 = struct","counters":[]},{"line":"  type 't t =","counters":[]},{"line":"    { reader : 't Pipe.Reader.t","counters":[]},{"line":"    ; mutable has_reader : bool","counters":[]},{"line":"    ; mutable downstreams : downstreams","counters":[]},{"line":"    ; name : string option","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  and downstreams =","counters":[]},{"line":"    | [] : downstreams","counters":[]},{"line":"    | ( :: ) : 'a t * downstreams -> downstreams","counters":[]},{"line":"","counters":[]},{"line":"  let rec downstreams_from_list : 'a t list -> downstreams = function","counters":[]},{"line":"    | [] ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        []","counters":[]},{"line":"    | r :: rs ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        r :: downstreams_from_list rs","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"","counters":[]},{"line":"  (* TODO: See #1281 *)","counters":[]},{"line":"  let to_linear_pipe { reader = pipe; has_reader; _ } =","counters":[]},{"line":"    { Linear_pipe.Reader.pipe; has_reader }","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let of_linear_pipe ?name { Linear_pipe.Reader.pipe = reader; has_reader } =","counters":[]},{"line":"    { reader; has_reader; downstreams = []; name }","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let pipe_name t = t.name","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"","counters":[]},{"line":"  let assert_not_read reader =","counters":[]},{"line":"    if reader.has_reader then","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      raise (Multiple_reads_attempted (value_or_empty reader.name))","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"","counters":[]},{"line":"  let wrap_reader ?name reader =","counters":[]},{"line":"    { reader; has_reader = false; downstreams = []; name }","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let enforce_single_reader reader deferred =","counters":[]},{"line":"    assert_not_read reader ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    reader.has_reader <- true ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let%map result = deferred in","counters":[]},{"line":"    reader.has_reader <- false ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    result","counters":[]},{"line":"","counters":[]},{"line":"  let read t = enforce_single_reader t (Pipe.read t.reader)","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"","counters":[]},{"line":"  let read' t = enforce_single_reader t (Pipe.read' t.reader)","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"","counters":[]},{"line":"  let fold reader ~init ~f =","counters":[]},{"line":"    enforce_single_reader reader","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (let rec go b =","counters":[]},{"line":"         match%bind Pipe.read reader.reader with","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"         | `Eof ->","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"             return b","counters":[]},{"line":"         | `Ok a ->","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"             (* The async scheduler could yield here *)","counters":[]},{"line":"             let%bind b' = f b a in","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"             go b'","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"       in","counters":[]},{"line":"       go init )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"  let fold_until reader ~init ~f =","counters":[]},{"line":"    enforce_single_reader reader","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (let rec go b =","counters":[]},{"line":"         match%bind Pipe.read reader.reader with","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"         | `Eof ->","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"             return (`Eof b)","counters":[]},{"line":"         | `Ok a -> (","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"             (* The async scheduler could yield here *)","counters":[]},{"line":"             match%bind f b a with","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"             | `Stop x ->","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                 return (`Terminated x)","counters":[]},{"line":"             | `Continue b' ->","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                 go b' )","counters":[]},{"line":"       in","counters":[]},{"line":"       go init )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"  let fold_without_pushback ?consumer reader ~init ~f =","counters":[]},{"line":"    Pipe.fold_without_pushback ?consumer reader.reader ~init ~f","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let iter reader ~f = fold reader ~init:() ~f:(fun () -> f)","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"","counters":[]},{"line":"  let iter_without_pushback ?consumer ?continue_on_error reader ~f =","counters":[]},{"line":"    Pipe.iter_without_pushback reader.reader ?consumer ?continue_on_error ~f","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let iter' reader ~f = Pipe.iter' reader.reader ~f","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"","counters":[]},{"line":"  let map reader ~f =","counters":[]},{"line":"    assert_not_read reader ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    reader.has_reader <- true ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let strict_reader =","counters":[]},{"line":"      wrap_reader ?name:reader.name (Pipe.map reader.reader ~f)","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"    in","counters":[]},{"line":"    reader.downstreams <- [ strict_reader ] ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    strict_reader","counters":[]},{"line":"","counters":[]},{"line":"  let filter_map reader ~f =","counters":[]},{"line":"    assert_not_read reader ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    reader.has_reader <- true ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let strict_reader =","counters":[]},{"line":"      wrap_reader ?name:reader.name (Pipe.filter_map reader.reader ~f)","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"    in","counters":[]},{"line":"    reader.downstreams <- [ strict_reader ] ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    strict_reader","counters":[]},{"line":"","counters":[]},{"line":"  let clear t = Pipe.clear t.reader","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"","counters":[]},{"line":"  let is_closed reader = Pipe.is_closed reader.reader","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"  module Merge = struct","counters":[]},{"line":"    let iter readers ~f =","counters":[]},{"line":"      let not_empty r = not @@ Pipe.is_empty r.reader in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"      let rec read_deferred readers =","counters":[]},{"line":"        let%bind ready_reader =","counters":[]},{"line":"          match List.find readers ~f:not_empty with","counters":[]},{"line":"          | Some reader ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Deferred.return (Some reader)","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let%map () =","counters":[]},{"line":"                Deferred.choose","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                  (List.map readers ~f:(fun r ->","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                       Deferred.choice (Pipe.values_available r.reader)","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"                         (fun _ -> ()) ) )","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"              in","counters":[]},{"line":"              List.find readers ~f:not_empty","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"        in","counters":[]},{"line":"        match ready_reader with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | Some reader -> (","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            match Pipe.read_now reader.reader with","counters":[]},{"line":"            | `Nothing_available ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                failwith \"impossible\"","counters":[]},{"line":"            | `Eof ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Deferred.unit","counters":[]},{"line":"            | `Ok value ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Deferred.bind (f value) ~f:(fun () -> read_deferred readers) )","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"        | None -> (","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            match List.filter readers ~f:(fun r -> not @@ is_closed r) with","counters":[{"col_start":51,"col_end":51,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"            | [] ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Deferred.unit","counters":[]},{"line":"            | open_readers ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                read_deferred open_readers )","counters":[]},{"line":"      in","counters":[]},{"line":"      List.iter readers ~f:assert_not_read ;","counters":[]},{"line":"      read_deferred readers","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let iter_sync readers ~f = iter readers ~f:(fun x -> f x ; Deferred.unit)","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":57,"col_end":57,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Fork = struct","counters":[]},{"line":"    let n reader count =","counters":[]},{"line":"      let pipes = List.init count ~f:(fun _ -> Pipe.create ()) in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"      let readers, writers = List.unzip pipes in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      (* This one place we _do_ want iter with pushback which we want to trigger","counters":[]},{"line":"       * when all reads have pushed back downstream","counters":[]},{"line":"       *","counters":[]},{"line":"       * Since future reads will resolve via the iter_without_pushback, we","counters":[]},{"line":"       * should still get the behavior we want. *)","counters":[]},{"line":"      don't_wait_for","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (Pipe.iter reader.reader ~f:(fun x ->","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"             Deferred.List.iter writers ~f:(fun writer ->","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"                 if not (Pipe.is_closed writer) then Pipe.write writer x","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"                 else return () ) ) ) ;","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"      don't_wait_for","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (let%map () = Deferred.List.iter readers ~f:Pipe.closed in","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"         Pipe.close_read reader.reader ) ;","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"      let strict_readers =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        List.map readers ~f:(wrap_reader ?name:reader.name)","counters":[]},{"line":"      in","counters":[]},{"line":"      reader.downstreams <- downstreams_from_list strict_readers ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"      strict_readers","counters":[]},{"line":"","counters":[]},{"line":"    let two reader =","counters":[]},{"line":"      match n reader 2 with [ a; b ] -> (a, b) | _ -> failwith \"unexpected\"","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"","counters":[]},{"line":"    let three reader =","counters":[]},{"line":"      match n reader 3 with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | [ a; b; c ] ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (a, b, c)","counters":[]},{"line":"      | _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          failwith \"unexpected\"","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let rec close_downstreams = function","counters":[]},{"line":"    | [] ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ()","counters":[]},{"line":"    (* The use of close_read is justified, because close_read would do","counters":[]},{"line":"     * everything close does, and in addition:","counters":[]},{"line":"     * 1. all pending flushes become determined with `Reader_closed.","counters":[]},{"line":"     * 2. the pipe buffer is cleared.","counters":[]},{"line":"     * 3. all subsequent reads will get `Eof. *)","counters":[]},{"line":"    | r :: rs ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Pipe.close_read r.reader ; close_downstreams rs","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Writer = struct","counters":[]},{"line":"  type ('t, 'type_, 'write_return) t =","counters":[]},{"line":"    { type_ : ('t, 'type_, 'write_return) type_","counters":[]},{"line":"    ; strict_reader : 't Reader0.t","counters":[]},{"line":"    ; writer : 't Pipe.Writer.t","counters":[]},{"line":"    ; warn_on_drop : bool","counters":[]},{"line":"    ; name : string option","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  (* TODO: See #1281 *)","counters":[]},{"line":"  let to_linear_pipe { writer = pipe; _ } = pipe","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"  let handle_buffered_write :","counters":[]},{"line":"      type type_ return.","counters":[]},{"line":"         ('t, type_, return) t","counters":[]},{"line":"      -> 't","counters":[]},{"line":"      -> capacity:int","counters":[]},{"line":"      -> on_overflow:(unit -> return)","counters":[]},{"line":"      -> normal_return:return","counters":[]},{"line":"      -> return =","counters":[]},{"line":"   fun t data ~capacity ~on_overflow ~normal_return ->","counters":[]},{"line":"    if Pipe.length t.strict_reader.reader > capacity then on_overflow ()","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"    else (","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"      Pipe.write_without_pushback t.writer data ;","counters":[]},{"line":"      normal_return )","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"  let write : type type_ return. ('t, type_, return) t -> 't -> return =","counters":[]},{"line":"   fun writer data ->","counters":[]},{"line":"    ( if Pipe.is_closed writer.writer then","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let logger = Logger.create () in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      [%log warn] \"writing to closed pipe $name\"","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":16,"col_end":16,"count":0}]},{"line":"        ~metadata:","counters":[]},{"line":"          [ ( \"name\"","counters":[]},{"line":"            , `String","counters":[]},{"line":"                (Sexplib.Sexp.to_string ([%sexp_of: string option] writer.name))","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"            )","counters":[]},{"line":"          ] ) ;","counters":[]},{"line":"    match writer.type_ with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Synchronous ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Pipe.write writer.writer data","counters":[]},{"line":"    | Buffered (`Capacity capacity, `Overflow Crash) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        handle_buffered_write writer data ~capacity","counters":[]},{"line":"          ~on_overflow:(fun () -> raise (Overflow (value_or_empty writer.name)))","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"          ~normal_return:()","counters":[]},{"line":"    | Buffered (`Capacity capacity, `Overflow (Drop_head f)) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        handle_buffered_write writer data ~capacity","counters":[]},{"line":"          ~on_overflow:(fun () ->","counters":[]},{"line":"            let logger = Logger.create () in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let my_name = Option.value writer.name ~default:\"<unnamed>\" in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            if writer.warn_on_drop then","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              [%log warn]","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"                ~metadata:[ (\"pipe_name\", `String my_name) ]","counters":[]},{"line":"                \"Dropping message on pipe $pipe_name\" ;","counters":[]},{"line":"            ( match Pipe.read_now writer.strict_reader.reader with","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            | `Ok head ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                f head","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"            | _ ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                () ) ;","counters":[]},{"line":"            Pipe.write_without_pushback writer.writer data )","counters":[]},{"line":"          ~normal_return:()","counters":[]},{"line":"    | Buffered (`Capacity capacity, `Overflow (Call f)) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        handle_buffered_write writer data ~capacity","counters":[]},{"line":"          ~on_overflow:(fun () -> Some (f data))","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"          ~normal_return:None","counters":[]},{"line":"","counters":[]},{"line":"  let close { strict_reader; writer; _ } =","counters":[]},{"line":"    Pipe.close writer ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Reader0.close_downstreams strict_reader.downstreams","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let kill { strict_reader; writer; _ } =","counters":[]},{"line":"    Pipe.clear strict_reader.reader ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Pipe.close writer ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Reader0.close_downstreams strict_reader.downstreams","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let is_closed { writer; _ } = Pipe.is_closed writer","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"","counters":[]},{"line":"  let pipe_name : type type_ return. ('t, type_, return) t -> string option =","counters":[]},{"line":"   fun writer -> writer.name","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let create ?name ?(warn_on_drop = true) type_ =","counters":[{"col_start":34,"col_end":34,"count":1}]},{"line":"  let reader, writer = Pipe.create () in","counters":[{"col_start":2,"col_end":2,"count":1}]},{"line":"  let strict_reader =","counters":[{"col_start":2,"col_end":2,"count":1}]},{"line":"    Reader0.{ reader; has_reader = false; downstreams = []; name }","counters":[]},{"line":"  in","counters":[]},{"line":"  let strict_writer =","counters":[]},{"line":"    Writer.{ type_; strict_reader; warn_on_drop; writer; name }","counters":[]},{"line":"  in","counters":[]},{"line":"  (strict_reader, strict_writer)","counters":[]},{"line":"","counters":[]},{"line":"let transfer reader Writer.{ strict_reader; writer; _ } ~f =","counters":[]},{"line":"  Reader0.(reader.downstreams <- [ strict_reader ]) ;","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  Reader0.enforce_single_reader reader (Pipe.transfer reader.reader writer ~f)","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"","counters":[]},{"line":"let rec transfer_while_writer_alive reader writer ~f =","counters":[]},{"line":"  if Pipe.is_closed writer.Writer.writer then Deferred.unit","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"  else","counters":[]},{"line":"    match%bind Pipe.read reader.Reader0.reader with","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"    | `Ok x ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let%bind () = Pipe.write_if_open writer.Writer.writer (f x) in","counters":[{"col_start":39,"col_end":39,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"        transfer_while_writer_alive reader writer ~f","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    | `Eof ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Pipe.close_read writer.Writer.strict_reader.reader ;","counters":[]},{"line":"        Deferred.unit","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"module Reader = struct","counters":[]},{"line":"  include Reader0","counters":[]},{"line":"","counters":[]},{"line":"  let partition_map3 reader ~f =","counters":[]},{"line":"    let (reader_a, writer_a), (reader_b, writer_b), (reader_c, writer_c) =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (create Synchronous, create Synchronous, create Synchronous)","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"    in","counters":[]},{"line":"    don't_wait_for","counters":[]},{"line":"      (Reader0.iter reader ~f:(fun x ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"           match f x with","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"           | `Fst x ->","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"               Writer.write writer_a x","counters":[]},{"line":"           | `Snd x ->","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"               Writer.write writer_b x","counters":[]},{"line":"           | `Trd x ->","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"               Writer.write writer_c x ) ) ;","counters":[]},{"line":"    don't_wait_for","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (let%map () = Pipe.closed reader_a.reader","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"       and () = Pipe.closed reader_b.reader","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"       and () = Pipe.closed reader_c.reader in","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"       Pipe.close_read reader.reader ) ;","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"    reader.downstreams <- [ reader_a; reader_b; reader_c ] ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    (reader_a, reader_b, reader_c)","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let%test_module \"Strict_pipe.Reader.Merge\" =","counters":[]},{"line":"  ( module struct","counters":[]},{"line":"    let%test_unit \"'iter' would filter out the closed pipes\" =","counters":[]},{"line":"      Run_in_thread.block_on_async_exn (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          let reader1, writer1 =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            create (Buffered (`Capacity 10, `Overflow (Drop_head ignore)))","counters":[]},{"line":"          in","counters":[]},{"line":"          let reader2, writer2 =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            create (Buffered (`Capacity 10, `Overflow (Drop_head ignore)))","counters":[]},{"line":"          in","counters":[]},{"line":"          Reader.Merge.iter [ reader1; reader2 ] ~f:(fun _ -> Deferred.unit)","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"          |> don't_wait_for ;","counters":[]},{"line":"          Writer.write writer1 1 ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          Writer.write writer2 2 ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          Writer.close writer1 ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let%map () = after (Time_ns.Span.of_ms 5.) in","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"          Writer.write writer2 3 ; () )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"  end )","counters":[]},{"line":"","counters":[]},{"line":"let%test_module \"Strict_pipe.close\" =","counters":[]},{"line":"  ( module struct","counters":[]},{"line":"    let%test_unit \"'close' would close a writer\" =","counters":[]},{"line":"      let _, writer = create Synchronous in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      assert (not (Writer.is_closed writer)) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"      Writer.close writer ;","counters":[]},{"line":"      assert (Writer.is_closed writer)","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"'close' would close a writer\" =","counters":[]},{"line":"      let _, writer = create (Buffered (`Capacity 64, `Overflow Crash)) in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      assert (not (Writer.is_closed writer)) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"      Writer.close writer ;","counters":[]},{"line":"      assert (Writer.is_closed writer)","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"'close' would close the downstream pipes linked by 'map'\" =","counters":[]},{"line":"      let input_reader, input_writer = create Synchronous in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      assert (not (Writer.is_closed input_writer)) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"      let output_reader = Reader.map ~f:Fn.id input_reader in","counters":[]},{"line":"      assert (not (Reader.is_closed output_reader)) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"      Writer.close input_writer ;","counters":[]},{"line":"      assert (Writer.is_closed input_writer) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"      assert (Reader.is_closed output_reader)","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"'close' would close the downstream pipes linked by \\","counters":[]},{"line":"                   'filter_map'\" =","counters":[]},{"line":"      let input_reader, input_writer = create Synchronous in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      assert (not (Writer.is_closed input_writer)) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"      let output_reader =","counters":[]},{"line":"        Reader.filter_map ~f:(Fn.const (Some 1)) input_reader","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"      in","counters":[]},{"line":"      assert (not (Reader.is_closed output_reader)) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"      Writer.close input_writer ;","counters":[]},{"line":"      assert (Writer.is_closed input_writer) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"      assert (Reader.is_closed output_reader)","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"'close' would close the downstream pipes linked by 'Fork'\" =","counters":[]},{"line":"      let input_reader, input_writer = create Synchronous in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      assert (not (Writer.is_closed input_writer)) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"      let output_reader1, output_reader2 = Reader.Fork.two input_reader in","counters":[]},{"line":"      assert (not (Reader.is_closed output_reader1)) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"      assert (not (Reader.is_closed output_reader2)) ;","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"      Writer.close input_writer ;","counters":[]},{"line":"      assert (Writer.is_closed input_writer) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"      assert (Reader.is_closed output_reader1) ;","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"      assert (Reader.is_closed output_reader2)","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"'close' would close the downstream pipes linked by \\","counters":[]},{"line":"                   'partition_map3'\" =","counters":[]},{"line":"      let input_reader, input_writer = create Synchronous in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      assert (not (Writer.is_closed input_writer)) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"      let output_reader1, output_reader2, output_reader3 =","counters":[]},{"line":"        Reader.partition_map3 input_reader ~f:(fun _ -> `Fst 1)","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"      in","counters":[]},{"line":"      assert (not (Reader.is_closed output_reader1)) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"      assert (not (Reader.is_closed output_reader2)) ;","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"      assert (not (Reader.is_closed output_reader3)) ;","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"      Writer.close input_writer ;","counters":[]},{"line":"      assert (Writer.is_closed input_writer) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"      assert (Reader.is_closed output_reader1) ;","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"      assert (Reader.is_closed output_reader2) ;","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"      assert (Reader.is_closed output_reader3)","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"'close' would close the downstream pipes linked by \\","counters":[]},{"line":"                   'transfer'\" =","counters":[]},{"line":"      let input_reader, input_writer = create Synchronous","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"      and _, output_writer = create Synchronous in","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"      assert (not (Writer.is_closed input_writer)) ;","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"      assert (not (Writer.is_closed output_writer)) ;","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"      let (_ : unit Deferred.t) =","counters":[]},{"line":"        transfer input_reader output_writer ~f:Fn.id","counters":[]},{"line":"      in","counters":[]},{"line":"      Writer.close input_writer ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      assert (Writer.is_closed input_writer) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"      assert (Writer.is_closed output_writer)","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"  end )","counters":[{"col_start":6,"col_end":6,"count":2}]}]}