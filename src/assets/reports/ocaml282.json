{"filename":"src/lib/random_oracle_input/random_oracle_input.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"module Chunked = struct","counters":[]},{"line":"  (** The input for a random oracle, formed of full field elements and 'chunks'","counters":[]},{"line":"      of fields that can be combined together into one or more field elements.","counters":[]},{"line":"","counters":[]},{"line":"      The chunks are represented as [(field, length)], where","counters":[]},{"line":"      [0 <= field < 2^length]. This allows us to efficiently combine values in","counters":[]},{"line":"      a known range. For example,","counters":[]},{"line":"{[","counters":[]},{"line":"    { field_elements= [||]; packeds= [|(x, 64); (y, 32); (z, 16)|] }","counters":[]},{"line":"]}","counters":[]},{"line":"      results in the chunks being combined as [x * 2^(32+16) + y * 2^(64) + z].","counters":[]},{"line":"      When the chunks do not fit within a single field element, they are","counters":[]},{"line":"      greedily concatenated to form field elements, from left to right.","counters":[]},{"line":"      This packing is performed by the [pack_to_fields] helper function.","counters":[]},{"line":"  *)","counters":[]},{"line":"  type 'field t =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    { field_elements : 'field array; packeds : ('field * int) array }","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":43,"col_end":43,"count":0},{"col_start":48,"col_end":48,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"  [@@deriving sexp, compare]","counters":[]},{"line":"","counters":[]},{"line":"  let append (t1 : _ t) (t2 : _ t) =","counters":[]},{"line":"    { field_elements = Array.append t1.field_elements t2.field_elements","counters":[{"col_start":4,"col_end":4,"count":3178},{"col_start":34,"col_end":34,"count":3178}]},{"line":"    ; packeds = Array.append t1.packeds t2.packeds","counters":[{"col_start":27,"col_end":27,"count":3178}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let field_elements (a : 'f array) : 'f t =","counters":[]},{"line":"    { field_elements = a; packeds = [||] }","counters":[{"col_start":4,"col_end":4,"count":435}]},{"line":"","counters":[]},{"line":"  let field x : _ t = field_elements [| x |]","counters":[{"col_start":22,"col_end":22,"count":429}]},{"line":"","counters":[]},{"line":"  (** An input [[|(x_1, l_1); (x_2, l_2); ...|]] includes the values","counters":[]},{"line":"      [[|x_1; x_2; ...|]] in the input, assuming that `0 <= x_1 < 2^l_1`,","counters":[]},{"line":"      `0 <= x_2 < 2^l_2`, etc. so that multiple [x_i]s can be combined into a","counters":[]},{"line":"      single field element when the sum of their [l_i]s are less than the size","counters":[]},{"line":"      of the field modulus (in bits).","counters":[]},{"line":"  *)","counters":[]},{"line":"  let packeds a = { field_elements = [||]; packeds = a }","counters":[{"col_start":18,"col_end":18,"count":2836}]},{"line":"","counters":[]},{"line":"  (** [packed x = packeds [| x |]] *)","counters":[]},{"line":"  let packed xn : _ t = packeds [| xn |]","counters":[{"col_start":24,"col_end":24,"count":2802}]},{"line":"","counters":[]},{"line":"  module type Field_intf = sig","counters":[]},{"line":"    type t","counters":[]},{"line":"","counters":[]},{"line":"    val size_in_bits : int","counters":[]},{"line":"","counters":[]},{"line":"    val zero : t","counters":[]},{"line":"","counters":[]},{"line":"    val ( + ) : t -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"    val ( * ) : t -> t -> t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  (** Convert the input into a series of field elements, by concatenating","counters":[]},{"line":"      any chunks of input that fit into a single field element.","counters":[]},{"line":"      The concatenation is greedy, operating from left to right.","counters":[]},{"line":"  *)","counters":[]},{"line":"  let pack_to_fields (type t) (module F : Field_intf with type t = t)","counters":[]},{"line":"      ~(pow2 : int -> t) { field_elements; packeds } =","counters":[]},{"line":"    let shift_left acc n = F.( * ) acc (pow2 n) in","counters":[{"col_start":4,"col_end":4,"count":113},{"col_start":27,"col_end":27,"count":4157},{"col_start":43,"col_end":43,"count":4157}]},{"line":"    let open F in","counters":[]},{"line":"    let packed_bits =","counters":[]},{"line":"      let xs, acc, acc_n =","counters":[]},{"line":"        Array.fold packeds ~init:([], zero, 0)","counters":[]},{"line":"          ~f:(fun (xs, acc, acc_n) (x, n) ->","counters":[]},{"line":"            let n' = Int.(n + acc_n) in","counters":[{"col_start":12,"col_end":12,"count":4199}]},{"line":"            if Int.(n' < size_in_bits) then (xs, shift_left acc n + x, n')","counters":[{"col_start":44,"col_end":44,"count":4157},{"col_start":58,"col_end":58,"count":4157}]},{"line":"            else (acc :: xs, x, n) )","counters":[{"col_start":17,"col_end":17,"count":42}]},{"line":"      in","counters":[]},{"line":"      (* if acc_n = 0, packeds was empty (or acc holds 0 bits) and we don't want to append 0 *)","counters":[]},{"line":"      let xs = if acc_n > 0 then acc :: xs else xs in","counters":[{"col_start":6,"col_end":6,"count":113},{"col_start":33,"col_end":33,"count":14},{"col_start":48,"col_end":48,"count":99}]},{"line":"      Array.of_list_rev xs","counters":[{"col_start":22,"col_end":22,"count":113}]},{"line":"    in","counters":[]},{"line":"    Array.append field_elements packed_bits","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Legacy = struct","counters":[]},{"line":"  type ('field, 'bool) t =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    { field_elements : 'field array; bitstrings : 'bool list array }","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":46,"col_end":46,"count":0},{"col_start":50,"col_end":50,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"  [@@deriving sexp, compare]","counters":[]},{"line":"","counters":[]},{"line":"  let append t1 t2 =","counters":[]},{"line":"    { field_elements = Array.append t1.field_elements t2.field_elements","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"    ; bitstrings = Array.append t1.bitstrings t2.bitstrings","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let field_elements x = { field_elements = x; bitstrings = [||] }","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"  let field x = { field_elements = [| x |]; bitstrings = [||] }","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"","counters":[]},{"line":"  let bitstring x = { field_elements = [||]; bitstrings = [| x |] }","counters":[{"col_start":20,"col_end":20,"count":1}]},{"line":"","counters":[]},{"line":"  let bitstrings x = { field_elements = [||]; bitstrings = x }","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"","counters":[]},{"line":"  let pack_bits ~max_size ~pack { field_elements = _; bitstrings } =","counters":[]},{"line":"    let rec pack_full_fields rev_fields bits length =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      if length >= max_size then","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let field_bits, bits = List.split_n bits max_size in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        pack_full_fields (pack field_bits :: rev_fields) bits (length - max_size)","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"      else (rev_fields, bits, length)","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"    in","counters":[]},{"line":"    let packed_field_elements, remaining_bits, remaining_length =","counters":[]},{"line":"      Array.fold bitstrings ~init:([], [], 0)","counters":[]},{"line":"        ~f:(fun (acc, bits, n) bitstring ->","counters":[]},{"line":"          let n = n + List.length bitstring in","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"          let bits = bits @ bitstring in","counters":[]},{"line":"          let acc, bits, n = pack_full_fields acc bits n in","counters":[]},{"line":"          (acc, bits, n) )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    in","counters":[]},{"line":"    if remaining_length = 0 then packed_field_elements","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"    else pack remaining_bits :: packed_field_elements","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":12,"col_end":12,"count":0}]},{"line":"","counters":[]},{"line":"  let pack_to_fields ~size_in_bits ~pack { field_elements; bitstrings } =","counters":[]},{"line":"    let max_size = size_in_bits - 1 in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let packed_bits =","counters":[]},{"line":"      pack_bits ~max_size ~pack { field_elements; bitstrings }","counters":[]},{"line":"    in","counters":[]},{"line":"    Array.append field_elements (Array.of_list_rev packed_bits)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"","counters":[]},{"line":"  let to_bits ~unpack { field_elements; bitstrings } =","counters":[]},{"line":"    let field_bits = Array.map ~f:unpack field_elements in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    List.concat @@ Array.to_list @@ Array.append field_bits bitstrings","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"","counters":[]},{"line":"  module Coding = struct","counters":[]},{"line":"    (** See https://github.com/CodaProtocol/coda/blob/develop/rfcs/0038-rosetta-construction-api.md for details on schema *)","counters":[]},{"line":"","counters":[]},{"line":"    (** Serialize a random oracle input with 32byte fields into bytes according to the RFC0038 specification *)","counters":[]},{"line":"    let serialize ~string_of_field ~to_bool ~of_bool t =","counters":[]},{"line":"      let len_to_string x =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        String.of_char_list","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Char.","counters":[]},{"line":"            [ of_int_exn @@ ((x lsr 24) land 0xff)","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"            ; of_int_exn @@ ((x lsr 16) land 0xff)","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"            ; of_int_exn @@ ((x lsr 8) land 0xff)","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"            ; of_int_exn @@ (x land 0xff)","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"            ]","counters":[]},{"line":"      in","counters":[]},{"line":"      let len1 = len_to_string @@ Array.length t.field_elements in","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"      let fields =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (* We only support 32byte fields *)","counters":[]},{"line":"        let () =","counters":[]},{"line":"          if Array.length t.field_elements > 0 then","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"            assert (String.length (string_of_field t.field_elements.(0)) = 32)","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"          else ()","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"        in","counters":[]},{"line":"        Array.map t.field_elements ~f:string_of_field |> String.concat_array","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":75,"col_end":75,"count":0}]},{"line":"      in","counters":[]},{"line":"      let len2 =","counters":[]},{"line":"        len_to_string","counters":[]},{"line":"        @@ Array.sum (module Int) t.bitstrings ~f:(fun x -> List.length x)","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"      in","counters":[]},{"line":"      let packed =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        pack_bits t ~max_size:8 ~pack:(fun bs ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"            let rec go i acc = function","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              | [] ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  acc","counters":[]},{"line":"              | b :: bs ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  go (i + 1) ((acc * 2) + if to_bool b then 1 else 0) bs","counters":[{"col_start":60,"col_end":60,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"            in","counters":[]},{"line":"            let pad =","counters":[]},{"line":"              List.init (8 - List.length bs) ~f:(Fn.const (of_bool false))","counters":[{"col_start":39,"col_end":39,"count":0},{"col_start":56,"col_end":56,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"            in","counters":[]},{"line":"            let combined = bs @ pad in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            assert (List.length combined = 8) ;","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"            go 0 0 combined )","counters":[]},{"line":"        |> List.map ~f:Char.of_int_exn","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"        |> List.rev |> String.of_char_list","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"      in","counters":[]},{"line":"      len1 ^ fields ^ len2 ^ packed","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    module Parser = struct","counters":[]},{"line":"      (* TODO: Before using this too much; use a solid parser library instead or beef this one up with more debugging info *)","counters":[]},{"line":"","counters":[]},{"line":"      (* The parser is a function over this monad-fail *)","counters":[]},{"line":"      module M = Result","counters":[]},{"line":"","counters":[]},{"line":"      module T = struct","counters":[]},{"line":"        type ('a, 'e) t = char list -> ('a * char list, 'e) M.t","counters":[]},{"line":"","counters":[]},{"line":"        let return a cs = M.return (a, cs)","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"","counters":[]},{"line":"        let bind : ('a, 'e) t -> f:('a -> ('b, 'e) t) -> ('b, 'e) t =","counters":[]},{"line":"         fun t ~f cs ->","counters":[]},{"line":"          let open M.Let_syntax in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let%bind a, rest = t cs in","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"          f a rest","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"        let map = `Define_using_bind","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      include Monad.Make2 (T)","counters":[]},{"line":"","counters":[]},{"line":"      let run p cs =","counters":[]},{"line":"        p cs","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        |> M.bind ~f:(fun (a, cs') ->","counters":[]},{"line":"               match cs' with [] -> M.return a | _ -> M.fail `Expected_eof )","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"","counters":[]},{"line":"      let fail why _ = M.fail why","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"      let char c = function","counters":[]},{"line":"        | c' :: cs when Char.equal c c' ->","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"            M.return (c', cs)","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"        | c' :: _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            M.fail (`Unexpected_char c')","counters":[]},{"line":"        | [] ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            M.fail `Unexpected_eof","counters":[]},{"line":"","counters":[]},{"line":"      let u8 = function","counters":[]},{"line":"        | c :: cs ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            M.return (c, cs)","counters":[]},{"line":"        | [] ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            M.fail `Unexpected_eof","counters":[]},{"line":"","counters":[]},{"line":"      let u32 =","counters":[]},{"line":"        let open Let_syntax in","counters":[]},{"line":"        let open Char in","counters":[]},{"line":"        let%map a = u8 and b = u8 and c = u8 and d = u8 in","counters":[]},{"line":"        (to_int a lsl 24)","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":14,"col_end":14,"count":0}]},{"line":"        lor (to_int b lsl 16)","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"        lor (to_int c lsl 8)","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"        lor to_int d","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"","counters":[]},{"line":"      let eof = function [] -> M.return ((), []) | _ -> M.fail `Expected_eof","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"","counters":[]},{"line":"      let take n cs =","counters":[]},{"line":"        if List.length cs < n then M.fail `Unexpected_eof","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"        else M.return (List.split_n cs n)","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"","counters":[]},{"line":"      (** p zero or more times, never fails *)","counters":[]},{"line":"      let many p =","counters":[]},{"line":"        (fun cs ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let rec go xs acc =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            match p xs with","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            | Ok (a, xs) ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                go xs (a :: acc)","counters":[]},{"line":"            | Error _ ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (acc, xs)","counters":[]},{"line":"          in","counters":[]},{"line":"          M.return @@ go cs [] )","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"        |> map ~f:List.rev","counters":[]},{"line":"","counters":[]},{"line":"      let%test_unit \"many\" =","counters":[]},{"line":"        [%test_eq: (char list, [ `Expected_eof ]) Result.t]","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"          (run (many u8) [ 'a'; 'b'; 'c' ])","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"          (Result.return [ 'a'; 'b'; 'c' ])","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"      (** p exactly n times *)","counters":[]},{"line":"      let exactly n p =","counters":[]},{"line":"        (fun cs ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let rec go xs acc = function","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            | 0 ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                M.return (acc, xs)","counters":[]},{"line":"            | i ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                let open M.Let_syntax in","counters":[]},{"line":"                let%bind a, xs = p xs in","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"                go xs (a :: acc) (i - 1)","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"          in","counters":[]},{"line":"          go cs [] n )","counters":[]},{"line":"        |> map ~f:List.rev","counters":[]},{"line":"","counters":[]},{"line":"      let%test_unit \"exactly\" =","counters":[]},{"line":"        [%test_eq:","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (char list * char list, [ `Expected_eof | `Unexpected_eof ]) Result.t]","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"          ((exactly 3 u8) [ 'a'; 'b'; 'c'; 'd' ])","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"          (Result.return ([ 'a'; 'b'; 'c' ], [ 'd' ]))","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"      let return_res r cs = r |> Result.map ~f:(fun x -> (x, cs))","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    let bits_of_byte ~of_bool b =","counters":[]},{"line":"      let b = Char.to_int b in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let f x =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        of_bool","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ( match x with","counters":[]},{"line":"          | 0 ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              false","counters":[]},{"line":"          | 1 ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              true","counters":[]},{"line":"          | _ ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              failwith \"Unexpected boolean integer\" )","counters":[]},{"line":"      in","counters":[]},{"line":"      [ (b land (0x1 lsl 7)) lsr 7","counters":[]},{"line":"      ; (b land (0x1 lsl 6)) lsr 6","counters":[]},{"line":"      ; (b land (0x1 lsl 5)) lsr 5","counters":[]},{"line":"      ; (b land (0x1 lsl 4)) lsr 4","counters":[]},{"line":"      ; (b land (0x1 lsl 3)) lsr 3","counters":[]},{"line":"      ; (b land (0x1 lsl 2)) lsr 2","counters":[]},{"line":"      ; (b land (0x1 lsl 1)) lsr 1","counters":[]},{"line":"      ; b land 0x1","counters":[]},{"line":"      ]","counters":[]},{"line":"      |> List.map ~f","counters":[]},{"line":"","counters":[]},{"line":"    (** Deserialize bytes into a random oracle input with 32byte fields according to the RFC0038 specification *)","counters":[]},{"line":"    let deserialize ~field_of_string ~of_bool s =","counters":[]},{"line":"      let field =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let open Parser.Let_syntax in","counters":[]},{"line":"        let%bind u8x32 = Parser.take 32 in","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"        let s = String.of_char_list u8x32 in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Parser.return_res (field_of_string s)","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"      in","counters":[]},{"line":"      let parser =","counters":[]},{"line":"        let open Parser.Let_syntax in","counters":[]},{"line":"        let%bind len1 = Parser.u32 in","counters":[]},{"line":"        let%bind fields = Parser.exactly len1 field in","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"        let%bind len2 = Parser.u32 in","counters":[]},{"line":"        let%map bytes = Parser.(many u8) in","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"        let bits = List.concat_map ~f:(bits_of_byte ~of_bool) bytes in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let bitstring = List.take bits len2 in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        { field_elements = Array.of_list fields; bitstrings = [| bitstring |] }","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"      in","counters":[]},{"line":"      Parser.run parser s","counters":[]},{"line":"","counters":[]},{"line":"    (** String of field as bits *)","counters":[]},{"line":"    let string_of_field xs =","counters":[]},{"line":"      List.chunks_of xs ~length:8","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"      |> List.map ~f:(fun xs ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"             let rec go i acc = function","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"               | [] ->","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                   acc","counters":[]},{"line":"               | b :: bs ->","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                   go (i + 1) ((acc * 2) + if b then 1 else 0) bs","counters":[{"col_start":53,"col_end":53,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"             in","counters":[]},{"line":"             let pad = List.init (8 - List.length xs) ~f:(Fn.const false) in","counters":[{"col_start":48,"col_end":48,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"             let combined = xs @ pad in","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"             assert (List.length combined = 8) ;","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"             go 0 0 combined )","counters":[]},{"line":"      |> List.map ~f:Char.of_int_exn","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"      |> String.of_char_list","counters":[]},{"line":"","counters":[]},{"line":"    (** Field of string as bits *)","counters":[]},{"line":"    let field_of_string s ~size_in_bits =","counters":[]},{"line":"      List.concat_map (String.to_list s) ~f:(bits_of_byte ~of_bool:Fn.id)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"      |> Fn.flip List.take size_in_bits","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"      |> Result.return","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  (** Coding2 is an alternate binary coding setup where we pass two arrays of","counters":[]},{"line":" *  field elements instead of a single structure to simplify manipulation","counters":[]},{"line":" *  outside of the Mina construction API","counters":[]},{"line":" *","counters":[]},{"line":" * This is described as the second mechanism for coding Random_oracle_input in","counters":[]},{"line":" * RFC0038","counters":[]},{"line":" *","counters":[]},{"line":"*)","counters":[]},{"line":"  module Coding2 = struct","counters":[]},{"line":"    module Rendered = struct","counters":[]},{"line":"      (* as bytes, you must hex this later *)","counters":[]},{"line":"      type 'field t_ = { prefix : 'field array; suffix : 'field array }","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":48,"col_end":48,"count":0},{"col_start":57,"col_end":57,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"      [@@deriving yojson]","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"","counters":[]},{"line":"      type t = string t_ [@@deriving yojson]","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"","counters":[]},{"line":"      let map ~f { prefix; suffix } =","counters":[]},{"line":"        { prefix = Array.map ~f prefix; suffix = Array.map ~f suffix }","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    let string_of_field : bool list -> string = Coding.string_of_field","counters":[]},{"line":"","counters":[]},{"line":"    let field_of_string = Coding.field_of_string","counters":[]},{"line":"","counters":[]},{"line":"    let serialize' t ~pack =","counters":[]},{"line":"      { Rendered.prefix = t.field_elements","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      ; suffix = pack_bits ~max_size:254 ~pack t |> Array.of_list_rev","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    let serialize t ~string_of_field ~pack =","counters":[]},{"line":"      let () =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        if Array.length t.field_elements > 0 then","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"          assert (String.length (string_of_field t.field_elements.(0)) = 32)","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"        else ()","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"      in","counters":[]},{"line":"      serialize' t ~pack |> Rendered.map ~f:string_of_field","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let%test_module \"random_oracle input\" =","counters":[]},{"line":"    ( module struct","counters":[]},{"line":"      let gen_field ~size_in_bits =","counters":[]},{"line":"        let open Quickcheck.Generator in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        list_with_length size_in_bits bool","counters":[]},{"line":"","counters":[]},{"line":"      let gen_input ?size_in_bits () =","counters":[]},{"line":"        let open Quickcheck.Generator in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let open Let_syntax in","counters":[]},{"line":"        let%bind size_in_bits =","counters":[]},{"line":"          size_in_bits |> Option.map ~f:return","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"          |> Option.value ~default:(Int.gen_incl 2 3000)","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"        in","counters":[]},{"line":"        let%bind field_elements =","counters":[]},{"line":"          (* Treat a field as a list of bools of length [size_in_bits]. *)","counters":[]},{"line":"          list (gen_field ~size_in_bits)","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"        in","counters":[]},{"line":"        let%map bitstrings = list (list bool) in","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"        ( size_in_bits","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        , { field_elements = Array.of_list field_elements","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"          ; bitstrings = Array.of_list bitstrings","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"          } )","counters":[]},{"line":"","counters":[]},{"line":"      let%test_unit \"coding2 equiv to hash directly\" =","counters":[]},{"line":"        let size_in_bits = 255 in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let field = gen_field ~size_in_bits in","counters":[]},{"line":"        Quickcheck.test ~trials:300","counters":[]},{"line":"          Quickcheck.Generator.(","counters":[]},{"line":"            tuple2 (gen_input ~size_in_bits ()) (tuple2 field field))","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"          ~f:(fun ((_, input), (x, y)) ->","counters":[]},{"line":"            let middle = [| x; y |] in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let expected =","counters":[]},{"line":"              append input (field_elements middle)","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"              |> pack_to_fields ~size_in_bits ~pack:Fn.id","counters":[]},{"line":"            in","counters":[]},{"line":"            let { Coding2.Rendered.prefix; suffix } =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Coding2.serialize' input ~pack:Fn.id","counters":[]},{"line":"            in","counters":[]},{"line":"            let actual = Array.(concat [ prefix; middle; suffix ]) in","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"            [%test_eq: bool list array] expected actual )","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"","counters":[]},{"line":"      let%test_unit \"field/string partial isomorphism bitstrings\" =","counters":[]},{"line":"        Quickcheck.test ~trials:300","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Quickcheck.Generator.(list_with_length 255 bool)","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"          ~f:(fun input ->","counters":[]},{"line":"            let serialized = Coding.string_of_field input in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let deserialized =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Coding.field_of_string serialized ~size_in_bits:255","counters":[]},{"line":"            in","counters":[]},{"line":"            [%test_eq: (bool list, unit) Result.t] (input |> Result.return)","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":73,"col_end":73,"count":0}]},{"line":"              deserialized )","counters":[]},{"line":"","counters":[]},{"line":"      let%test_unit \"serialize/deserialize partial isomorphism 32byte fields\" =","counters":[]},{"line":"        let size_in_bits = 255 in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Quickcheck.test ~trials:3000 (gen_input ~size_in_bits ())","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"          ~f:(fun (_, input) ->","counters":[]},{"line":"            let serialized =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Coding.(","counters":[]},{"line":"                serialize ~string_of_field ~to_bool:Fn.id ~of_bool:Fn.id input)","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"            in","counters":[]},{"line":"            let deserialized =","counters":[]},{"line":"              Coding.(","counters":[]},{"line":"                deserialize","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                  (String.to_list serialized)","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                  ~field_of_string:(field_of_string ~size_in_bits)","counters":[]},{"line":"                  ~of_bool:Fn.id)","counters":[]},{"line":"            in","counters":[]},{"line":"            let normalized t =","counters":[]},{"line":"              { t with","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                bitstrings =","counters":[]},{"line":"                  ( t.bitstrings |> Array.to_list |> List.concat","counters":[{"col_start":48,"col_end":48,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"                  |> fun xs -> [| xs |] )","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"              }","counters":[]},{"line":"            in","counters":[]},{"line":"            assert (","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"              Array.for_all input.field_elements ~f:(fun el ->","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                  List.length el = size_in_bits ) ) ;","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"            Result.iter deserialized ~f:(fun x ->","counters":[]},{"line":"                assert (","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                  Array.for_all x.field_elements ~f:(fun el ->","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                      List.length el = size_in_bits ) ) ) ;","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"            [%test_eq:","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              ( (bool list, bool) t","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"              , [ `Expected_eof | `Unexpected_eof ] )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"              Result.t]","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              (normalized input |> Result.return)","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"              (deserialized |> Result.map ~f:normalized) )","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"      let%test_unit \"data is preserved by to_bits\" =","counters":[]},{"line":"        Quickcheck.test ~trials:300 (gen_input ())","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"          ~f:(fun (size_in_bits, input) ->","counters":[]},{"line":"            let bits = to_bits ~unpack:Fn.id input in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let bools_equal = [%equal: bool list] in","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"            (* Fields are accumulated at the front, check them first. *)","counters":[]},{"line":"            let bitstring_bits =","counters":[]},{"line":"              Array.fold ~init:bits input.field_elements ~f:(fun bits field ->","counters":[]},{"line":"                  (* The next chunk of [size_in_bits] bits is for the field","counters":[]},{"line":"                           element.","counters":[]},{"line":"                  *)","counters":[]},{"line":"                  let field_bits, rest = List.split_n bits size_in_bits in","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  assert (bools_equal field_bits field) ;","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"                  rest )","counters":[]},{"line":"            in","counters":[]},{"line":"            (* Bits come after. *)","counters":[]},{"line":"            let remaining_bits =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Array.fold ~init:bitstring_bits input.bitstrings","counters":[]},{"line":"                ~f:(fun bits bitstring ->","counters":[]},{"line":"                  (* The next bits match the bitstring. *)","counters":[]},{"line":"                  let bitstring_bits, rest =","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    List.split_n bits (List.length bitstring)","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"                  in","counters":[]},{"line":"                  assert (bools_equal bitstring_bits bitstring) ;","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"                  rest )","counters":[]},{"line":"            in","counters":[]},{"line":"            (* All bits should have been consumed. *)","counters":[]},{"line":"            assert (List.is_empty remaining_bits) )","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"","counters":[]},{"line":"      let%test_unit \"data is preserved by pack_to_fields\" =","counters":[]},{"line":"        Quickcheck.test ~trials:300 (gen_input ())","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"          ~f:(fun (size_in_bits, input) ->","counters":[]},{"line":"            let fields = pack_to_fields ~size_in_bits ~pack:Fn.id input in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            (* Fields are accumulated at the front, check them first. *)","counters":[]},{"line":"            let fields = Array.to_list fields in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let bitstring_fields =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Array.fold ~init:fields input.field_elements","counters":[]},{"line":"                ~f:(fun fields input_field ->","counters":[]},{"line":"                  (* The next field element should be the literal field element","counters":[]},{"line":"                                     passed in.","counters":[]},{"line":"                  *)","counters":[]},{"line":"                  match fields with","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  | [] ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      failwith \"Too few field elements\"","counters":[]},{"line":"                  | field :: rest ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      assert ([%equal: bool list] field input_field) ;","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"                      rest )","counters":[]},{"line":"            in","counters":[]},{"line":"            (* Check that the remaining fields have the correct size. *)","counters":[]},{"line":"            let final_field_idx = List.length bitstring_fields - 1 in","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"            List.iteri bitstring_fields ~f:(fun i field_bits ->","counters":[]},{"line":"                if i < final_field_idx then","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  (* This field should be densely packed, but should contain","counters":[]},{"line":"                         fewer bits than the maximum field element to ensure that it","counters":[]},{"line":"                         doesn't overflow, so we expect [size_in_bits - 1] bits for","counters":[]},{"line":"                         maximum safe density.","counters":[]},{"line":"                  *)","counters":[]},{"line":"                  assert (List.length field_bits = size_in_bits - 1)","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"                else (","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                  (* This field will be comprised of the remaining bits, up to a","counters":[]},{"line":"                         maximum of [size_in_bits - 1]. It should not be empty.","counters":[]},{"line":"                  *)","counters":[]},{"line":"                  assert (not (List.is_empty field_bits)) ;","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"                  assert (List.length field_bits < size_in_bits) ) ) ;","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"            let rec go input_bitstrings packed_fields =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              match (input_bitstrings, packed_fields) with","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              | [], [] ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  (* We have consumed all bitstrings and fields in parallel, with","counters":[]},{"line":"                     no bits left over. Success.","counters":[]},{"line":"                  *)","counters":[]},{"line":"                  ()","counters":[]},{"line":"              | [] :: input_bitstrings, packed_fields","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"              | input_bitstrings, [] :: packed_fields ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  (* We have consumed the whole of an input bitstring or the whole","counters":[]},{"line":"                     of a packed field, move onto the next one.","counters":[]},{"line":"                  *)","counters":[]},{"line":"                  go input_bitstrings packed_fields","counters":[]},{"line":"              | ( (bi :: input_bitstring) :: input_bitstrings","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                , (bp :: packed_field) :: packed_fields ) ->","counters":[]},{"line":"                  (* Consume the next bit from the next input bitstring, and the","counters":[]},{"line":"                     next bit from the next packed field. They must match.","counters":[]},{"line":"                  *)","counters":[]},{"line":"                  assert (Bool.equal bi bp) ;","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"                  go","counters":[]},{"line":"                    (input_bitstring :: input_bitstrings)","counters":[]},{"line":"                    (packed_field :: packed_fields)","counters":[]},{"line":"              | [], _ ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  failwith \"Packed fields contain more bits than were provided\"","counters":[]},{"line":"              | _, [] ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  failwith","counters":[]},{"line":"                    \"There are input bits that were not present in the packed \\","counters":[]},{"line":"                     fields\"","counters":[]},{"line":"            in","counters":[]},{"line":"            (* Check that the bits match between the input bitstring and the","counters":[]},{"line":"                   remaining fields.","counters":[]},{"line":"            *)","counters":[]},{"line":"            go (Array.to_list input.bitstrings) bitstring_fields )","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"    end )","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}