{"filename":"src/lib/cli_lib/arg_type.ml","lines":[{"line":"open Core","counters":[]},{"line":"open Signature_lib","counters":[]},{"line":"","counters":[]},{"line":"let validate_int16 x =","counters":[]},{"line":"  let max_port = 1 lsl 16 in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  if 0 <= x && x < max_port then Ok x","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"  else Or_error.errorf !\"Port not between 0 and %d\" max_port","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"","counters":[]},{"line":"let int16 =","counters":[]},{"line":"  Command.Arg_type.map Command.Param.int","counters":[{"col_start":21,"col_end":21,"count":1}]},{"line":"    ~f:(Fn.compose Or_error.ok_exn validate_int16)","counters":[{"col_start":17,"col_end":17,"count":1}]},{"line":"","counters":[]},{"line":"let pubsub_topic_mode =","counters":[]},{"line":"  let open Gossip_net.Libp2p in","counters":[]},{"line":"  Command.Arg_type.create (fun s ->","counters":[{"col_start":24,"col_end":24,"count":1}]},{"line":"      match s with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | \"ro\" ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          RO","counters":[]},{"line":"      | \"rw\" ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          RW","counters":[]},{"line":"      | \"none\" ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          N","counters":[]},{"line":"      | _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          eprintf \"Invalid pubsub topic mode: %s\" s ;","counters":[]},{"line":"          exit 1 )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"let pubsub_topic_mode_to_string mode =","counters":[]},{"line":"  let open Gossip_net.Libp2p in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  match mode with RO -> \"ro\" | RW -> \"rw\" | N -> \"none\"","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"let public_key_compressed =","counters":[]},{"line":"  Command.Arg_type.create (fun s ->","counters":[{"col_start":24,"col_end":24,"count":1}]},{"line":"      let error_string e =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let random = Public_key.compress (Keypair.create ()).public_key in","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"        eprintf","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          \"Error parsing command line.  Run with -help for usage information.\\n\\n\\","counters":[]},{"line":"           Couldn't read public key\\n\\","counters":[]},{"line":"          \\ %s\\n\\","counters":[]},{"line":"          \\ - here's a sample one: %s\\n\"","counters":[]},{"line":"          (Error.to_string_hum e)","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"          (Public_key.Compressed.to_base58_check random) ;","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"        exit 1","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      in","counters":[]},{"line":"      try Public_key.of_base58_check_decompress_exn s","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"      with e -> error_string (Error.of_exn e) )","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"","counters":[]},{"line":"(* Hack to allow us to deprecate a value without needing to add an mli","counters":[]},{"line":" * just for this. We only want to have one \"kind\" of public key in the","counters":[]},{"line":" * public-facing interface if possible *)","counters":[]},{"line":"include (","counters":[]},{"line":"  struct","counters":[]},{"line":"    let public_key =","counters":[]},{"line":"      Command.Arg_type.map public_key_compressed ~f:(fun pk ->","counters":[{"col_start":25,"col_end":25,"count":1}]},{"line":"          match Public_key.decompress pk with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              failwith \"Invalid key\"","counters":[]},{"line":"          | Some pk' ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              pk' )","counters":[]},{"line":"  end :","counters":[]},{"line":"    sig","counters":[]},{"line":"      val public_key : Public_key.t Command.Arg_type.t","counters":[]},{"line":"        [@@deprecated \"Use public_key_compressed in commandline args\"]","counters":[]},{"line":"    end )","counters":[]},{"line":"","counters":[]},{"line":"let token_id =","counters":[]},{"line":"  Command.Arg_type.map ~f:Mina_base.Token_id.of_string Command.Param.string","counters":[{"col_start":21,"col_end":21,"count":1}]},{"line":"","counters":[]},{"line":"let receipt_chain_hash =","counters":[]},{"line":"  Command.Arg_type.map Command.Param.string","counters":[{"col_start":21,"col_end":21,"count":1}]},{"line":"    ~f:Mina_base.Receipt.Chain_hash.of_base58_check_exn","counters":[]},{"line":"","counters":[]},{"line":"let peer : Host_and_port.t Command.Arg_type.t =","counters":[]},{"line":"  Command.Arg_type.create (fun s -> Host_and_port.of_string s)","counters":[{"col_start":24,"col_end":24,"count":1},{"col_start":36,"col_end":36,"count":0}]},{"line":"","counters":[]},{"line":"let global_slot =","counters":[]},{"line":"  Command.Arg_type.map Command.Param.int ~f:Mina_numbers.Global_slot.of_int","counters":[{"col_start":21,"col_end":21,"count":1}]},{"line":"","counters":[]},{"line":"let txn_fee =","counters":[]},{"line":"  Command.Arg_type.map Command.Param.string ~f:Currency.Fee.of_formatted_string","counters":[{"col_start":21,"col_end":21,"count":1}]},{"line":"","counters":[]},{"line":"let txn_amount =","counters":[]},{"line":"  Command.Arg_type.map Command.Param.string","counters":[{"col_start":21,"col_end":21,"count":1}]},{"line":"    ~f:Currency.Amount.of_formatted_string","counters":[]},{"line":"","counters":[]},{"line":"let txn_nonce =","counters":[]},{"line":"  let open Mina_base in","counters":[]},{"line":"  Command.Arg_type.map Command.Param.string ~f:Account.Nonce.of_string","counters":[{"col_start":21,"col_end":21,"count":1}]},{"line":"","counters":[]},{"line":"let hd_index =","counters":[]},{"line":"  Command.Arg_type.map Command.Param.string ~f:Mina_numbers.Hd_index.of_string","counters":[{"col_start":21,"col_end":21,"count":1}]},{"line":"","counters":[]},{"line":"let ip_address =","counters":[]},{"line":"  Command.Arg_type.map Command.Param.string ~f:Unix.Inet_addr.of_string","counters":[{"col_start":21,"col_end":21,"count":1}]},{"line":"","counters":[]},{"line":"let cidr_mask = Command.Arg_type.map Command.Param.string ~f:Unix.Cidr.of_string","counters":[{"col_start":35,"col_end":35,"count":1}]},{"line":"","counters":[]},{"line":"let log_level =","counters":[]},{"line":"  Command.Arg_type.map Command.Param.string ~f:(fun log_level_str_with_case ->","counters":[{"col_start":21,"col_end":21,"count":1}]},{"line":"      let open Logger in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let log_level_str = String.lowercase log_level_str_with_case in","counters":[]},{"line":"      match Level.of_string log_level_str with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Error _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          eprintf \"Received unknown log-level %s. Expected one of: %s\\n\"","counters":[]},{"line":"            log_level_str","counters":[]},{"line":"            ( Level.all |> List.map ~f:Level.show","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"            |> List.map ~f:String.lowercase","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"            |> String.concat ~sep:\", \" ) ;","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"          exit 14","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"      | Ok ll ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ll )","counters":[]},{"line":"","counters":[]},{"line":"let user_command =","counters":[]},{"line":"  Command.Arg_type.create (fun s ->","counters":[{"col_start":24,"col_end":24,"count":1}]},{"line":"      match Mina_base.Signed_command.of_base64 s with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Ok s ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          s","counters":[]},{"line":"      | Error err ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Error.tag err ~tag:\"Couldn't decode transaction id\" |> Error.raise )","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"","counters":[]},{"line":"module Work_selection_method = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type t = Sequence | Random","counters":[{"col_start":6,"col_end":6,"count":2},{"col_start":11,"col_end":11,"count":2},{"col_start":15,"col_end":15,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":31,"col_end":31,"count":5}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let work_selection_method_val = function","counters":[]},{"line":"  | \"seq\" ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Work_selection_method.Sequence","counters":[]},{"line":"  | \"rand\" ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Random","counters":[]},{"line":"  | _ ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      failwith \"Invalid work selection\"","counters":[]},{"line":"","counters":[]},{"line":"let work_selection_method =","counters":[]},{"line":"  Command.Arg_type.map Command.Param.string ~f:work_selection_method_val","counters":[{"col_start":21,"col_end":21,"count":1}]},{"line":"","counters":[]},{"line":"let work_selection_method_to_module :","counters":[]},{"line":"    Work_selection_method.t -> (module Work_selector.Selection_method_intf) =","counters":[]},{"line":"  function","counters":[]},{"line":"  | Sequence ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (module Work_selector.Selection_methods.Sequence)","counters":[]},{"line":"  | Random ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (module Work_selector.Selection_methods.Random)","counters":[{"col_start":52,"col_end":52,"count":2}]}]}