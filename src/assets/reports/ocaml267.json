{"filename":"src/lib/structured_log_events/structured_log_events.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"type t = ..","counters":[]},{"line":"","counters":[]},{"line":"type id = string [@@deriving equal, yojson, sexp]","counters":[{"col_start":0,"col_end":0,"count":0},{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"let id_of_string s = s","counters":[{"col_start":21,"col_end":21,"count":26}]},{"line":"","counters":[]},{"line":"let string_of_id s = s","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"","counters":[]},{"line":"type repr =","counters":[]},{"line":"  { id : id","counters":[]},{"line":"  ; event_name : string","counters":[]},{"line":"  ; arguments : String.Set.t","counters":[]},{"line":"  ; log : t -> (string * (string * Yojson.Safe.t) list) option","counters":[]},{"line":"  ; parse : (string * Yojson.Safe.t) list -> t option","counters":[]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"module Registry = struct","counters":[]},{"line":"  let reprs : repr list ref = ref []","counters":[]},{"line":"","counters":[]},{"line":"  let register_constructor repr = reprs := repr :: !reprs","counters":[{"col_start":34,"col_end":34,"count":26}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let parse_exn id json_pairs =","counters":[]},{"line":"  let result =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    List.find_map !Registry.reprs ~f:(fun repr ->","counters":[]},{"line":"        if equal_id id repr.id then","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let json_pairs =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (* Remove additional metadata that may have been added to the log","counters":[]},{"line":"               message.","counters":[]},{"line":"            *)","counters":[]},{"line":"            List.filter json_pairs ~f:(fun (field_name, _) ->","counters":[]},{"line":"                Set.mem repr.arguments field_name )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"          in","counters":[]},{"line":"          match repr.parse json_pairs with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | Some t ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Some t","counters":[]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              failwithf","counters":[]},{"line":"                \"parse_exn: parser for id %s found, but failed when applied to \\","counters":[]},{"line":"                 arguments: %s\"","counters":[]},{"line":"                id","counters":[]},{"line":"                ( List.map json_pairs ~f:(fun (name, json) ->","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                      sprintf \"%s = %s\" name (Yojson.Safe.to_string json) )","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"                |> String.concat ~sep:\",\" )","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                ()","counters":[]},{"line":"        else None )","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"  in","counters":[]},{"line":"  match result with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | Some data ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      data","counters":[]},{"line":"  | None ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      failwithf \"parse_exn: did not find matching parser for id %s\" id ()","counters":[]},{"line":"","counters":[]},{"line":"let log t =","counters":[]},{"line":"  let result =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    List.find_map !Registry.reprs ~f:(fun repr ->","counters":[]},{"line":"        Option.map (repr.log t) ~f:(fun (msg, fields) -> (msg, repr.id, fields)) )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"  in","counters":[]},{"line":"  match result with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | Some data ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      data","counters":[]},{"line":"  | None ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let[@warning \"-3\"] name =","counters":[]},{"line":"        Obj.extension_name (Obj.extension_constructor t)","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"      in","counters":[]},{"line":"      failwithf \"log: did not find matching logger for %s\" name ()","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"let register_constructor = Registry.register_constructor","counters":[]},{"line":"","counters":[]},{"line":"let dump_registered_events () =","counters":[]},{"line":"  List.map !Registry.reprs ~f:(fun { event_name; id; arguments; _ } ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      (event_name, id, Set.to_list arguments) )","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"","counters":[]},{"line":"let check_interpolations_exn ~msg_loc msg label_names =","counters":[]},{"line":"  (* don't use Logproc_lib, which depends on C++ code","counters":[]},{"line":"     using Interpolator_lib allows use in js_of_ocaml","counters":[]},{"line":"     the `parse` code is the same","counters":[]},{"line":"  *)","counters":[]},{"line":"  match Interpolator_lib.Interpolator.parse msg with","counters":[{"col_start":2,"col_end":2,"count":1}]},{"line":"  | Error err ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      failwithf","counters":[]},{"line":"        \"%s\\nEncountered an error while parsing the structured log message: %s\"","counters":[]},{"line":"        msg_loc err ()","counters":[]},{"line":"  | Ok items ->","counters":[{"col_start":4,"col_end":4,"count":1}]},{"line":"      List.iter items ~f:(function","counters":[]},{"line":"        | `Interpolate interp","counters":[{"col_start":10,"col_end":10,"count":3}]},{"line":"          when not (List.mem ~equal:String.equal label_names interp) ->","counters":[{"col_start":27,"col_end":27,"count":3}]},{"line":"            failwithf","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              \"%s\\n\\","counters":[]},{"line":"               The structured log message contains interpolation point \\\"$%s\\\" \\","counters":[]},{"line":"               which is not a field in the record\"","counters":[]},{"line":"              msg_loc interp ()","counters":[]},{"line":"        | _ ->","counters":[{"col_start":10,"col_end":10,"count":6}]},{"line":"            () )","counters":[{"col_start":15,"col_end":15,"count":2}]}]}