{"filename":"src/lib/graphql_basic_scalars/utils.ml","lines":[{"line":"(**","counters":[]},{"line":"   Utility functors to build custom graphql scalars.  These functors","counters":[]},{"line":"   parametric in the GraphQL Schema module, so that we can use them","counters":[]},{"line":"   either with the async version (for the main application) or the","counters":[]},{"line":"   pure version (for tests).  *)","counters":[]},{"line":"","counters":[{"col_start":0,"col_end":0,"count":1}]},{"line":"module type Schema = sig","counters":[]},{"line":"  type ('a, 'b) typ","counters":[]},{"line":"","counters":[]},{"line":"  val scalar :","counters":[]},{"line":"       ?doc:string","counters":[]},{"line":"    -> string","counters":[]},{"line":"    -> coerce:('a -> Yojson.Basic.t)","counters":[]},{"line":"    -> ('ctx, 'a option) typ","counters":[]},{"line":"","counters":[]},{"line":"  val string : ('ctx, string option) typ","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type Json_intf_any_typ = sig","counters":[]},{"line":"  type t","counters":[]},{"line":"","counters":[]},{"line":"  type ('a, 'b) typ","counters":[]},{"line":"","counters":[]},{"line":"  val parse : Yojson.Basic.t -> t","counters":[]},{"line":"","counters":[]},{"line":"  val serialize : t -> Yojson.Basic.t","counters":[]},{"line":"","counters":[]},{"line":"  val typ : unit -> ('a, t option) typ","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make_scalar_using_to_string (T : sig","counters":[]},{"line":"  type t","counters":[]},{"line":"","counters":[]},{"line":"  val to_string : t -> string","counters":[]},{"line":"","counters":[]},{"line":"  val of_string : string -> t","counters":[]},{"line":"end) (Scalar : sig","counters":[]},{"line":"  val name : string","counters":[]},{"line":"","counters":[]},{"line":"  val doc : string","counters":[]},{"line":"end)","counters":[]},{"line":"(Schema : Schema) :","counters":[]},{"line":"  Json_intf_any_typ","counters":[]},{"line":"    with type ('a, 'b) typ := ('a, 'b) Schema.typ","counters":[]},{"line":"    with type t = T.t = struct","counters":[]},{"line":"  type t = T.t","counters":[]},{"line":"","counters":[]},{"line":"  let parse json = Yojson.Basic.Util.to_string json |> T.of_string","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"","counters":[]},{"line":"  let serialize x = `String (T.to_string x)","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"  let typ () = Schema.scalar Scalar.name ~doc:Scalar.doc ~coerce:serialize","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make_scalar_using_base58_check (T : sig","counters":[]},{"line":"  type t","counters":[]},{"line":"","counters":[]},{"line":"  val to_base58_check : t -> string","counters":[]},{"line":"","counters":[]},{"line":"  val of_base58_check_exn : string -> t","counters":[]},{"line":"end) (Scalar : sig","counters":[]},{"line":"  val name : string","counters":[]},{"line":"","counters":[]},{"line":"  val doc : string","counters":[]},{"line":"end)","counters":[]},{"line":"(Schema : Schema) :","counters":[]},{"line":"  Json_intf_any_typ","counters":[]},{"line":"    with type ('a, 'b) typ := ('a, 'b) Schema.typ","counters":[]},{"line":"    with type t = T.t = struct","counters":[]},{"line":"  type t = T.t","counters":[]},{"line":"","counters":[]},{"line":"  let parse json = Yojson.Basic.Util.to_string json |> T.of_base58_check_exn","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"","counters":[]},{"line":"  let serialize x = `String (T.to_base58_check x)","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"","counters":[]},{"line":"  let typ () = Schema.scalar Scalar.name ~doc:Scalar.doc ~coerce:serialize","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make_scalar_using_base64 (T : sig","counters":[]},{"line":"  type t","counters":[]},{"line":"","counters":[]},{"line":"  val to_base64 : t -> string","counters":[]},{"line":"","counters":[]},{"line":"  val of_base64 : string -> t Core_kernel.Or_error.t","counters":[]},{"line":"end) (Scalar : sig","counters":[]},{"line":"  val name : string","counters":[]},{"line":"","counters":[]},{"line":"  val doc : string","counters":[]},{"line":"end)","counters":[]},{"line":"(Schema : Schema) :","counters":[]},{"line":"  Json_intf_any_typ","counters":[]},{"line":"    with type ('a, 'b) typ := ('a, 'b) Schema.typ","counters":[]},{"line":"    with type t = T.t = struct","counters":[]},{"line":"  type t = T.t","counters":[]},{"line":"","counters":[]},{"line":"  let parse json =","counters":[]},{"line":"    Yojson.Basic.Util.to_string json","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"    |> T.of_base64 |> Core_kernel.Or_error.ok_exn","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"","counters":[]},{"line":"  let serialize x = `String (T.to_base64 x)","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"  let typ () = Schema.scalar Scalar.name ~doc:Scalar.doc ~coerce:serialize","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(** The async schema *)","counters":[]},{"line":"module Schema = Graphql_wrapper.Make (Graphql_async.Schema)","counters":[]},{"line":"","counters":[]},{"line":"(** The schema for non async tests *)","counters":[]},{"line":"module Test_schema = Graphql.Schema","counters":[{"col_start":34,"col_end":34,"count":2}]}]}