{"filename":"src/lib/pickles/common.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Pickles_types","counters":[]},{"line":"open Import","counters":[]},{"line":"open Backend","counters":[]},{"line":"","counters":[]},{"line":"module Max_degree = struct","counters":[]},{"line":"  let step_log2 = Nat.to_int Backend.Tick.Rounds.n","counters":[{"col_start":27,"col_end":27,"count":1}]},{"line":"","counters":[]},{"line":"  let step = 1 lsl step_log2","counters":[]},{"line":"","counters":[]},{"line":"  let wrap_log2 = Nat.to_int Backend.Tock.Rounds.n","counters":[{"col_start":27,"col_end":27,"count":1}]},{"line":"","counters":[]},{"line":"  let wrap = 1 lsl wrap_log2","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let tick_shifts, tock_shifts =","counters":[]},{"line":"  let mk g =","counters":[]},{"line":"    let f =","counters":[{"col_start":4,"col_end":4,"count":2}]},{"line":"      Memo.general ~cache_size_bound:20 ~hashable:Int.hashable (fun log2_size ->","counters":[]},{"line":"          g log2_size )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    in","counters":[]},{"line":"    fun ~log2_size -> f log2_size","counters":[{"col_start":4,"col_end":4,"count":2},{"col_start":22,"col_end":22,"count":0}]},{"line":"  in","counters":[]},{"line":"  ( mk Kimchi_bindings.Protocol.VerifierIndex.Fp.shifts","counters":[{"col_start":5,"col_end":5,"count":1}]},{"line":"  , mk Kimchi_bindings.Protocol.VerifierIndex.Fq.shifts )","counters":[{"col_start":5,"col_end":5,"count":1}]},{"line":"","counters":[]},{"line":"let wrap_domains ~proofs_verified =","counters":[]},{"line":"  let h =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    match proofs_verified with 0 -> 13 | 1 -> 14 | 2 -> 15 | _ -> assert false","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"  in","counters":[]},{"line":"  { Domains.h = Pow_2_roots_of_unity h }","counters":[]},{"line":"","counters":[]},{"line":"let hash_messages_for_next_step_proof ~app_state","counters":[]},{"line":"    (t : _ Types.Step.Proof_state.Messages_for_next_step_proof.t) =","counters":[]},{"line":"  let g (x, y) = [ x; y ] in","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"  let open Backend in","counters":[]},{"line":"  Tick_field_sponge.digest Tick_field_sponge.params","counters":[]},{"line":"    (Types.Step.Proof_state.Messages_for_next_step_proof.to_field_elements t ~g","counters":[{"col_start":73,"col_end":73,"count":0}]},{"line":"       ~comm:(fun (x : Tock.Curve.Affine.t) -> Array.of_list (g x))","counters":[{"col_start":47,"col_end":47,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"       ~app_state )","counters":[]},{"line":"","counters":[]},{"line":"let dlog_pcs_batch (type proofs_verified total)","counters":[]},{"line":"    ((without_degree_bound, _pi) :","counters":[]},{"line":"      total Nat.t * (proofs_verified, Nat.N26.n, total) Nat.Adds.t ) =","counters":[]},{"line":"  Pcs_batch.create ~without_degree_bound ~with_degree_bound:[]","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let when_profiling profiling default =","counters":[]},{"line":"  match Option.map (Sys.getenv_opt \"PICKLES_PROFILING\") ~f:String.lowercase with","counters":[{"col_start":2,"col_end":2,"count":2},{"col_start":33,"col_end":33,"count":2}]},{"line":"  | None | Some (\"0\" | \"false\") ->","counters":[{"col_start":4,"col_end":4,"count":2},{"col_start":17,"col_end":17,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"      default","counters":[]},{"line":"  | Some _ ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      profiling","counters":[]},{"line":"","counters":[]},{"line":"let time lab f =","counters":[]},{"line":"  when_profiling","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    (fun () ->","counters":[]},{"line":"      let start = Time.now () in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let x = f () in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let stop = Time.now () in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      printf \"%s: %s\\n%!\" lab (Time.Span.to_string_hum (Time.diff stop start)) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":53,"col_end":53,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"      x )","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    f ()","counters":[]},{"line":"","counters":[]},{"line":"let bits_to_bytes bits =","counters":[]},{"line":"  let byte_of_bits bs =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    List.foldi bs ~init:0 ~f:(fun i acc b ->","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":13,"col_end":13,"count":0}]},{"line":"        if b then acc lor (1 lsl i) else acc )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"    |> Char.of_int_exn","counters":[]},{"line":"  in","counters":[]},{"line":"  List.map (List.groupi bits ~break:(fun i _ _ -> i mod 8 = 0)) ~f:byte_of_bits","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"  |> String.of_char_list","counters":[]},{"line":"","counters":[]},{"line":"let group_map m ~a ~b =","counters":[]},{"line":"  let params = Group_map.Params.create m { a; b } in","counters":[{"col_start":2,"col_end":2,"count":2}]},{"line":"  stage (fun x -> Group_map.to_group m ~params x)","counters":[{"col_start":2,"col_end":2,"count":2},{"col_start":18,"col_end":18,"count":0}]},{"line":"","counters":[]},{"line":"module Shifts = struct","counters":[]},{"line":"  let tock1 : Tock.Field.t Shifted_value.Type1.Shift.t =","counters":[]},{"line":"    Shifted_value.Type1.Shift.create (module Tock.Field)","counters":[{"col_start":35,"col_end":35,"count":1}]},{"line":"","counters":[]},{"line":"  let tock2 : Tock.Field.t Shifted_value.Type2.Shift.t =","counters":[]},{"line":"    Shifted_value.Type2.Shift.create (module Tock.Field)","counters":[{"col_start":35,"col_end":35,"count":1}]},{"line":"","counters":[]},{"line":"  let tick1 : Tick.Field.t Shifted_value.Type1.Shift.t =","counters":[]},{"line":"    Shifted_value.Type1.Shift.create (module Tick.Field)","counters":[{"col_start":35,"col_end":35,"count":1}]},{"line":"","counters":[]},{"line":"  let tick2 : Tick.Field.t Shifted_value.Type2.Shift.t =","counters":[]},{"line":"    Shifted_value.Type2.Shift.create (module Tick.Field)","counters":[{"col_start":35,"col_end":35,"count":1}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Lookup_parameters = struct","counters":[]},{"line":"  let tick_zero : _ Composition_types.Zero_values.t =","counters":[]},{"line":"    { value =","counters":[]},{"line":"        { challenge = Challenge.Constant.zero","counters":[]},{"line":"        ; scalar =","counters":[]},{"line":"            Shifted_value.Type2.Shifted_value Impls.Wrap.Field.Constant.zero","counters":[]},{"line":"        }","counters":[]},{"line":"    ; var =","counters":[]},{"line":"        { challenge = Impls.Step.Field.zero","counters":[]},{"line":"        ; scalar =","counters":[]},{"line":"            Shifted_value.Type2.Shifted_value","counters":[]},{"line":"              (Impls.Step.Field.zero, Impls.Step.Boolean.false_)","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let tock_zero : _ Composition_types.Zero_values.t =","counters":[]},{"line":"    { value =","counters":[]},{"line":"        { challenge = Challenge.Constant.zero","counters":[]},{"line":"        ; scalar =","counters":[]},{"line":"            Shifted_value.Type2.Shifted_value Impls.Wrap.Field.Constant.zero","counters":[]},{"line":"        }","counters":[]},{"line":"    ; var =","counters":[]},{"line":"        { challenge = Impls.Wrap.Field.zero","counters":[]},{"line":"        ; scalar = Shifted_value.Type2.Shifted_value Impls.Wrap.Field.zero","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let tick ~lookup:flag : _ Composition_types.Wrap.Lookup_parameters.t =","counters":[]},{"line":"    { use = No; zero = tick_zero }","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let finite_exn : 'a Kimchi_types.or_infinity -> 'a * 'a = function","counters":[]},{"line":"  | Finite (x, y) ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (x, y)","counters":[]},{"line":"  | Infinity ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      failwith \"finite_exn\"","counters":[]},{"line":"","counters":[]},{"line":"let or_infinite_conv : ('a * 'a) Or_infinity.t -> 'a Kimchi_types.or_infinity =","counters":[]},{"line":"  function","counters":[]},{"line":"  | Finite (x, y) ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Finite (x, y)","counters":[]},{"line":"  | Infinity ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Infinity","counters":[]},{"line":"","counters":[]},{"line":"module Ipa = struct","counters":[]},{"line":"  open Backend","counters":[]},{"line":"","counters":[]},{"line":"  (* TODO: Make all this completely generic over backend *)","counters":[]},{"line":"","counters":[]},{"line":"  let compute_challenge (type f) ~endo_to_field","counters":[]},{"line":"      (module Field : Kimchi_backend.Field.S with type t = f) c =","counters":[]},{"line":"    endo_to_field c","counters":[{"col_start":4,"col_end":4,"count":31}]},{"line":"","counters":[]},{"line":"  let compute_challenges ~endo_to_field field chals =","counters":[]},{"line":"    Vector.map chals ~f:(fun { Bulletproof_challenge.prechallenge } ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        compute_challenge field ~endo_to_field prechallenge )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"  module Wrap = struct","counters":[]},{"line":"    let field =","counters":[]},{"line":"      (module Tock.Field : Kimchi_backend.Field.S with type t = Tock.Field.t)","counters":[]},{"line":"","counters":[]},{"line":"    let endo_to_field = Endo.Step_inner_curve.to_field","counters":[]},{"line":"","counters":[]},{"line":"    let compute_challenge c = compute_challenge field ~endo_to_field c","counters":[{"col_start":30,"col_end":30,"count":15}]},{"line":"","counters":[]},{"line":"    let compute_challenges cs = compute_challenges field ~endo_to_field cs","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"","counters":[]},{"line":"    let compute_sg chals =","counters":[]},{"line":"      let comm =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Kimchi_bindings.Protocol.SRS.Fq.b_poly_commitment","counters":[]},{"line":"          (Backend.Tock.Keypair.load_urs ())","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"          (Pickles_types.Vector.to_array (compute_challenges chals))","counters":[{"col_start":39,"col_end":39,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"      in","counters":[]},{"line":"      comm.unshifted.(0) |> finite_exn","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Step = struct","counters":[]},{"line":"    let field =","counters":[]},{"line":"      (module Tick.Field : Kimchi_backend.Field.S with type t = Tick.Field.t)","counters":[]},{"line":"","counters":[]},{"line":"    let endo_to_field = Endo.Wrap_inner_curve.to_field","counters":[]},{"line":"","counters":[]},{"line":"    let compute_challenge c = compute_challenge field ~endo_to_field c","counters":[{"col_start":30,"col_end":30,"count":16}]},{"line":"","counters":[]},{"line":"    let compute_challenges cs = compute_challenges field ~endo_to_field cs","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"","counters":[]},{"line":"    let compute_sg chals =","counters":[]},{"line":"      let comm =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Kimchi_bindings.Protocol.SRS.Fp.b_poly_commitment","counters":[]},{"line":"          (Backend.Tick.Keypair.load_urs ())","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"          (Pickles_types.Vector.to_array (compute_challenges chals))","counters":[{"col_start":39,"col_end":39,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"      in","counters":[]},{"line":"      comm.unshifted.(0) |> finite_exn","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let accumulator_check comm_chals =","counters":[]},{"line":"      let chals =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Array.concat","counters":[]},{"line":"        @@ List.map comm_chals ~f:(fun (_, chals) -> Vector.to_array chals)","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"      in","counters":[]},{"line":"      let comms =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Array.of_list_map comm_chals ~f:(fun (comm, _) ->","counters":[]},{"line":"            Or_infinity.Finite comm )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"      in","counters":[]},{"line":"      let urs = Backend.Tick.Keypair.load_urs () in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Promise.run_in_thread (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          Kimchi_bindings.Protocol.SRS.Fp.batch_accumulator_check urs","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (Array.map comms ~f:or_infinite_conv)","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"            chals )","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let tock_unpadded_public_input_of_statement prev_statement =","counters":[]},{"line":"  let input =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    let (T (typ, _conv, _conv_inv)) = Impls.Wrap.input () in","counters":[]},{"line":"    Impls.Wrap.generate_public_input typ prev_statement","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"  in","counters":[]},{"line":"  List.init","counters":[]},{"line":"    (Backend.Tock.Field.Vector.length input)","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"    ~f:(Backend.Tock.Field.Vector.get input)","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"","counters":[]},{"line":"let tock_public_input_of_statement s = tock_unpadded_public_input_of_statement s","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"let tick_public_input_of_statement ~max_proofs_verified ~uses_lookup","counters":[]},{"line":"    (prev_statement : _ Types.Step.Statement.t) =","counters":[]},{"line":"  let input =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    let (T (input, _conv, _conv_inv)) =","counters":[]},{"line":"      Impls.Step.input ~proofs_verified:max_proofs_verified","counters":[]},{"line":"        ~wrap_rounds:Tock.Rounds.n ~uses_lookup","counters":[]},{"line":"    in","counters":[]},{"line":"    Impls.Step.generate_public_input input prev_statement","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"  in","counters":[]},{"line":"  List.init","counters":[]},{"line":"    (Backend.Tick.Field.Vector.length input)","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"    ~f:(Backend.Tick.Field.Vector.get input)","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"","counters":[]},{"line":"let max_log2_degree = Pickles_base.Side_loaded_verification_key.max_log2_degree","counters":[]},{"line":"","counters":[]},{"line":"let max_quot_size ~of_int ~mul:( * ) ~sub:( - ) domain_size =","counters":[]},{"line":"  of_int 5 * (domain_size - of_int 1)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":7,"col_end":7,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"","counters":[]},{"line":"let max_quot_size_int = max_quot_size ~of_int:Fn.id ~mul:( * ) ~sub:( - )","counters":[]},{"line":"","counters":[]},{"line":"let ft_comm ~add:( + ) ~scale ~endoscale ~negate","counters":[]},{"line":"    ~verification_key:(m : _ Plonk_verification_key_evals.t) ~alpha","counters":[]},{"line":"    ~(plonk : _ Types.Wrap.Proof_state.Deferred_values.Plonk.In_circuit.t)","counters":[]},{"line":"    ~t_comm =","counters":[]},{"line":"  let ( * ) x g = scale g x in","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"  let _, [ sigma_comm_last ] =","counters":[]},{"line":"    Vector.split m.sigma_comm (snd (Plonk_types.Permuts_minus_1.add Nat.N1.n))","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"  in","counters":[]},{"line":"  let f_comm =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    (* The poseidon and generic gates are special cases,","counters":[]},{"line":"       as they use coefficient commitments from the verifier index.","counters":[]},{"line":"       Note that for all gates, powers of alpha start at a^0 = 1.","counters":[]},{"line":"    *)","counters":[]},{"line":"    let poseidon =","counters":[]},{"line":"      let (pn :: ps) = Vector.rev m.coefficients_comm in","counters":[]},{"line":"      let res =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Vector.fold ~init:pn ps ~f:(fun acc c -> c + endoscale acc alpha)","counters":[{"col_start":49,"col_end":49,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"      in","counters":[]},{"line":"      scale res plonk.poseidon_selector |> negate","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":10,"col_end":10,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"    in","counters":[]},{"line":"","counters":[]},{"line":"    (*","counters":[]},{"line":"    Remember, the layout of the generic gate:","counters":[]},{"line":"    | 0  |  1 |  2 |  3 |  4 |  5 |  6 |  7 |  8 |  9 |","counters":[]},{"line":"    | l1 | r1 | o1 | m1 | c1 | l2 | r2 | o2 | m2 | c2 |","counters":[]},{"line":"    *)","counters":[]},{"line":"    let generic =","counters":[]},{"line":"      let coeffs = Vector.to_array m.coefficients_comm in","counters":[]},{"line":"      let (generic_selector :: l1 :: r1 :: o1 :: m1 :: l2 :: r2 :: o2 :: m2 :: _)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          =","counters":[]},{"line":"        plonk.generic","counters":[]},{"line":"      in","counters":[]},{"line":"      (* Second gate first, to multiply with a power of alpha. *)","counters":[]},{"line":"      let snd_gate = l2 * coeffs.(5) in","counters":[]},{"line":"      let snd_gate = snd_gate + (r2 * coeffs.(6)) in","counters":[]},{"line":"      let snd_gate = snd_gate + (o2 * coeffs.(7)) in","counters":[]},{"line":"      let snd_gate = snd_gate + (m2 * coeffs.(8)) in","counters":[]},{"line":"      let snd_gate = snd_gate + coeffs.(9) in","counters":[]},{"line":"      let snd_gate = endoscale snd_gate alpha in","counters":[]},{"line":"      (* And then the first gate. *)","counters":[]},{"line":"      let generic_gate = snd_gate + (l1 * coeffs.(0)) in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let generic_gate = generic_gate + (r1 * coeffs.(1)) in","counters":[]},{"line":"      let generic_gate = generic_gate + (o1 * coeffs.(2)) in","counters":[]},{"line":"      let generic_gate = generic_gate + (m1 * coeffs.(3)) in","counters":[]},{"line":"      let generic_gate = generic_gate + coeffs.(4) in","counters":[]},{"line":"      (* generic_selector * (fst_gate + snd_gate * alpha) *)","counters":[]},{"line":"      generic_selector * generic_gate","counters":[]},{"line":"    in","counters":[]},{"line":"","counters":[]},{"line":"    List.reduce_exn ~f:( + )","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"      [ plonk.perm * sigma_comm_last","counters":[]},{"line":"      ; generic","counters":[]},{"line":"      ; poseidon","counters":[]},{"line":"      ; plonk.vbmul * m.mul_comm","counters":[]},{"line":"      ; plonk.complete_add * m.complete_add_comm","counters":[]},{"line":"      ; plonk.endomul * m.emul_comm","counters":[]},{"line":"      ; plonk.endomul_scalar * m.endomul_scalar_comm","counters":[]},{"line":"      ]","counters":[]},{"line":"  in","counters":[]},{"line":"  let chunked_t_comm =","counters":[]},{"line":"    let n = Array.length t_comm in","counters":[]},{"line":"    let res = ref t_comm.(n - 1) in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    for i = n - 2 downto 0 do","counters":[]},{"line":"      res := t_comm.(i) + scale !res plonk.zeta_to_srs_length","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"    done ;","counters":[]},{"line":"    !res","counters":[]},{"line":"  in","counters":[]},{"line":"  f_comm + chunked_t_comm","counters":[]},{"line":"  + negate (scale chunked_t_comm plonk.zeta_to_domain_size)","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":16,"col_end":16,"count":0}]},{"line":"","counters":[]},{"line":"let combined_evaluation (type f)","counters":[]},{"line":"    (module Impl : Snarky_backendless.Snark_intf.Run with type field = f)","counters":[]},{"line":"    ~(xi : Impl.Field.t) (without_degree_bound : _ list) =","counters":[]},{"line":"  let open Impl in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let open Field in","counters":[]},{"line":"  let mul_and_add ~(acc : Field.t) ~(xi : Field.t)","counters":[]},{"line":"      (fx : (Field.t, Boolean.var) Plonk_types.Opt.t) : Field.t =","counters":[]},{"line":"    match fx with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        acc","counters":[]},{"line":"    | Some fx ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        fx + (xi * acc)","counters":[]},{"line":"    | Maybe (b, fx) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Field.if_ b ~then_:(fx + (xi * acc)) ~else_:acc","counters":[]},{"line":"  in","counters":[]},{"line":"  with_label __LOC__ (fun () ->","counters":[]},{"line":"      Pcs_batch.combine_split_evaluations ~mul_and_add","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ~init:(function","counters":[]},{"line":"          | Some x ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              x","counters":[]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Field.zero","counters":[]},{"line":"          | Maybe (b, x) ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (b :> Field.t) * x )","counters":[]},{"line":"        ~xi without_degree_bound )","counters":[{"col_start":33,"col_end":33,"count":2}]}]}