{"filename":"src/lib/mina_net2/libp2p_stream.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Async_kernel","counters":[]},{"line":"open Network_peer","counters":[]},{"line":"","counters":[]},{"line":"type participant = Us | Them [@@deriving equal, show]","counters":[{"col_start":0,"col_end":0,"count":0}]},{"line":"","counters":[]},{"line":"let name_of_participant = function","counters":[]},{"line":"  | Us ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      \"the local host\"","counters":[]},{"line":"  | Them ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      \"the remote host\"","counters":[]},{"line":"","counters":[]},{"line":"type state =","counters":[{"col_start":0,"col_end":0,"count":0}]},{"line":"  | FullyOpen  (** Streams start in this state. Both sides can still write *)","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | HalfClosed of participant","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      (** Streams move from [FullyOpen] to [HalfClosed `Us] when the write pipe is closed. Streams move from [FullyOpen] to [HalfClosed `Them] when [Stream.reset] is called or the remote host closes their write stream. *)","counters":[]},{"line":"  | FullyClosed","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      (** Streams move from [HalfClosed peer] to FullyClosed once the party that isn't peer has their \"close write\" event. Once a stream is FullyClosed, its resources are released. *)","counters":[]},{"line":"[@@deriving equal, show]","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"type t =","counters":[]},{"line":"  { protocol : string","counters":[]},{"line":"  ; id : Libp2p_ipc.stream_id","counters":[]},{"line":"  ; mutable state : state","counters":[]},{"line":"  ; peer : Peer.t","counters":[]},{"line":"  ; incoming_r : string Pipe.Reader.t","counters":[]},{"line":"  ; incoming_w : string Pipe.Writer.t","counters":[]},{"line":"  ; outgoing_w : string Pipe.Writer.t","counters":[]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"let id { id; _ } = id","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"","counters":[]},{"line":"let protocol { protocol; _ } = protocol","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"","counters":[]},{"line":"let remote_peer { peer; _ } = peer","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"","counters":[]},{"line":"let pipes { incoming_r; outgoing_w; _ } = (incoming_r, outgoing_w)","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"","counters":[]},{"line":"let data_received { incoming_w; _ } data =","counters":[]},{"line":"  don't_wait_for (Pipe.write_if_open incoming_w data)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"let reset ~helper { id; _ } =","counters":[]},{"line":"  (* NOTE: do not close the pipes here. Reset_stream should end up","counters":[]},{"line":"      notifying us that streamReadComplete. We can reset the stream (telling","counters":[]},{"line":"      the remote peer to stop writing) and still be sending data ourselves. *)","counters":[]},{"line":"  Libp2p_helper.do_rpc helper","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"    (module Libp2p_ipc.Rpcs.ResetStream)","counters":[]},{"line":"    (Libp2p_ipc.Rpcs.ResetStream.create_request ~stream_id:id)","counters":[]},{"line":"  |> Deferred.Or_error.ignore_m","counters":[]},{"line":"","counters":[]},{"line":"let stream_state_invariant ~logger t =","counters":[]},{"line":"  let us_closed = Pipe.is_closed t.outgoing_w in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let them_closed = Pipe.is_closed t.incoming_w in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  [%log trace] \"%sus_closed && %sthem_closed\"","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":13,"col_end":13,"count":0}]},{"line":"    (if us_closed then \"\" else \"not \")","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"    (if them_closed then \"\" else \"not \") ;","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"  match t.state with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | FullyOpen ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (not us_closed) && not them_closed","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"  | HalfClosed Us ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      us_closed && not them_closed","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"  | HalfClosed Them ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (not us_closed) && them_closed","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"  | FullyClosed ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      us_closed && them_closed","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"","counters":[]},{"line":"(** Advance the stream_state automata, closing pipes as necessary. This","counters":[]},{"line":"    executes atomically, using a bool + condition variable to synchronize","counters":[]},{"line":"    updates. *)","counters":[]},{"line":"let stream_closed ~logger ~who_closed t =","counters":[]},{"line":"  (* FIXME: related to https://github.com/libp2p/go-libp2p-circuit/issues/18","counters":[]},{"line":"         \"preemptive\" or half-closing a stream doesn't actually seem supported:","counters":[]},{"line":"         after closing it we can't read anymore.","counters":[]},{"line":"       NOTE: if we reintroduce this logic, it will make this function deferred,","counters":[]},{"line":"         so we will need to also reintroduce a state lock here using","counters":[]},{"line":"         `Async.Throttle.Sequencer.t`.","counters":[]},{"line":"     let%map () =","counters":[]},{"line":"       match who_closed with","counters":[]},{"line":"       | Us ->","counters":[]},{"line":"           match%map","counters":[]},{"line":"             do_rpc net (module Rpcs.Close_stream) {stream_idx= stream.idx}","counters":[]},{"line":"           with","counters":[]},{"line":"           | Ok \"closeStream success\" ->","counters":[]},{"line":"               ()","counters":[]},{"line":"           | Ok v ->","counters":[]},{"line":"               failwithf \"helper broke RPC protocol: closeStream got %s\" v","counters":[]},{"line":"                 ()","counters":[]},{"line":"           | Error e ->","counters":[]},{"line":"               Error.raise e )","counters":[]},{"line":"       | Them ->","counters":[]},{"line":"           (* Helper notified us that the Go side closed its write pipe. *)","counters":[]},{"line":"           Pipe.close t.incoming_w ;","counters":[]},{"line":"           Deferred.unit","counters":[]},{"line":"     in","counters":[]},{"line":"  *)","counters":[]},{"line":"  (* Helper notified us that the Go side closed its write pipe. *)","counters":[]},{"line":"  if equal_participant who_closed Them then Pipe.close t.incoming_w ;","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"  let new_state =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    let log_double_close () =","counters":[]},{"line":"      [%log error] \"stream with index $index closed twice by $party\"","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"        ~metadata:","counters":[]},{"line":"          [ (\"index\", `String (Libp2p_ipc.stream_id_to_string t.id))","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"          ; (\"party\", `String (name_of_participant who_closed))","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"          ]","counters":[]},{"line":"    in","counters":[]},{"line":"    match t.state with","counters":[]},{"line":"    | FullyOpen ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        HalfClosed who_closed","counters":[]},{"line":"    | HalfClosed previous_closer ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        if equal_participant previous_closer who_closed then (","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"          log_double_close () ; HalfClosed previous_closer )","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"        else FullyClosed","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"    | FullyClosed ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        log_double_close () ; FullyClosed","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"  in","counters":[]},{"line":"  let old_state = t.state in","counters":[]},{"line":"  t.state <- new_state ;","counters":[]},{"line":"  (* TODO: maybe we can check some invariants on the Go side too? *)","counters":[]},{"line":"  if not (stream_state_invariant ~logger t) then","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"    [%log error]","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"      \"after $who_closed closed the stream, stream state invariant broke \\","counters":[]},{"line":"       (previous state: $old_stream_state)\"","counters":[]},{"line":"      ~metadata:","counters":[]},{"line":"        [ (\"who_closed\", `String (name_of_participant who_closed))","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"        ; (\"old_stream_state\", `String (show_state old_state))","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"        ] ;","counters":[]},{"line":"  `Stream_should_be_released (equal_state FullyOpen t.state)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"let create_from_existing ~logger ~helper ~stream_id ~protocol ~peer","counters":[]},{"line":"    ~release_stream =","counters":[]},{"line":"  let incoming_r, incoming_w = Pipe.create () in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let outgoing_r, outgoing_w = Pipe.create () in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let t =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    { id = stream_id","counters":[]},{"line":"    ; protocol","counters":[]},{"line":"    ; state = FullyOpen","counters":[]},{"line":"    ; peer","counters":[]},{"line":"    ; incoming_r","counters":[]},{"line":"    ; incoming_w","counters":[]},{"line":"    ; outgoing_w","counters":[]},{"line":"    }","counters":[]},{"line":"  in","counters":[]},{"line":"  let send_outgoing_messages_task =","counters":[]},{"line":"    Pipe.iter outgoing_r ~f:(fun msg ->","counters":[]},{"line":"        match%map","counters":[]},{"line":"          Libp2p_helper.do_rpc helper","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"            (module Libp2p_ipc.Rpcs.SendStream)","counters":[]},{"line":"            (Libp2p_ipc.Rpcs.SendStream.create_request ~stream_id ~data:msg)","counters":[]},{"line":"        with","counters":[]},{"line":"        | Ok _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ()","counters":[]},{"line":"        | Error e ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            [%log error] \"error sending message on stream $idx: $error\"","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"              ~metadata:","counters":[]},{"line":"                [ (\"idx\", `String (Libp2p_ipc.stream_id_to_string stream_id))","counters":[{"col_start":64,"col_end":64,"count":0}]},{"line":"                ; (\"error\", Error_json.error_to_yojson e)","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"                ] ;","counters":[]},{"line":"            Pipe.close outgoing_w )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"    (* TODO implement proper stream closing *)","counters":[]},{"line":"    (* >>= ( fun () ->","counters":[]},{"line":"       match%map Libp2p_helper.do_rpc helper","counters":[]},{"line":"           (module Libp2p_ipc.Rpcs.CloseStream)","counters":[]},{"line":"           (Libp2p_ipc.Rpcs.CloseStream.create_request ~stream_id) with","counters":[]},{"line":"         | Ok _ ->","counters":[]},{"line":"             ()","counters":[]},{"line":"         | Error e ->","counters":[]},{"line":"           [%log error] \"error closing stream $idx: $error\"","counters":[]},{"line":"             ~metadata:","counters":[]},{"line":"               [ (\"idx\", `String (Libp2p_ipc.stream_id_to_string stream_id))","counters":[]},{"line":"               ; (\"error\", Error_json.error_to_yojson e)","counters":[]},{"line":"               ] ;","counters":[]},{"line":"             ) *)","counters":[]},{"line":"  in","counters":[]},{"line":"  upon send_outgoing_messages_task (fun () ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      let (`Stream_should_be_released should_release) =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        stream_closed ~logger ~who_closed:Us t","counters":[]},{"line":"      in","counters":[]},{"line":"      if should_release then release_stream t.id ) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"  t","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"(* TODO: should we really even be parsing the peer back from the client here?","counters":[]},{"line":"   We will always have already had the full peer record by now... *)","counters":[]},{"line":"let open_ ~logger ~helper ~protocol ~peer_id ~release_stream =","counters":[]},{"line":"  let open Deferred.Or_error.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%map response =","counters":[]},{"line":"    Libp2p_helper.do_rpc helper","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"      (module Libp2p_ipc.Rpcs.OpenStream)","counters":[]},{"line":"      (Libp2p_ipc.Rpcs.OpenStream.create_request ~peer_id ~protocol)","counters":[]},{"line":"  in","counters":[]},{"line":"  let open Libp2p_ipc.Reader.Libp2pHelperInterface.OpenStream.Response in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let stream_id = stream_id_get response in","counters":[]},{"line":"  let peer = Libp2p_ipc.unsafe_parse_peer (peer_get response) in","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"  create_from_existing ~logger ~helper ~stream_id ~protocol ~peer","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    ~release_stream","counters":[{"col_start":18,"col_end":18,"count":2}]}]}