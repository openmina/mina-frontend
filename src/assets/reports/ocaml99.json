{"filename":"src/lib/signature_lib/schnorr.ml","lines":[{"line":"[%%import \"/src/config.mlh\"]","counters":[]},{"line":"","counters":[{"col_start":0,"col_end":0,"count":1}]},{"line":"module Bignum_bigint = Bigint","counters":[]},{"line":"open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"module type Message_intf = sig","counters":[]},{"line":"  type field","counters":[]},{"line":"","counters":[]},{"line":"  type t","counters":[]},{"line":"","counters":[]},{"line":"  type curve","counters":[]},{"line":"","counters":[]},{"line":"  type curve_scalar","counters":[]},{"line":"","counters":[]},{"line":"  val derive : t -> private_key:curve_scalar -> public_key:curve -> curve_scalar","counters":[]},{"line":"","counters":[]},{"line":"  val derive_for_mainnet :","counters":[]},{"line":"    t -> private_key:curve_scalar -> public_key:curve -> curve_scalar","counters":[]},{"line":"","counters":[]},{"line":"  val derive_for_testnet :","counters":[]},{"line":"    t -> private_key:curve_scalar -> public_key:curve -> curve_scalar","counters":[]},{"line":"","counters":[]},{"line":"  val hash : t -> public_key:curve -> r:field -> curve_scalar","counters":[]},{"line":"","counters":[]},{"line":"  val hash_for_mainnet : t -> public_key:curve -> r:field -> curve_scalar","counters":[]},{"line":"","counters":[]},{"line":"  val hash_for_testnet : t -> public_key:curve -> r:field -> curve_scalar","counters":[]},{"line":"","counters":[]},{"line":"  [%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"  type field_var","counters":[]},{"line":"","counters":[]},{"line":"  type boolean_var","counters":[]},{"line":"","counters":[]},{"line":"  type var","counters":[]},{"line":"","counters":[]},{"line":"  type curve_var","counters":[]},{"line":"","counters":[]},{"line":"  type curve_scalar_var","counters":[]},{"line":"","counters":[]},{"line":"  type _ checked","counters":[]},{"line":"","counters":[]},{"line":"  val hash_checked :","counters":[]},{"line":"    var -> public_key:curve_var -> r:field_var -> curve_scalar_var checked","counters":[]},{"line":"","counters":[]},{"line":"  [%%endif]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"[%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"module type S = sig","counters":[]},{"line":"  module Impl : Snarky_backendless.Snark_intf.S","counters":[]},{"line":"","counters":[]},{"line":"  open Impl","counters":[]},{"line":"","counters":[]},{"line":"  type curve","counters":[]},{"line":"","counters":[]},{"line":"  type curve_var","counters":[]},{"line":"","counters":[]},{"line":"  type curve_scalar","counters":[]},{"line":"","counters":[]},{"line":"  type curve_scalar_var","counters":[]},{"line":"","counters":[]},{"line":"  module Shifted : sig","counters":[]},{"line":"    module type S =","counters":[]},{"line":"      Snarky_curves.Shifted_intf","counters":[]},{"line":"        with type curve_var := curve_var","counters":[]},{"line":"         and type boolean_var := Boolean.var","counters":[]},{"line":"         and type 'a checked := 'a Checked.t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Message :","counters":[]},{"line":"    Message_intf","counters":[]},{"line":"      with type boolean_var := Boolean.var","counters":[]},{"line":"       and type curve_scalar := curve_scalar","counters":[]},{"line":"       and type curve_scalar_var := curve_scalar_var","counters":[]},{"line":"       and type 'a checked := 'a Checked.t","counters":[]},{"line":"       and type curve := curve","counters":[]},{"line":"       and type curve_var := curve_var","counters":[]},{"line":"       and type field := Field.t","counters":[]},{"line":"       and type field_var := Field.Var.t","counters":[]},{"line":"","counters":[]},{"line":"  module Signature : sig","counters":[]},{"line":"    type t = field * curve_scalar [@@deriving sexp]","counters":[]},{"line":"","counters":[]},{"line":"    type var = Field.Var.t * curve_scalar_var","counters":[]},{"line":"","counters":[]},{"line":"    val typ : (var, t) Typ.t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Private_key : sig","counters":[]},{"line":"    type t = curve_scalar [@@deriving sexp]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Public_key : sig","counters":[]},{"line":"    type t = curve [@@deriving sexp]","counters":[]},{"line":"","counters":[]},{"line":"    type var = curve_var","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Checked : sig","counters":[]},{"line":"    val compress : curve_var -> Boolean.var list Checked.t","counters":[]},{"line":"","counters":[]},{"line":"    val verifies :","counters":[]},{"line":"         (module Shifted.S with type t = 't)","counters":[]},{"line":"      -> Signature.var","counters":[]},{"line":"      -> Public_key.var","counters":[]},{"line":"      -> Message.var","counters":[]},{"line":"      -> Boolean.var Checked.t","counters":[]},{"line":"","counters":[]},{"line":"    val assert_verifies :","counters":[]},{"line":"         (module Shifted.S with type t = 't)","counters":[]},{"line":"      -> Signature.var","counters":[]},{"line":"      -> Public_key.var","counters":[]},{"line":"      -> Message.var","counters":[]},{"line":"      -> unit Checked.t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  val compress : curve -> bool list","counters":[]},{"line":"","counters":[]},{"line":"  val sign :","counters":[]},{"line":"       ?signature_kind:Mina_signature_kind.t","counters":[]},{"line":"    -> Private_key.t","counters":[]},{"line":"    -> Message.t","counters":[]},{"line":"    -> Signature.t","counters":[]},{"line":"","counters":[]},{"line":"  val verify :","counters":[]},{"line":"       ?signature_kind:Mina_signature_kind.t","counters":[]},{"line":"    -> Signature.t","counters":[]},{"line":"    -> Public_key.t","counters":[]},{"line":"    -> Message.t","counters":[]},{"line":"    -> bool","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make","counters":[]},{"line":"    (Impl : Snarky_backendless.Snark_intf.S) (Curve : sig","counters":[]},{"line":"      open Impl","counters":[]},{"line":"","counters":[]},{"line":"      module Scalar : sig","counters":[]},{"line":"        type t [@@deriving sexp, equal]","counters":[]},{"line":"","counters":[]},{"line":"        type var","counters":[]},{"line":"","counters":[]},{"line":"        val typ : (var, t) Typ.t","counters":[]},{"line":"","counters":[]},{"line":"        val zero : t","counters":[]},{"line":"","counters":[]},{"line":"        val ( * ) : t -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"        val ( + ) : t -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"        val negate : t -> t","counters":[]},{"line":"","counters":[]},{"line":"        module Checked : sig","counters":[]},{"line":"          val to_bits : var -> Boolean.var Bitstring_lib.Bitstring.Lsb_first.t","counters":[]},{"line":"        end","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      type t [@@deriving sexp]","counters":[]},{"line":"","counters":[]},{"line":"      type var = Field.Var.t * Field.Var.t","counters":[]},{"line":"","counters":[]},{"line":"      module Checked :","counters":[]},{"line":"        Snarky_curves.Weierstrass_checked_intf","counters":[]},{"line":"          with module Impl := Impl","counters":[]},{"line":"           and type t = var","counters":[]},{"line":"           and type unchecked := t","counters":[]},{"line":"","counters":[]},{"line":"      val one : t","counters":[]},{"line":"","counters":[]},{"line":"      val ( + ) : t -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"      val negate : t -> t","counters":[]},{"line":"","counters":[]},{"line":"      val scale : t -> Scalar.t -> t","counters":[]},{"line":"","counters":[]},{"line":"      val to_affine_exn : t -> Field.t * Field.t","counters":[]},{"line":"    end)","counters":[]},{"line":"    (Message : Message_intf","counters":[]},{"line":"                 with type boolean_var := Impl.Boolean.var","counters":[]},{"line":"                  and type curve_scalar_var := Curve.Scalar.var","counters":[]},{"line":"                  and type curve_scalar := Curve.Scalar.t","counters":[]},{"line":"                  and type curve := Curve.t","counters":[]},{"line":"                  and type curve_var := Curve.var","counters":[]},{"line":"                  and type field := Impl.Field.t","counters":[]},{"line":"                  and type field_var := Impl.Field.Var.t","counters":[]},{"line":"                  and type 'a checked := 'a Impl.Checked.t) :","counters":[]},{"line":"  S","counters":[]},{"line":"    with module Impl := Impl","counters":[]},{"line":"     and type curve := Curve.t","counters":[]},{"line":"     and type curve_var := Curve.var","counters":[]},{"line":"     and type curve_scalar := Curve.Scalar.t","counters":[]},{"line":"     and type curve_scalar_var := Curve.Scalar.var","counters":[]},{"line":"     and module Shifted := Curve.Checked.Shifted","counters":[]},{"line":"     and module Message := Message = struct","counters":[]},{"line":"  open Impl","counters":[]},{"line":"","counters":[]},{"line":"  module Signature = struct","counters":[]},{"line":"    type t = Field.t * Curve.Scalar.t [@@deriving sexp]","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":13,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"    type var = Field.Var.t * Curve.Scalar.var","counters":[]},{"line":"","counters":[]},{"line":"    let typ : (var, t) Typ.t = Typ.tuple2 Field.typ Curve.Scalar.typ","counters":[{"col_start":40,"col_end":40,"count":2}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Private_key = struct","counters":[]},{"line":"    type t = Curve.Scalar.t [@@deriving sexp]","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Public_key : sig","counters":[]},{"line":"    type t = Curve.t [@@deriving sexp]","counters":[]},{"line":"","counters":[]},{"line":"    type var = Curve.var","counters":[]},{"line":"  end =","counters":[]},{"line":"    Curve","counters":[]},{"line":"","counters":[]},{"line":"  let compress (t : Curve.t) =","counters":[]},{"line":"    let x, _ = Curve.to_affine_exn t in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Field.unpack x","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let is_even (t : Field.t) = not (Bigint.test_bit (Bigint.of_field t) 0)","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":49,"col_end":49,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"","counters":[]},{"line":"  let sign ?signature_kind (d_prime : Private_key.t) (m : Message.t) =","counters":[]},{"line":"    let public_key =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (* TODO: Don't recompute this. *) Curve.scale Curve.one d_prime","counters":[]},{"line":"    in","counters":[]},{"line":"    (* TODO: Once we switch to implicit sign-bit we'll have to conditionally negate d_prime. *)","counters":[]},{"line":"    let d = d_prime in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let derive =","counters":[]},{"line":"      let open Mina_signature_kind in","counters":[]},{"line":"      match signature_kind with","counters":[]},{"line":"      | None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Message.derive","counters":[]},{"line":"      | Some Mainnet ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Message.derive_for_mainnet","counters":[]},{"line":"      | Some Testnet ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Message.derive_for_testnet","counters":[]},{"line":"    in","counters":[]},{"line":"    let k_prime = derive m ~public_key ~private_key:d in","counters":[]},{"line":"    assert (not Curve.Scalar.(equal k_prime zero)) ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":11,"col_end":11,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"    let r, ry = Curve.(to_affine_exn (scale Curve.one k_prime)) in","counters":[{"col_start":35,"col_end":35,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"    let k = if is_even ry then k_prime else Curve.Scalar.negate k_prime in","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"    let hash =","counters":[]},{"line":"      let open Mina_signature_kind in","counters":[]},{"line":"      match signature_kind with","counters":[]},{"line":"      | None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Message.hash","counters":[]},{"line":"      | Some Mainnet ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Message.hash_for_mainnet","counters":[]},{"line":"      | Some Testnet ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Message.hash_for_testnet","counters":[]},{"line":"    in","counters":[]},{"line":"    let e = hash m ~public_key ~r in","counters":[]},{"line":"    let s = Curve.Scalar.(k + (e * d)) in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    (r, s)","counters":[]},{"line":"","counters":[]},{"line":"  let verify ?signature_kind ((r, s) : Signature.t) (pk : Public_key.t)","counters":[]},{"line":"      (m : Message.t) =","counters":[]},{"line":"    let hash =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let open Mina_signature_kind in","counters":[]},{"line":"      match signature_kind with","counters":[]},{"line":"      | None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Message.hash","counters":[]},{"line":"      | Some Mainnet ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Message.hash_for_mainnet","counters":[]},{"line":"      | Some Testnet ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Message.hash_for_testnet","counters":[]},{"line":"    in","counters":[]},{"line":"    let e = hash ~public_key:pk ~r m in","counters":[]},{"line":"    let r_pt = Curve.(scale one s + negate (scale pk e)) in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"    match Curve.to_affine_exn r_pt with","counters":[]},{"line":"    | rx, ry ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        is_even ry && Field.equal rx r","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"    | exception _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        false","counters":[]},{"line":"","counters":[]},{"line":"  [%%if call_logger]","counters":[]},{"line":"","counters":[]},{"line":"  let verify s pk m =","counters":[]},{"line":"    Mina_debug.Call_logger.record_call \"Signature_lib.Schnorr.verify\" ;","counters":[]},{"line":"    if Random.int 1000 = 0 then (","counters":[]},{"line":"      print_endline \"SCHNORR BACKTRACE:\" ;","counters":[]},{"line":"      Printexc.print_backtrace stdout ) ;","counters":[]},{"line":"    verify s pk m","counters":[]},{"line":"","counters":[]},{"line":"  [%%endif]","counters":[]},{"line":"","counters":[]},{"line":"  module Checked = struct","counters":[]},{"line":"    let to_bits x =","counters":[]},{"line":"      Field.Checked.choose_preimage_var x ~length:Field.size_in_bits","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let compress ((x, _) : Curve.var) = to_bits x","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"    let is_even y =","counters":[]},{"line":"      let%map bs = Field.Checked.unpack_full y in","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"      Bitstring_lib.Bitstring.Lsb_first.to_list bs |> List.hd_exn |> Boolean.not","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":54,"col_end":54,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"","counters":[]},{"line":"    (* returning r_point as a representable point ensures it is nonzero so the nonzero","counters":[]},{"line":"     * check does not have to explicitly be performed *)","counters":[]},{"line":"","counters":[]},{"line":"    let%snarkydef_ verifier (type s) ~equal ~final_check","counters":[]},{"line":"        ((module Shifted) as shifted :","counters":[]},{"line":"          (module Curve.Checked.Shifted.S with type t = s) )","counters":[]},{"line":"        ((r, s) : Signature.var) (public_key : Public_key.var) (m : Message.var)","counters":[]},{"line":"        =","counters":[]},{"line":"      let%bind e = Message.hash_checked m ~public_key ~r in","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"      (* s * g - e * public_key *)","counters":[]},{"line":"      let%bind e_pk =","counters":[]},{"line":"        Curve.Checked.scale shifted","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"          (Curve.Checked.negate public_key)","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"          (Curve.Scalar.Checked.to_bits e)","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"          ~init:Shifted.zero","counters":[]},{"line":"      in","counters":[]},{"line":"      let%bind s_g_e_pk =","counters":[]},{"line":"        Curve.Checked.scale_known shifted Curve.one","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"          (Curve.Scalar.Checked.to_bits s)","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"          ~init:e_pk","counters":[]},{"line":"      in","counters":[]},{"line":"      let%bind rx, ry = Shifted.unshift_nonzero s_g_e_pk in","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"      let%bind y_even = is_even ry in","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"      let%bind r_correct = equal r rx in","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"      final_check r_correct y_even","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let verifies s =","counters":[]},{"line":"      verifier ~equal:Field.Checked.equal ~final_check:Boolean.( && ) s","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let assert_verifies s =","counters":[]},{"line":"      verifier ~equal:Field.Checked.Assert.equal","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ~final_check:(fun () ry_even -> Boolean.Assert.is_true ry_even)","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"        s","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"[%%else]","counters":[]},{"line":"","counters":[]},{"line":"(* nonconsensus version of the functor; yes, there's some repeated code,","counters":[]},{"line":"   but seems difficult to abstract over the functors and signatures","counters":[]},{"line":"*)","counters":[]},{"line":"","counters":[]},{"line":"module type S = sig","counters":[]},{"line":"  open Snark_params.Tick","counters":[]},{"line":"","counters":[]},{"line":"  type curve","counters":[]},{"line":"","counters":[]},{"line":"  type curve_scalar","counters":[]},{"line":"","counters":[]},{"line":"  module Message :","counters":[]},{"line":"    Message_intf","counters":[]},{"line":"      with type curve_scalar := curve_scalar","counters":[]},{"line":"       and type curve := curve","counters":[]},{"line":"       and type field := Field.t","counters":[]},{"line":"","counters":[]},{"line":"  module Signature : sig","counters":[]},{"line":"    type t = Field.t * curve_scalar [@@deriving sexp]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Private_key : sig","counters":[]},{"line":"    type t = curve_scalar [@@deriving sexp]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Public_key : sig","counters":[]},{"line":"    type t = curve [@@deriving sexp]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  val sign :","counters":[]},{"line":"       ?signature_kind:Mina_signature_kind.t","counters":[]},{"line":"    -> Private_key.t","counters":[]},{"line":"    -> Message.t","counters":[]},{"line":"    -> Signature.t","counters":[]},{"line":"","counters":[]},{"line":"  val verify :","counters":[]},{"line":"       ?signature_kind:Mina_signature_kind.t","counters":[]},{"line":"    -> Signature.t","counters":[]},{"line":"    -> Public_key.t","counters":[]},{"line":"    -> Message.t","counters":[]},{"line":"    -> bool","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make","counters":[]},{"line":"    (Impl : module type of Snark_params.Tick) (Curve : sig","counters":[]},{"line":"      open Impl","counters":[]},{"line":"","counters":[]},{"line":"      module Scalar : sig","counters":[]},{"line":"        type t [@@deriving sexp, equal]","counters":[]},{"line":"","counters":[]},{"line":"        val zero : t","counters":[]},{"line":"","counters":[]},{"line":"        val ( * ) : t -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"        val ( + ) : t -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"        val negate : t -> t","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      type t [@@deriving sexp]","counters":[]},{"line":"","counters":[]},{"line":"      val one : t","counters":[]},{"line":"","counters":[]},{"line":"      val ( + ) : t -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"      val negate : t -> t","counters":[]},{"line":"","counters":[]},{"line":"      val scale : t -> Scalar.t -> t","counters":[]},{"line":"","counters":[]},{"line":"      val to_affine_exn : t -> Field.t * Field.t","counters":[]},{"line":"    end)","counters":[]},{"line":"    (Message : Message_intf","counters":[]},{"line":"                 with type curve := Curve.t","counters":[]},{"line":"                  and type curve_scalar := Curve.Scalar.t","counters":[]},{"line":"                  and type field := Impl.Field.t) :","counters":[]},{"line":"  S","counters":[]},{"line":"    with type curve := Curve.t","counters":[]},{"line":"     and type curve_scalar := Curve.Scalar.t","counters":[]},{"line":"     and module Message := Message = struct","counters":[]},{"line":"  module Private_key = struct","counters":[]},{"line":"    type t = Curve.Scalar.t [@@deriving sexp]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Signature = struct","counters":[]},{"line":"    type t = Impl.Field.t * Curve.Scalar.t [@@deriving sexp]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Public_key : sig","counters":[]},{"line":"    type t = Curve.t [@@deriving sexp]","counters":[]},{"line":"  end =","counters":[]},{"line":"    Curve","counters":[]},{"line":"","counters":[]},{"line":"  let is_even (t : Impl.Field.t) = not @@ Impl.Field.parity t","counters":[]},{"line":"","counters":[]},{"line":"  let sign ?signature_kind (d_prime : Private_key.t) m =","counters":[]},{"line":"    let public_key =","counters":[]},{"line":"      (* TODO: Don't recompute this. *)","counters":[]},{"line":"      Curve.scale Curve.one d_prime","counters":[]},{"line":"    in","counters":[]},{"line":"    (* TODO: Once we switch to implicit sign-bit we'll have to conditionally negate d_prime. *)","counters":[]},{"line":"    let d = d_prime in","counters":[]},{"line":"    let derive =","counters":[]},{"line":"      let open Mina_signature_kind in","counters":[]},{"line":"      match signature_kind with","counters":[]},{"line":"      | None ->","counters":[]},{"line":"          Message.derive","counters":[]},{"line":"      | Some Mainnet ->","counters":[]},{"line":"          Message.derive_for_mainnet","counters":[]},{"line":"      | Some Testnet ->","counters":[]},{"line":"          Message.derive_for_testnet","counters":[]},{"line":"    in","counters":[]},{"line":"    let k_prime = derive m ~public_key ~private_key:d in","counters":[]},{"line":"    assert (not Curve.Scalar.(equal k_prime zero)) ;","counters":[]},{"line":"    let r, (ry : Impl.Field.t) =","counters":[]},{"line":"      Curve.(to_affine_exn (scale Curve.one k_prime))","counters":[]},{"line":"    in","counters":[]},{"line":"    let k = if is_even ry then k_prime else Curve.Scalar.negate k_prime in","counters":[]},{"line":"    let hash =","counters":[]},{"line":"      let open Mina_signature_kind in","counters":[]},{"line":"      match signature_kind with","counters":[]},{"line":"      | None ->","counters":[]},{"line":"          Message.hash","counters":[]},{"line":"      | Some Mainnet ->","counters":[]},{"line":"          Message.hash_for_mainnet","counters":[]},{"line":"      | Some Testnet ->","counters":[]},{"line":"          Message.hash_for_testnet","counters":[]},{"line":"    in","counters":[]},{"line":"    let e = hash m ~public_key ~r in","counters":[]},{"line":"    let s = Curve.Scalar.(k + (e * d)) in","counters":[]},{"line":"    (r, s)","counters":[]},{"line":"","counters":[]},{"line":"  let verify ?signature_kind ((r, s) : Signature.t) (pk : Public_key.t)","counters":[]},{"line":"      (m : Message.t) =","counters":[]},{"line":"    let hash =","counters":[]},{"line":"      let open Mina_signature_kind in","counters":[]},{"line":"      match signature_kind with","counters":[]},{"line":"      | None ->","counters":[]},{"line":"          Message.hash","counters":[]},{"line":"      | Some Mainnet ->","counters":[]},{"line":"          Message.hash_for_mainnet","counters":[]},{"line":"      | Some Testnet ->","counters":[]},{"line":"          Message.hash_for_testnet","counters":[]},{"line":"    in","counters":[]},{"line":"    let e = hash ~public_key:pk ~r m in","counters":[]},{"line":"    let r_pt = Curve.(scale one s + negate (scale pk e)) in","counters":[]},{"line":"    match Curve.to_affine_exn r_pt with","counters":[]},{"line":"    | rx, ry ->","counters":[]},{"line":"        is_even ry && Impl.Field.(equal rx r)","counters":[]},{"line":"    | exception _ ->","counters":[]},{"line":"        false","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"[%%endif]","counters":[]},{"line":"","counters":[]},{"line":"open Snark_params","counters":[]},{"line":"","counters":[]},{"line":"module Message = struct","counters":[]},{"line":"  let network_id_mainnet = Char.of_int_exn 1","counters":[{"col_start":41,"col_end":41,"count":1}]},{"line":"","counters":[]},{"line":"  let network_id_testnet = Char.of_int_exn 0","counters":[{"col_start":41,"col_end":41,"count":1}]},{"line":"","counters":[]},{"line":"  let network_id =","counters":[]},{"line":"    match Mina_signature_kind.t with","counters":[]},{"line":"    | Mainnet ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        network_id_mainnet","counters":[]},{"line":"    | Testnet ->","counters":[{"col_start":6,"col_end":6,"count":1}]},{"line":"        network_id_testnet","counters":[]},{"line":"","counters":[]},{"line":"  module Legacy = struct","counters":[]},{"line":"    open Tick","counters":[]},{"line":"","counters":[]},{"line":"    type t = (Field.t, bool) Random_oracle.Input.Legacy.t [@@deriving sexp]","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"    let make_derive ~network_id t ~private_key ~public_key =","counters":[]},{"line":"      let input =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let x, y = Tick.Inner_curve.to_affine_exn public_key in","counters":[]},{"line":"        Random_oracle.Input.Legacy.append t","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"          { field_elements = [| x; y |]","counters":[]},{"line":"          ; bitstrings =","counters":[]},{"line":"              [| Tock.Field.unpack private_key","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"               ; Fold_lib.Fold.(","counters":[]},{"line":"                   to_list (string_bits (String.of_char network_id)))","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"              |]","counters":[]},{"line":"          }","counters":[]},{"line":"      in","counters":[]},{"line":"      Random_oracle.Input.Legacy.to_bits ~unpack:Field.unpack input","counters":[]},{"line":"      |> Array.of_list |> Blake2.bits_to_string |> Blake2.digest_string","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"      |> Blake2.to_raw_string |> Blake2.string_to_bits |> Array.to_list","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"      |> Fn.flip List.take (Int.min 256 (Tock.Field.size_in_bits - 1))","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"      |> Tock.Field.project","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"    let derive = make_derive ~network_id","counters":[]},{"line":"","counters":[]},{"line":"    let derive_for_mainnet = make_derive ~network_id:network_id_mainnet","counters":[]},{"line":"","counters":[]},{"line":"    let derive_for_testnet = make_derive ~network_id:network_id_testnet","counters":[]},{"line":"","counters":[]},{"line":"    let make_hash ~init t ~public_key ~r =","counters":[]},{"line":"      let input =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let px, py = Inner_curve.to_affine_exn public_key in","counters":[]},{"line":"        Random_oracle.Input.Legacy.append t","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"          { field_elements = [| px; py; r |]; bitstrings = [||] }","counters":[]},{"line":"      in","counters":[]},{"line":"      let open Random_oracle.Legacy in","counters":[]},{"line":"      hash ~init (pack_input input)","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"      |> Digest.to_bits ~length:Field.size_in_bits","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"      |> Inner_curve.Scalar.of_bits","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"    let hash = make_hash ~init:Hash_prefix_states.signature_legacy","counters":[]},{"line":"","counters":[]},{"line":"    let hash_for_mainnet =","counters":[]},{"line":"      make_hash ~init:Hash_prefix_states.signature_for_mainnet_legacy","counters":[]},{"line":"","counters":[]},{"line":"    let hash_for_testnet =","counters":[]},{"line":"      make_hash ~init:Hash_prefix_states.signature_for_testnet_legacy","counters":[]},{"line":"","counters":[]},{"line":"    [%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"    type var = (Field.Var.t, Boolean.var) Random_oracle.Input.Legacy.t","counters":[]},{"line":"","counters":[]},{"line":"    let%snarkydef_ hash_checked t ~public_key ~r =","counters":[]},{"line":"      let input =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let px, py = public_key in","counters":[]},{"line":"        Random_oracle.Input.Legacy.append t","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"          { field_elements = [| px; py; r |]; bitstrings = [||] }","counters":[]},{"line":"      in","counters":[]},{"line":"      make_checked (fun () ->","counters":[]},{"line":"          let open Random_oracle.Legacy.Checked in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          hash ~init:Hash_prefix_states.signature_legacy (pack_input input)","counters":[{"col_start":67,"col_end":67,"count":0}]},{"line":"          |> Digest.to_bits ~length:Field.size_in_bits","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"          |> Bitstring_lib.Bitstring.Lsb_first.of_list )","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"    [%%endif]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Chunked = struct","counters":[]},{"line":"    open Tick","counters":[]},{"line":"","counters":[]},{"line":"    type t = Field.t Random_oracle.Input.Chunked.t [@@deriving sexp]","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"    let make_derive ~network_id t ~private_key ~public_key =","counters":[]},{"line":"      let input =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let x, y = Tick.Inner_curve.to_affine_exn public_key in","counters":[]},{"line":"        let id =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Fold_lib.Fold.(to_list (string_bits (String.of_char network_id)))","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"        in","counters":[]},{"line":"        Random_oracle.Input.Chunked.append t","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"          { field_elements =","counters":[]},{"line":"              [| x; y; Field.project (Tock.Field.unpack private_key) |]","counters":[{"col_start":35,"col_end":35,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"          ; packeds = [| (Field.project id, List.length id) |]","counters":[{"col_start":38,"col_end":38,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"          }","counters":[]},{"line":"      in","counters":[]},{"line":"      Array.map (Random_oracle.pack_input input) ~f:Tick.Field.unpack","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"      |> Array.to_list |> List.concat |> Array.of_list |> Blake2.bits_to_string","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"      |> Blake2.digest_string |> Blake2.to_raw_string |> Blake2.string_to_bits","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"      |> Array.to_list","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"      |> Fn.flip List.take (Int.min 256 (Tock.Field.size_in_bits - 1))","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"      |> Tock.Field.project","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"    let derive = make_derive ~network_id","counters":[]},{"line":"","counters":[]},{"line":"    let derive_for_mainnet = make_derive ~network_id:network_id_mainnet","counters":[]},{"line":"","counters":[]},{"line":"    let derive_for_testnet = make_derive ~network_id:network_id_testnet","counters":[]},{"line":"","counters":[]},{"line":"    let make_hash ~init t ~public_key ~r =","counters":[]},{"line":"      let input =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let px, py = Inner_curve.to_affine_exn public_key in","counters":[]},{"line":"        Random_oracle.Input.Chunked.append t","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"          { field_elements = [| px; py; r |]; packeds = [||] }","counters":[]},{"line":"      in","counters":[]},{"line":"      let open Random_oracle in","counters":[]},{"line":"      hash ~init (pack_input input)","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"      |> Digest.to_bits ~length:Field.size_in_bits","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"      |> Inner_curve.Scalar.of_bits","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"    let hash = make_hash ~init:Hash_prefix_states.signature","counters":[]},{"line":"","counters":[]},{"line":"    let hash_for_mainnet =","counters":[]},{"line":"      make_hash ~init:Hash_prefix_states.signature_for_mainnet","counters":[]},{"line":"","counters":[]},{"line":"    let hash_for_testnet =","counters":[]},{"line":"      make_hash ~init:Hash_prefix_states.signature_for_testnet","counters":[]},{"line":"","counters":[]},{"line":"    [%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"    type var = Field.Var.t Random_oracle.Input.Chunked.t","counters":[]},{"line":"","counters":[]},{"line":"    let%snarkydef_ hash_checked t ~public_key ~r =","counters":[]},{"line":"      let input =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let px, py = public_key in","counters":[]},{"line":"        Random_oracle.Input.Chunked.append t","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"          { field_elements = [| px; py; r |]; packeds = [||] }","counters":[]},{"line":"      in","counters":[]},{"line":"      make_checked (fun () ->","counters":[]},{"line":"          let open Random_oracle.Checked in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          hash ~init:Hash_prefix_states.signature (pack_input input)","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"          |> Digest.to_bits ~length:Field.size_in_bits","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"          |> Bitstring_lib.Bitstring.Lsb_first.of_list )","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"    [%%endif]","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Legacy = Make (Tick) (Tick.Inner_curve) (Message.Legacy)","counters":[]},{"line":"module Chunked = Make (Tick) (Tick.Inner_curve) (Message.Chunked)","counters":[]},{"line":"","counters":[]},{"line":"[%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"let gen_legacy =","counters":[]},{"line":"  let open Quickcheck.Let_syntax in","counters":[]},{"line":"  let%map pk = Private_key.gen and msg = Tick.Field.gen in","counters":[]},{"line":"  (pk, Random_oracle.Input.Legacy.field_elements [| msg |])","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"","counters":[]},{"line":"let gen_chunked =","counters":[]},{"line":"  let open Quickcheck.Let_syntax in","counters":[]},{"line":"  let%map pk = Private_key.gen and msg = Tick.Field.gen in","counters":[]},{"line":"  (pk, Random_oracle.Input.Chunked.field_elements [| msg |])","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"","counters":[]},{"line":"(* Use for reading only. *)","counters":[]},{"line":"let legacy_message_typ () : (Message.Legacy.var, Message.Legacy.t) Tick.Typ.t =","counters":[]},{"line":"  let to_hlist { Random_oracle.Input.Legacy.field_elements; bitstrings } =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    H_list.[ field_elements; bitstrings ]","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  in","counters":[]},{"line":"  let of_hlist ([ field_elements; bitstrings ] : (unit, _) H_list.t) =","counters":[]},{"line":"    { Random_oracle.Input.Legacy.field_elements; bitstrings }","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  in","counters":[]},{"line":"  let open Tick.Typ in","counters":[]},{"line":"  of_hlistable","counters":[]},{"line":"    [ array ~length:0 Tick.Field.typ","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    ; array ~length:0 (list ~length:0 Tick.Boolean.typ)","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"    ]","counters":[]},{"line":"    ~var_to_hlist:to_hlist ~var_of_hlist:of_hlist ~value_to_hlist:to_hlist","counters":[]},{"line":"    ~value_of_hlist:of_hlist","counters":[]},{"line":"","counters":[]},{"line":"(* Use for reading only. *)","counters":[]},{"line":"let chunked_message_typ () : (Message.Chunked.var, Message.Chunked.t) Tick.Typ.t","counters":[]},{"line":"    =","counters":[]},{"line":"  let open Tick.Typ in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let const_typ =","counters":[]},{"line":"    Typ","counters":[]},{"line":"      { check = (fun _ -> Tick.make_checked_ast @@ Tick.Checked.return ())","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"      ; var_to_fields = (fun t -> ([||], t))","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"      ; var_of_fields = (fun (_, t) -> t)","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"      ; value_to_fields = (fun t -> ([||], t))","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"      ; value_of_fields = (fun (_, t) -> t)","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"      ; size_in_field_elements = 0","counters":[]},{"line":"      ; constraint_system_auxiliary =","counters":[]},{"line":"          (fun () -> failwith \"Cannot create constant in constraint-system mode\")","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"      }","counters":[]},{"line":"  in","counters":[]},{"line":"  let to_hlist { Random_oracle.Input.Chunked.field_elements; packeds } =","counters":[]},{"line":"    H_list.[ field_elements; packeds ]","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  in","counters":[]},{"line":"  let of_hlist ([ field_elements; packeds ] : (unit, _) H_list.t) =","counters":[]},{"line":"    { Random_oracle.Input.Chunked.field_elements; packeds }","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  in","counters":[]},{"line":"  of_hlistable","counters":[]},{"line":"    [ array ~length:0 Tick.Field.typ","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    ; array ~length:0 (Tick.Field.typ * const_typ)","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    ]","counters":[]},{"line":"    ~var_to_hlist:to_hlist ~var_of_hlist:of_hlist ~value_to_hlist:to_hlist","counters":[]},{"line":"    ~value_of_hlist:of_hlist","counters":[]},{"line":"","counters":[]},{"line":"let%test_unit \"schnorr checked + unchecked\" =","counters":[]},{"line":"  Quickcheck.test ~trials:5 gen_legacy ~f:(fun (pk, msg) ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      let s = Legacy.sign pk msg in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let pubkey = Tick.Inner_curve.(scale one pk) in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"      assert (Legacy.verify s pubkey msg) ;","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"      (Tick.Test.test_equal ~sexp_of_t:[%sexp_of: bool] ~equal:Bool.equal","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"         Tick.Typ.(","counters":[]},{"line":"           tuple3 Tick.Inner_curve.typ (legacy_message_typ ())","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"             Legacy.Signature.typ)","counters":[]},{"line":"         Tick.Boolean.typ","counters":[]},{"line":"         (fun (public_key, msg, s) ->","counters":[]},{"line":"           let open Tick.Checked in","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"           let%bind (module Shifted) =","counters":[]},{"line":"             Tick.Inner_curve.Checked.Shifted.create ()","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"           in","counters":[]},{"line":"           Legacy.Checked.verifies (module Shifted) s public_key msg )","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"         (fun _ -> true) )","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"        (pubkey, msg, s) )","counters":[]},{"line":"","counters":[]},{"line":"let%test_unit \"schnorr checked + unchecked\" =","counters":[]},{"line":"  Quickcheck.test ~trials:5 gen_chunked ~f:(fun (pk, msg) ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      let s = Chunked.sign pk msg in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let pubkey = Tick.Inner_curve.(scale one pk) in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"      assert (Chunked.verify s pubkey msg) ;","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"      (Tick.Test.test_equal ~sexp_of_t:[%sexp_of: bool] ~equal:Bool.equal","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"         Tick.Typ.(","counters":[]},{"line":"           tuple3 Tick.Inner_curve.typ (chunked_message_typ ())","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"             Chunked.Signature.typ)","counters":[]},{"line":"         Tick.Boolean.typ","counters":[]},{"line":"         (fun (public_key, msg, s) ->","counters":[]},{"line":"           let open Tick.Checked in","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"           let%bind (module Shifted) =","counters":[]},{"line":"             Tick.Inner_curve.Checked.Shifted.create ()","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"           in","counters":[]},{"line":"           Chunked.Checked.verifies (module Shifted) s public_key msg )","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"         (fun _ -> true) )","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"        (pubkey, msg, s) )","counters":[{"col_start":25,"col_end":25,"count":1}]},{"line":"","counters":[]},{"line":"[%%endif]","counters":[]}]}