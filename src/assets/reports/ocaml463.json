{"filename":"src/lib/pickles/pickles.ml","lines":[{"line":"(** Pickles implementation *)","counters":[]},{"line":"","counters":[]},{"line":"(** See documentation of the {!Mina_wire_types} library *)","counters":[{"col_start":58,"col_end":58,"count":1}]},{"line":"module Wire_types = Mina_wire_types.Pickles","counters":[]},{"line":"","counters":[]},{"line":"module Make_sig (A : Wire_types.Types.S) = struct","counters":[]},{"line":"  module type S =","counters":[]},{"line":"    Pickles_intf.S","counters":[]},{"line":"      with type Side_loaded.Verification_key.Stable.V2.t =","counters":[]},{"line":"        A.Side_loaded.Verification_key.V2.t","counters":[]},{"line":"       and type ('a, 'b) Proof.t = ('a, 'b) A.Proof.t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make_str (_ : Wire_types.Concrete) = struct","counters":[]},{"line":"  module Endo = Endo","counters":[]},{"line":"  module P = Proof","counters":[]},{"line":"","counters":[]},{"line":"  module type Statement_intf = Intf.Statement","counters":[]},{"line":"","counters":[]},{"line":"  module type Statement_var_intf = Intf.Statement_var","counters":[]},{"line":"","counters":[]},{"line":"  module type Statement_value_intf = Intf.Statement_value","counters":[]},{"line":"","counters":[]},{"line":"  module Common = Common","counters":[]},{"line":"  open Tuple_lib","counters":[]},{"line":"  module Scalar_challenge = Scalar_challenge","counters":[]},{"line":"  module SC = Scalar_challenge","counters":[]},{"line":"  open Core_kernel","counters":[]},{"line":"  open Async_kernel","counters":[]},{"line":"  open Import","counters":[]},{"line":"  open Pickles_types","counters":[]},{"line":"  open Poly_types","counters":[]},{"line":"  open Hlist","counters":[]},{"line":"  open Common","counters":[]},{"line":"  open Backend","counters":[]},{"line":"  module Backend = Backend","counters":[]},{"line":"  module Sponge_inputs = Sponge_inputs","counters":[]},{"line":"  module Util = Util","counters":[]},{"line":"  module Tick_field_sponge = Tick_field_sponge","counters":[]},{"line":"  module Impls = Impls","counters":[]},{"line":"  module Inductive_rule = Inductive_rule","counters":[]},{"line":"  module Tag = Tag","counters":[]},{"line":"  module Types_map = Types_map","counters":[]},{"line":"  module Dirty = Dirty","counters":[]},{"line":"  module Cache_handle = Cache_handle","counters":[]},{"line":"  module Step_main_inputs = Step_main_inputs","counters":[]},{"line":"  module Step_verifier = Step_verifier","counters":[]},{"line":"","counters":[]},{"line":"  exception Return_digest of Md5.t","counters":[]},{"line":"","counters":[]},{"line":"  let profile_constraints = false","counters":[]},{"line":"","counters":[]},{"line":"  let verify_promise = Verify.verify","counters":[]},{"line":"","counters":[]},{"line":"  let verify max_proofs_verified statement key proofs =","counters":[]},{"line":"    verify_promise max_proofs_verified statement key proofs","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"    |> Promise.to_deferred","counters":[]},{"line":"","counters":[]},{"line":"  (* This file (as you can see from the mli) defines a compiler which turns an inductive","counters":[]},{"line":"     definition of a set into an inductive SNARK system for proving using those rules.","counters":[]},{"line":"","counters":[]},{"line":"     The two ingredients we use are two SNARKs.","counters":[]},{"line":"     - A step based SNARK for a field Fp, using the group G1/Fq (whose scalar field is Fp)","counters":[]},{"line":"     - A DLOG based SNARK for a field Fq, using the group G/Fp (whose scalar field is Fq)","counters":[]},{"line":"","counters":[]},{"line":"     For convenience in this discussion, let's define","counters":[]},{"line":"      (F_0, G_0) := (Fp, G1)","counters":[]},{"line":"      (F_1, G_1) := (Fq, G)","counters":[]},{"line":"     So ScalarField(G_i) = F_i and G_i / F_{1-i}.","counters":[]},{"line":"","counters":[]},{"line":"     An inductive set A is defined by a sequence of inductive rules.","counters":[]},{"line":"     An inductive rule is intuitively described by something of the form","counters":[]},{"line":"","counters":[]},{"line":"     a1 ∈ A1, ..., an ∈ An","counters":[]},{"line":"       f [ a0, ... a1 ] a","counters":[]},{"line":"     ----------------------","counters":[]},{"line":"             a ∈ A","counters":[]},{"line":"","counters":[]},{"line":"     where f is a snarky function defined over an Impl with Field.t = Fp","counters":[]},{"line":"     and each Ai is itself an inductive rule (possibly equal to A itself).","counters":[]},{"line":"","counters":[]},{"line":"     We pursue the \"step\" then \"wrap\" approach for proof composition.","counters":[]},{"line":"","counters":[]},{"line":"     The main source of complexity is that we must \"wrap\" proofs whose verifiers are","counters":[]},{"line":"     slightly different.","counters":[]},{"line":"","counters":[]},{"line":"     The main sources of complexity are twofold:","counters":[]},{"line":"     1. Each SNARK verifier includes group operations and scalar field operations.","counters":[]},{"line":"        This is problematic because the group operations use the base field, which is","counters":[]},{"line":"        not equal to the scalar field.","counters":[]},{"line":"","counters":[]},{"line":"        Schematically, from the circuit point-of-view, we can say a proof is","counters":[]},{"line":"     - a sequence of F_0 elements xs_0","counters":[]},{"line":"     - a sequence of F_1 elelements xs_1","counters":[]},{"line":"        and a verifier is a pair of \"snarky functions\"","counters":[]},{"line":"     - check_0 : F_0 list -> F_1 list -> unit which uses the Impl with Field.t = F_0","counters":[]},{"line":"     - check_1 : F_0 list -> F_1 list -> unit which uses the Impl with Field.t = F_1","counters":[]},{"line":"     - subset_00 : 'a list -> 'a list","counters":[]},{"line":"     - subset_01 : 'a list -> 'a list","counters":[]},{"line":"     - subset_10 : 'a list -> 'a list","counters":[]},{"line":"     - subset_11 : 'a list -> 'a list","counters":[]},{"line":"        and a proof verifies if","counters":[]},{"line":"        ( check_0 (subset_00 xs_0) (subset_01 xs_1)  ;","counters":[]},{"line":"          check_1 (subset_10 xs_0) (subset_11 xs_1) )","counters":[]},{"line":"","counters":[]},{"line":"        When verifying a proof, we perform the parts of the verifier involving group operations","counters":[]},{"line":"        and expose as public input the scalar-field elements we need to perform the final checks.","counters":[]},{"line":"","counters":[]},{"line":"        In the F_0 circuit, we witness xs_0 and xs_1,","counters":[]},{"line":"        execute `check_0 (subset_00 xs_0) (subset_01 xs_1)` and","counters":[]},{"line":"        expose `subset_10 xs_0` and `subset_11 xs_1` as public inputs.","counters":[]},{"line":"","counters":[]},{"line":"        So the \"public inputs\" contain within them an \"unfinalized proof\".","counters":[]},{"line":"","counters":[]},{"line":"        Then, the next time we verify that proof within an F_1 circuit we \"finalize\" those","counters":[]},{"line":"        unfinalized proofs by running `check_1 xs_0_subset xs_1_subset`.","counters":[]},{"line":"","counters":[]},{"line":"        I didn't implement it exactly this way (although in retrospect probably I should have) but","counters":[]},{"line":"        that's the basic idea.","counters":[]},{"line":"","counters":[]},{"line":"        **The complexity this causes:**","counters":[]},{"line":"        When you prove a rule that includes k recursive verifications, you expose k unfinalized","counters":[]},{"line":"        proofs. So, the shape of a statement depends on how many \"predecessor statements\" it has","counters":[]},{"line":"        or in other words, how many verifications were performed within it.","counters":[]},{"line":"","counters":[]},{"line":"        Say we have an inductive set given by inductive rules R_1, ... R_n such that","counters":[]},{"line":"        each rule R_i has k_i predecessor statements.","counters":[]},{"line":"","counters":[]},{"line":"        In the \"wrap\" circuit, we must be able to verify a proof coming from any of the R_i.","counters":[]},{"line":"        So, we must pad the statement for the proof we're wrapping to have `max_i k_i`","counters":[]},{"line":"        unfinalized proof components.","counters":[]},{"line":"","counters":[]},{"line":"     2. The verifier for each R_i looks a little different depending on the complexity of the \"step\"","counters":[]},{"line":"        circuit corresponding to R_i has. Namely, it is dependent on the \"domains\" H and K for this","counters":[]},{"line":"        circuit.","counters":[]},{"line":"","counters":[]},{"line":"        So, when the \"wrap\" circuit proves the statement,","counters":[]},{"line":"        \"there exists some index i in 1,...,n and a proof P such that verifies(P)\"","counters":[]},{"line":"        \"verifies(P)\" must also take the index \"i\", compute the correct domain sizes correspond to rule \"i\"","counters":[]},{"line":"        and use *that* in the \"verifies\" computation.","counters":[]},{"line":"  *)","counters":[]},{"line":"","counters":[]},{"line":"  let pad_local_max_proofs_verifieds","counters":[]},{"line":"      (type prev_varss prev_valuess env max_proofs_verified branches)","counters":[]},{"line":"      (max_proofs_verified : max_proofs_verified Nat.t)","counters":[]},{"line":"      (length : (prev_varss, branches) Hlist.Length.t)","counters":[]},{"line":"      (local_max_proofs_verifieds :","counters":[]},{"line":"        (prev_varss, prev_valuess, env) H2_1.T(H2_1.T(E03(Int))).t ) :","counters":[]},{"line":"      ((int, max_proofs_verified) Vector.t, branches) Vector.t =","counters":[]},{"line":"    let module Vec = struct","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      type t = (int, max_proofs_verified) Vector.t","counters":[]},{"line":"    end in","counters":[]},{"line":"    let module M =","counters":[]},{"line":"      H2_1.Map","counters":[]},{"line":"        (H2_1.T","counters":[]},{"line":"           (E03 (Int))) (E03 (Vec))","counters":[]},{"line":"           (struct","counters":[]},{"line":"             module HI = H2_1.T (E03 (Int))","counters":[]},{"line":"","counters":[]},{"line":"             let f : type a b e. (a, b, e) H2_1.T(E03(Int)).t -> Vec.t =","counters":[]},{"line":"              fun xs ->","counters":[]},{"line":"               let (T (_proofs_verified, pi)) = HI.length xs in","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"               let module V = H2_1.To_vector (Int) in","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"               let v = V.f pi xs in","counters":[]},{"line":"               Vector.extend_exn v max_proofs_verified 0","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"           end)","counters":[]},{"line":"    in","counters":[]},{"line":"    let module V = H2_1.To_vector (Vec) in","counters":[]},{"line":"    V.f length (M.f local_max_proofs_verifieds)","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"","counters":[]},{"line":"  open Kimchi_backend","counters":[]},{"line":"","counters":[]},{"line":"  module Messages_for_next_proof_over_same_field = struct","counters":[]},{"line":"    module Wrap = Types.Wrap.Proof_state.Messages_for_next_wrap_proof","counters":[]},{"line":"    module Step = Types.Step.Proof_state.Messages_for_next_step_proof","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Proof_ = P.Base","counters":[]},{"line":"  module Proof = P","counters":[]},{"line":"","counters":[]},{"line":"  module Statement_with_proof = struct","counters":[]},{"line":"    type ('s, 'max_width, _) t =","counters":[]},{"line":"      (* TODO: use Max local max proofs verified instead of max_width *)","counters":[]},{"line":"      ('max_width, 'max_width) Proof.t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let pad_messages_for_next_wrap_proof","counters":[]},{"line":"      (type local_max_proofs_verifieds max_local_max_proofs_verifieds","counters":[]},{"line":"      max_proofs_verified )","counters":[]},{"line":"      (module M : Hlist.Maxes.S","counters":[]},{"line":"        with type ns = max_local_max_proofs_verifieds","counters":[]},{"line":"         and type length = max_proofs_verified )","counters":[]},{"line":"      (messages_for_next_wrap_proofs :","counters":[]},{"line":"        local_max_proofs_verifieds","counters":[]},{"line":"        H1.T(Proof_.Messages_for_next_proof_over_same_field.Wrap).t ) =","counters":[]},{"line":"    let dummy_chals = Dummy.Ipa.Wrap.challenges in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let rec go :","counters":[]},{"line":"        type len ms ns.","counters":[]},{"line":"           ms H1.T(Nat).t","counters":[]},{"line":"        -> ns H1.T(Proof_.Messages_for_next_proof_over_same_field.Wrap).t","counters":[]},{"line":"        -> ms H1.T(Proof_.Messages_for_next_proof_over_same_field.Wrap).t =","counters":[]},{"line":"     fun maxes messages_for_next_wrap_proofs ->","counters":[]},{"line":"      match (maxes, messages_for_next_wrap_proofs) with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | [], _ :: _ ->","counters":[]},{"line":"          assert false","counters":[]},{"line":"      | [], [] ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          []","counters":[]},{"line":"      | m :: maxes, [] ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          { challenge_polynomial_commitment = Lazy.force Dummy.Ipa.Step.sg","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"          ; old_bulletproof_challenges = Vector.init m ~f:(fun _ -> dummy_chals)","counters":[{"col_start":51,"col_end":51,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"          }","counters":[]},{"line":"          :: go maxes []","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"      | ( m :: maxes","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        , messages_for_next_wrap_proof :: messages_for_next_wrap_proofs ) ->","counters":[]},{"line":"          let messages_for_next_wrap_proof =","counters":[]},{"line":"            { messages_for_next_wrap_proof with","counters":[]},{"line":"              old_bulletproof_challenges =","counters":[]},{"line":"                Vector.extend_exn","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                  messages_for_next_wrap_proof.old_bulletproof_challenges m","counters":[]},{"line":"                  dummy_chals","counters":[]},{"line":"            }","counters":[]},{"line":"          in","counters":[]},{"line":"          messages_for_next_wrap_proof :: go maxes messages_for_next_wrap_proofs","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"    in","counters":[]},{"line":"    go M.maxes messages_for_next_wrap_proofs","counters":[]},{"line":"","counters":[]},{"line":"  module Verification_key = struct","counters":[]},{"line":"    include Verification_key","counters":[]},{"line":"","counters":[]},{"line":"    module Id = struct","counters":[]},{"line":"      include Cache.Wrap.Key.Verification","counters":[]},{"line":"","counters":[]},{"line":"      let dummy_id = Type_equal.Id.(uid (create ~name:\"dummy\" sexp_of_opaque))","counters":[{"col_start":38,"col_end":38,"count":1},{"col_start":46,"col_end":46,"count":1}]},{"line":"","counters":[]},{"line":"      let dummy : unit -> t =","counters":[]},{"line":"        let header =","counters":[]},{"line":"          { Snark_keys_header.header_version = Snark_keys_header.header_version","counters":[]},{"line":"          ; kind = { type_ = \"verification key\"; identifier = \"dummy\" }","counters":[]},{"line":"          ; constraint_constants =","counters":[]},{"line":"              { sub_windows_per_window = 0","counters":[]},{"line":"              ; ledger_depth = 0","counters":[]},{"line":"              ; work_delay = 0","counters":[]},{"line":"              ; block_window_duration_ms = 0","counters":[]},{"line":"              ; transaction_capacity = Log_2 0","counters":[]},{"line":"              ; pending_coinbase_depth = 0","counters":[]},{"line":"              ; coinbase_amount = Unsigned.UInt64.of_int 0","counters":[{"col_start":55,"col_end":55,"count":1}]},{"line":"              ; supercharged_coinbase_factor = 0","counters":[]},{"line":"              ; account_creation_fee = Unsigned.UInt64.of_int 0","counters":[{"col_start":60,"col_end":60,"count":1}]},{"line":"              ; fork = None","counters":[]},{"line":"              }","counters":[]},{"line":"          ; commits = { mina = \"\"; marlin = \"\" }","counters":[]},{"line":"          ; length = 0","counters":[]},{"line":"          ; commit_date = \"\"","counters":[]},{"line":"          ; constraint_system_hash = \"\"","counters":[]},{"line":"          ; identifying_hash = \"\"","counters":[]},{"line":"          }","counters":[]},{"line":"        in","counters":[]},{"line":"        let t = lazy (dummy_id, header, Md5.digest_string \"\") in","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"        fun () -> Lazy.force t","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    (* TODO: Make async *)","counters":[]},{"line":"    let load ~cache id =","counters":[]},{"line":"      Key_cache.Sync.read cache","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"        (Key_cache.Sync.Disk_storable.of_binable Id.to_string","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"           (module Verification_key.Stable.Latest) )","counters":[]},{"line":"        id","counters":[]},{"line":"      |> Deferred.return","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module type Proof_intf = sig","counters":[]},{"line":"    type statement","counters":[]},{"line":"","counters":[]},{"line":"    type t","counters":[]},{"line":"","counters":[]},{"line":"    val verification_key : Verification_key.t Lazy.t","counters":[]},{"line":"","counters":[]},{"line":"    val id : Verification_key.Id.t Lazy.t","counters":[]},{"line":"","counters":[]},{"line":"    val verify : (statement * t) list -> bool Deferred.t","counters":[]},{"line":"","counters":[]},{"line":"    val verify_promise : (statement * t) list -> bool Promise.t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Prover = struct","counters":[]},{"line":"    type ('prev_values, 'local_widths, 'local_heights, 'a_value, 'proof) t =","counters":[]},{"line":"         ?handler:","counters":[]},{"line":"           (   Snarky_backendless.Request.request","counters":[]},{"line":"            -> Snarky_backendless.Request.response )","counters":[]},{"line":"      -> 'a_value","counters":[]},{"line":"      -> 'proof","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Make","counters":[]},{"line":"      (Arg_var : Statement_var_intf)","counters":[]},{"line":"      (Arg_value : Statement_value_intf)","counters":[]},{"line":"      (Ret_var : T0)","counters":[]},{"line":"      (Ret_value : T0)","counters":[]},{"line":"      (Auxiliary_var : T0)","counters":[]},{"line":"      (Auxiliary_value : T0) =","counters":[]},{"line":"  struct","counters":[]},{"line":"    module IR =","counters":[]},{"line":"      Inductive_rule.T (Arg_var) (Arg_value) (Ret_var) (Ret_value)","counters":[]},{"line":"        (Auxiliary_var)","counters":[]},{"line":"        (Auxiliary_value)","counters":[]},{"line":"    module HIR = H4.T (IR)","counters":[]},{"line":"","counters":[]},{"line":"    let max_local_max_proofs_verifieds ~self (type n)","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"        (module Max_proofs_verified : Nat.Intf with type n = n) branches choices","counters":[]},{"line":"        =","counters":[]},{"line":"      let module Local_max_proofs_verifieds = struct","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        type t = (int, Max_proofs_verified.n) Vector.t","counters":[]},{"line":"      end in","counters":[]},{"line":"      let module M =","counters":[]},{"line":"        H4.Map (IR) (E04 (Local_max_proofs_verifieds))","counters":[]},{"line":"          (struct","counters":[]},{"line":"            module V = H4.To_vector (Int)","counters":[]},{"line":"            module HT = H4.T (Tag)","counters":[]},{"line":"","counters":[]},{"line":"            module M =","counters":[]},{"line":"              H4.Map (Tag) (E04 (Int))","counters":[]},{"line":"                (struct","counters":[]},{"line":"                  let f (type a b c d) (t : (a, b, c, d) Tag.t) : int =","counters":[]},{"line":"                    if Type_equal.Id.same t.id self then","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      Nat.to_int Max_proofs_verified.n","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                    else","counters":[]},{"line":"                      let (module M) = Types_map.max_proofs_verified t in","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                      Nat.to_int M.n","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                end)","counters":[]},{"line":"","counters":[]},{"line":"            let f :","counters":[]},{"line":"                type a b c d. (a, b, c, d) IR.t -> Local_max_proofs_verifieds.t","counters":[]},{"line":"                =","counters":[]},{"line":"             fun rule ->","counters":[]},{"line":"              let (T (_, l)) = HT.length rule.prevs in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              Vector.extend_exn (V.f l (M.f rule.prevs)) Max_proofs_verified.n 0","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"          end)","counters":[]},{"line":"      in","counters":[]},{"line":"      let module V = H4.To_vector (Local_max_proofs_verifieds) in","counters":[]},{"line":"      let padded = V.f branches (M.f choices) |> Vector.transpose in","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"      (padded, Maxes.m padded)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"","counters":[]},{"line":"    module Lazy_ (A : T0) = struct","counters":[]},{"line":"      type t = A.t Lazy.t","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Lazy_keys = struct","counters":[]},{"line":"      type t =","counters":[]},{"line":"        (Impls.Step.Keypair.t * Dirty.t) Lazy.t","counters":[]},{"line":"        * (Kimchi_bindings.Protocol.VerifierIndex.Fp.t * Dirty.t) Lazy.t","counters":[]},{"line":"","counters":[]},{"line":"      (* TODO Think this is right.. *)","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    let log_step main typ name index =","counters":[]},{"line":"      let module Constraints = Snarky_log.Constraints (Impls.Step.Internal_Basic) in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let log =","counters":[]},{"line":"        let weight =","counters":[]},{"line":"          let sys = Backend.Tick.R1CS_constraint_system.create () in","counters":[]},{"line":"          fun ({ annotation; basic } : Impls.Step.Constraint.t) ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let prev =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Kimchi_pasta_constraint_system.Vesta_constraint_system.next_row","counters":[]},{"line":"                sys","counters":[]},{"line":"            in","counters":[]},{"line":"            Backend.Tick.R1CS_constraint_system.add_constraint sys","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              ?label:annotation basic ;","counters":[]},{"line":"            let next =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Kimchi_pasta_constraint_system.Vesta_constraint_system.next_row","counters":[]},{"line":"                sys","counters":[]},{"line":"            in","counters":[]},{"line":"            next - prev","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"        in","counters":[]},{"line":"        Constraints.log ~weight (fun () -> Impls.Step.make_checked main)","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"      in","counters":[]},{"line":"      if profile_constraints then","counters":[]},{"line":"        Snarky_log.to_file (sprintf \"step-snark-%s-%d.json\" name index) log","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"","counters":[]},{"line":"    let log_wrap main typ name id =","counters":[]},{"line":"      let module Constraints = Snarky_log.Constraints (Impls.Wrap.Internal_Basic) in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let log =","counters":[]},{"line":"        let sys = Backend.Tock.R1CS_constraint_system.create () in","counters":[]},{"line":"        let weight ({ annotation; basic } : Impls.Wrap.Constraint.t) =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let prev =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Kimchi_pasta_constraint_system.Pallas_constraint_system.next_row sys","counters":[]},{"line":"          in","counters":[]},{"line":"          Backend.Tock.R1CS_constraint_system.add_constraint sys","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ?label:annotation basic ;","counters":[]},{"line":"          let next =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Kimchi_pasta_constraint_system.Pallas_constraint_system.next_row sys","counters":[]},{"line":"          in","counters":[]},{"line":"          next - prev","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        in","counters":[]},{"line":"        let log =","counters":[]},{"line":"          Constraints.log ~weight","counters":[]},{"line":"            Impls.Wrap.(","counters":[]},{"line":"              fun () ->","counters":[]},{"line":"                make_checked (fun () : unit ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                    let x = with_label __LOC__ (fun () -> exists typ) in","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"                    main x () ))","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"        in","counters":[]},{"line":"        log","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      in","counters":[]},{"line":"      if profile_constraints then","counters":[]},{"line":"        Snarky_log.to_file","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (sprintf","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"             !\"wrap-%s-%{sexp:Type_equal.Id.Uid.t}.json\"","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"             name (Type_equal.Id.uid id) )","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"          log","counters":[]},{"line":"","counters":[]},{"line":"    let compile :","counters":[]},{"line":"        type var value prev_varss prev_valuess widthss heightss max_proofs_verified branches.","counters":[]},{"line":"           self:(var, value, max_proofs_verified, branches) Tag.t","counters":[]},{"line":"        -> cache:Key_cache.Spec.t list","counters":[]},{"line":"        -> ?disk_keys:","counters":[]},{"line":"             (Cache.Step.Key.Verification.t, branches) Vector.t","counters":[]},{"line":"             * Cache.Wrap.Key.Verification.t","counters":[]},{"line":"        -> ?return_early_digest_exception:bool","counters":[]},{"line":"        -> branches:(module Nat.Intf with type n = branches)","counters":[]},{"line":"        -> max_proofs_verified:","counters":[]},{"line":"             (module Nat.Add.Intf with type n = max_proofs_verified)","counters":[]},{"line":"        -> name:string","counters":[]},{"line":"        -> constraint_constants:Snark_keys_header.Constraint_constants.t","counters":[]},{"line":"        -> public_input:","counters":[]},{"line":"             ( var","counters":[]},{"line":"             , value","counters":[]},{"line":"             , Arg_var.t","counters":[]},{"line":"             , Arg_value.t","counters":[]},{"line":"             , Ret_var.t","counters":[]},{"line":"             , Ret_value.t )","counters":[]},{"line":"             Inductive_rule.public_input","counters":[]},{"line":"        -> auxiliary_typ:(Auxiliary_var.t, Auxiliary_value.t) Impls.Step.Typ.t","counters":[]},{"line":"        -> choices:","counters":[]},{"line":"             (   self:(var, value, max_proofs_verified, branches) Tag.t","counters":[]},{"line":"              -> (prev_varss, prev_valuess, widthss, heightss) H4.T(IR).t )","counters":[]},{"line":"        -> unit","counters":[]},{"line":"        -> ( prev_valuess","counters":[]},{"line":"           , widthss","counters":[]},{"line":"           , heightss","counters":[]},{"line":"           , Arg_value.t","counters":[]},{"line":"           , ( Ret_value.t","counters":[]},{"line":"             * Auxiliary_value.t","counters":[]},{"line":"             * (max_proofs_verified, max_proofs_verified) Proof.t )","counters":[]},{"line":"             Promise.t )","counters":[]},{"line":"           H3_2.T(Prover).t","counters":[]},{"line":"           * _","counters":[]},{"line":"           * _","counters":[]},{"line":"           * _ =","counters":[]},{"line":"     fun ~self ~cache ?disk_keys ?(return_early_digest_exception = false)","counters":[{"col_start":67,"col_end":67,"count":0}]},{"line":"         ~branches:(module Branches) ~max_proofs_verified ~name","counters":[]},{"line":"         ~constraint_constants ~public_input ~auxiliary_typ ~choices () ->","counters":[]},{"line":"      let snark_keys_header kind constraint_system_hash =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { Snark_keys_header.header_version = Snark_keys_header.header_version","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        ; kind","counters":[]},{"line":"        ; constraint_constants","counters":[]},{"line":"        ; commits =","counters":[]},{"line":"            { mina = Mina_version.commit_id","counters":[]},{"line":"            ; marlin = Mina_version.marlin_commit_id","counters":[]},{"line":"            }","counters":[]},{"line":"        ; length = (* This is a dummy, it gets filled in on read/write. *) 0","counters":[]},{"line":"        ; commit_date = Mina_version.commit_date","counters":[]},{"line":"        ; constraint_system_hash","counters":[]},{"line":"        ; identifying_hash =","counters":[]},{"line":"            (* TODO: Proper identifying hash. *)","counters":[]},{"line":"            constraint_system_hash","counters":[]},{"line":"        }","counters":[]},{"line":"      in","counters":[]},{"line":"      Timer.start __LOC__ ;","counters":[]},{"line":"      let module Max_proofs_verified = ( val max_proofs_verified : Nat.Add.Intf","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"                                           with type n = max_proofs_verified )","counters":[]},{"line":"      in","counters":[]},{"line":"      let T = Max_proofs_verified.eq in","counters":[]},{"line":"      let choices = choices ~self in","counters":[]},{"line":"      let (T (prev_varss_n, prev_varss_length)) = HIR.length choices in","counters":[]},{"line":"      let T = Nat.eq_exn prev_varss_n Branches.n in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let padded, (module Maxes) =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        max_local_max_proofs_verifieds","counters":[]},{"line":"          ( module struct","counters":[]},{"line":"            include Max_proofs_verified","counters":[]},{"line":"          end )","counters":[]},{"line":"          prev_varss_length choices ~self:self.id","counters":[]},{"line":"      in","counters":[]},{"line":"      let full_signature = { Full_signature.padded; maxes = (module Maxes) } in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Timer.clock __LOC__ ;","counters":[]},{"line":"      let wrap_domains =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let module M =","counters":[]},{"line":"          Wrap_domains.Make (Arg_var) (Arg_value) (Ret_var) (Ret_value)","counters":[]},{"line":"            (Auxiliary_var)","counters":[]},{"line":"            (Auxiliary_value)","counters":[]},{"line":"        in","counters":[]},{"line":"        let rec f :","counters":[]},{"line":"            type a b c d. (a, b, c, d) H4.T(IR).t -> (a, b, c, d) H4.T(M.I).t =","counters":[]},{"line":"          function","counters":[]},{"line":"          | [] ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              []","counters":[]},{"line":"          | x :: xs ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              x :: f xs","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"        in","counters":[]},{"line":"        M.f full_signature prev_varss_n prev_varss_length ~self","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          ~choices:(f choices) ~max_proofs_verified","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"      in","counters":[]},{"line":"      Timer.clock __LOC__ ;","counters":[]},{"line":"      let module Branch_data = struct","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        type ('vars, 'vals, 'n, 'm) t =","counters":[]},{"line":"          ( Arg_var.t","counters":[]},{"line":"          , Arg_value.t","counters":[]},{"line":"          , Ret_var.t","counters":[]},{"line":"          , Ret_value.t","counters":[]},{"line":"          , Auxiliary_var.t","counters":[]},{"line":"          , Auxiliary_value.t","counters":[]},{"line":"          , Max_proofs_verified.n","counters":[]},{"line":"          , Branches.n","counters":[]},{"line":"          , 'vars","counters":[]},{"line":"          , 'vals","counters":[]},{"line":"          , 'n","counters":[]},{"line":"          , 'm )","counters":[]},{"line":"          Step_branch_data.t","counters":[]},{"line":"      end in","counters":[]},{"line":"      let proofs_verifieds =","counters":[]},{"line":"        let module M =","counters":[]},{"line":"          H4.Map (IR) (E04 (Int))","counters":[]},{"line":"            (struct","counters":[]},{"line":"              module M = H4.T (Tag)","counters":[]},{"line":"","counters":[]},{"line":"              let f : type a b c d. (a, b, c, d) IR.t -> int =","counters":[]},{"line":"               fun r ->","counters":[]},{"line":"                let (T (n, _)) = M.length r.prevs in","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                Nat.to_int n","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"            end)","counters":[]},{"line":"        in","counters":[]},{"line":"        let module V = H4.To_vector (Int) in","counters":[]},{"line":"        V.f prev_varss_length (M.f choices)","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"      in","counters":[]},{"line":"      let step_uses_lookup =","counters":[]},{"line":"        let rec go :","counters":[]},{"line":"            type a b c d. (a, b, c, d) H4.T(IR).t -> Plonk_types.Opt.Flag.t =","counters":[]},{"line":"         fun rules ->","counters":[]},{"line":"          match rules with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | [] ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              No","counters":[]},{"line":"          | r :: rules -> (","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let rest_usage = go rules in","counters":[]},{"line":"              match (r.uses_lookup, rest_usage) with","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              | true, Yes ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Yes","counters":[]},{"line":"              | false, No ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  No","counters":[]},{"line":"              | _, Maybe | true, No | false, Yes ->","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"                  Maybe )","counters":[]},{"line":"        in","counters":[]},{"line":"        go choices","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"      in","counters":[]},{"line":"      let step_data =","counters":[]},{"line":"        let i = ref 0 in","counters":[]},{"line":"        Timer.clock __LOC__ ;","counters":[]},{"line":"        let rec f :","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            type a b c d.","counters":[]},{"line":"            (a, b, c, d) H4.T(IR).t -> (a, b, c, d) H4.T(Branch_data).t =","counters":[]},{"line":"          function","counters":[]},{"line":"          | [] ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              []","counters":[]},{"line":"          | rule :: rules ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let first =","counters":[]},{"line":"                Timer.clock __LOC__ ;","counters":[]},{"line":"                let res =","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Common.time \"make step data\" (fun () ->","counters":[]},{"line":"                      Step_branch_data.create ~index:!i ~step_uses_lookup","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        ~max_proofs_verified:Max_proofs_verified.n","counters":[]},{"line":"                        ~branches:Branches.n ~self ~public_input ~auxiliary_typ","counters":[]},{"line":"                        Arg_var.to_field_elements Arg_value.to_field_elements","counters":[]},{"line":"                        rule ~wrap_domains ~proofs_verifieds )","counters":[]},{"line":"                in","counters":[]},{"line":"                Timer.clock __LOC__ ; incr i ; res","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"              in","counters":[]},{"line":"              first :: f rules","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"        in","counters":[]},{"line":"        f choices","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      in","counters":[]},{"line":"      Timer.clock __LOC__ ;","counters":[]},{"line":"      let step_domains =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let module M =","counters":[]},{"line":"          H4.Map (Branch_data) (E04 (Domains))","counters":[]},{"line":"            (struct","counters":[]},{"line":"              let f (T b : _ Branch_data.t) = b.domains","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"            end)","counters":[]},{"line":"        in","counters":[]},{"line":"        let module V = H4.To_vector (Domains) in","counters":[]},{"line":"        V.f prev_varss_length (M.f step_data)","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"      in","counters":[]},{"line":"      let cache_handle = ref (Lazy.return `Cache_hit) in","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"      let accum_dirty t = cache_handle := Cache_handle.(!cache_handle + t) in","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"      Timer.clock __LOC__ ;","counters":[]},{"line":"      let step_keypairs =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let disk_keys =","counters":[]},{"line":"          Option.map disk_keys ~f:(fun (xs, _) -> Vector.to_array xs)","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"        in","counters":[]},{"line":"        let module M =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          H4.Map (Branch_data) (E04 (Lazy_keys))","counters":[]},{"line":"            (struct","counters":[]},{"line":"              let etyp =","counters":[]},{"line":"                Impls.Step.input ~proofs_verified:Max_proofs_verified.n","counters":[]},{"line":"                  ~wrap_rounds:Tock.Rounds.n ~uses_lookup:Maybe","counters":[]},{"line":"              (* TODO *)","counters":[]},{"line":"","counters":[]},{"line":"              let f (T b : _ Branch_data.t) =","counters":[]},{"line":"                let (T (typ, _conv, conv_inv)) = etyp in","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                let main () () =","counters":[]},{"line":"                  let res = b.main ~step_domains () in","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  Impls.Step.with_label \"conv_inv\" (fun () -> conv_inv res)","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"                in","counters":[]},{"line":"                let () = if true then log_step main typ name b.index in","counters":[{"col_start":38,"col_end":38,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"                let open Impls.Step in","counters":[]},{"line":"                (* HACK: TODO docs *)","counters":[]},{"line":"                if return_early_digest_exception then","counters":[]},{"line":"                  raise","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    (Return_digest","counters":[]},{"line":"                       ( constraint_system ~input_typ:Typ.unit ~return_typ:typ","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"                           main","counters":[]},{"line":"                       |> R1CS_constraint_system.digest ) ) ;","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"","counters":[]},{"line":"                let k_p =","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  lazy","counters":[]},{"line":"                    (let cs =","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                       constraint_system ~input_typ:Typ.unit ~return_typ:typ","counters":[]},{"line":"                         main","counters":[]},{"line":"                     in","counters":[]},{"line":"                     let cs_hash =","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                       Md5.to_hex (R1CS_constraint_system.digest cs)","counters":[{"col_start":63,"col_end":63,"count":0}]},{"line":"                     in","counters":[]},{"line":"                     ( Type_equal.Id.uid self.id","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"                     , snark_keys_header","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"                         { type_ = \"step-proving-key\"","counters":[]},{"line":"                         ; identifier = name ^ \"-\" ^ b.rule.identifier","counters":[]},{"line":"                         }","counters":[]},{"line":"                         cs_hash","counters":[]},{"line":"                     , b.index","counters":[]},{"line":"                     , cs ) )","counters":[]},{"line":"                in","counters":[]},{"line":"                let k_v =","counters":[]},{"line":"                  match disk_keys with","counters":[]},{"line":"                  | Some ks ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      Lazy.return ks.(b.index)","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                  | None ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      lazy","counters":[]},{"line":"                        (let id, _header, index, cs = Lazy.force k_p in","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                         let digest = R1CS_constraint_system.digest cs in","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                         ( id","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                         , snark_keys_header","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"                             { type_ = \"step-verification-key\"","counters":[]},{"line":"                             ; identifier = name ^ \"-\" ^ b.rule.identifier","counters":[]},{"line":"                             }","counters":[]},{"line":"                             (Md5.to_hex digest)","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"                         , index","counters":[]},{"line":"                         , digest ) )","counters":[]},{"line":"                in","counters":[]},{"line":"                let ((pk, vk) as res) =","counters":[]},{"line":"                  Common.time \"step read or generate\" (fun () ->","counters":[]},{"line":"                      Cache.Step.read_or_generate","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        ~prev_challenges:(Nat.to_int (fst b.proofs_verified))","counters":[{"col_start":51,"col_end":51,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"                        cache k_p k_v","counters":[]},{"line":"                        (Snarky_backendless.Typ.unit ())","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                        typ main )","counters":[]},{"line":"                in","counters":[]},{"line":"                accum_dirty (Lazy.map pk ~f:snd) ;","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"                accum_dirty (Lazy.map vk ~f:snd) ;","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"                res","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"            end)","counters":[]},{"line":"        in","counters":[]},{"line":"        M.f step_data","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"      in","counters":[]},{"line":"      Timer.clock __LOC__ ;","counters":[]},{"line":"      let step_vks =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let module V = H4.To_vector (Lazy_keys) in","counters":[]},{"line":"        lazy","counters":[]},{"line":"          (Vector.map (V.f prev_varss_length step_keypairs) ~f:(fun (_, vk) ->","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"               Tick.Keypair.vk_commitments (fst (Lazy.force vk)) ) )","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":46,"col_end":46,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"      in","counters":[]},{"line":"      Timer.clock __LOC__ ;","counters":[]},{"line":"      let wrap_requests, wrap_main =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Wrap_main.wrap_main full_signature prev_varss_length step_vks","counters":[]},{"line":"          proofs_verifieds step_domains max_proofs_verified","counters":[]},{"line":"      in","counters":[]},{"line":"      Timer.clock __LOC__ ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let (wrap_pk, wrap_vk), disk_key =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let open Impls.Wrap in","counters":[]},{"line":"        let (T (typ, conv, _conv_inv)) = input () in","counters":[]},{"line":"        let main x () : unit = wrap_main (conv x) in","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"        let () = if true then log_wrap main typ name self.id in","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"        let self_id = Type_equal.Id.uid self.id in","counters":[]},{"line":"        let disk_key_prover =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          lazy","counters":[]},{"line":"            (let cs =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"               constraint_system ~input_typ:typ","counters":[]},{"line":"                 ~return_typ:(Snarky_backendless.Typ.unit ())","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"                 main","counters":[]},{"line":"             in","counters":[]},{"line":"             let cs_hash = Md5.to_hex (R1CS_constraint_system.digest cs) in","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"             ( self_id","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"             , snark_keys_header","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                 { type_ = \"wrap-proving-key\"; identifier = name }","counters":[]},{"line":"                 cs_hash","counters":[]},{"line":"             , cs ) )","counters":[]},{"line":"        in","counters":[]},{"line":"        let disk_key_verifier =","counters":[]},{"line":"          match disk_keys with","counters":[]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              lazy","counters":[]},{"line":"                (let id, _header, cs = Lazy.force disk_key_prover in","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                 let digest = R1CS_constraint_system.digest cs in","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                 ( id","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                 , snark_keys_header","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                     { type_ = \"wrap-verification-key\"; identifier = name }","counters":[]},{"line":"                     (Md5.to_hex digest)","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                 , digest ) )","counters":[]},{"line":"          | Some (_, (_id, header, digest)) ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Lazy.return (self_id, header, digest)","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"        in","counters":[]},{"line":"        let r =","counters":[]},{"line":"          Common.time \"wrap read or generate \" (fun () ->","counters":[]},{"line":"              Cache.Wrap.read_or_generate (* Due to Wrap_hack *)","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ~prev_challenges:2 cache disk_key_prover disk_key_verifier typ","counters":[]},{"line":"                (Snarky_backendless.Typ.unit ())","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"                main )","counters":[]},{"line":"        in","counters":[]},{"line":"        (r, disk_key_verifier)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      in","counters":[]},{"line":"      Timer.clock __LOC__ ;","counters":[]},{"line":"      accum_dirty (Lazy.map wrap_pk ~f:snd) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"      accum_dirty (Lazy.map wrap_vk ~f:snd) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"      let wrap_vk = Lazy.map wrap_vk ~f:fst in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let module S =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Step.Make (Arg_var) (Arg_value)","counters":[]},{"line":"          (struct","counters":[]},{"line":"            include Max_proofs_verified","counters":[]},{"line":"          end)","counters":[]},{"line":"      in","counters":[]},{"line":"      let (typ : (var, value) Impls.Step.Typ.t) =","counters":[]},{"line":"        match public_input with","counters":[]},{"line":"        | Input typ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            typ","counters":[]},{"line":"        | Output typ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            typ","counters":[]},{"line":"        | Input_and_output (input_typ, output_typ) ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Impls.Step.Typ.(input_typ * output_typ)","counters":[]},{"line":"      in","counters":[]},{"line":"      let provers =","counters":[]},{"line":"        let module Z = H4.Zip (Branch_data) (E04 (Impls.Step.Keypair)) in","counters":[]},{"line":"        let f :","counters":[]},{"line":"            type prev_vars prev_values local_widths local_heights.","counters":[]},{"line":"               ( prev_vars","counters":[]},{"line":"               , prev_values","counters":[]},{"line":"               , local_widths","counters":[]},{"line":"               , local_heights )","counters":[]},{"line":"               Branch_data.t","counters":[]},{"line":"            -> Lazy_keys.t","counters":[]},{"line":"            -> ?handler:","counters":[]},{"line":"                 (   Snarky_backendless.Request.request","counters":[]},{"line":"                  -> Snarky_backendless.Request.response )","counters":[]},{"line":"            -> Arg_value.t","counters":[]},{"line":"            -> ( Ret_value.t","counters":[]},{"line":"               * Auxiliary_value.t","counters":[]},{"line":"               * (Max_proofs_verified.n, Max_proofs_verified.n) Proof.t )","counters":[]},{"line":"               Promise.t =","counters":[]},{"line":"         fun (T b as branch_data) (step_pk, step_vk) ->","counters":[]},{"line":"          let (module Requests) = b.requests in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let _, prev_vars_length = b.proofs_verified in","counters":[]},{"line":"          let step handler next_state =","counters":[]},{"line":"            let wrap_vk = Lazy.force wrap_vk in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            S.f ?handler branch_data next_state ~prevs_length:prev_vars_length","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              ~self ~step_domains ~self_dlog_plonk_index:wrap_vk.commitments","counters":[]},{"line":"              ~public_input ~auxiliary_typ","counters":[]},{"line":"              ~uses_lookup:(if b.rule.uses_lookup then Yes else No)","counters":[{"col_start":55,"col_end":55,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"              (Impls.Step.Keypair.pk (fst (Lazy.force step_pk)))","counters":[{"col_start":35,"col_end":35,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"              wrap_vk.index","counters":[]},{"line":"          in","counters":[]},{"line":"          let step_vk = fst (Lazy.force step_vk) in","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"          let wrap ?handler next_state =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let wrap_vk = Lazy.force wrap_vk in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let%bind.Promise ( proof","counters":[]},{"line":"                             , return_value","counters":[]},{"line":"                             , auxiliary_value","counters":[]},{"line":"                             , actual_wrap_domains ) =","counters":[]},{"line":"              step handler ~maxes:(module Maxes) next_state","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"            in","counters":[]},{"line":"            let proof =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              { proof with","counters":[]},{"line":"                statement =","counters":[]},{"line":"                  { proof.statement with","counters":[]},{"line":"                    messages_for_next_wrap_proof =","counters":[]},{"line":"                      pad_messages_for_next_wrap_proof","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"                        (module Maxes)","counters":[]},{"line":"                        proof.statement.messages_for_next_wrap_proof","counters":[]},{"line":"                  }","counters":[]},{"line":"              }","counters":[]},{"line":"            in","counters":[]},{"line":"            let%map.Promise proof =","counters":[]},{"line":"              Wrap.wrap ~max_proofs_verified:Max_proofs_verified.n","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                full_signature.maxes wrap_requests","counters":[]},{"line":"                ~dlog_plonk_index:wrap_vk.commitments wrap_main ~typ ~step_vk","counters":[]},{"line":"                ~step_plonk_indices:(Lazy.force step_vks) ~actual_wrap_domains","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"                (Impls.Wrap.Keypair.pk (fst (Lazy.force wrap_pk)))","counters":[{"col_start":37,"col_end":37,"count":0},{"col_start":42,"col_end":42,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"                proof","counters":[]},{"line":"            in","counters":[]},{"line":"            ( return_value","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            , auxiliary_value","counters":[]},{"line":"            , Proof.T","counters":[]},{"line":"                { proof with","counters":[]},{"line":"                  statement =","counters":[]},{"line":"                    { proof.statement with","counters":[]},{"line":"                      messages_for_next_step_proof =","counters":[]},{"line":"                        { proof.statement.messages_for_next_step_proof with","counters":[]},{"line":"                          app_state = ()","counters":[]},{"line":"                        }","counters":[]},{"line":"                    }","counters":[]},{"line":"                } )","counters":[]},{"line":"          in","counters":[]},{"line":"          wrap","counters":[]},{"line":"        in","counters":[]},{"line":"        let rec go :","counters":[]},{"line":"            type xs1 xs2 xs3 xs4 xs5 xs6.","counters":[]},{"line":"               (xs1, xs2, xs3, xs4) H4.T(Branch_data).t","counters":[]},{"line":"            -> (xs1, xs2, xs3, xs4) H4.T(E04(Lazy_keys)).t","counters":[]},{"line":"            -> ( xs2","counters":[]},{"line":"               , xs3","counters":[]},{"line":"               , xs4","counters":[]},{"line":"               , Arg_value.t","counters":[]},{"line":"               , ( Ret_value.t","counters":[]},{"line":"                 * Auxiliary_value.t","counters":[]},{"line":"                 * (max_proofs_verified, max_proofs_verified) Proof.t )","counters":[]},{"line":"                 Promise.t )","counters":[]},{"line":"               H3_2.T(Prover).t =","counters":[]},{"line":"         fun bs ks ->","counters":[]},{"line":"          match (bs, ks) with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | [], [] ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              []","counters":[]},{"line":"          | b :: bs, k :: ks ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              f b k :: go bs ks","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"        in","counters":[]},{"line":"        go step_data step_keypairs","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"      in","counters":[]},{"line":"      Timer.clock __LOC__ ;","counters":[]},{"line":"      let data : _ Types_map.Compiled.t =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { branches = Branches.n","counters":[]},{"line":"        ; proofs_verifieds","counters":[]},{"line":"        ; max_proofs_verified","counters":[]},{"line":"        ; public_input = typ","counters":[]},{"line":"        ; wrap_key = Lazy.map wrap_vk ~f:Verification_key.commitments","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"        ; wrap_vk = Lazy.map wrap_vk ~f:Verification_key.index","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"        ; wrap_domains","counters":[]},{"line":"        ; step_domains","counters":[]},{"line":"        ; step_uses_lookup","counters":[]},{"line":"        }","counters":[]},{"line":"      in","counters":[]},{"line":"      Timer.clock __LOC__ ;","counters":[]},{"line":"      Types_map.add_exn self data ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      (provers, wrap_vk, disk_key, !cache_handle)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Side_loaded = struct","counters":[]},{"line":"    module V = Verification_key","counters":[]},{"line":"","counters":[]},{"line":"    module Verification_key = struct","counters":[]},{"line":"      include Side_loaded_verification_key","counters":[]},{"line":"","counters":[]},{"line":"      let to_input (t : t) =","counters":[]},{"line":"        to_input ~field_of_int:Impls.Step.Field.Constant.of_int t","counters":[{"col_start":8,"col_end":8,"count":1}]},{"line":"","counters":[]},{"line":"      let of_compiled tag : t =","counters":[]},{"line":"        let d = Types_map.lookup_compiled tag.Tag.id in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        { wrap_vk = Some (Lazy.force d.wrap_vk)","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"        ; wrap_index = Lazy.force d.wrap_key","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"        ; max_proofs_verified =","counters":[]},{"line":"            Pickles_base.Proofs_verified.of_nat","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"              (Nat.Add.n d.max_proofs_verified)","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"      module Max_width = Width.Max","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    let in_circuit tag vk =","counters":[]},{"line":"      Types_map.set_ephemeral tag { index = `In_circuit vk }","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let in_prover tag vk = Types_map.set_ephemeral tag { index = `In_prover vk }","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"","counters":[]},{"line":"    let create ~name ~max_proofs_verified ~uses_lookup ~typ =","counters":[]},{"line":"      Types_map.add_side_loaded ~name","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { max_proofs_verified","counters":[]},{"line":"        ; public_input = typ","counters":[]},{"line":"        ; branches = Verification_key.Max_branches.n","counters":[]},{"line":"        ; step_uses_lookup = uses_lookup","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"    module Proof = struct","counters":[]},{"line":"      include Proof.Proofs_verified_max","counters":[]},{"line":"","counters":[]},{"line":"      let of_proof : _ Proof.t -> t = Wrap_hack.pad_proof","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    let verify_promise (type t) ~(typ : (_, t) Impls.Step.Typ.t)","counters":[]},{"line":"        (ts : (Verification_key.t * t * Proof.t) list) =","counters":[]},{"line":"      let m =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ( module struct","counters":[]},{"line":"          type nonrec t = t","counters":[]},{"line":"","counters":[]},{"line":"          let to_field_elements =","counters":[]},{"line":"            let (Typ typ) = typ in","counters":[]},{"line":"            fun x -> fst (typ.value_to_fields x)","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"        end : Intf.Statement_value","counters":[]},{"line":"          with type t = t )","counters":[]},{"line":"      in","counters":[]},{"line":"      (* TODO: This should be the actual max width on a per proof basis *)","counters":[]},{"line":"      let max_proofs_verified =","counters":[]},{"line":"        (module Verification_key.Max_width : Nat.Intf","counters":[]},{"line":"          with type n = Verification_key.Max_width.n )","counters":[]},{"line":"      in","counters":[]},{"line":"      with_return (fun { return } ->","counters":[]},{"line":"          List.map ts ~f:(fun (vk, x, p) ->","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"              let vk : V.t =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                { commitments = vk.wrap_index","counters":[]},{"line":"                ; index =","counters":[]},{"line":"                    ( match vk.wrap_vk with","counters":[]},{"line":"                    | None ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        return (Promise.return false)","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"                    | Some x ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        x )","counters":[]},{"line":"                ; data =","counters":[]},{"line":"                    (* This isn't used in verify_heterogeneous, so we can leave this dummy *)","counters":[]},{"line":"                    { constraints = 0 }","counters":[]},{"line":"                }","counters":[]},{"line":"              in","counters":[]},{"line":"              Verify.Instance.T (max_proofs_verified, m, vk, x, p) )","counters":[]},{"line":"          |> Verify.verify_heterogenous )","counters":[]},{"line":"","counters":[]},{"line":"    let verify ~typ ts = verify_promise ~typ ts |> Promise.to_deferred","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"","counters":[]},{"line":"    let srs_precomputation () : unit =","counters":[]},{"line":"      let srs = Tock.Keypair.load_urs () in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      List.iter [ 0; 1; 2 ] ~f:(fun i ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          Kimchi_bindings.Protocol.SRS.Fq.add_lagrange_basis srs","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (Domain.log2_size (Common.wrap_domains ~proofs_verified:i).h) )","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let compile_promise :","counters":[]},{"line":"      type var value a_var a_value ret_var ret_value auxiliary_var auxiliary_value prev_varss prev_valuess prev_ret_varss prev_ret_valuess widthss heightss max_proofs_verified branches.","counters":[]},{"line":"         ?self:(var, value, max_proofs_verified, branches) Tag.t","counters":[]},{"line":"      -> ?cache:Key_cache.Spec.t list","counters":[]},{"line":"      -> ?disk_keys:","counters":[]},{"line":"           (Cache.Step.Key.Verification.t, branches) Vector.t","counters":[]},{"line":"           * Cache.Wrap.Key.Verification.t","counters":[]},{"line":"      -> ?return_early_digest_exception:bool","counters":[]},{"line":"      -> public_input:","counters":[]},{"line":"           ( var","counters":[]},{"line":"           , value","counters":[]},{"line":"           , a_var","counters":[]},{"line":"           , a_value","counters":[]},{"line":"           , ret_var","counters":[]},{"line":"           , ret_value )","counters":[]},{"line":"           Inductive_rule.public_input","counters":[]},{"line":"      -> auxiliary_typ:(auxiliary_var, auxiliary_value) Impls.Step.Typ.t","counters":[]},{"line":"      -> branches:(module Nat.Intf with type n = branches)","counters":[]},{"line":"      -> max_proofs_verified:","counters":[]},{"line":"           (module Nat.Add.Intf with type n = max_proofs_verified)","counters":[]},{"line":"      -> name:string","counters":[]},{"line":"      -> constraint_constants:Snark_keys_header.Constraint_constants.t","counters":[]},{"line":"      -> choices:","counters":[]},{"line":"           (   self:(var, value, max_proofs_verified, branches) Tag.t","counters":[]},{"line":"            -> ( prev_varss","counters":[]},{"line":"               , prev_valuess","counters":[]},{"line":"               , widthss","counters":[]},{"line":"               , heightss","counters":[]},{"line":"               , a_var","counters":[]},{"line":"               , a_value","counters":[]},{"line":"               , ret_var","counters":[]},{"line":"               , ret_value","counters":[]},{"line":"               , auxiliary_var","counters":[]},{"line":"               , auxiliary_value )","counters":[]},{"line":"               H4_6.T(Inductive_rule).t )","counters":[]},{"line":"      -> unit","counters":[]},{"line":"      -> (var, value, max_proofs_verified, branches) Tag.t","counters":[]},{"line":"         * Cache_handle.t","counters":[]},{"line":"         * (module Proof_intf","counters":[]},{"line":"              with type t = (max_proofs_verified, max_proofs_verified) Proof.t","counters":[]},{"line":"               and type statement = value )","counters":[]},{"line":"         * ( prev_valuess","counters":[]},{"line":"           , widthss","counters":[]},{"line":"           , heightss","counters":[]},{"line":"           , a_value","counters":[]},{"line":"           , ( ret_value","counters":[]},{"line":"             * auxiliary_value","counters":[]},{"line":"             * (max_proofs_verified, max_proofs_verified) Proof.t )","counters":[]},{"line":"             Promise.t )","counters":[]},{"line":"           H3_2.T(Prover).t =","counters":[]},{"line":"   (* This function is an adapter between the user-facing Pickles.compile API","counters":[]},{"line":"      and the underlying Make(_).compile function which builds the circuits.","counters":[]},{"line":"   *)","counters":[]},{"line":"   fun ?self ?(cache = []) ?disk_keys ?(return_early_digest_exception = false)","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":72,"col_end":72,"count":0}]},{"line":"       ~public_input ~auxiliary_typ ~branches ~max_proofs_verified ~name","counters":[]},{"line":"       ~constraint_constants ~choices () ->","counters":[]},{"line":"    let self =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      match self with","counters":[]},{"line":"      | None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          { Tag.id = Type_equal.Id.create ~name sexp_of_opaque","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"          ; kind = Compiled","counters":[]},{"line":"          }","counters":[]},{"line":"      | Some self ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          self","counters":[]},{"line":"    in","counters":[]},{"line":"    (* Extract to_fields methods from the public input declaration. *)","counters":[]},{"line":"    let (a_var_to_fields : a_var -> _), (a_value_to_fields : a_value -> _) =","counters":[]},{"line":"      match public_input with","counters":[]},{"line":"      | Input (Typ typ) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ( (fun x -> fst (typ.var_to_fields x))","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"          , fun x -> fst (typ.value_to_fields x) )","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"      | Output _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ((fun () -> [||]), fun () -> [||])","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"      | Input_and_output (Typ typ, _) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ( (fun x -> fst (typ.var_to_fields x))","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"          , fun x -> fst (typ.value_to_fields x) )","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"    in","counters":[]},{"line":"    let module A_var = struct","counters":[]},{"line":"      type t = a_var","counters":[]},{"line":"","counters":[]},{"line":"      let to_field_elements = a_var_to_fields","counters":[]},{"line":"    end in","counters":[]},{"line":"    let module A_value = struct","counters":[]},{"line":"      type t = a_value","counters":[]},{"line":"","counters":[]},{"line":"      let to_field_elements = a_value_to_fields","counters":[]},{"line":"    end in","counters":[]},{"line":"    let module Ret_var = struct","counters":[]},{"line":"      type t = ret_var","counters":[]},{"line":"    end in","counters":[]},{"line":"    let module Ret_value = struct","counters":[]},{"line":"      type t = ret_value","counters":[]},{"line":"    end in","counters":[]},{"line":"    let module Auxiliary_var = struct","counters":[]},{"line":"      type t = auxiliary_var","counters":[]},{"line":"    end in","counters":[]},{"line":"    let module Auxiliary_value = struct","counters":[]},{"line":"      type t = auxiliary_value","counters":[]},{"line":"    end in","counters":[]},{"line":"    let module M =","counters":[]},{"line":"      Make (A_var) (A_value) (Ret_var) (Ret_value) (Auxiliary_var)","counters":[]},{"line":"        (Auxiliary_value)","counters":[]},{"line":"    in","counters":[]},{"line":"    let rec conv_irs :","counters":[]},{"line":"        type v1ss v2ss v3ss v4ss wss hss.","counters":[]},{"line":"           ( v1ss","counters":[]},{"line":"           , v2ss","counters":[]},{"line":"           , wss","counters":[]},{"line":"           , hss","counters":[]},{"line":"           , a_var","counters":[]},{"line":"           , a_value","counters":[]},{"line":"           , ret_var","counters":[]},{"line":"           , ret_value","counters":[]},{"line":"           , auxiliary_var","counters":[]},{"line":"           , auxiliary_value )","counters":[]},{"line":"           H4_6.T(Inductive_rule).t","counters":[]},{"line":"        -> (v1ss, v2ss, wss, hss) H4.T(M.IR).t = function","counters":[]},{"line":"      | [] ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          []","counters":[]},{"line":"      | r :: rs ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          r :: conv_irs rs","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"    in","counters":[]},{"line":"    let provers, wrap_vk, wrap_disk_key, cache_handle =","counters":[]},{"line":"      M.compile ~return_early_digest_exception ~self ~cache ?disk_keys ~branches","counters":[]},{"line":"        ~max_proofs_verified ~name ~public_input ~auxiliary_typ","counters":[]},{"line":"        ~constraint_constants","counters":[]},{"line":"        ~choices:(fun ~self -> conv_irs (choices ~self))","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"        ()","counters":[]},{"line":"    in","counters":[]},{"line":"    let (module Max_proofs_verified) = max_proofs_verified in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let T = Max_proofs_verified.eq in","counters":[]},{"line":"    let module Value = struct","counters":[]},{"line":"      type t = value","counters":[]},{"line":"","counters":[]},{"line":"      let typ : (var, value) Impls.Step.Typ.t =","counters":[]},{"line":"        match public_input with","counters":[]},{"line":"        | Input typ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            typ","counters":[]},{"line":"        | Output typ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            typ","counters":[]},{"line":"        | Input_and_output (input_typ, output_typ) ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Impls.Step.Typ.(input_typ * output_typ)","counters":[]},{"line":"","counters":[]},{"line":"      let to_field_elements =","counters":[]},{"line":"        let (Typ typ) = typ in","counters":[]},{"line":"        fun x -> fst (typ.value_to_fields x)","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"    end in","counters":[]},{"line":"    let module P = struct","counters":[]},{"line":"      type statement = value","counters":[]},{"line":"","counters":[]},{"line":"      type return_type = ret_value","counters":[]},{"line":"","counters":[]},{"line":"      module Max_local_max_proofs_verified = Max_proofs_verified","counters":[]},{"line":"","counters":[]},{"line":"      module Max_proofs_verified_vec = Nvector (struct","counters":[]},{"line":"        include Max_proofs_verified","counters":[]},{"line":"      end)","counters":[]},{"line":"","counters":[]},{"line":"      include","counters":[]},{"line":"        Proof.Make","counters":[]},{"line":"          (struct","counters":[]},{"line":"            include Max_proofs_verified","counters":[]},{"line":"          end)","counters":[]},{"line":"          (struct","counters":[]},{"line":"            include Max_local_max_proofs_verified","counters":[]},{"line":"          end)","counters":[]},{"line":"","counters":[]},{"line":"      let id = wrap_disk_key","counters":[]},{"line":"","counters":[]},{"line":"      let verification_key = wrap_vk","counters":[]},{"line":"","counters":[]},{"line":"      let verify_promise ts =","counters":[]},{"line":"        verify_promise","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ( module struct","counters":[]},{"line":"            include Max_proofs_verified","counters":[]},{"line":"          end )","counters":[]},{"line":"          (module Value)","counters":[]},{"line":"          (Lazy.force verification_key)","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"          ts","counters":[]},{"line":"","counters":[]},{"line":"      let verify ts = verify_promise ts |> Promise.to_deferred","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"      let statement (T p : t) =","counters":[]},{"line":"        p.statement.messages_for_next_step_proof.app_state","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    end in","counters":[]},{"line":"    (self, cache_handle, (module P), provers)","counters":[]},{"line":"","counters":[]},{"line":"  let compile ?self ?cache ?disk_keys ~public_input ~auxiliary_typ ~branches","counters":[]},{"line":"      ~max_proofs_verified ~name ~constraint_constants ~choices () =","counters":[]},{"line":"    let self, cache_handle, proof_module, provers =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      compile_promise ?self ?cache ?disk_keys ~public_input ~auxiliary_typ","counters":[]},{"line":"        ~branches ~max_proofs_verified ~name ~constraint_constants ~choices ()","counters":[]},{"line":"    in","counters":[]},{"line":"    let rec adjust_provers :","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        type a1 a2 a3 a4 s1 s2_inner.","counters":[]},{"line":"           (a1, a2, a3, s1, s2_inner Promise.t) H3_2.T(Prover).t","counters":[]},{"line":"        -> (a1, a2, a3, s1, s2_inner Deferred.t) H3_2.T(Prover).t = function","counters":[]},{"line":"      | [] ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          []","counters":[]},{"line":"      | prover :: tl ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (fun ?handler public_input ->","counters":[]},{"line":"            Promise.to_deferred (prover ?handler public_input) )","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"          :: adjust_provers tl","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"    in","counters":[]},{"line":"    (self, cache_handle, proof_module, adjust_provers provers)","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"","counters":[]},{"line":"  module Provers = H3_2.T (Prover)","counters":[]},{"line":"  module Proof0 = Proof","counters":[]},{"line":"","counters":[]},{"line":"  let%test_module \"test no side-loaded\" =","counters":[]},{"line":"    ( module struct","counters":[]},{"line":"      let () = Tock.Keypair.set_urs_info []","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"      let () = Tick.Keypair.set_urs_info []","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"      (*","counters":[]},{"line":"    let%test_unit \"test deserialization and verification for side-loaded keys\" =","counters":[]},{"line":"      Side_loaded.srs_precomputation () ;","counters":[]},{"line":"      let pi =","counters":[]},{"line":"        match","counters":[]},{"line":"          \"KChzdGF0ZW1lbnQoKHByb29mX3N0YXRlKChkZWZlcnJlZF92YWx1ZXMoKHBsb25rKChhbHBoYSgoaW5uZXIoNTI4Y2RiZjE2NzA4YTUzYSAxZjkwYTdlZWEyZTA2ZjZhKSkpKShiZXRhKDYxN2U1YTdmZDZiZTM2NmEgZGUxOTcxMjJhNDQxNTE3NSkpKGdhbW1hKDNjYTM1ZDQ0NTIxODFjOTkgMTBmMDg1NDBiYTYxYjBlYykpKHpldGEoKGlubmVyKDliOWNiM2ViODlmOTk4NjAgZmMzZjJhNTU2YjNkYTNiOCkpKSkpKShjb21iaW5lZF9pbm5lcl9wcm9kdWN0KFNoaWZ0ZWRfdmFsdWUgMHgwODIzRTU2NzkzQjU1OTI2MTRBREJBNEQwRTVGRTcxODJDMzYwNTlFRkE2N0I2MkZGMzQ4QzI5ODAyNUVEM0IxKSkoYihTaGlmdGVkX3ZhbHVlIDB4MTVFNkU1ODMwODhGMzgzOUEwQTI0QkEwOTYwNThEMzExRjgwRTYzREM3QzVGOTY5NjFFREYwRTg0MzFCM0E4OSkpKHhpKChpbm5lcig1Yzc4YjUxMDZkYzkxOTZiIGRkOTIzNjA4ZjNhMmQ3YzcpKSkpKGJ1bGxldHByb29mX2NoYWxsZW5nZXMoKChwcmVjaGFsbGVuZ2UoKGlubmVyKDAyNzdmNmFhZDlkODM1YTUgZDdjZTY0NGFmMWUwYTYyMykpKSkpKChwcmVjaGFsbGVuZ2UoKGlubmVyKDcxNTVjOGNhMjcwODkwYTkgODgyMTBlZjUwNWQ3NDYzYSkpKSkpKChwcmVjaGFsbGVuZ2UoKGlubmVyKDY2ZGQwOWNmOGM3NjdjYTggNDlhMWYzZjBkMDJjMjdkMSkpKSkpKChwcmVjaGFsbGVuZ2UoKGlubmVyKGIzYWY1YjdmZmY3N2QzZGQgN2UzZDUzYjJkNjk5ZDIxMCkpKSkpKChwcmVjaGFsbGVuZ2UoKGlubmVyKDFhNzAzNDcyMmYzOWM2ODAgZGFjMGI5MjA3MTBhM2JhZikpKSkpKChwcmVjaGFsbGVuZ2UoKGlubmVyKDMxYTM5MTk2M2ExZWRhMjIgMTc2OGY5NjNmZGEzMGRiZCkpKSkpKChwcmVjaGFsbGVuZ2UoKGlubmVyKGNhNjk3N2JjMmNkMDhmMDIgOGNjYTA4MGEzZWVhOTFkZSkpKSkpKChwcmVjaGFsbGVuZ2UoKGlubmVyKGNhMWM0NDU5YzZkYjkwZTAgNWRjOTc0NDQyMjQ2OTJiOCkpKSkpKChwcmVjaGFsbGVuZ2UoKGlubmVyKDVhODY5MWZlOTM4ZDc3NjYgZmZhN2I3NmQ1MDU0NTMwMCkpKSkpKChwcmVjaGFsbGVuZ2UoKGlubmVyKGUyOGE2YmQ3ODg1ZTJkY2UgY2ZmYzcxMGZkMDIzZmNmMikpKSkpKChwcmVjaGFsbGVuZ2UoKGlubmVyKDY3YzljYWNkYmVjMTAxNTIgZGJiYmIxNzQ0NjUxNGNkYykpKSkpKChwcmVjaGFsbGVuZ2UoKGlubmVyKGI5NjI2OTBkNGM2MTQ3ZmUgMDQ3ZWQyYjY0MzJhZTlhOCkpKSkpKChwcmVjaGFsbGVuZ2UoKGlubmVyKDI0N2EzYzAyNmZkNDJhMWYgMzBmZmQzZWIyZTkyZjZlMCkpKSkpKChwcmVjaGFsbGVuZ2UoKGlubmVyKGZiMDQwYTVmN2FlMTY4MmEgNjdlODhjMDNiNDY0MjlmYikpKSkpKChwcmVjaGFsbGVuZ2UoKGlubmVyKGRhN2FhZWI5OTE0MmQ0OTAgZTZkZjFlZjJhMjdiZDVkZCkpKSkpKChwcmVjaGFsbGVuZ2UoKGlubmVyKGM5NTkwYmEyZDY1ZTc3NGMgNjUxM2JlOTc2ZGJiZDAxNCkpKSkpKSkoYnJhbmNoX2RhdGEoKHByb29mc192ZXJpZmllZCBOMCkoZG9tYWluX2xvZzIiXG4iKSkpKSkoc3BvbmdlX2RpZ2VzdF9iZWZvcmVfZXZhbHVhdGlvbnMoMzQ1YmNhODlhMThiZTZlYiAzMmIzMmJlYTk4NTNjZTUxIGU0Yjc4YmQwOWJiYjY4YTUgMGM2NzkxZmIwOGUwY2E1NykpKG1lX29ubHkoKGNoYWxsZW5nZV9wb2x5bm9taWFsX2NvbW1pdG1lbnQoMHgwRjY5QjY1QTU4NTVGM0EzOThEMERGRDBDMTMxQjk2MTJDOUYyMDYxRDJGMDZFNjc2RjYxMkM0OEQ4MjdFMUU2IDB4MENDQUYzRjAzRjlEMkMzQzNENDRFMDlBMTIxMDY5MTFGQTY5OURGOTM0RjcwNkU2MjEzMUJBRDYzOUYzMDE1NSkpKG9sZF9idWxsZXRwcm9vZl9jaGFsbGVuZ2VzKCgoKHByZWNoYWxsZW5nZSgoaW5uZXIoMzM4MmIzYzlhY2U2YmY2ZiA3OTk3NDM1OGY5NzYxODYzKSkpKSkoKHByZWNoYWxsZW5nZSgoaW5uZXIoZGQzYTJiMDZlOTg4ODc5NyBkZDdhZTY0MDI5NDRhMWM3KSkpKSkoKHByZWNoYWxsZW5nZSgoaW5uZXIoYzZlOGU1MzBmNDljOWZjYiAwN2RkYmI2NWNkYTA5Y2RkKSkpKSkoKHByZWNoYWxsZW5nZSgoaW5uZXIoNTMyYzU5YTI4NzY5MWExMyBhOTIxYmNiMDJhNjU2ZjdiKSkpKSkoKHByZWNoYWxsZW5nZSgoaW5uZXIoZTI5Yzc3YjE4ZjEwMDc4YiBmODVjNWYwMGRmNmIwY2VlKSkpKSkoKHByZWNoYWxsZW5nZSgoaW5uZXIoMWRiZGE3MmQwN2IwOWM4NyA0ZDFiOTdlMmU5NWYyNmEwKSkpKSkoKHByZWNoYWxsZW5nZSgoaW5uZXIoOWM3NTc0N2M1NjgwNWYxMSBhMWZlNjM2OWZhY2VmMWU4KSkpKSkoKHByZWNoYWxsZW5nZSgoaW5uZXIoNWMyYjhhZGZkYmU5NjA0ZCA1YThjNzE4Y2YyMTBmNzliKSkpKSkoKHByZWNoYWxsZW5nZSgoaW5uZXIoMjJjMGIzNWM1MWUwNmI0OCBhNjg4OGI3MzQwYTk2ZGVkKSkpKSkoKHByZWNoYWxsZW5nZSgoaW5uZXIoOTAwN2Q3YjU1ZTc2NjQ2ZSBjMWM2OGIzOWRiNGU4ZTEyKSkpKSkoKHByZWNoYWxsZW5nZSgoaW5uZXIoNDQ0NWUzNWUzNzNmMmJjOSA5ZDQwYzcxNWZjOGNjZGU1KSkpKSkoKHByZWNoYWxsZW5nZSgoaW5uZXIoNDI5ODgyODQ0YmJjYWE0ZSA5N2E5MjdkN2QwYWZiN2JjKSkpKSkoKHByZWNoYWxsZW5nZSgoaW5uZXIoOTljYTNkNWJmZmZkNmU3NyBlZmU2NmE1NTE1NWM0Mjk0KSkpKSkoKHByZWNoYWxsZW5nZSgoaW5uZXIoNGI3ZGIyNzEyMTk3OTk1NCA5NTFmYTJlMDYxOTNjODQwKSkpKSkoKHByZWNoYWxsZW5nZSgoaW5uZXIoMmNkMWNjYmViMjA3NDdiMyA1YmQxZGUzY2YyNjQwMjFkKSkpKSkpKCgocHJlY2hhbGxlbmdlKChpbm5lcigzMzgyYjNjOWFjZTZiZjZmIDc5OTc0MzU4Zjk3NjE4NjMpKSkpKSgocHJlY2hhbGxlbmdlKChpbm5lcihkZDNhMmIwNmU5ODg4Nzk3IGRkN2FlNjQwMjk0NGExYzcpKSkpKSgocHJlY2hhbGxlbmdlKChpbm5lcihjNmU4ZTUzMGY0OWM5ZmNiIDA3ZGRiYjY1Y2RhMDljZGQpKSkpKSgocHJlY2hhbGxlbmdlKChpbm5lcig1MzJjNTlhMjg3NjkxYTEzIGE5MjFiY2IwMmE2NTZmN2IpKSkpKSgocHJlY2hhbGxlbmdlKChpbm5lcihlMjljNzdiMThmMTAwNzhiIGY4NWM1ZjAwZGY2YjBjZWUpKSkpKSgocHJlY2hhbGxlbmdlKChpbm5lcigxZGJkYTcyZDA3YjA5Yzg3IDRkMWI5N2UyZTk1ZjI2YTApKSkpKSgocHJlY2hhbGxlbmdlKChpbm5lcig5Yzc1NzQ3YzU2ODA1ZjExIGExZmU2MzY5ZmFjZWYxZTgpKSkpKSgocHJlY2hhbGxlbmdlKChpbm5lcig1YzJiOGFkZmRiZTk2MDRkIDVhOGM3MThjZjIxMGY3OWIpKSkpKSgocHJlY2hhbGxlbmdlKChpbm5lcigyMmMwYjM1YzUxZTA2YjQ4IGE2ODg4YjczNDBhOTZkZWQpKSkpKSgocHJlY2hhbGxlbmdlKChpbm5lcig5MDA3ZDdiNTVlNzY2NDZlIGMxYzY4YjM5ZGI0ZThlMTIpKSkpKSgocHJlY2hhbGxlbmdlKChpbm5lcig0NDQ1ZTM1ZTM3M2YyYmM5IDlkNDBjNzE1ZmM4Y2NkZTUpKSkpKSgocHJlY2hhbGxlbmdlKChpbm5lcig0Mjk4ODI4NDRiYmNhYTRlIDk3YTkyN2Q3ZDBhZmI3YmMpKSkpKSgocHJlY2hhbGxlbmdlKChpbm5lcig5OWNhM2Q1YmZmZmQ2ZTc3IGVmZTY2YTU1MTU1YzQyOTQpKSkpKSgocHJlY2hhbGxlbmdlKChpbm5lcig0YjdkYjI3MTIxOTc5OTU0IDk1MWZhMmUwNjE5M2M4NDApKSkpKSgocHJlY2hhbGxlbmdlKChpbm5lcigyY2QxY2NiZWIyMDc0N2IzIDViZDFkZTNjZjI2NDAyMWQpKSkpKSkpKSkpKSkocGFzc190aHJvdWdoKChhcHBfc3RhdGUoKSkoY2hhbGxlbmdlX3BvbHlub21pYWxfY29tbWl0bWVudHMoKSkob2xkX2J1bGxldHByb29mX2NoYWxsZW5nZXMoKSkpKSkpKHByZXZfZXZhbHMoKGV2YWxzKCgocHVibGljX2lucHV0IDB4MUQ1MDUwQUJDMTkzRkQ4Mjg4RkU4QjA5REE5QTJBQThDNEE5NUU3OTZDMzNERkI3MTJFOENDQUQ3MzY3MjY2QSkoZXZhbHMoKHcoKDB4MkMzM0MxNzNCREU5MzQwQkU5NDFFQ0QyMDlBQjZFOTlFQ0E4QkRDQTFDQThCREE4REFDM0U0MEMzMzE1RjY5NikoMHgwMkFFOTI5NjgzNDREMUY1OTYwM0JBMDE1QzI5RDc4MDE4OTdGNkI1OUU1RUQ0M0EzQkVFMzE2RDZBODc2QzNCKSgweDNENEZERDI0MDI4NEYwOTZCMEQ5Q0U0MDVDMjAxNkU3Q0FFNDk5MzFEMDU3MUYyN0RBN0EzRERCMjAyRkM0MzcpKDB4MUQ4QTlBMTdBQkRGRjU5NzU4MzJCMkVBNEFFQjk0QkFERTYzNDZBNTU0RUIyNEE1MUIzRUNGRjU2MEQzMzc0OCkoMHgzNkY4MDZGMDQzRDhGMzNGN0ZEODk3MzBGQjY5RTVEQUYzMjNFODYzN0QyM0Q5NTY5NDY2NUFCMUIyOUFEMTk0KSgweDIxQ0U2NzdFOTQxNjc4M0RCQTczMTBFMjgxM0QyMDAxMDRBMDMyOERDQTVDRjJDMEU2MzJCRkQ3MTk5NTFDQkQpKDB4MEEzNDY0RDVBQkJERjFDMUZBNkMzQ0Y1QzUzMjhDQkVEN0QxNDAyQUQ0OTkwQUYyRDA3Q0Y2OTU4NzAwRTA3OSkoMHgzMDY3OTIzQUY5M0M4NUJDNjc3NzE1Rjc4RUZFRTJCNzY1RjQ3MTJEOTJBMThERDY5MUIyRDYxNzI0NUQyODM3KSgweDFENzVFMUNDRTQxNjVGRDE5QkJGMUQ4MzRGMDM2NkUzMzMwQTkxNkYyNTI4MDFBQ0MyQTlGQ0NGRTE5QkIwM0YpKDB4Mjk3OTNDM0QzMTEzNTM0NDRDNEZDRjJCRjYyMjk5ODkzRjY5RkNFRjBBREY3MzQ1MzEwREI3RTczNkMyMTc1OCkoMHgzRjkwRTI0NDhDQUIyNjM5Nzg4RUVGMEVEQkQ0Rjg3NDYzMDgyRUFFMEM1MkY3MTBFMEE1N0I0MjM4NTc3QzA5KSgweDNFMTlFOUU0NUM2Q0ZDRjBGNzAzNkQzQTU5OEUyNkJDNEMyNTBBQjQ1MDQ5RTE5QTgxRUYzRjlDNjhFN0IwOUUpKDB4MzFDRjJGQzQ1QzU5RTQ1RTVCMTZBOUZBMzU3OTcyQUVGMUY3NDQzODhDODFDODg2QjI4QkRCQzU1ODE1Q0U0NSkoMHgyNEIzMTBBNDE4Q0I1ODE1NTEzRENDNUI0REJGNEIyQzY0QkQ5NEEyRDQ3NjQyOTRFRUJERjRDN0RFMUIxQjA4KSgweDNFNzQ4QjhCRjdGM0Y2MzIzNUI2NTBEQjg3M0JENjUyQkM1OERCMUM2N0M5NEFGMDNCMjE4REI1OENBMEVBODYpKSkoeigweDNGQTY3NDFEODRFMTE0MzRENzkxOEE0NTlBRDFCNjk4QjhGMzYxNkUyQTkwMUIzQjE3RTlFMEJBOEMyMjlBOTUpKShzKCgweDIxNjAyODVBNzg4MDMxQzQ1QjBFMDQxQzBDM0UxMzIyRTEzMzBDNzE4QjcwOTk5OUU2NzdFNEM4MkMxQThERUMpKDB4MkNDMUVFMTE1NEY1MjdCMzNBMDExQTVGODE2QUZDM0MyMTk4OTJEMENDM0EyNTUwMUE5MDE4M0EyMjIxQjg0NykoMHgyOTkzNjZEN0JEQjUwQ0QyNzhCREI0M0ZGQ0MxQUY2NkNGRDZDODIxMjAzRjk4MEFDMjJBOUUwMTc4NjEyRkNDKSgweDA0MjA0NzU5RTdEOEU4NEMxMTIyQkNGNjUwMDhBQkFDMDE3REU3REFFNDRCN0U0NzlEMzA3NzM5NjZFQjZCMEEpKDB4MDhENUFCREIzOENFRUE2RDUwRkMzNzhGQ0NFQTY1MTE2QzI5OEVFMDMwN0Q4MjdGRjY3NDQ3NTAyQzVDNUEyMykoMHgwQUIxQjE2MDVDMDdGQjA1NTQxNDMwOEZEOUQzODcyRDExODRBQzQzNkJGNjJCRTA2QkY2OEE0MjlFQjgwNkM4KSkpKGdlbmVyaWNfc2VsZWN0b3IoMHgyMDczRTU3RUNBMDk3Q0RCNDM0OUY1NkE5NkREODcwRUY0MjMyRjU0NzYyNEJGREQ3QUZGREY4NDA3ODI2MDAwKSkocG9zZWlkb25fc2VsZWN0b3IoMHgxNDEyNjQxRjM3OEI3QjRBQTJERjFCMjk1NzNFM0JCQTJFMDkyRTc0RDQ4Q0M4Q0EwM0JGQkQ4ODc1NUY1REQ1KSkpKSkoKHB1YmxpY19pbnB1dCAweDBFRkMwQ0M0RTg2MDRDQjRCMzM3QjIzN0JCNDY5MTYxMTBGNTYwNDA0MTY2OUUzOEVCMTcxMkM3OEE4NjUzOUQpKGV2YWxzKCh3KCgweDMwQzgxMjQ1NUQ4NDBGMDlCMUExMEQ3M0U2MDdGMUNEMjNGMDk3N0UyMDU5NDZERDcyNTIxNDlDM0M4RUIyRUIpKDB4MDMwMTA4MkZDODVBODVBNUM1RTQ4NDgzQ0IyMzFGNjRCRTRFNDJBREI3QUI3M0I5NzMwMzRGOTJDMjAwODI0MykoMHgxQUMyNjNDMjkzQjU0OEU3ODYyMjM0NDgxODY1QTZDNDI1NTE4MEYzM0Q1RkNCMUUzMDM2MERDNUFBNEE4MTY0KSgweDI2NzlCMDM5MDFBQTJBMjg2REYxRTJBOTBCQzcyQTNBRjU3QzEzREQ2NUI5QkIxMTEwNERCOTE4OUFEQkI5NzApKDB4MzlGMENGRTUxMzNENENDM0I1OThGMUY2RUExNjAwNDY2MURGN0JBNkQxMzE2QzM4RTEyNEM2NUVGNEYyMUM5NSkoMHgxNjQ1N0RGRDZCRjMyM0JFMTMxNjI3NzlFQjBGNDhDQUQzQUQ4RDQ5NzBFOUU2NDMzRjI3NUIyMjI2Q0Y5OUQ5KSgweDJBRjQzNkZFMEZBRjBDQjkwNUREODIwMkREQzQyQzA5RDE1NjVDRTQxNUZENDRGMzMxNzhEOTRCMUJGNzYxMjcpKDB4MjZBOTE0RjdENTVBQzMxMjkxOEQ0MUZEQTUxNjM0MkU5MjkwMzRDMDZEMTk3MDc5NEMxMTU2RkY4NjkwQjBFNikoMHgwQkREREIyNzZCOUNERjRCMkM5QjRDNkI0M0YyRjMwMkQ0NkUyQTAxMDQ3MjRENzc3OUI3MTRDQzFDMTNEMTBDKSgweDA1N0MwNDVGNERBNzIwMjMxN0U0QTQ3OTUyQkVGMTlEMTA5NDc1NzQ5RkM4QkYwRUQ5MjQ0RkQ2QkRCMjBDQzMpKDB4M0FEOTgwNUJFODYzNDVCM0ZFOTgzNjdEMkFEQUFBRjZBM0IyQTUxMUI3MDExRDM1NENDMDc0QkIwRjBCNjE4QykoMHgwODY0QkIyREY2MEYyOUJFQkM4RDU1REVDMkI2RjE5OURGNTNDQjY1MEJENzk3RDhDODFBQTdEMzlGN0E0OTRDKSgweDM3NUYyMTUzNkI2NkU4MTZEQ0ZDRTgyOTQ5NUE3QjQyOUNBMUVCNjU4MTIzREU4ODU4Qjc2NURCMjZEMURDNjgpKDB4MzREMUI1OUEzMzM2OTM1MDg2N0VFMEU1MzhDNjhENjkzRTE5QkQ1RjhGMDVGQkRFNTI4MjhBNkFFMzk2NjZDQSkoMHgzODFBRDI4NTMzNEE3ODg0NjkwRjNBQjg0MTIyOTFGQ0IwRDMzNTcxNjlDMEYxNzZEMkE2REI4RDJCM0ZDMDJCKSkpKHooMHgyRkI0MTUzNkU0NjU1QzExOUJFNUYwREVEOTAzOTFBODE3MUMxOTFCM0E5NzY0Rjc2NUZCQjZFQkYyQUFCQUM5KSkocygoMHgzRjU1MjJBMUQ4QTBBQkZBODg3NkI0MTg1RTlDQTFGODg1NjYzRjU1NTc5QzM5RjczNTJGOTgxQ0IzMDRDQ0VGKSgweDJFMDcwMEQ2RjhBMDJDMDRCMURGRTYzMDg5NkI1OTYxNUYyMUM0QjNCNTQxRTI2RUU2M0RCQ0ZERkU1OUQ2NTgpKDB4MTBGNzMyN0M4MzNFQjM1QjQ0OTlBRDRBMUVGMEJDQjY2ODYxODIyMzgxREVCMENDNjc5OUU3MTgyODkyQkQyNikoMHgyOUFCOEY0QzdFMjU2RDJENzcwM0UzNjhGOTEwMUJFRDAyMTVFMDhDRUM4N0FBNTQ5OUNGQTdEMUU5RTExNjU3KSgweDE2NTIzRERGNDM4QUNGMkMwNzJEQzdGMDBDNDFGMUUzQTUyMTQ3NjFDNzdEMjUzMzk3MEE5MzgyQjVCNDhEMzApKDB4MEQ2ODRBNDYwQjM0ODA4MkY1RUZCMDNGN0E2MzVCNTM1OEU1MjIzNTgyMUQzNjI1MUQ2NzY0NENFNjk0QUJDNCkpKShnZW5lcmljX3NlbGVjdG9yKDB4MkIyMDRCODU5NTI5OUQyMkNDODNERTZFMkE3OEQ0QUYzOUFBRTg1MjdGQjRCMjk3QTM1MDUxRjM3NkFFMTBDNikpKHBvc2VpZG9uX3NlbGVjdG9yKDB4MzcwQzdEQUM1OERCMURBQjExNDdEQUE4QkJGN0VFMUYxRTJDMkVBQjY0QkVFRDg4NUNBMTRGQzg2RDc4NjQ1OSkpKSkpKSkoZnRfZXZhbDEgMHgwNDU5REU5RUE3NEI4Q0IzOEI1NDQ1NEZBMEY1OUQzNzUzMDdCMTIxMEY3NDAzNTI2MTUzRDVDQzEyODhERTYzKSkpKHByb29mKChtZXNzYWdlcygod19jb21tKCgoMHgzRTJDRjhGREI3RjI1Q0MzRDUyM0U4ODczNUNDOEIwMDY4QTQzNkExMDdEOTI2OTc3QjQ0MDg5NTVBRkI1QTdEIDB4MzJDRUU5NTVFQzVCRkNGMjY5QTA1MEM1MEM5RUQ4Njg2NjRGMjZBRURCNEZDQzk2QTJFQjIyQzRFOTAzMUFDQykpKCgweDIwMjlGNTRDRTNGRTEyNTUwMDVEQzZFMEQ1NkY0NUVENDZEOTI5NEEyMDIxQUQ3QzREOUVDQjlBMkZDMzVEREMgMHgyMDA5OEU5RUI0Mzc0MTRGODYxQzhCQjVGREYzMTExRUIzQzY3MDdEQzE1NkZGRUUzRjNCNzEyRkI2N0Y0QTJFKSkoKDB4MTExMEFFM0YwNUEzREYyRkU0MTQ5RUI3MTI1QjdDRjMxNUQwMUQ2QkZCREM0RTFFQkVBMDVBREQ2MzM0NzBGRCAweDMwQkFFRjA5MUMxNjVCOEZDRkFGQUE5NkMwRkI5RUI1OUE2RkQ5ODE3Njg5NzQyMzA0MzYyM0FGQjhEQ0IwODQpKSgoMHgzMzk1RDI5OTNDQ0JCOUMwQTIyQkUzMjFENzBGNUYwMUYzOUI4M0Q3OEQ3RDM2ODRERTdFRkVGNzFDOUVFRDk0IDB4M0E5OUEwNzhEQTcwNkYzQzQzQjZDMDgxREU1QTA5QTY5RDJEMzA4QkE1MEI5NjFDQUM2QTY2NEUzRDRFOEUzRSkpKCgweDI1OEM1NkZBMzJCNTU1QkZDMzI4OEY2RUVBQTExMzQ0RTQ0MzBDNTFGM0VENkE1OUYzNUY3NDlGOUZBRjA4NEUgMHgxRDQ3QUMzNDFFRjdBQTc2RjE1RjAyMzlBNDk0QTU0MUUwMThDMTEzQUNENjJFODdGQUE3NzY0RTIzMjUxOTQ0KSkoKDB4MkMwNDMxMUI4MUVEMjkyNDBERTlEQTYyMkM4OTQzMjMyMzZERDYyMzg0NkU4M0MwODMwOUQxQzU1MkIwNjUwMyAweDI0MzgwMzZFRTdFRjJFQUVCOTIxNkE4NDM2OTJBMkZBNDVGOEI1OTUxMDdEOUVBNkMwNTUyM0M4Mjc0RENERkUpKSgoMHgxOUMxREUxMzk4MjU4M0EyMkZBRDA0NTUzMDgyNDk5Qzg4MDU1QzBENzA3QzA5REM3NzY1MEVCQzE0NzE4RjZDIDB4MjYxMUIxRkM3MjFCOEI3M0IxMDk4ODZFNUEyOTYwQUJCQzVBNDcxNDcyRjJERTI3RjBCNzA5ODlCMEU2NDBCRikpKCgweDEzNjU1MDMxNUE0NDQwRTIyREIzMjkwNkUzQzdDOTU1Qjk2QzczNUU0MDU4RjFBRkY4QkRDRjc1QkUyMzI0QzggMHgzNEFCODdBNTkwQ0I0Qjk2NzRGMjhBNzVGNkNGOTI3NTdFODRFMTY0OUYzMkNBQkNCRTBCNzZBRUQxQTYwRThEKSkoKDB4MkVFOEQ1QkVBNEQ0NjAzMjFCOUJEMUI1OEJENUY5RUY3NkRGM0QwREVCQjAxNTE5MEQzMTdDNjFDNzM1ODRBQyAweDNEMzMwNDAzRTU0QkQxODlDNTU0NDgxNzBENTlENkY5RDNFRjQ4QzgwOTUyODFGNDU1ODhCOTJCNjEwNzUzNUYpKSgoMHgzNzBFMjMzNzU3MDdCNEU3NDQ4NjQxNUExNTNDQjFGMDExMUMyQjk1MEM4NzE3OEZBODU4OTFDQ0FCMEQzRDhBIDB4MEU3NUM1OThFNjM2ODgyMTdCRUZCQjVEQ0EwMjA0MzNDRTE1OEQ0RjgwNzBDNjM5ODIyNzVGODI2MUEzQ0U5NSkpKCgweDJFRkExNjAzNTBDQzQyODJFRTA2QUY0NjNFQzhDQTY5ODBBRjA3OTgzQTQyQjYyNzVFNDJGQzRBQTZFNjg1QzggMHgwRUVDQTlFREI1MTI2NTE4MkNCRUMxMEVGM0IwQUFGODFFRkI1M0U5QjkxOTk0MDE5NEMyNzI2QjlBNzg1RDFDKSkoKDB4MjdGRTY5RkY0QTcxNkUyREYxMzg5Q0ZDRDRDNDI1QjA1MEMwMDkzMUNERDEyM0MwQzVCRUE3REZGREQzRDYwMyAweDEyMkUwNTkzMTIwNjM1NUFBQjYwREJBRTA3N0Q0OTA4ODdERDFDQUE1OTlCQUMwNTQ1OEJDM0Y0MTQyOENCQjYpKSgoMHgzNjYzRTFDMUMyN0M2RjE2M0FCNTUyRTgzQjIxRkREQzVFQkFBM0I3MzVFRkZGRTM4QkFFOTlCMDFENzFEMDM3IDB4MkM0NkM5MTMzNkNFMzgxRjM5MDBCRDJBODBDMkIzNkE2QkM5MEM1RDUzQTU3OUUwMjI0MEJCQUJCMjAxOEU2MCkpKCgweDI2NjY3RTIzQTAwODVGRERBOTcwRDRDREM3OEQ2QTREOUM5RjAwMzA2MUY0MEY1QUU4RjgxOTg2QzBENkQyNjAgMHgyQjA1QTlGMTIwREFBQTM1NUY1NEU4RDBCOTZBNzhBNjc0ODk4RkIxODMwQTRFQjcxMzU2MTM3Qzg5ODRCREE1KSkoKDB4MTA1RDI0OTFFRUFFMDNEMUFBNEFEODkwODQxMkYzRUQwQjk4OEE0M0M0RjMzQzgxNTgxQzNBNjBGRUU5NzIxRiAweDJEQkFBRDU2QkZBMURDRERFNUNGRTQwNDgwQzhFOEU1N0UwMDkzRkVCMTUzRDlENEY5ODM0MDdCM0VBOTE0MTIpKSkpKHpfY29tbSgoMHgwMjlFRTdGNjREM0ZGRjFGNjkyMEQ2RjAwOTMwNEMyQzhGOUFCRjJCNzY5QUNENjlGN0Y3ODIwMUEwOUYxMEJCIDB4MzAxNDQ5NDgzQkYzQTY4ODU1MjE5MjkzNEUxMDM5MUQ3QkU5N0U1NEJFQjI2RjdBM0YzQjFBMjQ0M0NBMDdFQykpKSh0X2NvbW0oKDB4MjdFRDA1NkUyODg2NDY5M0FCMTY1M0Y2MkFERjVDNkY0N0RDQ0QwNzBFRjE2QTJFOTExMjgzMjI0MDE1OTIxRSAweDEwNzcyODRERDE1Rjk5MTQzRUZBQ0JBODVEM0RENjM2MDhGMjIyQ0Q2RDdDRjdBNzkzREZDNjQzOTBCN0RCRDgpKDB4MDdBMTBGOTVBNEY1NTU5N0Y2NkMzQzkyQkJGOUQ2OUEyM0M2RUU4NkNFMkM4NjRGQzBBMzVGQjE5OTk4MEI4OSAweDJCQzU2NEVDMDZCOEI3MDUyRjQ2OUMzRUM3NEFERDMyQzFDNzEzRUZBMTlGMjYxMDJFN0M3MzUyMEY5MEVEMkMpKDB4M0YzMEU5NkMzRDVBMjMxNzBGOTQ4OTU1NjU0MjJDNkQ1NEI4Qzg1OTREMTU0Q0I0OTVCRDgwODk0MTg0OEMyMSAweDE3Rjg1M0QzQzU4NjkwNDJDNjAwQzcxNzIwNjEwQTIxREQwNTdENjg5QTM0Q0YwOEU2QTcwNTRCMUJEREQ3MEMpKDB4MEMyN0ZBOEQyODI5QkNCREQ5MEUyNDU2NzczOTRERjcxNTFGN0M0RTk0RDk1ODMyOTYyRDcxODdGRUIzMzQzMiAweDA0NDJDNzNCQzdDMzc3OTFEQTlDRTBCRTYzMzJGNjkxNjZFRjZFNkY2NTFFMjNEODU5MjA3QjFGQURGOUUxQTkpKDB4MDM5QjkyMDA2N0Y1OUIzNDU4RjhDRkE2NjBCQzU4NUI3MDU4MjY5MDZCODg4OTNCODhDQURFMTk5MzA2MDRDNCAweDMzQUFBNjIyMTEzQTE0QkIxNDA4NTM4QjM4Q0E1MTU3QkNDODM1NTQ2QkMwODFCQTJEMzlFNUE2MzZGNzg1NEIpKDB4MEU3NkFFRTQ3NDg1MDczQURCNjZFODgyN0I3RjExQzk5Qjc0RjVEMzYwQUYxMkMzMjZERUJGRjQ1N0FCQjI5OCAweDE1RDdGNTlCRDZCRDBFNDlCMzZCQUUxQThFMTcwNzNGQUQzNDQyQjgyNjhENTBEMzI3RTg3Q0Q0Mzc0QzlFMkUpKDB4MjRCMTdDNDI3NThDRDk3N0RBMzFBNUQ2MTlEMEIwQ0M4ODVBMDc0RjEzREYxQjBEOTAzNkE1QkU5NjJGQUE2NiAweDMzQUJGNzU5NjRENDMxOEYyMUFBN0YzQzg4OUVBODhDNDk1RTEzMjJCMjlDODE2NDZDOTAxOTA2MjZBRjkzQTApKSkpKShvcGVuaW5ncygocHJvb2YoKGxyKCgoMHgwMThFODJCODVGNDMzODBFMzJDRURBRDU3MTg4NkRDREI2NTFGRDE2QzU0QUZBQ0M4QTVGMEZDQTFBMzVENzdBIDB4MDc1NThDOERFOTM2MjgyNkY1MkVEMUZDOUYzRkFDM0U2MEJFNkJGOUE2OTNGMUE5NjBDQjJGNTRCRjlBRDMwOCkoMHgyREQzNEFERjczMjM0MENFMTY2QTM5ODlDMjg2M0UwMEFBMjBFRThERDM2ODFBNkZDNDc5NDhEREMyMjkxOTE5IDB4MzlFRkIzNTkyOTI0Q0Y0OUY0NUQ1QjQ3MUFDRDY2QkQ2QTlENzJDN0YwMzRFQzc1NzAzNzQwNzM3RTA2OEZGOSkpKCgweDA1REQ3ODQ1QjBEMTkyMTJBQ0RGNjY2REQ5MEYzMDk5OTlCRjI4NzE5QjJBMUY3MEIyMjhBRjVEM0U1OUE2MzMgMHgyMDc3OTlBQjQyMDE1NUM2RkZFQ0RCMzUzOEIwRUYyMjU5RUVGNzc2QTMzQTc4MUFDNEYzRUY2QkNFRTYwNzAwKSgweDNBQUZDNEUyNEEyNUQyQUZGNzE0RjAwMDhGMjQ2NTQ5NkM2MkVCNkMxRjc1NjJFNjA1QzM4RUM1OURCREJDNjcgMHgzNzhGNUJBQ0NFNUM0QkQ2RkVGODYzMEY2OEM0MzlGOEZFOTg2RjIxOEE1NjJCMUVDMDU0RTA3RkM1ODI0QjU5KSkoKDB4MzhFNjA4RTZDODY2QUQxQzYxQkM2RjI1MEEwQUQ3NzYxQjcxQzZFNUUwRjdBMDY1RjAxQjdCMkY0RjQ4NUQxOCAweDJGMUNGQ0VFOTY1ODRGNTkyQ0RFMDVCMEIzRjkzNkE4RDFGQjYwM0EyOTg0RUVDQjFEQjA0MkJBNkQ4MUE2RDkpKDB4MDdBRDYxODFBOEUzMkMzODk4QjA2QkYwOTJFMjhEMUM4RTkyODI5MzEyNTYwOTAzMzk3OUFFRERCOTExNkJDRSAweDM1Mjg3RjdBQTIzMDBFQ0ExQ0M1OEFFODE0MUFCOTc0MTFFMDBGNjFDNjVGNUIxQTk4QTU4RUY1OTE4QzM2M0IpKSgoMHgzNDYxRkFDRTFCRUI4NUY2MDVFNzJGQUY5QTNDODA0Q0MzQkY4MkZDMjA5NDU4MzUyOEYwQzdFQkE3NERGQjQ4IDB4MjIxMjAxNUU4Q0EyOTY1RkUwRThBNEEwNjgzOENFRERFRDFFQTUzMUExMzlGNUNGRDE1ODhEQjU3MzYzODFDMykoMHgwREUxNDM5NzdCQThCM0ZDOTNEMjU0MzRFRURBNDkyMUU4QkRFNUFENTlFMTE4MUU2QjQ1NkI0MzA5MDU3RjA4IDB4MjRCMDk0RDRBQzQ1NkVDM0Y1NUQ0NjgzMEY0RTgyQkYwNzMxMkExRkFBOTdEOTEzOEJGNDFGMTZGN0UyM0E5QSkpKCgweDIxRTU2NDUzMzBEQzczRjZGNjgxOTE3NkY4RTkwQTA4MjcxMTc2NjRBOTNCNEQ5NkUxOURFOEIyODE5Njg5RjIgMHgxQUM2MzFENjA4RkRFQjFFRUZGQjZDMThBNzIwRTQwQ0YxNDA4QjBCRTI2NkE2MkJFOEI3RDBCNDZEQUYwRkQzKSgweDAwRDczQkU5QzMxOTMxOUU0QzEyQThGOTYxMEM0NzZEMTZGMDg3OEYwMzJERTZENjY2NEU3N0RBQUE0NDYzODcgMHgxMjgxNEY4NjM4ODI2RUE2MDk5RTA2OTE3NzBGRkU1MEY4MTdDRkIzQzQ1QzFGMDY1RUIwRjg1RDZFRTdCQThCKSkoKDB4MjdEMDVENUNFOTJGODM3NUQxNUM3RTI4QTRGNkEwMkUxQzI0MEJCQTE4OTc4MzI5RENBMDcyNDM2Q0RCM0I3QiAweDFDOTk0ODQzQkUzNzk3RTlBNkYyQUM2RkNDQUIxQzlCMTc0NUU4MTkxNDNGMjkxOEEzODNEM0QzMzZDNTg0NkMpKDB4MUQ4QUJDNTk0RURFMzExQTc0QTNDRUU3REUzNkU0MDY1ODUxQzBFRDAzQTQxNDhGMUExM0FGOEE0RTFDRThCMiAweDJDMzIwN0I2N0VFMDA1QzdGQzVCMUMwNzJFOTgwQURGOTY5NUYwMTVBRTI2QkYxNkFFMzJFODNDMDZGQ0M2MTEpKSgoMHgxMzVEQzBGOTg0NjVFMzZBRUZDNEFGQUYwODJGNDU5NDQzNEI0QTQzNzQzMDlDQkQzMzQ3NTA5ODNBNzgxMUE0IDB4MTEwNTdDMERGNkJEMkNDN0E1MDVBNkIzOTk2OTA3MDY1NkNCMzlFNEVDNDc5RENGRTQyRTAxRTcwQkEzOTExNCkoMHgxRTI1NEQ5QjdFNkJFREZFMTQyMjY0RTFCOTNCMUNBOTJCOTQzMjY0RTQ4QzhFMjc2QUFCQkMwNjNFNzlDMDJCIDB4MkE2MTcyMjlGNEQxOTRGM0JFM0QxNUQzOEI3NzdFQTRBQkJBMjhGMzY0MUIyNjlGN0EyNTFGQkZDNTExQjI1QSkpKCgweDFFOUUzRkE0NkE1MEVDN0E0MkYzNzBFOUE0MjlDMjE5ODRGQ0Y3MzBGQUFDODkxM0VDNkU1MEI5REJBMDM5MEMgMHgxOUE3Q0Q3QTg0QzNFOTk4QUJGQ0FCMUQxQUI4REYxRTlGNTdENTg3OEVDQjEyNjM2QThDMEQwMDhFNDY2OTM0KSgweDNGMkMyQjczN0NENzM2NThBQ0UzQ0M5MjQyREQ5QTUyRTM5ODM2QjEzOEJDREI3MTY1OEIxMDUyQzdGRTlDODMgMHgyMThFOEVBQjFGNjU3RUZFRjFBMjgxRkU2MUE2QjFDREQ5MzAzMzEzMEZDNjY0NDAzRUIxNjEwQUUyMEVGQjNCKSkoKDB4MDYzRThCNTBBOTBFN0FGQUE0NUI0QUUyQkI0RjQ4NTM3RjE0Q0ZFODJCRUYzMUExMTAwOTM5OTlGMEFCNTMzMyAweDEwMjgxQzhDMEUwMTc0RkEyMTIxRjQzNUYzNUQ5RTgwNTA2MzdBQTNGNThFMkEzNDJERUI5QzkxNzk4QzQ3QUMpKDB4MEQ0M0FCMDg1M0M2QzIwMkEyQ0UzQzM5RTlEMUNEQTYxNDQ5QThBMTZBOTEwMTJGRkU1OEFGQ0JGNjc1RDNENiAweDNCNURBREFBQUU1N0NGNkZCOTcyQzUyMUZFRDFBQzAzQjk2MDg1MUMwRDQ0QjYxMjJFQkI3MkEyMjU4QTQ2MDQpKSgoMHgxOEFFMzg4NUFDOEFGMEU2QkQ5QzBFNzc4NUQ4MzQ3N0VENkY1RkU4QTIzOUFFMjUyNjE0MTkzMUQ4MUVBQjU2IDB4MjlGQkIwODREOEZCRTcwM0QwMDhFOUNENzBCNzAyQjMxMTNCNDlGODU5QzJBMTlCNDQwNkFEMTMwRDM3MzFBMikoMHgwNEFGOTlFNzIwMjU0QjIyRThERjM2OEFFNkZDMjczQUM3NUE0NjM5QTZGMzAwNzM2OUZENDA1NTMyOTY0Q0JFIDB4MTI0NTI1RTM3RUM2MTVCMUY1N0Q1NDAwMjgzNkUzNTM4MDU0ODI3NkM2MUQ2QjI1MzlFQTUxQzkwMTVFRUQ5QykpKCgweDMyQTRFQ0E3Mjg2NEVFRkZDRjJEODNCODQzQjlCRTRBREJDRDQ1Qjk3MjYyNDgxMUM4OTRGOTE2RTRDODFBMzAgMHgzRTZGNTdBQjlDRjUzNjE4NjY0QTdBRDk4NjJGNjVCRjE2NEVGRkI0MkI3NDk3QjY0QTg4NDQzMzkzMThDMzY1KSgweDJGN0VFQ0M2M0YzRURGNTE5QTgzRTIwRDY0RTg4MjEzMTc5MjY0RjkzQTI0MzhBMjJBMTYzMzVFQjI4NTNFNkEgMHgxRDAzQzQwODc1MTZFRTAxQzEzOTgyNTA1OTk3Q0Y1RTEzQThFNEMyMjhCNDM0NkRFRkRDQjExMDFFNjU2NDk0KSkoKDB4Mzk0QzNGNDc2RjhERkFFNjhFNUI0NjEwRTczMjM5RjdBQ0Q4QzVBRTEyRTZGMDk0QjJEMTk5RDM5MzA4RDg3RCAweDFBMzhENDFDNjhDN0JEM0M2MTc2RDI0Rjc3NDY0MTEzNkQ2QzkyOTgxMUQ4NkFFNzJFNTQ1OThCQjdEQjI3RjQpKDB4MTYwQ0I0NEIyRkFGOTNCMDM3NUQ0MEU3N0Q1NjAwOTFGMDY2Qzg2MTZCNjkyRkY4NDJGOTBCNkZFQkM5QkFCMiAweDE2QzRFNUFEQTY1MzRCNUVBMDQwNjkxOEFEMkQ2NEJDNDE0RUFGRkJDNzIzRjI3QjM1OUM1MjRGRjVGQ0UzOUMpKSgoMHgzRkIxOTExNEU5NDdGRkRDNTQwRkI0Mjg0ODM1Q0I3NDI3OURBQjFDRjMxNTRGMDg3NEIwQTBBNUU2M0EzRUVCIDB4M0Q2NUQ1QjE3MkNFRjhEMzFGMzRBNDlBQjA4ODlGN0ExMEEyMjM4ODQ2QjZCMjQ1NjlENjhBQTc5MUY5NENCNikoMHgwRjAyNjk5RDgwMERCODY4QTA2RTNFRTRBMEMxNThDOTBCQzQ4QTY5MUU4MTc0NEZGQkNGREEzMkZGMjREQ0Y0IDB4MjcxNDY3MTI0M0ZEODIzN0QzMzlFMEFDMkM5NDFFRTlBNjQyRkRGNkZDQkJFMDMxQjQyNjk2RkQ2OUU4MzFBQikpKCgweDA1MjFGNkIwNTIxMkRDOTc1QUYwMDA3Q0QyNEQzMjhCMkVDRUQxQzgyNzkxRDJFNjA2MDU5QjY1QkNCRTU1NEUgMHgzNkJFNkRBQzRCNzczNDk0MTIxRjdERDVGODUwN0QzNkFFNkFDQzFEQzk5RkE4NjBERUQxQ0E3QUU4QTNFRDAxKSgweDM4QjUxQjU5MEJGNTBDQzZBMjRBQjgwNDc0RUIxNDdBMzBDNEFGM0REMTlBNTY1NEMxQjEwNTU1OUJEMTRENEQgMHgzRTExREU4QjFCNDYzOEZCRDhDNEQ2ODM2QTc0N0MwQTgxNTc4QTREMjJCODRBQzU4RUMwNjFGRUI2OEIzMTc3KSkoKDB4MkQ1MzI4RTBCQTU4OTk1QzcwNjY3NzRBNDYzRjhBOTAyRDdDMkI5N0JENDVDMTBCOUQ4QjREODIzREYxMDZBQyAweDI2OTMzQTlDMjE3NzI3QzlDREM0QTQ0OTREM0UzMzJCMzZCQjk5NzM5NkZDQTcwNjA5OUZGRDM0MzlCQjQ4MzYpKDB4MEJCMTE2QkE4MDdEMTJENERGNzk1NTdGRkI3RjYwQjQ4ODU4NjAxOTEyNTMwRTNGNDlDODkwQTM0QUVEMzFDQiAweDI0NjJFMDM5NkVEMzAyREQxMEE2RUY0M0FFNTMyMzMzNTQzRjRBODc1NTk5RTgzRkJFNDEwNjY0NERERDNGOEUpKSkpKHpfMSAweDA2QTYxNkMzQTYyNUY5MkVENjVCNUNBOTlEOUExREFBQTQ3NjQ4MUI5QzQ1RTQ1NTNFN0E4RTQzNkIxM0Q1NzApKHpfMiAweDMxMEFFNDBDQkNFMjFGQTBEQzkyRDFERkU3REY0OUQ5MzlBNTc5RkYwMjlGODY5MTE4MDM2QkY4QjM3MDQzOEMpKGRlbHRhKDB4MzY2NDE0RjRGRTlDM0REQjI3REE1QTg1NDUyQ0VEQkM2NUFGRDEwNEQxRjVDMjQxQkUyRTU5NEY2MTVBQkJCQyAweDBCNDE5MEQ1OUVFQTZFQkY4QjkzMTYwNTQ0MzlFOTJCNUJGREM4Q0Q5QkIwQzg2NDc4M0Q1RjFENzg1REY4N0UpKShjaGFsbGVuZ2VfcG9seW5vbWlhbF9jb21taXRtZW50KDB4MTM0MEMxMEIzMEFEMDdGNDkxM0MzQ0RENTg4QzNFOEE1QTZFNkRBQzk5NDczNzhGQTk3RDExRjUyQ0NENEFFMSAweDBCMTEwQUFEMkQxOTU3QzlDNjk0NDQzOURFRDgwQzlDRTlBMEVBRDM1Qzk2OTAzQUMxRUFEQkM5NEFFQjVEMjkpKSkpKGV2YWxzKCgodygoMHgxQkYxQ0U0OTREMjQzRkVGOTI1M0NCNjZDQzNENjMwMEEzN0VENEEyMzBDMTU0NDUxNzc5RkExNkY2QUFFREQ3KSgweDJBOUFCNDE3OEY5NUVBRTZBM0Q2MDgyNzZBNEJDRDM5MEE4OERBRjhDMzUxOTYwNjFFRDc5REFEQjc0N0NBNjIpKDB4MkYyNzJGRDhERjM1MkMwMzVFODFGQzFBNUM4NjY0QUFCRUY0RjYyOTYyQjdFM0QwM0Y2QkY1M0MxMEMyQjM5OCkoMHgwOTY3QjBGN0Y3NEU2NTU4QUI4NkQ4MTNFQUI4NDkwQzQzQzU2OUJBQjlFNzI3NjFDOEQ0MDg2ODEwQTYyMUIyKSgweDNCRTU4RTdFM0M4REZGRTgzMTdFNjhFNTA3MjlGRkJENkUyMkUzRkU0M0YzRkQwQzQ2OUY0Njc2ODA2ODU1MEIpKDB4MjQxN0NCNTM4MERBRDc5NzgwRDYyNDI4Q0MwOTE3NUZCRTJEQkM0NDNFMDc2NzE1NzU4OUE3RDU4MTQ1OEQzMykoMHgyMDZGQTE3NzlDNTA1N0NEMDYzOTY2NkQyNTgxQTE3MEI4M0NFNjU0QzY1NDU0NEM3M0Y3REZEMDIyRkYxNTk3KSgweDNFQzg1NzM3ODM4RUQ4QzRDQjkwRDU0NTIzMjMxQzk1MEZDNjQxREFBODM5MEFDNjYxMjk5NUFEQkJGQzI5NDcpKDB4MUEyNEMzMzk3RDJGMzlGMURGRUVDQ0NCNjZDNzhCRTYxMjc5RDVDMjJBRDY5MkMyM0RENTI2ODEzMzc5M0YzOCkoMHgxODEzQzU5MTMzRjQyMDRGMTU1NTREODkxRjk0RDgwMkQyNkUyRjE4MzQzRDUxM0UxNjQ3MDY2MzZDRDdENkU0KSgweDA1MzRERjY3OTU0QjdBQUE5MERCREZBODE0NjhCODNGNDE4MkI5MjdENUI0MThFNTMxNzk1OTk4Qjk4MjVCRTMpKDB4MEY3RkMyQ0VBMTk5ODQ5NzJFRTU3MzI3NDNBQ0RBNEM2QzQwNkYwM0E4NTI1NTUwMTlGMjEzRTQzMzI2QjYxQSkoMHgzNjdBREE1MzcwMzNBMDU0QTY1RjBFMTQ1RTZFNzlCNTZGMDU0RUVCODAxMUYxRUVFMTYzRTEzN0Q2MzY2Qjg5KSgweDFCMzIzMkRGQTMxNjk5N0Y0NTNEN0E2RjIwMDVFNkUwOTZCNTRCMzg0N0Y2RkU4RDU4MTE2NTg4N0Y4NUZENzEpKDB4MEVEQzFCQ0Q4Qjc4MjMzRjJDNUUyMzZENkQwNTI2NUE1ODY1ODdBQjBCMUMwRjVFRTNBMjZFM0VDNDVDODU1OSkpKSh6KDB4MkQ0NjcyN0NBQkQxQUQyMEU0NzZFN0VEOEQ2NjQ2NDBEMDU2NUQzRjAxQ0JCRjdDNjI1OEUyRjQzNkUwRkI2NCkpKHMoKDB4MTZDMUQxN0Y4OEMyNjdDNDNENERGRDE5NzY4NTgzQTJFOUFCN0FFQzY5NzVCMDlGMTM5REYxQUI1QzQxQzgxNSkoMHgyNTBFQTY3QUQyMkUyNjYxMjA4QjA1RTcyQjEwNTRGNjA3OThGRDU4RERGRTMzMzNGQUE5QjVBQjU0N0M2NzQ1KSgweDI1OEE4QzkxODI4MEMyNjVGODI1RUI3MkMwQjhDNjI1NjY1QzJGQUY2MDY5N0Q1ODhFQzZBQUNBQzczRDBCODYpKDB4MDcyRUZBQUZDOTY3RUZFNDVCRkYyRUVDMUE4Q0JGOEEwQjJDQzFGNDRCMjUyOTZEQTMzRjczQjNFNDg4NjJEMikoMHgzQTIzQThBQTJBM0QwREM4NTI5OURFNDk3NUM4NDg1NDczQzlDMUQwRDBEODRBMEJFQ0ZGRDMxMzUxQTYwNzFEKSgweDBEQkM1MUM5REY5MjNBQ0I0NDI3NDc0MjA5NTc2MUU1OTlFRDFEOEY5NEVGOEY0MTRDMTUxRENDNTIyM0ExM0YpKSkoZ2VuZXJpY19zZWxlY3RvcigweDFBQjlDODhCNTNDOUNGRDBBNjU4MjMzMTE3MTFBQkYxRTEzRTVCMzUyREMyRDM1QzZEMzRBNDUwOEVGNDJDMUQpKShwb3NlaWRvbl9zZWxlY3RvcigweDBENERCOTY5NDk4NzNCOTBGMzY1QkNCQzczQjJBMUFBRTY5NTUzMzc0MkY2NDcyRTA1MEQwMjRDNDdFRjA1MUYpKSkoKHcoKDB4MDQ0RTI0ODZEMjJCNTczNzczM0M0OTMzOTQ0ODY1MDc5QzFEMjRDQjFCNjJENUE1RDk5RkI0QTg0RDFBNzgwNikoMHgyQjdENkY4RkNBN0EwMTc3MDYyNjQ4OEFEODU0MEJEQkFEMTMzN0M2MjdDRDhBOUU2MzIxMkEyQTA1ODMxNDEwKSgweDJEOTI2NzNFQkM2N0ZCODhEQzMwNTNGMDIxQUE0NEY1RUNDMTBGRTU2RTlEODE2OUVCMjhCNjNDODZBRTU3NjYpKDB4MTFCRDE3OTE3RDY4QTJFNjhGNEUxNjk5OEE4OUYxNUY1M0JDRUU4NTI0MDQyRTg3MzE2QTkxN0JFMTE4QjU3MykoMHgxOTc4RUY3MzYyNzc0NkEwNTBERkZGQjk4MUFDQ0FGREUxRUQ1MTY5MDkyMTk5NERCQ0VFNjlFNDQ4OTJDMDdBKSgweDIwQjI0Q0RERDAyRjlFM0UzODY0QjkwNUEwRTM0QzE5MTA5MTRBMzk5MDQ5NzIwOEI0NEQ5QjdEMkY5QzA0RDgpKDB4MDc0MzQ3REUzOURCQjczOTE2M0VDMTZGNEFDNjEwQkFGRTkzMjhDNzY3N0E1OUFEQjBFNDk0OUJFQTcyMTM5RikoMHgyOUYzMzQyODNBMDk3QkVGNTQ1RUQ0QkQyNUZFOTA1Mzg1NjVBRkIxRUNDRkJGMTJCQjYzNkY1MzY5NTBBQUU1KSgweDFEOTU2RjI3QTJDMkIzMkY1MTA4RjkyNjFCRjA4MzM2Q0FCRjNGNDNBMzRENzY1NDk3NDdDNTg5QUIyNjhFMjYpKDB4MEY2N0Y4MjJCNTAwNTEyOUZEREZBMTk4MDZCNjNFMkY5MjkzNjUxMzE5RTAyNEY0NzBBNEUzQzA5M0M5NTNGQSkoMHgwN0ZFMTczNzM2MDUwMjZEMDYxMUVBOEM1NkQ1QTVFMDEyNzM3QTY1MUI5REI0RjJCNkQzNjQzRTY2QUU4MDU1KSgweDA1MENBMjE3N0U3NjhEMTkwREIxQjhFRjM2QkZDOTI5NTc5NjQ0N0MwRjAwRjFDMzBENEVBRDJDNENDRjI1NzYpKDB4MDA4QjEzMkI4REQ5NzFFOEJENzEwRTIxNzZCQTFBMTQ4NkU5ODI2ODI2MDNEN0M5OTM1NEZGRERENDJFRDBERikoMHgzODZFMDRBODQ1NUFDQjg3RDBFNzM3Mjc3NDBFQ0Q3RkQyMTYwN0JCRTcwQ0U0MTNBQUEyRUQ1MjkzRkEyMDNCKSgweDI5MjI1QkQ5MkYwMENDNzEyRTlGM0ZGQ0E3NjYwNTkyQjgwOTg3QkU4QjM1RERGRjgzMTk0RjA3OTlEQzNCNDQpKSkoeigweDIzNDVBMUE3RkIwMDRGRjRCOTMzRTQ3RTkxNEJDNzYyRDMzMjFBQzc0QTFFQjgwN0YyMkY3NUY3MTZBMjk3NDUpKShzKCgweDM4NEY5RENDNTBGRkNDQ0QxN0ZFNTMwOTRGREQ2QzZFM0ExODk5MzdFRjIyMDIwNTVBOUU4NDIwN0QxRjk5MEYpKDB4M0UzQzczRjM0OEMzNkI2MUQ1MkQ1RERGRjM2RDc2NjM1N0I1OEE5MTQ4NzU1NDk0NzEzNTFCRUFCMzU5NTJDQikoMHgxOTNBNDYyQjk3MzFFNzNDODYyMkU2NThCQUQwREI1QTkzMjIxMzk3OERCMzkyNURCQjVBQ0YwN0Y4QUIyQjRDKSgweDJCNkU3MUEzNUY4QTZDMTYxQTIyRDZDQTQ1Q0E1NzY2Mzc4ODkwQzMwRUE2MUFGMEExNzlDQjZCNTQ5NkUxNzcpKDB4MDNBN0JGNDFDRjQ2MjE1ODcxREMzODVGMUM0QUIwM0E4QzNERDY3RUMzRjc4OUU0MjVCQUVDOEVEMkI0QTY1RikoMHgyM0MzNzU4QzUyRkUyNDNBNUU2M0ZENkFFQzIyMThDQzJBMDAxQTZGNjU1RjJFNDRGMUExM0UzOTFGRkE0QkI4KSkpKGdlbmVyaWNfc2VsZWN0b3IoMHgyQ0M0M0YwQTlEOThDQkU4RTVCNkZDMzU0RTlCMDkwQjkxMDc1NDE4MTE2NURCRTQ3NUU4OEEwQTAyRjVBNzg2KSkocG9zZWlkb25fc2VsZWN0b3IoMHgyMkE4MUM1MENCQkU2MDhDQjZGOEE4MDc0NzE0MjRFQjBBNTE2N0IzOTI0NDZGMzJFMTkyRTMzRUZEQkZDRTc1KSkpKSkoZnRfZXZhbDEgMHgzNEFENUZBOEFEMzhEOUZCODM1MzRGODUxRjA5MjRCQTNCOUI0M0UxQzQ1NzAzRjE1MUExOUJDQ0U3MUY0RTdEKSkpKSkp\"","counters":[]},{"line":"          |> Side_loaded.Proof.of_base64","counters":[]},{"line":"        with","counters":[]},{"line":"        | Error e ->","counters":[]},{"line":"            failwith e","counters":[]},{"line":"        | Ok pi ->","counters":[]},{"line":"            pi","counters":[]},{"line":"      in","counters":[]},{"line":"      let statement =","counters":[]},{"line":"        let transaction =","counters":[]},{"line":"          Backend.Tick.Field.t_of_sexp","counters":[]},{"line":"            (Atom","counters":[]},{"line":"               \"0x2340A5795E22C7C923991D225400D0052B3A995C35BCCDC612E6205287419EC1\"","counters":[]},{"line":"            )","counters":[]},{"line":"        in","counters":[]},{"line":"        let at_account_update =","counters":[]},{"line":"          Backend.Tick.Field.t_of_sexp","counters":[]},{"line":"            (Atom","counters":[]},{"line":"               \"0x2340A5795E22C7C923991D225400D0052B3A995C35BCCDC612E6205287419EC1\"","counters":[]},{"line":"            )","counters":[]},{"line":"        in","counters":[]},{"line":"        [| transaction; at_account_update |]","counters":[]},{"line":"      in","counters":[]},{"line":"      let vk =","counters":[]},{"line":"        Side_loaded.Verification_key.of_base58_check_exn","counters":[]},{"line":"          \"VVA53aPgmCXemUiPjxo1dhgdNUSWbJarTh9Xhaki6b1AjVE31nk6wnSKcPa6JSJ8KDTDMryCozStCeisLTXLoYxBo3fjFhgPJn25EnuJMggPrVocSW3SfQBY7dgpPqQVccsqSPcFGJptarG6dRrLcx65M4SqudGDWbzpKd2oLyeTVifRTREq2BibC3rWMpUDuLwXEnp61FfFaktb4WKu3hfHyYBt5vL3Xndi9kynUWuhznijLG2yP7eX7o5M3nbjfkg7NdWaGReZH1yt4ewtrmHEMF5qTdK2UPgNzpScaK7ix8wZV5qECT483DsuY6Wpx3s2FfdmRDYwdr2YejhW4ZnJLNAxMgUkV3xkid5esqnk5TuQrdHMYvLZXju3RrZrvqhmbTFXpANKskZnuH1BUvkeoPvpQeYdoeYDJ6bgM6NFB3oWsPTU3vSMg3Wjsqx6Ekc8MuZHuaziGax9WNxbM3H6HscZFRs4npttEiwj1gSvZNaVc9FfRdCa3CMMWJNR1CkA1zKtCb8Sie1yiHc89hDA7K5mufV1yaX88xmAQrhZpTLCE8Ch62Zp3P1Vy6QVDACZCKSiz3bhikYEXFKZaJfRYVZVPeEBgjnUDrB4SD61KKnvWWESV8a3uGudeBLnJqoPJuBC8bZTUfskxqzkXmz2XTv4HMARJRTg21tFB8mZmLgVuaSWpc6inGxTZeWmE9ECSFzHuazEPNQ6yn1xo7G72ixrmLZrZqhbhPfnqSL5SWnmFWaWTihNNdHac8FDwb8JKvneC5yUur3WAZ8tTULiiNVvQhjhKVUrym2wTWFwhDAy6GqZcYeWRig9gpgdaxEuA7YnDc8XZZ5JS643PBfAWZZ3mZR4NxXPnVfn1xAUD2VFXmA8pzkqRwQ8DSpSPpKuwzwuJQUW6QSGtBheKFSxrXt6qekFX2azueedJZrhnwPW78dM7v3Qd2zTWo8iD2wfBB1Yot8BfUqAk7FYyi9hajKT1qZWQMg3kUVBywX93KBht2RFDJeVwiuE2hHaAzobxnnwsPJKPHaU8SM1EXQ4cFP2zJ2acPig52MNht3Z34fMeZ65bA3eEbcDbJw3pk2YS1pHtEr818b5TisPu6gshwkRGghbnTsQzHCjZVf61rpT4WphBsv6ob6foLwdc5ZSxq2BFzAWUv5j5nrtU9fqnQCx1DooZxAc8BnjxCXQ5TnE4Rpj82JwUR59QFNza2RwK2vZLvrNPt1LK5eCkZV8fBWuYD9J4AnxGA8icQbWBAfsSk9xXJBynEKymAsw6eTFPWCAMjQgJLhJP8MJR3NyNbqMfT1nR924EyZged7US9ogU8CLV5GcMBTSzAyCSFwFN8LGL1uT9sStzwQNbUvKvXYRwWNMYpb7Mxcjz1NjBaMbiWUryMcJc3D19yXt8VNt5g3L3Ty4GtL3WWV2aXRRXcuzYZai6wV8ESPGd3R6o4NJS5Ct5Z98fx25sNtswb77Q18pU379m4wsk8ck872oMZTPp9bDHTVpLoEBHd1gkC6j7pP8dx3cNTWc1NoewCGLi6zLDNfPZDrRXZESnaDRgVGEDinXS5SeAihMcQxvriHyskPW4SidcZsZtPvLnoQz7HQRpDnXfg4j6b8P5EX6sSJbkU9is3k6e8puQirFzLLgh2uC4oZH8EzLRZcGkonQPP5sLTmfwX4s5DJYdS4NLAVYSXndVZ4fazLfqPLukdWQkxZihUq4NtFkfzpNB8MPUBe6T72zhnvqVPegeEhgVvUokcn2DRJUc93DSYSGEJ3eZNFTruCgbM7xMXq83K6eraFRvxGqAgsQcTcQKwEfF9XvuppFDBbEHjdg84w1XiRkZ7xPKDdF6Hvi5G8V6rr6q1T7qypKiFqNrwM6frbJqgjedLpAY6RkPchip2WsZTpEX3EY1ryyGnJxZvb2fjCooQ9u1R6zNArVCV383KNJQZAaWFgzd58F7ZJ1fGU8zeFzDuhqSwqPyDE299sVYMSfbvp7xjWygxrbjApRE2FkjQtjuxaiXzsuemvrrSedVCGrktCHNqPKkJxbLcpz97rRBvwnKSd26x8LKHn2Zjzp2qeyxsY8HN7WVPATxPE4xXqi9dw41o8LBQ3GDGe1ASjphdp4bxj1guHhSZbMKTJDj7hJKyuvBMdG1YKQo3uv2qu5MiB3Afu5SZbZStNKBnxc2DRoDyF45yrQNeoBJogcSLAqWG624ZAdU4BWrqRJNjoAu6GxxE6E8TvFtvyDW1R9Nv7tXzmWE7RarrAL9YUD6uqe7gAanAv1cdAJRcPcdr2YvUL7zeB5d1daPfwJW4PYDvMwnnqDFSXgNqPreh8nFaiReDYjiHkwCojPcCgdcK5gJwpQTasjkWQBk2RmFQdfaLCpiPZGroZ6hTvRBHq2MwdUtkQHZjjCvY9fUtnniMVdUgkAZ9oLj8evpeoDEwyEHE1upmZZN84CMPP32NpHDtH3PwgGR3\"","counters":[]},{"line":"      in","counters":[]},{"line":"      assert (","counters":[]},{"line":"        Promise.block_on_async_exn (fun () ->","counters":[]},{"line":"            Side_loaded.verify_promise ~value_to_field_elements:Fn.id","counters":[]},{"line":"              ~return_typ:Impls.Step.Typ.unit","counters":[]},{"line":"              [ (vk, (statement, ()), pi) ] ) )*)","counters":[]},{"line":"","counters":[]},{"line":"      open Impls.Step","counters":[]},{"line":"","counters":[]},{"line":"      let () = Snarky_backendless.Snark0.set_eval_constraints true","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"","counters":[]},{"line":"      module Statement = struct","counters":[]},{"line":"        type t = Field.t","counters":[]},{"line":"","counters":[]},{"line":"        let to_field_elements x = [| x |]","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"","counters":[]},{"line":"        module Constant = struct","counters":[]},{"line":"          type t = Field.Constant.t [@@deriving bin_io]","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"","counters":[]},{"line":"          let to_field_elements x = [| x |]","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"        end","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      (* Currently, a circuit must have at least 1 of every type of constraint. *)","counters":[]},{"line":"      let dummy_constraints () =","counters":[]},{"line":"        Impl.(","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let x =","counters":[]},{"line":"            exists Field.typ ~compute:(fun () -> Field.Constant.of_int 3)","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"          in","counters":[]},{"line":"          let g =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            exists Step_main_inputs.Inner_curve.typ ~compute:(fun _ ->","counters":[]},{"line":"                Tick.Inner_curve.(to_affine_exn one) )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"          in","counters":[]},{"line":"          ignore","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ( SC.to_field_checked'","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"                (module Impl)","counters":[]},{"line":"                ~num_bits:16","counters":[]},{"line":"                (Kimchi_backend_common.Scalar_challenge.create x)","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"              : Field.t * Field.t * Field.t ) ;","counters":[]},{"line":"          ignore","counters":[]},{"line":"            ( Step_main_inputs.Ops.scale_fast g ~num_bits:5 (Shifted_value x)","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"              : Step_main_inputs.Inner_curve.t ) ;","counters":[]},{"line":"          ignore","counters":[]},{"line":"            ( Step_main_inputs.Ops.scale_fast g ~num_bits:5 (Shifted_value x)","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"              : Step_main_inputs.Inner_curve.t ) ;","counters":[]},{"line":"          ignore","counters":[]},{"line":"            ( Step_verifier.Scalar_challenge.endo g ~num_bits:4","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"                (Kimchi_backend_common.Scalar_challenge.create x)","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"              : Field.t * Field.t ))","counters":[]},{"line":"","counters":[]},{"line":"      module No_recursion = struct","counters":[]},{"line":"        module Statement = Statement","counters":[]},{"line":"","counters":[]},{"line":"        let tag, _, p, Provers.[ step ] =","counters":[]},{"line":"          Common.time \"compile\" (fun () ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"              compile_promise () ~public_input:(Input Field.typ)","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ~auxiliary_typ:Typ.unit","counters":[]},{"line":"                ~branches:(module Nat.N1)","counters":[]},{"line":"                ~max_proofs_verified:(module Nat.N0)","counters":[]},{"line":"                ~name:\"blockchain-snark\"","counters":[]},{"line":"                ~constraint_constants:","counters":[]},{"line":"                  (* Dummy values *)","counters":[]},{"line":"                  { sub_windows_per_window = 0","counters":[]},{"line":"                  ; ledger_depth = 0","counters":[]},{"line":"                  ; work_delay = 0","counters":[]},{"line":"                  ; block_window_duration_ms = 0","counters":[]},{"line":"                  ; transaction_capacity = Log_2 0","counters":[]},{"line":"                  ; pending_coinbase_depth = 0","counters":[]},{"line":"                  ; coinbase_amount = Unsigned.UInt64.of_int 0","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"                  ; supercharged_coinbase_factor = 0","counters":[]},{"line":"                  ; account_creation_fee = Unsigned.UInt64.of_int 0","counters":[{"col_start":64,"col_end":64,"count":0}]},{"line":"                  ; fork = None","counters":[]},{"line":"                  }","counters":[]},{"line":"                ~choices:(fun ~self ->","counters":[]},{"line":"                  [ { identifier = \"main\"","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    ; prevs = []","counters":[]},{"line":"                    ; uses_lookup = false","counters":[]},{"line":"                    ; main =","counters":[]},{"line":"                        (fun { public_input = self } ->","counters":[]},{"line":"                          dummy_constraints () ;","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                          Field.Assert.equal self Field.zero ;","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                          { previous_proof_statements = []","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                          ; public_output = ()","counters":[]},{"line":"                          ; auxiliary_output = ()","counters":[]},{"line":"                          } )","counters":[]},{"line":"                    }","counters":[]},{"line":"                  ] ) )","counters":[]},{"line":"","counters":[]},{"line":"        module Proof = (val p)","counters":[]},{"line":"","counters":[]},{"line":"        let example =","counters":[]},{"line":"          let (), (), b0 =","counters":[]},{"line":"            Common.time \"b0\" (fun () ->","counters":[]},{"line":"                Promise.block_on_async_exn (fun () -> step Field.Constant.zero) )","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"          in","counters":[]},{"line":"          assert (","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"            Promise.block_on_async_exn (fun () ->","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                Proof.verify_promise [ (Field.Constant.zero, b0) ] ) ) ;","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"          (Field.Constant.zero, b0)","counters":[]},{"line":"","counters":[]},{"line":"        let example_input, example_proof = example","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      module No_recursion_return = struct","counters":[]},{"line":"        module Statement = struct","counters":[]},{"line":"          type t = unit","counters":[]},{"line":"","counters":[]},{"line":"          let to_field_elements () = [||]","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"          module Constant = struct","counters":[]},{"line":"            type t = unit [@@deriving bin_io]","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"            let to_field_elements () = [||]","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"          end","counters":[]},{"line":"        end","counters":[]},{"line":"","counters":[]},{"line":"        let tag, _, p, Provers.[ step ] =","counters":[]},{"line":"          Common.time \"compile\" (fun () ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"              compile_promise () ~public_input:(Output Field.typ)","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ~auxiliary_typ:Typ.unit","counters":[]},{"line":"                ~branches:(module Nat.N1)","counters":[]},{"line":"                ~max_proofs_verified:(module Nat.N0)","counters":[]},{"line":"                ~name:\"blockchain-snark\"","counters":[]},{"line":"                ~constraint_constants:","counters":[]},{"line":"                  (* Dummy values *)","counters":[]},{"line":"                  { sub_windows_per_window = 0","counters":[]},{"line":"                  ; ledger_depth = 0","counters":[]},{"line":"                  ; work_delay = 0","counters":[]},{"line":"                  ; block_window_duration_ms = 0","counters":[]},{"line":"                  ; transaction_capacity = Log_2 0","counters":[]},{"line":"                  ; pending_coinbase_depth = 0","counters":[]},{"line":"                  ; coinbase_amount = Unsigned.UInt64.of_int 0","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"                  ; supercharged_coinbase_factor = 0","counters":[]},{"line":"                  ; account_creation_fee = Unsigned.UInt64.of_int 0","counters":[{"col_start":64,"col_end":64,"count":0}]},{"line":"                  ; fork = None","counters":[]},{"line":"                  }","counters":[]},{"line":"                ~choices:(fun ~self ->","counters":[]},{"line":"                  [ { identifier = \"main\"","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    ; prevs = []","counters":[]},{"line":"                    ; uses_lookup = false","counters":[]},{"line":"                    ; main =","counters":[]},{"line":"                        (fun _ ->","counters":[]},{"line":"                          dummy_constraints () ;","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                          { previous_proof_statements = []","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                          ; public_output = Field.zero","counters":[]},{"line":"                          ; auxiliary_output = ()","counters":[]},{"line":"                          } )","counters":[]},{"line":"                    }","counters":[]},{"line":"                  ] ) )","counters":[]},{"line":"","counters":[]},{"line":"        module Proof = (val p)","counters":[]},{"line":"","counters":[]},{"line":"        let example =","counters":[]},{"line":"          let res, (), b0 =","counters":[]},{"line":"            Common.time \"b0\" (fun () ->","counters":[]},{"line":"                Promise.block_on_async_exn (fun () -> step ()) )","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"          in","counters":[]},{"line":"          assert (Field.Constant.(equal zero) res) ;","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"          assert (","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"            Promise.block_on_async_exn (fun () ->","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                Proof.verify_promise [ (res, b0) ] ) ) ;","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"          (res, b0)","counters":[]},{"line":"","counters":[]},{"line":"        let example_input, example_proof = example","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      module Simple_chain = struct","counters":[]},{"line":"        module Statement = Statement","counters":[]},{"line":"","counters":[]},{"line":"        type _ Snarky_backendless.Request.t +=","counters":[]},{"line":"          | Prev_input : Field.Constant.t Snarky_backendless.Request.t","counters":[]},{"line":"          | Proof : (Nat.N1.n, Nat.N1.n) Proof.t Snarky_backendless.Request.t","counters":[]},{"line":"","counters":[]},{"line":"        let handler (prev_input : Field.Constant.t) (proof : _ Proof.t)","counters":[]},{"line":"            (Snarky_backendless.Request.With { request; respond }) =","counters":[]},{"line":"          match request with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | Prev_input ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              respond (Provide prev_input)","counters":[]},{"line":"          | Proof ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              respond (Provide proof)","counters":[]},{"line":"          | _ ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              respond Unhandled","counters":[]},{"line":"","counters":[]},{"line":"        let tag, _, p, Provers.[ step ] =","counters":[]},{"line":"          Common.time \"compile\" (fun () ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"              compile_promise () ~public_input:(Input Field.typ)","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ~auxiliary_typ:Typ.unit","counters":[]},{"line":"                ~branches:(module Nat.N1)","counters":[]},{"line":"                ~max_proofs_verified:(module Nat.N1)","counters":[]},{"line":"                ~name:\"blockchain-snark\"","counters":[]},{"line":"                ~constraint_constants:","counters":[]},{"line":"                  (* Dummy values *)","counters":[]},{"line":"                  { sub_windows_per_window = 0","counters":[]},{"line":"                  ; ledger_depth = 0","counters":[]},{"line":"                  ; work_delay = 0","counters":[]},{"line":"                  ; block_window_duration_ms = 0","counters":[]},{"line":"                  ; transaction_capacity = Log_2 0","counters":[]},{"line":"                  ; pending_coinbase_depth = 0","counters":[]},{"line":"                  ; coinbase_amount = Unsigned.UInt64.of_int 0","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"                  ; supercharged_coinbase_factor = 0","counters":[]},{"line":"                  ; account_creation_fee = Unsigned.UInt64.of_int 0","counters":[{"col_start":64,"col_end":64,"count":0}]},{"line":"                  ; fork = None","counters":[]},{"line":"                  }","counters":[]},{"line":"                ~choices:(fun ~self ->","counters":[]},{"line":"                  [ { identifier = \"main\"","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    ; prevs = [ self ]","counters":[]},{"line":"                    ; uses_lookup = false","counters":[]},{"line":"                    ; main =","counters":[]},{"line":"                        (fun { public_input = self } ->","counters":[]},{"line":"                          let prev =","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            exists Field.typ ~request:(fun () -> Prev_input)","counters":[{"col_start":65,"col_end":65,"count":0}]},{"line":"                          in","counters":[]},{"line":"                          let proof =","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            exists (Typ.Internal.ref ()) ~request:(fun () ->","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                                Proof )","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                          in","counters":[]},{"line":"                          let is_base_case = Field.equal Field.zero self in","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                          let proof_must_verify = Boolean.not is_base_case in","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                          let self_correct = Field.(equal (one + prev) self) in","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"                          Boolean.Assert.any [ self_correct; is_base_case ] ;","counters":[]},{"line":"                          { previous_proof_statements =","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                              [ { public_input = prev","counters":[]},{"line":"                                ; proof","counters":[]},{"line":"                                ; proof_must_verify","counters":[]},{"line":"                                }","counters":[]},{"line":"                              ]","counters":[]},{"line":"                          ; public_output = ()","counters":[]},{"line":"                          ; auxiliary_output = ()","counters":[]},{"line":"                          } )","counters":[]},{"line":"                    }","counters":[]},{"line":"                  ] ) )","counters":[]},{"line":"","counters":[]},{"line":"        module Proof = (val p)","counters":[]},{"line":"","counters":[]},{"line":"        let example =","counters":[]},{"line":"          let s_neg_one = Field.Constant.(negate one) in","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"          let b_neg_one : (Nat.N1.n, Nat.N1.n) Proof0.t =","counters":[]},{"line":"            Proof0.dummy Nat.N1.n Nat.N1.n Nat.N1.n ~domain_log2:14","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"          in","counters":[]},{"line":"          let (), (), b0 =","counters":[]},{"line":"            Common.time \"b0\" (fun () ->","counters":[]},{"line":"                Promise.block_on_async_exn (fun () ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                    step","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      ~handler:(handler s_neg_one b_neg_one)","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"                      Field.Constant.zero ) )","counters":[]},{"line":"          in","counters":[]},{"line":"          assert (","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"            Promise.block_on_async_exn (fun () ->","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                Proof.verify_promise [ (Field.Constant.zero, b0) ] ) ) ;","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"          let (), (), b1 =","counters":[]},{"line":"            Common.time \"b1\" (fun () ->","counters":[]},{"line":"                Promise.block_on_async_exn (fun () ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                    step","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      ~handler:(handler Field.Constant.zero b0)","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"                      Field.Constant.one ) )","counters":[]},{"line":"          in","counters":[]},{"line":"          assert (","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"            Promise.block_on_async_exn (fun () ->","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                Proof.verify_promise [ (Field.Constant.one, b1) ] ) ) ;","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"          (Field.Constant.one, b1)","counters":[]},{"line":"","counters":[]},{"line":"        let example_input, example_proof = example","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      module Tree_proof = struct","counters":[]},{"line":"        type _ Snarky_backendless.Request.t +=","counters":[]},{"line":"          | No_recursion_input : Field.Constant.t Snarky_backendless.Request.t","counters":[]},{"line":"          | No_recursion_proof :","counters":[]},{"line":"              (Nat.N0.n, Nat.N0.n) Proof.t Snarky_backendless.Request.t","counters":[]},{"line":"          | Recursive_input : Field.Constant.t Snarky_backendless.Request.t","counters":[]},{"line":"          | Recursive_proof :","counters":[]},{"line":"              (Nat.N2.n, Nat.N2.n) Proof.t Snarky_backendless.Request.t","counters":[]},{"line":"","counters":[]},{"line":"        let handler","counters":[]},{"line":"            ((no_recursion_input, no_recursion_proof) :","counters":[]},{"line":"              Field.Constant.t * _ Proof.t )","counters":[]},{"line":"            ((recursion_input, recursion_proof) : Field.Constant.t * _ Proof.t)","counters":[]},{"line":"            (Snarky_backendless.Request.With { request; respond }) =","counters":[]},{"line":"          match request with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | No_recursion_input ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              respond (Provide no_recursion_input)","counters":[]},{"line":"          | No_recursion_proof ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              respond (Provide no_recursion_proof)","counters":[]},{"line":"          | Recursive_input ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              respond (Provide recursion_input)","counters":[]},{"line":"          | Recursive_proof ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              respond (Provide recursion_proof)","counters":[]},{"line":"          | _ ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              respond Unhandled","counters":[]},{"line":"","counters":[]},{"line":"        let tag, _, p, Provers.[ step ] =","counters":[]},{"line":"          Common.time \"compile\" (fun () ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"              compile_promise () ~public_input:(Input Field.typ)","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ~auxiliary_typ:Typ.unit","counters":[]},{"line":"                ~branches:(module Nat.N1)","counters":[]},{"line":"                ~max_proofs_verified:(module Nat.N2)","counters":[]},{"line":"                ~name:\"blockchain-snark\"","counters":[]},{"line":"                ~constraint_constants:","counters":[]},{"line":"                  (* Dummy values *)","counters":[]},{"line":"                  { sub_windows_per_window = 0","counters":[]},{"line":"                  ; ledger_depth = 0","counters":[]},{"line":"                  ; work_delay = 0","counters":[]},{"line":"                  ; block_window_duration_ms = 0","counters":[]},{"line":"                  ; transaction_capacity = Log_2 0","counters":[]},{"line":"                  ; pending_coinbase_depth = 0","counters":[]},{"line":"                  ; coinbase_amount = Unsigned.UInt64.of_int 0","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"                  ; supercharged_coinbase_factor = 0","counters":[]},{"line":"                  ; account_creation_fee = Unsigned.UInt64.of_int 0","counters":[{"col_start":64,"col_end":64,"count":0}]},{"line":"                  ; fork = None","counters":[]},{"line":"                  }","counters":[]},{"line":"                ~choices:(fun ~self ->","counters":[]},{"line":"                  [ { identifier = \"main\"","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    ; uses_lookup = false","counters":[]},{"line":"                    ; prevs = [ No_recursion.tag; self ]","counters":[]},{"line":"                    ; main =","counters":[]},{"line":"                        (fun { public_input = self } ->","counters":[]},{"line":"                          let no_recursive_input =","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            exists Field.typ ~request:(fun () ->","counters":[]},{"line":"                                No_recursion_input )","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                          in","counters":[]},{"line":"                          let no_recursive_proof =","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            exists (Typ.Internal.ref ()) ~request:(fun () ->","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                                No_recursion_proof )","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                          in","counters":[]},{"line":"                          let prev =","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            exists Field.typ ~request:(fun () ->","counters":[]},{"line":"                                Recursive_input )","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                          in","counters":[]},{"line":"                          let prev_proof =","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            exists (Typ.Internal.ref ()) ~request:(fun () ->","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                                Recursive_proof )","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                          in","counters":[]},{"line":"                          let is_base_case = Field.equal Field.zero self in","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                          let proof_must_verify = Boolean.not is_base_case in","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                          let self_correct = Field.(equal (one + prev) self) in","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"                          Boolean.Assert.any [ self_correct; is_base_case ] ;","counters":[]},{"line":"                          { previous_proof_statements =","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                              [ { public_input = no_recursive_input","counters":[]},{"line":"                                ; proof = no_recursive_proof","counters":[]},{"line":"                                ; proof_must_verify = Boolean.true_","counters":[]},{"line":"                                }","counters":[]},{"line":"                              ; { public_input = prev","counters":[]},{"line":"                                ; proof = prev_proof","counters":[]},{"line":"                                ; proof_must_verify","counters":[]},{"line":"                                }","counters":[]},{"line":"                              ]","counters":[]},{"line":"                          ; public_output = ()","counters":[]},{"line":"                          ; auxiliary_output = ()","counters":[]},{"line":"                          } )","counters":[]},{"line":"                    }","counters":[]},{"line":"                  ] ) )","counters":[]},{"line":"","counters":[]},{"line":"        module Proof = (val p)","counters":[]},{"line":"","counters":[]},{"line":"        let example1, example2 =","counters":[]},{"line":"          let s_neg_one = Field.Constant.(negate one) in","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"          let b_neg_one : (Nat.N2.n, Nat.N2.n) Proof0.t =","counters":[]},{"line":"            Proof0.dummy Nat.N2.n Nat.N2.n Nat.N2.n ~domain_log2:15","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"          in","counters":[]},{"line":"          let (), (), b0 =","counters":[]},{"line":"            Common.time \"tree b0\" (fun () ->","counters":[]},{"line":"                Promise.block_on_async_exn (fun () ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                    step","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      ~handler:","counters":[]},{"line":"                        (handler No_recursion.example (s_neg_one, b_neg_one))","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                      Field.Constant.zero ) )","counters":[]},{"line":"          in","counters":[]},{"line":"          assert (","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"            Promise.block_on_async_exn (fun () ->","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                Proof.verify_promise [ (Field.Constant.zero, b0) ] ) ) ;","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"          let (), (), b1 =","counters":[]},{"line":"            Common.time \"tree b1\" (fun () ->","counters":[]},{"line":"                Promise.block_on_async_exn (fun () ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                    step","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      ~handler:","counters":[]},{"line":"                        (handler No_recursion.example (Field.Constant.zero, b0))","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                      Field.Constant.one ) )","counters":[]},{"line":"          in","counters":[]},{"line":"          ((Field.Constant.zero, b0), (Field.Constant.one, b1))","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"        let examples = [ example1; example2 ]","counters":[]},{"line":"","counters":[]},{"line":"        let example1_input, example_proof = example1","counters":[]},{"line":"","counters":[]},{"line":"        let example2_input, example2_proof = example2","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      let%test_unit \"verify\" =","counters":[]},{"line":"        assert (","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"          Promise.block_on_async_exn (fun () ->","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"              Tree_proof.Proof.verify_promise Tree_proof.examples ) )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"","counters":[]},{"line":"      module Tree_proof_return = struct","counters":[]},{"line":"        module Statement = No_recursion_return.Statement","counters":[]},{"line":"","counters":[]},{"line":"        type _ Snarky_backendless.Request.t +=","counters":[]},{"line":"          | Is_base_case : bool Snarky_backendless.Request.t","counters":[]},{"line":"          | No_recursion_input : Field.Constant.t Snarky_backendless.Request.t","counters":[]},{"line":"          | No_recursion_proof :","counters":[]},{"line":"              (Nat.N0.n, Nat.N0.n) Proof.t Snarky_backendless.Request.t","counters":[]},{"line":"          | Recursive_input : Field.Constant.t Snarky_backendless.Request.t","counters":[]},{"line":"          | Recursive_proof :","counters":[]},{"line":"              (Nat.N2.n, Nat.N2.n) Proof.t Snarky_backendless.Request.t","counters":[]},{"line":"","counters":[]},{"line":"        let handler (is_base_case : bool)","counters":[]},{"line":"            ((no_recursion_input, no_recursion_proof) :","counters":[]},{"line":"              Field.Constant.t * _ Proof.t )","counters":[]},{"line":"            ((recursion_input, recursion_proof) : Field.Constant.t * _ Proof.t)","counters":[]},{"line":"            (Snarky_backendless.Request.With { request; respond }) =","counters":[]},{"line":"          match request with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | Is_base_case ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              respond (Provide is_base_case)","counters":[]},{"line":"          | No_recursion_input ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              respond (Provide no_recursion_input)","counters":[]},{"line":"          | No_recursion_proof ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              respond (Provide no_recursion_proof)","counters":[]},{"line":"          | Recursive_input ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              respond (Provide recursion_input)","counters":[]},{"line":"          | Recursive_proof ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              respond (Provide recursion_proof)","counters":[]},{"line":"          | _ ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              respond Unhandled","counters":[]},{"line":"","counters":[]},{"line":"        let tag, _, p, Provers.[ step ] =","counters":[]},{"line":"          Common.time \"compile\" (fun () ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"              compile_promise () ~public_input:(Output Field.typ)","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ~auxiliary_typ:Typ.unit","counters":[]},{"line":"                ~branches:(module Nat.N1)","counters":[]},{"line":"                ~max_proofs_verified:(module Nat.N2)","counters":[]},{"line":"                ~name:\"blockchain-snark\"","counters":[]},{"line":"                ~constraint_constants:","counters":[]},{"line":"                  (* Dummy values *)","counters":[]},{"line":"                  { sub_windows_per_window = 0","counters":[]},{"line":"                  ; ledger_depth = 0","counters":[]},{"line":"                  ; work_delay = 0","counters":[]},{"line":"                  ; block_window_duration_ms = 0","counters":[]},{"line":"                  ; transaction_capacity = Log_2 0","counters":[]},{"line":"                  ; pending_coinbase_depth = 0","counters":[]},{"line":"                  ; coinbase_amount = Unsigned.UInt64.of_int 0","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"                  ; supercharged_coinbase_factor = 0","counters":[]},{"line":"                  ; account_creation_fee = Unsigned.UInt64.of_int 0","counters":[{"col_start":64,"col_end":64,"count":0}]},{"line":"                  ; fork = None","counters":[]},{"line":"                  }","counters":[]},{"line":"                ~choices:(fun ~self ->","counters":[]},{"line":"                  [ { identifier = \"main\"","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    ; uses_lookup = false","counters":[]},{"line":"                    ; prevs = [ No_recursion_return.tag; self ]","counters":[]},{"line":"                    ; main =","counters":[]},{"line":"                        (fun { public_input = () } ->","counters":[]},{"line":"                          let no_recursive_input =","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            exists Field.typ ~request:(fun () ->","counters":[]},{"line":"                                No_recursion_input )","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                          in","counters":[]},{"line":"                          let no_recursive_proof =","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            exists (Typ.Internal.ref ()) ~request:(fun () ->","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                                No_recursion_proof )","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                          in","counters":[]},{"line":"                          let prev =","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            exists Field.typ ~request:(fun () ->","counters":[]},{"line":"                                Recursive_input )","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                          in","counters":[]},{"line":"                          let prev_proof =","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            exists (Typ.Internal.ref ()) ~request:(fun () ->","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                                Recursive_proof )","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                          in","counters":[]},{"line":"                          let is_base_case =","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            exists Boolean.typ ~request:(fun () -> Is_base_case)","counters":[{"col_start":67,"col_end":67,"count":0}]},{"line":"                          in","counters":[]},{"line":"                          let proof_must_verify = Boolean.not is_base_case in","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                          let self =","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            Field.(","counters":[]},{"line":"                              if_ is_base_case ~then_:zero ~else_:(one + prev))","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                          in","counters":[]},{"line":"                          { previous_proof_statements =","counters":[]},{"line":"                              [ { public_input = no_recursive_input","counters":[]},{"line":"                                ; proof = no_recursive_proof","counters":[]},{"line":"                                ; proof_must_verify = Boolean.true_","counters":[]},{"line":"                                }","counters":[]},{"line":"                              ; { public_input = prev","counters":[]},{"line":"                                ; proof = prev_proof","counters":[]},{"line":"                                ; proof_must_verify","counters":[]},{"line":"                                }","counters":[]},{"line":"                              ]","counters":[]},{"line":"                          ; public_output = self","counters":[]},{"line":"                          ; auxiliary_output = ()","counters":[]},{"line":"                          } )","counters":[]},{"line":"                    }","counters":[]},{"line":"                  ] ) )","counters":[]},{"line":"","counters":[]},{"line":"        module Proof = (val p)","counters":[]},{"line":"","counters":[]},{"line":"        let example1, example2 =","counters":[]},{"line":"          let s_neg_one = Field.Constant.(negate one) in","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"          let b_neg_one : (Nat.N2.n, Nat.N2.n) Proof0.t =","counters":[]},{"line":"            Proof0.dummy Nat.N2.n Nat.N2.n Nat.N2.n ~domain_log2:15","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"          in","counters":[]},{"line":"          let s0, (), b0 =","counters":[]},{"line":"            Common.time \"tree b0\" (fun () ->","counters":[]},{"line":"                Promise.block_on_async_exn (fun () ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                    step","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      ~handler:","counters":[]},{"line":"                        (handler true No_recursion_return.example","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                           (s_neg_one, b_neg_one) )","counters":[]},{"line":"                      () ) )","counters":[]},{"line":"          in","counters":[]},{"line":"          assert (Field.Constant.(equal zero) s0) ;","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"          assert (","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"            Promise.block_on_async_exn (fun () ->","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                Proof.verify_promise [ (s0, b0) ] ) ) ;","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"          let s1, (), b1 =","counters":[]},{"line":"            Common.time \"tree b1\" (fun () ->","counters":[]},{"line":"                Promise.block_on_async_exn (fun () ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                    step","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      ~handler:","counters":[]},{"line":"                        (handler false No_recursion_return.example (s0, b0))","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                      () ) )","counters":[]},{"line":"          in","counters":[]},{"line":"          assert (Field.Constant.(equal one) s1) ;","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"          ((s0, b0), (s1, b1))","counters":[]},{"line":"","counters":[]},{"line":"        let examples = [ example1; example2 ]","counters":[]},{"line":"","counters":[]},{"line":"        let example1_input, example1_proof = example1","counters":[]},{"line":"","counters":[]},{"line":"        let example2_input, example2_proof = example2","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      let%test_unit \"verify\" =","counters":[]},{"line":"        assert (","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"          Promise.block_on_async_exn (fun () ->","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"              Tree_proof_return.Proof.verify_promise Tree_proof_return.examples ) )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"","counters":[]},{"line":"      module Add_one_return = struct","counters":[]},{"line":"        module Statement = struct","counters":[]},{"line":"          type t = Field.t","counters":[]},{"line":"","counters":[]},{"line":"          let to_field_elements x = [| x |]","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"","counters":[]},{"line":"          module Constant = struct","counters":[]},{"line":"            type t = Field.Constant.t [@@deriving bin_io]","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"","counters":[]},{"line":"            let to_field_elements x = [| x |]","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"          end","counters":[]},{"line":"        end","counters":[]},{"line":"","counters":[]},{"line":"        let tag, _, p, Provers.[ step ] =","counters":[]},{"line":"          Common.time \"compile\" (fun () ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"              compile_promise ()","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ~public_input:(Input_and_output (Field.typ, Field.typ))","counters":[]},{"line":"                ~auxiliary_typ:Typ.unit","counters":[]},{"line":"                ~branches:(module Nat.N1)","counters":[]},{"line":"                ~max_proofs_verified:(module Nat.N0)","counters":[]},{"line":"                ~name:\"blockchain-snark\"","counters":[]},{"line":"                ~constraint_constants:","counters":[]},{"line":"                  (* Dummy values *)","counters":[]},{"line":"                  { sub_windows_per_window = 0","counters":[]},{"line":"                  ; ledger_depth = 0","counters":[]},{"line":"                  ; work_delay = 0","counters":[]},{"line":"                  ; block_window_duration_ms = 0","counters":[]},{"line":"                  ; transaction_capacity = Log_2 0","counters":[]},{"line":"                  ; pending_coinbase_depth = 0","counters":[]},{"line":"                  ; coinbase_amount = Unsigned.UInt64.of_int 0","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"                  ; supercharged_coinbase_factor = 0","counters":[]},{"line":"                  ; account_creation_fee = Unsigned.UInt64.of_int 0","counters":[{"col_start":64,"col_end":64,"count":0}]},{"line":"                  ; fork = None","counters":[]},{"line":"                  }","counters":[]},{"line":"                ~choices:(fun ~self ->","counters":[]},{"line":"                  [ { identifier = \"main\"","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    ; uses_lookup = false","counters":[]},{"line":"                    ; prevs = []","counters":[]},{"line":"                    ; main =","counters":[]},{"line":"                        (fun { public_input = x } ->","counters":[]},{"line":"                          dummy_constraints () ;","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                          { previous_proof_statements = []","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                          ; public_output = Field.(add one) x","counters":[{"col_start":53,"col_end":53,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"                          ; auxiliary_output = ()","counters":[]},{"line":"                          } )","counters":[]},{"line":"                    }","counters":[]},{"line":"                  ] ) )","counters":[]},{"line":"","counters":[]},{"line":"        module Proof = (val p)","counters":[]},{"line":"","counters":[]},{"line":"        let example =","counters":[]},{"line":"          let input = Field.Constant.of_int 42 in","counters":[]},{"line":"          let res, (), b0 =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Common.time \"b0\" (fun () ->","counters":[]},{"line":"                Promise.block_on_async_exn (fun () -> step input) )","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"          in","counters":[]},{"line":"          assert (Field.Constant.(equal (of_int 43)) res) ;","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":46,"col_end":46,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"          assert (","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"            Promise.block_on_async_exn (fun () ->","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                Proof.verify_promise [ ((input, res), b0) ] ) ) ;","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"          ((input, res), b0)","counters":[]},{"line":"","counters":[]},{"line":"        let example_input, example_proof = example","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      module Auxiliary_return = struct","counters":[]},{"line":"        module Statement = struct","counters":[]},{"line":"          type t = Field.t","counters":[]},{"line":"","counters":[]},{"line":"          let to_field_elements x = [| x |]","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"","counters":[]},{"line":"          module Constant = struct","counters":[]},{"line":"            type t = Field.Constant.t [@@deriving bin_io]","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"","counters":[]},{"line":"            let to_field_elements x = [| x |]","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"          end","counters":[]},{"line":"        end","counters":[]},{"line":"","counters":[]},{"line":"        let tag, _, p, Provers.[ step ] =","counters":[]},{"line":"          Common.time \"compile\" (fun () ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"              compile_promise ()","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ~public_input:(Input_and_output (Field.typ, Field.typ))","counters":[]},{"line":"                ~auxiliary_typ:Field.typ","counters":[]},{"line":"                ~branches:(module Nat.N1)","counters":[]},{"line":"                ~max_proofs_verified:(module Nat.N0)","counters":[]},{"line":"                ~name:\"blockchain-snark\"","counters":[]},{"line":"                ~constraint_constants:","counters":[]},{"line":"                  (* Dummy values *)","counters":[]},{"line":"                  { sub_windows_per_window = 0","counters":[]},{"line":"                  ; ledger_depth = 0","counters":[]},{"line":"                  ; work_delay = 0","counters":[]},{"line":"                  ; block_window_duration_ms = 0","counters":[]},{"line":"                  ; transaction_capacity = Log_2 0","counters":[]},{"line":"                  ; pending_coinbase_depth = 0","counters":[]},{"line":"                  ; coinbase_amount = Unsigned.UInt64.of_int 0","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"                  ; supercharged_coinbase_factor = 0","counters":[]},{"line":"                  ; account_creation_fee = Unsigned.UInt64.of_int 0","counters":[{"col_start":64,"col_end":64,"count":0}]},{"line":"                  ; fork = None","counters":[]},{"line":"                  }","counters":[]},{"line":"                ~choices:(fun ~self ->","counters":[]},{"line":"                  [ { identifier = \"main\"","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    ; uses_lookup = false","counters":[]},{"line":"                    ; prevs = []","counters":[]},{"line":"                    ; main =","counters":[]},{"line":"                        (fun { public_input = input } ->","counters":[]},{"line":"                          dummy_constraints () ;","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                          let sponge =","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            Step_main_inputs.Sponge.create","counters":[]},{"line":"                              Step_main_inputs.sponge_params","counters":[]},{"line":"                          in","counters":[]},{"line":"                          let blinding_value =","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            exists Field.typ ~compute:Field.Constant.random","counters":[]},{"line":"                          in","counters":[]},{"line":"                          Step_main_inputs.Sponge.absorb sponge (`Field input) ;","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                          Step_main_inputs.Sponge.absorb sponge","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            (`Field blinding_value) ;","counters":[]},{"line":"                          let result = Step_main_inputs.Sponge.squeeze sponge in","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                          { previous_proof_statements = []","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                          ; public_output = result","counters":[]},{"line":"                          ; auxiliary_output = blinding_value","counters":[]},{"line":"                          } )","counters":[]},{"line":"                    }","counters":[]},{"line":"                  ] ) )","counters":[]},{"line":"","counters":[]},{"line":"        module Proof = (val p)","counters":[]},{"line":"","counters":[]},{"line":"        let example =","counters":[]},{"line":"          let input = Field.Constant.of_int 42 in","counters":[]},{"line":"          let result, blinding_value, b0 =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Common.time \"b0\" (fun () ->","counters":[]},{"line":"                Promise.block_on_async_exn (fun () -> step input) )","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"          in","counters":[]},{"line":"          let sponge =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Tick_field_sponge.Field.create Tick_field_sponge.params","counters":[]},{"line":"          in","counters":[]},{"line":"          Tick_field_sponge.Field.absorb sponge input ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          Tick_field_sponge.Field.absorb sponge blinding_value ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let result' = Tick_field_sponge.Field.squeeze sponge in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          assert (Field.Constant.equal result result') ;","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"          assert (","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"            Promise.block_on_async_exn (fun () ->","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                Proof.verify_promise [ ((input, result), b0) ] ) ) ;","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"          ((input, result), b0)","counters":[]},{"line":"","counters":[]},{"line":"        let example_input, example_proof = example","counters":[]},{"line":"      end","counters":[]},{"line":"    end )","counters":[]},{"line":"","counters":[]},{"line":"  let%test_module \"test uncorrelated bulletproof_challenges\" =","counters":[]},{"line":"    ( module struct","counters":[]},{"line":"      let () = Backtrace.elide := false","counters":[]},{"line":"","counters":[]},{"line":"      let () = Snarky_backendless.Snark0.set_eval_constraints true","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"","counters":[]},{"line":"      module Statement = struct","counters":[]},{"line":"        type t = unit","counters":[]},{"line":"","counters":[]},{"line":"        let to_field_elements () = [||]","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      module A = Statement","counters":[]},{"line":"      module A_value = Statement","counters":[]},{"line":"","counters":[]},{"line":"      let typ = Impls.Step.Typ.unit","counters":[]},{"line":"","counters":[]},{"line":"      module Branches = Nat.N1","counters":[]},{"line":"      module Max_proofs_verified = Nat.N2","counters":[]},{"line":"","counters":[]},{"line":"      let constraint_constants : Snark_keys_header.Constraint_constants.t =","counters":[]},{"line":"        { sub_windows_per_window = 0","counters":[]},{"line":"        ; ledger_depth = 0","counters":[]},{"line":"        ; work_delay = 0","counters":[]},{"line":"        ; block_window_duration_ms = 0","counters":[]},{"line":"        ; transaction_capacity = Log_2 0","counters":[]},{"line":"        ; pending_coinbase_depth = 0","counters":[]},{"line":"        ; coinbase_amount = Unsigned.UInt64.of_int 0","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"        ; supercharged_coinbase_factor = 0","counters":[]},{"line":"        ; account_creation_fee = Unsigned.UInt64.of_int 0","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"        ; fork = None","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"      let tag =","counters":[]},{"line":"        { Tag.id = Type_equal.Id.create ~name:\"\" sexp_of_opaque","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"        ; kind = Compiled","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"      let rule : _ Inductive_rule.t =","counters":[]},{"line":"        let open Impls.Step in","counters":[]},{"line":"        { identifier = \"main\"","counters":[]},{"line":"        ; prevs = [ tag; tag ]","counters":[]},{"line":"        ; main =","counters":[]},{"line":"            (fun { public_input = () } ->","counters":[]},{"line":"              let dummy_proof =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                As_prover.Ref.create (fun () ->","counters":[]},{"line":"                    Proof0.dummy Nat.N2.n Nat.N2.n Nat.N2.n ~domain_log2:15 )","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"              in","counters":[]},{"line":"              { previous_proof_statements =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                  [ { public_input = ()","counters":[]},{"line":"                    ; proof = dummy_proof","counters":[]},{"line":"                    ; proof_must_verify = Boolean.false_","counters":[]},{"line":"                    }","counters":[]},{"line":"                  ; { public_input = ()","counters":[]},{"line":"                    ; proof = dummy_proof","counters":[]},{"line":"                    ; proof_must_verify = Boolean.false_","counters":[]},{"line":"                    }","counters":[]},{"line":"                  ]","counters":[]},{"line":"              ; public_output = ()","counters":[]},{"line":"              ; auxiliary_output = ()","counters":[]},{"line":"              } )","counters":[]},{"line":"        ; uses_lookup = false","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"      module M = struct","counters":[]},{"line":"        module IR = Inductive_rule.T (A) (A_value) (A) (A_value) (A) (A_value)","counters":[]},{"line":"        module HIR = H4.T (IR)","counters":[]},{"line":"","counters":[]},{"line":"        let max_local_max_proofs_verifieds ~self (type n)","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"            (module Max_proofs_verified : Nat.Intf with type n = n) branches","counters":[]},{"line":"            choices =","counters":[]},{"line":"          let module Local_max_proofs_verifieds = struct","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            type t = (int, Max_proofs_verified.n) Vector.t","counters":[]},{"line":"          end in","counters":[]},{"line":"          let module M =","counters":[]},{"line":"            H4.Map (IR) (E04 (Local_max_proofs_verifieds))","counters":[]},{"line":"              (struct","counters":[]},{"line":"                module V = H4.To_vector (Int)","counters":[]},{"line":"                module HT = H4.T (Tag)","counters":[]},{"line":"","counters":[]},{"line":"                module M =","counters":[]},{"line":"                  H4.Map (Tag) (E04 (Int))","counters":[]},{"line":"                    (struct","counters":[]},{"line":"                      let f (type a b c d) (t : (a, b, c, d) Tag.t) : int =","counters":[]},{"line":"                        if Type_equal.Id.same t.id self then","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          Nat.to_int Max_proofs_verified.n","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                        else","counters":[]},{"line":"                          let (module M) = Types_map.max_proofs_verified t in","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                          Nat.to_int M.n","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                    end)","counters":[]},{"line":"","counters":[]},{"line":"                let f :","counters":[]},{"line":"                    type a b c d.","counters":[]},{"line":"                    (a, b, c, d) IR.t -> Local_max_proofs_verifieds.t =","counters":[]},{"line":"                 fun rule ->","counters":[]},{"line":"                  let (T (_, l)) = HT.length rule.prevs in","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  Vector.extend_exn","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    (V.f l (M.f rule.prevs))","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"                    Max_proofs_verified.n 0","counters":[]},{"line":"              end)","counters":[]},{"line":"          in","counters":[]},{"line":"          let module V = H4.To_vector (Local_max_proofs_verifieds) in","counters":[]},{"line":"          let padded = V.f branches (M.f choices) |> Vector.transpose in","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"          (padded, Maxes.m padded)","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"        module Lazy_ (A : T0) = struct","counters":[]},{"line":"          type t = A.t Lazy.t","counters":[]},{"line":"        end","counters":[]},{"line":"","counters":[]},{"line":"        module Lazy_keys = struct","counters":[]},{"line":"          type t =","counters":[]},{"line":"            (Impls.Step.Keypair.t * Dirty.t) Lazy.t","counters":[]},{"line":"            * (Kimchi_bindings.Protocol.VerifierIndex.Fp.t * Dirty.t) Lazy.t","counters":[]},{"line":"","counters":[]},{"line":"          (* TODO Think this is right.. *)","counters":[]},{"line":"        end","counters":[]},{"line":"","counters":[]},{"line":"        let compile :","counters":[]},{"line":"            (   unit","counters":[]},{"line":"             -> (Max_proofs_verified.n, Max_proofs_verified.n) Proof.t Promise.t","counters":[]},{"line":"            )","counters":[]},{"line":"            * _","counters":[]},{"line":"            * _ =","counters":[]},{"line":"          let self = tag in","counters":[]},{"line":"          let snark_keys_header kind constraint_system_hash =","counters":[]},{"line":"            { Snark_keys_header.header_version =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"                Snark_keys_header.header_version","counters":[]},{"line":"            ; kind","counters":[]},{"line":"            ; constraint_constants","counters":[]},{"line":"            ; commits =","counters":[]},{"line":"                { mina = Mina_version.commit_id","counters":[]},{"line":"                ; marlin = Mina_version.marlin_commit_id","counters":[]},{"line":"                }","counters":[]},{"line":"            ; length = (* This is a dummy, it gets filled in on read/write. *) 0","counters":[]},{"line":"            ; commit_date = Mina_version.commit_date","counters":[]},{"line":"            ; constraint_system_hash","counters":[]},{"line":"            ; identifying_hash =","counters":[]},{"line":"                (* TODO: Proper identifying hash. *)","counters":[]},{"line":"                constraint_system_hash","counters":[]},{"line":"            }","counters":[]},{"line":"          in","counters":[]},{"line":"          let T = Max_proofs_verified.eq in","counters":[]},{"line":"          let prev_varss_n = Branches.n in","counters":[]},{"line":"          let prev_varss_length : _ Length.t = S Z in","counters":[]},{"line":"          let T = Nat.eq_exn prev_varss_n Branches.n in","counters":[]},{"line":"          let padded, (module Maxes) =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            max_local_max_proofs_verifieds","counters":[]},{"line":"              (module Max_proofs_verified)","counters":[]},{"line":"              prev_varss_length [ rule ] ~self:self.id","counters":[]},{"line":"          in","counters":[]},{"line":"          let full_signature =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            { Full_signature.padded; maxes = (module Maxes) }","counters":[]},{"line":"          in","counters":[]},{"line":"          let wrap_domains =","counters":[]},{"line":"            let module M =","counters":[]},{"line":"              Wrap_domains.Make (A) (A_value) (A) (A_value) (A) (A_value)","counters":[]},{"line":"            in","counters":[]},{"line":"            M.f full_signature prev_varss_n prev_varss_length ~self","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              ~choices:[ rule ]","counters":[]},{"line":"              ~max_proofs_verified:(module Max_proofs_verified)","counters":[]},{"line":"          in","counters":[]},{"line":"          let module Branch_data = struct","counters":[]},{"line":"            type ('vars, 'vals, 'n, 'm) t =","counters":[]},{"line":"              ( A.t","counters":[]},{"line":"              , A_value.t","counters":[]},{"line":"              , A.t","counters":[]},{"line":"              , A_value.t","counters":[]},{"line":"              , A.t","counters":[]},{"line":"              , A_value.t","counters":[]},{"line":"              , Max_proofs_verified.n","counters":[]},{"line":"              , Branches.n","counters":[]},{"line":"              , 'vars","counters":[]},{"line":"              , 'vals","counters":[]},{"line":"              , 'n","counters":[]},{"line":"              , 'm )","counters":[]},{"line":"              Step_branch_data.t","counters":[]},{"line":"          end in","counters":[]},{"line":"          let proofs_verifieds = Vector.[ 2 ] in","counters":[]},{"line":"          let (T inner_step_data as step_data) =","counters":[]},{"line":"            Step_branch_data.create ~index:0 ~step_uses_lookup:No","counters":[]},{"line":"              ~max_proofs_verified:Max_proofs_verified.n ~branches:Branches.n","counters":[]},{"line":"              ~self ~public_input:(Input typ) ~auxiliary_typ:typ","counters":[]},{"line":"              A.to_field_elements A_value.to_field_elements rule ~wrap_domains","counters":[]},{"line":"              ~proofs_verifieds","counters":[]},{"line":"          in","counters":[]},{"line":"          let step_domains = Vector.[ inner_step_data.domains ] in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let step_keypair =","counters":[]},{"line":"            let etyp =","counters":[]},{"line":"              Impls.Step.input ~uses_lookup:No","counters":[]},{"line":"                ~proofs_verified:Max_proofs_verified.n","counters":[]},{"line":"                ~wrap_rounds:Tock.Rounds.n","counters":[]},{"line":"            in","counters":[]},{"line":"            let (T (typ, _conv, conv_inv)) = etyp in","counters":[]},{"line":"            let main () () =","counters":[]},{"line":"              let res = inner_step_data.main ~step_domains () in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              Impls.Step.with_label \"conv_inv\" (fun () -> conv_inv res)","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"            in","counters":[]},{"line":"            let open Impls.Step in","counters":[]},{"line":"            let k_p =","counters":[]},{"line":"              lazy","counters":[]},{"line":"                (let cs =","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                   constraint_system ~input_typ:Typ.unit ~return_typ:typ main","counters":[]},{"line":"                 in","counters":[]},{"line":"                 let cs_hash = Md5.to_hex (R1CS_constraint_system.digest cs) in","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"                 ( Type_equal.Id.uid self.id","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"                 , snark_keys_header","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                     { type_ = \"step-proving-key\"","counters":[]},{"line":"                     ; identifier = inner_step_data.rule.identifier","counters":[]},{"line":"                     }","counters":[]},{"line":"                     cs_hash","counters":[]},{"line":"                 , inner_step_data.index","counters":[]},{"line":"                 , cs ) )","counters":[]},{"line":"            in","counters":[]},{"line":"            let k_v =","counters":[]},{"line":"              lazy","counters":[]},{"line":"                (let id, _header, index, cs = Lazy.force k_p in","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                 let digest = R1CS_constraint_system.digest cs in","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                 ( id","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                 , snark_keys_header","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                     { type_ = \"step-verification-key\"","counters":[]},{"line":"                     ; identifier = inner_step_data.rule.identifier","counters":[]},{"line":"                     }","counters":[]},{"line":"                     (Md5.to_hex digest)","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                 , index","counters":[]},{"line":"                 , digest ) )","counters":[]},{"line":"            in","counters":[]},{"line":"            Cache.Step.read_or_generate","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"              ~prev_challenges:","counters":[]},{"line":"                (Nat.to_int (fst inner_step_data.proofs_verified))","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"              [] k_p k_v","counters":[]},{"line":"              (Snarky_backendless.Typ.unit ())","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"              typ main","counters":[]},{"line":"          in","counters":[]},{"line":"          let step_vks =","counters":[]},{"line":"            let module V = H4.To_vector (Lazy_keys) in","counters":[]},{"line":"            lazy","counters":[]},{"line":"              (Vector.map [ step_keypair ] ~f:(fun (_, vk) ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                   Tick.Keypair.vk_commitments (fst (Lazy.force vk)) ) )","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":50,"col_end":50,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"          in","counters":[]},{"line":"          let wrap_main _ =","counters":[]},{"line":"            let module SC' = SC in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let open Impls.Wrap in","counters":[]},{"line":"            let open Wrap_main_inputs in","counters":[]},{"line":"            let open Wrap_main in","counters":[]},{"line":"            let x =","counters":[]},{"line":"              exists Field.typ ~compute:(fun () -> Field.Constant.of_int 3)","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"            in","counters":[]},{"line":"            let y =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              exists Field.typ ~compute:(fun () -> Field.Constant.of_int 0)","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"            in","counters":[]},{"line":"            let z =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              exists Field.typ ~compute:(fun () -> Field.Constant.of_int 0)","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"            in","counters":[]},{"line":"            let g = Inner_curve.one in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let sponge = Sponge.create sponge_params in","counters":[]},{"line":"            Sponge.absorb sponge x ;","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            ignore (Sponge.squeeze_field sponge : Field.t) ;","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"            ignore","counters":[]},{"line":"              ( SC'.to_field_checked'","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"                  (module Impl)","counters":[]},{"line":"                  ~num_bits:16","counters":[]},{"line":"                  (Kimchi_backend_common.Scalar_challenge.create x)","counters":[{"col_start":63,"col_end":63,"count":0}]},{"line":"                : Field.t * Field.t * Field.t ) ;","counters":[]},{"line":"            ignore","counters":[]},{"line":"              (Ops.scale_fast g ~num_bits:5 (Shifted_value x) : Inner_curve.t) ;","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"            ignore","counters":[]},{"line":"              ( Scalar_challenge.endo g ~num_bits:4","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"                  (Kimchi_backend_common.Scalar_challenge.create x)","counters":[{"col_start":63,"col_end":63,"count":0}]},{"line":"                : Field.t * Field.t ) ;","counters":[]},{"line":"            for i = 0 to 64000 do","counters":[]},{"line":"              assert_r1cs x y z","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"            done","counters":[]},{"line":"          in","counters":[]},{"line":"          let (wrap_pk, wrap_vk), disk_key =","counters":[]},{"line":"            let open Impls.Wrap in","counters":[]},{"line":"            let (T (typ, conv, _conv_inv)) = input () in","counters":[]},{"line":"            let main x () : unit = wrap_main (conv x) in","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"            let self_id = Type_equal.Id.uid self.id in","counters":[]},{"line":"            let disk_key_prover =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              lazy","counters":[]},{"line":"                (let cs =","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                   constraint_system ~input_typ:typ ~return_typ:Typ.unit main","counters":[]},{"line":"                 in","counters":[]},{"line":"                 let cs_hash = Md5.to_hex (R1CS_constraint_system.digest cs) in","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"                 ( self_id","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                 , snark_keys_header","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                     { type_ = \"wrap-proving-key\"; identifier = \"\" }","counters":[]},{"line":"                     cs_hash","counters":[]},{"line":"                 , cs ) )","counters":[]},{"line":"            in","counters":[]},{"line":"            let disk_key_verifier =","counters":[]},{"line":"              lazy","counters":[]},{"line":"                (let id, _header, cs = Lazy.force disk_key_prover in","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                 let digest = R1CS_constraint_system.digest cs in","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                 ( id","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                 , snark_keys_header","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                     { type_ = \"wrap-verification-key\"; identifier = \"\" }","counters":[]},{"line":"                     (Md5.to_hex digest)","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                 , digest ) )","counters":[]},{"line":"            in","counters":[]},{"line":"            let r =","counters":[]},{"line":"              Common.time \"wrap read or generate \" (fun () ->","counters":[]},{"line":"                  Cache.Wrap.read_or_generate ~prev_challenges:2 []","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    disk_key_prover disk_key_verifier typ Typ.unit main )","counters":[]},{"line":"            in","counters":[]},{"line":"            (r, disk_key_verifier)","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          in","counters":[]},{"line":"          let wrap_vk = Lazy.map wrap_vk ~f:fst in","counters":[]},{"line":"          let module S = Step.Make (A) (A_value) (Max_proofs_verified) in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let prover =","counters":[]},{"line":"            let module Z = H4.Zip (Branch_data) (E04 (Impls.Step.Keypair)) in","counters":[]},{"line":"            let f :","counters":[]},{"line":"                   ( unit * (unit * unit)","counters":[]},{"line":"                   , unit * (unit * unit)","counters":[]},{"line":"                   , Nat.N2.n * (Nat.N2.n * unit)","counters":[]},{"line":"                   , Nat.N1.n * (Nat.N1.n * unit) )","counters":[]},{"line":"                   Branch_data.t","counters":[]},{"line":"                -> Lazy_keys.t","counters":[]},{"line":"                -> unit","counters":[]},{"line":"                -> (Max_proofs_verified.n, Max_proofs_verified.n) Proof.t","counters":[]},{"line":"                   Promise.t =","counters":[]},{"line":"             fun (T b as branch_data) (step_pk, step_vk) () ->","counters":[]},{"line":"              let (( module","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                    Req )","counters":[]},{"line":"                    : (Max_proofs_verified.n, Maxes.ns) Requests.Wrap.t ) =","counters":[]},{"line":"                Requests.Wrap.create ()","counters":[]},{"line":"              in","counters":[]},{"line":"              let (module Requests) = b.requests in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              let _, prev_vars_length = b.proofs_verified in","counters":[]},{"line":"              let step =","counters":[]},{"line":"                let wrap_vk = Lazy.force wrap_vk in","counters":[]},{"line":"                S.f branch_data () ~uses_lookup:No","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"                  ~prevs_length:prev_vars_length ~self ~public_input:(Input typ)","counters":[]},{"line":"                  ~auxiliary_typ:Impls.Step.Typ.unit ~step_domains","counters":[]},{"line":"                  ~self_dlog_plonk_index:wrap_vk.commitments","counters":[]},{"line":"                  (Impls.Step.Keypair.pk (fst (Lazy.force step_pk)))","counters":[{"col_start":39,"col_end":39,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"                  wrap_vk.index","counters":[]},{"line":"              in","counters":[]},{"line":"              let pairing_vk = fst (Lazy.force step_vk) in","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"              let wrap =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                let wrap_vk = Lazy.force wrap_vk in","counters":[]},{"line":"                let%bind.Promise proof, (), (), _ =","counters":[]},{"line":"                  step ~maxes:(module Maxes)","counters":[]},{"line":"                in","counters":[]},{"line":"                let proof =","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  { proof with","counters":[]},{"line":"                    statement =","counters":[]},{"line":"                      { proof.statement with","counters":[]},{"line":"                        messages_for_next_wrap_proof =","counters":[]},{"line":"                          pad_messages_for_next_wrap_proof","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"                            (module Maxes)","counters":[]},{"line":"                            proof.statement.messages_for_next_wrap_proof","counters":[]},{"line":"                      }","counters":[]},{"line":"                  }","counters":[]},{"line":"                in","counters":[]},{"line":"                let%map.Promise proof =","counters":[]},{"line":"                  let module Pairing_acc = Tock.Inner_curve.Affine in","counters":[]},{"line":"                  (* The prover for wrapping a proof *)","counters":[]},{"line":"                  let wrap (type actual_branching)","counters":[]},{"line":"                      ~(max_proofs_verified : Max_proofs_verified.n Nat.t)","counters":[]},{"line":"                      (module Max_local_max_proofs_verifieds : Hlist.Maxes.S","counters":[]},{"line":"                        with type ns = Maxes.ns","counters":[]},{"line":"                         and type length = Max_proofs_verified.n )","counters":[]},{"line":"                      ~dlog_plonk_index wrap_main to_field_elements ~pairing_vk","counters":[]},{"line":"                      ~step_domains ~wrap_domains ~pairing_plonk_indices pk","counters":[]},{"line":"                      ({ statement = prev_statement","counters":[]},{"line":"                       ; prev_evals","counters":[]},{"line":"                       ; proof","counters":[]},{"line":"                       ; index = which_index","counters":[]},{"line":"                       } :","counters":[]},{"line":"                        ( _","counters":[]},{"line":"                        , _","counters":[]},{"line":"                        , (_, actual_branching) Vector.t","counters":[]},{"line":"                        , (_, actual_branching) Vector.t","counters":[]},{"line":"                        , Maxes.ns","counters":[]},{"line":"                          H1.T","counters":[]},{"line":"                            (P.Base.Messages_for_next_proof_over_same_field.Wrap)","counters":[]},{"line":"                          .t","counters":[]},{"line":"                        , ( ( Tock.Field.t","counters":[]},{"line":"                            , Tock.Field.t array )","counters":[]},{"line":"                            Plonk_types.All_evals.t","counters":[]},{"line":"                          , Max_proofs_verified.n )","counters":[]},{"line":"                          Vector.t )","counters":[]},{"line":"                        P.Base.Step.t ) =","counters":[]},{"line":"                    let prev_messages_for_next_wrap_proof =","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      let module M =","counters":[]},{"line":"                        H1.Map","counters":[]},{"line":"                          (P.Base.Messages_for_next_proof_over_same_field.Wrap)","counters":[]},{"line":"                          (P.Base.Messages_for_next_proof_over_same_field.Wrap","counters":[]},{"line":"                           .Prepared)","counters":[]},{"line":"                          (struct","counters":[]},{"line":"                            let f =","counters":[]},{"line":"                              P.Base.Messages_for_next_proof_over_same_field","counters":[]},{"line":"                              .Wrap","counters":[]},{"line":"                              .prepare","counters":[]},{"line":"                          end)","counters":[]},{"line":"                      in","counters":[]},{"line":"                      M.f prev_statement.messages_for_next_wrap_proof","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                    in","counters":[]},{"line":"                    let prev_statement_with_hashes : _ Types.Step.Statement.t =","counters":[]},{"line":"                      { proof_state =","counters":[]},{"line":"                          { prev_statement.proof_state with","counters":[]},{"line":"                            messages_for_next_step_proof =","counters":[]},{"line":"                              (* TODO: Careful here... the length of","counters":[]},{"line":"                                 old_buletproof_challenges inside the messages_for_next_wrap_proof","counters":[]},{"line":"                                 might not be correct *)","counters":[]},{"line":"                              Common.hash_messages_for_next_step_proof","counters":[{"col_start":69,"col_end":69,"count":0}]},{"line":"                                ~app_state:to_field_elements","counters":[]},{"line":"                                (P.Base.Messages_for_next_proof_over_same_field","counters":[]},{"line":"                                 .Step","counters":[]},{"line":"                                 .prepare ~dlog_plonk_index","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"                                   prev_statement.proof_state","counters":[]},{"line":"                                     .messages_for_next_step_proof )","counters":[]},{"line":"                          }","counters":[]},{"line":"                      ; messages_for_next_wrap_proof =","counters":[]},{"line":"                          (let module M =","counters":[]},{"line":"                             H1.Map","counters":[]},{"line":"                               (P.Base.Messages_for_next_proof_over_same_field","counters":[]},{"line":"                                .Wrap","counters":[]},{"line":"                                .Prepared)","counters":[]},{"line":"                               (E01 (Digest.Constant))","counters":[]},{"line":"                               (struct","counters":[]},{"line":"                                 let f (type n)","counters":[]},{"line":"                                     (m :","counters":[]},{"line":"                                       n","counters":[]},{"line":"                                       P.Base","counters":[]},{"line":"                                       .Messages_for_next_proof_over_same_field","counters":[]},{"line":"                                       .Wrap","counters":[]},{"line":"                                       .Prepared","counters":[]},{"line":"                                       .t ) =","counters":[]},{"line":"                                   let T =","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                                     Nat.eq_exn max_proofs_verified","counters":[]},{"line":"                                       (Vector.length","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"                                          m.old_bulletproof_challenges )","counters":[]},{"line":"                                   in","counters":[]},{"line":"                                   Wrap_hack.hash_messages_for_next_wrap_proof","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                                     max_proofs_verified m","counters":[]},{"line":"                               end)","counters":[]},{"line":"                           in","counters":[]},{"line":"                          let module V = H1.To_vector (Digest.Constant) in","counters":[]},{"line":"                          V.f Max_local_max_proofs_verifieds.length","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                            (M.f prev_messages_for_next_wrap_proof) )","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                      }","counters":[]},{"line":"                    in","counters":[]},{"line":"                    let module O = Tick.Oracles in","counters":[]},{"line":"                    let public_input =","counters":[]},{"line":"                      tick_public_input_of_statement ~max_proofs_verified","counters":[]},{"line":"                        ~uses_lookup:No prev_statement_with_hashes","counters":[]},{"line":"                    in","counters":[]},{"line":"                    let prev_challenges =","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      Vector.map ~f:Ipa.Step.compute_challenges","counters":[]},{"line":"                        prev_statement.proof_state.messages_for_next_step_proof","counters":[]},{"line":"                          .old_bulletproof_challenges","counters":[]},{"line":"                    in","counters":[]},{"line":"                    let actual_proofs_verified =","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      Vector.length prev_challenges","counters":[]},{"line":"                    in","counters":[]},{"line":"                    let lte =","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      Nat.lte_exn actual_proofs_verified","counters":[]},{"line":"                        (Length.to_nat Max_local_max_proofs_verifieds.length)","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                    in","counters":[]},{"line":"                    let o =","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      let sgs =","counters":[]},{"line":"                        let module M =","counters":[]},{"line":"                          H1.Map","counters":[]},{"line":"                            (P.Base.Messages_for_next_proof_over_same_field.Wrap","counters":[]},{"line":"                             .Prepared)","counters":[]},{"line":"                            (E01 (Tick.Curve.Affine))","counters":[]},{"line":"                            (struct","counters":[]},{"line":"                              let f :","counters":[]},{"line":"                                  type n.","counters":[]},{"line":"                                     n","counters":[]},{"line":"                                     P.Base","counters":[]},{"line":"                                     .Messages_for_next_proof_over_same_field","counters":[]},{"line":"                                     .Wrap","counters":[]},{"line":"                                     .Prepared","counters":[]},{"line":"                                     .t","counters":[]},{"line":"                                  -> _ =","counters":[]},{"line":"                               fun t -> t.challenge_polynomial_commitment","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"                            end)","counters":[]},{"line":"                        in","counters":[]},{"line":"                        let module V = H1.To_vector (Tick.Curve.Affine) in","counters":[]},{"line":"                        V.f Max_local_max_proofs_verifieds.length","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                          (M.f prev_messages_for_next_wrap_proof)","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                      in","counters":[]},{"line":"                      O.create pairing_vk","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                        Vector.(","counters":[]},{"line":"                          map2 (Vector.trim sgs lte) prev_challenges","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"                            ~f:(fun commitment cs ->","counters":[]},{"line":"                              { Tick.Proof.Challenge_polynomial.commitment","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                              ; challenges = Vector.to_array cs","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"                              } )","counters":[]},{"line":"                          |> to_list)","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                        public_input proof","counters":[]},{"line":"                    in","counters":[]},{"line":"                    let x_hat = O.(p_eval_1 o, p_eval_2 o) in","counters":[{"col_start":42,"col_end":42,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"                    let step_vk, _ = Lazy.force step_vk in","counters":[]},{"line":"                    let next_statement : _ Types.Wrap.Statement.In_circuit.t =","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      let scalar_chal f =","counters":[]},{"line":"                        Scalar_challenge.map ~f:Challenge.Constant.of_tick_field","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          (f o)","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                      in","counters":[]},{"line":"                      let sponge_digest_before_evaluations =","counters":[]},{"line":"                        O.digest_before_evaluations o","counters":[]},{"line":"                      in","counters":[]},{"line":"                      let plonk0 =","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        { Types.Wrap.Proof_state.Deferred_values.Plonk.Minimal","counters":[]},{"line":"                          .alpha = scalar_chal O.alpha","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"                        ; beta = O.beta o","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"                        ; gamma = O.gamma o","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"                        ; zeta = scalar_chal O.zeta","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"                        ; joint_combiner =","counters":[]},{"line":"                            Option.map (O.joint_combiner_chal o)","counters":[{"col_start":37,"col_end":37,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"                              ~f:","counters":[]},{"line":"                                (Scalar_challenge.map","counters":[]},{"line":"                                   ~f:Challenge.Constant.of_tick_field )","counters":[]},{"line":"                        }","counters":[]},{"line":"                      in","counters":[]},{"line":"                      let r = scalar_chal O.u in","counters":[]},{"line":"                      let xi = scalar_chal O.v in","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                      let to_field =","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        SC.to_field_constant","counters":[]},{"line":"                          (module Tick.Field)","counters":[]},{"line":"                          ~endo:Endo.Wrap_inner_curve.scalar","counters":[]},{"line":"                      in","counters":[]},{"line":"                      let module As_field = struct","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        let r = to_field r","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"                        let xi = to_field xi","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"                        let zeta = to_field plonk0.zeta","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"","counters":[]},{"line":"                        let alpha = to_field plonk0.alpha","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"","counters":[]},{"line":"                        let joint_combiner =","counters":[]},{"line":"                          Option.map ~f:to_field plonk0.joint_combiner","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                      end in","counters":[]},{"line":"                      let domain =","counters":[]},{"line":"                        Domain.Pow_2_roots_of_unity","counters":[]},{"line":"                          step_vk.domain.log_size_of_group","counters":[]},{"line":"                      in","counters":[]},{"line":"                      let w = step_vk.domain.group_gen in","counters":[]},{"line":"                      (* Debug *)","counters":[]},{"line":"                      [%test_eq: Tick.Field.t] w","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"                        (Tick.Field.domain_generator","counters":[]},{"line":"                           ~log2_size:(Domain.log2_size domain) ) ;","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"                      let zetaw = Tick.Field.mul As_field.zeta w in","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                      let tick_plonk_minimal =","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        { plonk0 with","counters":[]},{"line":"                          zeta = As_field.zeta","counters":[]},{"line":"                        ; alpha = As_field.alpha","counters":[]},{"line":"                        ; joint_combiner = As_field.joint_combiner","counters":[]},{"line":"                        }","counters":[]},{"line":"                      in","counters":[]},{"line":"                      let tick_combined_evals =","counters":[]},{"line":"                        Plonk_checks.evals_of_split_evals","counters":[]},{"line":"                          (module Tick.Field)","counters":[]},{"line":"                          proof.openings.evals","counters":[]},{"line":"                          ~rounds:(Nat.to_int Tick.Rounds.n) ~zeta:As_field.zeta","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"                          ~zetaw","counters":[]},{"line":"                      in","counters":[]},{"line":"                      let tick_domain =","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        Plonk_checks.domain","counters":[]},{"line":"                          (module Tick.Field)","counters":[]},{"line":"                          domain ~shifts:Common.tick_shifts","counters":[]},{"line":"                          ~domain_generator:Backend.Tick.Field.domain_generator","counters":[]},{"line":"                      in","counters":[]},{"line":"                      let tick_combined_evals =","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        Plonk_types.Evals.to_in_circuit tick_combined_evals","counters":[]},{"line":"                      in","counters":[]},{"line":"                      let tick_env =","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        Plonk_checks.scalars_env","counters":[]},{"line":"                          (module Tick.Field)","counters":[]},{"line":"                          ~endo:Endo.Step_inner_curve.base","counters":[]},{"line":"                          ~mds:Tick_field_sponge.params.mds","counters":[]},{"line":"                          ~srs_length_log2:Common.Max_degree.step_log2","counters":[]},{"line":"                          ~field_of_hex:(fun s ->","counters":[]},{"line":"                            Kimchi_pasta.Pasta.Bigint256.of_hex_string s","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"                            |> Kimchi_pasta.Pasta.Fp.of_bigint )","counters":[]},{"line":"                          ~domain:tick_domain tick_plonk_minimal","counters":[]},{"line":"                          tick_combined_evals","counters":[]},{"line":"                      in","counters":[]},{"line":"                      let combined_inner_product =","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        let open As_field in","counters":[]},{"line":"                        Wrap.combined_inner_product","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                        (* Note: We do not pad here. *)","counters":[]},{"line":"                          ~actual_proofs_verified:","counters":[]},{"line":"                            (Nat.Add.create actual_proofs_verified)","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"                          { evals = proof.openings.evals; public_input = x_hat }","counters":[]},{"line":"                          ~r ~xi ~zeta ~zetaw","counters":[]},{"line":"                          ~old_bulletproof_challenges:prev_challenges","counters":[]},{"line":"                          ~env:tick_env ~domain:tick_domain","counters":[]},{"line":"                          ~ft_eval1:proof.openings.ft_eval1","counters":[]},{"line":"                          ~plonk:tick_plonk_minimal","counters":[]},{"line":"                      in","counters":[]},{"line":"                      let chal = Challenge.Constant.of_tick_field in","counters":[]},{"line":"                      let sg_new, new_bulletproof_challenges, b =","counters":[]},{"line":"                        let prechals =","counters":[]},{"line":"                          Array.map (O.opening_prechallenges o) ~f:(fun x ->","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"                              let x =","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                                Scalar_challenge.map","counters":[]},{"line":"                                  ~f:Challenge.Constant.of_tick_field x","counters":[]},{"line":"                              in","counters":[]},{"line":"                              x )","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                        in","counters":[]},{"line":"                        let chals =","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          Array.map prechals ~f:(fun x ->","counters":[]},{"line":"                              Ipa.Step.compute_challenge x )","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                        in","counters":[]},{"line":"                        let challenge_polynomial =","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          unstage (Wrap.challenge_polynomial chals)","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"                        in","counters":[]},{"line":"                        let open As_field in","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                        let b =","counters":[]},{"line":"                          let open Tick.Field in","counters":[]},{"line":"                          challenge_polynomial zeta","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"                          + (r * challenge_polynomial zetaw)","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"                        in","counters":[]},{"line":"                        let overwritten_prechals =","counters":[]},{"line":"                          Array.map prechals","counters":[]},{"line":"                            ~f:","counters":[]},{"line":"                              (Scalar_challenge.map ~f:(fun _ ->","counters":[]},{"line":"                                   Challenge.Constant.of_tick_field","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                                     (Impls.Step.Field.Constant.of_int 100) ) )","counters":[{"col_start":69,"col_end":69,"count":0}]},{"line":"                        in","counters":[]},{"line":"                        let chals =","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          Array.map overwritten_prechals ~f:(fun x ->","counters":[]},{"line":"                              Ipa.Step.compute_challenge x )","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                        in","counters":[]},{"line":"                        let sg_new =","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          let urs = Backend.Tick.Keypair.load_urs () in","counters":[]},{"line":"                          Kimchi_bindings.Protocol.SRS.Fp","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                          .batch_accumulator_generate urs 1 chals","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"                        in","counters":[]},{"line":"                        let sg_new =","counters":[]},{"line":"                          match sg_new with","counters":[]},{"line":"                          | [| Kimchi_types.Finite x |] ->","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                              x","counters":[]},{"line":"                          | _ ->","counters":[]},{"line":"                              assert false","counters":[]},{"line":"                        in","counters":[]},{"line":"                        let overwritten_prechals =","counters":[]},{"line":"                          Array.map overwritten_prechals ~f:(fun x ->","counters":[]},{"line":"                              { Bulletproof_challenge.prechallenge = x } )","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                        in","counters":[]},{"line":"                        (sg_new, overwritten_prechals, b)","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                      in","counters":[]},{"line":"                      let plonk =","counters":[]},{"line":"                        Wrap.Plonk_checks.Type1.derive_plonk","counters":[]},{"line":"                          (module Tick.Field)","counters":[]},{"line":"                          ~shift:Shifts.tick1 ~env:tick_env tick_plonk_minimal","counters":[]},{"line":"                          tick_combined_evals","counters":[]},{"line":"                      in","counters":[]},{"line":"                      let shift_value =","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        Shifted_value.Type1.of_field","counters":[]},{"line":"                          (module Tick.Field)","counters":[]},{"line":"                          ~shift:Shifts.tick1","counters":[]},{"line":"                      in","counters":[]},{"line":"                      let branch_data : Composition_types.Branch_data.t =","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        { proofs_verified =","counters":[]},{"line":"                            ( match actual_proofs_verified with","counters":[]},{"line":"                            | Z ->","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                                Composition_types.Branch_data.Proofs_verified.N0","counters":[]},{"line":"                            | S Z ->","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                                N1","counters":[]},{"line":"                            | S (S Z) ->","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                                N2","counters":[]},{"line":"                            | _ ->","counters":[]},{"line":"                                assert false )","counters":[]},{"line":"                        ; domain_log2 =","counters":[]},{"line":"                            Composition_types.Branch_data.Domain_log2.of_int_exn","counters":[{"col_start":79,"col_end":79,"count":0}]},{"line":"                              step_vk.domain.log_size_of_group","counters":[]},{"line":"                        }","counters":[]},{"line":"                      in","counters":[]},{"line":"                      let messages_for_next_wrap_proof :","counters":[]},{"line":"                          _","counters":[]},{"line":"                          P.Base.Messages_for_next_proof_over_same_field.Wrap.t","counters":[]},{"line":"                          =","counters":[]},{"line":"                        { challenge_polynomial_commitment = sg_new","counters":[]},{"line":"                        ; old_bulletproof_challenges =","counters":[]},{"line":"                            Vector.map","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                              prev_statement.proof_state.unfinalized_proofs","counters":[]},{"line":"                              ~f:(fun t ->","counters":[]},{"line":"                                t.deferred_values.bulletproof_challenges )","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                        }","counters":[]},{"line":"                      in","counters":[]},{"line":"                      { proof_state =","counters":[]},{"line":"                          { deferred_values =","counters":[]},{"line":"                              { xi","counters":[]},{"line":"                              ; b = shift_value b","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"                              ; bulletproof_challenges =","counters":[]},{"line":"                                  Vector.of_array_and_length_exn","counters":[{"col_start":63,"col_end":63,"count":0}]},{"line":"                                    new_bulletproof_challenges Tick.Rounds.n","counters":[]},{"line":"                              ; combined_inner_product =","counters":[]},{"line":"                                  shift_value combined_inner_product","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"                              ; branch_data","counters":[]},{"line":"                              ; plonk =","counters":[]},{"line":"                                  { plonk with","counters":[]},{"line":"                                    zeta = plonk0.zeta","counters":[]},{"line":"                                  ; alpha = plonk0.alpha","counters":[]},{"line":"                                  ; beta = chal plonk0.beta","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"                                  ; gamma = chal plonk0.gamma","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"                                  ; lookup = Plonk_types.Opt.None","counters":[]},{"line":"                                  }","counters":[]},{"line":"                              }","counters":[]},{"line":"                          ; sponge_digest_before_evaluations =","counters":[]},{"line":"                              Digest.Constant.of_tick_field","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"                                sponge_digest_before_evaluations","counters":[]},{"line":"                          ; messages_for_next_wrap_proof","counters":[]},{"line":"                          }","counters":[]},{"line":"                      ; messages_for_next_step_proof =","counters":[]},{"line":"                          prev_statement.proof_state","counters":[]},{"line":"                            .messages_for_next_step_proof","counters":[]},{"line":"                      }","counters":[]},{"line":"                    in","counters":[]},{"line":"                    let messages_for_next_wrap_proof_prepared =","counters":[]},{"line":"                      P.Base.Messages_for_next_proof_over_same_field.Wrap","counters":[]},{"line":"                      .prepare","counters":[]},{"line":"                        next_statement.proof_state.messages_for_next_wrap_proof","counters":[]},{"line":"                    in","counters":[]},{"line":"                    let%map.Promise next_proof =","counters":[]},{"line":"                      let (T (input, conv, _conv_inv)) = Impls.Wrap.input () in","counters":[]},{"line":"                      Common.time \"wrap proof\" (fun () ->","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"                          Impls.Wrap.generate_witness_conv","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            ~f:(fun { Impls.Wrap.Proof_inputs.auxiliary_inputs","counters":[]},{"line":"                                    ; public_inputs","counters":[]},{"line":"                                    } () ->","counters":[]},{"line":"                              Backend.Tock.Proof.create_async","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                                ~primary:public_inputs","counters":[]},{"line":"                                ~auxiliary:auxiliary_inputs pk","counters":[]},{"line":"                                ~message:","counters":[]},{"line":"                                  ( Vector.map2","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"                                      (Vector.extend_exn","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"                                         prev_statement.proof_state","counters":[]},{"line":"                                           .messages_for_next_step_proof","counters":[]},{"line":"                                           .challenge_polynomial_commitments","counters":[]},{"line":"                                         max_proofs_verified","counters":[]},{"line":"                                         (Lazy.force Dummy.Ipa.Wrap.sg) )","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                                      messages_for_next_wrap_proof_prepared","counters":[]},{"line":"                                        .old_bulletproof_challenges","counters":[]},{"line":"                                      ~f:(fun sg chals ->","counters":[]},{"line":"                                        { Tock.Proof.Challenge_polynomial","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"                                          .commitment = sg","counters":[]},{"line":"                                        ; challenges = Vector.to_array chals","counters":[{"col_start":69,"col_end":69,"count":0}]},{"line":"                                        } )","counters":[]},{"line":"                                  |> Wrap_hack.pad_accumulator ) )","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"                            ~input_typ:input","counters":[]},{"line":"                            ~return_typ:(Snarky_backendless.Typ.unit ())","counters":[{"col_start":67,"col_end":67,"count":0}]},{"line":"                            (fun x () : unit -> wrap_main (conv x))","counters":[{"col_start":48,"col_end":48,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"                            { messages_for_next_step_proof =","counters":[]},{"line":"                                prev_statement_with_hashes.proof_state","counters":[]},{"line":"                                  .messages_for_next_step_proof","counters":[]},{"line":"                            ; proof_state =","counters":[]},{"line":"                                { next_statement.proof_state with","counters":[]},{"line":"                                  messages_for_next_wrap_proof =","counters":[]},{"line":"                                    Wrap_hack.hash_messages_for_next_wrap_proof","counters":[{"col_start":78,"col_end":78,"count":0}]},{"line":"                                      max_proofs_verified","counters":[]},{"line":"                                      messages_for_next_wrap_proof_prepared","counters":[]},{"line":"                                ; deferred_values =","counters":[]},{"line":"                                    { next_statement.proof_state.deferred_values with","counters":[]},{"line":"                                      plonk =","counters":[]},{"line":"                                        { next_statement.proof_state","counters":[]},{"line":"                                            .deferred_values","counters":[]},{"line":"                                            .plonk","counters":[]},{"line":"                                          with","counters":[]},{"line":"                                          lookup = None","counters":[]},{"line":"                                        }","counters":[]},{"line":"                                    }","counters":[]},{"line":"                                }","counters":[]},{"line":"                            } )","counters":[]},{"line":"                    in","counters":[]},{"line":"                    ( { proof = next_proof","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                      ; statement =","counters":[]},{"line":"                          Types.Wrap.Statement.to_minimal","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"                            ~to_option:Plonk_types.Opt.to_option next_statement","counters":[]},{"line":"                      ; prev_evals =","counters":[]},{"line":"                          { Plonk_types.All_evals.evals =","counters":[]},{"line":"                              { public_input = x_hat","counters":[]},{"line":"                              ; evals = proof.openings.evals","counters":[]},{"line":"                              }","counters":[]},{"line":"                          ; ft_eval1 = proof.openings.ft_eval1","counters":[]},{"line":"                          }","counters":[]},{"line":"                      }","counters":[]},{"line":"                      : _ P.Base.Wrap.t )","counters":[]},{"line":"                  in","counters":[]},{"line":"                  wrap ~max_proofs_verified:Max_proofs_verified.n","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                    full_signature.maxes ~dlog_plonk_index:wrap_vk.commitments","counters":[]},{"line":"                    wrap_main A_value.to_field_elements ~pairing_vk","counters":[]},{"line":"                    ~step_domains:b.domains","counters":[]},{"line":"                    ~pairing_plonk_indices:(Lazy.force step_vks) ~wrap_domains","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"                    (Impls.Wrap.Keypair.pk (fst (Lazy.force wrap_pk)))","counters":[{"col_start":41,"col_end":41,"count":0},{"col_start":46,"col_end":46,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"                    proof","counters":[]},{"line":"                in","counters":[]},{"line":"                Proof.T","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  { proof with","counters":[]},{"line":"                    statement =","counters":[]},{"line":"                      { proof.statement with","counters":[]},{"line":"                        messages_for_next_step_proof =","counters":[]},{"line":"                          { proof.statement.messages_for_next_step_proof with","counters":[]},{"line":"                            app_state = ()","counters":[]},{"line":"                          }","counters":[]},{"line":"                      }","counters":[]},{"line":"                  }","counters":[]},{"line":"              in","counters":[]},{"line":"              wrap","counters":[]},{"line":"            in","counters":[]},{"line":"            f step_data step_keypair","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          in","counters":[]},{"line":"          let data : _ Types_map.Compiled.t =","counters":[]},{"line":"            { branches = Branches.n","counters":[]},{"line":"            ; step_uses_lookup = No","counters":[]},{"line":"            ; proofs_verifieds","counters":[]},{"line":"            ; max_proofs_verified = (module Max_proofs_verified)","counters":[]},{"line":"            ; public_input = typ","counters":[]},{"line":"            ; wrap_key = Lazy.map wrap_vk ~f:Verification_key.commitments","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"            ; wrap_vk = Lazy.map wrap_vk ~f:Verification_key.index","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"            ; wrap_domains","counters":[]},{"line":"            ; step_domains","counters":[]},{"line":"            }","counters":[]},{"line":"          in","counters":[]},{"line":"          Types_map.add_exn self data ;","counters":[]},{"line":"          (prover, wrap_vk, disk_key)","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      let step, wrap_vk, wrap_disk_key = M.compile","counters":[]},{"line":"","counters":[]},{"line":"      module Proof = struct","counters":[]},{"line":"        type statement = A_value.t","counters":[]},{"line":"","counters":[]},{"line":"        module Max_local_max_proofs_verified = Max_proofs_verified","counters":[]},{"line":"        module Max_proofs_verified_vec = Nvector (Max_proofs_verified)","counters":[]},{"line":"        include Proof.Make (Max_proofs_verified) (Max_local_max_proofs_verified)","counters":[]},{"line":"","counters":[]},{"line":"        let id = wrap_disk_key","counters":[]},{"line":"","counters":[]},{"line":"        let verification_key = wrap_vk","counters":[]},{"line":"","counters":[]},{"line":"        let verify ts =","counters":[]},{"line":"          verify_promise","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (module Max_proofs_verified)","counters":[]},{"line":"            (module A_value)","counters":[]},{"line":"            (Lazy.force verification_key)","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"            ts","counters":[]},{"line":"","counters":[]},{"line":"        let statement (T p : t) =","counters":[]},{"line":"          p.statement.messages_for_next_step_proof.app_state","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      let proof_with_stmt =","counters":[]},{"line":"        let p = Promise.block_on_async_exn (fun () -> step ()) in","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"        ((), p)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      let%test \"should not be able to verify invalid proof\" =","counters":[]},{"line":"        not","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        @@ Promise.block_on_async_exn (fun () ->","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"               Proof.verify [ proof_with_stmt ] )","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"","counters":[]},{"line":"      module Recurse_on_bad_proof = struct","counters":[]},{"line":"        open Impls.Step","counters":[]},{"line":"","counters":[]},{"line":"        let dummy_proof =","counters":[]},{"line":"          Proof0.dummy Nat.N2.n Nat.N2.n Nat.N2.n ~domain_log2:15","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"","counters":[]},{"line":"        type _ Snarky_backendless.Request.t +=","counters":[]},{"line":"          | Proof : (Nat.N2.n, Nat.N2.n) Proof0.t Snarky_backendless.Request.t","counters":[]},{"line":"","counters":[]},{"line":"        let handler (proof : _ Proof0.t)","counters":[]},{"line":"            (Snarky_backendless.Request.With { request; respond }) =","counters":[]},{"line":"          match request with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | Proof ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              respond (Provide proof)","counters":[]},{"line":"          | _ ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              respond Unhandled","counters":[]},{"line":"","counters":[]},{"line":"        let tag, _, p, Provers.[ step ] =","counters":[]},{"line":"          Common.time \"compile\" (fun () ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"              compile_promise () ~public_input:(Input Typ.unit)","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ~auxiliary_typ:Typ.unit","counters":[]},{"line":"                ~branches:(module Nat.N1)","counters":[]},{"line":"                ~max_proofs_verified:(module Nat.N2)","counters":[]},{"line":"                ~name:\"recurse-on-bad\" ~constraint_constants","counters":[]},{"line":"                ~choices:(fun ~self ->","counters":[]},{"line":"                  [ { identifier = \"main\"","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    ; uses_lookup = false","counters":[]},{"line":"                    ; prevs = [ tag; tag ]","counters":[]},{"line":"                    ; main =","counters":[]},{"line":"                        (fun { public_input = () } ->","counters":[]},{"line":"                          let proof =","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            exists (Typ.Internal.ref ()) ~request:(fun () ->","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                                Proof )","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                          in","counters":[]},{"line":"                          { previous_proof_statements =","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                              [ { public_input = ()","counters":[]},{"line":"                                ; proof","counters":[]},{"line":"                                ; proof_must_verify = Boolean.true_","counters":[]},{"line":"                                }","counters":[]},{"line":"                              ; { public_input = ()","counters":[]},{"line":"                                ; proof","counters":[]},{"line":"                                ; proof_must_verify = Boolean.true_","counters":[]},{"line":"                                }","counters":[]},{"line":"                              ]","counters":[]},{"line":"                          ; public_output = ()","counters":[]},{"line":"                          ; auxiliary_output = ()","counters":[]},{"line":"                          } )","counters":[]},{"line":"                    }","counters":[]},{"line":"                  ] ) )","counters":[]},{"line":"","counters":[]},{"line":"        module Proof = (val p)","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      let%test \"should not be able to create a recursive proof from an invalid \\","counters":[]},{"line":"                proof\" =","counters":[]},{"line":"        try","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let (), (), proof =","counters":[]},{"line":"            Promise.block_on_async_exn (fun () ->","counters":[]},{"line":"                Recurse_on_bad_proof.step","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  ~handler:(Recurse_on_bad_proof.handler (snd proof_with_stmt))","counters":[{"col_start":55,"col_end":55,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"                  () )","counters":[]},{"line":"          in","counters":[]},{"line":"          not","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":12,"col_end":12,"count":0}]},{"line":"          @@ Promise.block_on_async_exn (fun () ->","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"                 Recurse_on_bad_proof.Proof.verify_promise [ ((), proof) ] )","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"        with _ -> true","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"    end )","counters":[]},{"line":"","counters":[]},{"line":"  let%test_module \"test uncorrelated deferred b\" =","counters":[]},{"line":"    ( module struct","counters":[]},{"line":"      let () = Backtrace.elide := false","counters":[]},{"line":"","counters":[]},{"line":"      let () = Snarky_backendless.Snark0.set_eval_constraints true","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"","counters":[]},{"line":"      module Statement = struct","counters":[]},{"line":"        type t = unit","counters":[]},{"line":"","counters":[]},{"line":"        let to_field_elements () = [||]","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      module A = Statement","counters":[]},{"line":"      module A_value = Statement","counters":[]},{"line":"","counters":[]},{"line":"      let typ = Impls.Step.Typ.unit","counters":[]},{"line":"","counters":[]},{"line":"      module Branches = Nat.N1","counters":[]},{"line":"      module Max_proofs_verified = Nat.N2","counters":[]},{"line":"","counters":[]},{"line":"      let constraint_constants : Snark_keys_header.Constraint_constants.t =","counters":[]},{"line":"        { sub_windows_per_window = 0","counters":[]},{"line":"        ; ledger_depth = 0","counters":[]},{"line":"        ; work_delay = 0","counters":[]},{"line":"        ; block_window_duration_ms = 0","counters":[]},{"line":"        ; transaction_capacity = Log_2 0","counters":[]},{"line":"        ; pending_coinbase_depth = 0","counters":[]},{"line":"        ; coinbase_amount = Unsigned.UInt64.of_int 0","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"        ; supercharged_coinbase_factor = 0","counters":[]},{"line":"        ; account_creation_fee = Unsigned.UInt64.of_int 0","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"        ; fork = None","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"      let tag =","counters":[]},{"line":"        { Tag.id = Type_equal.Id.create ~name:\"\" sexp_of_opaque","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"        ; kind = Compiled","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"      let rule : _ Inductive_rule.t =","counters":[]},{"line":"        let open Impls.Step in","counters":[]},{"line":"        { identifier = \"main\"","counters":[]},{"line":"        ; uses_lookup = false","counters":[]},{"line":"        ; prevs = [ tag; tag ]","counters":[]},{"line":"        ; main =","counters":[]},{"line":"            (fun { public_input = () } ->","counters":[]},{"line":"              let dummy_proof =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                As_prover.Ref.create (fun () ->","counters":[]},{"line":"                    Proof0.dummy Nat.N2.n Nat.N2.n Nat.N2.n ~domain_log2:15 )","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"              in","counters":[]},{"line":"              { previous_proof_statements =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                  [ { public_input = ()","counters":[]},{"line":"                    ; proof = dummy_proof","counters":[]},{"line":"                    ; proof_must_verify = Boolean.false_","counters":[]},{"line":"                    }","counters":[]},{"line":"                  ; { public_input = ()","counters":[]},{"line":"                    ; proof = dummy_proof","counters":[]},{"line":"                    ; proof_must_verify = Boolean.false_","counters":[]},{"line":"                    }","counters":[]},{"line":"                  ]","counters":[]},{"line":"              ; public_output = ()","counters":[]},{"line":"              ; auxiliary_output = ()","counters":[]},{"line":"              } )","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"      module M = struct","counters":[]},{"line":"        module IR = Inductive_rule.T (A) (A_value) (A) (A_value) (A) (A_value)","counters":[]},{"line":"        module HIR = H4.T (IR)","counters":[]},{"line":"","counters":[]},{"line":"        let max_local_max_proofs_verifieds ~self (type n)","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"            (module Max_proofs_verified : Nat.Intf with type n = n) branches","counters":[]},{"line":"            choices =","counters":[]},{"line":"          let module Local_max_proofs_verifieds = struct","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            type t = (int, Max_proofs_verified.n) Vector.t","counters":[]},{"line":"          end in","counters":[]},{"line":"          let module M =","counters":[]},{"line":"            H4.Map (IR) (E04 (Local_max_proofs_verifieds))","counters":[]},{"line":"              (struct","counters":[]},{"line":"                module V = H4.To_vector (Int)","counters":[]},{"line":"                module HT = H4.T (Tag)","counters":[]},{"line":"","counters":[]},{"line":"                module M =","counters":[]},{"line":"                  H4.Map (Tag) (E04 (Int))","counters":[]},{"line":"                    (struct","counters":[]},{"line":"                      let f (type a b c d) (t : (a, b, c, d) Tag.t) : int =","counters":[]},{"line":"                        if Type_equal.Id.same t.id self then","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          Nat.to_int Max_proofs_verified.n","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                        else","counters":[]},{"line":"                          let (module M) = Types_map.max_proofs_verified t in","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                          Nat.to_int M.n","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                    end)","counters":[]},{"line":"","counters":[]},{"line":"                let f :","counters":[]},{"line":"                    type a b c d.","counters":[]},{"line":"                    (a, b, c, d) IR.t -> Local_max_proofs_verifieds.t =","counters":[]},{"line":"                 fun rule ->","counters":[]},{"line":"                  let (T (_, l)) = HT.length rule.prevs in","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  Vector.extend_exn","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    (V.f l (M.f rule.prevs))","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"                    Max_proofs_verified.n 0","counters":[]},{"line":"              end)","counters":[]},{"line":"          in","counters":[]},{"line":"          let module V = H4.To_vector (Local_max_proofs_verifieds) in","counters":[]},{"line":"          let padded = V.f branches (M.f choices) |> Vector.transpose in","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"          (padded, Maxes.m padded)","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"        module Lazy_ (A : T0) = struct","counters":[]},{"line":"          type t = A.t Lazy.t","counters":[]},{"line":"        end","counters":[]},{"line":"","counters":[]},{"line":"        module Lazy_keys = struct","counters":[]},{"line":"          type t =","counters":[]},{"line":"            (Impls.Step.Keypair.t * Dirty.t) Lazy.t","counters":[]},{"line":"            * (Kimchi_bindings.Protocol.VerifierIndex.Fp.t * Dirty.t) Lazy.t","counters":[]},{"line":"","counters":[]},{"line":"          (* TODO Think this is right.. *)","counters":[]},{"line":"        end","counters":[]},{"line":"","counters":[]},{"line":"        let compile :","counters":[]},{"line":"            (   unit","counters":[]},{"line":"             -> (Max_proofs_verified.n, Max_proofs_verified.n) Proof.t Promise.t","counters":[]},{"line":"            )","counters":[]},{"line":"            * _","counters":[]},{"line":"            * _ =","counters":[]},{"line":"          let self = tag in","counters":[]},{"line":"          let snark_keys_header kind constraint_system_hash =","counters":[]},{"line":"            { Snark_keys_header.header_version =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"                Snark_keys_header.header_version","counters":[]},{"line":"            ; kind","counters":[]},{"line":"            ; constraint_constants","counters":[]},{"line":"            ; commits =","counters":[]},{"line":"                { mina = Mina_version.commit_id","counters":[]},{"line":"                ; marlin = Mina_version.marlin_commit_id","counters":[]},{"line":"                }","counters":[]},{"line":"            ; length = (* This is a dummy, it gets filled in on read/write. *) 0","counters":[]},{"line":"            ; commit_date = Mina_version.commit_date","counters":[]},{"line":"            ; constraint_system_hash","counters":[]},{"line":"            ; identifying_hash =","counters":[]},{"line":"                (* TODO: Proper identifying hash. *)","counters":[]},{"line":"                constraint_system_hash","counters":[]},{"line":"            }","counters":[]},{"line":"          in","counters":[]},{"line":"          let T = Max_proofs_verified.eq in","counters":[]},{"line":"          let prev_varss_n = Branches.n in","counters":[]},{"line":"          let prev_varss_length : _ Length.t = S Z in","counters":[]},{"line":"          let T = Nat.eq_exn prev_varss_n Branches.n in","counters":[]},{"line":"          let padded, (module Maxes) =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            max_local_max_proofs_verifieds","counters":[]},{"line":"              (module Max_proofs_verified)","counters":[]},{"line":"              prev_varss_length [ rule ] ~self:self.id","counters":[]},{"line":"          in","counters":[]},{"line":"          let full_signature =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            { Full_signature.padded; maxes = (module Maxes) }","counters":[]},{"line":"          in","counters":[]},{"line":"          let wrap_domains =","counters":[]},{"line":"            let module M =","counters":[]},{"line":"              Wrap_domains.Make (A) (A_value) (A) (A_value) (A) (A_value)","counters":[]},{"line":"            in","counters":[]},{"line":"            M.f full_signature prev_varss_n prev_varss_length ~self","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              ~choices:[ rule ]","counters":[]},{"line":"              ~max_proofs_verified:(module Max_proofs_verified)","counters":[]},{"line":"          in","counters":[]},{"line":"          let module Branch_data = struct","counters":[]},{"line":"            type ('vars, 'vals, 'n, 'm) t =","counters":[]},{"line":"              ( A.t","counters":[]},{"line":"              , A_value.t","counters":[]},{"line":"              , A.t","counters":[]},{"line":"              , A_value.t","counters":[]},{"line":"              , A.t","counters":[]},{"line":"              , A_value.t","counters":[]},{"line":"              , Max_proofs_verified.n","counters":[]},{"line":"              , Branches.n","counters":[]},{"line":"              , 'vars","counters":[]},{"line":"              , 'vals","counters":[]},{"line":"              , 'n","counters":[]},{"line":"              , 'm )","counters":[]},{"line":"              Step_branch_data.t","counters":[]},{"line":"          end in","counters":[]},{"line":"          let proofs_verifieds = Vector.[ 2 ] in","counters":[]},{"line":"          let (T inner_step_data as step_data) =","counters":[]},{"line":"            Step_branch_data.create ~index:0 ~step_uses_lookup:No","counters":[]},{"line":"              ~max_proofs_verified:Max_proofs_verified.n ~branches:Branches.n","counters":[]},{"line":"              ~self ~public_input:(Input typ) ~auxiliary_typ:typ","counters":[]},{"line":"              A.to_field_elements A_value.to_field_elements rule ~wrap_domains","counters":[]},{"line":"              ~proofs_verifieds","counters":[]},{"line":"          in","counters":[]},{"line":"          let step_domains = Vector.[ inner_step_data.domains ] in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let step_keypair =","counters":[]},{"line":"            let etyp =","counters":[]},{"line":"              Impls.Step.input ~uses_lookup:No","counters":[]},{"line":"                ~proofs_verified:Max_proofs_verified.n","counters":[]},{"line":"                ~wrap_rounds:Tock.Rounds.n","counters":[]},{"line":"            in","counters":[]},{"line":"            let (T (typ, _conv, conv_inv)) = etyp in","counters":[]},{"line":"            let main () () =","counters":[]},{"line":"              let res = inner_step_data.main ~step_domains () in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              Impls.Step.with_label \"conv_inv\" (fun () -> conv_inv res)","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"            in","counters":[]},{"line":"            let open Impls.Step in","counters":[]},{"line":"            let k_p =","counters":[]},{"line":"              lazy","counters":[]},{"line":"                (let cs =","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                   constraint_system ~input_typ:Typ.unit ~return_typ:typ main","counters":[]},{"line":"                 in","counters":[]},{"line":"                 let cs_hash = Md5.to_hex (R1CS_constraint_system.digest cs) in","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"                 ( Type_equal.Id.uid self.id","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"                 , snark_keys_header","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                     { type_ = \"step-proving-key\"","counters":[]},{"line":"                     ; identifier = inner_step_data.rule.identifier","counters":[]},{"line":"                     }","counters":[]},{"line":"                     cs_hash","counters":[]},{"line":"                 , inner_step_data.index","counters":[]},{"line":"                 , cs ) )","counters":[]},{"line":"            in","counters":[]},{"line":"            let k_v =","counters":[]},{"line":"              lazy","counters":[]},{"line":"                (let id, _header, index, cs = Lazy.force k_p in","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                 let digest = R1CS_constraint_system.digest cs in","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                 ( id","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                 , snark_keys_header","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                     { type_ = \"step-verification-key\"","counters":[]},{"line":"                     ; identifier = inner_step_data.rule.identifier","counters":[]},{"line":"                     }","counters":[]},{"line":"                     (Md5.to_hex digest)","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                 , index","counters":[]},{"line":"                 , digest ) )","counters":[]},{"line":"            in","counters":[]},{"line":"            Cache.Step.read_or_generate","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"              ~prev_challenges:","counters":[]},{"line":"                (Nat.to_int (fst inner_step_data.proofs_verified))","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"              [] k_p k_v","counters":[]},{"line":"              (Snarky_backendless.Typ.unit ())","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"              typ main","counters":[]},{"line":"          in","counters":[]},{"line":"          let step_vks =","counters":[]},{"line":"            let module V = H4.To_vector (Lazy_keys) in","counters":[]},{"line":"            lazy","counters":[]},{"line":"              (Vector.map [ step_keypair ] ~f:(fun (_, vk) ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                   Tick.Keypair.vk_commitments (fst (Lazy.force vk)) ) )","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":50,"col_end":50,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"          in","counters":[]},{"line":"          let wrap_main _ =","counters":[]},{"line":"            let module SC' = SC in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let open Impls.Wrap in","counters":[]},{"line":"            let open Wrap_main_inputs in","counters":[]},{"line":"            let open Wrap_main in","counters":[]},{"line":"            let x =","counters":[]},{"line":"              exists Field.typ ~compute:(fun () -> Field.Constant.of_int 3)","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"            in","counters":[]},{"line":"            let y =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              exists Field.typ ~compute:(fun () -> Field.Constant.of_int 0)","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"            in","counters":[]},{"line":"            let z =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              exists Field.typ ~compute:(fun () -> Field.Constant.of_int 0)","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"            in","counters":[]},{"line":"            let g = Inner_curve.one in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let sponge = Sponge.create sponge_params in","counters":[]},{"line":"            Sponge.absorb sponge x ;","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            ignore (Sponge.squeeze_field sponge : Field.t) ;","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"            ignore","counters":[]},{"line":"              ( SC'.to_field_checked'","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"                  (module Impl)","counters":[]},{"line":"                  ~num_bits:16","counters":[]},{"line":"                  (Kimchi_backend_common.Scalar_challenge.create x)","counters":[{"col_start":63,"col_end":63,"count":0}]},{"line":"                : Field.t * Field.t * Field.t ) ;","counters":[]},{"line":"            ignore","counters":[]},{"line":"              (Ops.scale_fast g ~num_bits:5 (Shifted_value x) : Inner_curve.t) ;","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"            ignore","counters":[]},{"line":"              ( Scalar_challenge.endo g ~num_bits:4","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"                  (Kimchi_backend_common.Scalar_challenge.create x)","counters":[{"col_start":63,"col_end":63,"count":0}]},{"line":"                : Field.t * Field.t ) ;","counters":[]},{"line":"            for i = 0 to 61000 do","counters":[]},{"line":"              assert_r1cs x y z","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"            done","counters":[]},{"line":"          in","counters":[]},{"line":"          let (wrap_pk, wrap_vk), disk_key =","counters":[]},{"line":"            let open Impls.Wrap in","counters":[]},{"line":"            let (T (typ, conv, _conv_inv)) = input () in","counters":[]},{"line":"            let main x () : unit = wrap_main (conv x) in","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"            let self_id = Type_equal.Id.uid self.id in","counters":[]},{"line":"            let disk_key_prover =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              lazy","counters":[]},{"line":"                (let cs =","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                   constraint_system ~input_typ:typ ~return_typ:Typ.unit main","counters":[]},{"line":"                 in","counters":[]},{"line":"                 let cs_hash = Md5.to_hex (R1CS_constraint_system.digest cs) in","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"                 ( self_id","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                 , snark_keys_header","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                     { type_ = \"wrap-proving-key\"; identifier = \"\" }","counters":[]},{"line":"                     cs_hash","counters":[]},{"line":"                 , cs ) )","counters":[]},{"line":"            in","counters":[]},{"line":"            let disk_key_verifier =","counters":[]},{"line":"              lazy","counters":[]},{"line":"                (let id, _header, cs = Lazy.force disk_key_prover in","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                 let digest = R1CS_constraint_system.digest cs in","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                 ( id","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                 , snark_keys_header","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                     { type_ = \"wrap-verification-key\"; identifier = \"\" }","counters":[]},{"line":"                     (Md5.to_hex digest)","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                 , digest ) )","counters":[]},{"line":"            in","counters":[]},{"line":"            let r =","counters":[]},{"line":"              Common.time \"wrap read or generate \" (fun () ->","counters":[]},{"line":"                  Cache.Wrap.read_or_generate ~prev_challenges:2 []","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    disk_key_prover disk_key_verifier typ Typ.unit main )","counters":[]},{"line":"            in","counters":[]},{"line":"            (r, disk_key_verifier)","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          in","counters":[]},{"line":"          let wrap_vk = Lazy.map wrap_vk ~f:fst in","counters":[]},{"line":"          let module S = Step.Make (A) (A_value) (Max_proofs_verified) in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let prover =","counters":[]},{"line":"            let module Z = H4.Zip (Branch_data) (E04 (Impls.Step.Keypair)) in","counters":[]},{"line":"            let f :","counters":[]},{"line":"                   ( unit * (unit * unit)","counters":[]},{"line":"                   , unit * (unit * unit)","counters":[]},{"line":"                   , Nat.N2.n * (Nat.N2.n * unit)","counters":[]},{"line":"                   , Nat.N1.n * (Nat.N1.n * unit) )","counters":[]},{"line":"                   Branch_data.t","counters":[]},{"line":"                -> Lazy_keys.t","counters":[]},{"line":"                -> unit","counters":[]},{"line":"                -> (Max_proofs_verified.n, Max_proofs_verified.n) Proof.t","counters":[]},{"line":"                   Promise.t =","counters":[]},{"line":"             fun (T b as branch_data) (step_pk, step_vk) () ->","counters":[]},{"line":"              let (( module","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                    Req )","counters":[]},{"line":"                    : (Max_proofs_verified.n, Maxes.ns) Requests.Wrap.t ) =","counters":[]},{"line":"                Requests.Wrap.create ()","counters":[]},{"line":"              in","counters":[]},{"line":"              let (module Requests) = b.requests in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              let _, prev_vars_length = b.proofs_verified in","counters":[]},{"line":"              let step =","counters":[]},{"line":"                let wrap_vk = Lazy.force wrap_vk in","counters":[]},{"line":"                S.f branch_data () ~uses_lookup:No","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"                  ~prevs_length:prev_vars_length ~self ~public_input:(Input typ)","counters":[]},{"line":"                  ~auxiliary_typ:Impls.Step.Typ.unit ~step_domains","counters":[]},{"line":"                  ~self_dlog_plonk_index:wrap_vk.commitments","counters":[]},{"line":"                  (Impls.Step.Keypair.pk (fst (Lazy.force step_pk)))","counters":[{"col_start":39,"col_end":39,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"                  wrap_vk.index","counters":[]},{"line":"              in","counters":[]},{"line":"              let pairing_vk = fst (Lazy.force step_vk) in","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"              let wrap =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                let wrap_vk = Lazy.force wrap_vk in","counters":[]},{"line":"                let%bind.Promise proof, (), (), _ =","counters":[]},{"line":"                  step ~maxes:(module Maxes)","counters":[]},{"line":"                in","counters":[]},{"line":"                let proof =","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  { proof with","counters":[]},{"line":"                    statement =","counters":[]},{"line":"                      { proof.statement with","counters":[]},{"line":"                        messages_for_next_wrap_proof =","counters":[]},{"line":"                          pad_messages_for_next_wrap_proof","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"                            (module Maxes)","counters":[]},{"line":"                            proof.statement.messages_for_next_wrap_proof","counters":[]},{"line":"                      }","counters":[]},{"line":"                  }","counters":[]},{"line":"                in","counters":[]},{"line":"                let%map.Promise proof =","counters":[]},{"line":"                  let module Pairing_acc = Tock.Inner_curve.Affine in","counters":[]},{"line":"                  (* The prover for wrapping a proof *)","counters":[]},{"line":"                  let wrap (type actual_branching)","counters":[]},{"line":"                      ~(max_proofs_verified : Max_proofs_verified.n Nat.t)","counters":[]},{"line":"                      (module Max_local_max_proofs_verifieds : Hlist.Maxes.S","counters":[]},{"line":"                        with type ns = Maxes.ns","counters":[]},{"line":"                         and type length = Max_proofs_verified.n )","counters":[]},{"line":"                      ~dlog_plonk_index wrap_main to_field_elements ~pairing_vk","counters":[]},{"line":"                      ~step_domains ~wrap_domains ~pairing_plonk_indices pk","counters":[]},{"line":"                      ({ statement = prev_statement","counters":[]},{"line":"                       ; prev_evals","counters":[]},{"line":"                       ; proof","counters":[]},{"line":"                       ; index = which_index","counters":[]},{"line":"                       } :","counters":[]},{"line":"                        ( _","counters":[]},{"line":"                        , _","counters":[]},{"line":"                        , (_, actual_branching) Vector.t","counters":[]},{"line":"                        , (_, actual_branching) Vector.t","counters":[]},{"line":"                        , Maxes.ns","counters":[]},{"line":"                          H1.T","counters":[]},{"line":"                            (P.Base.Messages_for_next_proof_over_same_field.Wrap)","counters":[]},{"line":"                          .t","counters":[]},{"line":"                        , ( ( Tock.Field.t","counters":[]},{"line":"                            , Tock.Field.t array )","counters":[]},{"line":"                            Plonk_types.All_evals.t","counters":[]},{"line":"                          , Max_proofs_verified.n )","counters":[]},{"line":"                          Vector.t )","counters":[]},{"line":"                        P.Base.Step.t ) =","counters":[]},{"line":"                    let prev_messages_for_next_wrap_proof =","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      let module M =","counters":[]},{"line":"                        H1.Map","counters":[]},{"line":"                          (P.Base.Messages_for_next_proof_over_same_field.Wrap)","counters":[]},{"line":"                          (P.Base.Messages_for_next_proof_over_same_field.Wrap","counters":[]},{"line":"                           .Prepared)","counters":[]},{"line":"                          (struct","counters":[]},{"line":"                            let f =","counters":[]},{"line":"                              P.Base.Messages_for_next_proof_over_same_field","counters":[]},{"line":"                              .Wrap","counters":[]},{"line":"                              .prepare","counters":[]},{"line":"                          end)","counters":[]},{"line":"                      in","counters":[]},{"line":"                      M.f prev_statement.messages_for_next_wrap_proof","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                    in","counters":[]},{"line":"                    let prev_statement_with_hashes : _ Types.Step.Statement.t =","counters":[]},{"line":"                      { proof_state =","counters":[]},{"line":"                          { prev_statement.proof_state with","counters":[]},{"line":"                            messages_for_next_step_proof =","counters":[]},{"line":"                              (* TODO: Careful here... the length of","counters":[]},{"line":"                                 old_buletproof_challenges inside the messages_for_next_step_proof","counters":[]},{"line":"                                 might not be correct *)","counters":[]},{"line":"                              Common.hash_messages_for_next_step_proof","counters":[{"col_start":69,"col_end":69,"count":0}]},{"line":"                                ~app_state:to_field_elements","counters":[]},{"line":"                                (P.Base.Messages_for_next_proof_over_same_field","counters":[]},{"line":"                                 .Step","counters":[]},{"line":"                                 .prepare ~dlog_plonk_index","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"                                   prev_statement.proof_state","counters":[]},{"line":"                                     .messages_for_next_step_proof )","counters":[]},{"line":"                          }","counters":[]},{"line":"                      ; messages_for_next_wrap_proof =","counters":[]},{"line":"                          (let module M =","counters":[]},{"line":"                             H1.Map","counters":[]},{"line":"                               (P.Base.Messages_for_next_proof_over_same_field","counters":[]},{"line":"                                .Wrap","counters":[]},{"line":"                                .Prepared)","counters":[]},{"line":"                               (E01 (Digest.Constant))","counters":[]},{"line":"                               (struct","counters":[]},{"line":"                                 let f (type n)","counters":[]},{"line":"                                     (m :","counters":[]},{"line":"                                       n","counters":[]},{"line":"                                       P.Base","counters":[]},{"line":"                                       .Messages_for_next_proof_over_same_field","counters":[]},{"line":"                                       .Wrap","counters":[]},{"line":"                                       .Prepared","counters":[]},{"line":"                                       .t ) =","counters":[]},{"line":"                                   let T =","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                                     Nat.eq_exn max_proofs_verified","counters":[]},{"line":"                                       (Vector.length","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"                                          m.old_bulletproof_challenges )","counters":[]},{"line":"                                   in","counters":[]},{"line":"                                   Wrap_hack.hash_messages_for_next_wrap_proof","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                                     max_proofs_verified m","counters":[]},{"line":"                               end)","counters":[]},{"line":"                           in","counters":[]},{"line":"                          let module V = H1.To_vector (Digest.Constant) in","counters":[]},{"line":"                          V.f Max_local_max_proofs_verifieds.length","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                            (M.f prev_messages_for_next_wrap_proof) )","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                      }","counters":[]},{"line":"                    in","counters":[]},{"line":"                    let module O = Tick.Oracles in","counters":[]},{"line":"                    let public_input =","counters":[]},{"line":"                      tick_public_input_of_statement ~uses_lookup:No","counters":[]},{"line":"                        ~max_proofs_verified prev_statement_with_hashes","counters":[]},{"line":"                    in","counters":[]},{"line":"                    let prev_challenges =","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      Vector.map ~f:Ipa.Step.compute_challenges","counters":[]},{"line":"                        prev_statement.proof_state.messages_for_next_step_proof","counters":[]},{"line":"                          .old_bulletproof_challenges","counters":[]},{"line":"                    in","counters":[]},{"line":"                    let actual_proofs_verified =","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      Vector.length prev_challenges","counters":[]},{"line":"                    in","counters":[]},{"line":"                    let lte =","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      Nat.lte_exn actual_proofs_verified","counters":[]},{"line":"                        (Length.to_nat Max_local_max_proofs_verifieds.length)","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                    in","counters":[]},{"line":"                    let o =","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      let sgs =","counters":[]},{"line":"                        let module M =","counters":[]},{"line":"                          H1.Map","counters":[]},{"line":"                            (P.Base.Messages_for_next_proof_over_same_field.Wrap","counters":[]},{"line":"                             .Prepared)","counters":[]},{"line":"                            (E01 (Tick.Curve.Affine))","counters":[]},{"line":"                            (struct","counters":[]},{"line":"                              let f :","counters":[]},{"line":"                                  type n.","counters":[]},{"line":"                                     n","counters":[]},{"line":"                                     P.Base","counters":[]},{"line":"                                     .Messages_for_next_proof_over_same_field","counters":[]},{"line":"                                     .Wrap","counters":[]},{"line":"                                     .Prepared","counters":[]},{"line":"                                     .t","counters":[]},{"line":"                                  -> _ =","counters":[]},{"line":"                               fun t -> t.challenge_polynomial_commitment","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"                            end)","counters":[]},{"line":"                        in","counters":[]},{"line":"                        let module V = H1.To_vector (Tick.Curve.Affine) in","counters":[]},{"line":"                        V.f Max_local_max_proofs_verifieds.length","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                          (M.f prev_messages_for_next_wrap_proof)","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                      in","counters":[]},{"line":"                      O.create pairing_vk","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                        Vector.(","counters":[]},{"line":"                          map2 (Vector.trim sgs lte) prev_challenges","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"                            ~f:(fun commitment cs ->","counters":[]},{"line":"                              { Tick.Proof.Challenge_polynomial.commitment","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                              ; challenges = Vector.to_array cs","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"                              } )","counters":[]},{"line":"                          |> to_list)","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                        public_input proof","counters":[]},{"line":"                    in","counters":[]},{"line":"                    let x_hat = O.(p_eval_1 o, p_eval_2 o) in","counters":[{"col_start":42,"col_end":42,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"                    let step_vk, _ = Lazy.force step_vk in","counters":[]},{"line":"                    let next_statement : _ Types.Wrap.Statement.In_circuit.t =","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      let scalar_chal f =","counters":[]},{"line":"                        Scalar_challenge.map ~f:Challenge.Constant.of_tick_field","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          (f o)","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                      in","counters":[]},{"line":"                      let sponge_digest_before_evaluations =","counters":[]},{"line":"                        O.digest_before_evaluations o","counters":[]},{"line":"                      in","counters":[]},{"line":"                      let plonk0 =","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        { Types.Wrap.Proof_state.Deferred_values.Plonk.Minimal","counters":[]},{"line":"                          .alpha = scalar_chal O.alpha","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"                        ; beta = O.beta o","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"                        ; gamma = O.gamma o","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"                        ; zeta = scalar_chal O.zeta","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"                        ; joint_combiner =","counters":[]},{"line":"                            Option.map (O.joint_combiner_chal o)","counters":[{"col_start":37,"col_end":37,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"                              ~f:","counters":[]},{"line":"                                (Scalar_challenge.map","counters":[]},{"line":"                                   ~f:Challenge.Constant.of_tick_field )","counters":[]},{"line":"                        }","counters":[]},{"line":"                      in","counters":[]},{"line":"                      let r = scalar_chal O.u in","counters":[]},{"line":"                      let xi = scalar_chal O.v in","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                      let to_field =","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        SC.to_field_constant","counters":[]},{"line":"                          (module Tick.Field)","counters":[]},{"line":"                          ~endo:Endo.Wrap_inner_curve.scalar","counters":[]},{"line":"                      in","counters":[]},{"line":"                      let module As_field = struct","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        let r = to_field r","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"                        let xi = to_field xi","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"                        let zeta = to_field plonk0.zeta","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"","counters":[]},{"line":"                        let alpha = to_field plonk0.alpha","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"","counters":[]},{"line":"                        let joint_combiner =","counters":[]},{"line":"                          Option.map ~f:to_field plonk0.joint_combiner","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                      end in","counters":[]},{"line":"                      let domain =","counters":[]},{"line":"                        Domain.Pow_2_roots_of_unity","counters":[]},{"line":"                          step_vk.domain.log_size_of_group","counters":[]},{"line":"                      in","counters":[]},{"line":"                      let w = step_vk.domain.group_gen in","counters":[]},{"line":"                      (* Debug *)","counters":[]},{"line":"                      [%test_eq: Tick.Field.t] w","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"                        (Tick.Field.domain_generator","counters":[]},{"line":"                           ~log2_size:(Domain.log2_size domain) ) ;","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"                      let zetaw = Tick.Field.mul As_field.zeta w in","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                      let tick_plonk_minimal =","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        { plonk0 with","counters":[]},{"line":"                          zeta = As_field.zeta","counters":[]},{"line":"                        ; alpha = As_field.alpha","counters":[]},{"line":"                        ; joint_combiner = As_field.joint_combiner","counters":[]},{"line":"                        }","counters":[]},{"line":"                      in","counters":[]},{"line":"                      let tick_combined_evals =","counters":[]},{"line":"                        Plonk_checks.evals_of_split_evals","counters":[]},{"line":"                          (module Tick.Field)","counters":[]},{"line":"                          proof.openings.evals","counters":[]},{"line":"                          ~rounds:(Nat.to_int Tick.Rounds.n) ~zeta:As_field.zeta","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"                          ~zetaw","counters":[]},{"line":"                      in","counters":[]},{"line":"                      let tick_domain =","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        Plonk_checks.domain","counters":[]},{"line":"                          (module Tick.Field)","counters":[]},{"line":"                          domain ~shifts:Common.tick_shifts","counters":[]},{"line":"                          ~domain_generator:Backend.Tick.Field.domain_generator","counters":[]},{"line":"                      in","counters":[]},{"line":"                      let tick_combined_evals =","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        Plonk_types.Evals.to_in_circuit tick_combined_evals","counters":[]},{"line":"                      in","counters":[]},{"line":"                      let tick_env =","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        Plonk_checks.scalars_env","counters":[]},{"line":"                          (module Tick.Field)","counters":[]},{"line":"                          ~endo:Endo.Step_inner_curve.base","counters":[]},{"line":"                          ~mds:Tick_field_sponge.params.mds","counters":[]},{"line":"                          ~srs_length_log2:Common.Max_degree.step_log2","counters":[]},{"line":"                          ~field_of_hex:(fun s ->","counters":[]},{"line":"                            Kimchi_pasta.Pasta.Bigint256.of_hex_string s","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"                            |> Kimchi_pasta.Pasta.Fp.of_bigint )","counters":[]},{"line":"                          ~domain:tick_domain tick_plonk_minimal","counters":[]},{"line":"                          tick_combined_evals","counters":[]},{"line":"                      in","counters":[]},{"line":"                      let combined_inner_product =","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        let open As_field in","counters":[]},{"line":"                        Wrap.combined_inner_product","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                        (* Note: We do not pad here. *)","counters":[]},{"line":"                          ~actual_proofs_verified:","counters":[]},{"line":"                            (Nat.Add.create actual_proofs_verified)","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"                          { evals = proof.openings.evals; public_input = x_hat }","counters":[]},{"line":"                          ~r ~xi ~zeta ~zetaw","counters":[]},{"line":"                          ~old_bulletproof_challenges:prev_challenges","counters":[]},{"line":"                          ~env:tick_env ~domain:tick_domain","counters":[]},{"line":"                          ~ft_eval1:proof.openings.ft_eval1","counters":[]},{"line":"                          ~plonk:tick_plonk_minimal","counters":[]},{"line":"                      in","counters":[]},{"line":"                      let chal = Challenge.Constant.of_tick_field in","counters":[]},{"line":"                      let new_bulletproof_challenges, b =","counters":[]},{"line":"                        let prechals =","counters":[]},{"line":"                          Array.map (O.opening_prechallenges o) ~f:(fun x ->","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"                              let x =","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                                Scalar_challenge.map","counters":[]},{"line":"                                  ~f:Challenge.Constant.of_tick_field x","counters":[]},{"line":"                              in","counters":[]},{"line":"                              x )","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                        in","counters":[]},{"line":"                        let b = Tick.Field.random () in","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                        let prechals =","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          Array.map prechals ~f:(fun x ->","counters":[]},{"line":"                              { Bulletproof_challenge.prechallenge = x } )","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                        in","counters":[]},{"line":"                        (prechals, b)","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                      in","counters":[]},{"line":"                      let plonk =","counters":[]},{"line":"                        Wrap.Plonk_checks.Type1.derive_plonk","counters":[]},{"line":"                          (module Tick.Field)","counters":[]},{"line":"                          ~shift:Shifts.tick1 ~env:tick_env tick_plonk_minimal","counters":[]},{"line":"                          tick_combined_evals","counters":[]},{"line":"                      in","counters":[]},{"line":"                      let shift_value =","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        Shifted_value.Type1.of_field","counters":[]},{"line":"                          (module Tick.Field)","counters":[]},{"line":"                          ~shift:Shifts.tick1","counters":[]},{"line":"                      in","counters":[]},{"line":"                      let branch_data : Composition_types.Branch_data.t =","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        { proofs_verified =","counters":[]},{"line":"                            ( match actual_proofs_verified with","counters":[]},{"line":"                            | Z ->","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                                Composition_types.Branch_data.Proofs_verified.N0","counters":[]},{"line":"                            | S Z ->","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                                N1","counters":[]},{"line":"                            | S (S Z) ->","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                                N2","counters":[]},{"line":"                            | _ ->","counters":[]},{"line":"                                assert false )","counters":[]},{"line":"                        ; domain_log2 =","counters":[]},{"line":"                            Composition_types.Branch_data.Domain_log2.of_int_exn","counters":[{"col_start":79,"col_end":79,"count":0}]},{"line":"                              step_vk.domain.log_size_of_group","counters":[]},{"line":"                        }","counters":[]},{"line":"                      in","counters":[]},{"line":"                      let messages_for_next_wrap_proof :","counters":[]},{"line":"                          _","counters":[]},{"line":"                          P.Base.Messages_for_next_proof_over_same_field.Wrap.t","counters":[]},{"line":"                          =","counters":[]},{"line":"                        { challenge_polynomial_commitment =","counters":[]},{"line":"                            proof.openings.proof.challenge_polynomial_commitment","counters":[]},{"line":"                        ; old_bulletproof_challenges =","counters":[]},{"line":"                            Vector.map","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                              prev_statement.proof_state.unfinalized_proofs","counters":[]},{"line":"                              ~f:(fun t ->","counters":[]},{"line":"                                t.deferred_values.bulletproof_challenges )","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                        }","counters":[]},{"line":"                      in","counters":[]},{"line":"                      { proof_state =","counters":[]},{"line":"                          { deferred_values =","counters":[]},{"line":"                              { xi","counters":[]},{"line":"                              ; b = shift_value b","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"                              ; bulletproof_challenges =","counters":[]},{"line":"                                  Vector.of_array_and_length_exn","counters":[{"col_start":63,"col_end":63,"count":0}]},{"line":"                                    new_bulletproof_challenges Tick.Rounds.n","counters":[]},{"line":"                              ; combined_inner_product =","counters":[]},{"line":"                                  shift_value combined_inner_product","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"                              ; branch_data","counters":[]},{"line":"                              ; plonk =","counters":[]},{"line":"                                  { plonk with","counters":[]},{"line":"                                    zeta = plonk0.zeta","counters":[]},{"line":"                                  ; alpha = plonk0.alpha","counters":[]},{"line":"                                  ; beta = chal plonk0.beta","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"                                  ; gamma = chal plonk0.gamma","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"                                  ; lookup = Plonk_types.Opt.None","counters":[]},{"line":"                                  }","counters":[]},{"line":"                              }","counters":[]},{"line":"                          ; sponge_digest_before_evaluations =","counters":[]},{"line":"                              Digest.Constant.of_tick_field","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"                                sponge_digest_before_evaluations","counters":[]},{"line":"                          ; messages_for_next_wrap_proof","counters":[]},{"line":"                          }","counters":[]},{"line":"                      ; messages_for_next_step_proof =","counters":[]},{"line":"                          prev_statement.proof_state","counters":[]},{"line":"                            .messages_for_next_step_proof","counters":[]},{"line":"                      }","counters":[]},{"line":"                    in","counters":[]},{"line":"                    let messages_for_next_wrap_proof_prepared =","counters":[]},{"line":"                      P.Base.Messages_for_next_proof_over_same_field.Wrap","counters":[]},{"line":"                      .prepare","counters":[]},{"line":"                        next_statement.proof_state.messages_for_next_wrap_proof","counters":[]},{"line":"                    in","counters":[]},{"line":"                    let%map.Promise next_proof =","counters":[]},{"line":"                      let (T (input, conv, _conv_inv)) = Impls.Wrap.input () in","counters":[]},{"line":"                      Common.time \"wrap proof\" (fun () ->","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"                          Impls.Wrap.generate_witness_conv","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            ~f:(fun { Impls.Wrap.Proof_inputs.auxiliary_inputs","counters":[]},{"line":"                                    ; public_inputs","counters":[]},{"line":"                                    } () ->","counters":[]},{"line":"                              Backend.Tock.Proof.create_async","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                                ~primary:public_inputs","counters":[]},{"line":"                                ~auxiliary:auxiliary_inputs pk","counters":[]},{"line":"                                ~message:","counters":[]},{"line":"                                  ( Vector.map2","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"                                      (Vector.extend_exn","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"                                         prev_statement.proof_state","counters":[]},{"line":"                                           .messages_for_next_step_proof","counters":[]},{"line":"                                           .challenge_polynomial_commitments","counters":[]},{"line":"                                         max_proofs_verified","counters":[]},{"line":"                                         (Lazy.force Dummy.Ipa.Wrap.sg) )","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                                      messages_for_next_wrap_proof_prepared","counters":[]},{"line":"                                        .old_bulletproof_challenges","counters":[]},{"line":"                                      ~f:(fun sg chals ->","counters":[]},{"line":"                                        { Tock.Proof.Challenge_polynomial","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"                                          .commitment = sg","counters":[]},{"line":"                                        ; challenges = Vector.to_array chals","counters":[{"col_start":69,"col_end":69,"count":0}]},{"line":"                                        } )","counters":[]},{"line":"                                  |> Wrap_hack.pad_accumulator ) )","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"                            ~input_typ:input","counters":[]},{"line":"                            ~return_typ:(Snarky_backendless.Typ.unit ())","counters":[{"col_start":67,"col_end":67,"count":0}]},{"line":"                            (fun x () : unit -> wrap_main (conv x))","counters":[{"col_start":48,"col_end":48,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"                            { messages_for_next_step_proof =","counters":[]},{"line":"                                prev_statement_with_hashes.proof_state","counters":[]},{"line":"                                  .messages_for_next_step_proof","counters":[]},{"line":"                            ; proof_state =","counters":[]},{"line":"                                { next_statement.proof_state with","counters":[]},{"line":"                                  messages_for_next_wrap_proof =","counters":[]},{"line":"                                    Wrap_hack.hash_messages_for_next_wrap_proof","counters":[{"col_start":78,"col_end":78,"count":0}]},{"line":"                                      max_proofs_verified","counters":[]},{"line":"                                      messages_for_next_wrap_proof_prepared","counters":[]},{"line":"                                ; deferred_values =","counters":[]},{"line":"                                    { next_statement.proof_state.deferred_values with","counters":[]},{"line":"                                      plonk =","counters":[]},{"line":"                                        { next_statement.proof_state","counters":[]},{"line":"                                            .deferred_values","counters":[]},{"line":"                                            .plonk","counters":[]},{"line":"                                          with","counters":[]},{"line":"                                          lookup = None","counters":[]},{"line":"                                        }","counters":[]},{"line":"                                    }","counters":[]},{"line":"                                }","counters":[]},{"line":"                            } )","counters":[]},{"line":"                    in","counters":[]},{"line":"                    ( { proof = next_proof","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                      ; statement =","counters":[]},{"line":"                          Types.Wrap.Statement.to_minimal","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"                            ~to_option:Plonk_types.Opt.to_option next_statement","counters":[]},{"line":"                      ; prev_evals =","counters":[]},{"line":"                          { Plonk_types.All_evals.evals =","counters":[]},{"line":"                              { public_input = x_hat","counters":[]},{"line":"                              ; evals = proof.openings.evals","counters":[]},{"line":"                              }","counters":[]},{"line":"                          ; ft_eval1 = proof.openings.ft_eval1","counters":[]},{"line":"                          }","counters":[]},{"line":"                      }","counters":[]},{"line":"                      : _ P.Base.Wrap.t )","counters":[]},{"line":"                  in","counters":[]},{"line":"                  wrap ~max_proofs_verified:Max_proofs_verified.n","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                    full_signature.maxes ~dlog_plonk_index:wrap_vk.commitments","counters":[]},{"line":"                    wrap_main A_value.to_field_elements ~pairing_vk","counters":[]},{"line":"                    ~step_domains:b.domains","counters":[]},{"line":"                    ~pairing_plonk_indices:(Lazy.force step_vks) ~wrap_domains","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"                    (Impls.Wrap.Keypair.pk (fst (Lazy.force wrap_pk)))","counters":[{"col_start":41,"col_end":41,"count":0},{"col_start":46,"col_end":46,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"                    proof","counters":[]},{"line":"                in","counters":[]},{"line":"                Proof.T","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  { proof with","counters":[]},{"line":"                    statement =","counters":[]},{"line":"                      { proof.statement with","counters":[]},{"line":"                        messages_for_next_step_proof =","counters":[]},{"line":"                          { proof.statement.messages_for_next_step_proof with","counters":[]},{"line":"                            app_state = ()","counters":[]},{"line":"                          }","counters":[]},{"line":"                      }","counters":[]},{"line":"                  }","counters":[]},{"line":"              in","counters":[]},{"line":"              wrap","counters":[]},{"line":"            in","counters":[]},{"line":"            f step_data step_keypair","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          in","counters":[]},{"line":"          let data : _ Types_map.Compiled.t =","counters":[]},{"line":"            { branches = Branches.n","counters":[]},{"line":"            ; step_uses_lookup = No","counters":[]},{"line":"            ; proofs_verifieds","counters":[]},{"line":"            ; max_proofs_verified = (module Max_proofs_verified)","counters":[]},{"line":"            ; public_input = typ","counters":[]},{"line":"            ; wrap_key = Lazy.map wrap_vk ~f:Verification_key.commitments","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"            ; wrap_vk = Lazy.map wrap_vk ~f:Verification_key.index","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"            ; wrap_domains","counters":[]},{"line":"            ; step_domains","counters":[]},{"line":"            }","counters":[]},{"line":"          in","counters":[]},{"line":"          Types_map.add_exn self data ;","counters":[]},{"line":"          (prover, wrap_vk, disk_key)","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      let step, wrap_vk, wrap_disk_key = M.compile","counters":[]},{"line":"","counters":[]},{"line":"      module Proof = struct","counters":[]},{"line":"        type statement = A_value.t","counters":[]},{"line":"","counters":[]},{"line":"        module Max_local_max_proofs_verified = Max_proofs_verified","counters":[]},{"line":"        module Max_proofs_verified_vec = Nvector (Max_proofs_verified)","counters":[]},{"line":"        include Proof.Make (Max_proofs_verified) (Max_local_max_proofs_verified)","counters":[]},{"line":"","counters":[]},{"line":"        let id = wrap_disk_key","counters":[]},{"line":"","counters":[]},{"line":"        let verification_key = wrap_vk","counters":[]},{"line":"","counters":[]},{"line":"        let verify ts =","counters":[]},{"line":"          verify_promise","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (module Max_proofs_verified)","counters":[]},{"line":"            (module A_value)","counters":[]},{"line":"            (Lazy.force verification_key)","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"            ts","counters":[]},{"line":"","counters":[]},{"line":"        let statement (T p : t) =","counters":[]},{"line":"          p.statement.messages_for_next_step_proof.app_state","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      let proof_with_stmt =","counters":[]},{"line":"        let p = Promise.block_on_async_exn (fun () -> step ()) in","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"        ((), p)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      let%test \"should not be able to verify invalid proof\" =","counters":[]},{"line":"        not","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        @@ Promise.block_on_async_exn (fun () ->","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"               Proof.verify [ proof_with_stmt ] )","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"","counters":[]},{"line":"      module Recurse_on_bad_proof = struct","counters":[]},{"line":"        open Impls.Step","counters":[]},{"line":"","counters":[]},{"line":"        let dummy_proof =","counters":[]},{"line":"          Proof0.dummy Nat.N2.n Nat.N2.n Nat.N2.n ~domain_log2:15","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"","counters":[]},{"line":"        type _ Snarky_backendless.Request.t +=","counters":[]},{"line":"          | Proof : (Nat.N2.n, Nat.N2.n) Proof0.t Snarky_backendless.Request.t","counters":[]},{"line":"","counters":[]},{"line":"        let handler (proof : _ Proof0.t)","counters":[]},{"line":"            (Snarky_backendless.Request.With { request; respond }) =","counters":[]},{"line":"          match request with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | Proof ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              respond (Provide proof)","counters":[]},{"line":"          | _ ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              respond Unhandled","counters":[]},{"line":"","counters":[]},{"line":"        let tag, _, p, Provers.[ step ] =","counters":[]},{"line":"          Common.time \"compile\" (fun () ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"              compile_promise () ~public_input:(Input Typ.unit)","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ~auxiliary_typ:Typ.unit","counters":[]},{"line":"                ~branches:(module Nat.N1)","counters":[]},{"line":"                ~max_proofs_verified:(module Nat.N2)","counters":[]},{"line":"                ~name:\"recurse-on-bad\" ~constraint_constants","counters":[]},{"line":"                ~choices:(fun ~self ->","counters":[]},{"line":"                  [ { identifier = \"main\"","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    ; uses_lookup = false","counters":[]},{"line":"                    ; prevs = [ tag; tag ]","counters":[]},{"line":"                    ; main =","counters":[]},{"line":"                        (fun { public_input = () } ->","counters":[]},{"line":"                          let proof =","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            exists (Typ.Internal.ref ()) ~request:(fun () ->","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                                Proof )","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                          in","counters":[]},{"line":"                          { previous_proof_statements =","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                              [ { public_input = ()","counters":[]},{"line":"                                ; proof","counters":[]},{"line":"                                ; proof_must_verify = Boolean.true_","counters":[]},{"line":"                                }","counters":[]},{"line":"                              ; { public_input = ()","counters":[]},{"line":"                                ; proof","counters":[]},{"line":"                                ; proof_must_verify = Boolean.true_","counters":[]},{"line":"                                }","counters":[]},{"line":"                              ]","counters":[]},{"line":"                          ; public_output = ()","counters":[]},{"line":"                          ; auxiliary_output = ()","counters":[]},{"line":"                          } )","counters":[]},{"line":"                    }","counters":[]},{"line":"                  ] ) )","counters":[]},{"line":"","counters":[]},{"line":"        module Proof = (val p)","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      let%test \"should not be able to create a recursive proof from an invalid \\","counters":[]},{"line":"                proof\" =","counters":[]},{"line":"        try","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let (), (), proof =","counters":[]},{"line":"            Promise.block_on_async_exn (fun () ->","counters":[]},{"line":"                Recurse_on_bad_proof.step","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  ~handler:(Recurse_on_bad_proof.handler (snd proof_with_stmt))","counters":[{"col_start":55,"col_end":55,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"                  () )","counters":[]},{"line":"          in","counters":[]},{"line":"          not","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":12,"col_end":12,"count":0}]},{"line":"          @@ Promise.block_on_async_exn (fun () ->","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"                 Recurse_on_bad_proof.Proof.verify_promise [ ((), proof) ] )","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"        with _ -> true","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"    end )","counters":[]},{"line":"","counters":[]},{"line":"  let%test_module \"domain too small\" =","counters":[]},{"line":"    ( module struct","counters":[]},{"line":"      open Impls.Step","counters":[]},{"line":"","counters":[]},{"line":"      module Statement = struct","counters":[]},{"line":"        type t = Field.t","counters":[]},{"line":"","counters":[]},{"line":"        let to_field_elements x = [| x |]","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"","counters":[]},{"line":"        module Constant = struct","counters":[]},{"line":"          type t = Field.Constant.t [@@deriving bin_io]","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"","counters":[]},{"line":"          let to_field_elements x = [| x |]","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"        end","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      (* Currently, a circuit must have at least 1 of every type of constraint. *)","counters":[]},{"line":"      let dummy_constraints () =","counters":[]},{"line":"        Impl.(","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let x =","counters":[]},{"line":"            exists Field.typ ~compute:(fun () -> Field.Constant.of_int 3)","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"          in","counters":[]},{"line":"          let g =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            exists Step_main_inputs.Inner_curve.typ ~compute:(fun _ ->","counters":[]},{"line":"                Tick.Inner_curve.(to_affine_exn one) )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"          in","counters":[]},{"line":"          ignore","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ( SC.to_field_checked'","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"                (module Impl)","counters":[]},{"line":"                ~num_bits:16","counters":[]},{"line":"                (Kimchi_backend_common.Scalar_challenge.create x)","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"              : Field.t * Field.t * Field.t ) ;","counters":[]},{"line":"          ignore","counters":[]},{"line":"            ( Step_main_inputs.Ops.scale_fast g ~num_bits:5 (Shifted_value x)","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"              : Step_main_inputs.Inner_curve.t ) ;","counters":[]},{"line":"          ignore","counters":[]},{"line":"            ( Step_main_inputs.Ops.scale_fast g ~num_bits:5 (Shifted_value x)","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"              : Step_main_inputs.Inner_curve.t ) ;","counters":[]},{"line":"          ignore","counters":[]},{"line":"            ( Step_verifier.Scalar_challenge.endo g ~num_bits:4","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"                (Kimchi_backend_common.Scalar_challenge.create x)","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"              : Field.t * Field.t ))","counters":[]},{"line":"","counters":[]},{"line":"      module No_recursion = struct","counters":[]},{"line":"        module Statement = Statement","counters":[]},{"line":"","counters":[]},{"line":"        let tag, _, p, Provers.[ step ] =","counters":[]},{"line":"          Common.time \"compile\" (fun () ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"              compile_promise () ~public_input:(Input Field.typ)","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ~auxiliary_typ:Typ.unit","counters":[]},{"line":"                ~branches:(module Nat.N1)","counters":[]},{"line":"                ~max_proofs_verified:(module Nat.N0)","counters":[]},{"line":"                ~name:\"blockchain-snark\"","counters":[]},{"line":"                ~constraint_constants:","counters":[]},{"line":"                  (* Dummy values *)","counters":[]},{"line":"                  { sub_windows_per_window = 0","counters":[]},{"line":"                  ; ledger_depth = 0","counters":[]},{"line":"                  ; work_delay = 0","counters":[]},{"line":"                  ; block_window_duration_ms = 0","counters":[]},{"line":"                  ; transaction_capacity = Log_2 0","counters":[]},{"line":"                  ; pending_coinbase_depth = 0","counters":[]},{"line":"                  ; coinbase_amount = Unsigned.UInt64.of_int 0","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"                  ; supercharged_coinbase_factor = 0","counters":[]},{"line":"                  ; account_creation_fee = Unsigned.UInt64.of_int 0","counters":[{"col_start":64,"col_end":64,"count":0}]},{"line":"                  ; fork = None","counters":[]},{"line":"                  }","counters":[]},{"line":"                ~choices:(fun ~self ->","counters":[]},{"line":"                  [ { identifier = \"main\"","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    ; prevs = []","counters":[]},{"line":"                    ; uses_lookup = false","counters":[]},{"line":"                    ; main =","counters":[]},{"line":"                        (fun { public_input = self } ->","counters":[]},{"line":"                          dummy_constraints () ;","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                          Field.Assert.equal self Field.zero ;","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                          { previous_proof_statements = []","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                          ; public_output = ()","counters":[]},{"line":"                          ; auxiliary_output = ()","counters":[]},{"line":"                          } )","counters":[]},{"line":"                    }","counters":[]},{"line":"                  ] ) )","counters":[]},{"line":"","counters":[]},{"line":"        module Proof = (val p)","counters":[]},{"line":"","counters":[]},{"line":"        let example =","counters":[]},{"line":"          let (), (), b0 =","counters":[]},{"line":"            Common.time \"b0\" (fun () ->","counters":[]},{"line":"                Promise.block_on_async_exn (fun () -> step Field.Constant.zero) )","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"          in","counters":[]},{"line":"          assert (","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"            Promise.block_on_async_exn (fun () ->","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                Proof.verify_promise [ (Field.Constant.zero, b0) ] ) ) ;","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"          (Field.Constant.zero, b0)","counters":[]},{"line":"","counters":[]},{"line":"        let example_input, example_proof = example","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      module Fake_1_recursion = struct","counters":[]},{"line":"        module Statement = Statement","counters":[]},{"line":"","counters":[]},{"line":"        let tag, _, p, Provers.[ step ] =","counters":[]},{"line":"          Common.time \"compile\" (fun () ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"              compile_promise () ~public_input:(Input Field.typ)","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ~auxiliary_typ:Typ.unit","counters":[]},{"line":"                ~branches:(module Nat.N1)","counters":[]},{"line":"                ~max_proofs_verified:(module Nat.N1)","counters":[]},{"line":"                ~name:\"blockchain-snark\"","counters":[]},{"line":"                ~constraint_constants:","counters":[]},{"line":"                  (* Dummy values *)","counters":[]},{"line":"                  { sub_windows_per_window = 0","counters":[]},{"line":"                  ; ledger_depth = 0","counters":[]},{"line":"                  ; work_delay = 0","counters":[]},{"line":"                  ; block_window_duration_ms = 0","counters":[]},{"line":"                  ; transaction_capacity = Log_2 0","counters":[]},{"line":"                  ; pending_coinbase_depth = 0","counters":[]},{"line":"                  ; coinbase_amount = Unsigned.UInt64.of_int 0","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"                  ; supercharged_coinbase_factor = 0","counters":[]},{"line":"                  ; account_creation_fee = Unsigned.UInt64.of_int 0","counters":[{"col_start":64,"col_end":64,"count":0}]},{"line":"                  ; fork = None","counters":[]},{"line":"                  }","counters":[]},{"line":"                ~choices:(fun ~self ->","counters":[]},{"line":"                  [ { identifier = \"main\"","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    ; prevs = []","counters":[]},{"line":"                    ; uses_lookup = false","counters":[]},{"line":"                    ; main =","counters":[]},{"line":"                        (fun { public_input = self } ->","counters":[]},{"line":"                          dummy_constraints () ;","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                          Field.Assert.equal self Field.zero ;","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                          { previous_proof_statements = []","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                          ; public_output = ()","counters":[]},{"line":"                          ; auxiliary_output = ()","counters":[]},{"line":"                          } )","counters":[]},{"line":"                    }","counters":[]},{"line":"                  ] ) )","counters":[]},{"line":"","counters":[]},{"line":"        module Proof = (val p)","counters":[]},{"line":"","counters":[]},{"line":"        let example =","counters":[]},{"line":"          let (), (), b0 =","counters":[]},{"line":"            Common.time \"b0\" (fun () ->","counters":[]},{"line":"                Promise.block_on_async_exn (fun () -> step Field.Constant.zero) )","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"          in","counters":[]},{"line":"          assert (","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"            Promise.block_on_async_exn (fun () ->","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                Proof.verify_promise [ (Field.Constant.zero, b0) ] ) ) ;","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"          (Field.Constant.zero, b0)","counters":[]},{"line":"","counters":[]},{"line":"        let example_input, example_proof = example","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      module Fake_2_recursion = struct","counters":[]},{"line":"        module Statement = Statement","counters":[]},{"line":"","counters":[]},{"line":"        let tag, _, p, Provers.[ step ] =","counters":[]},{"line":"          Common.time \"compile\" (fun () ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"              compile_promise () ~public_input:(Input Field.typ)","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ~auxiliary_typ:Typ.unit","counters":[]},{"line":"                ~branches:(module Nat.N1)","counters":[]},{"line":"                ~max_proofs_verified:(module Nat.N2)","counters":[]},{"line":"                ~name:\"blockchain-snark\"","counters":[]},{"line":"                ~constraint_constants:","counters":[]},{"line":"                  (* Dummy values *)","counters":[]},{"line":"                  { sub_windows_per_window = 0","counters":[]},{"line":"                  ; ledger_depth = 0","counters":[]},{"line":"                  ; work_delay = 0","counters":[]},{"line":"                  ; block_window_duration_ms = 0","counters":[]},{"line":"                  ; transaction_capacity = Log_2 0","counters":[]},{"line":"                  ; pending_coinbase_depth = 0","counters":[]},{"line":"                  ; coinbase_amount = Unsigned.UInt64.of_int 0","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"                  ; supercharged_coinbase_factor = 0","counters":[]},{"line":"                  ; account_creation_fee = Unsigned.UInt64.of_int 0","counters":[{"col_start":64,"col_end":64,"count":0}]},{"line":"                  ; fork = None","counters":[]},{"line":"                  }","counters":[]},{"line":"                ~choices:(fun ~self ->","counters":[]},{"line":"                  [ { identifier = \"main\"","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    ; prevs = []","counters":[]},{"line":"                    ; uses_lookup = false","counters":[]},{"line":"                    ; main =","counters":[]},{"line":"                        (fun { public_input = self } ->","counters":[]},{"line":"                          dummy_constraints () ;","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                          Field.Assert.equal self Field.zero ;","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                          { previous_proof_statements = []","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                          ; public_output = ()","counters":[]},{"line":"                          ; auxiliary_output = ()","counters":[]},{"line":"                          } )","counters":[]},{"line":"                    }","counters":[]},{"line":"                  ] ) )","counters":[]},{"line":"","counters":[]},{"line":"        module Proof = (val p)","counters":[]},{"line":"","counters":[]},{"line":"        let example =","counters":[]},{"line":"          let (), (), b0 =","counters":[]},{"line":"            Common.time \"b0\" (fun () ->","counters":[]},{"line":"                Promise.block_on_async_exn (fun () -> step Field.Constant.zero) )","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"          in","counters":[]},{"line":"          assert (","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"            Promise.block_on_async_exn (fun () ->","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                Proof.verify_promise [ (Field.Constant.zero, b0) ] ) ) ;","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"          (Field.Constant.zero, b0)","counters":[]},{"line":"","counters":[]},{"line":"        let example_input, example_proof = example","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      module Simple_chain = struct","counters":[]},{"line":"        module Statement = Statement","counters":[]},{"line":"","counters":[]},{"line":"        type _ Snarky_backendless.Request.t +=","counters":[]},{"line":"          | Prev_input : Field.Constant.t Snarky_backendless.Request.t","counters":[]},{"line":"          | Proof : Side_loaded.Proof.t Snarky_backendless.Request.t","counters":[]},{"line":"          | Verifier_index :","counters":[]},{"line":"              Side_loaded.Verification_key.t Snarky_backendless.Request.t","counters":[]},{"line":"","counters":[]},{"line":"        let handler (prev_input : Field.Constant.t) (proof : _ Proof.t)","counters":[]},{"line":"            (verifier_index : Side_loaded.Verification_key.t)","counters":[]},{"line":"            (Snarky_backendless.Request.With { request; respond }) =","counters":[]},{"line":"          match request with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | Prev_input ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              respond (Provide prev_input)","counters":[]},{"line":"          | Proof ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              respond (Provide proof)","counters":[]},{"line":"          | Verifier_index ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              respond (Provide verifier_index)","counters":[]},{"line":"          | _ ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              respond Unhandled","counters":[]},{"line":"","counters":[]},{"line":"        let side_loaded_tag =","counters":[]},{"line":"          Side_loaded.create ~name:\"foo\"","counters":[]},{"line":"            ~max_proofs_verified:(Nat.Add.create Nat.N2.n) ~uses_lookup:No","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"            ~typ:Field.typ","counters":[]},{"line":"","counters":[]},{"line":"        let tag, _, p, Provers.[ step ] =","counters":[]},{"line":"          Common.time \"compile\" (fun () ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"              compile_promise () ~public_input:(Input Field.typ)","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ~auxiliary_typ:Typ.unit","counters":[]},{"line":"                ~branches:(module Nat.N1)","counters":[]},{"line":"                ~max_proofs_verified:(module Nat.N1)","counters":[]},{"line":"                ~name:\"blockchain-snark\"","counters":[]},{"line":"                ~constraint_constants:","counters":[]},{"line":"                  (* Dummy values *)","counters":[]},{"line":"                  { sub_windows_per_window = 0","counters":[]},{"line":"                  ; ledger_depth = 0","counters":[]},{"line":"                  ; work_delay = 0","counters":[]},{"line":"                  ; block_window_duration_ms = 0","counters":[]},{"line":"                  ; transaction_capacity = Log_2 0","counters":[]},{"line":"                  ; pending_coinbase_depth = 0","counters":[]},{"line":"                  ; coinbase_amount = Unsigned.UInt64.of_int 0","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"                  ; supercharged_coinbase_factor = 0","counters":[]},{"line":"                  ; account_creation_fee = Unsigned.UInt64.of_int 0","counters":[{"col_start":64,"col_end":64,"count":0}]},{"line":"                  ; fork = None","counters":[]},{"line":"                  }","counters":[]},{"line":"                ~choices:(fun ~self ->","counters":[]},{"line":"                  [ { identifier = \"main\"","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    ; prevs = [ side_loaded_tag ]","counters":[]},{"line":"                    ; uses_lookup = false","counters":[]},{"line":"                    ; main =","counters":[]},{"line":"                        (fun { public_input = self } ->","counters":[]},{"line":"                          let prev =","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            exists Field.typ ~request:(fun () -> Prev_input)","counters":[{"col_start":65,"col_end":65,"count":0}]},{"line":"                          in","counters":[]},{"line":"                          let proof =","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            exists (Typ.Internal.ref ()) ~request:(fun () ->","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                                Proof )","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                          in","counters":[]},{"line":"                          let vk =","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            exists (Typ.Internal.ref ()) ~request:(fun () ->","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                                Verifier_index )","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                          in","counters":[]},{"line":"                          as_prover (fun () ->","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                              let vk = As_prover.Ref.get vk in","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                              Side_loaded.in_prover side_loaded_tag vk ) ;","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                          let vk =","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            exists Side_loaded_verification_key.typ","counters":[]},{"line":"                              ~compute:(fun () -> As_prover.Ref.get vk)","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                          in","counters":[]},{"line":"                          Side_loaded.in_circuit side_loaded_tag vk ;","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                          let is_base_case = Field.equal Field.zero self in","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                          let self_correct = Field.(equal (one + prev) self) in","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"                          Boolean.Assert.any [ self_correct; is_base_case ] ;","counters":[]},{"line":"                          { previous_proof_statements =","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                              [ { public_input = prev","counters":[]},{"line":"                                ; proof","counters":[]},{"line":"                                ; proof_must_verify = Boolean.true_","counters":[]},{"line":"                                }","counters":[]},{"line":"                              ]","counters":[]},{"line":"                          ; public_output = ()","counters":[]},{"line":"                          ; auxiliary_output = ()","counters":[]},{"line":"                          } )","counters":[]},{"line":"                    }","counters":[]},{"line":"                  ] ) )","counters":[]},{"line":"","counters":[]},{"line":"        module Proof = (val p)","counters":[]},{"line":"","counters":[]},{"line":"        let example1 =","counters":[]},{"line":"          let (), (), b1 =","counters":[]},{"line":"            Common.time \"b1\" (fun () ->","counters":[]},{"line":"                Promise.block_on_async_exn (fun () ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                    step","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      ~handler:","counters":[]},{"line":"                        (handler No_recursion.example_input","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                           (Side_loaded.Proof.of_proof","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"                              No_recursion.example_proof )","counters":[]},{"line":"                           (Side_loaded.Verification_key.of_compiled","counters":[{"col_start":67,"col_end":67,"count":0}]},{"line":"                              No_recursion.tag ) )","counters":[]},{"line":"                      Field.Constant.one ) )","counters":[]},{"line":"          in","counters":[]},{"line":"          assert (","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"            Promise.block_on_async_exn (fun () ->","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                Proof.verify_promise [ (Field.Constant.one, b1) ] ) ) ;","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"          (Field.Constant.one, b1)","counters":[]},{"line":"","counters":[]},{"line":"        let example2 =","counters":[]},{"line":"          let (), (), b2 =","counters":[]},{"line":"            Common.time \"b2\" (fun () ->","counters":[]},{"line":"                Promise.block_on_async_exn (fun () ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                    step","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      ~handler:","counters":[]},{"line":"                        (handler Fake_1_recursion.example_input","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                           (Side_loaded.Proof.of_proof","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"                              Fake_1_recursion.example_proof )","counters":[]},{"line":"                           (Side_loaded.Verification_key.of_compiled","counters":[{"col_start":67,"col_end":67,"count":0}]},{"line":"                              Fake_1_recursion.tag ) )","counters":[]},{"line":"                      Field.Constant.one ) )","counters":[]},{"line":"          in","counters":[]},{"line":"          assert (","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"            Promise.block_on_async_exn (fun () ->","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                Proof.verify_promise [ (Field.Constant.one, b2) ] ) ) ;","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"          (Field.Constant.one, b2)","counters":[]},{"line":"","counters":[]},{"line":"        let example3 =","counters":[]},{"line":"          let (), (), b3 =","counters":[]},{"line":"            Common.time \"b3\" (fun () ->","counters":[]},{"line":"                Promise.block_on_async_exn (fun () ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                    step","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      ~handler:","counters":[]},{"line":"                        (handler Fake_2_recursion.example_input","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                           (Side_loaded.Proof.of_proof","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"                              Fake_2_recursion.example_proof )","counters":[]},{"line":"                           (Side_loaded.Verification_key.of_compiled","counters":[{"col_start":67,"col_end":67,"count":0}]},{"line":"                              Fake_2_recursion.tag ) )","counters":[]},{"line":"                      Field.Constant.one ) )","counters":[]},{"line":"          in","counters":[]},{"line":"          assert (","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"            Promise.block_on_async_exn (fun () ->","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                Proof.verify_promise [ (Field.Constant.one, b3) ] ) ) ;","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"          (Field.Constant.one, b3)","counters":[]},{"line":"      end","counters":[]},{"line":"    end )","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"include Wire_types.Make (Make_sig) (Make_str)","counters":[{"col_start":44,"col_end":44,"count":2}]}]}