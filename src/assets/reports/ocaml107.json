{"filename":"src/lib/verifier/prod.ml","lines":[{"line":"(* prod.ml *)","counters":[]},{"line":"","counters":[]},{"line":"open Core_kernel","counters":[]},{"line":"open Async","counters":[]},{"line":"open Mina_base","counters":[]},{"line":"open Mina_state","counters":[]},{"line":"open Blockchain_snark","counters":[]},{"line":"","counters":[]},{"line":"type invalid = Common.invalid [@@deriving bin_io_unversioned, to_yojson]","counters":[{"col_start":0,"col_end":0,"count":1},{"col_start":11,"col_end":11,"count":1},{"col_start":15,"col_end":15,"count":0},{"col_start":71,"col_end":71,"count":4}]},{"line":"","counters":[]},{"line":"let invalid_to_string = Common.invalid_to_string","counters":[]},{"line":"","counters":[]},{"line":"type ledger_proof = Ledger_proof.Prod.t","counters":[]},{"line":"","counters":[]},{"line":"module Worker_state = struct","counters":[]},{"line":"  module type S = sig","counters":[]},{"line":"    val verify_blockchain_snarks :","counters":[]},{"line":"      (Protocol_state.Value.t * Proof.t) list -> bool Deferred.t","counters":[]},{"line":"","counters":[]},{"line":"    val verify_commands :","counters":[]},{"line":"         Mina_base.User_command.Verifiable.t list","counters":[]},{"line":"      -> [ `Valid of Mina_base.User_command.Valid.t","counters":[]},{"line":"         | `Valid_assuming of","counters":[]},{"line":"           ( Pickles.Side_loaded.Verification_key.t","counters":[]},{"line":"           * Mina_base.Zkapp_statement.t","counters":[]},{"line":"           * Pickles.Side_loaded.Proof.t )","counters":[]},{"line":"           list","counters":[]},{"line":"         | invalid ]","counters":[]},{"line":"         list","counters":[]},{"line":"         Deferred.t","counters":[]},{"line":"","counters":[]},{"line":"    val verify_transaction_snarks :","counters":[]},{"line":"      (Transaction_snark.t * Sok_message.t) list -> bool Deferred.t","counters":[]},{"line":"","counters":[]},{"line":"    val get_blockchain_verification_key : unit -> Pickles.Verification_key.t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  (* bin_io required by rpc_parallel *)","counters":[]},{"line":"  type init_arg =","counters":[{"col_start":2,"col_end":2,"count":1},{"col_start":14,"col_end":14,"count":2}]},{"line":"    { conf_dir : string option","counters":[]},{"line":"    ; logger : Logger.Stable.Latest.t","counters":[]},{"line":"    ; proof_level : Genesis_constants.Proof_level.t","counters":[]},{"line":"    ; constraint_constants : Genesis_constants.Constraint_constants.t","counters":[]},{"line":"    }","counters":[]},{"line":"  [@@deriving bin_io_unversioned]","counters":[{"col_start":32,"col_end":32,"count":4}]},{"line":"","counters":[]},{"line":"  type t = (module S)","counters":[]},{"line":"","counters":[]},{"line":"  let create { logger; proof_level; constraint_constants; _ } : t Deferred.t =","counters":[]},{"line":"    Memory_stats.log_memory_stats logger ~process:\"verifier\" ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    match proof_level with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Full ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Pickles.Side_loaded.srs_precomputation () ;","counters":[]},{"line":"        Deferred.return","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (let module M = struct","counters":[]},{"line":"             module T = Transaction_snark.Make (struct","counters":[]},{"line":"               let constraint_constants = constraint_constants","counters":[]},{"line":"","counters":[]},{"line":"               let proof_level = proof_level","counters":[]},{"line":"             end)","counters":[]},{"line":"","counters":[]},{"line":"             module B = Blockchain_snark_state.Make (struct","counters":[]},{"line":"               let tag = T.tag","counters":[]},{"line":"","counters":[]},{"line":"               let constraint_constants = constraint_constants","counters":[]},{"line":"","counters":[]},{"line":"               let proof_level = proof_level","counters":[]},{"line":"             end)","counters":[]},{"line":"","counters":[]},{"line":"             let verify_commands (cs : User_command.Verifiable.t list) :","counters":[]},{"line":"                 _ list Deferred.t =","counters":[]},{"line":"               let cs = List.map cs ~f:Common.check in","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"               let to_verify =","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                 List.concat_map cs ~f:(function","counters":[]},{"line":"                   | `Valid _ ->","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                       []","counters":[]},{"line":"                   | `Valid_assuming (_, xs) ->","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                       xs","counters":[]},{"line":"                   | `Invalid_keys _","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                   | `Invalid_signature _","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                   | `Invalid_proof","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                   | `Missing_verification_key _ ->","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                       [] )","counters":[]},{"line":"               in","counters":[]},{"line":"               let%map all_verified =","counters":[]},{"line":"                 Pickles.Side_loaded.verify ~typ:Zkapp_statement.typ to_verify","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"               in","counters":[]},{"line":"               List.map cs ~f:(function","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                 | `Valid c ->","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"                     `Valid c","counters":[]},{"line":"                 | `Valid_assuming (c, xs) ->","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"                     if all_verified then `Valid c else `Valid_assuming xs","counters":[{"col_start":42,"col_end":42,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"                 | `Invalid_keys keys ->","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"                     `Invalid_keys keys","counters":[]},{"line":"                 | `Invalid_signature keys ->","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"                     `Invalid_signature keys","counters":[]},{"line":"                 | `Invalid_proof ->","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"                     `Invalid_proof","counters":[]},{"line":"                 | `Missing_verification_key keys ->","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"                     `Missing_verification_key keys )","counters":[]},{"line":"","counters":[]},{"line":"             let verify_blockchain_snarks = B.Proof.verify","counters":[]},{"line":"","counters":[]},{"line":"             let verify_transaction_snarks ts =","counters":[]},{"line":"               match Or_error.try_with (fun () -> T.verify ts) with","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"               | Ok result ->","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                   result","counters":[]},{"line":"               | Error e ->","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                   [%log error]","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                     ~metadata:[ (\"error\", Error_json.error_to_yojson e) ]","counters":[{"col_start":68,"col_end":68,"count":0}]},{"line":"                     \"Verifier threw an exception while verifying transaction \\","counters":[]},{"line":"                      snark\" ;","counters":[]},{"line":"                   failwith \"Verifier crashed\"","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"","counters":[]},{"line":"             let get_blockchain_verification_key () =","counters":[]},{"line":"               Lazy.force B.Proof.verification_key","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"           end in","counters":[]},{"line":"          (module M : S) )","counters":[]},{"line":"    | Check | None ->","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":14,"col_end":14,"count":0}]},{"line":"        Deferred.return","counters":[]},{"line":"        @@ ( module struct","counters":[]},{"line":"             let verify_commands cs =","counters":[]},{"line":"               List.map cs ~f:(fun c ->","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                   match Common.check c with","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"                   | `Valid c ->","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                       `Valid c","counters":[]},{"line":"                   | `Valid_assuming (c, _) ->","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                       `Valid c","counters":[]},{"line":"                   | `Invalid_keys keys ->","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                       `Invalid_keys keys","counters":[]},{"line":"                   | `Invalid_signature keys ->","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                       `Invalid_signature keys","counters":[]},{"line":"                   | `Invalid_proof ->","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                       `Invalid_proof","counters":[]},{"line":"                   | `Missing_verification_key keys ->","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                       `Missing_verification_key keys )","counters":[]},{"line":"               |> Deferred.return","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"","counters":[]},{"line":"             let verify_blockchain_snarks _ = Deferred.return true","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"","counters":[]},{"line":"             let verify_transaction_snarks _ = Deferred.return true","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"","counters":[]},{"line":"             let vk =","counters":[]},{"line":"               lazy","counters":[]},{"line":"                 (let module T = Transaction_snark.Make (struct","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                    let constraint_constants = constraint_constants","counters":[]},{"line":"","counters":[]},{"line":"                    let proof_level = proof_level","counters":[]},{"line":"                  end) in","counters":[]},{"line":"                 let module B = Blockchain_snark_state.Make (struct","counters":[]},{"line":"                   let tag = T.tag","counters":[]},{"line":"","counters":[]},{"line":"                   let constraint_constants = constraint_constants","counters":[]},{"line":"","counters":[]},{"line":"                   let proof_level = proof_level","counters":[]},{"line":"                 end) in","counters":[]},{"line":"                 Lazy.force B.Proof.verification_key )","counters":[]},{"line":"","counters":[]},{"line":"             let get_blockchain_verification_key () = Lazy.force vk","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"           end : S )","counters":[]},{"line":"","counters":[]},{"line":"  let get = Fn.id","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Worker = struct","counters":[]},{"line":"  module T = struct","counters":[]},{"line":"    module F = Rpc_parallel.Function","counters":[]},{"line":"","counters":[]},{"line":"    type 'w functions =","counters":[]},{"line":"      { verify_blockchains : ('w, Blockchain.t list, bool) F.t","counters":[]},{"line":"      ; verify_transaction_snarks :","counters":[]},{"line":"          ('w, (Transaction_snark.t * Sok_message.t) list, bool) F.t","counters":[]},{"line":"      ; verify_commands :","counters":[]},{"line":"          ( 'w","counters":[]},{"line":"          , User_command.Verifiable.t list","counters":[]},{"line":"          , [ `Valid of User_command.Valid.t","counters":[]},{"line":"            | `Valid_assuming of","counters":[]},{"line":"              ( Pickles.Side_loaded.Verification_key.t","counters":[]},{"line":"              * Mina_base.Zkapp_statement.t","counters":[]},{"line":"              * Pickles.Side_loaded.Proof.t )","counters":[]},{"line":"              list","counters":[]},{"line":"            | invalid ]","counters":[]},{"line":"            list )","counters":[]},{"line":"          F.t","counters":[]},{"line":"      ; get_blockchain_verification_key :","counters":[]},{"line":"          ('w, unit, Pickles.Verification_key.t) F.t","counters":[]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    module Worker_state = Worker_state","counters":[]},{"line":"","counters":[]},{"line":"    module Connection_state = struct","counters":[]},{"line":"      (* bin_io required by rpc_parallel *)","counters":[]},{"line":"      type init_arg = unit [@@deriving bin_io_unversioned]","counters":[{"col_start":6,"col_end":6,"count":1},{"col_start":18,"col_end":18,"count":1},{"col_start":57,"col_end":57,"count":4}]},{"line":"","counters":[]},{"line":"      type t = unit","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Functions","counters":[]},{"line":"        (C : Rpc_parallel.Creator","counters":[]},{"line":"               with type worker_state := Worker_state.t","counters":[]},{"line":"                and type connection_state := Connection_state.t) =","counters":[]},{"line":"    struct","counters":[]},{"line":"      let verify_blockchains (w : Worker_state.t) (chains : Blockchain.t list) =","counters":[]},{"line":"        let (module M) = Worker_state.get w in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        M.verify_blockchain_snarks","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (List.map chains ~f:(fun snark ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"               ( Blockchain_snark.Blockchain.state snark","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"               , Blockchain_snark.Blockchain.proof snark ) ) )","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"","counters":[]},{"line":"      let verify_transaction_snarks (w : Worker_state.t) ts =","counters":[]},{"line":"        let (module M) = Worker_state.get w in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        M.verify_transaction_snarks ts","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      let verify_commands (w : Worker_state.t) ts =","counters":[]},{"line":"        let (module M) = Worker_state.get w in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        M.verify_commands ts","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      let get_blockchain_verification_key (w : Worker_state.t) () =","counters":[]},{"line":"        let (module M) = Worker_state.get w in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Deferred.return (M.get_blockchain_verification_key ())","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"","counters":[]},{"line":"      let functions =","counters":[]},{"line":"        let f (i, o, f) =","counters":[]},{"line":"          C.create_rpc","counters":[{"col_start":10,"col_end":10,"count":4}]},{"line":"            ~f:(fun ~worker_state ~conn_state:_ i -> f worker_state i)","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"            ~bin_input:i ~bin_output:o ()","counters":[]},{"line":"        in","counters":[]},{"line":"        { verify_blockchains =","counters":[]},{"line":"            f","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"              ( [%bin_type_class: Blockchain.Stable.Latest.t list]","counters":[]},{"line":"              , Bool.bin_t","counters":[]},{"line":"              , verify_blockchains )","counters":[]},{"line":"        ; verify_transaction_snarks =","counters":[]},{"line":"            f","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"              ( [%bin_type_class:","counters":[]},{"line":"                  ( Transaction_snark.Stable.Latest.t","counters":[]},{"line":"                  * Sok_message.Stable.Latest.t )","counters":[]},{"line":"                  list]","counters":[]},{"line":"              , Bool.bin_t","counters":[]},{"line":"              , verify_transaction_snarks )","counters":[]},{"line":"        ; verify_commands =","counters":[]},{"line":"            f","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"              ( [%bin_type_class: User_command.Verifiable.Stable.Latest.t list]","counters":[]},{"line":"              , [%bin_type_class:","counters":[]},{"line":"                  [ `Valid of User_command.Valid.Stable.Latest.t","counters":[]},{"line":"                  | `Valid_assuming of","counters":[]},{"line":"                    ( Pickles.Side_loaded.Verification_key.Stable.Latest.t","counters":[]},{"line":"                    * Mina_base.Zkapp_statement.Stable.Latest.t","counters":[]},{"line":"                    * Pickles.Side_loaded.Proof.Stable.Latest.t )","counters":[]},{"line":"                    list","counters":[]},{"line":"                  | invalid ]","counters":[]},{"line":"                  list]","counters":[]},{"line":"              , verify_commands )","counters":[]},{"line":"        ; get_blockchain_verification_key =","counters":[]},{"line":"            f","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"              ( [%bin_type_class: unit]","counters":[]},{"line":"              , [%bin_type_class: Pickles.Verification_key.Stable.Latest.t]","counters":[]},{"line":"              , get_blockchain_verification_key )","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"      let init_worker_state","counters":[]},{"line":"          Worker_state.{ conf_dir; logger; proof_level; constraint_constants } =","counters":[]},{"line":"        ( if Option.is_some conf_dir then","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let max_size = 256 * 1024 * 512 in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let num_rotate = 1 in","counters":[]},{"line":"          Logger.Consumer_registry.register ~id:\"default\"","counters":[]},{"line":"            ~processor:(Logger.Processor.raw ())","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"            ~transport:","counters":[]},{"line":"              (Logger_file_system.dumb_logrotate","counters":[]},{"line":"                 ~directory:(Option.value_exn conf_dir)","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"                 ~log_filename:\"mina-verifier.log\" ~max_size ~num_rotate ) ) ;","counters":[]},{"line":"        [%log info] \"Verifier started\" ;","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"        Worker_state.create","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          { conf_dir; logger; proof_level; constraint_constants }","counters":[]},{"line":"","counters":[]},{"line":"      let init_connection_state ~connection:_ ~worker_state:_ () = Deferred.unit","counters":[{"col_start":67,"col_end":67,"count":0}]},{"line":"    end","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  include Rpc_parallel.Make (T)","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"type worker =","counters":[]},{"line":"  { connection : Worker.Connection.t","counters":[]},{"line":"  ; process : Process.t","counters":[]},{"line":"  ; exit_or_signal : Unix.Exit_or_signal.t Deferred.Or_error.t","counters":[]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"type t = { worker : worker Ivar.t ref; logger : Logger.Stable.Latest.t }","counters":[]},{"line":"","counters":[]},{"line":"(* TODO: investigate why conf_dir wasn't being used *)","counters":[]},{"line":"let create ~logger ~proof_level ~constraint_constants ~pids ~conf_dir :","counters":[]},{"line":"    t Deferred.t =","counters":[]},{"line":"  let on_failure err =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    [%log error] \"Verifier process failed with error $err\"","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"      ~metadata:[ (\"err\", Error_json.error_to_yojson err) ] ;","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"    Error.raise err","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  in","counters":[]},{"line":"  let create_worker () =","counters":[]},{"line":"    [%log info] \"Starting a new verifier process\" ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":14,"col_end":14,"count":0}]},{"line":"    let%map.Deferred.Or_error connection, process =","counters":[]},{"line":"      (* This [try_with] isn't really here to catch an error that throws while","counters":[]},{"line":"         the process is being spawned. Indeed, the immediate [ok_exn] will","counters":[]},{"line":"         ensure that any errors that occur during that time are immediately","counters":[]},{"line":"         re-raised.","counters":[]},{"line":"         However, this *also* captures any exceptions raised by code scheduled","counters":[]},{"line":"         as a result of the inner calls, but which have not completed by the","counters":[]},{"line":"         time the process has been created.","counters":[]},{"line":"         In order to suppress errors around [wait]s coming from [Rpc_parallel]","counters":[]},{"line":"         -- in particular the \"no child processes\" WNOHANG error -- we supply a","counters":[]},{"line":"         [rest] handler for the 'rest' of the errors after the value is","counters":[]},{"line":"         determined, which logs the errors and then swallows them.","counters":[]},{"line":"      *)","counters":[]},{"line":"      Monitor.try_with ~name:\"Verifier RPC worker\" ~here:[%here] ~run:`Now","counters":[]},{"line":"        ~rest:","counters":[]},{"line":"          (`Call","counters":[]},{"line":"            (fun exn ->","counters":[]},{"line":"              let err = Error.of_exn ~backtrace:`Get exn in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              [%log error] \"Error from verifier worker $err\"","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"                ~metadata:[ (\"err\", Error_json.error_to_yojson err) ] ) )","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"        (fun () ->","counters":[]},{"line":"          Worker.spawn_in_foreground_exn","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ~connection_timeout:(Time.Span.of_min 1.) ~on_failure","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"            ~shutdown_on:Connection_closed ~connection_state_init_arg:()","counters":[]},{"line":"            { conf_dir; logger; proof_level; constraint_constants } )","counters":[]},{"line":"      |> Deferred.Result.map_error ~f:Error.of_exn","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"    in","counters":[]},{"line":"    Child_processes.Termination.wait_for_process_log_errors ~logger process","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ~module_:__MODULE__ ~location:__LOC__ ~here:[%here] ;","counters":[]},{"line":"    let exit_or_signal =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Child_processes.Termination.wait_safe ~logger process ~module_:__MODULE__","counters":[]},{"line":"        ~location:__LOC__ ~here:[%here]","counters":[]},{"line":"    in","counters":[]},{"line":"    [%log info]","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":14,"col_end":14,"count":0}]},{"line":"      \"Daemon started process of kind $process_kind with pid $verifier_pid\"","counters":[]},{"line":"      ~metadata:","counters":[]},{"line":"        [ (\"verifier_pid\", `Int (Process.pid process |> Pid.to_int))","counters":[{"col_start":56,"col_end":56,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"        ; ( \"process_kind\"","counters":[]},{"line":"          , `String Child_processes.Termination.(show_process_kind Verifier) )","counters":[{"col_start":65,"col_end":65,"count":0}]},{"line":"        ] ;","counters":[]},{"line":"    Child_processes.Termination.register_process pids process","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Child_processes.Termination.Verifier ;","counters":[]},{"line":"    (* Always report termination as expected, and use the restart logic here","counters":[]},{"line":"       instead.","counters":[]},{"line":"    *)","counters":[]},{"line":"    don't_wait_for","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    @@ Pipe.iter","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"         (Process.stdout process |> Reader.pipe)","counters":[{"col_start":36,"col_end":36,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"         ~f:(fun stdout ->","counters":[]},{"line":"           return","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"           @@ [%log debug] \"Verifier stdout: $stdout\"","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                ~metadata:[ (\"stdout\", `String stdout) ] ) ;","counters":[]},{"line":"    don't_wait_for","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    @@ Pipe.iter","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"         (Process.stderr process |> Reader.pipe)","counters":[{"col_start":36,"col_end":36,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"         ~f:(fun stderr ->","counters":[]},{"line":"           return","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"           @@ [%log error] \"Verifier stderr: $stderr\"","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                ~metadata:[ (\"stderr\", `String stderr) ] ) ;","counters":[]},{"line":"    { connection; process; exit_or_signal }","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%map worker = create_worker () |> Deferred.Or_error.ok_exn in","counters":[{"col_start":39,"col_end":39,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"  let worker_ref = ref (Ivar.create_full worker) in","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"  let rec on_worker { connection = _; process; exit_or_signal } =","counters":[]},{"line":"    let finished =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Deferred.any","counters":[]},{"line":"        [ ( exit_or_signal","counters":[]},{"line":"          >>| function","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          | Ok _ ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              `Unexpected_termination","counters":[]},{"line":"          | Error err ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              `Wait_threw_an_exception err )","counters":[]},{"line":"        ]","counters":[]},{"line":"    in","counters":[]},{"line":"    upon finished (fun e ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        don't_wait_for (Process.stdin process |> Writer.close) ;","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":49,"col_end":49,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"        let pid = Process.pid process in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Child_processes.Termination.remove pids pid ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let create_worker_trigger = Ivar.create () in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        don't_wait_for","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (* If we don't hear back that the process has died after 10 seconds,","counters":[]},{"line":"             begin creating a new process anyway.","counters":[]},{"line":"          *)","counters":[]},{"line":"          (let%map () = after (Time.Span.of_sec 10.) in","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"           Ivar.fill_if_empty create_worker_trigger () ) ;","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"        let () =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          match e with","counters":[]},{"line":"          | `Unexpected_termination ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              [%log error] \"verifier terminated unexpectedly\"","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                ~metadata:[ (\"verifier_pid\", `Int (Pid.to_int pid)) ] ;","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"              Ivar.fill_if_empty create_worker_trigger ()","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"          | `Wait_threw_an_exception _ -> (","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              ( match e with","counters":[]},{"line":"              | `Wait_threw_an_exception err ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  [%log info]","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                    \"Saw an exception while trying to wait for the verifier \\","counters":[]},{"line":"                     process: $exn\"","counters":[]},{"line":"                    ~metadata:[ (\"exn\", Error_json.error_to_yojson err) ]","counters":[{"col_start":65,"col_end":65,"count":0}]},{"line":"              | _ ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  () ) ;","counters":[]},{"line":"              match Signal.send Signal.kill (`Pid pid) with","counters":[]},{"line":"              | `No_such_process ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  [%log info] \"verifier failed to get sigkill (no such process)\"","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                    ~metadata:[ (\"verifier_pid\", `Int (Pid.to_int pid)) ] ;","counters":[{"col_start":64,"col_end":64,"count":0}]},{"line":"                  Ivar.fill_if_empty create_worker_trigger ()","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"              | `Ok ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  [%log info] \"verifier successfully got sigkill\"","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                    ~metadata:[ (\"verifier_pid\", `Int (Pid.to_int pid)) ] )","counters":[{"col_start":64,"col_end":64,"count":0}]},{"line":"        in","counters":[]},{"line":"        let new_worker = Ivar.create () in","counters":[]},{"line":"        worker_ref := new_worker ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        don't_wait_for","counters":[]},{"line":"          (let%map exit_metadata =","counters":[]},{"line":"             match%map exit_or_signal with","counters":[]},{"line":"             | Ok res ->","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                 [ ( \"exit_status\"","counters":[]},{"line":"                   , `String (Unix.Exit_or_signal.to_string_hum res) )","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"                 ]","counters":[]},{"line":"             | Error err ->","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                 [ (\"exit_status\", `String \"Unknown: wait threw an error\")","counters":[]},{"line":"                 ; (\"exn\", Error_json.error_to_yojson err)","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"                 ]","counters":[]},{"line":"           in","counters":[]},{"line":"           [%log info] \"verifier successfully stopped\"","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"             ~metadata:","counters":[]},{"line":"               ( (\"verifier_pid\", `Int (Process.pid process |> Pid.to_int))","counters":[{"col_start":63,"col_end":63,"count":0},{"col_start":72,"col_end":72,"count":0}]},{"line":"               :: exit_metadata ) ;","counters":[]},{"line":"           Child_processes.Termination.remove pids pid ;","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"           Ivar.fill_if_empty create_worker_trigger () ) ;","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"        don't_wait_for","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (let%bind () = Ivar.read create_worker_trigger in","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"           let rec try_create_worker () =","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"             match%bind create_worker () with","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"             | Ok worker ->","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                 on_worker worker ;","counters":[]},{"line":"                 Ivar.fill new_worker worker ;","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                 return ()","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"             | Error err ->","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                 [%log error]","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                   \"Failed to create a new verifier process: $err. Retrying...\"","counters":[]},{"line":"                   ~metadata:[ (\"err\", Error_json.error_to_yojson err) ] ;","counters":[{"col_start":64,"col_end":64,"count":0}]},{"line":"                 (* Wait 5s before retrying. *)","counters":[]},{"line":"                 let%bind () = after Time.Span.(of_sec 5.) in","counters":[{"col_start":35,"col_end":35,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"                 try_create_worker ()","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"           in","counters":[]},{"line":"           try_create_worker () ) )","counters":[]},{"line":"  in","counters":[]},{"line":"  on_worker worker ;","counters":[]},{"line":"  { worker = worker_ref; logger }","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let with_retry ~logger f =","counters":[]},{"line":"  let pause = Time.Span.of_sec 5. in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let rec go attempts_remaining =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    [%log trace] \"Verifier trying with $attempts_remaining\"","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"      ~metadata:[ (\"attempts_remaining\", `Int attempts_remaining) ] ;","counters":[]},{"line":"    match%bind f () with","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"    | Ok (`Continue x) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        return (Ok x)","counters":[]},{"line":"    | Ok (`Stop e) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        return (Error e)","counters":[]},{"line":"    | Error e ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        if attempts_remaining = 0 then return (Error e)","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"        else","counters":[]},{"line":"          let%bind () = after pause in","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"          go (attempts_remaining - 1)","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"  in","counters":[]},{"line":"  go 4","counters":[]},{"line":"","counters":[]},{"line":"let verify_blockchain_snarks { worker; logger } chains =","counters":[]},{"line":"  O1trace.thread \"dispatch_blockchain_snark_verification\" (fun () ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      with_retry ~logger (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          let%bind { connection; _ } =","counters":[]},{"line":"            let ivar = !worker in","counters":[]},{"line":"            match Ivar.peek ivar with","counters":[]},{"line":"            | Some worker ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Deferred.return worker","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"            | None ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                [%log debug] \"Waiting for the verifier process to restart\" ;","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                let%map worker = Ivar.read ivar in","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"                [%log debug] \"Verifier process has restarted; finished waiting\" ;","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"                worker","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"          in","counters":[]},{"line":"          Deferred.any","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            [ ( after (Time.Span.of_min 3.)","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"              >>| fun _ ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"              Or_error.return","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              @@ `Stop (Error.of_string \"verify_blockchain_snarks timeout\") )","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"            ; Worker.Connection.run connection","counters":[]},{"line":"                ~f:Worker.functions.verify_blockchains ~arg:chains","counters":[]},{"line":"              |> Deferred.Or_error.map ~f:(fun x -> `Continue x)","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"            ] ) )","counters":[]},{"line":"","counters":[]},{"line":"let verify_transaction_snarks { worker; logger } ts =","counters":[]},{"line":"  O1trace.thread \"dispatch_transaction_snark_verification\" (fun () ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      let n = List.length ts in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let metadata = [ (\"n\", `Int n) ] in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      [%log trace] \"verify $n transaction_snarks (before)\" ~metadata ;","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"      let%map res =","counters":[]},{"line":"        with_retry ~logger (fun () ->","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"            let%bind { connection; _ } = Ivar.read !worker in","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"            Worker.Connection.run connection","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              ~f:Worker.functions.verify_transaction_snarks ~arg:ts","counters":[]},{"line":"            |> Deferred.Or_error.map ~f:(fun x -> `Continue x) )","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"      in","counters":[]},{"line":"      [%log trace] \"verify $n transaction_snarks (after)!\"","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"        ~metadata:","counters":[]},{"line":"          ( ( \"result\"","counters":[]},{"line":"            , `String (Sexp.to_string ([%sexp_of: bool Or_error.t] res)) )","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"          :: metadata ) ;","counters":[]},{"line":"      res )","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"let verify_commands { worker; logger } ts =","counters":[]},{"line":"  O1trace.thread \"dispatch_user_command_verification\" (fun () ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      with_retry ~logger (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          let%bind { connection; _ } = Ivar.read !worker in","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"          Worker.Connection.run connection ~f:Worker.functions.verify_commands","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ~arg:ts","counters":[]},{"line":"          |> Deferred.Or_error.map ~f:(fun x -> `Continue x) ) )","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"","counters":[]},{"line":"let get_blockchain_verification_key { worker; logger } =","counters":[]},{"line":"  O1trace.thread \"dispatch_blockchain_verification_key\" (fun () ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      with_retry ~logger (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          let%bind { connection; _ } = Ivar.read !worker in","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"          Worker.Connection.run connection","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ~f:Worker.functions.get_blockchain_verification_key ~arg:()","counters":[]},{"line":"          |> Deferred.Or_error.map ~f:(fun x -> `Continue x) ) )","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":48,"col_end":48,"count":0}]}]}