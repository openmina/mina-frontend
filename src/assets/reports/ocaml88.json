{"filename":"src/lib/mina_ledger/sparse_ledger.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Mina_base","counters":[]},{"line":"include Sparse_ledger_base","counters":[]},{"line":"module GS = Global_state","counters":[]},{"line":"","counters":[]},{"line":"let of_ledger_root ledger =","counters":[]},{"line":"  of_root ~depth:(Ledger.depth ledger) (Ledger.merkle_root ledger)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"","counters":[]},{"line":"let of_any_ledger (ledger : Ledger.Any_ledger.witness) =","counters":[]},{"line":"  Ledger.Any_ledger.M.foldi ledger","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    ~init:","counters":[]},{"line":"      (of_root","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"         ~depth:(Ledger.Any_ledger.M.depth ledger)","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"         (Ledger.Any_ledger.M.merkle_root ledger) )","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"    ~f:(fun _addr sparse_ledger account ->","counters":[]},{"line":"      let loc =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Option.value_exn","counters":[]},{"line":"          (Ledger.Any_ledger.M.location_of_account ledger","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"             (Account.identifier account) )","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"      in","counters":[]},{"line":"      add_path sparse_ledger","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (Ledger.Any_ledger.M.merkle_path ledger loc)","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"        (Account.identifier account)","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"        (Option.value_exn (Ledger.Any_ledger.M.get ledger loc)) )","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"","counters":[]},{"line":"let of_ledger_subset_exn (oledger : Ledger.t) keys =","counters":[]},{"line":"  let ledger = Ledger.copy oledger in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  (* Printf.eprintf \"KEYS_LENGTH=%d\\n%!\" (List.length keys) ; *)","counters":[]},{"line":"  let _, sparse =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    List.fold keys","counters":[]},{"line":"      ~f:(fun (new_keys, sl) key ->","counters":[]},{"line":"        match Ledger.location_of_account ledger key with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | Some loc ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (* let path = Ledger.merkle_path ledger loc in *)","counters":[]},{"line":"            (* let v = *)","counters":[]},{"line":"            (*   List.map path ~f:(fun p -> *)","counters":[]},{"line":"            (*       match p with `Right h -> h | `Left h -> h ) *)","counters":[]},{"line":"            (* in *)","counters":[]},{"line":"            (* let v = List.map v ~f:Snark_params.Tick.Field.to_string in *)","counters":[]},{"line":"            (* Printf.eprintf \"PATH=%s\\n%!\" (String.concat ~sep:\",\" v) ; *)","counters":[]},{"line":"","counters":[]},{"line":"            (* let root = Ledger.merkle_root ledger in *)","counters":[]},{"line":"            (* Printf.eprintf \"location=%s root=%s num_accounts=%d\\n%!\" *)","counters":[]},{"line":"            (*   (Ledger.Location.to_path_exn loc |> Ledger.Addr.to_string) *)","counters":[]},{"line":"            (*   (Snark_params.Tick.Field.to_string root) *)","counters":[]},{"line":"            (*   (Ledger.num_accounts ledger) ; *)","counters":[]},{"line":"            ( new_keys","counters":[]},{"line":"            , add_path sl","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                (Ledger.merkle_path ledger loc)","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"                key","counters":[]},{"line":"                ( Ledger.get ledger loc","counters":[]},{"line":"                |> Option.value_exn ?here:None ?error:None ?message:None ) )","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (* Printf.eprintf \"no location\\n%!\" ; *)","counters":[]},{"line":"            let path, acct = Ledger.create_empty_exn ledger key in","counters":[]},{"line":"            (key :: new_keys, add_path sl path key acct) )","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"      ~init:([], of_ledger_root ledger)","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"  in","counters":[]},{"line":"  Debug_assert.debug_assert (fun () ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      [%test_eq: Ledger_hash.t]","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"        (Ledger.merkle_root ledger)","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"        ((merkle_root sparse :> Random_oracle.Digest.t) |> Ledger_hash.of_hash) ) ;","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":77,"col_end":77,"count":0}]},{"line":"  sparse","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let of_ledger_index_subset_exn (ledger : Ledger.Any_ledger.witness) indexes =","counters":[]},{"line":"  List.fold indexes","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    ~init:","counters":[]},{"line":"      (of_root","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"         ~depth:(Ledger.Any_ledger.M.depth ledger)","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"         (Ledger.Any_ledger.M.merkle_root ledger) )","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"    ~f:(fun acc i ->","counters":[]},{"line":"      let account = Ledger.Any_ledger.M.get_at_index_exn ledger i in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      add_path acc","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (Ledger.Any_ledger.M.merkle_path_at_index_exn ledger i)","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"        (Account.identifier account)","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"        account )","counters":[]},{"line":"","counters":[]},{"line":"let%test_unit \"of_ledger_subset_exn with keys that don't exist works\" =","counters":[]},{"line":"  let keygen () =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    let privkey = Signature_lib.Private_key.create () in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    ( privkey","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    , Signature_lib.Public_key.of_private_key_exn privkey","counters":[]},{"line":"      |> Signature_lib.Public_key.compress )","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"  in","counters":[]},{"line":"  Ledger.with_ledger","counters":[]},{"line":"    ~depth:Genesis_constants.Constraint_constants.for_unit_tests.ledger_depth","counters":[]},{"line":"    ~f:(fun ledger ->","counters":[]},{"line":"      let _, pub1 = keygen () in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let _, pub2 = keygen () in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let aid1 = Account_id.create pub1 Token_id.default in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let aid2 = Account_id.create pub2 Token_id.default in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let sl = of_ledger_subset_exn ledger [ aid1; aid2 ] in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      [%test_eq: Ledger_hash.t]","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"        (Ledger.merkle_root ledger)","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"        ((merkle_root sl :> Random_oracle.Digest.t) |> Ledger_hash.of_hash) )","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":73,"col_end":73,"count":0}]},{"line":"","counters":[]},{"line":"module T = Mina_transaction_logic.Make (L)","counters":[]},{"line":"","counters":[]},{"line":"let apply_zkapp_command_unchecked_with_states ~constraint_constants ~state_view","counters":[]},{"line":"    ~fee_excess ~supply_increase ledger c =","counters":[]},{"line":"  let open T in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  apply_zkapp_command_unchecked_aux ~constraint_constants ~state_view","counters":[]},{"line":"    ~fee_excess ~supply_increase (ref ledger) c ~init:[]","counters":[]},{"line":"    ~f:(fun","counters":[]},{"line":"         acc","counters":[]},{"line":"         ({ ledger; fee_excess; supply_increase; protocol_state }, local_state)","counters":[]},{"line":"       ->","counters":[]},{"line":"      ( { GS.ledger = !ledger; fee_excess; supply_increase; protocol_state }","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      , { local_state with ledger = !(local_state.ledger) } )","counters":[]},{"line":"      :: acc )","counters":[]},{"line":"  |> Result.map ~f:(fun (account_update_applied, states) ->","counters":[{"col_start":5,"col_end":5,"count":0}]},{"line":"         (* We perform a [List.rev] here to ensure that the states are in order","counters":[]},{"line":"            wrt. the zkapp_command that generated the states.","counters":[]},{"line":"         *)","counters":[]},{"line":"         (account_update_applied, List.rev states) )","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"","counters":[]},{"line":"let apply_transaction_logic f t x =","counters":[]},{"line":"  let open Or_error.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let t' = ref t in","counters":[]},{"line":"  let%map app = f t' x in","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"  (!t', app)","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let apply_user_command ~constraint_constants ~txn_global_slot =","counters":[]},{"line":"  apply_transaction_logic","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    (T.apply_user_command ~constraint_constants ~txn_global_slot)","counters":[]},{"line":"","counters":[]},{"line":"let apply_transaction' ~constraint_constants ~txn_state_view l t =","counters":[]},{"line":"  O1trace.sync_thread \"apply_transaction\" (fun () ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      T.apply_transaction ~constraint_constants ~txn_state_view l t )","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"let apply_transaction ~constraint_constants ~txn_state_view =","counters":[]},{"line":"  apply_transaction_logic","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    (apply_transaction' ~constraint_constants ~txn_state_view)","counters":[{"col_start":61,"col_end":61,"count":1}]}]}