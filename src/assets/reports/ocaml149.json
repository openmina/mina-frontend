{"filename":"src/lib/mina_base/signed_command_memo.ml","lines":[{"line":"(* signed_command_memo.ml *)","counters":[]},{"line":"","counters":[]},{"line":"[%%import \"/src/config.mlh\"]","counters":[]},{"line":"","counters":[{"col_start":0,"col_end":0,"count":1}]},{"line":"open Core_kernel","counters":[]},{"line":"open Snark_params","counters":[]},{"line":"","counters":[]},{"line":"(** See documentation of the {!Mina_wire_types} library *)","counters":[]},{"line":"module Wire_types = Mina_wire_types.Mina_base.Signed_command_memo","counters":[]},{"line":"","counters":[]},{"line":"module Make_sig (A : Wire_types.Types.S) = struct","counters":[]},{"line":"  module type S = Signed_command_memo_intf.S with type t = A.V1.t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make_str (_ : Wire_types.Concrete) = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"    module V1 = struct","counters":[]},{"line":"      [@@@with_all_version_tags]","counters":[]},{"line":"","counters":[]},{"line":"      type t = string [@@deriving sexp, equal, compare, hash]","counters":[{"col_start":6,"col_end":6,"count":4},{"col_start":11,"col_end":11,"count":2},{"col_start":60,"col_end":60,"count":15}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"      module Base58_check = Base58_check.Make (struct","counters":[]},{"line":"        let description = \"User command memo\"","counters":[]},{"line":"","counters":[]},{"line":"        let version_byte = Base58_check.Version_bytes.user_command_memo","counters":[]},{"line":"      end)","counters":[]},{"line":"","counters":[]},{"line":"      let to_base58_check (memo : t) : string = Base58_check.encode memo","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"","counters":[]},{"line":"      let of_base58_check (s : string) : t Or_error.t = Base58_check.decode s","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"","counters":[]},{"line":"      let of_base58_check_exn (s : string) : t = Base58_check.decode_exn s","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"","counters":[]},{"line":"      module T = struct","counters":[]},{"line":"        type nonrec t = t","counters":[]},{"line":"","counters":[]},{"line":"        let to_string = to_base58_check","counters":[]},{"line":"","counters":[]},{"line":"        let of_string = of_base58_check_exn","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      include Codable.Make_of_string (T)","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  [%%define_locally","counters":[]},{"line":"  Stable.Latest.","counters":[]},{"line":"    (to_yojson, of_yojson, to_base58_check, of_base58_check, of_base58_check_exn)]","counters":[]},{"line":"","counters":[]},{"line":"  exception Too_long_user_memo_input","counters":[]},{"line":"","counters":[]},{"line":"  exception Too_long_digestible_string","counters":[]},{"line":"","counters":[]},{"line":"  let max_digestible_string_length = 1000","counters":[]},{"line":"","counters":[]},{"line":"  (* 0th byte is a tag to distinguish digests from other data","counters":[]},{"line":"     1st byte is length, always 32 for digests","counters":[]},{"line":"     bytes 2 to 33 are data, 0-right-padded if length is less than 32","counters":[]},{"line":"  *)","counters":[]},{"line":"","counters":[]},{"line":"  let digest_tag = '\\x00'","counters":[]},{"line":"","counters":[]},{"line":"  let bytes_tag = '\\x01'","counters":[]},{"line":"","counters":[]},{"line":"  let tag_index = 0","counters":[]},{"line":"","counters":[]},{"line":"  let length_index = 1","counters":[]},{"line":"","counters":[]},{"line":"  let digest_length = Blake2.digest_size_in_bytes","counters":[]},{"line":"","counters":[]},{"line":"  let digest_length_byte = Char.of_int_exn digest_length","counters":[{"col_start":41,"col_end":41,"count":1}]},{"line":"","counters":[]},{"line":"  (* +2 for tag and length bytes *)","counters":[]},{"line":"  let memo_length = digest_length + 2","counters":[]},{"line":"","counters":[]},{"line":"  let max_input_length = digest_length","counters":[]},{"line":"","counters":[]},{"line":"  let tag (memo : t) = memo.[tag_index]","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"  let length memo = Char.to_int memo.[length_index]","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"","counters":[]},{"line":"  let is_bytes memo = Char.equal (tag memo) bytes_tag","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"","counters":[]},{"line":"  let is_digest memo = Char.equal (tag memo) digest_tag","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"  let is_valid memo =","counters":[]},{"line":"    Int.(String.length memo = memo_length)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"    &&","counters":[]},{"line":"    let length = length memo in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    if is_digest memo then Int.(length = digest_length)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"    else","counters":[]},{"line":"      Char.equal (tag memo) bytes_tag","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":20,"col_end":20,"count":0}]},{"line":"      && Int.(length <= digest_length)","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"      &&","counters":[]},{"line":"      let padded =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        String.sub memo ~pos:(length + 2) ~len:(digest_length - length)","counters":[]},{"line":"      in","counters":[]},{"line":"      String.for_all padded ~f:(Char.equal '\\x00')","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"","counters":[]},{"line":"  let create_by_digesting_string_exn s =","counters":[]},{"line":"    if Int.(String.length s > max_digestible_string_length) then","counters":[{"col_start":4,"col_end":4,"count":1},{"col_start":24,"col_end":24,"count":1}]},{"line":"      raise Too_long_digestible_string ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    let digest = Blake2.(to_raw_string (digest_string s)) in","counters":[{"col_start":4,"col_end":4,"count":1},{"col_start":37,"col_end":37,"count":1},{"col_start":52,"col_end":52,"count":1}]},{"line":"    String.init memo_length ~f:(fun ndx ->","counters":[]},{"line":"        if Int.(ndx = tag_index) then digest_tag","counters":[{"col_start":8,"col_end":8,"count":34},{"col_start":38,"col_end":38,"count":1}]},{"line":"        else if Int.(ndx = length_index) then digest_length_byte","counters":[{"col_start":13,"col_end":13,"count":33},{"col_start":46,"col_end":46,"count":1}]},{"line":"        else digest.[ndx - 2] )","counters":[{"col_start":13,"col_end":13,"count":32}]},{"line":"","counters":[]},{"line":"  let create_by_digesting_string (s : string) =","counters":[]},{"line":"    try Ok (create_by_digesting_string_exn s)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"    with Too_long_digestible_string ->","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"      Or_error.error_string \"create_by_digesting_string: string too long\"","counters":[]},{"line":"","counters":[]},{"line":"  module type Memoable = sig","counters":[]},{"line":"    type t","counters":[]},{"line":"","counters":[]},{"line":"    val length : t -> int","counters":[]},{"line":"","counters":[]},{"line":"    val get : t -> int -> char","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let create_from_value_exn (type t) (module M : Memoable with type t = t)","counters":[]},{"line":"      (value : t) =","counters":[]},{"line":"    let len = M.length value in","counters":[{"col_start":4,"col_end":4,"count":1}]},{"line":"    if Int.(len > max_input_length) then raise Too_long_user_memo_input ;","counters":[{"col_start":4,"col_end":4,"count":1},{"col_start":41,"col_end":41,"count":0}]},{"line":"    String.init memo_length ~f:(fun ndx ->","counters":[{"col_start":4,"col_end":4,"count":1}]},{"line":"        if Int.(ndx = tag_index) then bytes_tag","counters":[{"col_start":8,"col_end":8,"count":34},{"col_start":38,"col_end":38,"count":1}]},{"line":"        else if Int.(ndx = length_index) then Char.of_int_exn len","counters":[{"col_start":13,"col_end":13,"count":33},{"col_start":46,"col_end":46,"count":1}]},{"line":"        else if Int.(ndx < len + 2) then M.get value (ndx - 2)","counters":[{"col_start":13,"col_end":13,"count":32},{"col_start":41,"col_end":41,"count":0}]},{"line":"        else '\\x00' )","counters":[{"col_start":13,"col_end":13,"count":32}]},{"line":"","counters":[]},{"line":"  let create_from_bytes_exn bytes = create_from_value_exn (module Bytes) bytes","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"","counters":[]},{"line":"  let create_from_bytes bytes =","counters":[]},{"line":"    try Ok (create_from_bytes_exn bytes)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"    with Too_long_user_memo_input ->","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"      Or_error.error_string","counters":[]},{"line":"        (sprintf \"create_from_bytes: length exceeds %d\" max_input_length)","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"","counters":[]},{"line":"  let create_from_string_exn s = create_from_value_exn (module String) s","counters":[{"col_start":33,"col_end":33,"count":1}]},{"line":"","counters":[]},{"line":"  let create_from_string s =","counters":[]},{"line":"    try Ok (create_from_string_exn s)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"    with Too_long_user_memo_input ->","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"      Or_error.error_string","counters":[]},{"line":"        (sprintf \"create_from_string: length exceeds %d\" max_input_length)","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"","counters":[]},{"line":"  let dummy = (create_by_digesting_string_exn \"\" :> t)","counters":[{"col_start":44,"col_end":44,"count":1}]},{"line":"","counters":[]},{"line":"  let empty = create_from_string_exn \"\"","counters":[{"col_start":35,"col_end":35,"count":1}]},{"line":"","counters":[]},{"line":"  type raw = Digest of string | Bytes of string","counters":[]},{"line":"","counters":[]},{"line":"  let to_raw_exn memo =","counters":[]},{"line":"    let tag = tag memo in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    if Char.equal tag digest_tag then Digest (to_base58_check memo)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"    else if Char.equal tag bytes_tag then","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"      let len = length memo in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Bytes (String.init len ~f:(fun idx -> memo.[idx - 2]))","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"    else failwithf \"Unknown memo tag %c\" tag ()","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"  let to_raw_bytes_exn memo =","counters":[]},{"line":"    match to_raw_exn memo with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Digest _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        failwith \"Cannot convert a digest to raw bytes\"","counters":[]},{"line":"    | Bytes str ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        str","counters":[]},{"line":"","counters":[]},{"line":"  let of_raw_exn = function","counters":[]},{"line":"    | Digest base58_check ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        of_base58_check_exn base58_check","counters":[]},{"line":"    | Bytes str ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        of_base58_check_exn str","counters":[]},{"line":"","counters":[]},{"line":"  let fold_bits t =","counters":[]},{"line":"    { Fold_lib.Fold.fold =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        (fun ~init ~f ->","counters":[]},{"line":"          let n = 8 * String.length t in","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"          let rec go acc i =","counters":[]},{"line":"            if i = n then acc","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"            else","counters":[]},{"line":"              let b = (Char.to_int t.[i / 8] lsr (i mod 8)) land 1 = 1 in","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"              go (f acc b) (i + 1)","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"          in","counters":[]},{"line":"          go init 0 )","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let to_bits t = Fold_lib.Fold.to_list (fold_bits t)","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"","counters":[]},{"line":"  let gen =","counters":[]},{"line":"    Quickcheck.Generator.map String.quickcheck_generator","counters":[{"col_start":27,"col_end":27,"count":1}]},{"line":"      ~f:create_by_digesting_string_exn","counters":[]},{"line":"","counters":[]},{"line":"  let hash memo =","counters":[]},{"line":"    Random_oracle.hash ~init:Hash_prefix.zkapp_memo","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (Random_oracle.Legacy.pack_input","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"         (Random_oracle_input.Legacy.bitstring (to_bits memo)) )","counters":[{"col_start":45,"col_end":45,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"","counters":[]},{"line":"  let to_plaintext (memo : t) : string Or_error.t =","counters":[]},{"line":"    if is_bytes memo then Ok (String.sub memo ~pos:2 ~len:(length memo))","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"    else Error (Error.of_string \"Memo does not contain text bytes\")","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"","counters":[]},{"line":"  let to_digest (memo : t) : string Or_error.t =","counters":[]},{"line":"    if is_digest memo then Ok (String.sub memo ~pos:2 ~len:digest_length)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"    else Error (Error.of_string \"Memo does not contain a digest\")","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"","counters":[]},{"line":"  let to_string_hum (memo : t) =","counters":[]},{"line":"    match to_plaintext memo with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Ok text ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        text","counters":[]},{"line":"    | Error _ -> (","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        match to_digest memo with","counters":[]},{"line":"        | Ok digest ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            sprintf \"0x%s\" (Hex.encode digest)","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"        | Error _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            \"(Invalid memo, neither text nor a digest)\" )","counters":[]},{"line":"","counters":[]},{"line":"  [%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"  module Boolean = Tick.Boolean","counters":[]},{"line":"  module Typ = Tick.Typ","counters":[]},{"line":"","counters":[]},{"line":"  (* the code below is much the same as in Random_oracle.Digest; tag and length bytes","counters":[]},{"line":"     make it a little different","counters":[]},{"line":"  *)","counters":[]},{"line":"","counters":[]},{"line":"  module Checked = struct","counters":[]},{"line":"    type unchecked = t","counters":[]},{"line":"","counters":[]},{"line":"    type t = Boolean.var array","counters":[]},{"line":"","counters":[]},{"line":"    let constant unchecked =","counters":[]},{"line":"      assert (Int.(String.length (unchecked :> string) = memo_length)) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"      Array.map","counters":[]},{"line":"        (Blake2.string_to_bits (unchecked :> string))","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"        ~f:Boolean.var_of_value","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let length_in_bits = 8 * memo_length","counters":[]},{"line":"","counters":[]},{"line":"  let typ : (Checked.t, t) Typ.t =","counters":[]},{"line":"    Typ.transport","counters":[{"col_start":16,"col_end":16,"count":1}]},{"line":"      (Typ.array ~length:length_in_bits Boolean.typ)","counters":[{"col_start":15,"col_end":15,"count":1}]},{"line":"      ~there:(fun (t : t) -> Blake2.string_to_bits (t :> string))","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"      ~back:(fun bs -> (Blake2.bits_to_string bs :> t))","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"  [%%endif]","counters":[]},{"line":"","counters":[]},{"line":"  let deriver obj =","counters":[]},{"line":"    Fields_derivers_zkapps.iso_string obj ~name:\"Memo\" ~js_type:String","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ~to_string:to_base58_check ~of_string:of_base58_check_exn","counters":[]},{"line":"","counters":[]},{"line":"  let%test_module \"user_command_memo\" =","counters":[]},{"line":"    ( module struct","counters":[]},{"line":"      let data memo = String.sub memo ~pos:(length_index + 1) ~len:(length memo)","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":73,"col_end":73,"count":0}]},{"line":"","counters":[]},{"line":"      let%test \"digest string\" =","counters":[]},{"line":"        let s = \"this is a string\" in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let memo = create_by_digesting_string_exn s in","counters":[]},{"line":"        is_valid memo","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      let%test \"digest too-long string\" =","counters":[]},{"line":"        let s =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          String.init (max_digestible_string_length + 1) ~f:(fun _ -> '\\xFF')","counters":[{"col_start":70,"col_end":70,"count":0}]},{"line":"        in","counters":[]},{"line":"        try","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let (_ : t) = create_by_digesting_string_exn s in","counters":[]},{"line":"          false","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        with Too_long_digestible_string -> true","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"      let%test \"memo from string\" =","counters":[]},{"line":"        let s = \"time and tide wait for no one\" in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let memo = create_from_string_exn s in","counters":[]},{"line":"        is_valid memo && String.equal s (data memo)","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"      let%test \"memo from too-long string\" =","counters":[]},{"line":"        let s = String.init (max_input_length + 1) ~f:(fun _ -> '\\xFF') in","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"        try","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let (_ : t) = create_from_string_exn s in","counters":[]},{"line":"          false","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        with Too_long_user_memo_input -> true","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"      [%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"      let%test_unit \"typ is identity\" =","counters":[]},{"line":"        let s = \"this is a string\" in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let memo = create_by_digesting_string_exn s in","counters":[]},{"line":"        let read_constant = function","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          | Snarky_backendless.Cvar.Constant x ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              x","counters":[]},{"line":"          | _ ->","counters":[]},{"line":"              assert false","counters":[]},{"line":"        in","counters":[]},{"line":"        let (Typ typ) = typ in","counters":[]},{"line":"        let memo_var =","counters":[]},{"line":"          memo |> typ.value_to_fields","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"          |> (fun (arr, aux) ->","counters":[]},{"line":"               ( Array.map arr ~f:(fun x -> Snarky_backendless.Cvar.Constant x)","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"               , aux ) )","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"          |> typ.var_of_fields","counters":[]},{"line":"        in","counters":[]},{"line":"        let memo_read =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          memo_var |> typ.var_to_fields","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"          |> (fun (arr, aux) ->","counters":[]},{"line":"               (Array.map arr ~f:(fun x -> read_constant x), aux) )","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":43,"col_end":43,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"          |> typ.value_of_fields","counters":[]},{"line":"        in","counters":[]},{"line":"        [%test_eq: string] memo memo_read","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"","counters":[]},{"line":"      [%%endif]","counters":[]},{"line":"    end )","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"include Wire_types.Make (Make_sig) (Make_str)","counters":[{"col_start":44,"col_end":44,"count":1}]}]}