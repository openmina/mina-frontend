{"filename":"src/scan_state/parallel_scan.rs","lines":[{"line":"use std::collections::{BTreeMap, VecDeque};","counters":[]},{"line":"use std::fmt::Debug;","counters":[]},{"line":"use std::io::Write;","counters":[]},{"line":"use std::ops::ControlFlow;","counters":[]},{"line":"","counters":[]},{"line":"use itertools::Itertools;","counters":[]},{"line":"use sha2::digest::generic_array::GenericArray;","counters":[]},{"line":"use sha2::digest::typenum::U32;","counters":[]},{"line":"use sha2::{Digest, Sha256};","counters":[]},{"line":"use ControlFlow::{Break, Continue};","counters":[]},{"line":"","counters":[]},{"line":"/// Sequence number for jobs in the scan state that corresponds to the order in","counters":[]},{"line":"/// which they were added","counters":[]},{"line":"#[derive(Clone, Eq, Ord, PartialEq, PartialOrd)]","counters":[{"col_start":9,"col_end":14,"count":0},{"col_start":20,"col_end":23,"count":0}]},{"line":"pub struct SequenceNumber(u64);","counters":[]},{"line":"","counters":[]},{"line":"impl Debug for SequenceNumber {","counters":[]},{"line":"    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {","counters":[{"col_start":4,"col_end":72,"count":154434}]},{"line":"        f.write_fmt(format_args!(\"{}\", self.0))","counters":[{"col_start":0,"col_end":47,"count":154434}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":154434}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl SequenceNumber {","counters":[]},{"line":"    fn zero() -> Self {","counters":[{"col_start":4,"col_end":23,"count":622}]},{"line":"        Self(0)","counters":[{"col_start":0,"col_end":15,"count":622}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":622}]},{"line":"","counters":[]},{"line":"    pub fn incr(&self) -> Self {","counters":[{"col_start":4,"col_end":32,"count":268786}]},{"line":"        Self(self.0 + 1)","counters":[{"col_start":0,"col_end":24,"count":268786}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":268786}]},{"line":"","counters":[]},{"line":"    fn is_u64_max(&self) -> bool {","counters":[{"col_start":4,"col_end":34,"count":0}]},{"line":"        self.0 == u64::MAX","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl std::ops::Sub for &'_ SequenceNumber {","counters":[]},{"line":"    type Output = SequenceNumber;","counters":[]},{"line":"","counters":[]},{"line":"    fn sub(self, rhs: &'_ SequenceNumber) -> Self::Output {","counters":[{"col_start":4,"col_end":59,"count":0}]},{"line":"        SequenceNumber(self.0 - rhs.0)","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"/// Each node on the tree is viewed as a job that needs to be completed. When a","counters":[]},{"line":"/// job is completed, it creates a new \"Todo\" job and marks the old job as \"Done\"","counters":[]},{"line":"#[derive(Clone, Debug)]","counters":[{"col_start":9,"col_end":10,"count":0},{"col_start":13,"col_end":14,"count":0},{"col_start":16,"col_end":17,"count":0},{"col_start":20,"col_end":21,"count":0}]},{"line":"pub enum JobStatus {","counters":[]},{"line":"    Todo,","counters":[]},{"line":"    Done,","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl JobStatus {","counters":[]},{"line":"    fn as_str(&self) -> &'static str {","counters":[{"col_start":4,"col_end":38,"count":0}]},{"line":"        match self {","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"            JobStatus::Todo => \"Todo\",","counters":[{"col_start":31,"col_end":37,"count":0}]},{"line":"            JobStatus::Done => \"Done\",","counters":[{"col_start":31,"col_end":37,"count":0}]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"/// The number of new jobs- base and merge that can be added to this tree.","counters":[]},{"line":"/// Each node has a weight associated to it and the","counters":[]},{"line":"/// new jobs received are distributed across the tree based on this number.","counters":[]},{"line":"#[derive(Clone)]","counters":[{"col_start":9,"col_end":14,"count":0}]},{"line":"pub struct Weight {","counters":[]},{"line":"    base: u64,","counters":[]},{"line":"    merge: u64,","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Debug for Weight {","counters":[]},{"line":"    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {","counters":[{"col_start":4,"col_end":72,"count":0}]},{"line":"        write!(f, \"{{ base: {} merge: {} }}\", self.base, self.merge)","counters":[{"col_start":0,"col_end":68,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Weight {","counters":[]},{"line":"    fn zero() -> Self {","counters":[{"col_start":4,"col_end":23,"count":0}]},{"line":"        Self { base: 0, merge: 0 }","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"trait Lens {","counters":[]},{"line":"    type Value;","counters":[]},{"line":"    type Target;","counters":[]},{"line":"    fn get<'a>(&self, target: &'a Self::Target) -> &'a Self::Value;","counters":[]},{"line":"    fn set(&self, target: &Self::Target, value: Self::Value) -> Self::Target;","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"enum WeightLens {","counters":[]},{"line":"    Base,","counters":[]},{"line":"    Merge,","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Lens for WeightLens {","counters":[]},{"line":"    type Value = u64;","counters":[]},{"line":"    type Target = Weight;","counters":[]},{"line":"","counters":[]},{"line":"    fn get<'a>(&self, target: &'a Self::Target) -> &'a Self::Value {","counters":[{"col_start":4,"col_end":68,"count":0}]},{"line":"        match self {","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"            WeightLens::Base => &target.base,","counters":[{"col_start":32,"col_end":44,"count":-192503}]},{"line":"            WeightLens::Merge => &target.merge,","counters":[{"col_start":33,"col_end":46,"count":192503}]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn set(&self, target: &Self::Target, value: Self::Value) -> Self::Target {","counters":[{"col_start":4,"col_end":78,"count":0}]},{"line":"        match self {","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"            WeightLens::Base => Self::Target {","counters":[{"col_start":32,"col_end":46,"count":0}]},{"line":"                base: value,","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"                merge: target.merge,","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"            },","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"            WeightLens::Merge => Self::Target {","counters":[{"col_start":33,"col_end":47,"count":0}]},{"line":"                base: target.base,","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"                merge: value,","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"            },","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"#[derive(Debug)]","counters":[{"col_start":9,"col_end":10,"count":0},{"col_start":13,"col_end":14,"count":0}]},{"line":"enum WorkForTree {","counters":[]},{"line":"    Current,","counters":[]},{"line":"    Next,","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"/// For base proofs (Proving new transactions)","counters":[]},{"line":"pub mod base {","counters":[]},{"line":"    use super::*;","counters":[]},{"line":"","counters":[]},{"line":"    #[derive(Clone)]","counters":[{"col_start":13,"col_end":18,"count":0}]},{"line":"    pub struct Record<BaseJob> {","counters":[]},{"line":"        pub job: BaseJob,","counters":[]},{"line":"        pub seq_no: SequenceNumber,","counters":[]},{"line":"        pub state: JobStatus,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl<BaseJob> Debug for Record<BaseJob> {","counters":[]},{"line":"        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {","counters":[{"col_start":8,"col_end":76,"count":0}]},{"line":"            let Self {","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"                job: _,","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"                seq_no,","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"                state,","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"            } = self;","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"            f.write_fmt(format_args!(\"seq_no: {:?}, state: {:?}\", seq_no, state))","counters":[{"col_start":0,"col_end":81,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    #[derive(Clone)]","counters":[{"col_start":13,"col_end":14,"count":0},{"col_start":17,"col_end":18,"count":0}]},{"line":"    pub enum Job<BaseJob> {","counters":[]},{"line":"        Empty,","counters":[]},{"line":"        Full(Record<BaseJob>),","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl<BaseJob> Debug for Job<BaseJob> {","counters":[]},{"line":"        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {","counters":[{"col_start":8,"col_end":76,"count":0}]},{"line":"            match self {","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"                Self::Empty => write!(f, \"Empty\"),","counters":[{"col_start":16,"col_end":49,"count":0}]},{"line":"                Self::Full(arg0) => f.write_fmt(format_args!(\"Full {{ {:?} }}\", arg0)),","counters":[{"col_start":16,"col_end":86,"count":0}]},{"line":"            }","counters":[]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    #[derive(Clone, Debug)]","counters":[{"col_start":13,"col_end":18,"count":0}]},{"line":"    pub struct Base<BaseJob> {","counters":[]},{"line":"        pub weight: Weight,","counters":[]},{"line":"        pub job: Job<BaseJob>,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl<BaseJob: Clone> Record<BaseJob> {","counters":[]},{"line":"        pub fn map<F: Fn(&BaseJob) -> BaseJob>(&self, fun: F) -> Self {","counters":[]},{"line":"            Self {","counters":[]},{"line":"                job: fun(&self.job),","counters":[]},{"line":"                seq_no: self.seq_no.clone(),","counters":[]},{"line":"                state: self.state.clone(),","counters":[]},{"line":"            }","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        pub fn with_seq_no(&self, no: SequenceNumber) -> Self {","counters":[{"col_start":8,"col_end":63,"count":0}]},{"line":"            Self {","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"                seq_no: no,","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"                state: self.state.clone(),","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"                job: self.job.clone(),","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl<BaseJob: Clone> Job<BaseJob> {","counters":[]},{"line":"        pub fn map<F: Fn(&BaseJob) -> BaseJob>(&self, fun: F) -> Self {","counters":[]},{"line":"            match self {","counters":[]},{"line":"                Job::Empty => Self::Empty,","counters":[]},{"line":"                Job::Full(r) => Job::Full(r.map(fun)),","counters":[]},{"line":"            }","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl<BaseJob: Clone> Base<BaseJob> {","counters":[]},{"line":"        pub fn map<F: Fn(&BaseJob) -> BaseJob>(&self, fun: F) -> Self {","counters":[]},{"line":"            Self {","counters":[]},{"line":"                weight: self.weight.clone(),","counters":[]},{"line":"                job: self.job.map(fun),","counters":[]},{"line":"            }","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        pub fn with_seq_no(&self, no: SequenceNumber) -> Self {","counters":[{"col_start":8,"col_end":63,"count":0}]},{"line":"            Self {","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"                weight: self.weight.clone(),","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"                job: match &self.job {","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"                    Job::Full(record) => Job::Full(record.with_seq_no(no)),","counters":[{"col_start":30,"col_end":74,"count":0}]},{"line":"                    x => x.clone(),","counters":[{"col_start":20,"col_end":34,"count":0}]},{"line":"                },","counters":[]},{"line":"            }","counters":[]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"/// For merge proofs: Merging two base proofs or two merge proofs","counters":[]},{"line":"pub mod merge {","counters":[]},{"line":"    use super::*;","counters":[]},{"line":"","counters":[]},{"line":"    #[derive(Clone)]","counters":[{"col_start":13,"col_end":18,"count":0}]},{"line":"    pub struct Record<MergeJob> {","counters":[]},{"line":"        pub left: MergeJob,","counters":[]},{"line":"        pub right: MergeJob,","counters":[]},{"line":"        pub seq_no: SequenceNumber,","counters":[]},{"line":"        pub state: JobStatus,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl<MergeJob> Debug for Record<MergeJob> {","counters":[]},{"line":"        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {","counters":[{"col_start":8,"col_end":76,"count":0}]},{"line":"            let Self {","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"                left: _,","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"                right: _,","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"                seq_no,","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"                state,","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"            } = self;","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"            f.write_fmt(format_args!(\"seq_no: {:?}, state: {:?}\", seq_no, state))","counters":[{"col_start":0,"col_end":81,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl<MergeJob: Clone> Record<MergeJob> {","counters":[]},{"line":"        pub fn with_seq_no(&self, no: SequenceNumber) -> Self {","counters":[{"col_start":8,"col_end":63,"count":0}]},{"line":"            Self {","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"                seq_no: no,","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"                left: self.left.clone(),","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"                right: self.right.clone(),","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"                state: self.state.clone(),","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    #[derive(Clone)]","counters":[{"col_start":13,"col_end":14,"count":0},{"col_start":17,"col_end":18,"count":0}]},{"line":"    pub enum Job<MergeJob> {","counters":[]},{"line":"        Empty,","counters":[]},{"line":"        Part(MergeJob), // left","counters":[]},{"line":"        Full(Record<MergeJob>),","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl<MergeJob> Debug for Job<MergeJob> {","counters":[]},{"line":"        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {","counters":[{"col_start":8,"col_end":76,"count":0}]},{"line":"            match self {","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"                Self::Empty => write!(f, \"Empty\"),","counters":[{"col_start":16,"col_end":49,"count":0}]},{"line":"                Self::Part(_) => write!(f, \"Part(merge)\"),","counters":[{"col_start":16,"col_end":57,"count":0}]},{"line":"                Self::Full(arg0) => f.write_fmt(format_args!(\"Full {{ {:?} }}\", arg0)),","counters":[{"col_start":16,"col_end":86,"count":0}]},{"line":"            }","counters":[]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    #[derive(Clone, Debug)]","counters":[{"col_start":13,"col_end":18,"count":0}]},{"line":"    pub struct Merge<MergeJob> {","counters":[]},{"line":"        pub weight: (Weight, Weight),","counters":[]},{"line":"        pub job: Job<MergeJob>,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl<MergeJob> Record<MergeJob> {","counters":[]},{"line":"        pub fn map<F: Fn(&MergeJob) -> MergeJob>(&self, fun: F) -> Self {","counters":[]},{"line":"            Self {","counters":[]},{"line":"                left: fun(&self.left),","counters":[]},{"line":"                right: fun(&self.right),","counters":[]},{"line":"                seq_no: self.seq_no.clone(),","counters":[]},{"line":"                state: self.state.clone(),","counters":[]},{"line":"            }","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl<MergeJob> Job<MergeJob> {","counters":[]},{"line":"        pub fn map<F: Fn(&MergeJob) -> MergeJob>(&self, fun: F) -> Self {","counters":[]},{"line":"            match self {","counters":[]},{"line":"                Job::Empty => Self::Empty,","counters":[]},{"line":"                Job::Part(j) => Job::Part(fun(j)),","counters":[]},{"line":"                Job::Full(r) => Job::Full(r.map(fun)),","counters":[]},{"line":"            }","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl<MergeJob: Clone> Merge<MergeJob> {","counters":[]},{"line":"        pub fn map<F: Fn(&MergeJob) -> MergeJob>(&self, fun: F) -> Self {","counters":[]},{"line":"            Self {","counters":[]},{"line":"                weight: self.weight.clone(),","counters":[]},{"line":"                job: self.job.map(fun),","counters":[]},{"line":"            }","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        pub fn with_seq_no(&self, no: SequenceNumber) -> Self {","counters":[{"col_start":8,"col_end":63,"count":0}]},{"line":"            Self {","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"                weight: self.weight.clone(),","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"                job: match &self.job {","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"                    Job::Full(record) => Job::Full(record.with_seq_no(no)),","counters":[{"col_start":30,"col_end":74,"count":0}]},{"line":"                    x => x.clone(),","counters":[{"col_start":20,"col_end":34,"count":0}]},{"line":"                },","counters":[]},{"line":"            }","counters":[]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"/// All the jobs on a tree that can be done. Base.Full and Merge.Full","counters":[]},{"line":"#[derive(Clone, Debug)]","counters":[{"col_start":9,"col_end":10,"count":0},{"col_start":13,"col_end":14,"count":0}]},{"line":"pub enum AvailableJob<BaseJob, MergeJob> {","counters":[]},{"line":"    Base(BaseJob),","counters":[]},{"line":"    Merge { left: MergeJob, right: MergeJob },","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"/// New jobs to be added (including new transactions or new merge jobs)","counters":[]},{"line":"#[derive(Clone, Debug)]","counters":[]},{"line":"enum Job<BaseJob, MergeJob> {","counters":[]},{"line":"    Base(BaseJob),","counters":[]},{"line":"    Merge(MergeJob),","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"/// Space available and number of jobs required to enqueue data.","counters":[]},{"line":"/// first = space on the current tree and number of jobs required","counters":[]},{"line":"/// to be completed","counters":[]},{"line":"/// second = If the current-tree space is less than <max_base_jobs>","counters":[]},{"line":"/// then remaining number of slots on a new tree and the corresponding","counters":[]},{"line":"/// job count.","counters":[]},{"line":"#[derive(Clone)]","counters":[]},{"line":"pub struct SpacePartition {","counters":[]},{"line":"    pub first: (u64, u64),","counters":[]},{"line":"    pub second: Option<(u64, u64)>,","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Debug for SpacePartition {","counters":[]},{"line":"    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {","counters":[{"col_start":4,"col_end":72,"count":0}]},{"line":"        struct Detail {","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"            space_available: u64,","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"            njobs_to_be_completed: u64,","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        impl Debug for Detail {","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {","counters":[{"col_start":0,"col_end":80,"count":0}]},{"line":"                f.write_fmt(format_args!(","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"                    \"space_available: {}, njobs_to_be_completed={}\",","counters":[{"col_start":0,"col_end":68,"count":0}]},{"line":"                    self.space_available, self.njobs_to_be_completed","counters":[{"col_start":0,"col_end":68,"count":0}]},{"line":"                ))","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        f.debug_struct(\"SpacePartition\")","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"            .field(","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"                \"first(current_tree)\",","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"                &Detail {","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"                    space_available: self.first.0,","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"                    njobs_to_be_completed: self.first.1,","counters":[{"col_start":0,"col_end":56,"count":0}]},{"line":"                },","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"            )","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"            .field(","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"                \"second(next_tree)\",","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"                &self.second.map(|second| Detail {","counters":[{"col_start":0,"col_end":33,"count":0},{"col_start":42,"col_end":50,"count":0}]},{"line":"                    space_available: second.0,","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"                    njobs_to_be_completed: second.1,","counters":[{"col_start":0,"col_end":52,"count":0}]},{"line":"                }),","counters":[{"col_start":0,"col_end":17,"count":0},{"col_start":17,"col_end":19,"count":0}]},{"line":"            )","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"            .finish()","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"trait WithVTable<T>: Debug {","counters":[]},{"line":"    fn by_ref(&self) -> &T;","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl<T: Debug> WithVTable<T> for T {","counters":[]},{"line":"    fn by_ref(&self) -> &Self {","counters":[]},{"line":"        self","counters":[]},{"line":"    }","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"#[derive(Clone, Debug)]","counters":[{"col_start":9,"col_end":10,"count":0},{"col_start":13,"col_end":14,"count":0}]},{"line":"enum Value<B, M> {","counters":[]},{"line":"    Leaf(B),","counters":[]},{"line":"    Node(M),","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"/// A single tree with number of leaves = max_base_jobs = 2**transaction_capacity_log_2","counters":[]},{"line":"#[derive(Clone)]","counters":[{"col_start":9,"col_end":14,"count":0}]},{"line":"pub struct Tree<B, M> {","counters":[]},{"line":"    values: Vec<Value<B, M>>,","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl<B, M> Debug for Tree<base::Base<B>, merge::Merge<M>>","counters":[]},{"line":"where","counters":[]},{"line":"    B: Debug,","counters":[]},{"line":"    M: Debug,","counters":[]},{"line":"{","counters":[]},{"line":"    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {","counters":[]},{"line":"        enum BaseOrMerge<'a, B, M> {","counters":[]},{"line":"            Base(&'a base::Base<B>),","counters":[]},{"line":"            Merge(&'a merge::Merge<M>),","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        impl<'a, B, M> Debug for BaseOrMerge<'a, B, M>","counters":[]},{"line":"        where","counters":[]},{"line":"            B: Debug,","counters":[]},{"line":"            M: Debug,","counters":[]},{"line":"        {","counters":[]},{"line":"            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {","counters":[]},{"line":"                match self {","counters":[]},{"line":"                    Self::Base(arg0) => write!(f, \"{:?}\", arg0),","counters":[]},{"line":"                    Self::Merge(arg0) => write!(f, \"{:?}\", arg0),","counters":[]},{"line":"                }","counters":[]},{"line":"            }","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        let mut by_depth = BTreeMap::<usize, Vec<_>>::default();","counters":[]},{"line":"","counters":[]},{"line":"        for (index, v) in self.values.iter().enumerate() {","counters":[]},{"line":"            let vec = by_depth.entry(btree::depth_at(index) as usize).or_default();","counters":[]},{"line":"            let v = match v {","counters":[]},{"line":"                Value::Leaf(b) => BaseOrMerge::Base(b),","counters":[]},{"line":"                Value::Node(m) => BaseOrMerge::Merge(m),","counters":[]},{"line":"            };","counters":[]},{"line":"            vec.push(v);","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        for (depth, values) in by_depth.iter() {","counters":[]},{"line":"            writeln!(f, \"depth={} {:#?}\", depth, values)?;","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        Ok(())","counters":[]},{"line":"    }","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"mod btree {","counters":[]},{"line":"    // https://stackoverflow.com/a/31147495/5717561","counters":[]},{"line":"    pub fn depth_at(index: usize) -> u64 {","counters":[{"col_start":4,"col_end":42,"count":0}]},{"line":"        // Get the depth from its index (in the array)","counters":[{"col_start":0,"col_end":54,"count":0}]},{"line":"        // TODO: Find if there is a faster way to get that","counters":[{"col_start":0,"col_end":58,"count":0}]},{"line":"        let depth = ((index + 1) as f32).log2().floor() as u32;","counters":[{"col_start":0,"col_end":63,"count":0}]},{"line":"        depth as u64","counters":[{"col_start":0,"col_end":20,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn child_left(index: usize) -> usize {","counters":[{"col_start":4,"col_end":46,"count":0}]},{"line":"        (index * 2) + 1","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn child_right(index: usize) -> usize {","counters":[{"col_start":4,"col_end":47,"count":0}]},{"line":"        (index * 2) + 2","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn parent(index: usize) -> Option<usize> {","counters":[]},{"line":"        Some(index.checked_sub(1)? / 2)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    pub fn range_at_depth(depth: u64) -> std::ops::Range<usize> {","counters":[]},{"line":"        if depth == 0 {","counters":[]},{"line":"            return 0..1;","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        let start = (1 << depth) - 1;","counters":[]},{"line":"        let end = (1 << (depth + 1)) - 1;","counters":[]},{"line":"","counters":[]},{"line":"        start..end","counters":[]},{"line":"    }","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl<B, M> Tree<B, M>","counters":[]},{"line":"where","counters":[]},{"line":"    B: Debug + 'static,","counters":[]},{"line":"    M: Debug + 'static,","counters":[]},{"line":"{","counters":[]},{"line":"    /// mapi where i is the level of the tree","counters":[]},{"line":"    fn map_depth<FunMerge, FunBase>(&self, fun_merge: &FunMerge, fun_base: &FunBase) -> Self","counters":[{"col_start":4,"col_end":92,"count":0}]},{"line":"    where","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"        FunMerge: for<'a> Fn(u64, &'a M) -> M,","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"        FunBase: for<'a> Fn(&'a B) -> B,","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"    {","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"        let values = self","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"            .values","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"            .iter()","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"            .enumerate()","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"            .map(|(index, value)| match value {","counters":[{"col_start":0,"col_end":17,"count":0},{"col_start":34,"col_end":45,"count":0}]},{"line":"                Value::Leaf(base) => Value::Leaf(fun_base(base)),","counters":[{"col_start":28,"col_end":64,"count":0}]},{"line":"                Value::Node(merge) => Value::Node(fun_merge(btree::depth_at(index), merge)),","counters":[{"col_start":28,"col_end":91,"count":0}]},{"line":"            })","counters":[{"col_start":12,"col_end":13,"count":0},{"col_start":13,"col_end":14,"count":0}]},{"line":"            .collect();","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"        Self { values }","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn map<FunMerge, FunBase>(&self, fun_merge: FunMerge, fun_base: FunBase) -> Self","counters":[{"col_start":4,"col_end":84,"count":0}]},{"line":"    where","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"        FunMerge: Fn(&M) -> M,","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"        FunBase: Fn(&B) -> B,","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"    {","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"        self.map_depth(&|_, m| fun_merge(m), &fun_base)","counters":[{"col_start":0,"col_end":24,"count":0},{"col_start":31,"col_end":43,"count":0},{"col_start":43,"col_end":55,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    /// foldi where i is the cur_level","counters":[]},{"line":"    fn fold_depth_until_prime<Accum, Final, FunMerge, FunBase>(","counters":[{"col_start":4,"col_end":63,"count":0}]},{"line":"        &self,","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"        fun_merge: &FunMerge,","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"        fun_base: &FunBase,","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"        init: Accum,","counters":[{"col_start":0,"col_end":20,"count":0}]},{"line":"    ) -> ControlFlow<Final, Accum>","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"    where","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"        FunMerge: Fn(u64, Accum, &M) -> ControlFlow<Final, Accum>,","counters":[{"col_start":0,"col_end":66,"count":0}]},{"line":"        FunBase: Fn(Accum, &B) -> ControlFlow<Final, Accum>,","counters":[{"col_start":0,"col_end":60,"count":0}]},{"line":"    {","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"        let mut accum = init;","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"","counters":[]},{"line":"        for (index, value) in self.values.iter().enumerate() {","counters":[{"col_start":13,"col_end":25,"count":0},{"col_start":30,"col_end":60,"count":0},{"col_start":61,"col_end":62,"count":0}]},{"line":"            accum = match value {","counters":[{"col_start":0,"col_end":17,"count":0},{"col_start":26,"col_end":31,"count":0}]},{"line":"                Value::Leaf(base) => fun_base(accum, base)?,","counters":[{"col_start":28,"col_end":58,"count":0},{"col_start":58,"col_end":59,"count":0}]},{"line":"                Value::Node(merge) => fun_merge(btree::depth_at(index), accum, merge)?,","counters":[{"col_start":28,"col_end":85,"count":0},{"col_start":85,"col_end":86,"count":622}]},{"line":"            };","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        Continue(accum)","counters":[{"col_start":8,"col_end":23,"count":0}]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":622}]},{"line":"","counters":[]},{"line":"    /// foldi where i is the cur_level","counters":[]},{"line":"    fn fold_depth_until_prime_err<Accum, FunMerge, FunBase>(","counters":[{"col_start":4,"col_end":60,"count":0}]},{"line":"        &self,","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"        fun_merge: &FunMerge,","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"        fun_base: &FunBase,","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"        init: Accum,","counters":[{"col_start":0,"col_end":20,"count":0}]},{"line":"    ) -> Result<Accum, String>","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"    where","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"        FunMerge: Fn(u64, Accum, &M) -> Result<Accum, String>,","counters":[{"col_start":0,"col_end":62,"count":0}]},{"line":"        FunBase: Fn(Accum, &B) -> Result<Accum, String>,","counters":[{"col_start":0,"col_end":56,"count":0}]},{"line":"    {","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"        let mut accum = init;","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"","counters":[]},{"line":"        for (index, value) in self.values.iter().enumerate() {","counters":[{"col_start":13,"col_end":25,"count":0},{"col_start":30,"col_end":60,"count":0},{"col_start":61,"col_end":62,"count":-95}]},{"line":"            accum = match value {","counters":[{"col_start":0,"col_end":17,"count":-95},{"col_start":26,"col_end":31,"count":0}]},{"line":"                Value::Leaf(base) => fun_base(accum, base)?,","counters":[{"col_start":28,"col_end":58,"count":0},{"col_start":58,"col_end":59,"count":95}]},{"line":"                Value::Node(merge) => fun_merge(btree::depth_at(index), accum, merge)?,","counters":[{"col_start":28,"col_end":85,"count":0},{"col_start":85,"col_end":86,"count":0}]},{"line":"            };","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        Ok(accum)","counters":[{"col_start":8,"col_end":17,"count":2}]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":97}]},{"line":"","counters":[]},{"line":"    fn fold_depth_until<Accum, Final, FunFinish, FunMerge, FunBase>(","counters":[{"col_start":4,"col_end":68,"count":0}]},{"line":"        &self,","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"        fun_merge: FunMerge,","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"        fun_base: FunBase,","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"        fun_finish: FunFinish,","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"        init: Accum,","counters":[{"col_start":0,"col_end":20,"count":0}]},{"line":"    ) -> Final","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"    where","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"        FunMerge: Fn(u64, Accum, &M) -> ControlFlow<Final, Accum>,","counters":[{"col_start":0,"col_end":66,"count":0}]},{"line":"        FunBase: Fn(Accum, &B) -> ControlFlow<Final, Accum>,","counters":[{"col_start":0,"col_end":60,"count":0}]},{"line":"        FunFinish: Fn(Accum) -> Final,","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"    {","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"        match self.fold_depth_until_prime(&fun_merge, &fun_base, init) {","counters":[{"col_start":0,"col_end":70,"count":0}]},{"line":"            Continue(accum) => fun_finish(accum),","counters":[{"col_start":21,"col_end":48,"count":0}]},{"line":"            Break(value) => value,","counters":[{"col_start":18,"col_end":33,"count":0}]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn fold_depth<Accum, FunMerge, FunBase>(","counters":[{"col_start":4,"col_end":44,"count":0}]},{"line":"        &self,","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"        fun_merge: FunMerge,","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"        fun_base: FunBase,","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"        init: Accum,","counters":[{"col_start":0,"col_end":20,"count":0}]},{"line":"    ) -> Accum","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"    where","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"        FunMerge: Fn(u64, Accum, &M) -> Accum,","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"        FunBase: Fn(Accum, &B) -> Accum,","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"    {","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"        self.fold_depth_until(","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"            |i, accum, a| Continue(fun_merge(i, accum, a)),","counters":[{"col_start":0,"col_end":12,"count":0},{"col_start":26,"col_end":58,"count":0},{"col_start":58,"col_end":59,"count":0}]},{"line":"            |accum, d| Continue(fun_base(accum, d)),","counters":[{"col_start":0,"col_end":12,"count":0},{"col_start":23,"col_end":51,"count":268786},{"col_start":51,"col_end":52,"count":0}]},{"line":"            |x| x,","counters":[{"col_start":0,"col_end":12,"count":0},{"col_start":16,"col_end":17,"count":0},{"col_start":17,"col_end":18,"count":0}]},{"line":"            init,","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"        )","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn fold<Accum, FunMerge, FunBase>(","counters":[{"col_start":4,"col_end":38,"count":0}]},{"line":"        &self,","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"        fun_merge: FunMerge,","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"        fun_base: FunBase,","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"        init: Accum,","counters":[{"col_start":0,"col_end":20,"count":0}]},{"line":"    ) -> Accum","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"    where","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"        FunMerge: Fn(Accum, &M) -> Accum,","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"        FunBase: Fn(Accum, &B) -> Accum,","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"    {","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"        self.fold_depth(|_, accum, a| fun_merge(accum, a), fun_base, init)","counters":[{"col_start":0,"col_end":24,"count":0},{"col_start":38,"col_end":57,"count":0},{"col_start":57,"col_end":74,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn fold_until<Accum, Final, FunFinish, FunMerge, FunBase>(","counters":[]},{"line":"        &self,","counters":[]},{"line":"        fun_merge: FunMerge,","counters":[]},{"line":"        fun_base: FunBase,","counters":[]},{"line":"        fun_finish: FunFinish,","counters":[]},{"line":"        init: Accum,","counters":[]},{"line":"    ) -> Final","counters":[]},{"line":"    where","counters":[]},{"line":"        FunMerge: Fn(Accum, &M) -> ControlFlow<Final, Accum>,","counters":[]},{"line":"        FunBase: Fn(Accum, &B) -> ControlFlow<Final, Accum>,","counters":[]},{"line":"        FunFinish: Fn(Accum) -> Final,","counters":[]},{"line":"    {","counters":[]},{"line":"        self.fold_depth_until(","counters":[]},{"line":"            |_, accum, a| fun_merge(accum, a),","counters":[]},{"line":"            fun_base,","counters":[]},{"line":"            fun_finish,","counters":[]},{"line":"            init,","counters":[]},{"line":"        )","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn update_split<Data, FunJobs, FunWeight, FunMerge, FunBase, Weight, R>(","counters":[{"col_start":4,"col_end":76,"count":268786}]},{"line":"        &self,","counters":[{"col_start":0,"col_end":14,"count":268786}]},{"line":"        fun_merge: &FunMerge,","counters":[{"col_start":0,"col_end":29,"count":268786}]},{"line":"        fun_base: &FunBase,","counters":[{"col_start":0,"col_end":27,"count":268786}]},{"line":"        weight_merge: &FunWeight,","counters":[{"col_start":0,"col_end":33,"count":268786}]},{"line":"        jobs: &[Data],","counters":[{"col_start":0,"col_end":22,"count":268786}]},{"line":"        update_level: u64,","counters":[{"col_start":0,"col_end":26,"count":268786}]},{"line":"        jobs_split: &FunJobs,","counters":[{"col_start":0,"col_end":29,"count":268786}]},{"line":"    ) -> Result<(Self, Option<R>), ()>","counters":[{"col_start":0,"col_end":38,"count":268786}]},{"line":"    where","counters":[{"col_start":0,"col_end":9,"count":268786}]},{"line":"        FunMerge: Fn(&[Data], u64, M) -> Result<(M, Option<R>), ()>,","counters":[{"col_start":0,"col_end":68,"count":268786}]},{"line":"        FunBase: Fn(&[Data], B) -> Result<B, ()>,","counters":[{"col_start":0,"col_end":49,"count":268786}]},{"line":"        FunWeight: Fn(&M) -> (Weight, Weight),","counters":[{"col_start":0,"col_end":46,"count":268786}]},{"line":"        FunJobs: Fn((Weight, Weight), &[Data]) -> (&[Data], &[Data]),","counters":[{"col_start":0,"col_end":69,"count":268786}]},{"line":"        Data: Clone,","counters":[{"col_start":0,"col_end":20,"count":268786}]},{"line":"        M: Clone,","counters":[{"col_start":0,"col_end":17,"count":268786}]},{"line":"        B: Clone,","counters":[{"col_start":0,"col_end":17,"count":268786}]},{"line":"    {","counters":[{"col_start":0,"col_end":5,"count":268786}]},{"line":"        let mut values = Vec::with_capacity(self.values.len());","counters":[{"col_start":0,"col_end":63,"count":268786}]},{"line":"        let mut scan_result = None;","counters":[{"col_start":0,"col_end":35,"count":268786}]},{"line":"","counters":[]},{"line":"        // Because our tree is a perfect binary tree, two values pushed","counters":[{"col_start":0,"col_end":71,"count":268786}]},{"line":"        // at the back of `jobs_fifo` by a node will be popped by its","counters":[{"col_start":0,"col_end":69,"count":268786}]},{"line":"        // left and right children, respectively","counters":[{"col_start":0,"col_end":48,"count":268786}]},{"line":"        let mut jobs_fifo = VecDeque::with_capacity(self.values.len());","counters":[{"col_start":0,"col_end":71,"count":268786}]},{"line":"","counters":[]},{"line":"        jobs_fifo.push_back(jobs);","counters":[{"col_start":0,"col_end":33,"count":268786}]},{"line":"","counters":[]},{"line":"        for (index, value) in self.values.iter().enumerate() {","counters":[{"col_start":13,"col_end":25,"count":0},{"col_start":30,"col_end":60,"count":268786}]},{"line":"            let depth = btree::depth_at(index);","counters":[{"col_start":16,"col_end":47,"count":0}]},{"line":"","counters":[]},{"line":"            if depth > update_level {","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"                values.push(value.clone());","counters":[{"col_start":16,"col_end":43,"count":0}]},{"line":"                continue;","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"            }","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"            let jobs_for_this = jobs_fifo.pop_front().unwrap();","counters":[{"col_start":0,"col_end":62,"count":0}]},{"line":"","counters":[]},{"line":"            let value = match value {","counters":[{"col_start":16,"col_end":21,"count":0},{"col_start":30,"col_end":35,"count":0}]},{"line":"                Value::Leaf(base) => Value::Leaf(fun_base(jobs_for_this, base.clone())?),","counters":[{"col_start":28,"col_end":86,"count":0},{"col_start":86,"col_end":87,"count":0}]},{"line":"                Value::Node(merge) => {","counters":[{"col_start":28,"col_end":39,"count":0}]},{"line":"                    let (jobs_left, jobs_right) = jobs_split(weight_merge(merge), jobs_for_this);","counters":[{"col_start":0,"col_end":97,"count":0}]},{"line":"                    jobs_fifo.push_back(jobs_left);","counters":[{"col_start":0,"col_end":51,"count":0}]},{"line":"                    jobs_fifo.push_back(jobs_right);","counters":[{"col_start":0,"col_end":51,"count":0}]},{"line":"","counters":[]},{"line":"                    let (value, result) = fun_merge(jobs_for_this, depth, merge.clone())?;","counters":[{"col_start":25,"col_end":38,"count":0},{"col_start":42,"col_end":88,"count":0},{"col_start":88,"col_end":89,"count":0}]},{"line":"","counters":[]},{"line":"                    if scan_result.is_none() {","counters":[{"col_start":23,"col_end":44,"count":0},{"col_start":45,"col_end":46,"count":0}]},{"line":"                        scan_result = Some(result);","counters":[{"col_start":0,"col_end":51,"count":0}]},{"line":"                    }","counters":[{"col_start":0,"col_end":21,"count":0},{"col_start":21,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"                    Value::Node(value)","counters":[{"col_start":20,"col_end":38,"count":0}]},{"line":"                }","counters":[]},{"line":"            };","counters":[]},{"line":"","counters":[]},{"line":"            values.push(value);","counters":[{"col_start":12,"col_end":30,"count":0}]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        assert_eq!(jobs_fifo.capacity(), self.values.len());","counters":[{"col_start":8,"col_end":59,"count":0}]},{"line":"","counters":[]},{"line":"        Ok(((Self { values }), scan_result.flatten()))","counters":[{"col_start":8,"col_end":54,"count":0}]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn update_accumulate<Data, FunMerge, FunBase>(","counters":[{"col_start":4,"col_end":50,"count":0}]},{"line":"        &self,","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"        fun_merge: &FunMerge,","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"        fun_base: &FunBase,","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"    ) -> (Self, Data)","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"    where","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"        FunMerge: Fn((Data, Data), &M) -> (M, Data),","counters":[{"col_start":0,"col_end":52,"count":0}]},{"line":"        FunBase: Fn(&B) -> (B, Data),","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"        Data: Clone,","counters":[{"col_start":0,"col_end":20,"count":0}]},{"line":"    {","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"        let mut datas = vec![None; self.values.len()];","counters":[{"col_start":0,"col_end":54,"count":0}]},{"line":"","counters":[]},{"line":"        let childs_of = |data: &mut [Option<Data>], index: usize| -> Option<(Data, Data)> {","counters":[{"col_start":0,"col_end":21,"count":0},{"col_start":90,"col_end":91,"count":0}]},{"line":"            let left = data","counters":[{"col_start":16,"col_end":20,"count":0},{"col_start":23,"col_end":27,"count":0}]},{"line":"                .get_mut(btree::child_left(index))","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"                .and_then(Option::take)?;","counters":[{"col_start":0,"col_end":39,"count":0},{"col_start":39,"col_end":40,"count":0}]},{"line":"            let right = data","counters":[{"col_start":16,"col_end":21,"count":0},{"col_start":24,"col_end":28,"count":0}]},{"line":"                .get_mut(btree::child_right(index))","counters":[{"col_start":0,"col_end":51,"count":0}]},{"line":"                .and_then(Option::take)?;","counters":[{"col_start":0,"col_end":39,"count":0},{"col_start":39,"col_end":40,"count":10}]},{"line":"","counters":[]},{"line":"            Some((left, right))","counters":[{"col_start":12,"col_end":31,"count":0}]},{"line":"        };","counters":[{"col_start":8,"col_end":9,"count":10}]},{"line":"","counters":[]},{"line":"        let mut values: Vec<_> = self","counters":[{"col_start":12,"col_end":37,"count":0}]},{"line":"            .values","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"            .iter()","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"            .enumerate()","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"            .rev()","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"            .map(|(index, value)| match value {","counters":[{"col_start":0,"col_end":17,"count":0},{"col_start":34,"col_end":45,"count":0}]},{"line":"                Value::Leaf(base) => {","counters":[{"col_start":28,"col_end":38,"count":0}]},{"line":"                    let (new_base, count_list) = fun_base(base);","counters":[{"col_start":0,"col_end":64,"count":0}]},{"line":"                    datas[index] = Some(count_list);","counters":[{"col_start":0,"col_end":52,"count":0}]},{"line":"                    Value::Leaf(new_base)","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"                }","counters":[]},{"line":"                Value::Node(merge) => {","counters":[{"col_start":28,"col_end":39,"count":0}]},{"line":"                    let (left, right) = childs_of(datas.as_mut(), index).unwrap();","counters":[{"col_start":0,"col_end":82,"count":0}]},{"line":"                    let (value, count_list) = fun_merge((left, right), merge);","counters":[{"col_start":0,"col_end":78,"count":0}]},{"line":"                    datas[index] = Some(count_list);","counters":[{"col_start":0,"col_end":52,"count":0}]},{"line":"                    Value::Node(value)","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"                }","counters":[]},{"line":"            })","counters":[{"col_start":12,"col_end":13,"count":0},{"col_start":13,"col_end":14,"count":0}]},{"line":"            .collect();","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"        values.reverse();","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"        (Self { values }, datas[0].take().unwrap())","counters":[{"col_start":0,"col_end":51,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn iter(&self) -> impl Iterator<Item = (u64, &Value<B, M>)> {","counters":[]},{"line":"        self.values","counters":[]},{"line":"            .iter()","counters":[]},{"line":"            .enumerate()","counters":[]},{"line":"            .map(|(index, value)| (btree::depth_at(index), value))","counters":[]},{"line":"    }","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"#[derive(Clone, Debug)]","counters":[{"col_start":9,"col_end":14,"count":0}]},{"line":"pub struct ParallelScan<BaseJob, MergeJob> {","counters":[]},{"line":"    pub trees: Vec<Tree<base::Base<BaseJob>, merge::Merge<MergeJob>>>,","counters":[]},{"line":"    /// last emitted proof and the corresponding transactions","counters":[]},{"line":"    acc: Option<(MergeJob, Vec<BaseJob>)>,","counters":[]},{"line":"    /// Sequence number for the jobs added every block","counters":[]},{"line":"    pub curr_job_seq_no: SequenceNumber,","counters":[]},{"line":"    /// transaction_capacity_log_2","counters":[]},{"line":"    max_base_jobs: u64,","counters":[]},{"line":"    delay: u64,","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"pub(super) enum ResetKind {","counters":[]},{"line":"    Base,","counters":[]},{"line":"    Merge,","counters":[]},{"line":"    Both,","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl<BaseJob, MergeJob> Tree<base::Base<BaseJob>, merge::Merge<MergeJob>>","counters":[]},{"line":"where","counters":[]},{"line":"    BaseJob: Clone + Debug + 'static,","counters":[]},{"line":"    MergeJob: Clone + Debug + 'static,","counters":[]},{"line":"{","counters":[]},{"line":"    fn update(","counters":[{"col_start":4,"col_end":14,"count":0}]},{"line":"        &self,","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"        completed_jobs: &[Job<BaseJob, MergeJob>],","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"        update_level: u64,","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"        sequence_no: SequenceNumber,","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"        lens: WeightLens,","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"    ) -> Result<(Self, Option<MergeJob>), ()> {","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"        let add_merges = |jobs: &[Job<BaseJob, MergeJob>],","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"                          current_level: u64,","counters":[]},{"line":"                          merge_job: merge::Merge<MergeJob>|","counters":[]},{"line":"         -> Result<(merge::Merge<MergeJob>, Option<MergeJob>), ()> {","counters":[{"col_start":67,"col_end":68,"count":0}]},{"line":"            use merge::{","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"                Job::{Empty, Full, Part},","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"                Record,","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"            };","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"            use Job::{Base, Merge};","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"            let weight = merge_job.weight;","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"            let m = merge_job.job;","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"","counters":[]},{"line":"            let (w1, w2) = &weight;","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"            let (left, right) = (*lens.get(w1), *lens.get(w2));","counters":[{"col_start":0,"col_end":63,"count":0}]},{"line":"","counters":[]},{"line":"            // println!(\"current_level={} update_level={}\", current_level, update_level);","counters":[{"col_start":0,"col_end":89,"count":0}]},{"line":"            if update_level > 0 && current_level == update_level - 1 {","counters":[{"col_start":0,"col_end":31,"count":0},{"col_start":35,"col_end":68,"count":0}]},{"line":"                // Create new jobs from the completed ones","counters":[]},{"line":"                let (new_weight, new_m) = match (&jobs[..], m) {","counters":[{"col_start":21,"col_end":38,"count":38},{"col_start":49,"col_end":64,"count":0}]},{"line":"                    ([], m) => (weight, m),","counters":[{"col_start":0,"col_end":23,"count":0},{"col_start":25,"col_end":42,"count":0}]},{"line":"                    ([Merge(a), Merge(b)], Empty) => {","counters":[{"col_start":28,"col_end":54,"count":0}]},{"line":"                        let w1 = lens.set(w1, left - 1);","counters":[{"col_start":0,"col_end":56,"count":0}]},{"line":"                        let w2 = lens.set(w2, right - 1);","counters":[{"col_start":0,"col_end":57,"count":0}]},{"line":"","counters":[]},{"line":"                        (","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"                            (w1, w2),","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"                            Full(Record {","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"                                left: a.clone(),","counters":[{"col_start":0,"col_end":48,"count":0}]},{"line":"                                right: b.clone(),","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"                                seq_no: sequence_no.clone(),","counters":[{"col_start":0,"col_end":60,"count":0}]},{"line":"                                state: JobStatus::Todo,","counters":[{"col_start":0,"col_end":55,"count":0}]},{"line":"                            }),","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"                        )","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"                    }","counters":[]},{"line":"                    ([Merge(a)], Empty) => {","counters":[{"col_start":28,"col_end":44,"count":0}]},{"line":"                        let w1 = lens.set(w1, left - 1);","counters":[{"col_start":0,"col_end":56,"count":0}]},{"line":"                        let w2 = lens.set(w2, right);","counters":[{"col_start":0,"col_end":53,"count":0}]},{"line":"","counters":[]},{"line":"                        ((w1, w2), Part(a.clone()))","counters":[{"col_start":0,"col_end":51,"count":0}]},{"line":"                    }","counters":[]},{"line":"                    ([Merge(b)], Part(a)) => {","counters":[{"col_start":28,"col_end":46,"count":0}]},{"line":"                        let w1 = lens.set(w1, left);","counters":[{"col_start":0,"col_end":52,"count":0}]},{"line":"                        let w2 = lens.set(w2, right - 1);","counters":[{"col_start":0,"col_end":57,"count":0}]},{"line":"","counters":[]},{"line":"                        (","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"                            (w1, w2),","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"                            Full(Record {","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"                                left: a.clone(),","counters":[{"col_start":0,"col_end":48,"count":0}]},{"line":"                                right: b.clone(),","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"                                seq_no: sequence_no.clone(),","counters":[{"col_start":0,"col_end":60,"count":0}]},{"line":"                                state: JobStatus::Todo,","counters":[{"col_start":0,"col_end":55,"count":0}]},{"line":"                            }),","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"                        )","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"                    }","counters":[]},{"line":"                    ([Base(_)], Empty) => {","counters":[]},{"line":"                        // Depending on whether this is the first or second of the two base jobs","counters":[]},{"line":"","counters":[]},{"line":"                        let weight = if left == 0 {","counters":[{"col_start":28,"col_end":34,"count":38},{"col_start":40,"col_end":49,"count":0}]},{"line":"                            let w1 = lens.set(w1, left);","counters":[{"col_start":32,"col_end":56,"count":0}]},{"line":"                            let w2 = lens.set(w2, right - 1);","counters":[{"col_start":0,"col_end":61,"count":0}]},{"line":"                            (w1, w2)","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"                        } else {","counters":[]},{"line":"                            let w1 = lens.set(w1, left - 1);","counters":[{"col_start":32,"col_end":60,"count":38}]},{"line":"                            let w2 = lens.set(w2, right);","counters":[{"col_start":0,"col_end":57,"count":38}]},{"line":"                            (w1, w2)","counters":[{"col_start":0,"col_end":36,"count":38}]},{"line":"                        };","counters":[]},{"line":"","counters":[]},{"line":"                        (weight, Empty)","counters":[{"col_start":24,"col_end":39,"count":38}]},{"line":"                    }","counters":[]},{"line":"                    ([Base(_), Base(_)], Empty) => {","counters":[]},{"line":"                        let w1 = lens.set(w1, left - 1);","counters":[{"col_start":28,"col_end":56,"count":0}]},{"line":"                        let w2 = lens.set(w2, right - 1);","counters":[{"col_start":0,"col_end":57,"count":0}]},{"line":"","counters":[]},{"line":"                        ((w1, w2), Empty)","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"                    }","counters":[]},{"line":"                    (xs, m) => {","counters":[{"col_start":21,"col_end":32,"count":0}]},{"line":"                        panic!(","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"                            \"Got {} jobs when updating level {} and when one of the merge \\","counters":[{"col_start":0,"col_end":91,"count":0}]},{"line":"                             nodes at level {} is {:?}\",","counters":[{"col_start":0,"col_end":56,"count":0}]},{"line":"                            xs.len(),","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"                            update_level,","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"                            current_level,","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"                            m","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"                        );","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"                    }","counters":[]},{"line":"                };","counters":[]},{"line":"","counters":[]},{"line":"                Ok((","counters":[{"col_start":16,"col_end":20,"count":38}]},{"line":"                    merge::Merge {","counters":[{"col_start":0,"col_end":34,"count":38}]},{"line":"                        weight: new_weight,","counters":[{"col_start":0,"col_end":43,"count":38}]},{"line":"                        job: new_m,","counters":[{"col_start":0,"col_end":35,"count":38}]},{"line":"                    },","counters":[{"col_start":0,"col_end":22,"count":38}]},{"line":"                    None::<MergeJob>,","counters":[{"col_start":0,"col_end":37,"count":38}]},{"line":"                ))","counters":[{"col_start":0,"col_end":18,"count":38}]},{"line":"            } else if current_level == update_level {","counters":[{"col_start":22,"col_end":51,"count":0}]},{"line":"                // Mark completed jobs as Done","counters":[]},{"line":"","counters":[]},{"line":"                match (jobs, m) {","counters":[{"col_start":23,"col_end":30,"count":0}]},{"line":"                    (","counters":[]},{"line":"                        [Merge(a)],","counters":[{"col_start":31,"col_end":35,"count":0}]},{"line":"                        Full(","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"                            mut x @ Record {","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"                                state: JobStatus::Todo,","counters":[{"col_start":0,"col_end":55,"count":0}]},{"line":"                                ..","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"                            },","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"                        ),","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"                    ) => {","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"                        x.state = JobStatus::Done;","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"                        let new_job = Full(x);","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"","counters":[]},{"line":"                        let (scan_result, weight) = if current_level == 0 {","counters":[{"col_start":29,"col_end":48,"count":0},{"col_start":55,"col_end":73,"count":0}]},{"line":"                            let w1 = lens.set(w1, 0);","counters":[{"col_start":32,"col_end":53,"count":0}]},{"line":"                            let w2 = lens.set(w2, 0);","counters":[{"col_start":0,"col_end":53,"count":0}]},{"line":"","counters":[]},{"line":"                            (Some(a.clone()), (w1, w2))","counters":[{"col_start":0,"col_end":55,"count":0}]},{"line":"                        } else {","counters":[]},{"line":"                            (None, weight)","counters":[{"col_start":28,"col_end":42,"count":0}]},{"line":"                        };","counters":[]},{"line":"","counters":[]},{"line":"                        Ok((","counters":[{"col_start":24,"col_end":28,"count":0}]},{"line":"                            merge::Merge {","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"                                weight,","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"                                job: new_job,","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"                            },","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"                            scan_result,","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"                        ))","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"                    }","counters":[]},{"line":"                    ([], m) => Ok((merge::Merge { weight, job: m }, None)),","counters":[{"col_start":21,"col_end":23,"count":0},{"col_start":25,"col_end":74,"count":0}]},{"line":"                    // ([], m) => Ok(((weight, m), None)),","counters":[]},{"line":"                    (xs, m) => {","counters":[{"col_start":21,"col_end":32,"count":0}]},{"line":"                        panic!(","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"                            \"Got {} jobs when updating level {} and when one of the merge \\","counters":[{"col_start":0,"col_end":91,"count":0}]},{"line":"                             nodes at level {} is {:?}\",","counters":[{"col_start":0,"col_end":56,"count":0}]},{"line":"                            xs.len(),","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"                            update_level,","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"                            current_level,","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"                            m","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"                        );","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"                    }","counters":[]},{"line":"                }","counters":[]},{"line":"            } else if update_level > 0 && (current_level < update_level - 1) {","counters":[{"col_start":22,"col_end":38,"count":0},{"col_start":42,"col_end":76,"count":0}]},{"line":"                // Update the job count for all the level above","counters":[]},{"line":"                match jobs {","counters":[{"col_start":22,"col_end":28,"count":0}]},{"line":"                    [] => Ok((merge::Merge { weight, job: m }, None)),","counters":[{"col_start":0,"col_end":22,"count":0},{"col_start":26,"col_end":69,"count":0}]},{"line":"                    _ => {","counters":[]},{"line":"                        let jobs_length = jobs.len() as u64;","counters":[{"col_start":28,"col_end":60,"count":0}]},{"line":"                        let jobs_sent_left = jobs_length.min(left);","counters":[{"col_start":0,"col_end":67,"count":0}]},{"line":"                        let jobs_sent_right = (jobs_length - jobs_sent_left).min(right);","counters":[{"col_start":0,"col_end":88,"count":0}]},{"line":"","counters":[]},{"line":"                        let w1 = lens.set(w1, left - jobs_sent_left);","counters":[{"col_start":0,"col_end":69,"count":0}]},{"line":"                        let w2 = lens.set(w2, right - jobs_sent_right);","counters":[{"col_start":0,"col_end":71,"count":0}]},{"line":"                        let weight = (w1, w2);","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"","counters":[]},{"line":"                        Ok((merge::Merge { weight, job: m }, None))","counters":[{"col_start":0,"col_end":67,"count":0}]},{"line":"                    }","counters":[]},{"line":"                }","counters":[]},{"line":"            } else {","counters":[]},{"line":"                Ok((merge::Merge { weight, job: m }, None))","counters":[{"col_start":16,"col_end":59,"count":0}]},{"line":"            }","counters":[]},{"line":"        };","counters":[{"col_start":8,"col_end":9,"count":38}]},{"line":"","counters":[]},{"line":"        let add_bases = |jobs: &[Job<BaseJob, MergeJob>], base: base::Base<BaseJob>| {","counters":[{"col_start":12,"col_end":24,"count":0},{"col_start":85,"col_end":86,"count":0}]},{"line":"            use base::Job::{Empty, Full};","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"            use Job::{Base, Merge};","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"            let w = base.weight;","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"            let d = base.job;","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"            let weight = lens.get(&w);","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"","counters":[]},{"line":"            // println!(\"add_bases jobs={:?} w={}\", jobs.len(), weight);","counters":[{"col_start":0,"col_end":72,"count":0}]},{"line":"            match (jobs, d) {","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"                ([], d) => Ok(base::Base { weight: w, job: d }),","counters":[{"col_start":0,"col_end":19,"count":0},{"col_start":21,"col_end":63,"count":0}]},{"line":"                ([Base(d)], Empty) => {","counters":[{"col_start":23,"col_end":39,"count":0}]},{"line":"                    let w = lens.set(&w, weight - 1);","counters":[{"col_start":0,"col_end":53,"count":0}]},{"line":"","counters":[]},{"line":"                    Ok(base::Base {","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"                        weight: w,","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"                        job: Full(base::Record {","counters":[{"col_start":0,"col_end":48,"count":0}]},{"line":"                            job: d.clone(),","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"                            seq_no: sequence_no.clone(),","counters":[{"col_start":0,"col_end":56,"count":0}]},{"line":"                            state: JobStatus::Todo,","counters":[{"col_start":0,"col_end":51,"count":0}]},{"line":"                        }),","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"                    })","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"                }","counters":[]},{"line":"                ([Merge(_)], Full(mut b)) => {","counters":[{"col_start":34,"col_end":46,"count":0}]},{"line":"                    b.state = JobStatus::Done;","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"","counters":[]},{"line":"                    Ok(base::Base {","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"                        weight: w,","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"                        job: Full(b),","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"                    })","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"                }","counters":[]},{"line":"                (xs, d) => {","counters":[{"col_start":17,"col_end":28,"count":0}]},{"line":"                    panic!(","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"                        \"Got {} jobs when updating level {} and when one of the base nodes \\","counters":[{"col_start":0,"col_end":92,"count":0}]},{"line":"                         is {:?}\",","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"                        xs.len(),","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"                        update_level,","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"                        d","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"                    );","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"                }","counters":[]},{"line":"            }","counters":[]},{"line":"        };","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        self.update_split(","counters":[{"col_start":8,"col_end":26,"count":0}]},{"line":"            &add_merges,","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"            &add_bases,","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"            &|merge| merge.weight.clone(),","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"            completed_jobs,","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"            update_level,","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"            &|(w1, w2), a: &[Job<BaseJob, MergeJob>]| {","counters":[{"col_start":0,"col_end":13,"count":0},{"col_start":54,"col_end":55,"count":0}]},{"line":"                let l = *lens.get(&w1) as usize;","counters":[{"col_start":0,"col_end":48,"count":0}]},{"line":"                let r = *lens.get(&w2) as usize;","counters":[{"col_start":0,"col_end":48,"count":0}]},{"line":"","counters":[]},{"line":"                // println!(\"split l={} r={} len={}\", l, r, a.len());","counters":[{"col_start":0,"col_end":69,"count":0}]},{"line":"","counters":[]},{"line":"                (take(a, l), take_at(a, l, r))","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"            },","counters":[{"col_start":0,"col_end":13,"count":0},{"col_start":13,"col_end":14,"count":0}]},{"line":"        )","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn reset_weights(&self, reset_kind: ResetKind) -> Self {","counters":[{"col_start":4,"col_end":60,"count":0}]},{"line":"        let fun_base = |base: &base::Base<BaseJob>| {","counters":[{"col_start":0,"col_end":23,"count":0},{"col_start":52,"col_end":53,"count":0}]},{"line":"            let set_one = |lens: WeightLens, weight: &Weight| lens.set(weight, 1);","counters":[{"col_start":0,"col_end":23,"count":0},{"col_start":62,"col_end":81,"count":0}]},{"line":"            let set_zero = |lens: WeightLens, weight: &Weight| lens.set(weight, 0);","counters":[{"col_start":16,"col_end":24,"count":0},{"col_start":63,"col_end":82,"count":0}]},{"line":"","counters":[]},{"line":"            use base::{","counters":[]},{"line":"                Job::{Empty, Full},","counters":[]},{"line":"                Record,","counters":[]},{"line":"            };","counters":[]},{"line":"            use JobStatus::Todo;","counters":[]},{"line":"","counters":[]},{"line":"            let update_merge_weight = |weight: &Weight| {","counters":[{"col_start":16,"col_end":38,"count":0}]},{"line":"                // When updating the merge-weight of base nodes, only the nodes with","counters":[]},{"line":"                // \"Todo\" status needs to be included","counters":[]},{"line":"                match &base.job {","counters":[{"col_start":22,"col_end":31,"count":0}]},{"line":"                    Full(Record { state: Todo, .. }) => set_one(WeightLens::Merge, weight),","counters":[{"col_start":56,"col_end":90,"count":0}]},{"line":"                    _ => set_zero(WeightLens::Merge, weight),","counters":[{"col_start":25,"col_end":60,"count":0}]},{"line":"                }","counters":[]},{"line":"            };","counters":[{"col_start":12,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"            let update_base_weight = |weight: &Weight| {","counters":[{"col_start":16,"col_end":37,"count":0},{"col_start":55,"col_end":56,"count":0}]},{"line":"                // When updating the base-weight of base nodes, only the Empty nodes","counters":[{"col_start":0,"col_end":84,"count":0}]},{"line":"                // need to be included","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"                match &base.job {","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"                    Empty => set_one(WeightLens::Base, weight),","counters":[{"col_start":29,"col_end":62,"count":0}]},{"line":"                    Full(_) => set_zero(WeightLens::Base, weight),","counters":[{"col_start":31,"col_end":65,"count":0}]},{"line":"                }","counters":[]},{"line":"            };","counters":[{"col_start":12,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"            let weight = &base.weight;","counters":[{"col_start":16,"col_end":37,"count":0}]},{"line":"            let (new_weight, dummy_right_for_base_nodes) = match reset_kind {","counters":[{"col_start":17,"col_end":55,"count":0},{"col_start":65,"col_end":75,"count":0}]},{"line":"                ResetKind::Merge => (","counters":[{"col_start":36,"col_end":37,"count":0}]},{"line":"                    update_merge_weight(weight),","counters":[{"col_start":0,"col_end":48,"count":0}]},{"line":"                    set_zero(WeightLens::Merge, weight),","counters":[{"col_start":0,"col_end":56,"count":0}]},{"line":"                ),","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"                ResetKind::Base => (","counters":[{"col_start":35,"col_end":36,"count":0}]},{"line":"                    update_base_weight(weight),","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"                    set_zero(WeightLens::Base, weight),","counters":[{"col_start":0,"col_end":55,"count":0}]},{"line":"                ),","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"                ResetKind::Both => {","counters":[]},{"line":"                    let w = update_base_weight(weight);","counters":[{"col_start":24,"col_end":55,"count":0}]},{"line":"                    (update_merge_weight(&w), Weight::zero())","counters":[{"col_start":0,"col_end":61,"count":0}]},{"line":"                }","counters":[]},{"line":"            };","counters":[]},{"line":"","counters":[]},{"line":"            let base = base::Base {","counters":[{"col_start":16,"col_end":35,"count":0}]},{"line":"                weight: new_weight.clone(),","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"                job: base.job.clone(),","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"            };","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"","counters":[]},{"line":"            (base, (new_weight, dummy_right_for_base_nodes))","counters":[{"col_start":0,"col_end":60,"count":0}]},{"line":"        };","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        let fun_merge = |lst: ((Weight, Weight), (Weight, Weight)),","counters":[{"col_start":12,"col_end":21,"count":0}]},{"line":"                         merge: &merge::Merge<MergeJob>| {","counters":[{"col_start":57,"col_end":58,"count":0}]},{"line":"            let ((w1, w2), (w3, w4)) = &lst;","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"            let reset = |lens: WeightLens, w: &Weight, ww: &Weight| {","counters":[{"col_start":0,"col_end":24,"count":0},{"col_start":68,"col_end":69,"count":0}]},{"line":"                // Weights of all other jobs is sum of weights of its children","counters":[{"col_start":0,"col_end":78,"count":0}]},{"line":"                (","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"                    lens.set(w, lens.get(w1) + lens.get(w2)),","counters":[{"col_start":0,"col_end":61,"count":0}]},{"line":"                    lens.set(ww, lens.get(w3) + lens.get(w4)),","counters":[{"col_start":0,"col_end":62,"count":0}]},{"line":"                )","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"            };","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"            use merge::{Job::Full, Record};","counters":[]},{"line":"            use JobStatus::Todo;","counters":[]},{"line":"","counters":[]},{"line":"            let ww = match reset_kind {","counters":[{"col_start":16,"col_end":18,"count":0},{"col_start":27,"col_end":37,"count":0}]},{"line":"                ResetKind::Merge => {","counters":[]},{"line":"                    // When updating the merge-weight of merge nodes, only the nodes","counters":[]},{"line":"                    // with \"Todo\" status needs to be included","counters":[]},{"line":"                    let lens = WeightLens::Merge;","counters":[{"col_start":24,"col_end":49,"count":0}]},{"line":"                    match (&merge.weight, &merge.job) {","counters":[{"col_start":0,"col_end":52,"count":0}]},{"line":"                        ((w1, w2), Full(Record { state: Todo, .. })) => {","counters":[{"col_start":26,"col_end":73,"count":0}]},{"line":"                            (lens.set(w1, 1), lens.set(w2, 0))","counters":[{"col_start":0,"col_end":62,"count":0}]},{"line":"                        }","counters":[]},{"line":"                        ((w1, w2), _) => reset(lens, w1, w2),","counters":[{"col_start":26,"col_end":60,"count":0}]},{"line":"                    }","counters":[]},{"line":"                }","counters":[]},{"line":"                ResetKind::Base => {","counters":[]},{"line":"                    // The base-weight of merge nodes is the sum of weights of its","counters":[]},{"line":"                    // children","counters":[]},{"line":"                    let w = &merge.weight;","counters":[{"col_start":24,"col_end":42,"count":0}]},{"line":"                    reset(WeightLens::Base, &w.0, &w.1)","counters":[{"col_start":0,"col_end":55,"count":0}]},{"line":"                }","counters":[]},{"line":"                ResetKind::Both => {","counters":[]},{"line":"                    let w = &merge.weight;","counters":[{"col_start":24,"col_end":42,"count":0}]},{"line":"                    let w = reset(WeightLens::Base, &w.0, &w.1);","counters":[{"col_start":0,"col_end":64,"count":0}]},{"line":"                    reset(WeightLens::Merge, &w.0, &w.1)","counters":[{"col_start":0,"col_end":56,"count":0}]},{"line":"                }","counters":[]},{"line":"            };","counters":[]},{"line":"","counters":[]},{"line":"            let merge = merge::Merge {","counters":[{"col_start":16,"col_end":38,"count":0}]},{"line":"                weight: ww.clone(),","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"                job: merge.job.clone(),","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"            };","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"","counters":[]},{"line":"            (merge, ww)","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"        };","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        let (result, _) = self.update_accumulate(&fun_merge, &fun_base);","counters":[{"col_start":13,"col_end":72,"count":0}]},{"line":"        result","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn jobs_on_level(&self, depth: u64, level: u64) -> Vec<AvailableJob<BaseJob, MergeJob>> {","counters":[{"col_start":4,"col_end":93,"count":0}]},{"line":"        use JobStatus::Todo;","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"","counters":[]},{"line":"        // self.iter()","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"        //     .filter(|(d, _)| *d == depth)","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"        //     .filter_map(|(_, value)| match value {","counters":[{"col_start":0,"col_end":53,"count":0}]},{"line":"        //         Value::Leaf(base::Base {","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"        //             job:","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"        //                 base::Job::Full(base::Record {","counters":[{"col_start":0,"col_end":57,"count":0}]},{"line":"        //                     job, state: Todo, ..","counters":[{"col_start":0,"col_end":51,"count":0}]},{"line":"        //                 }),","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"        //             ..","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"        //         }) => Some(AvailableJob::Base(job.clone())),","counters":[{"col_start":0,"col_end":63,"count":0}]},{"line":"        //         Value::Node(merge::Merge {","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"        //             job:","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"        //                 merge::Job::Full(merge::Record {","counters":[{"col_start":0,"col_end":59,"count":0}]},{"line":"        //                     left,","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"        //                     right,","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"        //                     state: Todo,","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"        //                     ..","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"        //                 }),","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"        //             ..","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"        //         }) => Some(AvailableJob::Merge {","counters":[{"col_start":0,"col_end":51,"count":0}]},{"line":"        //             left: left.clone(),","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"        //             right: right.clone(),","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"        //         }),","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"        //         _ => None,","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"        //     })","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"        //     .collect::<Vec<_>>();","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"","counters":[]},{"line":"        self.fold_depth(","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"            |i, mut acc, a| {","counters":[{"col_start":0,"col_end":12,"count":0},{"col_start":28,"col_end":29,"count":0}]},{"line":"                use merge::{Job::Full, Record};","counters":[]},{"line":"","counters":[]},{"line":"                if let (","counters":[]},{"line":"                    true,","counters":[]},{"line":"                    Full(Record {","counters":[]},{"line":"                        left,","counters":[{"col_start":24,"col_end":29,"count":0}]},{"line":"                        right,","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"                        state: Todo,","counters":[]},{"line":"                        ..","counters":[]},{"line":"                    }),","counters":[]},{"line":"                ) = (i == level, &a.job)","counters":[{"col_start":20,"col_end":40,"count":0}]},{"line":"                {","counters":[{"col_start":16,"col_end":17,"count":0}]},{"line":"                    acc.push(AvailableJob::Merge {","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"                        left: left.clone(),","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"                        right: right.clone(),","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"                    });","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"                };","counters":[{"col_start":0,"col_end":17,"count":0},{"col_start":17,"col_end":18,"count":0}]},{"line":"                acc","counters":[{"col_start":16,"col_end":19,"count":0}]},{"line":"            },","counters":[{"col_start":0,"col_end":13,"count":0},{"col_start":13,"col_end":14,"count":0}]},{"line":"            |mut acc, d| {","counters":[{"col_start":0,"col_end":12,"count":0},{"col_start":25,"col_end":26,"count":0}]},{"line":"                use base::{Job::Full, Record};","counters":[]},{"line":"","counters":[]},{"line":"                if let (","counters":[]},{"line":"                    true,","counters":[]},{"line":"                    Full(Record {","counters":[]},{"line":"                        job, state: Todo, ..","counters":[{"col_start":24,"col_end":27,"count":0}]},{"line":"                    }),","counters":[]},{"line":"                ) = (level == depth, &d.job)","counters":[{"col_start":20,"col_end":44,"count":0}]},{"line":"                {","counters":[{"col_start":16,"col_end":17,"count":0}]},{"line":"                    acc.push(AvailableJob::Base(job.clone()));","counters":[{"col_start":0,"col_end":62,"count":0}]},{"line":"                }","counters":[{"col_start":0,"col_end":17,"count":0},{"col_start":17,"col_end":18,"count":0}]},{"line":"                acc","counters":[{"col_start":16,"col_end":19,"count":0}]},{"line":"            },","counters":[{"col_start":0,"col_end":13,"count":0},{"col_start":13,"col_end":14,"count":0}]},{"line":"            Vec::with_capacity(256),","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"        )","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn to_hashable_jobs(&self) -> Vec<Job<base::Base<BaseJob>, merge::Merge<MergeJob>>> {","counters":[{"col_start":4,"col_end":89,"count":266}]},{"line":"        use JobStatus::Done;","counters":[{"col_start":0,"col_end":28,"count":266}]},{"line":"","counters":[]},{"line":"        self.fold(","counters":[{"col_start":0,"col_end":18,"count":266}]},{"line":"            |mut acc, a| {","counters":[{"col_start":0,"col_end":12,"count":266}]},{"line":"                match &a.job {","counters":[{"col_start":22,"col_end":28,"count":20}]},{"line":"                    merge::Job::Full(merge::Record { state: Done, .. }) => {}","counters":[{"col_start":75,"col_end":77,"count":0}]},{"line":"                    _ => {","counters":[{"col_start":25,"col_end":26,"count":0}]},{"line":"                        acc.push(Job::Merge(a.clone()));","counters":[{"col_start":0,"col_end":56,"count":0}]},{"line":"                    }","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"                }","counters":[]},{"line":"                acc","counters":[{"col_start":16,"col_end":19,"count":0}]},{"line":"            },","counters":[{"col_start":0,"col_end":13,"count":0},{"col_start":13,"col_end":14,"count":266}]},{"line":"            |mut acc, d| {","counters":[{"col_start":0,"col_end":12,"count":266}]},{"line":"                match &d.job {","counters":[{"col_start":22,"col_end":28,"count":0}]},{"line":"                    base::Job::Full(base::Record { state: Done, .. }) => {}","counters":[{"col_start":73,"col_end":75,"count":0}]},{"line":"                    _ => {","counters":[{"col_start":25,"col_end":26,"count":38}]},{"line":"                        acc.push(Job::Base(d.clone()));","counters":[{"col_start":0,"col_end":55,"count":38}]},{"line":"                    }","counters":[{"col_start":0,"col_end":21,"count":38}]},{"line":"                }","counters":[]},{"line":"                acc","counters":[{"col_start":16,"col_end":19,"count":38}]},{"line":"            },","counters":[{"col_start":0,"col_end":13,"count":38},{"col_start":13,"col_end":14,"count":266}]},{"line":"            Vec::with_capacity(256),","counters":[{"col_start":0,"col_end":36,"count":266}]},{"line":"        )","counters":[{"col_start":0,"col_end":9,"count":266}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":266}]},{"line":"","counters":[]},{"line":"    fn jobs_records(&self) -> Vec<Job<base::Record<BaseJob>, merge::Record<MergeJob>>> {","counters":[]},{"line":"        self.fold(","counters":[]},{"line":"            |mut acc, a: &merge::Merge<MergeJob>| {","counters":[]},{"line":"                if let merge::Job::Full(x) = &a.job {","counters":[]},{"line":"                    acc.push(Job::Merge(x.clone()));","counters":[]},{"line":"                }","counters":[]},{"line":"                acc","counters":[]},{"line":"            },","counters":[]},{"line":"            |mut acc, d: &base::Base<BaseJob>| {","counters":[]},{"line":"                if let base::Job::Full(j) = &d.job {","counters":[]},{"line":"                    acc.push(Job::Base(j.clone()));","counters":[]},{"line":"                }","counters":[]},{"line":"                acc","counters":[]},{"line":"            },","counters":[]},{"line":"            Vec::with_capacity(256),","counters":[]},{"line":"        )","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn base_jobs(&self) -> Vec<BaseJob> {","counters":[{"col_start":4,"col_end":41,"count":0}]},{"line":"        self.fold_depth(","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"            |_, acc, _| acc,","counters":[{"col_start":0,"col_end":12,"count":0},{"col_start":24,"col_end":27,"count":0},{"col_start":27,"col_end":28,"count":0}]},{"line":"            |mut acc, d| {","counters":[{"col_start":0,"col_end":12,"count":0}]},{"line":"                if let base::Job::Full(base::Record { job, .. }) = &d.job {","counters":[{"col_start":54,"col_end":57,"count":-6},{"col_start":67,"col_end":73,"count":0},{"col_start":74,"col_end":75,"count":-6}]},{"line":"                    acc.push(job.clone());","counters":[{"col_start":0,"col_end":42,"count":-6}]},{"line":"                };","counters":[{"col_start":0,"col_end":17,"count":-6},{"col_start":17,"col_end":18,"count":6}]},{"line":"                acc","counters":[{"col_start":16,"col_end":19,"count":0}]},{"line":"            },","counters":[{"col_start":0,"col_end":13,"count":0},{"col_start":13,"col_end":14,"count":0}]},{"line":"            Vec::with_capacity(256),","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"        )","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    /// calculates the number of base and merge jobs that is currently with the Todo status","counters":[]},{"line":"    fn todo_job_count(&self) -> (u64, u64) {","counters":[]},{"line":"        use JobStatus::Todo;","counters":[]},{"line":"","counters":[]},{"line":"        self.fold_depth(","counters":[]},{"line":"            |_, (b, m), j| match &j.job {","counters":[]},{"line":"                merge::Job::Full(merge::Record { state: Todo, .. }) => (b, m + 1),","counters":[]},{"line":"                _ => (b, m),","counters":[]},{"line":"            },","counters":[]},{"line":"            |(b, m), d| match &d.job {","counters":[]},{"line":"                base::Job::Full(base::Record { state: Todo, .. }) => (b + 1, m),","counters":[]},{"line":"                _ => (b, m),","counters":[]},{"line":"            },","counters":[]},{"line":"            (0, 0),","counters":[]},{"line":"        )","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn leaves(&self) -> Vec<base::Base<BaseJob>> {","counters":[{"col_start":4,"col_end":50,"count":0}]},{"line":"        self.fold_depth(","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"            |_, acc, _| acc,","counters":[{"col_start":0,"col_end":12,"count":0},{"col_start":24,"col_end":27,"count":0},{"col_start":27,"col_end":28,"count":0}]},{"line":"            |mut acc, d| {","counters":[{"col_start":0,"col_end":12,"count":0},{"col_start":25,"col_end":26,"count":0}]},{"line":"                if let base::Job::Full(_) = &d.job {","counters":[{"col_start":0,"col_end":50,"count":0},{"col_start":51,"col_end":52,"count":0}]},{"line":"                    acc.push(d.clone());","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"                };","counters":[{"col_start":0,"col_end":17,"count":0},{"col_start":17,"col_end":18,"count":0}]},{"line":"                acc","counters":[{"col_start":16,"col_end":19,"count":0}]},{"line":"            },","counters":[{"col_start":0,"col_end":13,"count":0},{"col_start":13,"col_end":14,"count":0}]},{"line":"            Vec::with_capacity(256),","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"        )","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn required_job_count(&self) -> u64 {","counters":[{"col_start":4,"col_end":41,"count":0}]},{"line":"        match &self.values[0] {","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"            Value::Node(value) => {","counters":[{"col_start":24,"col_end":35,"count":0}]},{"line":"                let (w1, w2) = &value.weight;","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"                w1.merge + w2.merge","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"            }","counters":[]},{"line":"            Value::Leaf(base) => base.weight.merge,","counters":[{"col_start":24,"col_end":50,"count":0}]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn available_space(&self) -> u64 {","counters":[{"col_start":4,"col_end":38,"count":0}]},{"line":"        match &self.values[0] {","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"            Value::Node(value) => {","counters":[{"col_start":24,"col_end":35,"count":0}]},{"line":"                let (w1, w2) = &value.weight;","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"                w1.base + w2.base","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"            }","counters":[]},{"line":"            Value::Leaf(base) => base.weight.base,","counters":[{"col_start":24,"col_end":49,"count":0}]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn create_tree_for_level(","counters":[{"col_start":4,"col_end":29,"count":0}]},{"line":"        level: i64,","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"        depth: u64,","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"        merge_job: merge::Job<MergeJob>,","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"        base_job: base::Job<BaseJob>,","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"    ) -> Self {","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"        let base_weight = if level == -1 {","counters":[{"col_start":12,"col_end":23,"count":0},{"col_start":29,"col_end":40,"count":0}]},{"line":"            Weight::zero()","counters":[{"col_start":12,"col_end":26,"count":0}]},{"line":"        } else {","counters":[]},{"line":"            Weight { base: 1, merge: 0 }","counters":[{"col_start":12,"col_end":40,"count":0}]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        let make_base = || base::Base {","counters":[{"col_start":12,"col_end":24,"count":0},{"col_start":27,"col_end":39,"count":0}]},{"line":"            weight: base_weight.clone(),","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"            job: base_job.clone(),","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"        };","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        let make_merge = |d: u64| {","counters":[{"col_start":12,"col_end":25,"count":0},{"col_start":34,"col_end":35,"count":0}]},{"line":"            let weight = if level == -1 {","counters":[{"col_start":16,"col_end":22,"count":0},{"col_start":28,"col_end":39,"count":0}]},{"line":"                (Weight::zero(), Weight::zero())","counters":[{"col_start":16,"col_end":48,"count":0}]},{"line":"            } else {","counters":[]},{"line":"                let x = 2u64.pow(level as u32) / 2u64.pow(d as u32 + 1);","counters":[{"col_start":20,"col_end":72,"count":0}]},{"line":"                (Weight { base: x, merge: 0 }, Weight { base: x, merge: 0 })","counters":[{"col_start":0,"col_end":76,"count":0}]},{"line":"            };","counters":[]},{"line":"            merge::Merge {","counters":[{"col_start":12,"col_end":26,"count":0}]},{"line":"                weight,","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"                job: merge_job.clone(),","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        };","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        let nnodes = 2u64.pow((depth + 1) as u32) - 1;","counters":[{"col_start":12,"col_end":54,"count":0}]},{"line":"","counters":[]},{"line":"        let values: Vec<_> = (0..nnodes)","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"            .into_iter()","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"            .map(|index| {","counters":[{"col_start":0,"col_end":17,"count":0},{"col_start":25,"col_end":26,"count":0}]},{"line":"                let node_depth = btree::depth_at(index as usize);","counters":[{"col_start":0,"col_end":65,"count":0}]},{"line":"","counters":[]},{"line":"                if node_depth == depth {","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"                    Value::Leaf(make_base())","counters":[{"col_start":20,"col_end":44,"count":0}]},{"line":"                } else {","counters":[]},{"line":"                    Value::Node(make_merge(node_depth))","counters":[{"col_start":20,"col_end":55,"count":0}]},{"line":"                }","counters":[]},{"line":"            })","counters":[{"col_start":12,"col_end":13,"count":0},{"col_start":13,"col_end":14,"count":0}]},{"line":"            .collect();","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"        // println!(\"first={:?}\", values[0]);","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"","counters":[]},{"line":"        // println!(\"nnodes={:?} len={:?} nbases={:?}\", nnodes, values.len(), values.iter().filter(|v| {","counters":[{"col_start":0,"col_end":104,"count":0}]},{"line":"        //   matches!(v, Value::Leaf(_))","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"        // }).count());","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"        Self { values }","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn create_tree(depth: u64) -> Self {","counters":[{"col_start":4,"col_end":40,"count":12}]},{"line":"        let level: i64 = depth.try_into().unwrap();","counters":[{"col_start":0,"col_end":51,"count":12}]},{"line":"        Self::create_tree_for_level(level, depth, merge::Job::Empty, base::Job::Empty)","counters":[{"col_start":0,"col_end":86,"count":12}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":12}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl<BaseJob, MergeJob> ParallelScan<BaseJob, MergeJob>","counters":[]},{"line":"where","counters":[]},{"line":"    BaseJob: Debug + Clone + 'static,","counters":[]},{"line":"    MergeJob: Debug + Clone + 'static,","counters":[]},{"line":"{","counters":[]},{"line":"    fn with_leaner_trees(&self) -> Self {","counters":[{"col_start":4,"col_end":41,"count":216}]},{"line":"        use JobStatus::Done;","counters":[{"col_start":0,"col_end":28,"count":216}]},{"line":"","counters":[]},{"line":"        let trees = self","counters":[{"col_start":0,"col_end":24,"count":216}]},{"line":"            .trees","counters":[{"col_start":0,"col_end":18,"count":216}]},{"line":"            .iter()","counters":[{"col_start":0,"col_end":19,"count":216}]},{"line":"            .map(|tree| {","counters":[{"col_start":0,"col_end":17,"count":216},{"col_start":24,"col_end":25,"count":0}]},{"line":"                tree.map(","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"                    |merge_node| match &merge_node.job {","counters":[{"col_start":0,"col_end":20,"count":0},{"col_start":39,"col_end":54,"count":0}]},{"line":"                        merge::Job::Full(merge::Record { state: Done, .. }) => merge::Merge {","counters":[{"col_start":79,"col_end":93,"count":0}]},{"line":"                            weight: merge_node.weight.clone(),","counters":[{"col_start":0,"col_end":62,"count":0}]},{"line":"                            job: merge::Job::Empty,","counters":[{"col_start":0,"col_end":51,"count":0}]},{"line":"                        },","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"                        _ => merge_node.clone(),","counters":[{"col_start":29,"col_end":47,"count":0}]},{"line":"                    },","counters":[{"col_start":20,"col_end":21,"count":0},{"col_start":21,"col_end":22,"count":0}]},{"line":"                    |b| b.clone(),","counters":[{"col_start":0,"col_end":20,"count":0},{"col_start":24,"col_end":33,"count":0},{"col_start":33,"col_end":34,"count":0}]},{"line":"                )","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"            })","counters":[{"col_start":0,"col_end":13,"count":0},{"col_start":13,"col_end":14,"count":216}]},{"line":"            .collect();","counters":[{"col_start":0,"col_end":23,"count":216}]},{"line":"","counters":[]},{"line":"        Self {","counters":[{"col_start":0,"col_end":14,"count":216}]},{"line":"            trees,","counters":[{"col_start":0,"col_end":18,"count":216}]},{"line":"            acc: self.acc.clone(),","counters":[{"col_start":0,"col_end":34,"count":216}]},{"line":"            curr_job_seq_no: self.curr_job_seq_no.clone(),","counters":[{"col_start":0,"col_end":58,"count":216}]},{"line":"            max_base_jobs: self.max_base_jobs,","counters":[{"col_start":0,"col_end":46,"count":216}]},{"line":"            delay: self.delay,","counters":[{"col_start":0,"col_end":30,"count":216}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":216}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":216}]},{"line":"","counters":[]},{"line":"    pub fn empty(max_base_jobs: u64, delay: u64) -> Self {","counters":[{"col_start":4,"col_end":58,"count":0}]},{"line":"        let depth = ceil_log2(max_base_jobs);","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"        // println!(\"empty depth={:?}\", depth);","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"","counters":[]},{"line":"        let first_tree = Tree::create_tree(depth);","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"","counters":[]},{"line":"        let mut trees = Vec::with_capacity(32);","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"        trees.push(first_tree);","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"","counters":[]},{"line":"        Self {","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"            trees,","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"            acc: None,","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"            curr_job_seq_no: SequenceNumber(0),","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"            max_base_jobs,","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"            delay,","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn map<F1, F2>(&self, f1: F1, f2: F2) -> Self","counters":[]},{"line":"    where","counters":[]},{"line":"        F1: Fn(&MergeJob) -> MergeJob,","counters":[]},{"line":"        F2: Fn(&BaseJob) -> BaseJob,","counters":[]},{"line":"    {","counters":[]},{"line":"        let trees = self","counters":[]},{"line":"            .trees","counters":[]},{"line":"            .iter()","counters":[]},{"line":"            .map(|tree| tree.map_depth(&|_, m| m.map(&f1), &|a| a.map(&f2)))","counters":[]},{"line":"            .collect();","counters":[]},{"line":"","counters":[]},{"line":"        let acc = self","counters":[]},{"line":"            .acc","counters":[]},{"line":"            .as_ref()","counters":[]},{"line":"            .map(|(m, bs)| (f1(m), bs.iter().map(&f2).collect()));","counters":[]},{"line":"","counters":[]},{"line":"        Self {","counters":[]},{"line":"            trees,","counters":[]},{"line":"            acc,","counters":[]},{"line":"            curr_job_seq_no: self.curr_job_seq_no.clone(),","counters":[]},{"line":"            max_base_jobs: self.max_base_jobs,","counters":[]},{"line":"            delay: self.delay,","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    pub fn hash<FunMerge, FunBase>(","counters":[{"col_start":4,"col_end":35,"count":0}]},{"line":"        &self,","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"        fun_merge: FunMerge,","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"        fun_base: FunBase,","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"    ) -> GenericArray<u8, U32>","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"    where","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"        FunMerge: Fn(&mut Vec<u8>, &MergeJob),","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"        FunBase: Fn(&mut Vec<u8>, &BaseJob),","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"    {","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"        const BUFFER_CAPACITY: usize = 128 * 1024;","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"","counters":[]},{"line":"        let Self {","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"            trees,","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"            acc,","counters":[{"col_start":0,"col_end":16,"count":0}]},{"line":"            curr_job_seq_no,","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"            max_base_jobs,","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"            delay,","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"        } = self.with_leaner_trees();","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"        let mut sha: Sha256 = Sha256::new();","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"        let mut buffer = Vec::with_capacity(BUFFER_CAPACITY);","counters":[{"col_start":0,"col_end":61,"count":0}]},{"line":"        let buffer = &mut buffer;","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"","counters":[]},{"line":"        let add_weight =","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"            |buffer: &mut Vec<u8>, w: &Weight| write!(buffer, \"{}{}\", w.base, w.merge).unwrap();","counters":[{"col_start":47,"col_end":95,"count":0}]},{"line":"","counters":[]},{"line":"        let add_two_weights = |buffer: &mut Vec<u8>, (w1, w2): &(Weight, Weight)| {","counters":[{"col_start":12,"col_end":30,"count":0},{"col_start":82,"col_end":83,"count":0}]},{"line":"            add_weight(buffer, w1);","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"            add_weight(buffer, w2);","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"        };","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        for job in trees.iter().flat_map(Tree::to_hashable_jobs) {","counters":[{"col_start":12,"col_end":15,"count":0},{"col_start":19,"col_end":64,"count":0}]},{"line":"            buffer.clear();","counters":[{"col_start":12,"col_end":27,"count":0}]},{"line":"","counters":[]},{"line":"            match &job {","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"                Job::Base(base) => match &base.job {","counters":[{"col_start":26,"col_end":50,"count":0}]},{"line":"                    base::Job::Empty => {","counters":[{"col_start":40,"col_end":41,"count":0}]},{"line":"                        add_weight(buffer, &base.weight);","counters":[{"col_start":0,"col_end":57,"count":0}]},{"line":"                        write!(buffer, \"Empty\").unwrap();","counters":[{"col_start":0,"col_end":57,"count":0}]},{"line":"                    }","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"                    base::Job::Full(base::Record { job, seq_no, state }) => {","counters":[{"col_start":51,"col_end":77,"count":0}]},{"line":"                        add_weight(buffer, &base.weight);","counters":[{"col_start":0,"col_end":57,"count":0}]},{"line":"                        write!(buffer, \"Full{}{}\", seq_no.0, state.as_str()).unwrap();","counters":[{"col_start":0,"col_end":86,"count":0}]},{"line":"","counters":[]},{"line":"                        fun_base(buffer, job);","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"                    }","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"                },","counters":[]},{"line":"                Job::Merge(merge) => match &merge.job {","counters":[{"col_start":27,"col_end":53,"count":0}]},{"line":"                    merge::Job::Empty => {","counters":[{"col_start":41,"col_end":42,"count":0}]},{"line":"                        add_two_weights(buffer, &merge.weight);","counters":[{"col_start":0,"col_end":63,"count":0}]},{"line":"                        write!(buffer, \"Empty\").unwrap();","counters":[{"col_start":0,"col_end":57,"count":0}]},{"line":"                    }","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"                    merge::Job::Part(job) => {","counters":[{"col_start":37,"col_end":46,"count":0}]},{"line":"                        add_two_weights(buffer, &merge.weight);","counters":[{"col_start":0,"col_end":63,"count":0}]},{"line":"                        write!(buffer, \"Part\").unwrap();","counters":[{"col_start":0,"col_end":56,"count":0}]},{"line":"","counters":[]},{"line":"                        fun_merge(buffer, job);","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"                    }","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"                    merge::Job::Full(merge::Record {","counters":[]},{"line":"                        left,","counters":[{"col_start":24,"col_end":29,"count":0}]},{"line":"                        right,","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"                        seq_no,","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"                        state,","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"                    }) => {","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"                        add_two_weights(buffer, &merge.weight);","counters":[{"col_start":0,"col_end":63,"count":0}]},{"line":"                        write!(buffer, \"Full{}{}\", seq_no.0, state.as_str()).unwrap();","counters":[{"col_start":0,"col_end":86,"count":0}]},{"line":"","counters":[]},{"line":"                        fun_merge(buffer, left);","counters":[{"col_start":0,"col_end":48,"count":0}]},{"line":"                        fun_merge(buffer, right);","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"                    }","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"                },","counters":[]},{"line":"            }","counters":[]},{"line":"","counters":[]},{"line":"            sha.update(buffer.as_slice());","counters":[{"col_start":12,"col_end":42,"count":0}]},{"line":"","counters":[]},{"line":"            // TODO: Remove this assert once we know it's a good capacity","counters":[{"col_start":0,"col_end":73,"count":0}]},{"line":"            //       (buffer is not resized for serialization)","counters":[{"col_start":0,"col_end":62,"count":0}]},{"line":"            assert_eq!(buffer.capacity(), BUFFER_CAPACITY);","counters":[{"col_start":0,"col_end":58,"count":0}]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        match &acc {","counters":[{"col_start":14,"col_end":18,"count":0}]},{"line":"            Some((a, d_lst)) => {","counters":[{"col_start":18,"col_end":33,"count":0}]},{"line":"                buffer.clear();","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"","counters":[]},{"line":"                fun_merge(buffer, a);","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"                for j in d_lst {","counters":[{"col_start":20,"col_end":21,"count":0},{"col_start":25,"col_end":30,"count":0},{"col_start":31,"col_end":32,"count":0}]},{"line":"                    fun_base(buffer, j);","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"                }","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"","counters":[]},{"line":"                sha.update(&buffer);","counters":[{"col_start":16,"col_end":35,"count":0}]},{"line":"            }","counters":[]},{"line":"            None => {","counters":[{"col_start":20,"col_end":21,"count":0}]},{"line":"                sha.update(\"None\");","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        buffer.clear();","counters":[{"col_start":8,"col_end":23,"count":0}]},{"line":"        write!(buffer, \"{}{}{}\", curr_job_seq_no.0, max_base_jobs, delay).unwrap();","counters":[{"col_start":0,"col_end":83,"count":0}]},{"line":"        sha.update(&buffer);","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"","counters":[]},{"line":"        sha.finalize()","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn fold_chronological_until<Accum, Final, FunMerge, FunBase, FunFinish>(","counters":[]},{"line":"        &self,","counters":[]},{"line":"        init: Accum,","counters":[]},{"line":"        fun_merge: FunMerge,","counters":[]},{"line":"        fun_base: FunBase,","counters":[]},{"line":"        fun_finish: FunFinish,","counters":[]},{"line":"    ) -> Final","counters":[]},{"line":"    where","counters":[]},{"line":"        FunMerge: Fn(Accum, &merge::Merge<MergeJob>) -> ControlFlow<Final, Accum>,","counters":[]},{"line":"        FunBase: Fn(Accum, &base::Base<BaseJob>) -> ControlFlow<Final, Accum>,","counters":[]},{"line":"        FunFinish: Fn(Accum) -> Final,","counters":[]},{"line":"    {","counters":[]},{"line":"        let mut accum = init;","counters":[]},{"line":"","counters":[]},{"line":"        for tree in self.trees.iter().rev() {","counters":[]},{"line":"            match tree.fold_depth_until_prime(&|_, acc, m| fun_merge(acc, m), &fun_base, accum) {","counters":[]},{"line":"                Continue(acc) => accum = acc,","counters":[]},{"line":"                Break(v) => return v,","counters":[]},{"line":"            }","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        fun_finish(accum)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    pub fn fold_chronological_until_err<Accum, FunMerge, FunBase, FunFinish>(","counters":[{"col_start":4,"col_end":77,"count":16}]},{"line":"        &self,","counters":[{"col_start":0,"col_end":14,"count":16}]},{"line":"        init: Accum,","counters":[{"col_start":0,"col_end":20,"count":16}]},{"line":"        fun_merge: FunMerge,","counters":[{"col_start":0,"col_end":28,"count":16}]},{"line":"        fun_base: FunBase,","counters":[{"col_start":0,"col_end":26,"count":16}]},{"line":"        fun_finish: FunFinish,","counters":[{"col_start":0,"col_end":30,"count":16}]},{"line":"    ) -> Result<Accum, String>","counters":[{"col_start":0,"col_end":30,"count":16}]},{"line":"    where","counters":[{"col_start":0,"col_end":9,"count":16}]},{"line":"        FunMerge: Fn(Accum, &merge::Merge<MergeJob>) -> Result<Accum, String>,","counters":[{"col_start":0,"col_end":78,"count":16}]},{"line":"        FunBase: Fn(Accum, &base::Base<BaseJob>) -> Result<Accum, String>,","counters":[{"col_start":0,"col_end":74,"count":16}]},{"line":"        FunFinish: Fn(Accum) -> Accum,","counters":[{"col_start":0,"col_end":38,"count":16}]},{"line":"    {","counters":[{"col_start":0,"col_end":5,"count":16}]},{"line":"        let mut accum = init;","counters":[{"col_start":0,"col_end":28,"count":16}]},{"line":"","counters":[]},{"line":"        for tree in self.trees.iter().rev() {","counters":[{"col_start":12,"col_end":16,"count":0},{"col_start":20,"col_end":43,"count":16}]},{"line":"            match tree.fold_depth_until_prime_err(&|_, acc, m| fun_merge(acc, m), &fun_base, accum)","counters":[{"col_start":18,"col_end":51,"count":0},{"col_start":63,"col_end":80,"count":0},{"col_start":80,"col_end":99,"count":0}]},{"line":"            {","counters":[]},{"line":"                Ok(acc) => accum = acc,","counters":[{"col_start":19,"col_end":38,"count":0}]},{"line":"                Err(e) => return Err(e),","counters":[{"col_start":20,"col_end":39,"count":0}]},{"line":"            }","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        Ok(fun_finish(accum))","counters":[{"col_start":8,"col_end":29,"count":0}]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn fold_chronological<Accum, FunMerge, FunBase>(","counters":[]},{"line":"        &self,","counters":[]},{"line":"        init: Accum,","counters":[]},{"line":"        fun_merge: FunMerge,","counters":[]},{"line":"        fun_base: FunBase,","counters":[]},{"line":"    ) -> Accum","counters":[]},{"line":"    where","counters":[]},{"line":"        FunMerge: Fn(Accum, &merge::Merge<MergeJob>) -> Accum,","counters":[]},{"line":"        FunBase: Fn(Accum, &base::Base<BaseJob>) -> Accum,","counters":[]},{"line":"    {","counters":[]},{"line":"        self.fold_chronological_until(","counters":[]},{"line":"            init,","counters":[]},{"line":"            |acc, a| Continue(fun_merge(acc, a)),","counters":[]},{"line":"            |acc, d| Continue(fun_base(acc, d)),","counters":[]},{"line":"            |v| v,","counters":[]},{"line":"        )","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn max_trees(&self) -> u64 {","counters":[{"col_start":4,"col_end":32,"count":0}]},{"line":"        ((ceil_log2(self.max_base_jobs) + 1) * (self.delay + 1)) + 1","counters":[{"col_start":0,"col_end":68,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn work_for_tree(&self, data_tree: WorkForTree) -> Vec<AvailableJob<BaseJob, MergeJob>> {","counters":[{"col_start":4,"col_end":93,"count":0}]},{"line":"        let delay = self.delay + 1;","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"","counters":[]},{"line":"        // TODO: Not sure if skip(1) is correct below","counters":[]},{"line":"        let trees = match data_tree {","counters":[{"col_start":12,"col_end":17,"count":0},{"col_start":26,"col_end":35,"count":0}]},{"line":"            WorkForTree::Current => &self.trees[1..],","counters":[{"col_start":36,"col_end":52,"count":0}]},{"line":"            WorkForTree::Next => &self.trees,","counters":[{"col_start":33,"col_end":44,"count":0}]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        // println!(\"WORK_FOR_TREE len={} delay={}\", trees.len(), delay);","counters":[]},{"line":"","counters":[]},{"line":"        work(trees, delay, self.max_base_jobs)","counters":[{"col_start":8,"col_end":46,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    /// work on all the level and all the trees","counters":[]},{"line":"    fn all_work(&self) -> Vec<Vec<AvailableJob<BaseJob, MergeJob>>> {","counters":[{"col_start":4,"col_end":69,"count":0}]},{"line":"        let depth = ceil_log2(self.max_base_jobs);","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"        // TODO: Not sure if it's correct","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"        let set1 = self.work_for_tree(WorkForTree::Current);","counters":[{"col_start":0,"col_end":60,"count":0}]},{"line":"        // let setaaa = self.work_for_tree(WorkForTree::Next);","counters":[{"col_start":0,"col_end":62,"count":0}]},{"line":"","counters":[]},{"line":"        // println!(","counters":[{"col_start":0,"col_end":20,"count":0}]},{"line":"        //     \"ntrees={} delay={} set1={}\",","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"        //     self.trees.len(),","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"        //     self.delay,","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"        //     set1.len()","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"        // );","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        // println!(\"ntrees={} set1={} setaa={}\", self.trees.len(), set1.len(), setaaa.len());","counters":[{"col_start":0,"col_end":94,"count":0}]},{"line":"","counters":[]},{"line":"        let mut this = self.clone();","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"        this.trees.reserve(self.delay as usize + 1);","counters":[{"col_start":0,"col_end":52,"count":0}]},{"line":"","counters":[]},{"line":"        // println!(\"set1={:?}\", set1.len());","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"","counters":[]},{"line":"        let mut other_set = Vec::with_capacity(256);","counters":[{"col_start":0,"col_end":52,"count":0}]},{"line":"        other_set.push(set1);","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"        for _ in 0..self.delay + 1 {","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"            // println!(\"trees={}\", this.trees.len());","counters":[]},{"line":"            this.trees.insert(0, Tree::create_tree(depth));","counters":[{"col_start":12,"col_end":59,"count":3}]},{"line":"            let work = this.work_for_tree(WorkForTree::Current);","counters":[{"col_start":0,"col_end":64,"count":3}]},{"line":"","counters":[]},{"line":"            // println!(\"work={}\", work.len());","counters":[{"col_start":0,"col_end":47,"count":3}]},{"line":"","counters":[]},{"line":"            if !work.is_empty() {","counters":[{"col_start":0,"col_end":31,"count":3},{"col_start":32,"col_end":33,"count":0}]},{"line":"                other_set.push(work);","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0},{"col_start":13,"col_end":14,"count":3}]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        other_set","counters":[{"col_start":8,"col_end":17,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    // let all_work :","counters":[]},{"line":"    //     type merge base. (merge, base) t -> (merge, base) Available_job.t list list","counters":[]},{"line":"    //     =","counters":[]},{"line":"    //  fun t ->","counters":[]},{"line":"    //   let depth = Int.ceil_log2 t.max_base_jobs in","counters":[]},{"line":"    //   Printf.eprintf \"ntrees=%d\\n%!\" (Non_empty_list.length t.trees);","counters":[]},{"line":"    //   let set1 = work_for_tree t ~data_tree:`Current in","counters":[]},{"line":"    //   let _, other_sets =","counters":[]},{"line":"    //     List.fold ~init:(t, [])","counters":[]},{"line":"    //       (List.init ~f:Fn.id (t.delay + 1))","counters":[]},{"line":"    //       ~f:(fun (t, work_list) _ ->","counters":[]},{"line":"    //         Printf.eprintf \"trees=%d\\n%!\" (Non_empty_list.length t.trees);","counters":[]},{"line":"    //         let trees' = Non_empty_list.cons (create_tree ~depth) t.trees in","counters":[]},{"line":"    //         let t' = { t with trees = trees' } in","counters":[]},{"line":"    //         let work = work_for_tree t' ~data_tree:`Current in","counters":[]},{"line":"    //         Printf.eprintf \"work=%d\\n%!\" (List.length work);","counters":[]},{"line":"    //         match work_for_tree t' ~data_tree:`Current with","counters":[]},{"line":"    //         | [] ->","counters":[]},{"line":"    //             (t', work_list)","counters":[]},{"line":"    //         | work ->","counters":[]},{"line":"    //             (t', work :: work_list) )","counters":[]},{"line":"    //   in","counters":[]},{"line":"    //   Printf.eprintf \"set1=%d\\n%!\" (List.length set1);","counters":[]},{"line":"    //   if List.is_empty set1 then List.rev other_sets","counters":[]},{"line":"    //   else set1 :: List.rev other_sets","counters":[]},{"line":"","counters":[]},{"line":"    fn work_for_next_update(&self, data_count: u64) -> Vec<Vec<AvailableJob<BaseJob, MergeJob>>> {","counters":[{"col_start":4,"col_end":98,"count":0}]},{"line":"        let delay = self.delay + 1;","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"        let current_tree_space = self.trees[0].available_space() as usize;","counters":[{"col_start":0,"col_end":74,"count":0}]},{"line":"","counters":[]},{"line":"        let mut set1 = work(&self.trees[1..], delay, self.max_base_jobs);","counters":[{"col_start":0,"col_end":73,"count":0}]},{"line":"        let count = data_count.min(self.max_base_jobs) as usize;","counters":[{"col_start":0,"col_end":64,"count":0}]},{"line":"","counters":[]},{"line":"        if current_tree_space < count {","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"            let mut set2 = work(&self.trees, delay, self.max_base_jobs);","counters":[{"col_start":16,"col_end":72,"count":0}]},{"line":"            set2.truncate((count - current_tree_space) * 2);","counters":[{"col_start":0,"col_end":60,"count":0}]},{"line":"","counters":[]},{"line":"            [set1, set2].into_iter().filter(|v| !v.is_empty()).collect()","counters":[{"col_start":0,"col_end":44,"count":0},{"col_start":48,"col_end":61,"count":0},{"col_start":61,"col_end":72,"count":0}]},{"line":"        } else {","counters":[]},{"line":"            set1.truncate(2 * count);","counters":[{"col_start":12,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"            if set1.is_empty() {","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"                vec![]","counters":[{"col_start":16,"col_end":22,"count":0}]},{"line":"            } else {","counters":[]},{"line":"                vec![set1]","counters":[{"col_start":16,"col_end":26,"count":0}]},{"line":"            }","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn free_space_on_current_tree(&self) -> u64 {","counters":[{"col_start":4,"col_end":49,"count":0}]},{"line":"        self.trees[0].available_space()","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn add_merge_jobs(","counters":[{"col_start":4,"col_end":22,"count":0}]},{"line":"        &mut self,","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"        completed_jobs: &[MergeJob],","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"    ) -> Result<Option<(MergeJob, Vec<BaseJob>)>, ()> {","counters":[{"col_start":0,"col_end":55,"count":0}]},{"line":"        fn take<T>(slice: &[T], n: usize) -> &[T] {","counters":[{"col_start":0,"col_end":51,"count":0}]},{"line":"            slice.get(..n).unwrap_or(slice)","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        fn drop<T>(slice: &[T], n: usize) -> &[T] {","counters":[{"col_start":0,"col_end":51,"count":0}]},{"line":"            slice.get(n..).unwrap_or(&[])","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        if completed_jobs.is_empty() {","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"            return Ok(None);","counters":[{"col_start":19,"col_end":27,"count":0}]},{"line":"        }","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        let delay = self.delay + 1;","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"        let udelay = delay as usize;","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"        let depth = ceil_log2(self.max_base_jobs);","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"","counters":[]},{"line":"        let completed_jobs_len = completed_jobs.len();","counters":[{"col_start":0,"col_end":54,"count":0}]},{"line":"        let merge_jobs: Vec<_> = completed_jobs.iter().cloned().map(Job::Merge).collect();","counters":[{"col_start":0,"col_end":90,"count":0}]},{"line":"        let jobs_required = self.work_for_tree(WorkForTree::Current);","counters":[{"col_start":0,"col_end":69,"count":0}]},{"line":"","counters":[]},{"line":"        assert!(","counters":[{"col_start":0,"col_end":16,"count":0}]},{"line":"            merge_jobs.len() <= jobs_required.len(),","counters":[{"col_start":0,"col_end":51,"count":0}]},{"line":"            \"More work than required\"","counters":[{"col_start":12,"col_end":37,"count":0}]},{"line":"        );","counters":[]},{"line":"","counters":[]},{"line":"        let curr_tree = &self.trees[0];","counters":[{"col_start":12,"col_end":39,"count":0}]},{"line":"        let to_be_updated_trees = &self.trees[1..];","counters":[{"col_start":0,"col_end":51,"count":0}]},{"line":"","counters":[]},{"line":"        // (index, (level, njobs))","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"        let mut stats = BTreeMap::<u64, (u64, usize)>::new();","counters":[{"col_start":0,"col_end":60,"count":0}]},{"line":"","counters":[]},{"line":"        let (mut updated_trees, result_opt) = {","counters":[{"col_start":13,"col_end":42,"count":38}]},{"line":"            let mut jobs = merge_jobs.as_slice();","counters":[{"col_start":16,"col_end":49,"count":0}]},{"line":"","counters":[]},{"line":"            let mut updated_trees = Vec::with_capacity(to_be_updated_trees.len());","counters":[{"col_start":0,"col_end":82,"count":0}]},{"line":"            let mut scan_result = None;","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"","counters":[]},{"line":"            for (i, tree) in to_be_updated_trees.iter().enumerate() {","counters":[{"col_start":17,"col_end":24,"count":0},{"col_start":29,"col_end":67,"count":0}]},{"line":"                // Every nth (n=delay) tree","counters":[]},{"line":"                if (i % udelay == udelay - 1) && !jobs.is_empty() {","counters":[{"col_start":19,"col_end":45,"count":0},{"col_start":49,"col_end":65,"count":0}]},{"line":"                    let nrequired = tree.required_job_count() as usize;","counters":[{"col_start":24,"col_end":71,"count":0}]},{"line":"                    let completed_jobs = take(jobs, nrequired);","counters":[{"col_start":0,"col_end":63,"count":0}]},{"line":"                    let i = i as u64;","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"                    let level = depth - (i / delay);","counters":[{"col_start":0,"col_end":52,"count":0}]},{"line":"                    let old = stats.insert(i, (level, completed_jobs.len()));","counters":[{"col_start":0,"col_end":77,"count":0}]},{"line":"                    assert!(old.is_none());","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"","counters":[]},{"line":"                    let (tree, result) = tree.update(","counters":[{"col_start":25,"col_end":37,"count":0},{"col_start":41,"col_end":53,"count":0}]},{"line":"                        completed_jobs,","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"                        depth - (i / delay),","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"                        self.curr_job_seq_no.clone(),","counters":[{"col_start":0,"col_end":53,"count":0}]},{"line":"                        WeightLens::Merge,","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"                    )?;","counters":[{"col_start":0,"col_end":21,"count":0},{"col_start":21,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"                    updated_trees.push(tree);","counters":[{"col_start":20,"col_end":45,"count":0}]},{"line":"                    scan_result = result;","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"                    jobs = drop(jobs, nrequired);","counters":[{"col_start":0,"col_end":48,"count":0}]},{"line":"                } else {","counters":[{"col_start":23,"col_end":24,"count":0}]},{"line":"                    updated_trees.push(tree.clone());","counters":[{"col_start":0,"col_end":53,"count":0}]},{"line":"                }","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"            }","counters":[]},{"line":"","counters":[]},{"line":"            (updated_trees, scan_result)","counters":[{"col_start":12,"col_end":40,"count":38}]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        for (index, (level, njobs)) in stats.iter().rev() {","counters":[{"col_start":13,"col_end":33,"count":0},{"col_start":39,"col_end":57,"count":38}]},{"line":"            let index = self.trees.len() - *index as usize - 2;","counters":[{"col_start":16,"col_end":63,"count":0}]},{"line":"","counters":[]},{"line":"            if result_opt.is_some() && index == 0 {","counters":[{"col_start":0,"col_end":35,"count":0},{"col_start":39,"col_end":49,"count":0},{"col_start":50,"col_end":51,"count":0}]},{"line":"                println!(","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"                    \"- tree[{:>02}] level={} {:>3} completed jobs, a proof is emitted, tree is removed\",","counters":[{"col_start":0,"col_end":104,"count":0}]},{"line":"                    index,","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"                    level,","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"                    njobs","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"                );","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"            } else {","counters":[{"col_start":0,"col_end":13,"count":0},{"col_start":19,"col_end":20,"count":0}]},{"line":"                println!(","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"                    \"- tree[{:>02}] level={} {:>3} completed jobs (DONE)\",","counters":[{"col_start":0,"col_end":74,"count":0}]},{"line":"                    index, level, njobs","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"                );","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"                println!(","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"                    \"           level={} {:>3} new merge jobs (TODO)\",","counters":[{"col_start":0,"col_end":70,"count":0}]},{"line":"                    level - 1,","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"                    njobs / 2,","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"                );","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        let (mut updated_trees, result_opt) = {","counters":[{"col_start":13,"col_end":42,"count":0}]},{"line":"            let (updated_trees, result_opt) = match result_opt {","counters":[{"col_start":17,"col_end":42,"count":0},{"col_start":52,"col_end":62,"count":0}]},{"line":"                Some(scan_result) if !updated_trees.is_empty() => {","counters":[{"col_start":21,"col_end":67,"count":0}]},{"line":"                    let last = updated_trees.pop().unwrap();","counters":[{"col_start":0,"col_end":60,"count":0}]},{"line":"                    let tree_data = last.base_jobs();","counters":[{"col_start":0,"col_end":53,"count":0}]},{"line":"                    (updated_trees, Some((scan_result, tree_data)))","counters":[{"col_start":0,"col_end":67,"count":0}]},{"line":"                }","counters":[]},{"line":"                _ => (updated_trees, None),","counters":[{"col_start":21,"col_end":42,"count":0}]},{"line":"            };","counters":[]},{"line":"","counters":[]},{"line":"            // TODO: Not sure if priority is same as OCaml here","counters":[]},{"line":"            if result_opt.is_some()","counters":[{"col_start":15,"col_end":35,"count":0}]},{"line":"                || (updated_trees.len() + 1) < self.max_trees() as usize","counters":[{"col_start":19,"col_end":72,"count":0}]},{"line":"                    && (completed_jobs_len == jobs_required.len())","counters":[{"col_start":23,"col_end":66,"count":0}]},{"line":"            {","counters":[]},{"line":"                let updated_trees = updated_trees","counters":[{"col_start":20,"col_end":49,"count":0}]},{"line":"                    .into_iter()","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"                    .map(|tree| tree.reset_weights(ResetKind::Merge))","counters":[{"col_start":0,"col_end":25,"count":0},{"col_start":32,"col_end":68,"count":0},{"col_start":68,"col_end":69,"count":0}]},{"line":"                    .collect();","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"                (updated_trees, result_opt)","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"            } else {","counters":[]},{"line":"                (updated_trees, result_opt)","counters":[{"col_start":16,"col_end":43,"count":0}]},{"line":"            }","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        updated_trees.insert(0, curr_tree.clone());","counters":[{"col_start":8,"col_end":51,"count":0}]},{"line":"","counters":[]},{"line":"        self.trees = updated_trees;","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"        Ok(result_opt)","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn add_data(","counters":[{"col_start":4,"col_end":16,"count":0}]},{"line":"        &mut self,","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"        data: Vec<BaseJob>,","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"        base_kind: impl Fn(&BaseJob) -> usize,","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"    ) -> Result<(), ()> {","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"        if data.is_empty() {","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"            return Ok(());","counters":[{"col_start":19,"col_end":25,"count":0}]},{"line":"        }","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":9,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        let data_len = data.len();","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"        let depth = ceil_log2(self.max_base_jobs);","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"        let tree = &self.trees[0];","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"","counters":[]},{"line":"        let base_jobs: Vec<_> = data.into_iter().map(Job::Base).collect();","counters":[{"col_start":0,"col_end":74,"count":0}]},{"line":"        let available_space = tree.available_space() as usize;","counters":[{"col_start":0,"col_end":62,"count":0}]},{"line":"","counters":[]},{"line":"        assert!(","counters":[{"col_start":0,"col_end":16,"count":0}]},{"line":"            data_len <= available_space,","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"            \"Data count ({}) exceeded available space ({})\",","counters":[{"col_start":12,"col_end":59,"count":0}]},{"line":"            data_len,","counters":[]},{"line":"            available_space","counters":[]},{"line":"        );","counters":[]},{"line":"","counters":[]},{"line":"        // println!(","counters":[]},{"line":"        //     \"base_jobs={:?} available_space={:?} depth={:?}\",","counters":[]},{"line":"        //     base_jobs.len(),","counters":[]},{"line":"        //     available_space,","counters":[]},{"line":"        //     depth","counters":[]},{"line":"        // );","counters":[]},{"line":"","counters":[]},{"line":"        let (tree, _) = tree","counters":[{"col_start":13,"col_end":28,"count":0}]},{"line":"            .update(","counters":[{"col_start":0,"col_end":20,"count":0}]},{"line":"                &base_jobs,","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"                depth,","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"                self.curr_job_seq_no.clone(),","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"                WeightLens::Base,","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"            )","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"            .expect(\"Error while adding a base job to the tree\");","counters":[{"col_start":0,"col_end":65,"count":0}]},{"line":"","counters":[]},{"line":"        let bases = tree.base_jobs();","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"        let nbase = bases.len();","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"","counters":[]},{"line":"        let updated_trees = if data_len == available_space {","counters":[{"col_start":12,"col_end":25,"count":0},{"col_start":31,"col_end":58,"count":0}]},{"line":"            let new_tree = Tree::create_tree(depth);","counters":[{"col_start":16,"col_end":52,"count":0}]},{"line":"            let tree = tree.reset_weights(ResetKind::Both);","counters":[{"col_start":0,"col_end":59,"count":0}]},{"line":"            vec![new_tree, tree]","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"        } else {","counters":[]},{"line":"            let tree = tree.reset_weights(ResetKind::Merge);","counters":[{"col_start":16,"col_end":60,"count":0}]},{"line":"            vec![tree]","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        println!(","counters":[{"col_start":8,"col_end":17,"count":0}]},{"line":"            \"- tree[{:>02}] level=7 {:>3} new base jobs (TODO), total_nbase_jobs={:?}\",","counters":[{"col_start":0,"col_end":87,"count":0}]},{"line":"            self.trees.len() - 1,","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"            data_len,","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"            nbase,","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"        );","counters":[{"col_start":0,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"        let max_base_jobs = self.max_base_jobs as usize;","counters":[{"col_start":0,"col_end":56,"count":0}]},{"line":"","counters":[]},{"line":"        let mut folded = bases.iter().fold(","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"            Vec::<(usize, usize)>::with_capacity(max_base_jobs),","counters":[{"col_start":0,"col_end":64,"count":0}]},{"line":"            |mut accum, b| {","counters":[{"col_start":0,"col_end":12,"count":0},{"col_start":27,"col_end":28,"count":0}]},{"line":"                let kind = base_kind(b);","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"                match accum.last_mut() {","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"                    Some(last) if last.0 == kind => last.1 += 1,","counters":[{"col_start":25,"col_end":29,"count":0},{"col_start":34,"col_end":40,"count":0},{"col_start":47,"col_end":63,"count":0}]},{"line":"                    _ => accum.push((kind, 1)),","counters":[{"col_start":25,"col_end":46,"count":0}]},{"line":"                }","counters":[]},{"line":"                accum","counters":[{"col_start":16,"col_end":21,"count":0}]},{"line":"            },","counters":[{"col_start":0,"col_end":13,"count":0},{"col_start":13,"col_end":14,"count":0}]},{"line":"        );","counters":[{"col_start":0,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"        let total_folded: usize = folded.iter().map(|(_, n)| *n).sum();","counters":[{"col_start":0,"col_end":52,"count":0},{"col_start":61,"col_end":63,"count":0},{"col_start":63,"col_end":71,"count":0}]},{"line":"","counters":[]},{"line":"        if total_folded != max_base_jobs {","counters":[{"col_start":0,"col_end":40,"count":0},{"col_start":41,"col_end":42,"count":0}]},{"line":"            folded.push((10, max_base_jobs - total_folded));","counters":[{"col_start":0,"col_end":60,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0},{"col_start":9,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"        let to_s = |n: usize, s: &str| {","counters":[{"col_start":12,"col_end":16,"count":0},{"col_start":39,"col_end":40,"count":0}]},{"line":"            if n == 1 {","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"                s.to_string()","counters":[{"col_start":16,"col_end":29,"count":0}]},{"line":"            } else {","counters":[]},{"line":"                format!(\"{n} {s}\")","counters":[{"col_start":16,"col_end":34,"count":0}]},{"line":"            }","counters":[]},{"line":"        };","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        let s = folded","counters":[{"col_start":12,"col_end":22,"count":0}]},{"line":"            .iter()","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"            .map(|(kind, n)| match kind {","counters":[{"col_start":0,"col_end":17,"count":0},{"col_start":29,"col_end":39,"count":0}]},{"line":"                0 => to_s(*n, \"CMD\"),","counters":[{"col_start":21,"col_end":36,"count":0}]},{"line":"                1 => to_s(*n, \"FT\"),","counters":[{"col_start":21,"col_end":35,"count":8}]},{"line":"                2 => to_s(*n, \"CB\"),","counters":[{"col_start":21,"col_end":35,"count":0}]},{"line":"                10 => to_s(*n, \"EMPTY\"),","counters":[{"col_start":22,"col_end":39,"count":0}]},{"line":"                _ => panic!(),","counters":[{"col_start":21,"col_end":29,"count":0}]},{"line":"            })","counters":[{"col_start":12,"col_end":13,"count":0},{"col_start":13,"col_end":14,"count":0}]},{"line":"            .join(\"|\");","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"        println!(\"           level=7 has the following jobs (in this order):\");","counters":[{"col_start":0,"col_end":79,"count":0}]},{"line":"        println!(\"           {s}\");","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"        // println!(","counters":[{"col_start":0,"col_end":20,"count":0}]},{"line":"        //     \"updated_trees={} self_trees={:?}\",","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"        //     updated_trees.len(),","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"        //     self.trees.len()","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"        // );","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"        // println!(\"WORK1={:?}\", work(updated_trees.as_slice(), self.delay + 1, self.max_base_jobs));","counters":[{"col_start":0,"col_end":102,"count":0}]},{"line":"        // println!(\"WORK2={:?}\", work(self.trees.as_slice(), self.delay + 1, self.max_base_jobs));","counters":[{"col_start":0,"col_end":99,"count":0}]},{"line":"","counters":[]},{"line":"        // self.trees.append(&mut updated_trees);","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"","counters":[]},{"line":"        // let tail = &self.trees[1..];","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"        // self.trees = updated_trees.into_iter().zip(tail.iter().cloned().collect()).collect();","counters":[{"col_start":0,"col_end":96,"count":0}]},{"line":"","counters":[]},{"line":"        let mut old = std::mem::replace(&mut self.trees, updated_trees);","counters":[{"col_start":0,"col_end":72,"count":0}]},{"line":"        old.remove(0);","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"        self.trees.append(&mut old);","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"","counters":[]},{"line":"        // println!(\"WORK3={:?}\", work(self.trees.as_slice(), self.delay + 1, self.max_base_jobs));","counters":[{"col_start":0,"col_end":99,"count":0}]},{"line":"","counters":[]},{"line":"        Ok(())","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn reset_seq_no(&mut self) {","counters":[{"col_start":4,"col_end":32,"count":0}]},{"line":"        let last = self.trees.last().unwrap();","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"        let oldest_seq_no = match last.leaves().first() {","counters":[{"col_start":12,"col_end":25,"count":0},{"col_start":34,"col_end":55,"count":0}]},{"line":"            Some(base::Base {","counters":[]},{"line":"                job: base::Job::Full(base::Record { seq_no, .. }),","counters":[{"col_start":52,"col_end":66,"count":0}]},{"line":"                ..","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"            }) => seq_no.clone(),","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"            _ => SequenceNumber::zero(),","counters":[{"col_start":17,"col_end":39,"count":0}]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        let new_seq = |seq: &SequenceNumber| (seq - &oldest_seq_no).incr();","counters":[{"col_start":12,"col_end":22,"count":0},{"col_start":45,"col_end":74,"count":0}]},{"line":"","counters":[]},{"line":"        let fun_merge = |m: &merge::Merge<MergeJob>| match &m.job {","counters":[{"col_start":12,"col_end":21,"count":0},{"col_start":53,"col_end":65,"count":0}]},{"line":"            merge::Job::Full(merge::Record { seq_no, .. }) => m.with_seq_no(new_seq(seq_no)),","counters":[{"col_start":45,"col_end":92,"count":0}]},{"line":"            _ => m.clone(),","counters":[{"col_start":17,"col_end":26,"count":0}]},{"line":"        };","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        let fun_base = |m: &base::Base<BaseJob>| match &m.job {","counters":[{"col_start":12,"col_end":20,"count":0},{"col_start":49,"col_end":61,"count":0}]},{"line":"            base::Job::Full(base::Record { seq_no, .. }) => m.with_seq_no(new_seq(seq_no)),","counters":[{"col_start":43,"col_end":90,"count":0}]},{"line":"            _ => m.clone(),","counters":[{"col_start":17,"col_end":26,"count":0}]},{"line":"        };","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        let mut max_seq = SequenceNumber::zero();","counters":[{"col_start":12,"col_end":49,"count":0}]},{"line":"        let mut updated_trees = Vec::with_capacity(self.trees.len());","counters":[{"col_start":0,"col_end":68,"count":0}]},{"line":"","counters":[]},{"line":"        for tree in &self.trees {","counters":[{"col_start":12,"col_end":16,"count":0},{"col_start":20,"col_end":31,"count":0}]},{"line":"            use base::{Base, Job::Full, Record};","counters":[]},{"line":"","counters":[]},{"line":"            let tree = tree.map(fun_merge, fun_base);","counters":[{"col_start":16,"col_end":53,"count":0}]},{"line":"            updated_trees.push(tree.clone());","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"","counters":[]},{"line":"            let leaves = tree.leaves();","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"","counters":[]},{"line":"            let last = match leaves.last() {","counters":[{"col_start":16,"col_end":20,"count":0},{"col_start":29,"col_end":42,"count":0}]},{"line":"                Some(last) => last,","counters":[{"col_start":21,"col_end":34,"count":0}]},{"line":"                None => continue,","counters":[{"col_start":24,"col_end":32,"count":0}]},{"line":"            };","counters":[]},{"line":"","counters":[]},{"line":"            if let Base {","counters":[]},{"line":"                job: Full(Record { seq_no, .. }),","counters":[{"col_start":35,"col_end":41,"count":0}]},{"line":"                ..","counters":[]},{"line":"            } = last","counters":[{"col_start":16,"col_end":20,"count":0}]},{"line":"            {","counters":[{"col_start":12,"col_end":13,"count":0}]},{"line":"                max_seq = max_seq.max(seq_no.clone());","counters":[{"col_start":0,"col_end":54,"count":0}]},{"line":"            };","counters":[{"col_start":0,"col_end":13,"count":0},{"col_start":13,"col_end":14,"count":0}]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        self.curr_job_seq_no = max_seq;","counters":[{"col_start":8,"col_end":39,"count":0}]},{"line":"        self.trees = updated_trees;","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn incr_sequence_no(&mut self) {","counters":[{"col_start":4,"col_end":36,"count":0}]},{"line":"        let next_seq_no = self.curr_job_seq_no.incr();","counters":[{"col_start":0,"col_end":54,"count":0}]},{"line":"","counters":[]},{"line":"        if next_seq_no.is_u64_max() {","counters":[{"col_start":0,"col_end":35,"count":0},{"col_start":36,"col_end":37,"count":0}]},{"line":"            self.reset_seq_no();","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"        } else {","counters":[{"col_start":0,"col_end":9,"count":0},{"col_start":15,"col_end":16,"count":0}]},{"line":"            self.curr_job_seq_no = next_seq_no;","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn update_helper(","counters":[{"col_start":4,"col_end":21,"count":0}]},{"line":"        &mut self,","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"        data: Vec<BaseJob>,","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"        completed_jobs: Vec<MergeJob>,","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"        base_kind: impl Fn(&BaseJob) -> usize,","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"    ) -> Result<Option<(MergeJob, Vec<BaseJob>)>, ()> {","counters":[{"col_start":0,"col_end":55,"count":0}]},{"line":"        fn split<T>(slice: &[T], n: usize) -> (&[T], &[T]) {","counters":[{"col_start":0,"col_end":60,"count":0}]},{"line":"            (","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"                slice.get(..n).unwrap_or(slice),","counters":[{"col_start":0,"col_end":48,"count":0}]},{"line":"                slice.get(n..).unwrap_or(&[]),","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"            )","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        let data_count = data.len() as u64;","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"","counters":[]},{"line":"        assert!(","counters":[{"col_start":0,"col_end":16,"count":0}]},{"line":"            data_count <= self.max_base_jobs,","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"            \"Data count ({}) exceeded maximum ({})\",","counters":[{"col_start":12,"col_end":51,"count":0}]},{"line":"            data_count,","counters":[]},{"line":"            self.max_base_jobs","counters":[]},{"line":"        );","counters":[]},{"line":"","counters":[]},{"line":"        let required_jobs_count = self","counters":[{"col_start":12,"col_end":38,"count":0}]},{"line":"            .work_for_next_update(data_count)","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"            .into_iter()","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"            .flatten()","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"            .count();","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"","counters":[]},{"line":"        {","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"            let required = (required_jobs_count + 1) / 2;","counters":[{"col_start":0,"col_end":57,"count":0}]},{"line":"            let got = (completed_jobs.len() + 1) / 2;","counters":[{"col_start":0,"col_end":53,"count":0}]},{"line":"","counters":[]},{"line":"            // println!(\"required={:?} got={:?}\", required, got);","counters":[{"col_start":0,"col_end":65,"count":0}]},{"line":"","counters":[]},{"line":"            let max_base_jobs = self.max_base_jobs as usize;","counters":[{"col_start":0,"col_end":59,"count":0}]},{"line":"            assert!(","counters":[{"col_start":12,"col_end":19,"count":0}]},{"line":"                !(got < required && data.len() > max_base_jobs - required + got),","counters":[{"col_start":18,"col_end":32,"count":0},{"col_start":36,"col_end":79,"count":0}]},{"line":"                \"Insufficient jobs (Data count {}): Required- {} got- {}\",","counters":[{"col_start":16,"col_end":73,"count":0}]},{"line":"                data_count,","counters":[]},{"line":"                required,","counters":[]},{"line":"                got","counters":[]},{"line":"            )","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        let delay = self.delay + 1;","counters":[{"col_start":12,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"        // Increment the sequence number","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"        self.incr_sequence_no();","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"","counters":[]},{"line":"        let latest_tree = &self.trees[0];","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"        let available_space = latest_tree.available_space();","counters":[{"col_start":0,"col_end":60,"count":0}]},{"line":"","counters":[]},{"line":"        // Possible that new base jobs is added to a new tree within an","counters":[{"col_start":0,"col_end":71,"count":0}]},{"line":"        // update i.e., part of it is added to the first tree and the rest","counters":[{"col_start":0,"col_end":74,"count":0}]},{"line":"        // of it to a new tree. This happens when the throughput is not max.","counters":[{"col_start":0,"col_end":76,"count":0}]},{"line":"        // This also requires merge jobs to be done on two different set of trees*)","counters":[{"col_start":0,"col_end":83,"count":0}]},{"line":"","counters":[]},{"line":"        let (data1, data2) = split(&data, available_space as usize);","counters":[{"col_start":0,"col_end":68,"count":0}]},{"line":"","counters":[]},{"line":"        // println!(","counters":[{"col_start":0,"col_end":20,"count":0}]},{"line":"        //     \"delay={} available_space={} data1={} data2={}\",","counters":[{"col_start":0,"col_end":63,"count":0}]},{"line":"        //     delay,","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"        //     available_space,","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"        //     data1.len(),","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"        //     data2.len()","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"        // );","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"        let required_jobs_for_current_tree =","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"            work(&self.trees[1..], delay, self.max_base_jobs).len();","counters":[{"col_start":0,"col_end":68,"count":0}]},{"line":"        let (jobs1, jobs2) = split(&completed_jobs, required_jobs_for_current_tree);","counters":[{"col_start":0,"col_end":84,"count":0}]},{"line":"","counters":[]},{"line":"        // println!(","counters":[{"col_start":0,"col_end":20,"count":0}]},{"line":"        //     \"required_jobs_for_current_tree={} jobs1={} jobs2={}\",","counters":[{"col_start":0,"col_end":69,"count":0}]},{"line":"        //     required_jobs_for_current_tree,","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"        //     jobs1.len(),","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"        //     jobs2.len()","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"        // );","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"        // TODO: For logs, consider when works are splitted on 2 trees","counters":[{"col_start":0,"col_end":70,"count":0}]},{"line":"        println!(\"scan_state update:\");","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"","counters":[]},{"line":"        // update first set of jobs and data","counters":[]},{"line":"        let result_opt = self.add_merge_jobs(jobs1)?;","counters":[{"col_start":12,"col_end":22,"count":0},{"col_start":25,"col_end":51,"count":0},{"col_start":51,"col_end":52,"count":0}]},{"line":"        self.add_data(data1.to_vec(), &base_kind)?;","counters":[{"col_start":8,"col_end":49,"count":0},{"col_start":49,"col_end":50,"count":0}]},{"line":"","counters":[]},{"line":"        if !jobs2.is_empty() || !data2.is_empty() {","counters":[{"col_start":11,"col_end":28,"count":0},{"col_start":32,"col_end":49,"count":0},{"col_start":50,"col_end":51,"count":0}]},{"line":"            println!(\"scan_state update: (2nd set of jobs, new transactions didn't fit in latest/current tree)\");","counters":[{"col_start":0,"col_end":113,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0},{"col_start":9,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"        // update second set of jobs and data.","counters":[]},{"line":"        // This will be empty if all the data fit in the current tree","counters":[]},{"line":"        self.add_merge_jobs(jobs2)?;","counters":[{"col_start":8,"col_end":34,"count":0},{"col_start":34,"col_end":35,"count":0}]},{"line":"        self.add_data(data2.to_vec(), base_kind)?;","counters":[{"col_start":8,"col_end":48,"count":0},{"col_start":48,"col_end":49,"count":0}]},{"line":"","counters":[]},{"line":"        // update the latest emitted value","counters":[]},{"line":"        if result_opt.is_some() {","counters":[{"col_start":11,"col_end":31,"count":0},{"col_start":32,"col_end":33,"count":0}]},{"line":"            self.acc = result_opt.clone();","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"        };","counters":[{"col_start":0,"col_end":9,"count":0},{"col_start":9,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"        assert!(","counters":[{"col_start":8,"col_end":16,"count":0}]},{"line":"            self.trees.len() <= self.max_trees() as usize,","counters":[{"col_start":0,"col_end":57,"count":0}]},{"line":"            \"Tree list length ({}) exceeded maximum ({})\",","counters":[{"col_start":12,"col_end":58,"count":0}]},{"line":"            self.trees.len(),","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"            self.max_trees()","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"        );","counters":[]},{"line":"","counters":[]},{"line":"        Ok(result_opt)","counters":[{"col_start":8,"col_end":22,"count":0}]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn update(","counters":[{"col_start":4,"col_end":18,"count":0}]},{"line":"        &mut self,","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"        data: Vec<BaseJob>,","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"        completed_jobs: Vec<MergeJob>,","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"        base_kind: impl Fn(&BaseJob) -> usize,","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"    ) -> Result<Option<(MergeJob, Vec<BaseJob>)>, ()> {","counters":[{"col_start":0,"col_end":55,"count":0}]},{"line":"        self.update_helper(data, completed_jobs, base_kind)","counters":[{"col_start":0,"col_end":59,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn all_jobs(&self) -> Vec<Vec<AvailableJob<BaseJob, MergeJob>>> {","counters":[{"col_start":4,"col_end":73,"count":0}]},{"line":"        self.all_work()","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn jobs_for_next_update(&self) -> Vec<Vec<AvailableJob<BaseJob, MergeJob>>> {","counters":[{"col_start":4,"col_end":85,"count":0}]},{"line":"        self.work_for_next_update(self.max_base_jobs)","counters":[{"col_start":0,"col_end":53,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn jobs_for_slots(&self, slots: u64) -> Vec<Vec<AvailableJob<BaseJob, MergeJob>>> {","counters":[]},{"line":"        self.work_for_next_update(slots)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    pub fn free_space(&self) -> u64 {","counters":[{"col_start":4,"col_end":37,"count":0}]},{"line":"        self.max_base_jobs","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn last_emitted_value(&self) -> Option<&(MergeJob, Vec<BaseJob>)> {","counters":[{"col_start":4,"col_end":75,"count":0}]},{"line":"        self.acc.as_ref()","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn current_job_sequence_number(&self) -> SequenceNumber {","counters":[]},{"line":"        self.curr_job_seq_no.clone()","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    pub fn base_jobs_on_latest_tree(&self) -> impl Iterator<Item = BaseJob> {","counters":[{"col_start":4,"col_end":77,"count":0}]},{"line":"        let depth = ceil_log2(self.max_base_jobs);","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"        let level = depth;","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"","counters":[]},{"line":"        self.trees[0]","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"            .jobs_on_level(depth, level)","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"            .into_iter()","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"            .filter_map(|job| match job {","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"                AvailableJob::Base(base) => Some(base),","counters":[]},{"line":"                AvailableJob::Merge { .. } => None,","counters":[]},{"line":"            })","counters":[{"col_start":13,"col_end":14,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    // 0-based indexing, so 0 indicates next-to-latest tree","counters":[]},{"line":"    pub fn base_jobs_on_earlier_tree(&self, index: usize) -> impl Iterator<Item = BaseJob> {","counters":[{"col_start":4,"col_end":92,"count":0}]},{"line":"        let depth = ceil_log2(self.max_base_jobs);","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"        let level = depth;","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"","counters":[]},{"line":"        let earlier_trees = &self.trees[1..];","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"","counters":[]},{"line":"        let base_job = |job| match job {","counters":[{"col_start":0,"col_end":20,"count":0}]},{"line":"            AvailableJob::Base(base) => Some(base),","counters":[]},{"line":"            AvailableJob::Merge { .. } => None,","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        match earlier_trees.get(index) {","counters":[{"col_start":14,"col_end":38,"count":0}]},{"line":"            None => {","counters":[]},{"line":"                // Use `Vec::new().into_iter().filter_map` to returns same concrete type","counters":[]},{"line":"                // than the `Some(_)` branch","counters":[]},{"line":"                Vec::new().into_iter().filter_map(base_job)","counters":[{"col_start":16,"col_end":59,"count":0}]},{"line":"            }","counters":[]},{"line":"            Some(tree) => tree","counters":[{"col_start":17,"col_end":30,"count":0}]},{"line":"                .jobs_on_level(depth, level)","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"                .into_iter()","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"                .filter_map(base_job),","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn partition_if_overflowing(&self) -> SpacePartition {","counters":[{"col_start":4,"col_end":62,"count":0}]},{"line":"        let cur_tree_space = self.free_space_on_current_tree();","counters":[{"col_start":0,"col_end":63,"count":0}]},{"line":"","counters":[]},{"line":"        // Check actual work count because it would be zero initially","counters":[{"col_start":0,"col_end":69,"count":0}]},{"line":"","counters":[]},{"line":"        let work_count = self.work_for_tree(WorkForTree::Current).len() as u64;","counters":[{"col_start":0,"col_end":79,"count":0}]},{"line":"        let work_count_new_tree = self.work_for_tree(WorkForTree::Next).len() as u64;","counters":[{"col_start":0,"col_end":85,"count":0}]},{"line":"","counters":[]},{"line":"        SpacePartition {","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"            first: (cur_tree_space, work_count),","counters":[{"col_start":0,"col_end":48,"count":0}]},{"line":"            second: {","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"                if cur_tree_space < self.max_base_jobs {","counters":[{"col_start":0,"col_end":54,"count":0}]},{"line":"                    let slots = self.max_base_jobs - cur_tree_space;","counters":[{"col_start":24,"col_end":68,"count":0}]},{"line":"                    Some((slots, work_count_new_tree.min(2 * slots)))","counters":[{"col_start":0,"col_end":69,"count":0}]},{"line":"                } else {","counters":[]},{"line":"                    None","counters":[{"col_start":20,"col_end":24,"count":0}]},{"line":"                }","counters":[]},{"line":"            },","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn next_on_new_tree(&self) -> bool {","counters":[{"col_start":4,"col_end":44,"count":0}]},{"line":"        let curr_tree_space = self.free_space_on_current_tree();","counters":[{"col_start":0,"col_end":64,"count":0}]},{"line":"        curr_tree_space == self.max_base_jobs","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn pending_data(&self) -> Vec<BaseJob> {","counters":[]},{"line":"        self.trees.iter().rev().flat_map(Tree::base_jobs).collect()","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    // #[cfg(test)]","counters":[]},{"line":"    fn job_count(&self) -> (f64, f64) {","counters":[]},{"line":"        use JobStatus::{Done, Todo};","counters":[]},{"line":"","counters":[]},{"line":"        self.fold_chronological(","counters":[]},{"line":"            (0.0, 0.0),","counters":[]},{"line":"            |(ntodo, ndone), merge| {","counters":[]},{"line":"                use merge::{","counters":[]},{"line":"                    Job::{Empty, Full, Part},","counters":[]},{"line":"                    Record,","counters":[]},{"line":"                };","counters":[]},{"line":"","counters":[]},{"line":"                let (todo, done) = match &merge.job {","counters":[]},{"line":"                    Part(_) => (0.5, 0.0),","counters":[]},{"line":"                    Full(Record { state: Todo, .. }) => (1.0, 0.0),","counters":[]},{"line":"                    Full(Record { state: Done, .. }) => (0.0, 1.0),","counters":[]},{"line":"                    Empty => (0.0, 0.0),","counters":[]},{"line":"                };","counters":[]},{"line":"                (ntodo + todo, ndone + done)","counters":[]},{"line":"            },","counters":[]},{"line":"            |(ntodo, ndone), base| {","counters":[]},{"line":"                use base::{","counters":[]},{"line":"                    Job::{Empty, Full},","counters":[]},{"line":"                    Record,","counters":[]},{"line":"                };","counters":[]},{"line":"","counters":[]},{"line":"                let (todo, done) = match &base.job {","counters":[]},{"line":"                    Empty => (0.0, 0.0),","counters":[]},{"line":"                    Full(Record { state: Todo, .. }) => (1.0, 0.0),","counters":[]},{"line":"                    Full(Record { state: Done, .. }) => (0.0, 1.0),","counters":[]},{"line":"                };","counters":[]},{"line":"","counters":[]},{"line":"                (ntodo + todo, ndone + done)","counters":[]},{"line":"            },","counters":[]},{"line":"        )","counters":[]},{"line":"    }","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"fn work_to_do<'a, BaseJob, MergeJob, I>(","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"    trees: I,","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"    max_base_jobs: u64,","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":") -> Vec<AvailableJob<BaseJob, MergeJob>>","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"where","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"    I: Iterator<Item = &'a Tree<base::Base<BaseJob>, merge::Merge<MergeJob>>>,","counters":[{"col_start":0,"col_end":78,"count":0}]},{"line":"    BaseJob: Debug + Clone + 'static,","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"    MergeJob: Debug + Clone + 'static,","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"{","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"    let depth = ceil_log2(max_base_jobs);","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"","counters":[]},{"line":"    // let trees: Vec<_> = trees.collect();","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"","counters":[]},{"line":"    // println!(\"work_to_do length={}\", trees.len());","counters":[{"col_start":0,"col_end":53,"count":0}]},{"line":"","counters":[]},{"line":"    trees","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"        // .iter()","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"        .enumerate()","counters":[{"col_start":0,"col_end":20,"count":0}]},{"line":"        .flat_map(|(i, tree)| {","counters":[{"col_start":0,"col_end":18,"count":0},{"col_start":30,"col_end":31,"count":0}]},{"line":"            let level = depth - i as u64;","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"            tree.jobs_on_level(depth, level)","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"        })","counters":[{"col_start":0,"col_end":9,"count":0},{"col_start":9,"col_end":10,"count":0}]},{"line":"        .collect()","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"fn work<'a, BaseJob, MergeJob, I>(","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"    trees: I,","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"    delay: u64,","counters":[{"col_start":0,"col_end":15,"count":0}]},{"line":"    max_base_jobs: u64,","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":") -> Vec<AvailableJob<BaseJob, MergeJob>>","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"where","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"    I: IntoIterator<Item = &'a Tree<base::Base<BaseJob>, merge::Merge<MergeJob>>>,","counters":[{"col_start":0,"col_end":82,"count":0}]},{"line":"    BaseJob: Debug + Clone + 'static,","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"    MergeJob: Debug + Clone + 'static,","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"{","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"    let depth = ceil_log2(max_base_jobs) as usize;","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"    let delay = delay as usize;","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"","counters":[]},{"line":"    // println!(\"WORK_DELAY={}\", delay);","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"    let work_trees = trees","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"        .into_iter()","counters":[{"col_start":0,"col_end":20,"count":0}]},{"line":"        .enumerate()","counters":[{"col_start":0,"col_end":20,"count":0}]},{"line":"        .filter_map(|(i, t)| {","counters":[{"col_start":0,"col_end":20,"count":0},{"col_start":29,"col_end":30,"count":0}]},{"line":"            if i % delay == delay - 1 {","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"                Some(t)","counters":[{"col_start":16,"col_end":23,"count":0}]},{"line":"            } else {","counters":[]},{"line":"                None","counters":[{"col_start":16,"col_end":20,"count":0}]},{"line":"            }","counters":[]},{"line":"        })","counters":[{"col_start":8,"col_end":9,"count":0},{"col_start":9,"col_end":10,"count":0}]},{"line":"        .take(depth + 1);","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"    work_to_do(work_trees, max_base_jobs)","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"fn take<T>(slice: &[T], n: usize) -> &[T] {","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"    slice.get(..n).unwrap_or(slice)","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"fn take_at<T>(slice: &[T], skip: usize, n: usize) -> &[T] {","counters":[{"col_start":0,"col_end":59,"count":0}]},{"line":"    slice.get(skip..).map(|s| take(s, n)).unwrap_or(&[])","counters":[{"col_start":0,"col_end":26,"count":0},{"col_start":30,"col_end":40,"count":0},{"col_start":40,"col_end":56,"count":0}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"pub const fn ceil_log2(n: u64) -> u64 {","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"    // let ceil_log2 i =","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"    //   if i <= 0","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"    //   then raise_s (Sexp.message \"[Int.ceil_log2] got invalid input\" [ \"\", sexp_of_int i ]);","counters":[{"col_start":0,"col_end":95,"count":0}]},{"line":"    //   if i = 1 then 0 else num_bits - clz (i - 1)","counters":[{"col_start":0,"col_end":52,"count":0}]},{"line":"","counters":[]},{"line":"    assert!(n > 0);","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"    if n == 1 {","counters":[{"col_start":7,"col_end":13,"count":0}]},{"line":"        0","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"    } else {","counters":[]},{"line":"        u64::BITS as u64 - (n - 1).leading_zeros() as u64","counters":[{"col_start":8,"col_end":57,"count":0}]},{"line":"    }","counters":[]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"fn flatten<T>(v: Vec<Vec<T>>) -> Vec<T> {","counters":[]},{"line":"    v.into_iter().flatten().collect()","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"// #[cfg(test)]","counters":[]},{"line":"fn assert_job_count<B, M>(","counters":[]},{"line":"    s1: &ParallelScan<B, M>,","counters":[]},{"line":"    s2: &ParallelScan<B, M>,","counters":[]},{"line":"    completed_job_count: f64,","counters":[]},{"line":"    base_job_count: f64,","counters":[]},{"line":"    value_emitted: bool,","counters":[]},{"line":") where","counters":[]},{"line":"    B: Debug + Clone + 'static,","counters":[]},{"line":"    M: Debug + Clone + 'static,","counters":[]},{"line":"{","counters":[]},{"line":"    // println!(\"s1={:#?}\", s1);","counters":[]},{"line":"    // println!(\"s2={:?}\", s2);","counters":[]},{"line":"","counters":[]},{"line":"    let (todo_before, done_before) = s1.job_count();","counters":[]},{"line":"    let (todo_after, done_after) = s2.job_count();","counters":[]},{"line":"","counters":[]},{"line":"    // println!(","counters":[]},{"line":"    //     \"before todo={:?} done={:?}\",","counters":[]},{"line":"    //     s1.job_count().0,","counters":[]},{"line":"    //     s1.job_count().1","counters":[]},{"line":"    // );","counters":[]},{"line":"    // println!(","counters":[]},{"line":"    //     \"after  todo={:?} done={:?}\",","counters":[]},{"line":"    //     s2.job_count().0,","counters":[]},{"line":"    //     s2.job_count().1","counters":[]},{"line":"    // );","counters":[]},{"line":"","counters":[]},{"line":"    // ordered list of jobs that is actually called when distributing work","counters":[]},{"line":"    let all_jobs = flatten(s2.all_jobs());","counters":[]},{"line":"","counters":[]},{"line":"    // list of jobs","counters":[]},{"line":"","counters":[]},{"line":"    let all_jobs_expected_count = s2","counters":[]},{"line":"        .trees","counters":[]},{"line":"        .iter()","counters":[]},{"line":"        .fold(Vec::with_capacity(s2.trees.len()), |mut acc, tree| {","counters":[]},{"line":"            let mut records = tree.jobs_records();","counters":[]},{"line":"            acc.append(&mut records);","counters":[]},{"line":"            acc","counters":[]},{"line":"        })","counters":[]},{"line":"        .into_iter()","counters":[]},{"line":"        .filter(|job| match job {","counters":[]},{"line":"            Job::Base(base::Record {","counters":[]},{"line":"                state: JobStatus::Todo,","counters":[]},{"line":"                ..","counters":[]},{"line":"            }) => true,","counters":[]},{"line":"            Job::Merge(merge::Record {","counters":[]},{"line":"                state: JobStatus::Todo,","counters":[]},{"line":"                ..","counters":[]},{"line":"            }) => true,","counters":[]},{"line":"            _ => false,","counters":[]},{"line":"        })","counters":[]},{"line":"        .count();","counters":[]},{"line":"","counters":[]},{"line":"    // println!(","counters":[]},{"line":"    //     \"all_jobs={} all_jobs_expected={}\",","counters":[]},{"line":"    //     all_jobs.len(),","counters":[]},{"line":"    //     all_jobs_expected_count","counters":[]},{"line":"    // );","counters":[]},{"line":"","counters":[]},{"line":"    assert_eq!(all_jobs.len(), all_jobs_expected_count);","counters":[]},{"line":"","counters":[]},{"line":"    let expected_todo_after = {","counters":[]},{"line":"        let new_jobs = if value_emitted {","counters":[]},{"line":"            (completed_job_count - 1.0) / 2.0","counters":[]},{"line":"        } else {","counters":[]},{"line":"            completed_job_count / 2.0","counters":[]},{"line":"        };","counters":[]},{"line":"        todo_before + base_job_count - completed_job_count + new_jobs","counters":[]},{"line":"    };","counters":[]},{"line":"","counters":[]},{"line":"    let expected_done_after = {","counters":[]},{"line":"        let jobs_from_delete_tree = if value_emitted {","counters":[]},{"line":"            ((2 * s1.max_base_jobs) - 1) as f64","counters":[]},{"line":"        } else {","counters":[]},{"line":"            0.0","counters":[]},{"line":"        };","counters":[]},{"line":"        done_before + completed_job_count - jobs_from_delete_tree","counters":[]},{"line":"    };","counters":[]},{"line":"","counters":[]},{"line":"    assert_eq!(todo_after, expected_todo_after);","counters":[]},{"line":"    assert_eq!(done_after, expected_done_after);","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"fn test_update<B, M>(","counters":[]},{"line":"    s1: &ParallelScan<B, M>,","counters":[]},{"line":"    data: Vec<B>,","counters":[]},{"line":"    completed_jobs: Vec<M>,","counters":[]},{"line":") -> (Option<(M, Vec<B>)>, ParallelScan<B, M>)","counters":[]},{"line":"where","counters":[]},{"line":"    B: Debug + Clone + 'static,","counters":[]},{"line":"    M: Debug + Clone + 'static,","counters":[]},{"line":"{","counters":[]},{"line":"    let mut s2 = s1.clone();","counters":[]},{"line":"    let result_opt = s2","counters":[]},{"line":"        .update(data.clone(), completed_jobs.clone(), |_| 0)","counters":[]},{"line":"        .unwrap();","counters":[]},{"line":"","counters":[]},{"line":"    assert_job_count(","counters":[]},{"line":"        s1,","counters":[]},{"line":"        &s2,","counters":[]},{"line":"        completed_jobs.len() as f64,","counters":[]},{"line":"        data.len() as f64,","counters":[]},{"line":"        result_opt.is_some(),","counters":[]},{"line":"    );","counters":[]},{"line":"    (result_opt, s2)","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"fn int_to_string(u: &usize) -> String {","counters":[]},{"line":"    u.to_string()","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"// fn sint_to_string(i: &i64) -> String {","counters":[]},{"line":"//     i.to_string()","counters":[]},{"line":"// }","counters":[]},{"line":"","counters":[]},{"line":"fn sint_to_string(buffer: &mut Vec<u8>, i: &i64) {","counters":[]},{"line":"    write!(buffer, \"{}\", i).unwrap();","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"fn hash(state: &ParallelScan<i64, i64>) -> String {","counters":[]},{"line":"    hex::encode(state.hash(sint_to_string, sint_to_string))","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"#[cfg(test)]","counters":[]},{"line":"mod tests {","counters":[]},{"line":"    use std::{","counters":[]},{"line":"        array,","counters":[]},{"line":"        sync::{","counters":[]},{"line":"            atomic::{AtomicBool, Ordering::Relaxed},","counters":[]},{"line":"            mpsc::{sync_channel, Receiver, SyncSender},","counters":[]},{"line":"            Arc,","counters":[]},{"line":"        },","counters":[]},{"line":"    };","counters":[]},{"line":"","counters":[]},{"line":"    use rand::Rng;","counters":[]},{"line":"","counters":[]},{"line":"    use super::*;","counters":[]},{"line":"","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn test_ceil_log2() {","counters":[]},{"line":"        for a in 1..50u64 {","counters":[]},{"line":"            let v = (a as f32).log2().ceil() as u64;","counters":[]},{"line":"            let w = ceil_log2(a);","counters":[]},{"line":"            // println!(\"{} {} {}\", a, v, w);","counters":[]},{"line":"            assert_eq!(v, w);","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    // Make sure that sha256 produces same result when data is splitted or not","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn test_sha256() {","counters":[]},{"line":"        let array: [u8; 2 * 1024] = array::from_fn(|i| (i % 256) as u8);","counters":[]},{"line":"        let mut slice = &array[..];","counters":[]},{"line":"","counters":[]},{"line":"        let mut sha256 = sha2::Sha256::new();","counters":[]},{"line":"        for byte in slice.iter().copied() {","counters":[]},{"line":"            sha256.update(&[byte][..]);","counters":[]},{"line":"        }","counters":[]},{"line":"        let first = sha256.finalize();","counters":[]},{"line":"","counters":[]},{"line":"        let mut sha256 = sha2::Sha256::new();","counters":[]},{"line":"        let mut n = 1;","counters":[]},{"line":"        while !slice.is_empty() {","counters":[]},{"line":"            sha256.update(slice.get(..n).unwrap_or(slice));","counters":[]},{"line":"            slice = slice.get(n..).unwrap_or(&[]);","counters":[]},{"line":"","counters":[]},{"line":"            n += 2;","counters":[]},{"line":"        }","counters":[]},{"line":"        let second = sha256.finalize();","counters":[]},{"line":"","counters":[]},{"line":"        assert_eq!(first, second);","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn test_range_at_depth() {","counters":[]},{"line":"        let ranges: Vec<_> = (0..10u64).map(btree::range_at_depth).collect();","counters":[]},{"line":"","counters":[]},{"line":"        assert_eq!(","counters":[]},{"line":"            ranges,","counters":[]},{"line":"            [","counters":[]},{"line":"                0..1,","counters":[]},{"line":"                1..3,","counters":[]},{"line":"                3..7,","counters":[]},{"line":"                7..15,","counters":[]},{"line":"                15..31,","counters":[]},{"line":"                31..63,","counters":[]},{"line":"                63..127,","counters":[]},{"line":"                127..255,","counters":[]},{"line":"                255..511,","counters":[]},{"line":"                511..1023,","counters":[]},{"line":"            ]","counters":[]},{"line":"        );","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/parallel_scan/parallel_scan.ml#L1525","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn always_max_base_jobs() {","counters":[]},{"line":"        const MAX_BASE_JOS: u64 = 512;","counters":[]},{"line":"","counters":[]},{"line":"        // let int_to_string = |i: &usize| i.to_string();","counters":[]},{"line":"","counters":[]},{"line":"        // let state = ParallelScan::<usize, usize>::empty(8, 3);","counters":[]},{"line":"        // println!(\"STATE len={:?} ={:#?}\", state.trees.len(), state);","counters":[]},{"line":"        // println!(\"hash={:?}\", hash(&state));","counters":[]},{"line":"","counters":[]},{"line":"        let mut state = ParallelScan::<usize, usize>::empty(MAX_BASE_JOS, 3);","counters":[]},{"line":"        let mut expected_result: Vec<Vec<usize>> = vec![];","counters":[]},{"line":"","counters":[]},{"line":"        // println!(\"hash={:?}\", hex::encode(state.hash(int_to_string, int_to_string)));","counters":[]},{"line":"        // println!(\"hash={:?}\", state.hash(int_to_string, int_to_string));","counters":[]},{"line":"","counters":[]},{"line":"        for i in 0..100 {","counters":[]},{"line":"            println!(\"####### LOOP {:?} #########\", i);","counters":[]},{"line":"","counters":[]},{"line":"            let data: Vec<_> = (0..MAX_BASE_JOS as usize)","counters":[]},{"line":"                .into_iter()","counters":[]},{"line":"                .map(|j| i + j)","counters":[]},{"line":"                .collect();","counters":[]},{"line":"","counters":[]},{"line":"            expected_result.push(data.clone());","counters":[]},{"line":"","counters":[]},{"line":"            let work: Vec<_> = state","counters":[]},{"line":"                .work_for_next_update(data.len() as u64)","counters":[]},{"line":"                .into_iter()","counters":[]},{"line":"                .flatten()","counters":[]},{"line":"                .collect();","counters":[]},{"line":"","counters":[]},{"line":"            let new_merges: Vec<_> = work","counters":[]},{"line":"                .iter()","counters":[]},{"line":"                .map(|job| match job {","counters":[]},{"line":"                    AvailableJob::Base(i) => *i,","counters":[]},{"line":"                    AvailableJob::Merge { left, right } => *left + *right,","counters":[]},{"line":"                })","counters":[]},{"line":"                .collect();","counters":[]},{"line":"","counters":[]},{"line":"            println!(\"work={:?} new_merges={:?}\", work.len(), new_merges.len());","counters":[]},{"line":"            // println!(\"hash_s1={:?}\", hash(&state));","counters":[]},{"line":"","counters":[]},{"line":"            // let mut s2 = state.clone();","counters":[]},{"line":"            // let result_opt = s2.update(data.clone(), new_merges.clone()).unwrap();","counters":[]},{"line":"            // println!(\"hash_s2={:?}\", hash(&s2));","counters":[]},{"line":"","counters":[]},{"line":"            let (result_opt, s) = test_update(&state, data, new_merges);","counters":[]},{"line":"","counters":[]},{"line":"            // assert!(result_opt.is_none());","counters":[]},{"line":"","counters":[]},{"line":"            let (expected_result_, remaining_expected_results) = {","counters":[]},{"line":"                match result_opt {","counters":[]},{"line":"                    None => ((0, vec![]), expected_result.clone()),","counters":[]},{"line":"                    Some(ref r) => {","counters":[]},{"line":"                        println!(\"RESULT_OPT.0={} len={}\", r.0, r.1.len());","counters":[]},{"line":"                        // println!(\"expected_result={:?}\", expected_result);","counters":[]},{"line":"                        // Printf.eprintf \"RESULT_OPT.0=%d len=%d\\n%!\" a (List.length l);","counters":[]},{"line":"                        if expected_result.is_empty() {","counters":[]},{"line":"                            ((0, vec![]), vec![])","counters":[]},{"line":"                        } else {","counters":[]},{"line":"                            let first = expected_result[0].clone();","counters":[]},{"line":"                            let sum: usize = first.iter().sum();","counters":[]},{"line":"","counters":[]},{"line":"                            ((sum, first), expected_result[1..].to_vec())","counters":[]},{"line":"                        }","counters":[]},{"line":"                    }","counters":[]},{"line":"                }","counters":[]},{"line":"            };","counters":[]},{"line":"","counters":[]},{"line":"            assert_eq!(","counters":[]},{"line":"                result_opt.as_ref().unwrap_or(&expected_result_),","counters":[]},{"line":"                &expected_result_","counters":[]},{"line":"            );","counters":[]},{"line":"","counters":[]},{"line":"            expected_result = remaining_expected_results;","counters":[]},{"line":"            state = s;","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/parallel_scan/parallel_scan.ml#L1562","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn random_base_jobs() {","counters":[]},{"line":"        const MAX_BASE_JOS: usize = 512;","counters":[]},{"line":"","counters":[]},{"line":"        let mut state = ParallelScan::<usize, usize>::empty(MAX_BASE_JOS as u64, 3);","counters":[]},{"line":"        let mut rng = rand::thread_rng();","counters":[]},{"line":"        let expected_result = (MAX_BASE_JOS, vec![1usize; MAX_BASE_JOS]);","counters":[]},{"line":"","counters":[]},{"line":"        for _ in 0..1_000 {","counters":[]},{"line":"            let mut data = vec![1; rng.gen_range(0..=30)];","counters":[]},{"line":"            data.truncate(MAX_BASE_JOS);","counters":[]},{"line":"            let data_len = data.len();","counters":[]},{"line":"","counters":[]},{"line":"            println!(\"list_length={}\", data_len);","counters":[]},{"line":"","counters":[]},{"line":"            let work: Vec<_> = state","counters":[]},{"line":"                .work_for_next_update(data_len as u64)","counters":[]},{"line":"                .into_iter()","counters":[]},{"line":"                .flatten()","counters":[]},{"line":"                .take(data_len * 2)","counters":[]},{"line":"                .collect();","counters":[]},{"line":"            let new_merges: Vec<_> = work","counters":[]},{"line":"                .iter()","counters":[]},{"line":"                .map(|job| match job {","counters":[]},{"line":"                    AvailableJob::Base(i) => *i,","counters":[]},{"line":"                    AvailableJob::Merge { left, right } => left + right,","counters":[]},{"line":"                })","counters":[]},{"line":"                .collect();","counters":[]},{"line":"","counters":[]},{"line":"            let (result_opt, s) = test_update(&state, data, new_merges);","counters":[]},{"line":"","counters":[]},{"line":"            assert_eq!(","counters":[]},{"line":"                result_opt.as_ref().unwrap_or(&expected_result),","counters":[]},{"line":"                &expected_result","counters":[]},{"line":"            );","counters":[]},{"line":"","counters":[]},{"line":"            state = s;","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn gen<FunDone, FunAcc>(fun_job_done: FunDone, fun_acc: FunAcc) -> ParallelScan<i64, i64>","counters":[]},{"line":"    where","counters":[]},{"line":"        FunDone: Fn(&AvailableJob<i64, i64>) -> i64,","counters":[]},{"line":"        FunAcc: Fn(Option<(i64, Vec<i64>)>, (i64, Vec<i64>)) -> Option<(i64, Vec<i64>)>,","counters":[]},{"line":"    {","counters":[]},{"line":"        let mut rng = rand::thread_rng();","counters":[]},{"line":"","counters":[]},{"line":"        let depth = rng.gen_range(2..5);","counters":[]},{"line":"        let delay = rng.gen_range(0..=3);","counters":[]},{"line":"","counters":[]},{"line":"        let max_base_jobs = 2u64.pow(depth);","counters":[]},{"line":"","counters":[]},{"line":"        let mut s = ParallelScan::<i64, i64>::empty(max_base_jobs, delay);","counters":[]},{"line":"","counters":[]},{"line":"        let ndatas = rng.gen_range(2..=20);","counters":[]},{"line":"        let datas: Vec<Vec<i64>> = (1..ndatas)","counters":[]},{"line":"            .map(|_| {","counters":[]},{"line":"                std::iter::repeat_with(|| rng.gen())","counters":[]},{"line":"                    .take(max_base_jobs as usize)","counters":[]},{"line":"                    .collect()","counters":[]},{"line":"            })","counters":[]},{"line":"            .collect();","counters":[]},{"line":"","counters":[]},{"line":"        // let datas = vec![","counters":[]},{"line":"        //     // vec![-58823712978749242i64 as i64, 25103, 33363641, -1611555993190i64 as i64]","counters":[]},{"line":"        //     // std::iter::repeat_with(|| rng.gen_range(0..1000))","counters":[]},{"line":"        //     std::iter::repeat_with(|| rng.gen())","counters":[]},{"line":"        //     // std::iter::repeat_with(|| 1)","counters":[]},{"line":"        //         .take(max_base_jobs as usize)","counters":[]},{"line":"        //         .collect::<Vec<_>>()","counters":[]},{"line":"        // ];","counters":[]},{"line":"","counters":[]},{"line":"        for data in datas {","counters":[]},{"line":"            println!(\"ndata={}\", data.len());","counters":[]},{"line":"","counters":[]},{"line":"            let jobs = flatten(s.work_for_next_update(data.len() as u64));","counters":[]},{"line":"","counters":[]},{"line":"            let jobs_done: Vec<i64> = jobs.iter().map(&fun_job_done).collect();","counters":[]},{"line":"","counters":[]},{"line":"            println!(\"jobs_donea={}\", jobs_done.len());","counters":[]},{"line":"","counters":[]},{"line":"            let old_tuple = s.acc.clone();","counters":[]},{"line":"","counters":[]},{"line":"            let res_opt = s.update(data, jobs_done, |_| 0).unwrap();","counters":[]},{"line":"","counters":[]},{"line":"            if let Some(res) = res_opt {","counters":[]},{"line":"                let tuple = if old_tuple.is_some() {","counters":[]},{"line":"                    old_tuple","counters":[]},{"line":"                } else {","counters":[]},{"line":"                    s.acc.clone()","counters":[]},{"line":"                };","counters":[]},{"line":"","counters":[]},{"line":"                s.acc = fun_acc(tuple, res);","counters":[]},{"line":"            }","counters":[]},{"line":"            println!(\"s.acc.is_some={:?}\", s.acc.is_some());","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        s","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn fun_merge_up(","counters":[]},{"line":"        state: Option<(i64, Vec<i64>)>,","counters":[]},{"line":"        mut x: (i64, Vec<i64>),","counters":[]},{"line":"    ) -> Option<(i64, Vec<i64>)> {","counters":[]},{"line":"        let mut acc = state?;","counters":[]},{"line":"        acc.1.append(&mut x.1);","counters":[]},{"line":"        Some((acc.0.wrapping_add(x.0), acc.1))","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn job_done(job: &AvailableJob<i64, i64>) -> i64 {","counters":[]},{"line":"        match job {","counters":[]},{"line":"            AvailableJob::Base(x) => *x,","counters":[]},{"line":"            // AvailableJob::Merge { left, right } => left + right,","counters":[]},{"line":"            AvailableJob::Merge { left, right } => {","counters":[]},{"line":"                // let left = *left as i64;","counters":[]},{"line":"                // let right = *right as i64;","counters":[]},{"line":"                left.wrapping_add(*right)","counters":[]},{"line":"                // left + right","counters":[]},{"line":"            }","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// scan (+) over ints","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/parallel_scan/parallel_scan.ml#L1677","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn split_on_if_enqueuing_onto_the_next_queue() {","counters":[]},{"line":"        let mut rng = rand::thread_rng();","counters":[]},{"line":"","counters":[]},{"line":"        let p = 4;","counters":[]},{"line":"        let max_base_jobs = 2u64.pow(p);","counters":[]},{"line":"","counters":[]},{"line":"        for _ in 0..100000 {","counters":[]},{"line":"            let state = ParallelScan::<i64, i64>::empty(max_base_jobs, 1);","counters":[]},{"line":"            println!(\"hash_state={:?}\", hash(&state));","counters":[]},{"line":"            let i = rng.gen_range(0..max_base_jobs);","counters":[]},{"line":"","counters":[]},{"line":"            let data: Vec<i64> = (0..i as i64).collect();","counters":[]},{"line":"","counters":[]},{"line":"            let partition = state.partition_if_overflowing();","counters":[]},{"line":"            let jobs = flatten(state.work_for_next_update(data.len() as u64));","counters":[]},{"line":"","counters":[]},{"line":"            let jobs_done: Vec<i64> = jobs.iter().map(job_done).collect();","counters":[]},{"line":"","counters":[]},{"line":"            let tree_count_before = state.trees.len();","counters":[]},{"line":"","counters":[]},{"line":"            let (_, s) = test_update(&state, data, jobs_done);","counters":[]},{"line":"","counters":[]},{"line":"            println!(\"second={:?}\", partition.second.is_some());","counters":[]},{"line":"","counters":[]},{"line":"            match partition.second {","counters":[]},{"line":"                None => {","counters":[]},{"line":"                    let tree_count_after = s.trees.len();","counters":[]},{"line":"                    let expected_tree_count = if partition.first.0 == i {","counters":[]},{"line":"                        tree_count_before + 1","counters":[]},{"line":"                    } else {","counters":[]},{"line":"                        tree_count_before","counters":[]},{"line":"                    };","counters":[]},{"line":"                    assert_eq!(tree_count_after, expected_tree_count);","counters":[]},{"line":"                }","counters":[]},{"line":"                Some(_) => {","counters":[]},{"line":"                    let tree_count_after = s.trees.len();","counters":[]},{"line":"                    let expected_tree_count = if i > partition.first.0 {","counters":[]},{"line":"                        tree_count_before + 1","counters":[]},{"line":"                    } else {","counters":[]},{"line":"                        tree_count_before","counters":[]},{"line":"                    };","counters":[]},{"line":"                    assert_eq!(tree_count_after, expected_tree_count);","counters":[]},{"line":"                }","counters":[]},{"line":"            }","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/parallel_scan/parallel_scan.ml#L1722","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn sequence_number_reset() {","counters":[]},{"line":"        let p = 3;","counters":[]},{"line":"        let max_base_jobs = 2u64.pow(p);","counters":[]},{"line":"","counters":[]},{"line":"        let jobs = |state: &ParallelScan<i64, i64>| -> Vec<Vec<Job<base::Record<i64>, merge::Record<i64>>>> {","counters":[]},{"line":"            state.trees.iter().map(|t| t.jobs_records()).rev().collect()","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        let verify_sequence_number = |state: &ParallelScan<i64, i64>| {","counters":[]},{"line":"            let mut state = state.clone();","counters":[]},{"line":"            state.reset_seq_no();","counters":[]},{"line":"","counters":[]},{"line":"            let jobs_list = jobs(&state);","counters":[]},{"line":"","counters":[]},{"line":"            let depth = ceil_log2(max_base_jobs + 1);","counters":[]},{"line":"","counters":[]},{"line":"            for (i, jobs) in jobs_list.iter().enumerate() {","counters":[]},{"line":"                // each tree has jobs up till a level below the older tree","counters":[]},{"line":"                //  and have the following sequence numbers after reset","counters":[]},{"line":"                //             4","counters":[]},{"line":"                //         3       3","counters":[]},{"line":"                //       2   2   2   2","counters":[]},{"line":"                //      1 1 1 1 1 1 1 1","counters":[]},{"line":"","counters":[]},{"line":"                let cur_levels = depth - i as u64;","counters":[]},{"line":"","counters":[]},{"line":"                let seq_sum = (0..cur_levels).fold(0, |acc, j| {","counters":[]},{"line":"                    let j = j + i as u64;","counters":[]},{"line":"                    acc + (2u64.pow(j as u32) * (depth - j))","counters":[]},{"line":"                });","counters":[]},{"line":"","counters":[]},{"line":"                let offset = i as u64;","counters":[]},{"line":"","counters":[]},{"line":"                let sum_of_all_seq_numbers: u64 = jobs","counters":[]},{"line":"                    .iter()","counters":[]},{"line":"                    .map(|job| match job {","counters":[]},{"line":"                        Job::Base(base::Record { seq_no, .. }) => seq_no.0 - offset,","counters":[]},{"line":"                        Job::Merge(merge::Record { seq_no, .. }) => seq_no.0 - offset,","counters":[]},{"line":"                    })","counters":[]},{"line":"                    .sum();","counters":[]},{"line":"","counters":[]},{"line":"                dbg!(sum_of_all_seq_numbers, seq_sum);","counters":[]},{"line":"                assert_eq!(sum_of_all_seq_numbers, seq_sum);","counters":[]},{"line":"            }","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        let mut state = ParallelScan::<i64, i64>::empty(max_base_jobs, 0);","counters":[]},{"line":"        let mut counter = 0;","counters":[]},{"line":"","counters":[]},{"line":"        for _ in 0..50 {","counters":[]},{"line":"            let jobs = flatten(state.jobs_for_next_update());","counters":[]},{"line":"            let jobs_done: Vec<_> = jobs.iter().map(job_done).collect();","counters":[]},{"line":"            let data: Vec<i64> = (0..max_base_jobs as i64).collect();","counters":[]},{"line":"","counters":[]},{"line":"            let (res_opt, s) = test_update(&state, data, jobs_done);","counters":[]},{"line":"","counters":[]},{"line":"            state = s;","counters":[]},{"line":"","counters":[]},{"line":"            if res_opt.is_some() {","counters":[]},{"line":"                if counter > p {","counters":[]},{"line":"                    verify_sequence_number(&state);","counters":[]},{"line":"                } else {","counters":[]},{"line":"                    counter += 1;","counters":[]},{"line":"                }","counters":[]},{"line":"            };","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        assert_eq!(","counters":[]},{"line":"            hash(&state),","counters":[]},{"line":"            \"931a0dc0a488289000c195ae361138cc713deddc179b5d22bfa6344508d0cfb5\"","counters":[]},{"line":"        );","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn step_on_free_space<F, FAcc, B, M>(","counters":[]},{"line":"        state: &mut ParallelScan<B, M>,","counters":[]},{"line":"        w: &SyncSender<Option<(M, Vec<B>)>>,","counters":[]},{"line":"        mut ds: Vec<B>,","counters":[]},{"line":"        f: F,","counters":[]},{"line":"        f_acc: FAcc,","counters":[]},{"line":"    ) where","counters":[]},{"line":"        F: Fn(&AvailableJob<B, M>) -> M,","counters":[]},{"line":"        FAcc: Fn(Option<(M, Vec<B>)>, (M, Vec<B>)) -> Option<(M, Vec<B>)>,","counters":[]},{"line":"        B: Debug + Clone + 'static,","counters":[]},{"line":"        M: Debug + Clone + 'static,","counters":[]},{"line":"    {","counters":[]},{"line":"        loop {","counters":[]},{"line":"            let data = take(&ds, state.max_base_jobs as usize);","counters":[]},{"line":"","counters":[]},{"line":"            let jobs = flatten(state.work_for_next_update(data.len() as u64));","counters":[]},{"line":"            let jobs_done: Vec<_> = jobs.iter().map(&f).collect();","counters":[]},{"line":"","counters":[]},{"line":"            let old_tuple = state.acc.clone();","counters":[]},{"line":"","counters":[]},{"line":"            let (res_opt, mut s) = test_update(state, data.to_vec(), jobs_done);","counters":[]},{"line":"","counters":[]},{"line":"            let s = match res_opt {","counters":[]},{"line":"                Some(x) => {","counters":[]},{"line":"                    let tuple = if old_tuple.is_some() {","counters":[]},{"line":"                        f_acc(old_tuple, x)","counters":[]},{"line":"                    } else {","counters":[]},{"line":"                        s.acc.clone()","counters":[]},{"line":"                    };","counters":[]},{"line":"                    s.acc = tuple;","counters":[]},{"line":"                    s","counters":[]},{"line":"                }","counters":[]},{"line":"                None => s,","counters":[]},{"line":"            };","counters":[]},{"line":"","counters":[]},{"line":"            w.send(s.acc.clone()).unwrap();","counters":[]},{"line":"","counters":[]},{"line":"            *state = s;","counters":[]},{"line":"","counters":[]},{"line":"            let rem_ds = ds.get(state.max_base_jobs as usize..).unwrap_or(&[]);","counters":[]},{"line":"","counters":[]},{"line":"            if rem_ds.is_empty() {","counters":[]},{"line":"                return;","counters":[]},{"line":"            } else {","counters":[]},{"line":"                ds = rem_ds.to_vec();","counters":[]},{"line":"            }","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn do_steps<F, FAcc, B, M>(","counters":[]},{"line":"        state: &mut ParallelScan<B, M>,","counters":[]},{"line":"        recv: &Receiver<B>,","counters":[]},{"line":"        f: F,","counters":[]},{"line":"        f_acc: FAcc,","counters":[]},{"line":"        w: SyncSender<Option<(M, Vec<B>)>>,","counters":[]},{"line":"    ) where","counters":[]},{"line":"        F: Fn(&AvailableJob<B, M>) -> M,","counters":[]},{"line":"        FAcc: Fn(Option<(M, Vec<B>)>, (M, Vec<B>)) -> Option<(M, Vec<B>)>,","counters":[]},{"line":"        B: Debug + Clone + 'static,","counters":[]},{"line":"        M: Debug + Clone + 'static,","counters":[]},{"line":"    {","counters":[]},{"line":"        let data = recv.recv().unwrap();","counters":[]},{"line":"        step_on_free_space(state, &w, vec![data], &f, &f_acc);","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn scan<F, FAcc, B, M>(","counters":[]},{"line":"        s: &mut ParallelScan<B, M>,","counters":[]},{"line":"        data: &Receiver<B>,","counters":[]},{"line":"        f: F,","counters":[]},{"line":"        f_acc: FAcc,","counters":[]},{"line":"    ) -> Receiver<Option<(M, Vec<B>)>>","counters":[]},{"line":"    where","counters":[]},{"line":"        F: Fn(&AvailableJob<B, M>) -> M,","counters":[]},{"line":"        FAcc: Fn(Option<(M, Vec<B>)>, (M, Vec<B>)) -> Option<(M, Vec<B>)>,","counters":[]},{"line":"        B: Debug + Clone + 'static,","counters":[]},{"line":"        M: Debug + Clone + 'static,","counters":[]},{"line":"    {","counters":[]},{"line":"        let (send, rec) = std::sync::mpsc::sync_channel::<Option<(M, Vec<B>)>>(1);","counters":[]},{"line":"        do_steps(s, data, f, f_acc, send);","counters":[]},{"line":"        rec","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn step_repeatedly<F, FAcc, B, M>(","counters":[]},{"line":"        state: &mut ParallelScan<B, M>,","counters":[]},{"line":"        data: &Receiver<B>,","counters":[]},{"line":"        f: F,","counters":[]},{"line":"        f_acc: FAcc,","counters":[]},{"line":"    ) -> Receiver<Option<(M, Vec<B>)>>","counters":[]},{"line":"    where","counters":[]},{"line":"        F: Fn(&AvailableJob<B, M>) -> M,","counters":[]},{"line":"        FAcc: Fn(Option<(M, Vec<B>)>, (M, Vec<B>)) -> Option<(M, Vec<B>)>,","counters":[]},{"line":"        B: Debug + Clone + 'static,","counters":[]},{"line":"        M: Debug + Clone + 'static,","counters":[]},{"line":"    {","counters":[]},{"line":"        let (send, rec) = std::sync::mpsc::sync_channel::<Option<(M, Vec<B>)>>(1);","counters":[]},{"line":"        do_steps(state, data, f, f_acc, send);","counters":[]},{"line":"        rec","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/parallel_scan/parallel_scan.ml#L1803","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn scan_can_be_initialized_from_intermediate_state() {","counters":[]},{"line":"        for _ in 0..10 {","counters":[]},{"line":"            let mut state = gen(job_done, fun_merge_up);","counters":[]},{"line":"","counters":[]},{"line":"            println!(\"state={:#?}\", state);","counters":[]},{"line":"","counters":[]},{"line":"            let do_one_next = Arc::new(AtomicBool::new(false));","counters":[]},{"line":"","counters":[]},{"line":"            let do_one_next_clone = Arc::clone(&do_one_next);","counters":[]},{"line":"            let (send, recv) = sync_channel(1);","counters":[]},{"line":"","counters":[]},{"line":"            std::thread::spawn(move || loop {","counters":[]},{"line":"                let v = if do_one_next_clone.load(Relaxed) {","counters":[]},{"line":"                    do_one_next_clone.store(false, Relaxed);","counters":[]},{"line":"                    1i64","counters":[]},{"line":"                } else {","counters":[]},{"line":"                    0i64","counters":[]},{"line":"                };","counters":[]},{"line":"                if send.send(v).is_err() {","counters":[]},{"line":"                    return;","counters":[]},{"line":"                }","counters":[]},{"line":"            });","counters":[]},{"line":"","counters":[]},{"line":"            let one_then_zeros = recv;","counters":[]},{"line":"","counters":[]},{"line":"            let parallelism = state.max_base_jobs * ceil_log2(state.max_base_jobs);","counters":[]},{"line":"            let old_acc = state.acc.as_ref().cloned().unwrap_or((0, vec![]));","counters":[]},{"line":"","counters":[]},{"line":"            let fill_some_zero =","counters":[]},{"line":"                |state: &mut ParallelScan<i64, i64>, v: i64, r: &Receiver<i64>| -> i64 {","counters":[]},{"line":"                    (0..parallelism * parallelism).fold(v, |acc, _| {","counters":[]},{"line":"                        let pipe = step_repeatedly(state, r, job_done, fun_merge_up);","counters":[]},{"line":"","counters":[]},{"line":"                        match pipe.recv() {","counters":[]},{"line":"                            Ok(Some((v, _))) => v,","counters":[]},{"line":"                            Ok(None) => acc,","counters":[]},{"line":"                            Err(_) => acc,","counters":[]},{"line":"                        }","counters":[]},{"line":"                    })","counters":[]},{"line":"                };","counters":[]},{"line":"","counters":[]},{"line":"            let v = fill_some_zero(&mut state, 0, &one_then_zeros);","counters":[]},{"line":"","counters":[]},{"line":"            do_one_next.store(true, Relaxed);","counters":[]},{"line":"","counters":[]},{"line":"            let acc = { state.acc.clone().unwrap() };","counters":[]},{"line":"","counters":[]},{"line":"            assert_ne!(acc.0, old_acc.0);","counters":[]},{"line":"","counters":[]},{"line":"            fill_some_zero(&mut state, v, &one_then_zeros);","counters":[]},{"line":"","counters":[]},{"line":"            let acc_plus_one = { state.acc.unwrap() };","counters":[]},{"line":"            assert_eq!(acc_plus_one.0, acc.0.wrapping_add(1));","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// scan (+) over ints, map from string","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/parallel_scan/parallel_scan.ml#L1879","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn scan_behaves_like_a_fold_long_term() {","counters":[]},{"line":"        fn fun_merge_up(","counters":[]},{"line":"            tuple: Option<(i64, Vec<String>)>,","counters":[]},{"line":"            mut x: (i64, Vec<String>),","counters":[]},{"line":"        ) -> Option<(i64, Vec<String>)> {","counters":[]},{"line":"            let mut acc = tuple?;","counters":[]},{"line":"            acc.1.append(&mut x.1);","counters":[]},{"line":"","counters":[]},{"line":"            Some((acc.0.wrapping_add(x.0), acc.1))","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        fn job_done(job: &AvailableJob<String, i64>) -> i64 {","counters":[]},{"line":"            match job {","counters":[]},{"line":"                AvailableJob::Base(x) => x.parse().unwrap(),","counters":[]},{"line":"                AvailableJob::Merge { left, right } => left.wrapping_add(*right),","counters":[]},{"line":"            }","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        let (send, recv) = sync_channel(1);","counters":[]},{"line":"","counters":[]},{"line":"        let depth = 7;","counters":[]},{"line":"        let count: i64 = 1000;","counters":[]},{"line":"","counters":[]},{"line":"        std::thread::spawn(move || {","counters":[]},{"line":"            let mut count = count;","counters":[]},{"line":"            let x = count;","counters":[]},{"line":"            loop {","counters":[]},{"line":"                let next = if count <= 0 {","counters":[]},{"line":"                    \"0\".to_string()","counters":[]},{"line":"                } else {","counters":[]},{"line":"                    (x - count).to_string()","counters":[]},{"line":"                };","counters":[]},{"line":"","counters":[]},{"line":"                count -= 1;","counters":[]},{"line":"","counters":[]},{"line":"                if send.send(next).is_err() {","counters":[]},{"line":"                    return;","counters":[]},{"line":"                }","counters":[]},{"line":"            }","counters":[]},{"line":"        });","counters":[]},{"line":"","counters":[]},{"line":"        let mut s = ParallelScan::<String, i64>::empty(2u64.pow(depth as u32), 1);","counters":[]},{"line":"","counters":[]},{"line":"        let after_3n = (0..4 * count).fold(0i64, |acc, _| {","counters":[]},{"line":"            let result = scan(&mut s, &recv, job_done, fun_merge_up);","counters":[]},{"line":"            match result.recv() {","counters":[]},{"line":"                Ok(Some((v, _))) => v,","counters":[]},{"line":"                Ok(None) => acc,","counters":[]},{"line":"                Err(_) => acc,","counters":[]},{"line":"            }","counters":[]},{"line":"        });","counters":[]},{"line":"","counters":[]},{"line":"        let expected = (0..count).fold(0i64, |a, b| a.wrapping_add(b));","counters":[]},{"line":"","counters":[]},{"line":"        assert_eq!(after_3n, expected);","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// scan performs operation in correct order with \\","counters":[]},{"line":"    /// non-commutative semigroup","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/parallel_scan/parallel_scan.ml#L1917","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn scan_concat_over_strings() {","counters":[]},{"line":"        fn fun_merge_up(","counters":[]},{"line":"            tuple: Option<(String, Vec<String>)>,","counters":[]},{"line":"            mut x: (String, Vec<String>),","counters":[]},{"line":"        ) -> Option<(String, Vec<String>)> {","counters":[]},{"line":"            let mut acc = tuple?;","counters":[]},{"line":"            acc.1.append(&mut x.1);","counters":[]},{"line":"","counters":[]},{"line":"            Some((format!(\"{}{}\", acc.0, x.0), acc.1))","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        fn job_done(job: &AvailableJob<String, String>) -> String {","counters":[]},{"line":"            match job {","counters":[]},{"line":"                AvailableJob::Base(x) => x.clone(),","counters":[]},{"line":"                AvailableJob::Merge { left, right } => {","counters":[]},{"line":"                    format!(\"{}{}\", left, right)","counters":[]},{"line":"                }","counters":[]},{"line":"            }","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        let (send, recv) = sync_channel(1);","counters":[]},{"line":"","counters":[]},{"line":"        let depth = 7;","counters":[]},{"line":"        let count: i64 = 100;","counters":[]},{"line":"","counters":[]},{"line":"        std::thread::spawn(move || {","counters":[]},{"line":"            let mut count = count;","counters":[]},{"line":"            let x = count;","counters":[]},{"line":"            loop {","counters":[]},{"line":"                let next = if count <= 0 {","counters":[]},{"line":"                    \"\".to_string()","counters":[]},{"line":"                } else {","counters":[]},{"line":"                    let n = (x - count).to_string();","counters":[]},{"line":"                    format!(\"{},\", n)","counters":[]},{"line":"                };","counters":[]},{"line":"","counters":[]},{"line":"                count -= 1;","counters":[]},{"line":"","counters":[]},{"line":"                if send.send(next).is_err() {","counters":[]},{"line":"                    return;","counters":[]},{"line":"                }","counters":[]},{"line":"            }","counters":[]},{"line":"        });","counters":[]},{"line":"","counters":[]},{"line":"        let mut s = ParallelScan::<String, String>::empty(2u64.pow(depth as u32), 1);","counters":[]},{"line":"","counters":[]},{"line":"        let after_3n = (0..42 * count).fold(String::new(), |acc, _| {","counters":[]},{"line":"            let result = scan(&mut s, &recv, job_done, fun_merge_up);","counters":[]},{"line":"            match result.recv() {","counters":[]},{"line":"                Ok(Some((v, _))) => v,","counters":[]},{"line":"                Ok(None) => acc,","counters":[]},{"line":"                Err(_) => acc,","counters":[]},{"line":"            }","counters":[]},{"line":"        });","counters":[]},{"line":"","counters":[]},{"line":"        let expected = (0..count)","counters":[]},{"line":"            .map(|i| format!(\"{},\", i))","counters":[]},{"line":"            .fold(String::new(), |a, b| format!(\"{}{}\", a, b));","counters":[]},{"line":"","counters":[]},{"line":"        assert_eq!(after_3n, expected);","counters":[]},{"line":"    }","counters":[]},{"line":"}","counters":[]}]}