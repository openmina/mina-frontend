{"filename":"src/lib/crypto/kimchi_backend/common/plonk_dlog_proof.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Async_kernel","counters":[]},{"line":"open Pickles_types","counters":[]},{"line":"","counters":[]},{"line":"let tuple15_to_vec","counters":[]},{"line":"    (w0, w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, w11, w12, w13, w14) =","counters":[]},{"line":"  Vector.[ w0; w1; w2; w3; w4; w5; w6; w7; w8; w9; w10; w11; w12; w13; w14 ]","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let tuple15_of_vec","counters":[]},{"line":"    Vector.[ w0; w1; w2; w3; w4; w5; w6; w7; w8; w9; w10; w11; w12; w13; w14 ] =","counters":[]},{"line":"  (w0, w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, w11, w12, w13, w14)","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let tuple6_to_vec (w0, w1, w2, w3, w4, w5) = Vector.[ w0; w1; w2; w3; w4; w5 ]","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"","counters":[]},{"line":"let tuple6_of_vec Vector.[ w0; w1; w2; w3; w4; w5 ] = (w0, w1, w2, w3, w4, w5)","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"","counters":[]},{"line":"module type Stable_v1 = sig","counters":[]},{"line":"  module Stable : sig","counters":[]},{"line":"    module V1 : sig","counters":[]},{"line":"      type t [@@deriving version, bin_io, sexp, compare, yojson, hash, equal]","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Latest = V1","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  type t = Stable.V1.t [@@deriving sexp, compare, yojson]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type Inputs_intf = sig","counters":[]},{"line":"  open Intf","counters":[]},{"line":"","counters":[]},{"line":"  val id : string","counters":[]},{"line":"","counters":[]},{"line":"  module Scalar_field : sig","counters":[]},{"line":"    include Stable_v1","counters":[]},{"line":"","counters":[]},{"line":"    val one : t","counters":[]},{"line":"","counters":[]},{"line":"    module Vector : Snarky_intf.Vector.S with type elt = t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Base_field : sig","counters":[]},{"line":"    type t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Curve : sig","counters":[]},{"line":"    module Affine : sig","counters":[]},{"line":"      include Stable_v1 with type Stable.V1.t = Base_field.t * Base_field.t","counters":[]},{"line":"","counters":[]},{"line":"      module Backend : sig","counters":[]},{"line":"        type t = Base_field.t Kimchi_types.or_infinity","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      val of_backend :","counters":[]},{"line":"        Backend.t -> (Base_field.t * Base_field.t) Pickles_types.Or_infinity.t","counters":[]},{"line":"","counters":[]},{"line":"      val to_backend :","counters":[]},{"line":"        (Base_field.t * Base_field.t) Pickles_types.Or_infinity.t -> Backend.t","counters":[]},{"line":"    end","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Poly_comm : sig","counters":[]},{"line":"    type t = Base_field.t Poly_comm.t","counters":[]},{"line":"","counters":[]},{"line":"    module Backend : sig","counters":[]},{"line":"      type t = Curve.Affine.Backend.t Kimchi_types.poly_comm","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    val of_backend_with_degree_bound : Backend.t -> t","counters":[]},{"line":"","counters":[]},{"line":"    val of_backend_without_degree_bound : Backend.t -> t","counters":[]},{"line":"","counters":[]},{"line":"    val to_backend : t -> Backend.t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Opening_proof_backend : sig","counters":[]},{"line":"    type t = (Curve.Affine.Backend.t, Scalar_field.t) Kimchi_types.opening_proof","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Evaluations_backend : sig","counters":[]},{"line":"    type t = Scalar_field.t Kimchi_types.proof_evaluations","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Index : sig","counters":[]},{"line":"    type t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Verifier_index : sig","counters":[]},{"line":"    type t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Backend : sig","counters":[]},{"line":"    type t = (Curve.Affine.Backend.t, Scalar_field.t) Kimchi_types.prover_proof","counters":[]},{"line":"","counters":[]},{"line":"    val create :","counters":[]},{"line":"         Index.t","counters":[]},{"line":"      -> Scalar_field.Vector.t","counters":[]},{"line":"      -> Scalar_field.Vector.t","counters":[]},{"line":"      -> Scalar_field.t array","counters":[]},{"line":"      -> Curve.Affine.Backend.t array","counters":[]},{"line":"      -> t","counters":[]},{"line":"","counters":[]},{"line":"    val create_async :","counters":[]},{"line":"         Index.t","counters":[]},{"line":"      -> Scalar_field.Vector.t","counters":[]},{"line":"      -> Scalar_field.Vector.t","counters":[]},{"line":"      -> Scalar_field.t array","counters":[]},{"line":"      -> Curve.Affine.Backend.t array","counters":[]},{"line":"      -> t Promise.t","counters":[]},{"line":"","counters":[]},{"line":"    val verify : Verifier_index.t -> t -> bool","counters":[]},{"line":"","counters":[]},{"line":"    val batch_verify : Verifier_index.t array -> t array -> bool Promise.t","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Challenge_polynomial = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type ('g, 'fq) t = { challenges : 'fq array; commitment : 'g }","counters":[{"col_start":6,"col_end":6,"count":2},{"col_start":21,"col_end":21,"count":10},{"col_start":27,"col_end":27,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":48,"col_end":48,"count":0},{"col_start":51,"col_end":51,"count":0},{"col_start":60,"col_end":60,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"      [@@deriving version, bin_io, sexp, compare, yojson]","counters":[{"col_start":56,"col_end":56,"count":6}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make (Inputs : Inputs_intf) = struct","counters":[]},{"line":"  open Inputs","counters":[]},{"line":"  module Backend = Backend","counters":[]},{"line":"  module Fq = Scalar_field","counters":[]},{"line":"  module G = Curve","counters":[]},{"line":"","counters":[]},{"line":"  module Challenge_polynomial = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type t =","counters":[{"col_start":8,"col_end":8,"count":4},{"col_start":13,"col_end":13,"count":2}]},{"line":"          ( G.Affine.Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":12,"col_end":12,"count":0}]},{"line":"          , Fq.Stable.V1.t )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          Challenge_polynomial.Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        [@@deriving sexp, compare, yojson]","counters":[{"col_start":41,"col_end":41,"count":10}]},{"line":"","counters":[]},{"line":"        let to_latest = Fn.id","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    type ('g, 'fq) t_ = ('g, 'fq) Challenge_polynomial.t =","counters":[]},{"line":"      { challenges : 'fq array; commitment : 'g }","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  type message = Challenge_polynomial.t list","counters":[]},{"line":"","counters":[]},{"line":"  let hash_fold_array f s x = hash_fold_list f s (Array.to_list x)","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V2 = struct","counters":[]},{"line":"      module T = struct","counters":[{"col_start":6,"col_end":6,"count":4}]},{"line":"        type t =","counters":[{"col_start":8,"col_end":8,"count":2},{"col_start":13,"col_end":13,"count":2}]},{"line":"          ( G.Affine.Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":12,"col_end":12,"count":0}]},{"line":"          , Fq.Stable.V1.t","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          , Fq.Stable.V1.t array )","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"          Pickles_types.Plonk_types.Proof.Stable.V2.t","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        [@@deriving compare, sexp, yojson, hash, equal]","counters":[]},{"line":"","counters":[]},{"line":"        let id = \"plong_dlog_proof_\" ^ Inputs.id","counters":[]},{"line":"","counters":[]},{"line":"        type 'a creator =","counters":[]},{"line":"             messages:G.Affine.t Pickles_types.Plonk_types.Messages.Stable.V2.t","counters":[]},{"line":"          -> openings:","counters":[]},{"line":"               ( G.Affine.t","counters":[]},{"line":"               , Fq.t","counters":[]},{"line":"               , Fq.t array )","counters":[]},{"line":"               Pickles_types.Plonk_types.Openings.Stable.V2.t","counters":[]},{"line":"          -> 'a","counters":[]},{"line":"","counters":[]},{"line":"        let map_creator c ~f ~messages ~openings = f (c ~messages ~openings)","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"","counters":[]},{"line":"        let create ~messages ~openings =","counters":[]},{"line":"          let open Pickles_types.Plonk_types.Proof in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          { messages; openings }","counters":[]},{"line":"      end","counters":[{"col_start":8,"col_end":8,"count":10}]},{"line":"","counters":[]},{"line":"      include T","counters":[]},{"line":"","counters":[]},{"line":"      include (","counters":[]},{"line":"        Allocation_functor.Make.Full","counters":[]},{"line":"          (T) :","counters":[]},{"line":"            Allocation_functor.Intf.Output.Full_intf","counters":[]},{"line":"              with type t := t","counters":[]},{"line":"               and type 'a creator := 'a creator )","counters":[]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  include (","counters":[]},{"line":"    Stable.Latest :","counters":[]},{"line":"      sig","counters":[]},{"line":"        type t [@@deriving compare, sexp, yojson, hash, equal, bin_io]","counters":[]},{"line":"      end","counters":[]},{"line":"      with type t := t )","counters":[]},{"line":"","counters":[]},{"line":"  [%%define_locally Stable.Latest.(create)]","counters":[]},{"line":"","counters":[]},{"line":"  let g t f = G.Affine.of_backend (f t)","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"  let fq_array_to_vec arr =","counters":[]},{"line":"    let vec = Fq.Vector.create () in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Array.iter arr ~f:(fun fe -> Fq.Vector.emplace_back vec fe) ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"    vec","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  (** Note that this function will panic if any of the points are points at infinity *)","counters":[]},{"line":"  let opening_proof_of_backend_exn (t : Opening_proof_backend.t) =","counters":[]},{"line":"    let g (x : G.Affine.Backend.t) : G.Affine.t =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      G.Affine.of_backend x |> Pickles_types.Or_infinity.finite_exn","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"    in","counters":[]},{"line":"    let gpair ((g1, g2) : G.Affine.Backend.t * G.Affine.Backend.t) :","counters":[]},{"line":"        G.Affine.t * G.Affine.t =","counters":[]},{"line":"      (g g1, g g2)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":7,"col_end":7,"count":0},{"col_start":13,"col_end":13,"count":0}]},{"line":"    in","counters":[]},{"line":"    { Pickles_types.Plonk_types.Openings.Bulletproof.lr =","counters":[]},{"line":"        Array.map ~f:gpair t.lr","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"    ; z_1 = t.z1","counters":[]},{"line":"    ; z_2 = t.z2","counters":[]},{"line":"    ; delta = g t.delta","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"    ; challenge_polynomial_commitment = g t.sg","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let of_backend (t : Backend.t) : t =","counters":[]},{"line":"    let proof = opening_proof_of_backend_exn t.proof in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let e1, e2 = t.evals in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let evals =","counters":[]},{"line":"      let open Pickles_types.Plonk_types.Evals in","counters":[]},{"line":"      { w = Vector.zip (tuple15_to_vec e1.w) (tuple15_to_vec e2.w)","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"      ; s = Vector.zip (tuple6_to_vec e1.s) (tuple6_to_vec e2.s)","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"      ; z = (e1.z, e2.z)","counters":[]},{"line":"      ; generic_selector = (e1.generic_selector, e2.generic_selector)","counters":[]},{"line":"      ; poseidon_selector = (e1.poseidon_selector, e2.poseidon_selector)","counters":[]},{"line":"      ; lookup =","counters":[]},{"line":"          Option.map2 e1.lookup e2.lookup ~f:(fun l1 l2 ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"              { Lookup.aggreg = (l1.aggreg, l2.aggreg)","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              ; table = (l1.table, l2.table)","counters":[]},{"line":"              ; sorted = Array.map2_exn l1.sorted l2.sorted ~f:Tuple2.create","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"              ; runtime = Option.map2 l1.runtime l2.runtime ~f:Tuple2.create","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"              } )","counters":[]},{"line":"      }","counters":[]},{"line":"    in","counters":[]},{"line":"    let wo x : Inputs.Curve.Affine.t array =","counters":[]},{"line":"      match Poly_comm.of_backend_without_degree_bound x with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | `Without_degree_bound gs ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          gs","counters":[]},{"line":"      | _ ->","counters":[]},{"line":"          assert false","counters":[]},{"line":"    in","counters":[]},{"line":"    let w_comm =","counters":[]},{"line":"      tuple15_to_vec t.commitments.w_comm |> Pickles_types.Vector.map ~f:wo","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"    in","counters":[]},{"line":"    create","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ~messages:","counters":[]},{"line":"        { w_comm","counters":[]},{"line":"        ; z_comm = wo t.commitments.z_comm","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"        ; t_comm = wo t.commitments.t_comm","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"        ; lookup =","counters":[]},{"line":"            Option.map t.commitments.lookup","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"              ~f:(fun l : _ Pickles_types.Plonk_types.Messages.Lookup.t ->","counters":[]},{"line":"                { sorted = Array.map ~f:wo l.sorted","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"                ; aggreg = wo l.aggreg","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                ; runtime = Option.map ~f:wo l.runtime","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                } )","counters":[]},{"line":"        }","counters":[]},{"line":"      ~openings:{ proof; evals; ft_eval1 = t.ft_eval1 }","counters":[]},{"line":"","counters":[]},{"line":"  let lookup_eval_to_backend","counters":[]},{"line":"      { Pickles_types.Plonk_types.Evals.Lookup.sorted; aggreg; table; runtime }","counters":[]},{"line":"      : 'f Kimchi_types.lookup_evaluations =","counters":[]},{"line":"    { sorted; aggreg; table; runtime }","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let eval_to_backend","counters":[]},{"line":"      { Pickles_types.Plonk_types.Evals.w","counters":[]},{"line":"      ; z","counters":[]},{"line":"      ; s","counters":[]},{"line":"      ; generic_selector","counters":[]},{"line":"      ; poseidon_selector","counters":[]},{"line":"      ; lookup","counters":[]},{"line":"      } : Evaluations_backend.t =","counters":[]},{"line":"    { w = tuple15_of_vec w","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"    ; z","counters":[]},{"line":"    ; s = tuple6_of_vec s","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"    ; generic_selector","counters":[]},{"line":"    ; poseidon_selector","counters":[]},{"line":"    ; lookup = Option.map ~f:lookup_eval_to_backend lookup","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let vec_to_array (type t elt)","counters":[]},{"line":"      (module V : Snarky_intf.Vector.S with type t = t and type elt = elt)","counters":[]},{"line":"      (v : t) =","counters":[]},{"line":"    Array.init (V.length v) ~f:(V.get v)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"","counters":[]},{"line":"  let to_backend' (chal_polys : Challenge_polynomial.t list) primary_input","counters":[]},{"line":"      ({ messages = { w_comm; z_comm; t_comm; lookup }","counters":[]},{"line":"       ; openings =","counters":[]},{"line":"           { proof = { lr; z_1; z_2; delta; challenge_polynomial_commitment }","counters":[]},{"line":"           ; evals","counters":[]},{"line":"           ; ft_eval1","counters":[]},{"line":"           }","counters":[]},{"line":"       } :","counters":[]},{"line":"        t ) : Backend.t =","counters":[]},{"line":"    let g x = G.Affine.to_backend (Pickles_types.Or_infinity.Finite x) in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":14,"col_end":14,"count":0}]},{"line":"    let pcwo t = Poly_comm.to_backend (`Without_degree_bound t) in","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"    let lr = Array.map lr ~f:(fun (x, y) -> (g x, g y)) in","counters":[{"col_start":44,"col_end":44,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"    { commitments =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        { w_comm = tuple15_of_vec (Pickles_types.Vector.map ~f:pcwo w_comm)","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"        ; z_comm = pcwo z_comm","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"        ; t_comm = pcwo t_comm","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"        ; lookup =","counters":[]},{"line":"            Option.map lookup ~f:(fun t : _ Kimchi_types.lookup_commitments ->","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                { sorted = Array.map ~f:pcwo t.sorted","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"                ; aggreg = pcwo t.aggreg","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                ; runtime = Option.map ~f:pcwo t.runtime","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                } )","counters":[]},{"line":"        }","counters":[]},{"line":"    ; proof =","counters":[]},{"line":"        { lr","counters":[]},{"line":"        ; delta = g delta","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"        ; z1 = z_1","counters":[]},{"line":"        ; z2 = z_2","counters":[]},{"line":"        ; sg = g challenge_polynomial_commitment","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"        }","counters":[]},{"line":"    ; evals =","counters":[]},{"line":"        ( eval_to_backend (Plonk_types.Evals.map ~f:fst evals)","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"        , eval_to_backend (Plonk_types.Evals.map ~f:snd evals) )","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"    ; ft_eval1","counters":[]},{"line":"    ; public = primary_input","counters":[]},{"line":"    ; prev_challenges =","counters":[]},{"line":"        Array.of_list_map chal_polys","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"          ~f:(fun { Challenge_polynomial.commitment = x, y; challenges } ->","counters":[]},{"line":"            { Kimchi_types.chals = challenges","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            ; comm =","counters":[]},{"line":"                { Kimchi_types.shifted = None","counters":[]},{"line":"                ; unshifted = [| Kimchi_types.Finite (x, y) |]","counters":[]},{"line":"                }","counters":[]},{"line":"            } )","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let to_backend chal_polys primary_input t =","counters":[]},{"line":"    to_backend' chal_polys (List.to_array primary_input) t","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"  let create ?message pk ~primary ~auxiliary =","counters":[]},{"line":"    let chal_polys =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      match (message : message option) with Some s -> s | None -> []","counters":[{"col_start":44,"col_end":44,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"    in","counters":[]},{"line":"    let challenges =","counters":[]},{"line":"      List.map chal_polys ~f:(fun { Challenge_polynomial.challenges; _ } ->","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"          challenges )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"      |> Array.concat","counters":[]},{"line":"    in","counters":[]},{"line":"    let commitments =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Array.of_list_map chal_polys","counters":[]},{"line":"        ~f:(fun { Challenge_polynomial.commitment; _ } ->","counters":[]},{"line":"          G.Affine.to_backend (Finite commitment) )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    in","counters":[]},{"line":"    let res = Backend.create pk primary auxiliary challenges commitments in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    of_backend res","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let create_async ?message pk ~primary ~auxiliary =","counters":[]},{"line":"    let chal_polys =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      match (message : message option) with Some s -> s | None -> []","counters":[{"col_start":44,"col_end":44,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"    in","counters":[]},{"line":"    let challenges =","counters":[]},{"line":"      List.map chal_polys ~f:(fun { Challenge_polynomial.challenges; _ } ->","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"          challenges )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"      |> Array.concat","counters":[]},{"line":"    in","counters":[]},{"line":"    let commitments =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Array.of_list_map chal_polys","counters":[]},{"line":"        ~f:(fun { Challenge_polynomial.commitment; _ } ->","counters":[]},{"line":"          G.Affine.to_backend (Finite commitment) )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    in","counters":[]},{"line":"    let%map.Promise res =","counters":[]},{"line":"      Backend.create_async pk primary auxiliary challenges commitments","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"    in","counters":[]},{"line":"    of_backend res","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let batch_verify' (conv : 'a -> Fq.t array)","counters":[]},{"line":"      (ts : (Verifier_index.t * t * 'a * message option) list) =","counters":[]},{"line":"    let vks_and_v =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Array.of_list_map ts ~f:(fun (vk, t, xs, m) ->","counters":[]},{"line":"          let p = to_backend' (Option.value ~default:[] m) (conv xs) t in","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":42,"col_end":42,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"          (vk, p) )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    in","counters":[]},{"line":"    Backend.batch_verify","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (Array.map ~f:fst vks_and_v)","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"      (Array.map ~f:snd vks_and_v)","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"","counters":[]},{"line":"  let batch_verify = batch_verify' (fun xs -> List.to_array xs)","counters":[{"col_start":33,"col_end":33,"count":2},{"col_start":46,"col_end":46,"count":0}]},{"line":"","counters":[]},{"line":"  let verify ?message t vk xs : bool =","counters":[]},{"line":"    Backend.verify vk","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (to_backend'","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"         (Option.value ~default:[] message)","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"         (vec_to_array (module Scalar_field.Vector) xs)","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"         t )","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}