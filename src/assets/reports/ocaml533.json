{"filename":"src/lib/pickles/wrap_main_inputs.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Common","counters":[]},{"line":"open Backend","counters":[]},{"line":"module Me = Tock","counters":[]},{"line":"module Other = Tick","counters":[]},{"line":"module Impl = Impls.Wrap","counters":[]},{"line":"open Pickles_types","counters":[]},{"line":"open Import","counters":[]},{"line":"","counters":[]},{"line":"let high_entropy_bits = 128","counters":[]},{"line":"","counters":[]},{"line":"let sponge_params_constant =","counters":[]},{"line":"  Sponge.Params.(map pasta_q_kimchi ~f:Impl.Field.Constant.of_string)","counters":[{"col_start":19,"col_end":19,"count":1}]},{"line":"","counters":[]},{"line":"let field_random_oracle ?(length = Me.Field.size_in_bits - 1) s =","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"  Me.Field.of_bits (Ro.bits_random_oracle ~length s)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"let unrelated_g =","counters":[]},{"line":"  let group_map =","counters":[]},{"line":"    unstage","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"      (group_map","counters":[{"col_start":15,"col_end":15,"count":1}]},{"line":"         (module Me.Field)","counters":[]},{"line":"         ~a:Me.Inner_curve.Params.a ~b:Me.Inner_curve.Params.b )","counters":[]},{"line":"  and str = Fn.compose bits_to_bytes Me.Field.to_bits in","counters":[{"col_start":21,"col_end":21,"count":1}]},{"line":"  fun (x, y) -> group_map (field_random_oracle (str x ^ str y))","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":50,"col_end":50,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"","counters":[]},{"line":"open Impl","counters":[]},{"line":"","counters":[]},{"line":"module Other_field = struct","counters":[]},{"line":"  type t = Impls.Step.Field.Constant.t [@@deriving sexp]","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"  include (Tick.Field : module type of Tick.Field with type t := t)","counters":[]},{"line":"","counters":[]},{"line":"  let size = Impls.Step.Bigint.to_bignum_bigint size","counters":[{"col_start":46,"col_end":46,"count":1}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let sponge_params =","counters":[]},{"line":"  Sponge.Params.(map sponge_params_constant ~f:Impl.Field.constant)","counters":[{"col_start":19,"col_end":19,"count":1}]},{"line":"","counters":[]},{"line":"module Unsafe = struct","counters":[]},{"line":"  let unpack_unboolean ?(length = Field.size_in_bits) x =","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"    let res =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      exists","counters":[]},{"line":"        (Typ.list Boolean.typ_unchecked ~length)","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"        ~compute:","counters":[]},{"line":"          As_prover.(","counters":[]},{"line":"            fun () -> List.take (Field.Constant.unpack (read_var x)) length)","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":53,"col_end":53,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"    in","counters":[]},{"line":"    Field.Assert.equal x (Field.project res) ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"    res","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Sponge = struct","counters":[]},{"line":"  module Permutation =","counters":[]},{"line":"    Sponge_inputs.Make","counters":[]},{"line":"      (Impl)","counters":[]},{"line":"      (struct","counters":[]},{"line":"        include Tock_field_sponge.Inputs","counters":[]},{"line":"","counters":[]},{"line":"        let params = Tock_field_sponge.params","counters":[]},{"line":"      end)","counters":[]},{"line":"","counters":[]},{"line":"  module S = Sponge.Make_sponge (Permutation)","counters":[]},{"line":"  include S","counters":[]},{"line":"","counters":[]},{"line":"  let squeeze_field = squeeze","counters":[]},{"line":"","counters":[]},{"line":"  let squeeze = squeeze","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let%test_unit \"sponge\" =","counters":[]},{"line":"  let module T = Make_sponge.Test (Impl) (Tock_field_sponge.Field) (Sponge.S) in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  T.test Tock_field_sponge.params","counters":[]},{"line":"","counters":[]},{"line":"module Input_domain = struct","counters":[]},{"line":"  let lagrange_commitments domain : Me.Inner_curve.Affine.t array =","counters":[]},{"line":"    let domain_size = Domain.size domain in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    time \"lagrange\" (fun () ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        Array.init domain_size ~f:(fun i ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            (Kimchi_bindings.Protocol.SRS.Fp.lagrange_commitment","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"               (Tick.Keypair.load_urs ()) domain_size i )","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"              .unshifted.(0)","counters":[]},{"line":"            |> Common.finite_exn ) )","counters":[]},{"line":"","counters":[]},{"line":"  let domain = Domain.Pow_2_roots_of_unity 7","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Inner_curve = struct","counters":[]},{"line":"  module C = Kimchi_pasta.Pasta.Vesta","counters":[]},{"line":"","counters":[]},{"line":"  module Inputs = struct","counters":[]},{"line":"    module Impl = Impl","counters":[]},{"line":"","counters":[]},{"line":"    module Params = struct","counters":[]},{"line":"      include C.Params","counters":[]},{"line":"","counters":[]},{"line":"      let one = C.to_affine_exn C.one","counters":[{"col_start":30,"col_end":30,"count":1}]},{"line":"","counters":[]},{"line":"      let group_size_in_bits = Field.size_in_bits","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module F = struct","counters":[]},{"line":"      include struct","counters":[]},{"line":"        open Impl.Field","counters":[]},{"line":"","counters":[]},{"line":"        type nonrec t = t","counters":[]},{"line":"","counters":[]},{"line":"        let ( * ), ( + ), ( - ), inv_exn, square, scale, if_, typ, constant =","counters":[]},{"line":"          (( * ), ( + ), ( - ), inv, square, scale, if_, typ, constant)","counters":[]},{"line":"","counters":[]},{"line":"        let negate x = scale x Constant.(negate one)","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      module Constant = struct","counters":[]},{"line":"        open Impl.Field.Constant","counters":[]},{"line":"","counters":[]},{"line":"        type nonrec t = t","counters":[]},{"line":"","counters":[]},{"line":"        let ( * ), ( + ), ( - ), inv_exn, square, negate =","counters":[]},{"line":"          (( * ), ( + ), ( - ), inv, square, negate)","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      let assert_square x y = Impl.assert_square x y","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"","counters":[]},{"line":"      let assert_r1cs x y z = Impl.assert_r1cs x y z","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Constant = struct","counters":[]},{"line":"      include C.Affine","counters":[]},{"line":"      module Scalar = Impls.Step.Field.Constant","counters":[]},{"line":"","counters":[]},{"line":"      let scale (t : t) (x : Scalar.t) : t =","counters":[]},{"line":"        C.(to_affine_exn (scale (of_affine t) x))","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"","counters":[]},{"line":"      let random () : t = C.(to_affine_exn (random ()))","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"","counters":[]},{"line":"      let zero = Impl.Field.Constant.(zero, zero)","counters":[]},{"line":"","counters":[]},{"line":"      let ( + ) t1 t2 : t =","counters":[]},{"line":"        let is_zero (x, _) = Impl.Field.Constant.(equal zero x) in","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"        if is_zero t1 then t2","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"        else if is_zero t2 then t1","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"        else","counters":[]},{"line":"          let r = C.(of_affine t1 + of_affine t2) in","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"          try C.to_affine_exn r with _ -> zero","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"      let negate x : t = C.(to_affine_exn (negate (of_affine x)))","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":48,"col_end":48,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"","counters":[]},{"line":"      let to_affine_exn = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"      let of_affine = Fn.id","counters":[]},{"line":"    end","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Params = Inputs.Params","counters":[]},{"line":"  module Constant = Inputs.Constant","counters":[]},{"line":"  module T = Snarky_curve.For_native_base_field (Inputs)","counters":[]},{"line":"","counters":[]},{"line":"  include (","counters":[]},{"line":"    T :","counters":[]},{"line":"      module type of T","counters":[]},{"line":"        with module Scaling_precomputation := T.Scaling_precomputation )","counters":[]},{"line":"","counters":[]},{"line":"  module Scaling_precomputation = T.Scaling_precomputation","counters":[]},{"line":"","counters":[]},{"line":"  let ( + ) t1 t2 = Plonk_curve_ops.add_fast (module Impl) t1 t2","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"","counters":[]},{"line":"  let double t = t + t","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"","counters":[]},{"line":"  let scale t bs =","counters":[]},{"line":"    with_label __LOC__ (fun () ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        T.scale t (Bitstring_lib.Bitstring.Lsb_first.of_list bs) )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"","counters":[]},{"line":"  let to_field_elements (x, y) = [ x; y ]","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"","counters":[]},{"line":"  let assert_equal (x1, y1) (x2, y2) =","counters":[]},{"line":"    Field.Assert.equal x1 x2 ; Field.Assert.equal y1 y2","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"","counters":[]},{"line":"  let scale_inv t bs =","counters":[]},{"line":"    let res =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      exists typ","counters":[]},{"line":"        ~compute:","counters":[]},{"line":"          As_prover.(","counters":[]},{"line":"            fun () ->","counters":[]},{"line":"              C.scale","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":20,"col_end":20,"count":0}]},{"line":"                (C.of_affine (read typ t))","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"                (Other.Field.inv","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                   (Other.Field.of_bits (List.map ~f:(read Boolean.typ) bs)) )","counters":[{"col_start":38,"col_end":38,"count":0},{"col_start":48,"col_end":48,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"              |> C.to_affine_exn)","counters":[]},{"line":"    in","counters":[]},{"line":"    assert_equal t (scale res bs) ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"    res","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let negate = T.negate","counters":[]},{"line":"","counters":[]},{"line":"  let one = T.one","counters":[]},{"line":"","counters":[]},{"line":"  let if_ = T.if_","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Ops = Plonk_curve_ops.Make (Impl) (Inner_curve)","counters":[]},{"line":"","counters":[]},{"line":"module Generators = struct","counters":[]},{"line":"  let h =","counters":[]},{"line":"    lazy","counters":[]},{"line":"      ( Kimchi_bindings.Protocol.SRS.Fp.urs_h (Backend.Tick.Keypair.load_urs ())","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":75,"col_end":75,"count":0}]},{"line":"      |> Common.finite_exn )","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}