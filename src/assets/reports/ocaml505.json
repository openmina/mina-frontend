{"filename":"src/lib/pickles/step_main_inputs.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Common","counters":[]},{"line":"open Backend","counters":[]},{"line":"open Pickles_types","counters":[]},{"line":"module Impl = Impls.Step","counters":[]},{"line":"open Import","counters":[]},{"line":"","counters":[]},{"line":"let high_entropy_bits = 128","counters":[]},{"line":"","counters":[]},{"line":"let sponge_params_constant =","counters":[]},{"line":"  Sponge.Params.(map pasta_p_kimchi ~f:Impl.Field.Constant.of_string)","counters":[{"col_start":19,"col_end":19,"count":1}]},{"line":"","counters":[]},{"line":"let tick_field_random_oracle ?(length = Tick.Field.size_in_bits - 1) s =","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"  Tick.Field.of_bits (Ro.bits_random_oracle ~length s)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"","counters":[]},{"line":"let unrelated_g =","counters":[]},{"line":"  let group_map =","counters":[]},{"line":"    unstage","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"      (group_map","counters":[{"col_start":15,"col_end":15,"count":1}]},{"line":"         (module Tick.Field)","counters":[]},{"line":"         ~a:Tick.Inner_curve.Params.a ~b:Tick.Inner_curve.Params.b )","counters":[]},{"line":"  and str = Fn.compose bits_to_bytes Tick.Field.to_bits in","counters":[{"col_start":21,"col_end":21,"count":1}]},{"line":"  fun (x, y) -> group_map (tick_field_random_oracle (str x ^ str y))","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":50,"col_end":50,"count":0},{"col_start":55,"col_end":55,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"","counters":[]},{"line":"open Impl","counters":[]},{"line":"","counters":[]},{"line":"module Other_field = struct","counters":[]},{"line":"  type t = Tock.Field.t [@@deriving sexp]","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"  include (Tock.Field : module type of Tock.Field with type t := t)","counters":[]},{"line":"","counters":[]},{"line":"  let size = Impls.Wrap.Bigint.to_bignum_bigint size","counters":[{"col_start":46,"col_end":46,"count":1}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let sponge_params =","counters":[]},{"line":"  Sponge.Params.(map sponge_params_constant ~f:Impl.Field.constant)","counters":[{"col_start":19,"col_end":19,"count":1}]},{"line":"","counters":[]},{"line":"module Unsafe = struct","counters":[]},{"line":"  let unpack_unboolean ?(length = Field.size_in_bits) x =","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"    let res =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      exists","counters":[]},{"line":"        (Typ.list Boolean.typ_unchecked ~length)","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"        ~compute:","counters":[]},{"line":"          As_prover.(","counters":[]},{"line":"            fun () -> List.take (Field.Constant.unpack (read_var x)) length)","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":53,"col_end":53,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"    in","counters":[]},{"line":"    Field.Assert.equal x (Field.project res) ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"    res","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Sponge = struct","counters":[]},{"line":"  module Permutation =","counters":[]},{"line":"    Sponge_inputs.Make","counters":[]},{"line":"      (Impl)","counters":[]},{"line":"      (struct","counters":[]},{"line":"        include Tick_field_sponge.Inputs","counters":[]},{"line":"","counters":[]},{"line":"        let params = Tick_field_sponge.params","counters":[]},{"line":"      end)","counters":[]},{"line":"","counters":[]},{"line":"  module S = Sponge.Make_sponge (Permutation)","counters":[]},{"line":"  include S","counters":[]},{"line":"","counters":[]},{"line":"  let squeeze_field = squeeze","counters":[]},{"line":"","counters":[]},{"line":"  let squeeze = squeeze","counters":[]},{"line":"","counters":[]},{"line":"  let absorb t input =","counters":[]},{"line":"    match input with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | `Field x ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        absorb t x","counters":[]},{"line":"    | `Bits bs ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        absorb t (Field.pack bs)","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let%test_unit \"sponge\" =","counters":[]},{"line":"  let module T = Make_sponge.Test (Impl) (Tick_field_sponge.Field) (Sponge.S) in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  T.test Tick_field_sponge.params","counters":[]},{"line":"","counters":[]},{"line":"module Input_domain = struct","counters":[]},{"line":"  let domain = Domain.Pow_2_roots_of_unity 6","counters":[]},{"line":"","counters":[]},{"line":"  let lagrange_commitments =","counters":[]},{"line":"    lazy","counters":[]},{"line":"      (let domain_size = Domain.size domain in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"       time \"lagrange\" (fun () ->","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"           Array.init domain_size ~f:(fun i ->","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"               let v =","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                 (Kimchi_bindings.Protocol.SRS.Fq.lagrange_commitment","counters":[{"col_start":68,"col_end":68,"count":0}]},{"line":"                    (Backend.Tock.Keypair.load_urs ())","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"                    domain_size i )","counters":[]},{"line":"                   .unshifted","counters":[]},{"line":"               in","counters":[]},{"line":"               assert (Array.length v = 1) ;","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"               v.(0) |> Common.finite_exn ) ) )","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Inner_curve = struct","counters":[]},{"line":"  module C = Kimchi_pasta.Pasta.Pallas","counters":[]},{"line":"","counters":[]},{"line":"  module Inputs = struct","counters":[]},{"line":"    module Impl = Impl","counters":[]},{"line":"","counters":[]},{"line":"    module Params = struct","counters":[]},{"line":"      open Impl.Field.Constant","counters":[]},{"line":"      include C.Params","counters":[]},{"line":"","counters":[]},{"line":"      let one = C.to_affine_exn C.one","counters":[{"col_start":30,"col_end":30,"count":1}]},{"line":"","counters":[]},{"line":"      let group_size_in_bits = Field.size_in_bits","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module F = struct","counters":[]},{"line":"      include struct","counters":[]},{"line":"        open Impl.Field","counters":[]},{"line":"","counters":[]},{"line":"        type nonrec t = t","counters":[]},{"line":"","counters":[]},{"line":"        let ( * ), ( + ), ( - ), inv_exn, square, scale, if_, typ, constant =","counters":[]},{"line":"          (( * ), ( + ), ( - ), inv, square, scale, if_, typ, constant)","counters":[]},{"line":"","counters":[]},{"line":"        let negate x = scale x Constant.(negate one)","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      module Constant = struct","counters":[]},{"line":"        open Impl.Field.Constant","counters":[]},{"line":"","counters":[]},{"line":"        type nonrec t = t","counters":[]},{"line":"","counters":[]},{"line":"        let ( * ), ( + ), ( - ), inv_exn, square, negate =","counters":[]},{"line":"          (( * ), ( + ), ( - ), inv, square, negate)","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      let assert_square x y = Impl.assert_square x y","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"","counters":[]},{"line":"      let assert_r1cs x y z = Impl.assert_r1cs x y z","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Constant = struct","counters":[]},{"line":"      include C.Affine","counters":[]},{"line":"      module Scalar = Impls.Wrap.Field.Constant","counters":[]},{"line":"","counters":[]},{"line":"      let scale (t : t) x : t = C.(to_affine_exn (scale (of_affine t) x))","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":54,"col_end":54,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"","counters":[]},{"line":"      let random () = C.(to_affine_exn (random ()))","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"","counters":[]},{"line":"      let zero = Impl.Field.Constant.(zero, zero)","counters":[]},{"line":"","counters":[]},{"line":"      let ( + ) t1 t2 =","counters":[]},{"line":"        let is_zero (x, _) = Impl.Field.Constant.(equal zero x) in","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"        if is_zero t1 then t2","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"        else if is_zero t2 then t1","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"        else","counters":[]},{"line":"          let r = C.(of_affine t1 + of_affine t2) in","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"          try C.to_affine_exn r with _ -> zero","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"      let negate x = C.(to_affine_exn (negate (of_affine x)))","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"","counters":[]},{"line":"      let to_affine_exn = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"      let of_affine = Fn.id","counters":[]},{"line":"    end","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Params = Inputs.Params","counters":[]},{"line":"  module Constant = Inputs.Constant","counters":[]},{"line":"  module T = Snarky_curve.For_native_base_field (Inputs)","counters":[]},{"line":"","counters":[]},{"line":"  include (","counters":[]},{"line":"    T :","counters":[]},{"line":"      module type of T","counters":[]},{"line":"        with module Scaling_precomputation := T.Scaling_precomputation )","counters":[]},{"line":"","counters":[]},{"line":"  module Scaling_precomputation = T.Scaling_precomputation","counters":[]},{"line":"","counters":[]},{"line":"  let ( + ) t1 t2 = Plonk_curve_ops.add_fast (module Impl) t1 t2","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"","counters":[]},{"line":"  let double t = t + t","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"","counters":[]},{"line":"  let scale t bs =","counters":[]},{"line":"    with_label __LOC__ (fun () ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        T.scale t (Bitstring_lib.Bitstring.Lsb_first.of_list bs) )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"","counters":[]},{"line":"  let to_field_elements (x, y) = [ x; y ]","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"","counters":[]},{"line":"  let assert_equal (x1, y1) (x2, y2) =","counters":[]},{"line":"    Field.Assert.equal x1 x2 ; Field.Assert.equal y1 y2","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"","counters":[]},{"line":"  let scale_inv t bs =","counters":[]},{"line":"    let res =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      exists typ","counters":[]},{"line":"        ~compute:","counters":[]},{"line":"          As_prover.(","counters":[]},{"line":"            fun () ->","counters":[]},{"line":"              C.scale","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":20,"col_end":20,"count":0}]},{"line":"                (C.of_affine (read typ t))","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"                (Tock.Field.inv","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                   (Tock.Field.of_bits (List.map ~f:(read Boolean.typ) bs)) )","counters":[{"col_start":37,"col_end":37,"count":0},{"col_start":47,"col_end":47,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"              |> C.to_affine_exn)","counters":[]},{"line":"    in","counters":[]},{"line":"    assert_equal t (scale res bs) ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"    res","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let negate = T.negate","counters":[]},{"line":"","counters":[]},{"line":"  let one = T.one","counters":[]},{"line":"","counters":[]},{"line":"  let if_ = T.if_","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Ops = Plonk_curve_ops.Make (Impl) (Inner_curve)","counters":[]},{"line":"","counters":[]},{"line":"let%test_unit \"scale fast 2'\" =","counters":[]},{"line":"  let open Impl in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let module T = Internal_Basic in","counters":[]},{"line":"  let module G = Inner_curve in","counters":[]},{"line":"  let n = Field.size_in_bits in","counters":[]},{"line":"  let module F = struct","counters":[]},{"line":"    type t = Field.t","counters":[]},{"line":"","counters":[]},{"line":"    let typ = Field.typ","counters":[]},{"line":"","counters":[]},{"line":"    module Constant = struct","counters":[]},{"line":"      include Field.Constant","counters":[]},{"line":"","counters":[]},{"line":"      let to_bigint = Impl.Bigint.of_field","counters":[]},{"line":"    end","counters":[]},{"line":"  end in","counters":[]},{"line":"  Quickcheck.test ~trials:5 Field.Constant.gen ~f:(fun s ->","counters":[]},{"line":"      T.Test.test_equal ~equal:G.Constant.equal ~sexp_of_t:G.Constant.sexp_of_t","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (Typ.tuple2 G.typ Field.typ)","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"        G.typ","counters":[]},{"line":"        (fun (g, s) ->","counters":[]},{"line":"          make_checked (fun () -> Ops.scale_fast2' ~num_bits:n (module F) g s)","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"          )","counters":[]},{"line":"        (fun (g, _) ->","counters":[]},{"line":"          let x =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let chunks_needed = Ops.chunks_needed ~num_bits:(n - 1) in","counters":[]},{"line":"            let actual_bits_used = chunks_needed * Ops.bits_per_chunk in","counters":[]},{"line":"            Pickles_types.Pcs_batch.pow ~one:G.Constant.Scalar.one","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"              ~mul:G.Constant.Scalar.( * )","counters":[]},{"line":"              G.Constant.Scalar.(of_int 2)","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"              actual_bits_used","counters":[]},{"line":"            |> G.Constant.Scalar.( + )","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                 (G.Constant.Scalar.project (Field.Constant.unpack s))","counters":[{"col_start":42,"col_end":42,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"          in","counters":[]},{"line":"          G.Constant.scale g x )","counters":[]},{"line":"        (G.Constant.random (), s) )","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"let%test_unit \"scale fast 2 small\" =","counters":[]},{"line":"  let open Impl in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let module T = Internal_Basic in","counters":[]},{"line":"  let module G = Inner_curve in","counters":[]},{"line":"  let n = 8 in","counters":[]},{"line":"  let module F = struct","counters":[]},{"line":"    type t = Field.t","counters":[]},{"line":"","counters":[]},{"line":"    let typ = Field.typ","counters":[]},{"line":"","counters":[]},{"line":"    module Constant = struct","counters":[]},{"line":"      include Field.Constant","counters":[]},{"line":"","counters":[]},{"line":"      let to_bigint = Impl.Bigint.of_field","counters":[]},{"line":"    end","counters":[]},{"line":"  end in","counters":[]},{"line":"  Quickcheck.test ~trials:5 Field.Constant.gen ~f:(fun s ->","counters":[]},{"line":"      let s =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Field.Constant.unpack s |> Fn.flip List.take n |> Field.Constant.project","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"      in","counters":[]},{"line":"      T.Test.test_equal ~equal:G.Constant.equal ~sexp_of_t:G.Constant.sexp_of_t","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (Typ.tuple2 G.typ Field.typ)","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"        G.typ","counters":[]},{"line":"        (fun (g, s) ->","counters":[]},{"line":"          make_checked (fun () -> Ops.scale_fast2' ~num_bits:n (module F) g s)","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"          )","counters":[]},{"line":"        (fun (g, _) ->","counters":[]},{"line":"          let x =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let chunks_needed = Ops.chunks_needed ~num_bits:(n - 1) in","counters":[]},{"line":"            let actual_bits_used = chunks_needed * Ops.bits_per_chunk in","counters":[]},{"line":"            Pickles_types.Pcs_batch.pow ~one:G.Constant.Scalar.one","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"              ~mul:G.Constant.Scalar.( * )","counters":[]},{"line":"              G.Constant.Scalar.(of_int 2)","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"              actual_bits_used","counters":[]},{"line":"            |> G.Constant.Scalar.( + )","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                 (G.Constant.Scalar.project (Field.Constant.unpack s))","counters":[{"col_start":42,"col_end":42,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"          in","counters":[]},{"line":"          G.Constant.scale g x )","counters":[]},{"line":"        (G.Constant.random (), s) )","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"module Generators = struct","counters":[]},{"line":"  let h =","counters":[]},{"line":"    lazy","counters":[]},{"line":"      ( Kimchi_bindings.Protocol.SRS.Fq.urs_h (Backend.Tock.Keypair.load_urs ())","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":75,"col_end":75,"count":0}]},{"line":"      |> Common.finite_exn )","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}