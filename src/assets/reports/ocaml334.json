{"filename":"src/lib/merkle_ledger/merkle_path.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"module type S = sig","counters":[]},{"line":"  type hash","counters":[]},{"line":"","counters":[]},{"line":"  type elem = [ `Left of hash | `Right of hash ] [@@deriving sexp, equal]","counters":[]},{"line":"","counters":[]},{"line":"  val elem_hash : elem -> hash","counters":[]},{"line":"","counters":[]},{"line":"  type t = elem list [@@deriving sexp, equal]","counters":[]},{"line":"","counters":[]},{"line":"  val implied_root : t -> hash -> hash","counters":[]},{"line":"","counters":[]},{"line":"  val check_path : t -> hash -> hash -> bool","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make (Hash : sig","counters":[]},{"line":"  type t [@@deriving sexp, equal]","counters":[]},{"line":"","counters":[]},{"line":"  val merge : height:int -> t -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"  val equal : t -> t -> bool","counters":[]},{"line":"end) : S with type hash := Hash.t = struct","counters":[]},{"line":"  type elem = [ `Left of Hash.t | `Right of Hash.t ] [@@deriving sexp, equal]","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":14,"col_end":14,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":76,"col_end":76,"count":0}]},{"line":"","counters":[]},{"line":"  let elem_hash = function `Left h | `Right h -> h","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"  type t = elem list [@@deriving sexp, equal]","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":11,"col_end":11,"count":0},{"col_start":16,"col_end":16,"count":0}]},{"line":"","counters":[]},{"line":"  let implied_root (t : t) leaf_hash =","counters":[]},{"line":"    List.fold t ~init:(leaf_hash, 0) ~f:(fun (acc, height) elem ->","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":12,"col_end":12,"count":0}]},{"line":"        let acc =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          match elem with","counters":[]},{"line":"          | `Left h ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Hash.merge ~height acc h","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"          | `Right h ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Hash.merge ~height h acc","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"        in","counters":[]},{"line":"        (acc, height + 1) )","counters":[]},{"line":"    |> fst","counters":[]},{"line":"","counters":[]},{"line":"  let check_path t leaf_hash root_hash =","counters":[]},{"line":"    Hash.equal (implied_root t leaf_hash) root_hash","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}