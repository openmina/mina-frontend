{"filename":"src/lib/pickles_types/nat.ml","lines":[{"line":"type z = Z of z","counters":[]},{"line":"","counters":[]},{"line":"type 'a s = Z | S of 'a","counters":[]},{"line":"","counters":[]},{"line":"type _ t = Z : z t | S : 'n t -> 'n s t","counters":[]},{"line":"","counters":[]},{"line":"type 'a nat = 'a t","counters":[]},{"line":"","counters":[]},{"line":"type e = T : 'n nat -> e","counters":[]},{"line":"","counters":[]},{"line":"let to_int : type n. n t -> int =","counters":[]},{"line":"  let rec go : type n. int -> n t -> int =","counters":[]},{"line":"   fun acc n -> match n with Z -> acc | S n -> go (acc + 1) n","counters":[{"col_start":16,"col_end":16,"count":389},{"col_start":29,"col_end":29,"count":61},{"col_start":40,"col_end":40,"count":328}]},{"line":"  in","counters":[]},{"line":"  fun x -> go 0 x","counters":[{"col_start":11,"col_end":11,"count":61}]},{"line":"","counters":[]},{"line":"let rec of_int : int -> e =","counters":[]},{"line":" fun n ->","counters":[]},{"line":"  if n < 0 then failwith \"of_int: negative\"","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":16,"col_end":16,"count":0}]},{"line":"  else if n = 0 then T Z","counters":[{"col_start":7,"col_end":7,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"  else","counters":[]},{"line":"    let (T n) = of_int (n - 1) in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    T (S n)","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"module type Intf = sig","counters":[]},{"line":"  type n","counters":[]},{"line":"","counters":[]},{"line":"  val n : n t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Adds = struct","counters":[]},{"line":"  type ('a, 'b, 'c) t =","counters":[]},{"line":"    | Z : (z, 'n, 'n) t","counters":[]},{"line":"    | S : ('a, 'b, 'c) t -> ('a s, 'b, 'c s) t","counters":[]},{"line":"","counters":[]},{"line":"  let rec add_zr : type n. n nat -> (n, z, n) t = function","counters":[]},{"line":"    | Z ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Z","counters":[]},{"line":"    | S n ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let pi = add_zr n in","counters":[]},{"line":"        S pi","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Lte = struct","counters":[]},{"line":"  type (_, _) t = Z : (z, _) t | S : ('n, 'm) t -> ('n s, 'm s) t","counters":[]},{"line":"","counters":[]},{"line":"  let rec refl : type n. n nat -> (n, n) t = function","counters":[]},{"line":"    | Z ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Z","counters":[]},{"line":"    | S n ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        S (refl n)","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"","counters":[]},{"line":"  let rec trans : type a b c. (a, b) t -> (b, c) t -> (a, c) t =","counters":[]},{"line":"   fun t1 t2 -> match (t1, t2) with Z, _ -> Z | S t1, S t2 -> S (trans t1 t2)","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":48,"col_end":48,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module N0 = struct","counters":[]},{"line":"  type 'a plus_n = 'a","counters":[]},{"line":"","counters":[]},{"line":"  type n = z","counters":[]},{"line":"","counters":[]},{"line":"  let n = Z","counters":[]},{"line":"","counters":[]},{"line":"  let add m = (m, Adds.Z)","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"","counters":[]},{"line":"  let eq = Core_kernel.Type_equal.T","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Add = struct","counters":[]},{"line":"  module type Intf = sig","counters":[]},{"line":"    type _ plus_n","counters":[]},{"line":"","counters":[]},{"line":"    type n","counters":[]},{"line":"","counters":[]},{"line":"    val eq : (n, z plus_n) Core_kernel.Type_equal.t","counters":[]},{"line":"","counters":[]},{"line":"    val n : z plus_n t","counters":[]},{"line":"","counters":[]},{"line":"    val add : 'm nat -> 'm plus_n nat * (z plus_n, 'm, 'm plus_n) Adds.t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let rec create : type n. n nat -> (module Intf with type n = n) = function","counters":[]},{"line":"    | Z ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (module N0)","counters":[]},{"line":"    | S n ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let (module N) = create n in","counters":[]},{"line":"        let T = N.eq in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let module Sn = struct","counters":[]},{"line":"          type 'a plus_n = 'a N.plus_n s","counters":[]},{"line":"","counters":[]},{"line":"          type n = N.n s","counters":[]},{"line":"","counters":[]},{"line":"          let n = S N.n","counters":[]},{"line":"","counters":[]},{"line":"          let eq = Core_kernel.Type_equal.T","counters":[]},{"line":"","counters":[]},{"line":"          let add t =","counters":[]},{"line":"            let t_plus_n, pi = N.add t in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            (S t_plus_n, Adds.S pi)","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"        end in","counters":[]},{"line":"        (module Sn)","counters":[]},{"line":"","counters":[]},{"line":"  let n : type n. (module Intf with type n = n) -> n nat =","counters":[]},{"line":"   fun (module N) ->","counters":[]},{"line":"    let T = N.eq in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    N.n","counters":[]},{"line":"","counters":[]},{"line":"  module type Intf_transparent = sig","counters":[]},{"line":"    type _ plus_n","counters":[]},{"line":"","counters":[]},{"line":"    type n = z plus_n","counters":[]},{"line":"","counters":[]},{"line":"    val eq : (n, z plus_n) Core_kernel.Type_equal.t","counters":[]},{"line":"","counters":[]},{"line":"    val n : z plus_n t","counters":[]},{"line":"","counters":[]},{"line":"    val add : 'm nat -> 'm plus_n nat * (z plus_n, 'm, 'm plus_n) Adds.t","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module S (N : Add.Intf) = struct","counters":[]},{"line":"  type 'a plus_n = 'a N.plus_n s","counters":[]},{"line":"","counters":[]},{"line":"  type n = z plus_n","counters":[]},{"line":"","counters":[]},{"line":"  let n = S N.n","counters":[]},{"line":"","counters":[]},{"line":"  let add m =","counters":[]},{"line":"    let k, pi = N.add m in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    (S k, Adds.S pi)","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let eq = match N.eq with T -> Core_kernel.Type_equal.T","counters":[{"col_start":27,"col_end":27,"count":48}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module N1 = S (N0)","counters":[]},{"line":"module N2 = S (N1)","counters":[]},{"line":"module N3 = S (N2)","counters":[]},{"line":"module N4 = S (N3)","counters":[]},{"line":"module N5 = S (N4)","counters":[]},{"line":"module N6 = S (N5)","counters":[]},{"line":"module N7 = S (N6)","counters":[]},{"line":"module N8 = S (N7)","counters":[]},{"line":"module N9 = S (N8)","counters":[]},{"line":"module N10 = S (N9)","counters":[]},{"line":"module N11 = S (N10)","counters":[]},{"line":"module N12 = S (N11)","counters":[]},{"line":"module N13 = S (N12)","counters":[]},{"line":"module N14 = S (N13)","counters":[]},{"line":"module N15 = S (N14)","counters":[]},{"line":"module N16 = S (N15)","counters":[]},{"line":"module N17 = S (N16)","counters":[]},{"line":"module N18 = S (N17)","counters":[]},{"line":"module N19 = S (N18)","counters":[]},{"line":"module N20 = S (N19)","counters":[]},{"line":"module N21 = S (N20)","counters":[]},{"line":"module N22 = S (N21)","counters":[]},{"line":"module N23 = S (N22)","counters":[]},{"line":"module N24 = S (N23)","counters":[]},{"line":"module N25 = S (N24)","counters":[]},{"line":"module N26 = S (N25)","counters":[]},{"line":"module N27 = S (N26)","counters":[]},{"line":"module N28 = S (N27)","counters":[]},{"line":"module N29 = S (N28)","counters":[]},{"line":"module N30 = S (N29)","counters":[]},{"line":"module N31 = S (N30)","counters":[]},{"line":"module N32 = S (N31)","counters":[]},{"line":"module N33 = S (N32)","counters":[]},{"line":"module N34 = S (N33)","counters":[]},{"line":"module N35 = S (N34)","counters":[]},{"line":"module N36 = S (N35)","counters":[]},{"line":"module N37 = S (N36)","counters":[]},{"line":"module N38 = S (N37)","counters":[]},{"line":"module N39 = S (N38)","counters":[]},{"line":"module N40 = S (N39)","counters":[]},{"line":"module N41 = S (N40)","counters":[]},{"line":"module N42 = S (N41)","counters":[]},{"line":"module N43 = S (N42)","counters":[]},{"line":"module N44 = S (N43)","counters":[]},{"line":"module N45 = S (N44)","counters":[]},{"line":"module N46 = S (N45)","counters":[]},{"line":"module N47 = S (N46)","counters":[]},{"line":"module N48 = S (N47)","counters":[]},{"line":"","counters":[]},{"line":"module Empty = struct","counters":[]},{"line":"  type t = T of t","counters":[]},{"line":"","counters":[]},{"line":"  let rec elim : type a. t -> a = function T t -> elim t","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Not = struct","counters":[]},{"line":"  type 'a t = 'a -> Empty.t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"let rec compare :","counters":[]},{"line":"    type n m. n t -> m t -> [ `Lte of (n, m) Lte.t | `Gt of (n, m) Lte.t Not.t ]","counters":[]},{"line":"    =","counters":[]},{"line":" fun n m ->","counters":[]},{"line":"  match (n, m) with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | Z, _ ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      `Lte Lte.Z","counters":[]},{"line":"  | S _, Z ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      `Gt (function _ -> .)","counters":[]},{"line":"  | S n, S m -> (","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      match compare n m with","counters":[]},{"line":"      | `Lte pi ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          `Lte (S pi)","counters":[]},{"line":"      | `Gt gt ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          `Gt (function S pi -> gt pi) )","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"","counters":[]},{"line":"let lte_exn n m =","counters":[]},{"line":"  match compare n m with `Lte pi -> pi | `Gt _gt -> failwith \"lte_exn\"","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"","counters":[]},{"line":"let rec gt_implies_gte :","counters":[]},{"line":"    type n m. n nat -> m nat -> (n, m) Lte.t Not.t -> (m, n) Lte.t =","counters":[]},{"line":" fun n m not_lte ->","counters":[]},{"line":"  match (n, m) with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | Z, _ ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Empty.elim (not_lte Z)","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"  | S _, Z ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Z","counters":[]},{"line":"  | S n, S m ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      S (gt_implies_gte n m (fun pi -> not_lte (S pi)))","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"let rec eq :","counters":[]},{"line":"    type n m.","counters":[]},{"line":"       n nat","counters":[]},{"line":"    -> m nat","counters":[]},{"line":"    -> [ `Equal of (n, m) Type_equal.t","counters":[]},{"line":"       | `Not_equal of (n, m) Type_equal.t Not.t ] =","counters":[]},{"line":" fun n m ->","counters":[]},{"line":"  match (n, m) with","counters":[{"col_start":2,"col_end":2,"count":4}]},{"line":"  | Z, Z ->","counters":[{"col_start":4,"col_end":4,"count":2}]},{"line":"      `Equal T","counters":[]},{"line":"  | S _, Z ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      `Not_equal (function _ -> .)","counters":[]},{"line":"  | Z, S _ ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      `Not_equal (function _ -> .)","counters":[]},{"line":"  | S n, S m -> (","counters":[{"col_start":4,"col_end":4,"count":2}]},{"line":"      match eq n m with","counters":[]},{"line":"      | `Equal T ->","counters":[{"col_start":8,"col_end":8,"count":2}]},{"line":"          `Equal T","counters":[]},{"line":"      | `Not_equal f ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          `Not_equal (function T -> f T) )","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"","counters":[]},{"line":"let eq_exn : type n m. n nat -> m nat -> (n, m) Type_equal.t =","counters":[]},{"line":" fun n m ->","counters":[]},{"line":"  match eq n m with","counters":[{"col_start":2,"col_end":2,"count":2}]},{"line":"  | `Equal t ->","counters":[{"col_start":4,"col_end":4,"count":2}]},{"line":"      t","counters":[]},{"line":"  | `Not_equal _ ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      failwithf \"eq_exn: %d vs %d\" (to_int n) (to_int m) ()","counters":[{"col_start":41,"col_end":41,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"","counters":[]},{"line":"module type I = Add.Intf_transparent","counters":[{"col_start":35,"col_end":35,"count":2}]}]}