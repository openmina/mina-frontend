{"filename":"src/scan_state/transaction_logic.rs","lines":[{"line":"use ark_ff::Zero;","counters":[]},{"line":"use itertools::FoldWhile::{Continue, Done};","counters":[]},{"line":"use itertools::Itertools;","counters":[]},{"line":"use mina_hasher::{create_kimchi, Fp};","counters":[]},{"line":"use mina_p2p_messages::v2::MinaBaseUserCommandStableV2;","counters":[]},{"line":"use mina_signer::CompressedPubKey;","counters":[]},{"line":"","counters":[]},{"line":"use crate::{hash_with_kimchi, Inputs};","counters":[]},{"line":"use crate::{","counters":[]},{"line":"    scan_state::transaction_logic::transaction_applied::{CommandApplied, Varying},","counters":[]},{"line":"    staged_ledger::sparse_ledger::{LedgerIntf, SparseLedger},","counters":[]},{"line":"    Account, AccountId, BaseLedger, PermissionTo, ReceiptChainHash, Timing, TokenId,","counters":[]},{"line":"    VerificationKey,","counters":[]},{"line":"};","counters":[]},{"line":"","counters":[]},{"line":"use self::{","counters":[]},{"line":"    local_state::{CallStack, LocalStateEnv, StackFrame},","counters":[]},{"line":"    protocol_state::{GlobalState, ProtocolStateView},","counters":[]},{"line":"    signed_command::{SignedCommand, SignedCommandPayload},","counters":[]},{"line":"    transaction_applied::{","counters":[]},{"line":"        signed_command_applied::{self, SignedCommandApplied},","counters":[]},{"line":"        TransactionApplied, ZkappCommandApplied,","counters":[]},{"line":"    },","counters":[]},{"line":"    transaction_union_payload::TransactionUnionPayload,","counters":[]},{"line":"    zkapp_command::{","counters":[]},{"line":"        AccountPreconditions, AccountUpdate, WithHash, ZkAppCommand, ZkAppPreconditions,","counters":[]},{"line":"    },","counters":[]},{"line":"};","counters":[]},{"line":"","counters":[]},{"line":"use super::zkapp_logic::ZkAppCommandElt;","counters":[]},{"line":"use super::{","counters":[]},{"line":"    currency::{Amount, Balance, BlockTime, Fee, Index, Length, Magnitude, Nonce, Signed, Slot},","counters":[]},{"line":"    fee_excess::FeeExcess,","counters":[]},{"line":"    scan_state::{transaction_snark::OneOrTwo, ConstraintConstants},","counters":[]},{"line":"    zkapp_logic::{apply, Handler, IsStart, StartData},","counters":[]},{"line":"};","counters":[]},{"line":"","counters":[]},{"line":"/// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/mina_base/transaction_status.ml#L9","counters":[]},{"line":"#[derive(Debug, Clone, PartialEq, Eq)]","counters":[{"col_start":9,"col_end":10,"count":0},{"col_start":13,"col_end":14,"count":0},{"col_start":16,"col_end":17,"count":0},{"col_start":20,"col_end":21,"count":0},{"col_start":23,"col_end":24,"count":0},{"col_start":31,"col_end":32,"count":0}]},{"line":"pub enum TransactionFailure {","counters":[]},{"line":"    Predicate,","counters":[]},{"line":"    SourceNotPresent,","counters":[]},{"line":"    ReceiverNotPresent,","counters":[]},{"line":"    AmountInsufficientToCreateAccount,","counters":[]},{"line":"    CannotPayCreationFeeInToken,","counters":[]},{"line":"    SourceInsufficientBalance,","counters":[]},{"line":"    SourceMinimumBalanceViolation,","counters":[]},{"line":"    ReceiverAlreadyExists,","counters":[]},{"line":"    TokenOwnerNotCaller,","counters":[]},{"line":"    Overflow,","counters":[]},{"line":"    GlobalExcessOverflow,","counters":[]},{"line":"    LocalExcessOverflow,","counters":[]},{"line":"    LocalSupplyIncreaseOverflow,","counters":[]},{"line":"    GlobalSupplyIncreaseOverflow,","counters":[]},{"line":"    SignedCommandOnZkappAccount,","counters":[]},{"line":"    ZkappAccountNotPresent,","counters":[]},{"line":"    UpdateNotPermittedBalance,","counters":[]},{"line":"    UpdateNotPermittedTimingExistingAccount,","counters":[]},{"line":"    UpdateNotPermittedDelegate,","counters":[]},{"line":"    UpdateNotPermittedAppState,","counters":[]},{"line":"    UpdateNotPermittedVerificationKey,","counters":[]},{"line":"    UpdateNotPermittedSequenceState,","counters":[]},{"line":"    UpdateNotPermittedZkappUri,","counters":[]},{"line":"    UpdateNotPermittedTokenSymbol,","counters":[]},{"line":"    UpdateNotPermittedPermissions,","counters":[]},{"line":"    UpdateNotPermittedNonce,","counters":[]},{"line":"    UpdateNotPermittedVotingFor,","counters":[]},{"line":"    ZkappCommandReplayCheckFailed,","counters":[]},{"line":"    FeePayerNonceMustIncrease,","counters":[]},{"line":"    FeePayerMustBeSigned,","counters":[]},{"line":"    AccountBalancePreconditionUnsatisfied,","counters":[]},{"line":"    AccountNoncePreconditionUnsatisfied,","counters":[]},{"line":"    AccountReceiptChainHashPreconditionUnsatisfied,","counters":[]},{"line":"    AccountDelegatePreconditionUnsatisfied,","counters":[]},{"line":"    AccountSequenceStatePreconditionUnsatisfied,","counters":[]},{"line":"    AccountAppStatePreconditionUnsatisfied(usize),","counters":[]},{"line":"    AccountProvedStatePreconditionUnsatisfied,","counters":[]},{"line":"    AccountIsNewPreconditionUnsatisfied,","counters":[]},{"line":"    ProtocolStatePreconditionUnsatisfied,","counters":[]},{"line":"    IncorrectNonce,","counters":[]},{"line":"    InvalidFeeExcess,","counters":[]},{"line":"    Cancelled,","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl ToString for TransactionFailure {","counters":[]},{"line":"    fn to_string(&self) -> String {","counters":[{"col_start":4,"col_end":35,"count":0}]},{"line":"        match self {","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"            Self::Predicate => \"Predicate\".to_string(),","counters":[{"col_start":31,"col_end":54,"count":-78804}]},{"line":"            Self::SourceNotPresent => \"Source_not_present\".to_string(),","counters":[{"col_start":38,"col_end":70,"count":0}]},{"line":"            Self::ReceiverNotPresent => \"Receiver_not_present\".to_string(),","counters":[{"col_start":40,"col_end":74,"count":39401}]},{"line":"            Self::AmountInsufficientToCreateAccount => {","counters":[]},{"line":"                \"Amount_insufficient_to_create_account\".to_string()","counters":[{"col_start":16,"col_end":67,"count":0}]},{"line":"            }","counters":[]},{"line":"            Self::CannotPayCreationFeeInToken => \"Cannot_pay_creation_fee_in_token\".to_string(),","counters":[{"col_start":49,"col_end":95,"count":1}]},{"line":"            Self::SourceInsufficientBalance => \"Source_insufficient_balance\".to_string(),","counters":[{"col_start":47,"col_end":88,"count":39401}]},{"line":"            Self::SourceMinimumBalanceViolation => \"Source_minimum_balance_violation\".to_string(),","counters":[{"col_start":51,"col_end":97,"count":0}]},{"line":"            Self::ReceiverAlreadyExists => \"Receiver_already_exists\".to_string(),","counters":[{"col_start":43,"col_end":80,"count":1}]},{"line":"            Self::TokenOwnerNotCaller => \"Token_owner_not_caller\".to_string(),","counters":[{"col_start":41,"col_end":77,"count":0}]},{"line":"            Self::Overflow => \"Overflow\".to_string(),","counters":[{"col_start":30,"col_end":52,"count":0}]},{"line":"            Self::GlobalExcessOverflow => \"Global_excess_overflow\".to_string(),","counters":[{"col_start":42,"col_end":78,"count":0}]},{"line":"            Self::LocalExcessOverflow => \"Local_excess_overflow\".to_string(),","counters":[{"col_start":41,"col_end":76,"count":0}]},{"line":"            Self::LocalSupplyIncreaseOverflow => \"Local_supply_increase_overflow\".to_string(),","counters":[{"col_start":49,"col_end":93,"count":0}]},{"line":"            Self::GlobalSupplyIncreaseOverflow => \"Global_supply_increase_overflow\".to_string(),","counters":[{"col_start":50,"col_end":95,"count":0}]},{"line":"            Self::SignedCommandOnZkappAccount => \"Signed_command_on_zkapp_account\".to_string(),","counters":[{"col_start":49,"col_end":94,"count":0}]},{"line":"            Self::ZkappAccountNotPresent => \"Zkapp_account_not_present\".to_string(),","counters":[{"col_start":44,"col_end":83,"count":0}]},{"line":"            Self::UpdateNotPermittedBalance => \"Update_not_permitted_balance\".to_string(),","counters":[{"col_start":47,"col_end":89,"count":0}]},{"line":"            Self::UpdateNotPermittedTimingExistingAccount => {","counters":[]},{"line":"                \"Update_not_permitted_timing_existing_account\".to_string()","counters":[{"col_start":16,"col_end":74,"count":0}]},{"line":"            }","counters":[]},{"line":"            Self::UpdateNotPermittedDelegate => \"update_not_permitted_delegate\".to_string(),","counters":[{"col_start":48,"col_end":91,"count":0}]},{"line":"            Self::UpdateNotPermittedAppState => \"Update_not_permitted_app_state\".to_string(),","counters":[{"col_start":48,"col_end":92,"count":0}]},{"line":"            Self::UpdateNotPermittedVerificationKey => {","counters":[]},{"line":"                \"Update_not_permitted_verification_key\".to_string()","counters":[{"col_start":16,"col_end":67,"count":0}]},{"line":"            }","counters":[]},{"line":"            Self::UpdateNotPermittedSequenceState => {","counters":[]},{"line":"                \"Update_not_permitted_sequence_state\".to_string()","counters":[{"col_start":16,"col_end":65,"count":0}]},{"line":"            }","counters":[]},{"line":"            Self::UpdateNotPermittedZkappUri => \"Update_not_permitted_zkapp_uri\".to_string(),","counters":[{"col_start":48,"col_end":92,"count":0}]},{"line":"            Self::UpdateNotPermittedTokenSymbol => \"Update_not_permitted_token_symbol\".to_string(),","counters":[{"col_start":51,"col_end":98,"count":0}]},{"line":"            Self::UpdateNotPermittedPermissions => \"Update_not_permitted_permissions\".to_string(),","counters":[{"col_start":51,"col_end":97,"count":0}]},{"line":"            Self::UpdateNotPermittedNonce => \"Update_not_permitted_nonce\".to_string(),","counters":[{"col_start":45,"col_end":85,"count":0}]},{"line":"            Self::UpdateNotPermittedVotingFor => \"Update_not_permitted_voting_for\".to_string(),","counters":[{"col_start":49,"col_end":94,"count":0}]},{"line":"            Self::ZkappCommandReplayCheckFailed => \"Zkapp_command_replay_check_failed\".to_string(),","counters":[{"col_start":51,"col_end":98,"count":0}]},{"line":"            Self::FeePayerNonceMustIncrease => \"Fee_payer_nonce_must_increase\".to_string(),","counters":[{"col_start":47,"col_end":90,"count":0}]},{"line":"            Self::FeePayerMustBeSigned => \"Fee_payer_must_be_signed\".to_string(),","counters":[{"col_start":42,"col_end":80,"count":0}]},{"line":"            Self::AccountBalancePreconditionUnsatisfied => {","counters":[]},{"line":"                \"Account_balance_precondition_unsatisfied\".to_string()","counters":[{"col_start":16,"col_end":70,"count":0}]},{"line":"            }","counters":[]},{"line":"            Self::AccountNoncePreconditionUnsatisfied => {","counters":[]},{"line":"                \"Account_nonce_precondition_unsatisfied\".to_string()","counters":[{"col_start":16,"col_end":68,"count":0}]},{"line":"            }","counters":[]},{"line":"            Self::AccountReceiptChainHashPreconditionUnsatisfied => {","counters":[]},{"line":"                \"Account_receipt_chain_hash_precondition_unsatisfied\".to_string()","counters":[{"col_start":16,"col_end":81,"count":0}]},{"line":"            }","counters":[]},{"line":"            Self::AccountDelegatePreconditionUnsatisfied => {","counters":[]},{"line":"                \"Account_delegate_precondition_unsatisfied\".to_string()","counters":[{"col_start":16,"col_end":71,"count":0}]},{"line":"            }","counters":[]},{"line":"            Self::AccountSequenceStatePreconditionUnsatisfied => {","counters":[]},{"line":"                \"Account_sequence_state_precondition_unsatisfied\".to_string()","counters":[{"col_start":16,"col_end":77,"count":0}]},{"line":"            }","counters":[]},{"line":"            Self::AccountAppStatePreconditionUnsatisfied(i) => {","counters":[{"col_start":57,"col_end":64,"count":0}]},{"line":"                format!(\"Account_app_state_{}_precondition_unsatisfied\", i)","counters":[{"col_start":0,"col_end":75,"count":0}]},{"line":"            }","counters":[]},{"line":"            Self::AccountProvedStatePreconditionUnsatisfied => {","counters":[]},{"line":"                \"Account_proved_state_precondition_unsatisfied\".to_string()","counters":[{"col_start":16,"col_end":75,"count":0}]},{"line":"            }","counters":[]},{"line":"            Self::AccountIsNewPreconditionUnsatisfied => {","counters":[]},{"line":"                \"Account_is_new_precondition_unsatisfied\".to_string()","counters":[{"col_start":16,"col_end":69,"count":0}]},{"line":"            }","counters":[]},{"line":"            Self::ProtocolStatePreconditionUnsatisfied => {","counters":[]},{"line":"                \"Protocol_state_precondition_unsatisfied\".to_string()","counters":[{"col_start":16,"col_end":69,"count":0}]},{"line":"            }","counters":[]},{"line":"            Self::IncorrectNonce => \"Incorrect_nonce\".to_string(),","counters":[{"col_start":36,"col_end":65,"count":0}]},{"line":"            Self::InvalidFeeExcess => \"Invalid_fee_excess\".to_string(),","counters":[{"col_start":38,"col_end":70,"count":0}]},{"line":"            Self::Cancelled => \"Cancelled\".to_string(),","counters":[{"col_start":31,"col_end":54,"count":0}]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"pub fn single_failure() -> Vec<Vec<TransactionFailure>> {","counters":[{"col_start":0,"col_end":57,"count":0}]},{"line":"    vec![vec![TransactionFailure::UpdateNotPermittedBalance]]","counters":[{"col_start":0,"col_end":61,"count":0}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"/// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/mina_base/transaction_status.ml#L452","counters":[]},{"line":"#[derive(Debug, Clone, PartialEq, Eq)]","counters":[{"col_start":9,"col_end":10,"count":0},{"col_start":13,"col_end":14,"count":0},{"col_start":16,"col_end":17,"count":0},{"col_start":20,"col_end":21,"count":0},{"col_start":23,"col_end":24,"count":0},{"col_start":31,"col_end":32,"count":0}]},{"line":"pub enum TransactionStatus {","counters":[]},{"line":"    Applied,","counters":[]},{"line":"    Failed(Vec<Vec<TransactionFailure>>),","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"/// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/mina_base/with_status.ml#L6","counters":[]},{"line":"#[derive(Debug, Clone)]","counters":[{"col_start":9,"col_end":14,"count":0},{"col_start":16,"col_end":21,"count":0}]},{"line":"pub struct WithStatus<T> {","counters":[]},{"line":"    pub data: T,","counters":[]},{"line":"    pub status: TransactionStatus,","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl<T> WithStatus<T> {","counters":[]},{"line":"    pub fn map<F, R>(&self, fun: F) -> WithStatus<R>","counters":[{"col_start":4,"col_end":52,"count":0}]},{"line":"    where","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"        F: Fn(&T) -> R,","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"    {","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"        WithStatus {","counters":[{"col_start":0,"col_end":20,"count":0}]},{"line":"            data: fun(&self.data),","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"            status: self.status.clone(),","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn into_map<F, R>(self, fun: F) -> WithStatus<R>","counters":[{"col_start":4,"col_end":56,"count":0}]},{"line":"    where","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"        F: Fn(T) -> R,","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"    {","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"        WithStatus {","counters":[{"col_start":0,"col_end":20,"count":0}]},{"line":"            data: fun(self.data),","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"            status: self.status,","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"pub trait GenericCommand {","counters":[]},{"line":"    fn fee(&self) -> Fee;","counters":[]},{"line":"    fn forget(&self) -> UserCommand;","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"pub trait GenericTransaction: Sized {","counters":[]},{"line":"    fn is_fee_transfer(&self) -> bool;","counters":[]},{"line":"    fn is_coinbase(&self) -> bool;","counters":[]},{"line":"    fn is_command(&self) -> bool;","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"pub mod valid {","counters":[]},{"line":"    use super::*;","counters":[]},{"line":"","counters":[]},{"line":"    #[derive(Clone, Debug, Hash, PartialEq, Eq)]","counters":[{"col_start":13,"col_end":18,"count":0},{"col_start":20,"col_end":25,"count":0}]},{"line":"    pub struct VerificationKeyHash(pub Fp);","counters":[]},{"line":"","counters":[]},{"line":"    pub type SignedCommand = super::signed_command::SignedCommand;","counters":[]},{"line":"","counters":[]},{"line":"    #[derive(Clone, Debug, PartialEq)]","counters":[{"col_start":13,"col_end":14,"count":0},{"col_start":17,"col_end":18,"count":0},{"col_start":20,"col_end":21,"count":0},{"col_start":24,"col_end":25,"count":0}]},{"line":"    pub enum UserCommand {","counters":[]},{"line":"        SignedCommand(Box<SignedCommand>),","counters":[]},{"line":"        ZkAppCommand(Box<super::zkapp_command::valid::ZkAppCommand>),","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl UserCommand {","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/mina_base/user_command.ml#L277","counters":[]},{"line":"        pub fn forget_check(&self) -> super::UserCommand {","counters":[{"col_start":8,"col_end":58,"count":0}]},{"line":"            match self {","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"                UserCommand::SignedCommand(cmd) => super::UserCommand::SignedCommand(cmd.clone()),","counters":[{"col_start":43,"col_end":97,"count":0}]},{"line":"                UserCommand::ZkAppCommand(cmd) => {","counters":[{"col_start":42,"col_end":51,"count":0}]},{"line":"                    super::UserCommand::ZkAppCommand(Box::new(cmd.zkapp_command.clone()))","counters":[{"col_start":0,"col_end":89,"count":0}]},{"line":"                }","counters":[]},{"line":"            }","counters":[]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl GenericCommand for UserCommand {","counters":[]},{"line":"        fn fee(&self) -> Fee {","counters":[{"col_start":8,"col_end":30,"count":0}]},{"line":"            match self {","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"                UserCommand::SignedCommand(cmd) => cmd.fee(),","counters":[{"col_start":43,"col_end":60,"count":0}]},{"line":"                UserCommand::ZkAppCommand(cmd) => cmd.zkapp_command.fee(),","counters":[{"col_start":42,"col_end":73,"count":0}]},{"line":"            }","counters":[]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        fn forget(&self) -> super::UserCommand {","counters":[{"col_start":8,"col_end":48,"count":0}]},{"line":"            match self {","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"                UserCommand::SignedCommand(cmd) => super::UserCommand::SignedCommand(cmd.clone()),","counters":[{"col_start":43,"col_end":97,"count":0}]},{"line":"                UserCommand::ZkAppCommand(cmd) => {","counters":[{"col_start":42,"col_end":51,"count":0}]},{"line":"                    super::UserCommand::ZkAppCommand(Box::new(cmd.zkapp_command.clone()))","counters":[{"col_start":0,"col_end":89,"count":0}]},{"line":"                }","counters":[]},{"line":"            }","counters":[]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl GenericTransaction for Transaction {","counters":[]},{"line":"        fn is_fee_transfer(&self) -> bool {","counters":[{"col_start":8,"col_end":42,"count":0}]},{"line":"            matches!(self, Transaction::FeeTransfer(_))","counters":[{"col_start":12,"col_end":20,"count":2},{"col_start":21,"col_end":25,"count":0}]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"        fn is_coinbase(&self) -> bool {","counters":[{"col_start":8,"col_end":38,"count":4}]},{"line":"            matches!(self, Transaction::Coinbase(_))","counters":[{"col_start":12,"col_end":20,"count":0},{"col_start":21,"col_end":25,"count":4}]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":4}]},{"line":"        fn is_command(&self) -> bool {","counters":[{"col_start":8,"col_end":37,"count":0}]},{"line":"            matches!(self, Transaction::Command(_))","counters":[{"col_start":12,"col_end":20,"count":0},{"col_start":21,"col_end":25,"count":0}]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    #[derive(Debug, derive_more::From)]","counters":[{"col_start":13,"col_end":14,"count":0},{"col_start":17,"col_end":18,"count":0},{"col_start":20,"col_end":37,"count":0}]},{"line":"    pub enum Transaction {","counters":[]},{"line":"        Command(UserCommand),","counters":[]},{"line":"        FeeTransfer(super::FeeTransfer),","counters":[]},{"line":"        Coinbase(super::Coinbase),","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl Transaction {","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/transaction/transaction.ml#L61","counters":[]},{"line":"        pub fn forget(&self) -> super::Transaction {","counters":[{"col_start":8,"col_end":52,"count":3}]},{"line":"            match self {","counters":[{"col_start":0,"col_end":22,"count":3}]},{"line":"                Transaction::Command(cmd) => super::Transaction::Command(cmd.forget_check()),","counters":[{"col_start":37,"col_end":92,"count":-2}]},{"line":"                Transaction::FeeTransfer(ft) => super::Transaction::FeeTransfer(ft.clone()),","counters":[{"col_start":41,"col_end":91,"count":0}]},{"line":"                Transaction::Coinbase(cb) => super::Transaction::Coinbase(cb.clone()),","counters":[{"col_start":38,"col_end":85,"count":5}]},{"line":"            }","counters":[]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":3}]},{"line":"    }","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"/// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/mina_base/fee_transfer.ml#L19","counters":[]},{"line":"#[derive(Debug, Clone)]","counters":[{"col_start":9,"col_end":14,"count":0},{"col_start":16,"col_end":21,"count":0}]},{"line":"pub struct SingleFeeTransfer {","counters":[]},{"line":"    pub receiver_pk: CompressedPubKey,","counters":[]},{"line":"    pub fee: Fee,","counters":[]},{"line":"    pub fee_token: TokenId,","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl SingleFeeTransfer {","counters":[]},{"line":"    pub fn receiver(&self) -> AccountId {","counters":[{"col_start":4,"col_end":41,"count":0}]},{"line":"        AccountId {","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"            public_key: self.receiver_pk.clone(),","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"            token_id: self.fee_token.clone(),","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn create(receiver_pk: CompressedPubKey, fee: Fee, fee_token: TokenId) -> Self {","counters":[{"col_start":4,"col_end":88,"count":0}]},{"line":"        Self {","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"            receiver_pk,","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"            fee,","counters":[{"col_start":0,"col_end":16,"count":0}]},{"line":"            fee_token,","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"/// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/mina_base/fee_transfer.ml#L68","counters":[]},{"line":"#[derive(Debug, Clone)]","counters":[{"col_start":9,"col_end":14,"count":0},{"col_start":16,"col_end":21,"count":0}]},{"line":"pub struct FeeTransfer(pub(super) OneOrTwo<SingleFeeTransfer>);","counters":[]},{"line":"","counters":[]},{"line":"impl std::ops::Deref for FeeTransfer {","counters":[]},{"line":"    type Target = OneOrTwo<SingleFeeTransfer>;","counters":[]},{"line":"","counters":[]},{"line":"    fn deref(&self) -> &Self::Target {","counters":[{"col_start":4,"col_end":38,"count":0}]},{"line":"        &self.0","counters":[{"col_start":0,"col_end":15,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl FeeTransfer {","counters":[]},{"line":"    pub fn fee_tokens(&self) -> impl Iterator<Item = &TokenId> {","counters":[{"col_start":4,"col_end":64,"count":0}]},{"line":"        self.0.iter().map(|fee_transfer| &fee_transfer.fee_token)","counters":[{"col_start":0,"col_end":26,"count":0},{"col_start":41,"col_end":64,"count":0},{"col_start":64,"col_end":65,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn receiver_pks(&self) -> impl Iterator<Item = &CompressedPubKey> {","counters":[{"col_start":4,"col_end":75,"count":0}]},{"line":"        self.0.iter().map(|fee_transfer| &fee_transfer.receiver_pk)","counters":[{"col_start":0,"col_end":26,"count":0},{"col_start":41,"col_end":66,"count":0},{"col_start":66,"col_end":67,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn receivers(&self) -> impl Iterator<Item = AccountId> + '_ {","counters":[{"col_start":4,"col_end":69,"count":0}]},{"line":"        self.0.iter().map(|fee_transfer| AccountId {","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"            public_key: fee_transfer.receiver_pk.clone(),","counters":[]},{"line":"            token_id: fee_transfer.fee_token.clone(),","counters":[]},{"line":"        })","counters":[{"col_start":9,"col_end":10,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/e5183ca1dde1c085b4c5d37d1d9987e24c294c32/src/lib/mina_base/fee_transfer.ml#L109","counters":[]},{"line":"    pub fn fee_excess(&self) -> Result<FeeExcess, String> {","counters":[{"col_start":4,"col_end":59,"count":0}]},{"line":"        let one_or_two = self.0.map(|SingleFeeTransfer { fee, fee_token, .. }| {","counters":[{"col_start":0,"col_end":36,"count":0},{"col_start":79,"col_end":80,"count":0}]},{"line":"            (fee_token.clone(), Signed::<Fee>::of_unsigned(*fee).negate())","counters":[{"col_start":0,"col_end":74,"count":0}]},{"line":"        });","counters":[{"col_start":0,"col_end":9,"count":0},{"col_start":9,"col_end":11,"count":0}]},{"line":"        FeeExcess::of_one_or_two(one_or_two)","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/mina_base/fee_transfer.ml#L84","counters":[]},{"line":"    pub fn of_singles(singles: OneOrTwo<SingleFeeTransfer>) -> Result<Self, String> {","counters":[{"col_start":4,"col_end":85,"count":0}]},{"line":"        match singles {","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"            OneOrTwo::One(a) => Ok(Self(OneOrTwo::One(a))),","counters":[{"col_start":26,"col_end":58,"count":0}]},{"line":"            OneOrTwo::Two((one, two)) => {","counters":[{"col_start":27,"col_end":42,"count":0}]},{"line":"                if one.fee_token == two.fee_token {","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"                    Ok(Self(OneOrTwo::Two((one, two))))","counters":[{"col_start":20,"col_end":55,"count":0}]},{"line":"                } else {","counters":[]},{"line":"                    // Necessary invariant for the transaction snark: we should never have","counters":[]},{"line":"                    // fee excesses in multiple tokens simultaneously.","counters":[]},{"line":"                    return Err(format!(","counters":[{"col_start":27,"col_end":39,"count":0}]},{"line":"                        \"Cannot combine single fee transfers with incompatible tokens: {:?} <> {:?}\",","counters":[{"col_start":0,"col_end":101,"count":0}]},{"line":"                        one, two","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"                    ));","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"                }","counters":[]},{"line":"            }","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"#[derive(Debug, Clone)]","counters":[{"col_start":9,"col_end":14,"count":0},{"col_start":16,"col_end":21,"count":0}]},{"line":"pub struct CoinbaseFeeTransfer {","counters":[]},{"line":"    pub receiver_pk: CompressedPubKey,","counters":[]},{"line":"    pub fee: Fee,","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl CoinbaseFeeTransfer {","counters":[]},{"line":"    pub fn create(receiver_pk: CompressedPubKey, fee: Fee) -> Self {","counters":[{"col_start":4,"col_end":68,"count":0}]},{"line":"        Self { receiver_pk, fee }","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn receiver(&self) -> AccountId {","counters":[{"col_start":4,"col_end":41,"count":0}]},{"line":"        AccountId {","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"            public_key: self.receiver_pk.clone(),","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"            token_id: TokenId::default(),","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"/// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/mina_base/coinbase.ml#L17","counters":[]},{"line":"#[derive(Debug, Clone)]","counters":[{"col_start":9,"col_end":14,"count":0},{"col_start":16,"col_end":21,"count":0}]},{"line":"pub struct Coinbase {","counters":[]},{"line":"    pub receiver: CompressedPubKey,","counters":[]},{"line":"    pub amount: Amount,","counters":[]},{"line":"    pub fee_transfer: Option<CoinbaseFeeTransfer>,","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Coinbase {","counters":[]},{"line":"    fn is_valid(&self) -> bool {","counters":[{"col_start":4,"col_end":32,"count":1}]},{"line":"        match &self.fee_transfer {","counters":[{"col_start":0,"col_end":32,"count":1}]},{"line":"            None => true,","counters":[{"col_start":20,"col_end":24,"count":1}]},{"line":"            Some(CoinbaseFeeTransfer { fee, .. }) => Amount::of_fee(fee) <= self.amount,","counters":[{"col_start":39,"col_end":87,"count":0}]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":1}]},{"line":"","counters":[]},{"line":"    pub fn create(","counters":[{"col_start":4,"col_end":18,"count":0}]},{"line":"        amount: Amount,","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"        receiver: CompressedPubKey,","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"        fee_transfer: Option<CoinbaseFeeTransfer>,","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"    ) -> Result<Coinbase, String> {","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"        let mut this = Self {","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"            receiver: receiver.clone(),","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"            amount,","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"            fee_transfer,","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"        };","counters":[{"col_start":0,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"        if this.is_valid() {","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"            let adjusted_fee_transfer = this.fee_transfer.as_ref().and_then(|ft| {","counters":[{"col_start":16,"col_end":76,"count":0},{"col_start":81,"col_end":82,"count":0}]},{"line":"                if receiver != ft.receiver_pk {","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"                    Some(ft.clone())","counters":[{"col_start":20,"col_end":36,"count":0}]},{"line":"                } else {","counters":[]},{"line":"                    None","counters":[{"col_start":20,"col_end":24,"count":0}]},{"line":"                }","counters":[]},{"line":"            });","counters":[{"col_start":12,"col_end":13,"count":0},{"col_start":13,"col_end":15,"count":0}]},{"line":"            this.fee_transfer = adjusted_fee_transfer;","counters":[{"col_start":0,"col_end":54,"count":0}]},{"line":"            Ok(this)","counters":[{"col_start":0,"col_end":20,"count":0}]},{"line":"        } else {","counters":[]},{"line":"            Err(\"Coinbase.create: invalid coinbase\".to_string())","counters":[{"col_start":12,"col_end":64,"count":0}]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/f6756507ff7380a691516ce02a3cf7d9d32915ae/src/lib/mina_base/coinbase.ml#L76","counters":[]},{"line":"    fn expected_supply_increase(&self) -> Result<Amount, String> {","counters":[{"col_start":4,"col_end":66,"count":0}]},{"line":"        let Self {","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"            amount,","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"            fee_transfer,","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"            ..","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"        } = self;","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"","counters":[]},{"line":"        match fee_transfer {","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"            None => Ok(*amount),","counters":[{"col_start":20,"col_end":31,"count":0}]},{"line":"            Some(CoinbaseFeeTransfer { fee, .. }) => amount","counters":[{"col_start":39,"col_end":59,"count":0}]},{"line":"                .checked_sub(&Amount::of_fee(fee))","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"                // The substraction result is ignored here","counters":[{"col_start":0,"col_end":58,"count":0}]},{"line":"                .map(|_| *amount)","counters":[{"col_start":0,"col_end":21,"count":0},{"col_start":25,"col_end":32,"count":0},{"col_start":32,"col_end":33,"count":0}]},{"line":"                .ok_or_else(|| \"Coinbase underflow\".to_string()),","counters":[{"col_start":0,"col_end":28,"count":0},{"col_start":31,"col_end":63,"count":0},{"col_start":63,"col_end":64,"count":0}]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn fee_excess(&self) -> Result<FeeExcess, String> {","counters":[{"col_start":4,"col_end":59,"count":0}]},{"line":"        self.expected_supply_increase().map(|_| FeeExcess::empty())","counters":[{"col_start":0,"col_end":44,"count":0},{"col_start":48,"col_end":66,"count":0},{"col_start":66,"col_end":67,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/mina_base/coinbase.ml#L39","counters":[]},{"line":"    pub fn receiver(&self) -> AccountId {","counters":[{"col_start":4,"col_end":41,"count":0}]},{"line":"        AccountId::new(self.receiver.clone(), TokenId::default())","counters":[{"col_start":0,"col_end":65,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/mina_base/coinbase.ml#L51","counters":[]},{"line":"    pub fn accounts_accessed(&self) -> Vec<AccountId> {","counters":[{"col_start":4,"col_end":55,"count":0}]},{"line":"        let mut ids = Vec::with_capacity(2);","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"        ids.push(self.receiver());","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"","counters":[]},{"line":"        if let Some(fee_transfer) = self.fee_transfer.as_ref() {","counters":[{"col_start":20,"col_end":32,"count":0},{"col_start":36,"col_end":62,"count":0},{"col_start":63,"col_end":64,"count":0}]},{"line":"            ids.push(fee_transfer.receiver());","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"        };","counters":[{"col_start":0,"col_end":9,"count":0},{"col_start":9,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"        ids","counters":[{"col_start":8,"col_end":11,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"/// 0th byte is a tag to distinguish digests from other data","counters":[]},{"line":"/// 1st byte is length, always 32 for digests","counters":[]},{"line":"/// bytes 2 to 33 are data, 0-right-padded if length is less than 32","counters":[]},{"line":"///","counters":[]},{"line":"#[derive(Clone, PartialEq)]","counters":[{"col_start":9,"col_end":14,"count":0}]},{"line":"pub struct Memo(pub [u8; 34]);","counters":[]},{"line":"","counters":[]},{"line":"impl std::fmt::Debug for Memo {","counters":[]},{"line":"    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {","counters":[{"col_start":4,"col_end":72,"count":0}]},{"line":"        use crate::staged_ledger::hash::OCamlString;","counters":[{"col_start":0,"col_end":52,"count":0}]},{"line":"","counters":[]},{"line":"        // Display like OCaml","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"        // Example: \"\\000 \\014WQ\\192&\\229C\\178\\232\\171.\\176`\\153\\218\\161\\209\\229\\223Gw\\143w\\135\\250\\171E\\205\\241/\\227\\168\"","counters":[{"col_start":0,"col_end":122,"count":0}]},{"line":"","counters":[]},{"line":"        f.write_fmt(format_args!(\"\\\"{}\\\"\", self.0.to_ocaml_str()))","counters":[{"col_start":0,"col_end":66,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Memo {","counters":[]},{"line":"    const TAG_INDEX: usize = 0;","counters":[]},{"line":"    const LENGTH_INDEX: usize = 1;","counters":[]},{"line":"","counters":[]},{"line":"    const DIGEST_TAG: u8 = 0x00;","counters":[]},{"line":"    const BYTES_TAG: u8 = 0x01;","counters":[]},{"line":"","counters":[]},{"line":"    const DIGEST_LENGTH: usize = 32; // Blake2.digest_size_in_bytes","counters":[]},{"line":"    const DIGEST_LENGTH_BYTE: u8 = Self::DIGEST_LENGTH as u8;","counters":[]},{"line":"","counters":[]},{"line":"    /// +2 for tag and length bytes","counters":[]},{"line":"    const MEMO_LENGTH: usize = Self::DIGEST_LENGTH + 2;","counters":[]},{"line":"","counters":[]},{"line":"    const MAX_INPUT_LENGTH: usize = Self::DIGEST_LENGTH;","counters":[]},{"line":"","counters":[]},{"line":"    const MAX_DIGESTIBLE_STRING_LENGTH: usize = 1000;","counters":[]},{"line":"","counters":[]},{"line":"    pub fn hash(&self) -> Fp {","counters":[{"col_start":4,"col_end":30,"count":0}]},{"line":"        use mina_hasher::ROInput as LegacyInput;","counters":[{"col_start":0,"col_end":48,"count":0}]},{"line":"","counters":[]},{"line":"        let inputs = LegacyInput::new();","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"        let inputs = inputs.append_bytes(&self.0);","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"","counters":[]},{"line":"        use mina_hasher::{create_legacy, Hashable, Hasher, ROInput};","counters":[{"col_start":0,"col_end":68,"count":0}]},{"line":"","counters":[]},{"line":"        #[derive(Clone)]","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"        struct MyInput(LegacyInput);","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"","counters":[]},{"line":"        impl Hashable for MyInput {","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"            type D = ();","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"","counters":[]},{"line":"            fn to_roinput(&self) -> ROInput {","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"                self.0.clone()","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"            fn domain_string(_: Self::D) -> Option<String> {","counters":[{"col_start":0,"col_end":60,"count":0}]},{"line":"                Some(\"MinaZkappMemo\".to_string())","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        let mut hasher = create_kimchi::<MyInput>(());","counters":[{"col_start":0,"col_end":54,"count":0}]},{"line":"        hasher.update(&MyInput(inputs));","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"        hasher.digest()","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn as_slice(&self) -> &[u8] {","counters":[{"col_start":4,"col_end":37,"count":0}]},{"line":"        self.0.as_slice()","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3a78f0e0c1343d14e2729c8b00205baa2ec70c93/src/lib/mina_base/signed_command_memo.ml#L151","counters":[]},{"line":"    pub fn dummy() -> Self {","counters":[{"col_start":4,"col_end":28,"count":0}]},{"line":"        // TODO","counters":[{"col_start":0,"col_end":15,"count":0}]},{"line":"        Self([0; 34])","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    /// Example:","counters":[]},{"line":"    /// \"\\000 \\014WQ\\192&\\229C\\178\\232\\171.\\176`\\153\\218\\161\\209\\229\\223Gw\\143w\\135\\250\\171E\\205\\241/\\227\\168\"","counters":[]},{"line":"    #[cfg(test)]","counters":[]},{"line":"    pub fn from_ocaml_str(s: &str) -> Self {","counters":[]},{"line":"        use crate::staged_ledger::hash::OCamlString;","counters":[]},{"line":"","counters":[]},{"line":"        Self(<[u8; 34]>::from_ocaml_str(s))","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    pub fn with_number(number: usize) -> Self {","counters":[{"col_start":4,"col_end":47,"count":0}]},{"line":"        let s = format!(\"{:034}\", number);","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"        assert_eq!(s.len(), 34);","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"        Self(s.into_bytes().try_into().unwrap())","counters":[{"col_start":8,"col_end":48,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/d7dad23d8ea2052f515f5d55d187788fe0701c7f/src/lib/mina_base/signed_command_memo.ml#L103","counters":[]},{"line":"    fn create_by_digesting_string_exn(s: &str) -> Self {","counters":[{"col_start":4,"col_end":56,"count":0}]},{"line":"        if s.len() > Self::MAX_DIGESTIBLE_STRING_LENGTH {","counters":[{"col_start":0,"col_end":55,"count":0}]},{"line":"            panic!(\"Too_long_digestible_string\");","counters":[{"col_start":12,"col_end":48,"count":0}]},{"line":"        }","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        let mut memo = [0; 34];","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"        memo[Self::TAG_INDEX] = Self::DIGEST_TAG;","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"        memo[Self::LENGTH_INDEX] = Self::DIGEST_LENGTH_BYTE;","counters":[{"col_start":0,"col_end":60,"count":0}]},{"line":"","counters":[]},{"line":"        use blake2::{","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"            digest::{Update, VariableOutput},","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"            Blake2bVar,","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"        };","counters":[{"col_start":0,"col_end":10,"count":0}]},{"line":"        let mut hasher = Blake2bVar::new(32).expect(\"Invalid Blake2bVar output size\");","counters":[{"col_start":0,"col_end":86,"count":0}]},{"line":"        hasher.update(s.as_bytes());","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"        hasher.finalize_variable(&mut memo[2..]).unwrap();","counters":[{"col_start":0,"col_end":58,"count":0}]},{"line":"","counters":[]},{"line":"        Self(memo)","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/d7dad23d8ea2052f515f5d55d187788fe0701c7f/src/lib/mina_base/signed_command_memo.ml#L193","counters":[]},{"line":"    pub fn gen() -> Self {","counters":[{"col_start":4,"col_end":26,"count":0}]},{"line":"        use rand::distributions::{Alphanumeric, DistString};","counters":[{"col_start":0,"col_end":60,"count":0}]},{"line":"        let random_string = Alphanumeric.sample_string(&mut rand::thread_rng(), 50);","counters":[{"col_start":0,"col_end":84,"count":0}]},{"line":"","counters":[]},{"line":"        Self::create_by_digesting_string_exn(&random_string)","counters":[{"col_start":0,"col_end":60,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"pub mod signed_command {","counters":[]},{"line":"","counters":[]},{"line":"    use mina_signer::Signature;","counters":[]},{"line":"","counters":[]},{"line":"    use crate::{decompress_pk, scan_state::currency::Slot, AccountId};","counters":[]},{"line":"","counters":[]},{"line":"    use super::*;","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/mina_base/signed_command_payload.ml#L75","counters":[]},{"line":"    #[derive(Debug, Clone, PartialEq)]","counters":[{"col_start":13,"col_end":18,"count":0},{"col_start":20,"col_end":25,"count":0}]},{"line":"    pub struct Common {","counters":[]},{"line":"        pub fee: Fee,","counters":[]},{"line":"        pub fee_payer_pk: CompressedPubKey,","counters":[]},{"line":"        pub nonce: Nonce,","counters":[]},{"line":"        pub valid_until: Slot,","counters":[]},{"line":"        pub memo: Memo,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/mina_base/payment_payload.ml#L40","counters":[]},{"line":"    #[derive(Debug, Clone, PartialEq, Eq)]","counters":[{"col_start":13,"col_end":18,"count":0},{"col_start":20,"col_end":25,"count":0}]},{"line":"    pub struct PaymentPayload {","counters":[]},{"line":"        pub source_pk: CompressedPubKey,","counters":[]},{"line":"        pub receiver_pk: CompressedPubKey,","counters":[]},{"line":"        pub amount: Amount,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/mina_base/stake_delegation.ml#L11","counters":[]},{"line":"    #[derive(Debug, Clone, PartialEq, Eq)]","counters":[{"col_start":13,"col_end":18,"count":0},{"col_start":20,"col_end":25,"count":0}]},{"line":"    pub enum StakeDelegationPayload {","counters":[]},{"line":"        SetDelegate {","counters":[]},{"line":"            delegator: CompressedPubKey,","counters":[]},{"line":"            new_delegate: CompressedPubKey,","counters":[]},{"line":"        },","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl StakeDelegationPayload {","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/mina_base/stake_delegation.ml#L30","counters":[]},{"line":"        pub fn source(&self) -> AccountId {","counters":[{"col_start":8,"col_end":43,"count":0}]},{"line":"            let Self::SetDelegate { delegator, .. } = self;","counters":[{"col_start":0,"col_end":59,"count":0}]},{"line":"            AccountId::new(delegator.clone(), TokenId::default())","counters":[{"col_start":0,"col_end":65,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/mina_base/stake_delegation.ml#L28","counters":[]},{"line":"        pub fn source_pk(&self) -> &CompressedPubKey {","counters":[{"col_start":8,"col_end":54,"count":0}]},{"line":"            let Self::SetDelegate { delegator, .. } = self;","counters":[{"col_start":0,"col_end":59,"count":0}]},{"line":"            delegator","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/mina_base/stake_delegation.ml#L24","counters":[]},{"line":"        pub fn receiver(&self) -> AccountId {","counters":[{"col_start":8,"col_end":45,"count":0}]},{"line":"            let Self::SetDelegate { new_delegate, .. } = self;","counters":[{"col_start":0,"col_end":62,"count":0}]},{"line":"            AccountId::new(new_delegate.clone(), TokenId::default())","counters":[{"col_start":0,"col_end":68,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/mina_base/stake_delegation.ml#L22","counters":[]},{"line":"        pub fn receiver_pk(&self) -> &CompressedPubKey {","counters":[{"col_start":8,"col_end":56,"count":0}]},{"line":"            let Self::SetDelegate { new_delegate, .. } = self;","counters":[{"col_start":0,"col_end":62,"count":0}]},{"line":"            new_delegate","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/mina_base/signed_command_payload.mli#L24","counters":[]},{"line":"    #[derive(Debug, Clone, PartialEq, Eq)]","counters":[{"col_start":13,"col_end":14,"count":0},{"col_start":17,"col_end":18,"count":0},{"col_start":20,"col_end":21,"count":0},{"col_start":24,"col_end":25,"count":0}]},{"line":"    pub enum Body {","counters":[]},{"line":"        Payment(PaymentPayload),","counters":[]},{"line":"        StakeDelegation(StakeDelegationPayload),","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/mina_base/signed_command_payload.mli#L165","counters":[]},{"line":"    #[derive(Debug, Clone, PartialEq)]","counters":[{"col_start":13,"col_end":18,"count":1},{"col_start":20,"col_end":25,"count":0}]},{"line":"    pub struct SignedCommandPayload {","counters":[]},{"line":"        pub common: Common,","counters":[]},{"line":"        pub body: Body,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl SignedCommandPayload {","counters":[]},{"line":"        pub fn create(","counters":[{"col_start":8,"col_end":22,"count":0}]},{"line":"            fee: Fee,","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"            fee_payer_pk: CompressedPubKey,","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"            nonce: Nonce,","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"            valid_until: Option<Slot>,","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"            memo: Memo,","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"            body: Body,","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"        ) -> Self {","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"            Self {","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"                common: Common {","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"                    fee,","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"                    fee_payer_pk,","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"                    nonce,","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"                    valid_until: valid_until.unwrap_or_else(Slot::max),","counters":[{"col_start":0,"col_end":71,"count":0}]},{"line":"                    memo,","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"                },","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"                body,","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    #[derive(Debug, Clone, PartialEq)]","counters":[{"col_start":13,"col_end":18,"count":0},{"col_start":20,"col_end":25,"count":0}]},{"line":"    pub struct SignedCommand {","counters":[]},{"line":"        pub payload: SignedCommandPayload,","counters":[]},{"line":"        pub signer: CompressedPubKey, // TODO: This should be a `mina_signer::PubKey`","counters":[]},{"line":"        pub signature: Signature,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl SignedCommand {","counters":[]},{"line":"        pub fn valid_until(&self) -> Slot {","counters":[{"col_start":8,"col_end":43,"count":0}]},{"line":"            self.payload.common.valid_until","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/mina_base/signed_command_payload.ml#L322","counters":[]},{"line":"        pub fn fee_payer(&self) -> AccountId {","counters":[{"col_start":8,"col_end":46,"count":0}]},{"line":"            let public_key = self.payload.common.fee_payer_pk.clone();","counters":[{"col_start":0,"col_end":70,"count":0}]},{"line":"            AccountId::new(public_key, TokenId::default())","counters":[{"col_start":0,"col_end":58,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/mina_base/signed_command_payload.ml#L320","counters":[]},{"line":"        pub fn fee_payer_pk(&self) -> &CompressedPubKey {","counters":[{"col_start":8,"col_end":57,"count":0}]},{"line":"            &self.payload.common.fee_payer_pk","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/mina_base/signed_command_payload.ml#L318","counters":[]},{"line":"        pub fn fee_token(&self) -> TokenId {","counters":[{"col_start":8,"col_end":44,"count":0}]},{"line":"            TokenId::default()","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn fee(&self) -> Fee {","counters":[{"col_start":8,"col_end":34,"count":0}]},{"line":"            self.payload.common.fee","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/mina_base/signed_command_payload.ml#L243","counters":[]},{"line":"        pub fn source(&self) -> AccountId {","counters":[{"col_start":8,"col_end":43,"count":0}]},{"line":"            match &self.payload.body {","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"                Body::Payment(payload) => {","counters":[{"col_start":30,"col_end":43,"count":0}]},{"line":"                    AccountId::new(payload.source_pk.clone(), TokenId::default())","counters":[{"col_start":0,"col_end":81,"count":0}]},{"line":"                }","counters":[]},{"line":"                Body::StakeDelegation(payload) => payload.source(),","counters":[{"col_start":38,"col_end":66,"count":0}]},{"line":"            }","counters":[]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/mina_base/signed_command_payload.ml#L227","counters":[]},{"line":"        pub fn source_pk(&self) -> &CompressedPubKey {","counters":[{"col_start":8,"col_end":54,"count":0}]},{"line":"            match &self.payload.body {","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"                Body::Payment(payload) => &payload.source_pk,","counters":[{"col_start":30,"col_end":60,"count":0}]},{"line":"                Body::StakeDelegation(payload) => payload.source_pk(),","counters":[{"col_start":38,"col_end":69,"count":0}]},{"line":"            }","counters":[]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/mina_base/signed_command_payload.ml#L250","counters":[]},{"line":"        pub fn receiver(&self) -> AccountId {","counters":[{"col_start":8,"col_end":45,"count":0}]},{"line":"            match &self.payload.body {","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"                Body::Payment(payload) => {","counters":[{"col_start":30,"col_end":43,"count":0}]},{"line":"                    AccountId::new(payload.receiver_pk.clone(), TokenId::default())","counters":[{"col_start":0,"col_end":83,"count":0}]},{"line":"                }","counters":[]},{"line":"                Body::StakeDelegation(payload) => payload.receiver(),","counters":[{"col_start":38,"col_end":68,"count":0}]},{"line":"            }","counters":[]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/mina_base/signed_command_payload.ml#L234","counters":[]},{"line":"        pub fn receiver_pk(&self) -> &CompressedPubKey {","counters":[{"col_start":8,"col_end":56,"count":0}]},{"line":"            match &self.payload.body {","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"                Body::Payment(payload) => &payload.receiver_pk,","counters":[{"col_start":30,"col_end":62,"count":0}]},{"line":"                Body::StakeDelegation(payload) => payload.receiver_pk(),","counters":[{"col_start":38,"col_end":71,"count":0}]},{"line":"            }","counters":[]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn nonce(&self) -> Nonce {","counters":[{"col_start":8,"col_end":38,"count":0}]},{"line":"            self.payload.common.nonce","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn fee_excess(&self) -> FeeExcess {","counters":[{"col_start":8,"col_end":47,"count":0}]},{"line":"            FeeExcess::of_single((self.fee_token(), Signed::<Fee>::of_unsigned(self.fee())))","counters":[{"col_start":0,"col_end":92,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/mina_base/signed_command_payload.ml#L354","counters":[]},{"line":"        pub fn accounts_accessed(&self, status: TransactionStatus) -> Vec<AccountId> {","counters":[{"col_start":8,"col_end":86,"count":0}]},{"line":"            use TransactionStatus::*;","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"            match status {","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"                Applied => {","counters":[]},{"line":"                    vec![self.fee_payer(), self.source(), self.receiver()]","counters":[{"col_start":20,"col_end":74,"count":0}]},{"line":"                }","counters":[]},{"line":"                Failed(_) => vec![self.fee_payer()],","counters":[{"col_start":29,"col_end":51,"count":0}]},{"line":"            }","counters":[]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/mina_base/signed_command.ml#L401","counters":[]},{"line":"        pub fn public_keys(&self) -> [&CompressedPubKey; 3] {","counters":[{"col_start":8,"col_end":61,"count":0}]},{"line":"            [self.fee_payer_pk(), self.source_pk(), self.receiver_pk()]","counters":[{"col_start":0,"col_end":71,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/mina_base/signed_command.ml#L407","counters":[]},{"line":"        pub fn check_valid_keys(&self) -> bool {","counters":[{"col_start":8,"col_end":48,"count":0}]},{"line":"            self.public_keys()","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"                .into_iter()","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"                .all(|pk| decompress_pk(pk).is_some())","counters":[{"col_start":0,"col_end":21,"count":0},{"col_start":26,"col_end":53,"count":0},{"col_start":53,"col_end":54,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"pub mod zkapp_command {","counters":[]},{"line":"    use std::rc::Rc;","counters":[]},{"line":"","counters":[]},{"line":"    use ark_ff::{UniformRand, Zero};","counters":[]},{"line":"    use mina_p2p_messages::v2::{","counters":[]},{"line":"        MinaBaseAccountUpdateCallTypeStableV1, MinaBaseAccountUpdateTWireStableV1,","counters":[]},{"line":"        MinaBaseZkappCommandTStableV1WireStableV1AccountUpdatesA,","counters":[]},{"line":"    };","counters":[]},{"line":"    use mina_signer::Signature;","counters":[]},{"line":"    use rand::{seq::SliceRandom, Rng};","counters":[]},{"line":"    //use rand::{seq::SliceRandom, Rng};","counters":[]},{"line":"    use static_assertions::assert_eq_size_val;","counters":[]},{"line":"","counters":[]},{"line":"    use crate::{","counters":[]},{"line":"        account, dummy, gen_keypair, hash_noinputs, hash_with_kimchi,","counters":[]},{"line":"        scan_state::{","counters":[]},{"line":"            conv::AsAccountUpdateWithHash,","counters":[]},{"line":"            currency::{Balance, BlockTime, Length, MinMax, Sgn, Signed, Slot},","counters":[]},{"line":"        },","counters":[]},{"line":"        AuthRequired, ControlTag, Inputs, MyCow, Permissions, ToInputs, TokenSymbol,","counters":[]},{"line":"        VerificationKey, VotingFor, ZkAppUri,","counters":[]},{"line":"    };","counters":[]},{"line":"","counters":[]},{"line":"    use super::*;","counters":[]},{"line":"","counters":[]},{"line":"    #[derive(Debug, Clone, PartialEq)]","counters":[{"col_start":13,"col_end":18,"count":0},{"col_start":20,"col_end":25,"count":0}]},{"line":"    pub struct Event(pub Vec<Fp>);","counters":[]},{"line":"","counters":[]},{"line":"    impl Event {","counters":[]},{"line":"        pub fn hash(&self) -> Fp {","counters":[{"col_start":8,"col_end":34,"count":0}]},{"line":"            hash_with_kimchi(\"MinaZkappEvent\", &self.0[..])","counters":[{"col_start":0,"col_end":59,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/mina_base/account_update.ml#L834","counters":[]},{"line":"    #[derive(Debug, Clone, PartialEq)]","counters":[{"col_start":13,"col_end":18,"count":0},{"col_start":20,"col_end":25,"count":0}]},{"line":"    pub struct Events(pub Vec<Event>);","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3fe924c80a4d01f418b69f27398f5f93eb652514/src/lib/mina_base/zkapp_account.ml#L155","counters":[]},{"line":"    #[derive(Debug, Clone, PartialEq)]","counters":[{"col_start":13,"col_end":18,"count":0},{"col_start":20,"col_end":25,"count":0}]},{"line":"    pub struct SequenceEvents(pub Vec<Event>);","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3fe924c80a4d01f418b69f27398f5f93eb652514/src/lib/mina_base/zkapp_account.ml#L23","counters":[]},{"line":"    trait MakeEvents {","counters":[]},{"line":"        const SALT_PHRASE: &'static str;","counters":[]},{"line":"        const HASH_PREFIX: &'static str;","counters":[]},{"line":"        const DERIVER_NAME: (); // Unused here for now","counters":[]},{"line":"","counters":[]},{"line":"        fn events(&self) -> &[Event];","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3fe924c80a4d01f418b69f27398f5f93eb652514/src/lib/mina_base/zkapp_account.ml#L100","counters":[]},{"line":"    impl MakeEvents for Events {","counters":[]},{"line":"        const SALT_PHRASE: &'static str = \"MinaZkappEventsEmpty\";","counters":[]},{"line":"        const HASH_PREFIX: &'static str = \"MinaZkappEvents\";","counters":[]},{"line":"        const DERIVER_NAME: () = ();","counters":[]},{"line":"        fn events(&self) -> &[Event] {","counters":[{"col_start":8,"col_end":38,"count":0}]},{"line":"            self.0.as_slice()","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3fe924c80a4d01f418b69f27398f5f93eb652514/src/lib/mina_base/zkapp_account.ml#L156","counters":[]},{"line":"    impl MakeEvents for SequenceEvents {","counters":[]},{"line":"        const SALT_PHRASE: &'static str = \"MinaZkappSequenceEmpty\";","counters":[]},{"line":"        const HASH_PREFIX: &'static str = \"MinaZkappSeqEvents\";","counters":[]},{"line":"        const DERIVER_NAME: () = ();","counters":[]},{"line":"        fn events(&self) -> &[Event] {","counters":[{"col_start":8,"col_end":38,"count":0}]},{"line":"            self.0.as_slice()","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3fe924c80a4d01f418b69f27398f5f93eb652514/src/lib/mina_base/zkapp_account.ml#L52","counters":[]},{"line":"    fn events_to_inputs<E>(e: &E, inputs: &mut Inputs)","counters":[{"col_start":4,"col_end":54,"count":0}]},{"line":"    where","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"        E: MakeEvents,","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"    {","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"        let init = hash_noinputs(E::SALT_PHRASE);","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"","counters":[]},{"line":"        let field = e.events().iter().rfold(init, |accum, elem| {","counters":[{"col_start":0,"col_end":50,"count":0},{"col_start":64,"col_end":65,"count":0}]},{"line":"            hash_with_kimchi(E::HASH_PREFIX, &[accum, elem.hash()])","counters":[{"col_start":0,"col_end":67,"count":0}]},{"line":"        });","counters":[{"col_start":0,"col_end":9,"count":0},{"col_start":9,"col_end":11,"count":0}]},{"line":"","counters":[]},{"line":"        inputs.append_field(field);","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    impl ToInputs for Events {","counters":[]},{"line":"        fn to_inputs(&self, inputs: &mut Inputs) {","counters":[{"col_start":8,"col_end":50,"count":0}]},{"line":"            events_to_inputs(self, inputs);","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl ToInputs for SequenceEvents {","counters":[]},{"line":"        fn to_inputs(&self, inputs: &mut Inputs) {","counters":[{"col_start":8,"col_end":50,"count":0}]},{"line":"            events_to_inputs(self, inputs);","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// Note: It's a different one than in the normal `Account`","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3fe924c80a4d01f418b69f27398f5f93eb652514/src/lib/mina_base/account_update.ml#L163","counters":[]},{"line":"    #[derive(Clone, Debug, PartialEq, Eq)]","counters":[{"col_start":13,"col_end":18,"count":0},{"col_start":20,"col_end":25,"count":0}]},{"line":"    pub struct Timing {","counters":[]},{"line":"        pub initial_minimum_balance: Balance,","counters":[]},{"line":"        pub cliff_time: Slot,","counters":[]},{"line":"        pub cliff_amount: Amount,","counters":[]},{"line":"        pub vesting_period: Slot,","counters":[]},{"line":"        pub vesting_increment: Amount,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl Timing {","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/3fe924c80a4d01f418b69f27398f5f93eb652514/src/lib/mina_base/account_update.ml#L208","counters":[]},{"line":"        fn dummy() -> Self {","counters":[{"col_start":8,"col_end":28,"count":0}]},{"line":"            Self {","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"                initial_minimum_balance: Balance::zero(),","counters":[{"col_start":0,"col_end":57,"count":0}]},{"line":"                cliff_time: Slot::zero(),","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"                cliff_amount: Amount::zero(),","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"                vesting_period: Slot::zero(),","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"                vesting_increment: Amount::zero(),","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/3fe924c80a4d01f418b69f27398f5f93eb652514/src/lib/transaction_logic/mina_transaction_logic.ml#L1278","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/3fe924c80a4d01f418b69f27398f5f93eb652514/src/lib/mina_base/account_update.ml#L228","counters":[]},{"line":"        pub fn of_account_timing(timing: crate::account::Timing) -> Option<Self> {","counters":[{"col_start":8,"col_end":82,"count":0}]},{"line":"            match timing {","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"                crate::Timing::Untimed => None,","counters":[{"col_start":42,"col_end":46,"count":0}]},{"line":"                crate::Timing::Timed {","counters":[]},{"line":"                    initial_minimum_balance,","counters":[{"col_start":20,"col_end":44,"count":0}]},{"line":"                    cliff_time,","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"                    cliff_amount,","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"                    vesting_period,","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"                    vesting_increment,","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"                } => Some(Self {","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"                    initial_minimum_balance,","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"                    cliff_time,","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"                    cliff_amount,","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"                    vesting_period,","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"                    vesting_increment,","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"                }),","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"            }","counters":[]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/3fe924c80a4d01f418b69f27398f5f93eb652514/src/lib/mina_base/account_update.ml#L219","counters":[]},{"line":"        pub fn to_account_timing(self) -> crate::account::Timing {","counters":[{"col_start":8,"col_end":66,"count":0}]},{"line":"            let Self {","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"                initial_minimum_balance,","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"                cliff_time,","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"                cliff_amount,","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"                vesting_period,","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"                vesting_increment,","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"            } = self;","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"","counters":[]},{"line":"            crate::account::Timing::Timed {","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"                initial_minimum_balance,","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"                cliff_time,","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"                cliff_amount,","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"                vesting_period,","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"                vesting_increment,","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl ToInputs for Timing {","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/3fe924c80a4d01f418b69f27398f5f93eb652514/src/lib/mina_base/account_update.ml#L199","counters":[]},{"line":"        fn to_inputs(&self, inputs: &mut Inputs) {","counters":[{"col_start":8,"col_end":50,"count":0}]},{"line":"            let Timing {","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"                initial_minimum_balance,","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"                cliff_time,","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"                cliff_amount,","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"                vesting_period,","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"                vesting_increment,","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"            } = self;","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"","counters":[]},{"line":"            inputs.append_u64(initial_minimum_balance.as_u64());","counters":[{"col_start":0,"col_end":64,"count":0}]},{"line":"            inputs.append_u32(cliff_time.as_u32());","counters":[{"col_start":0,"col_end":51,"count":0}]},{"line":"            inputs.append_u64(cliff_amount.as_u64());","counters":[{"col_start":0,"col_end":53,"count":0}]},{"line":"            inputs.append_u32(vesting_period.as_u32());","counters":[{"col_start":0,"col_end":55,"count":0}]},{"line":"            inputs.append_u64(vesting_increment.as_u64());","counters":[{"col_start":0,"col_end":58,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl Events {","counters":[]},{"line":"        pub fn empty() -> Self {","counters":[{"col_start":8,"col_end":32,"count":0}]},{"line":"            Self(Vec::new())","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn is_empty(&self) -> bool {","counters":[{"col_start":8,"col_end":40,"count":0}]},{"line":"            self.0.is_empty()","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn push_event(acc: Fp, event: Event) -> Fp {","counters":[{"col_start":8,"col_end":56,"count":0}]},{"line":"            hash_with_kimchi(\"MinaZkappEvents\", &[acc, event.hash()])","counters":[{"col_start":0,"col_end":69,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn push_events(&self, acc: Fp) -> Fp {","counters":[{"col_start":8,"col_end":50,"count":0}]},{"line":"            let hash = self","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"                .0","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"                .iter()","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"                .rfold(hash_noinputs(\"MinaZkappEventsEmpty\"), |acc, e| {","counters":[{"col_start":0,"col_end":62,"count":0},{"col_start":71,"col_end":72,"count":0}]},{"line":"                    Self::push_event(acc, e.clone())","counters":[{"col_start":0,"col_end":52,"count":0}]},{"line":"                });","counters":[{"col_start":0,"col_end":17,"count":0},{"col_start":17,"col_end":19,"count":0}]},{"line":"            hash_with_kimchi(\"MinaZkappEvents\", &[acc, hash])","counters":[{"col_start":0,"col_end":61,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl SequenceEvents {","counters":[]},{"line":"        pub fn empty() -> Self {","counters":[{"col_start":8,"col_end":32,"count":0}]},{"line":"            Self(Vec::new())","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn is_empty(&self) -> bool {","counters":[{"col_start":8,"col_end":40,"count":0}]},{"line":"            self.0.is_empty()","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn push_event(acc: Fp, event: Event) -> Fp {","counters":[{"col_start":8,"col_end":56,"count":0}]},{"line":"            hash_with_kimchi(\"MinaZkappSeqEvents\", &[acc, event.hash()])","counters":[{"col_start":0,"col_end":72,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn push_events(&self, acc: Fp) -> Fp {","counters":[{"col_start":8,"col_end":50,"count":0}]},{"line":"            let hash = self","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"                .0","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"                .iter()","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"                .rfold(hash_noinputs(\"MinaZkappSequenceEmpty\"), |acc, e| {","counters":[{"col_start":0,"col_end":64,"count":0},{"col_start":73,"col_end":74,"count":0}]},{"line":"                    Self::push_event(acc, e.clone())","counters":[{"col_start":0,"col_end":52,"count":0}]},{"line":"                });","counters":[{"col_start":0,"col_end":17,"count":0},{"col_start":17,"col_end":19,"count":0}]},{"line":"            hash_with_kimchi(\"MinaZkappSeqEvents\", &[acc, hash])","counters":[{"col_start":0,"col_end":64,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/mina_base/zkapp_basic.ml#L100","counters":[]},{"line":"    #[derive(Debug, Clone, PartialEq, Eq)]","counters":[{"col_start":13,"col_end":14,"count":0},{"col_start":17,"col_end":18,"count":0},{"col_start":20,"col_end":21,"count":0},{"col_start":24,"col_end":25,"count":0}]},{"line":"    pub enum SetOrKeep<T: Clone> {","counters":[]},{"line":"        Set(T),","counters":[]},{"line":"        Keep,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl<T: Clone> SetOrKeep<T> {","counters":[]},{"line":"        fn map<'a, F, U>(&'a self, fun: F) -> SetOrKeep<U>","counters":[{"col_start":8,"col_end":58,"count":0}]},{"line":"        where","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"            F: FnOnce(&'a T) -> U,","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"            U: Clone,","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"        {","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"            match self {","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"                SetOrKeep::Set(v) => SetOrKeep::Set(fun(v)),","counters":[{"col_start":31,"col_end":59,"count":0}]},{"line":"                SetOrKeep::Keep => SetOrKeep::Keep,","counters":[{"col_start":35,"col_end":50,"count":0}]},{"line":"            }","counters":[]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn into_map<F, U>(self, fun: F) -> SetOrKeep<U>","counters":[{"col_start":8,"col_end":59,"count":0}]},{"line":"        where","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"            F: FnOnce(T) -> U,","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"            U: Clone,","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"        {","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"            match self {","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"                SetOrKeep::Set(v) => SetOrKeep::Set(fun(v)),","counters":[{"col_start":31,"col_end":59,"count":0}]},{"line":"                SetOrKeep::Keep => SetOrKeep::Keep,","counters":[{"col_start":35,"col_end":50,"count":0}]},{"line":"            }","counters":[]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn set_or_keep(&self, x: T) -> T {","counters":[{"col_start":8,"col_end":46,"count":155}]},{"line":"            match self {","counters":[{"col_start":0,"col_end":22,"count":155}]},{"line":"                Self::Set(data) => data.clone(),","counters":[{"col_start":16,"col_end":47,"count":155}]},{"line":"                Self::Keep => x,","counters":[{"col_start":16,"col_end":31,"count":620}]},{"line":"            }","counters":[]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":155}]},{"line":"","counters":[]},{"line":"        pub fn is_keep(&self) -> bool {","counters":[{"col_start":8,"col_end":39,"count":8060}]},{"line":"            match self {","counters":[{"col_start":0,"col_end":22,"count":8060}]},{"line":"                Self::Keep => true,","counters":[{"col_start":16,"col_end":34,"count":2575}]},{"line":"                Self::Set(_) => false,","counters":[{"col_start":16,"col_end":37,"count":7905}]},{"line":"            }","counters":[]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":8060}]},{"line":"","counters":[]},{"line":"        pub fn is_set(&self) -> bool {","counters":[{"col_start":8,"col_end":38,"count":0}]},{"line":"            !self.is_keep()","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn gen<F>(mut fun: F) -> Self","counters":[{"col_start":8,"col_end":41,"count":11935}]},{"line":"        where","counters":[{"col_start":0,"col_end":13,"count":11935}]},{"line":"            F: FnMut() -> T,","counters":[{"col_start":0,"col_end":28,"count":11935}]},{"line":"        {","counters":[{"col_start":0,"col_end":9,"count":11935}]},{"line":"            let mut rng = rand::thread_rng();","counters":[{"col_start":0,"col_end":45,"count":11935}]},{"line":"","counters":[]},{"line":"            if rng.gen() {","counters":[{"col_start":0,"col_end":24,"count":11935}]},{"line":"                Self::Set(fun())","counters":[{"col_start":16,"col_end":32,"count":155}]},{"line":"            } else {","counters":[]},{"line":"                Self::Keep","counters":[{"col_start":16,"col_end":26,"count":11935}]},{"line":"            }","counters":[]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":11935}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl<T, F> ToInputs for (&SetOrKeep<T>, F)","counters":[]},{"line":"    where","counters":[]},{"line":"        T: ToInputs,","counters":[]},{"line":"        T: Clone,","counters":[]},{"line":"        F: Fn() -> T,","counters":[]},{"line":"    {","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/3fe924c80a4d01f418b69f27398f5f93eb652514/src/lib/mina_base/zkapp_basic.ml#L223","counters":[]},{"line":"        fn to_inputs(&self, inputs: &mut Inputs) {","counters":[{"col_start":8,"col_end":50,"count":0}]},{"line":"            let (set_or_keep, default_fn) = self;","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"","counters":[]},{"line":"            match set_or_keep {","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"                SetOrKeep::Set(this) => {","counters":[{"col_start":31,"col_end":41,"count":0}]},{"line":"                    inputs.append_bool(true);","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"                    this.to_inputs(inputs);","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"                }","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"                SetOrKeep::Keep => {","counters":[{"col_start":35,"col_end":36,"count":0}]},{"line":"                    inputs.append_bool(false);","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"                    let default = default_fn();","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"                    default.to_inputs(inputs);","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"                }","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"            };","counters":[]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    #[derive(Debug, Clone, PartialEq, Eq)]","counters":[{"col_start":13,"col_end":18,"count":0},{"col_start":20,"col_end":25,"count":0}]},{"line":"    pub struct WithHash<T> {","counters":[]},{"line":"        pub data: T,","counters":[]},{"line":"        pub hash: Fp,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/mina_base/account_update.ml#L319","counters":[]},{"line":"    #[derive(Debug, Clone, PartialEq, Eq)]","counters":[{"col_start":13,"col_end":18,"count":0},{"col_start":20,"col_end":25,"count":0}]},{"line":"    pub struct Update {","counters":[]},{"line":"        pub app_state: [SetOrKeep<Fp>; 8],","counters":[]},{"line":"        pub delegate: SetOrKeep<CompressedPubKey>,","counters":[]},{"line":"        pub verification_key: SetOrKeep<WithHash<VerificationKey>>,","counters":[]},{"line":"        pub permissions: SetOrKeep<Permissions<AuthRequired>>,","counters":[]},{"line":"        pub zkapp_uri: SetOrKeep<ZkAppUri>,","counters":[]},{"line":"        pub token_symbol: SetOrKeep<TokenSymbol>,","counters":[]},{"line":"        pub timing: SetOrKeep<Timing>,","counters":[]},{"line":"        pub voting_for: SetOrKeep<VotingFor>,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl Update {","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/mina_base/account_update.ml#L460","counters":[]},{"line":"        pub fn noop() -> Self {","counters":[{"col_start":8,"col_end":31,"count":0}]},{"line":"            Self {","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"                app_state: std::array::from_fn(|_| SetOrKeep::Keep),","counters":[{"col_start":0,"col_end":47,"count":0},{"col_start":51,"col_end":66,"count":0},{"col_start":66,"col_end":68,"count":0}]},{"line":"                delegate: SetOrKeep::Keep,","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"                verification_key: SetOrKeep::Keep,","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"                permissions: SetOrKeep::Keep,","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"                zkapp_uri: SetOrKeep::Keep,","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"                token_symbol: SetOrKeep::Keep,","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"                timing: SetOrKeep::Keep,","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"                voting_for: SetOrKeep::Keep,","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/mina_base/account_update.ml#L472","counters":[]},{"line":"        pub fn dummy() -> Self {","counters":[{"col_start":8,"col_end":32,"count":0}]},{"line":"            Self::noop()","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/mina_base/account_update.ml#L338","counters":[]},{"line":"        pub fn gen(","counters":[{"col_start":8,"col_end":19,"count":0}]},{"line":"            token_account: Option<bool>,","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"            zkapp_account: Option<bool>,","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"            vk: Option<&WithHash<VerificationKey>>,","counters":[{"col_start":0,"col_end":51,"count":0}]},{"line":"            permissions_auth: Option<crate::ControlTag>,","counters":[{"col_start":0,"col_end":56,"count":0}]},{"line":"        ) -> Self {","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"            let mut rng = rand::thread_rng();","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"","counters":[]},{"line":"            let token_account = token_account.unwrap_or(false);","counters":[{"col_start":0,"col_end":63,"count":0}]},{"line":"            let zkapp_account = zkapp_account.unwrap_or(false);","counters":[{"col_start":0,"col_end":63,"count":0}]},{"line":"","counters":[]},{"line":"            let app_state: [_; 8] = std::array::from_fn(|_| SetOrKeep::gen(|| Fp::rand(&mut rng)));","counters":[{"col_start":0,"col_end":56,"count":0},{"col_start":60,"col_end":75,"count":0},{"col_start":78,"col_end":96,"count":0},{"col_start":96,"col_end":97,"count":0},{"col_start":97,"col_end":98,"count":0}]},{"line":"","counters":[]},{"line":"            let delegate = if !token_account {","counters":[{"col_start":16,"col_end":24,"count":0},{"col_start":30,"col_end":44,"count":0}]},{"line":"                SetOrKeep::gen(|| gen_keypair().public.into_compressed())","counters":[{"col_start":16,"col_end":31,"count":0},{"col_start":34,"col_end":72,"count":0},{"col_start":72,"col_end":73,"count":0}]},{"line":"            } else {","counters":[]},{"line":"                SetOrKeep::Keep","counters":[{"col_start":16,"col_end":31,"count":0}]},{"line":"            };","counters":[]},{"line":"","counters":[]},{"line":"            let verification_key = if zkapp_account {","counters":[{"col_start":16,"col_end":32,"count":0},{"col_start":38,"col_end":51,"count":0}]},{"line":"                SetOrKeep::gen(|| match vk {","counters":[{"col_start":16,"col_end":31,"count":0},{"col_start":34,"col_end":42,"count":0}]},{"line":"                    None => {","counters":[]},{"line":"                        let dummy = VerificationKey::dummy();","counters":[{"col_start":28,"col_end":61,"count":0}]},{"line":"                        let hash = dummy.digest();","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"                        WithHash { data: dummy, hash }","counters":[{"col_start":0,"col_end":54,"count":0}]},{"line":"                    }","counters":[]},{"line":"                    Some(vk) => vk.clone(),","counters":[{"col_start":25,"col_end":42,"count":0}]},{"line":"                })","counters":[{"col_start":16,"col_end":17,"count":0},{"col_start":17,"col_end":18,"count":0}]},{"line":"            } else {","counters":[]},{"line":"                SetOrKeep::Keep","counters":[{"col_start":16,"col_end":31,"count":0}]},{"line":"            };","counters":[]},{"line":"","counters":[]},{"line":"            let permissions = match permissions_auth {","counters":[{"col_start":16,"col_end":27,"count":0},{"col_start":36,"col_end":52,"count":0}]},{"line":"                None => SetOrKeep::Keep,","counters":[{"col_start":24,"col_end":39,"count":0}]},{"line":"                Some(auth_tag) => SetOrKeep::Set(Permissions::gen(auth_tag)),","counters":[{"col_start":21,"col_end":76,"count":0}]},{"line":"            };","counters":[]},{"line":"","counters":[]},{"line":"            let zkapp_uri = SetOrKeep::gen(|| {","counters":[{"col_start":16,"col_end":43,"count":0},{"col_start":46,"col_end":47,"count":0}]},{"line":"                ZkAppUri::from(","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"                    [","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"                        \"https://www.example.com\",","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"                        \"https://www.minaprotocol.com\",","counters":[{"col_start":0,"col_end":55,"count":0}]},{"line":"                        \"https://www.gurgle.com\",","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"                        \"https://faceplant.com\",","counters":[{"col_start":0,"col_end":48,"count":0}]},{"line":"                    ]","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"                    .choose(&mut rng)","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"                    .unwrap()","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"                    .to_string(),","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"                )","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"            });","counters":[{"col_start":0,"col_end":13,"count":0},{"col_start":13,"col_end":15,"count":0}]},{"line":"","counters":[]},{"line":"            let token_symbol = SetOrKeep::gen(|| {","counters":[{"col_start":0,"col_end":46,"count":0},{"col_start":49,"col_end":50,"count":0}]},{"line":"                TokenSymbol::from(","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"                    [\"MINA\", \"TOKEN1\", \"TOKEN2\", \"TOKEN3\", \"TOKEN4\", \"TOKEN5\"]","counters":[{"col_start":0,"col_end":78,"count":0}]},{"line":"                        .choose(&mut rng)","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"                        .unwrap()","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"                        .to_string(),","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"                )","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"            });","counters":[{"col_start":0,"col_end":13,"count":0},{"col_start":13,"col_end":15,"count":0}]},{"line":"","counters":[]},{"line":"            let voting_for = SetOrKeep::gen(|| VotingFor(Fp::rand(&mut rng)));","counters":[{"col_start":0,"col_end":44,"count":0},{"col_start":47,"col_end":76,"count":0},{"col_start":76,"col_end":78,"count":0}]},{"line":"","counters":[]},{"line":"            let timing = SetOrKeep::Keep;","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"","counters":[]},{"line":"            Self {","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"                app_state,","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"                delegate,","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"                verification_key,","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"                permissions,","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"                zkapp_uri,","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"                token_symbol,","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"                timing,","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"                voting_for,","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    pub trait Check {","counters":[]},{"line":"        type A;","counters":[]},{"line":"        type B;","counters":[]},{"line":"","counters":[]},{"line":"        fn check(&self, label: String, x: Self::B) -> Result<(), String>;","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl<T> Check for T","counters":[]},{"line":"    where","counters":[]},{"line":"        T: Eq,","counters":[]},{"line":"    {","counters":[]},{"line":"        type A = T;","counters":[]},{"line":"        type B = T;","counters":[]},{"line":"","counters":[]},{"line":"        fn check(&self, label: String, rhs: Self::B) -> Result<(), String> {","counters":[{"col_start":8,"col_end":76,"count":0}]},{"line":"            if *self == rhs {","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"                Ok(())","counters":[{"col_start":16,"col_end":22,"count":0}]},{"line":"            } else {","counters":[]},{"line":"                Err(format!(\"Equality check failed: {}\", label))","counters":[{"col_start":16,"col_end":64,"count":0}]},{"line":"            }","counters":[]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    // TODO: This could be std::ops::Range ?","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/mina_base/zkapp_precondition.ml#L23","counters":[]},{"line":"    #[derive(Debug, Clone, PartialEq)]","counters":[{"col_start":13,"col_end":18,"count":0},{"col_start":20,"col_end":25,"count":0}]},{"line":"    pub struct ClosedInterval<T> {","counters":[]},{"line":"        pub lower: T,","counters":[]},{"line":"        pub upper: T,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl<T> ClosedInterval<T>","counters":[]},{"line":"    where","counters":[]},{"line":"        T: MinMax,","counters":[]},{"line":"    {","counters":[]},{"line":"        fn min_max() -> Self {","counters":[{"col_start":8,"col_end":30,"count":0}]},{"line":"            Self {","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"                lower: T::min(),","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"                upper: T::max(),","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl<T> ToInputs for ClosedInterval<T>","counters":[]},{"line":"    where","counters":[]},{"line":"        T: ToInputs,","counters":[]},{"line":"    {","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/3fe924c80a4d01f418b69f27398f5f93eb652514/src/lib/mina_base/zkapp_precondition.ml#L37","counters":[]},{"line":"        fn to_inputs(&self, inputs: &mut Inputs) {","counters":[{"col_start":8,"col_end":50,"count":8060}]},{"line":"            let ClosedInterval { lower, upper } = self;","counters":[{"col_start":0,"col_end":55,"count":8060}]},{"line":"","counters":[]},{"line":"            lower.to_inputs(inputs);","counters":[{"col_start":0,"col_end":36,"count":8060}]},{"line":"            upper.to_inputs(inputs);","counters":[{"col_start":0,"col_end":36,"count":8060}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":8060}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl<T> Check for ClosedInterval<T>","counters":[]},{"line":"    where","counters":[]},{"line":"        T: PartialOrd + std::fmt::Debug,","counters":[]},{"line":"    {","counters":[]},{"line":"        type A = ClosedInterval<T>;","counters":[]},{"line":"        type B = T;","counters":[]},{"line":"","counters":[]},{"line":"        fn check(&self, label: String, rhs: Self::B) -> Result<(), String> {","counters":[{"col_start":8,"col_end":76,"count":0}]},{"line":"            /*println!(","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"                \"bounds check lower {:?} rhs {:?} upper {:?}\",","counters":[{"col_start":0,"col_end":62,"count":0}]},{"line":"                self.lower, rhs, self.upper","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"            );*/","counters":[{"col_start":0,"col_end":16,"count":0}]},{"line":"            if self.lower <= rhs && rhs <= self.upper {","counters":[{"col_start":0,"col_end":32,"count":0},{"col_start":36,"col_end":53,"count":272}]},{"line":"                Ok(())","counters":[{"col_start":16,"col_end":22,"count":0}]},{"line":"            } else {","counters":[]},{"line":"                Err(format!(\"Bounds check failed: {}\", label))","counters":[{"col_start":16,"col_end":62,"count":20}]},{"line":"            }","counters":[]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":20}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl<T> ClosedInterval<T>","counters":[]},{"line":"    where","counters":[]},{"line":"        T: PartialOrd,","counters":[]},{"line":"    {","counters":[]},{"line":"        pub fn is_constant(&self) -> bool {","counters":[{"col_start":8,"col_end":43,"count":0}]},{"line":"            self.lower == self.upper","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/d7d4aa4d650eb34b45a42b29276554802683ce15/src/lib/mina_base/zkapp_precondition.ml#L30","counters":[]},{"line":"        pub fn gen<F>(mut fun: F) -> Self","counters":[{"col_start":8,"col_end":41,"count":0}]},{"line":"        where","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"            F: FnMut() -> T,","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"        {","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"            let a1 = fun();","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"            let a2 = fun();","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"","counters":[]},{"line":"            if a1 <= a2 {","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"                Self {","counters":[{"col_start":16,"col_end":22,"count":0}]},{"line":"                    lower: a1,","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"                    upper: a2,","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"                }","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"            } else {","counters":[]},{"line":"                Self {","counters":[{"col_start":16,"col_end":22,"count":0}]},{"line":"                    lower: a2,","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"                    upper: a1,","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"                }","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"            }","counters":[]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/mina_base/zkapp_basic.ml#L232","counters":[]},{"line":"    #[derive(Debug, Clone, PartialEq)]","counters":[{"col_start":13,"col_end":14,"count":0},{"col_start":17,"col_end":18,"count":0},{"col_start":20,"col_end":21,"count":0},{"col_start":24,"col_end":25,"count":0}]},{"line":"    pub enum OrIgnore<T> {","counters":[]},{"line":"        Check(T),","counters":[]},{"line":"        Ignore,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl<T, F> ToInputs for (&OrIgnore<T>, F)","counters":[]},{"line":"    where","counters":[]},{"line":"        T: ToInputs,","counters":[]},{"line":"        F: Fn() -> T,","counters":[]},{"line":"    {","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/3fe924c80a4d01f418b69f27398f5f93eb652514/src/lib/mina_base/zkapp_precondition.ml#L414","counters":[]},{"line":"        fn to_inputs(&self, inputs: &mut Inputs) {","counters":[{"col_start":8,"col_end":50,"count":0}]},{"line":"            let (or_ignore, default_fn) = self;","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"","counters":[]},{"line":"            match or_ignore {","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"                OrIgnore::Check(this) => {","counters":[{"col_start":32,"col_end":42,"count":0}]},{"line":"                    inputs.append_bool(true);","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"                    this.to_inputs(inputs);","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"                }","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"                OrIgnore::Ignore => {","counters":[{"col_start":36,"col_end":37,"count":0}]},{"line":"                    inputs.append_bool(false);","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"                    let default = default_fn();","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"                    default.to_inputs(inputs);","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"                }","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"            };","counters":[]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl<T> OrIgnore<T>","counters":[]},{"line":"    where","counters":[]},{"line":"        T: Check<A = T>,","counters":[]},{"line":"    {","counters":[]},{"line":"        fn check(&self, label: String, rhs: T::B) -> Result<(), String> {","counters":[{"col_start":8,"col_end":72,"count":0}]},{"line":"            let ret = match self {","counters":[{"col_start":16,"col_end":19,"count":0},{"col_start":28,"col_end":32,"count":0}]},{"line":"                Self::Ignore => Ok(()),","counters":[{"col_start":16,"col_end":38,"count":0}]},{"line":"                Self::Check(t) => t.check(label.clone(), rhs),","counters":[{"col_start":16,"col_end":61,"count":0}]},{"line":"            };","counters":[]},{"line":"            //println!(\"[rust] check {}, {:?}\", label, ret);","counters":[]},{"line":"            ret","counters":[{"col_start":12,"col_end":15,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl<T> OrIgnore<T> {","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/d7d4aa4d650eb34b45a42b29276554802683ce15/src/lib/mina_base/zkapp_basic.ml#L239","counters":[]},{"line":"        pub fn gen<F>(mut fun: F) -> Self","counters":[{"col_start":8,"col_end":41,"count":0}]},{"line":"        where","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"            F: FnMut() -> T,","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"        {","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"            let mut rng = rand::thread_rng();","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"","counters":[]},{"line":"            if rng.gen() {","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"                Self::Check(fun())","counters":[{"col_start":16,"col_end":34,"count":0}]},{"line":"            } else {","counters":[]},{"line":"                Self::Ignore","counters":[{"col_start":16,"col_end":28,"count":0}]},{"line":"            }","counters":[]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn map<F, V>(&self, fun: F) -> OrIgnore<V>","counters":[{"col_start":8,"col_end":54,"count":0}]},{"line":"        where","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"            F: Fn(&T) -> V,","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"        {","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"            match self {","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"                OrIgnore::Check(v) => OrIgnore::Check(fun(v)),","counters":[{"col_start":32,"col_end":61,"count":0}]},{"line":"                OrIgnore::Ignore => OrIgnore::Ignore,","counters":[{"col_start":36,"col_end":52,"count":0}]},{"line":"            }","counters":[]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl<T> OrIgnore<ClosedInterval<T>>","counters":[]},{"line":"    where","counters":[]},{"line":"        T: PartialOrd,","counters":[]},{"line":"    {","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/mina_base/zkapp_precondition.ml#L294","counters":[]},{"line":"        pub fn is_constant(&self) -> bool {","counters":[{"col_start":8,"col_end":43,"count":0}]},{"line":"            match self {","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"                OrIgnore::Check(interval) => interval.lower == interval.upper,","counters":[{"col_start":32,"col_end":77,"count":0}]},{"line":"                OrIgnore::Ignore => false,","counters":[{"col_start":36,"col_end":41,"count":0}]},{"line":"            }","counters":[]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/mina_base/zkapp_precondition.ml#L439","counters":[]},{"line":"    pub type Hash<T> = OrIgnore<T>;","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/mina_base/zkapp_precondition.ml#L298","counters":[]},{"line":"    pub type EqData<T> = OrIgnore<T>;","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/mina_base/zkapp_precondition.ml#L178","counters":[]},{"line":"    pub type Numeric<T> = OrIgnore<ClosedInterval<T>>;","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/mina_base/epoch_ledger.ml#L9","counters":[]},{"line":"    #[derive(Debug, Clone, PartialEq)]","counters":[{"col_start":13,"col_end":18,"count":0},{"col_start":20,"col_end":25,"count":0}]},{"line":"    pub struct EpochLedger {","counters":[]},{"line":"        pub hash: Hash<Fp>,","counters":[]},{"line":"        pub total_currency: Numeric<Amount>,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl EpochLedger {","counters":[]},{"line":"        pub fn epoch_ledger(&self, t: protocol_state::EpochLedger) -> Result<(), String> {","counters":[]},{"line":"            self.hash.check(\"epoch_ledger_hash\".to_string(), t.hash)?;","counters":[{"col_start":12,"col_end":68,"count":0},{"col_start":68,"col_end":69,"count":0}]},{"line":"            self.total_currency","counters":[{"col_start":12,"col_end":31,"count":0}]},{"line":"                .check(\"epoch_ledger_total_currency\".to_string(), t.total_currency)","counters":[{"col_start":0,"col_end":83,"count":0}]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/mina_base/zkapp_precondition.ml#L797","counters":[]},{"line":"    #[derive(Debug, Clone, PartialEq)]","counters":[{"col_start":13,"col_end":18,"count":0},{"col_start":20,"col_end":25,"count":0}]},{"line":"    pub struct EpochData {","counters":[]},{"line":"        pub(crate) ledger: EpochLedger,","counters":[]},{"line":"        pub seed: Hash<Fp>,","counters":[]},{"line":"        pub start_checkpoint: Hash<Fp>,","counters":[]},{"line":"        pub lock_checkpoint: Hash<Fp>,","counters":[]},{"line":"        pub epoch_length: Numeric<Length>,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl ToInputs for EpochData {","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/3fe924c80a4d01f418b69f27398f5f93eb652514/src/lib/mina_base/zkapp_precondition.ml#L875","counters":[]},{"line":"        fn to_inputs(&self, inputs: &mut Inputs) {","counters":[{"col_start":8,"col_end":50,"count":0}]},{"line":"            let EpochData {","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"                ledger,","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"                seed,","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"                start_checkpoint,","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"                lock_checkpoint,","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"                epoch_length,","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"            } = self;","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"","counters":[]},{"line":"            {","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"                let EpochLedger {","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"                    hash,","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"                    total_currency,","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"                } = ledger;","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"","counters":[]},{"line":"                inputs.append(&(hash, Fp::zero));","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"                inputs.append(&(total_currency, ClosedInterval::min_max));","counters":[{"col_start":0,"col_end":74,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"            inputs.append(&(seed, Fp::zero));","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"            inputs.append(&(start_checkpoint, Fp::zero));","counters":[{"col_start":0,"col_end":57,"count":0}]},{"line":"            inputs.append(&(lock_checkpoint, Fp::zero));","counters":[{"col_start":0,"col_end":56,"count":0}]},{"line":"            inputs.append(&(epoch_length, ClosedInterval::min_max));","counters":[{"col_start":0,"col_end":68,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl EpochData {","counters":[]},{"line":"        pub fn epoch_data(&self, label: &str, t: protocol_state::EpochData) -> Result<(), String> {","counters":[]},{"line":"            self.ledger.epoch_ledger(t.ledger)?;","counters":[{"col_start":12,"col_end":46,"count":0},{"col_start":46,"col_end":47,"count":0}]},{"line":"            // ignore seed","counters":[]},{"line":"            self.start_checkpoint.check(","counters":[{"col_start":12,"col_end":40,"count":0}]},{"line":"                format!(\"{}_{}\", label, \"start_checkpoint\"),","counters":[{"col_start":0,"col_end":60,"count":0}]},{"line":"                t.start_checkpoint,","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"            )?;","counters":[{"col_start":0,"col_end":13,"count":0},{"col_start":13,"col_end":14,"count":0}]},{"line":"            self.lock_checkpoint.check(","counters":[{"col_start":12,"col_end":39,"count":0}]},{"line":"                format!(\"{}_{}\", label, \"lock_checkpoint\"),","counters":[{"col_start":0,"col_end":59,"count":0}]},{"line":"                t.lock_checkpoint,","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"            )?;","counters":[{"col_start":0,"col_end":13,"count":0},{"col_start":13,"col_end":14,"count":0}]},{"line":"            return self","counters":[{"col_start":19,"col_end":23,"count":0}]},{"line":"                .epoch_length","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"                .check(format!(\"{}_{}\", label, \"epoch_length\"), t.epoch_length);","counters":[{"col_start":0,"col_end":79,"count":0}]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/mina_base/zkapp_precondition.ml#L977","counters":[]},{"line":"    #[derive(Debug, Clone, PartialEq)]","counters":[{"col_start":13,"col_end":18,"count":0},{"col_start":20,"col_end":25,"count":0}]},{"line":"    pub struct ZkAppPreconditions {","counters":[]},{"line":"        pub snarked_ledger_hash: Hash<Fp>,","counters":[]},{"line":"        pub timestamp: Numeric<BlockTime>,","counters":[]},{"line":"        pub blockchain_length: Numeric<Length>,","counters":[]},{"line":"        pub min_window_density: Numeric<Length>,","counters":[]},{"line":"        pub last_vrf_output: (), // It's not defined in OCAml","counters":[]},{"line":"        pub total_currency: Numeric<Amount>,","counters":[]},{"line":"        pub global_slot_since_hard_fork: Numeric<Slot>,","counters":[]},{"line":"        pub global_slot_since_genesis: Numeric<Slot>,","counters":[]},{"line":"        pub staking_epoch_data: EpochData,","counters":[]},{"line":"        pub next_epoch_data: EpochData,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl ZkAppPreconditions {","counters":[]},{"line":"        pub fn check(&self, s: ProtocolStateView) -> Result<(), String> {","counters":[]},{"line":"            self.snarked_ledger_hash","counters":[{"col_start":12,"col_end":36,"count":0}]},{"line":"                .check(\"snarker_ledger_hash\".to_string(), s.snarked_ledger_hash)?;","counters":[{"col_start":0,"col_end":80,"count":0},{"col_start":80,"col_end":81,"count":0}]},{"line":"            self.timestamp.check(\"timestamp\".to_string(), s.timestamp)?;","counters":[{"col_start":12,"col_end":70,"count":0},{"col_start":70,"col_end":71,"count":0}]},{"line":"            self.blockchain_length","counters":[{"col_start":12,"col_end":34,"count":0}]},{"line":"                .check(\"blockchain_length\".to_string(), s.blockchain_length)?;","counters":[{"col_start":0,"col_end":76,"count":0},{"col_start":76,"col_end":77,"count":0}]},{"line":"            self.min_window_density","counters":[{"col_start":12,"col_end":35,"count":0}]},{"line":"                .check(\"min_window_density\".to_string(), s.min_window_density)?;","counters":[{"col_start":0,"col_end":78,"count":0},{"col_start":78,"col_end":79,"count":0}]},{"line":"            self.total_currency","counters":[{"col_start":12,"col_end":31,"count":0}]},{"line":"                .check(\"total_currency\".to_string(), s.total_currency)?;","counters":[{"col_start":0,"col_end":70,"count":0},{"col_start":70,"col_end":71,"count":0}]},{"line":"            self.global_slot_since_hard_fork.check(","counters":[{"col_start":12,"col_end":51,"count":0}]},{"line":"                \"curr_global_slot\".to_string(),","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"                s.global_slot_since_hard_fork,","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"            )?;","counters":[{"col_start":0,"col_end":13,"count":0},{"col_start":13,"col_end":14,"count":0}]},{"line":"            self.global_slot_since_genesis.check(","counters":[{"col_start":12,"col_end":49,"count":0}]},{"line":"                \"global_slot_since_genesis\".to_string(),","counters":[{"col_start":0,"col_end":56,"count":0}]},{"line":"                s.global_slot_since_genesis,","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"            )?;","counters":[{"col_start":0,"col_end":13,"count":0},{"col_start":13,"col_end":14,"count":0}]},{"line":"            self.staking_epoch_data","counters":[{"col_start":12,"col_end":35,"count":0}]},{"line":"                .epoch_data(\"staking_epoch_data\", s.staking_epoch_data)?;","counters":[{"col_start":0,"col_end":71,"count":0},{"col_start":71,"col_end":72,"count":0}]},{"line":"            self.next_epoch_data","counters":[{"col_start":12,"col_end":32,"count":0}]},{"line":"                .epoch_data(\"next_epoch_data\", s.next_epoch_data)","counters":[{"col_start":0,"col_end":65,"count":0}]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/mina_base/zkapp_precondition.ml#L1303","counters":[]},{"line":"        pub fn accept() -> Self {","counters":[{"col_start":8,"col_end":33,"count":0}]},{"line":"            let epoch_data = || EpochData {","counters":[{"col_start":0,"col_end":26,"count":0},{"col_start":32,"col_end":43,"count":0}]},{"line":"                ledger: EpochLedger {","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"                    hash: OrIgnore::Ignore,","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"                    total_currency: OrIgnore::Ignore,","counters":[{"col_start":0,"col_end":53,"count":0}]},{"line":"                },","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"                seed: OrIgnore::Ignore,","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"                start_checkpoint: OrIgnore::Ignore,","counters":[{"col_start":0,"col_end":51,"count":0}]},{"line":"                lock_checkpoint: OrIgnore::Ignore,","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"                epoch_length: OrIgnore::Ignore,","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"            };","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"            Self {","counters":[{"col_start":12,"col_end":18,"count":0}]},{"line":"                snarked_ledger_hash: OrIgnore::Ignore,","counters":[{"col_start":0,"col_end":54,"count":0}]},{"line":"                timestamp: OrIgnore::Ignore,","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"                blockchain_length: OrIgnore::Ignore,","counters":[{"col_start":0,"col_end":52,"count":0}]},{"line":"                min_window_density: OrIgnore::Ignore,","counters":[{"col_start":0,"col_end":53,"count":0}]},{"line":"                last_vrf_output: (),","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"                total_currency: OrIgnore::Ignore,","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"                global_slot_since_hard_fork: OrIgnore::Ignore,","counters":[{"col_start":0,"col_end":62,"count":0}]},{"line":"                global_slot_since_genesis: OrIgnore::Ignore,","counters":[{"col_start":0,"col_end":60,"count":0}]},{"line":"                staking_epoch_data: epoch_data(),","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"                next_epoch_data: epoch_data(),","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl ToInputs for ZkAppPreconditions {","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/3fe924c80a4d01f418b69f27398f5f93eb652514/src/lib/mina_base/zkapp_precondition.ml#L1052","counters":[]},{"line":"        fn to_inputs(&self, inputs: &mut Inputs) {","counters":[{"col_start":8,"col_end":50,"count":0}]},{"line":"            let ZkAppPreconditions {","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"                snarked_ledger_hash,","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"                timestamp,","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"                blockchain_length,","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"                min_window_density,","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"                last_vrf_output,","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"                total_currency,","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"                global_slot_since_hard_fork,","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"                global_slot_since_genesis,","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"                staking_epoch_data,","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"                next_epoch_data,","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"            } = &self;","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"            assert_eq_size_val!(*last_vrf_output, ());","counters":[{"col_start":0,"col_end":12,"count":0},{"col_start":53,"col_end":54,"count":0}]},{"line":"","counters":[]},{"line":"            inputs.append(&(snarked_ledger_hash, Fp::zero));","counters":[{"col_start":0,"col_end":60,"count":0}]},{"line":"            inputs.append(&(timestamp, ClosedInterval::min_max));","counters":[{"col_start":0,"col_end":65,"count":0}]},{"line":"","counters":[]},{"line":"            inputs.append(&(blockchain_length, ClosedInterval::min_max));","counters":[{"col_start":0,"col_end":73,"count":0}]},{"line":"            inputs.append(&(min_window_density, ClosedInterval::min_max));","counters":[{"col_start":0,"col_end":74,"count":0}]},{"line":"            inputs.append(&(total_currency, ClosedInterval::min_max));","counters":[{"col_start":0,"col_end":70,"count":0}]},{"line":"            inputs.append(&(global_slot_since_hard_fork, ClosedInterval::min_max));","counters":[{"col_start":0,"col_end":83,"count":0}]},{"line":"            inputs.append(&(global_slot_since_genesis, ClosedInterval::min_max));","counters":[{"col_start":0,"col_end":81,"count":0}]},{"line":"","counters":[]},{"line":"            inputs.append(staking_epoch_data);","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"            inputs.append(next_epoch_data);","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/mina_base/zkapp_precondition.ml#L478","counters":[]},{"line":"    #[derive(Debug, Clone, PartialEq)]","counters":[{"col_start":13,"col_end":18,"count":0},{"col_start":20,"col_end":25,"count":0}]},{"line":"    pub struct Account {","counters":[]},{"line":"        pub balance: Numeric<Balance>,","counters":[]},{"line":"        pub nonce: Numeric<Nonce>,","counters":[]},{"line":"        pub receipt_chain_hash: Hash<Fp>, // TODO: Should be type `ReceiptChainHash`","counters":[]},{"line":"        pub delegate: EqData<CompressedPubKey>,","counters":[]},{"line":"        pub state: [EqData<Fp>; 8],","counters":[]},{"line":"        pub sequence_state: EqData<Fp>,","counters":[]},{"line":"        pub proved_state: EqData<bool>,","counters":[]},{"line":"        pub is_new: EqData<bool>,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl Account {","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/3fe924c80a4d01f418b69f27398f5f93eb652514/src/lib/mina_base/zkapp_precondition.ml#L525","counters":[]},{"line":"        pub fn accept() -> Self {","counters":[{"col_start":8,"col_end":33,"count":0}]},{"line":"            Self {","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"                balance: Numeric::Ignore,","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"                nonce: Numeric::Ignore,","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"                receipt_chain_hash: Hash::Ignore,","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"                delegate: EqData::Ignore,","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"                state: std::array::from_fn(|_| EqData::Ignore),","counters":[{"col_start":0,"col_end":43,"count":0},{"col_start":47,"col_end":61,"count":0},{"col_start":61,"col_end":63,"count":0}]},{"line":"                sequence_state: EqData::Ignore,","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"                proved_state: EqData::Ignore,","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"                is_new: EqData::Ignore,","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl Account {","counters":[]},{"line":"        pub fn check<F>(&self, new_account: bool, mut check: F, a: account::Account)","counters":[{"col_start":8,"col_end":84,"count":0}]},{"line":"        where","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"            F: FnMut(TransactionFailure, bool),","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"        {","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"            self.checks(new_account, a)","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"                .iter()","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"                .for_each(|(failure, res)| check(failure.clone(), res.is_ok()))","counters":[{"col_start":0,"col_end":26,"count":0},{"col_start":43,"col_end":78,"count":0},{"col_start":78,"col_end":79,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        fn checks(","counters":[{"col_start":8,"col_end":18,"count":0}]},{"line":"            &self,","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"            new_account: bool,","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"            a: account::Account,","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"        ) -> Vec<(TransactionFailure, Result<(), String>)> {","counters":[{"col_start":0,"col_end":60,"count":0}]},{"line":"            let zkapp = a.zkapp.unwrap_or_default();","counters":[{"col_start":0,"col_end":52,"count":0}]},{"line":"            let mut ret = vec![","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"                (","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"                    TransactionFailure::AccountIsNewPreconditionUnsatisfied,","counters":[{"col_start":0,"col_end":76,"count":0}]},{"line":"                    self.is_new.check(\"is_new\".to_string(), new_account),","counters":[{"col_start":0,"col_end":73,"count":0}]},{"line":"                ),","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"                (","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"                    TransactionFailure::AccountProvedStatePreconditionUnsatisfied,","counters":[{"col_start":0,"col_end":82,"count":0}]},{"line":"                    self.proved_state","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"                        .check(\"proved_state\".to_string(), zkapp.proved_state),","counters":[{"col_start":0,"col_end":79,"count":0}]},{"line":"                ),","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"            ];","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"            for (i, (c, v)) in self.state.iter().zip(zkapp.app_state.iter()).enumerate() {","counters":[{"col_start":17,"col_end":25,"count":0},{"col_start":31,"col_end":88,"count":0},{"col_start":89,"col_end":90,"count":0}]},{"line":"                ret.push((","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"                    TransactionFailure::AccountAppStatePreconditionUnsatisfied(i),","counters":[{"col_start":0,"col_end":82,"count":0}]},{"line":"                    c.check(format!(\"state[{}]\", i), *v),","counters":[{"col_start":0,"col_end":57,"count":0}]},{"line":"                ));","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"            let mut ret2 =","counters":[{"col_start":16,"col_end":24,"count":0}]},{"line":"                vec![","counters":[{"col_start":16,"col_end":21,"count":0}]},{"line":"                    (","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"                        TransactionFailure::AccountSequenceStatePreconditionUnsatisfied,","counters":[{"col_start":0,"col_end":88,"count":0}]},{"line":"                        match zkapp.sequence_state.iter().find(|state| {","counters":[{"col_start":0,"col_end":63,"count":0},{"col_start":71,"col_end":72,"count":0}]},{"line":"                            self.sequence_state.check(\"\".to_string(), **state).is_ok()","counters":[{"col_start":0,"col_end":86,"count":0}]},{"line":"                        }) {","counters":[{"col_start":0,"col_end":25,"count":0},{"col_start":25,"col_end":26,"count":0}]},{"line":"                            None => Err(\"Sequence state mismatch\".to_string()),","counters":[{"col_start":36,"col_end":78,"count":0}]},{"line":"                            Some(_) => Ok(()),","counters":[{"col_start":39,"col_end":45,"count":0}]},{"line":"                        },","counters":[]},{"line":"                    ),","counters":[]},{"line":"                    (","counters":[{"col_start":20,"col_end":21,"count":0}]},{"line":"                        TransactionFailure::AccountDelegatePreconditionUnsatisfied,","counters":[{"col_start":0,"col_end":83,"count":0}]},{"line":"                        self.delegate","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"                            .check(\"delegate\".to_string(), a.delegate.unwrap()), // TODO: handle None case?","counters":[{"col_start":0,"col_end":107,"count":0}]},{"line":"                    ),","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"                    (","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"                        TransactionFailure::AccountReceiptChainHashPreconditionUnsatisfied,","counters":[{"col_start":0,"col_end":91,"count":0}]},{"line":"                        self.receipt_chain_hash","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"                            .check(\"receipt_chain_hash\".to_string(), a.receipt_chain_hash.0),","counters":[{"col_start":0,"col_end":93,"count":0}]},{"line":"                    ),","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"                    (","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"                        TransactionFailure::AccountNoncePreconditionUnsatisfied,","counters":[{"col_start":0,"col_end":80,"count":0}]},{"line":"                        self.nonce.check(\"nonce\".to_string(), a.nonce),","counters":[{"col_start":0,"col_end":71,"count":0}]},{"line":"                    ),","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"                    (","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"                        TransactionFailure::AccountBalancePreconditionUnsatisfied,","counters":[{"col_start":0,"col_end":82,"count":0}]},{"line":"                        self.balance.check(\"balance\".to_string(), a.balance),","counters":[{"col_start":0,"col_end":77,"count":0}]},{"line":"                    ),","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"                ];","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"","counters":[]},{"line":"            ret.append(&mut ret2);","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"            ret","counters":[{"col_start":0,"col_end":15,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/mina_base/account_update.ml#L613","counters":[]},{"line":"    #[derive(Debug, Clone, PartialEq)]","counters":[{"col_start":13,"col_end":14,"count":0},{"col_start":17,"col_end":18,"count":0},{"col_start":20,"col_end":21,"count":0},{"col_start":24,"col_end":25,"count":0}]},{"line":"    pub enum AccountPreconditions {","counters":[]},{"line":"        Full(Box<Account>),","counters":[]},{"line":"        Nonce(Nonce),","counters":[]},{"line":"        Accept,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl ToInputs for AccountPreconditions {","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/3fe924c80a4d01f418b69f27398f5f93eb652514/src/lib/mina_base/account_update.ml#L635","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/3fe924c80a4d01f418b69f27398f5f93eb652514/src/lib/mina_base/zkapp_precondition.ml#L568","counters":[]},{"line":"        fn to_inputs(&self, inputs: &mut Inputs) {","counters":[{"col_start":8,"col_end":49,"count":0},{"col_start":49,"col_end":50,"count":0}]},{"line":"            let account = match self {","counters":[{"col_start":0,"col_end":23,"count":0},{"col_start":32,"col_end":36,"count":0}]},{"line":"                AccountPreconditions::Full(account) => MyCow::Borrow(&**account),","counters":[{"col_start":43,"col_end":80,"count":0}]},{"line":"                AccountPreconditions::Nonce(nonce) => {","counters":[{"col_start":44,"col_end":55,"count":0}]},{"line":"                    let mut account = Account::accept();","counters":[{"col_start":0,"col_end":56,"count":0}]},{"line":"                    account.nonce = Numeric::Check(ClosedInterval {","counters":[{"col_start":0,"col_end":67,"count":0}]},{"line":"                        lower: *nonce,","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"                        upper: *nonce,","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"                    });","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"                    MyCow::Own(account)","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"                }","counters":[]},{"line":"                AccountPreconditions::Accept => MyCow::Own(Account::accept()),","counters":[{"col_start":48,"col_end":77,"count":0}]},{"line":"            };","counters":[]},{"line":"","counters":[]},{"line":"            let Account {","counters":[]},{"line":"                balance,","counters":[{"col_start":16,"col_end":24,"count":0}]},{"line":"                nonce,","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"                receipt_chain_hash,","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"                delegate,","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"                state,","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"                sequence_state,","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"                proved_state,","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"                is_new,","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"            } = account.as_ref();","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"","counters":[]},{"line":"            inputs.append(&(balance, ClosedInterval::min_max));","counters":[{"col_start":0,"col_end":63,"count":0}]},{"line":"            inputs.append(&(nonce, ClosedInterval::min_max));","counters":[{"col_start":0,"col_end":61,"count":0}]},{"line":"            inputs.append(&(receipt_chain_hash, Fp::zero));","counters":[{"col_start":0,"col_end":59,"count":0}]},{"line":"            inputs.append(&(delegate, CompressedPubKey::empty));","counters":[{"col_start":0,"col_end":64,"count":0}]},{"line":"","counters":[]},{"line":"            state.iter().for_each(|s| {","counters":[{"col_start":0,"col_end":34,"count":0},{"col_start":38,"col_end":39,"count":0}]},{"line":"                inputs.append(&(s, Fp::zero));","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"            });","counters":[{"col_start":0,"col_end":13,"count":0},{"col_start":13,"col_end":15,"count":0}]},{"line":"","counters":[]},{"line":"            // https://github.com/MinaProtocol/mina/blob/3fe924c80a4d01f418b69f27398f5f93eb652514/src/lib/mina_base/zkapp_account.ml#L168","counters":[{"col_start":0,"col_end":137,"count":0}]},{"line":"            inputs.append(&(sequence_state, || {","counters":[{"col_start":0,"col_end":44,"count":0},{"col_start":47,"col_end":48,"count":0}]},{"line":"                hash_noinputs(\"MinaZkappSequenceStateEmptyElt\")","counters":[{"col_start":0,"col_end":63,"count":0}]},{"line":"            }));","counters":[{"col_start":0,"col_end":13,"count":0},{"col_start":13,"col_end":16,"count":0}]},{"line":"","counters":[]},{"line":"            inputs.append(&(proved_state, || false));","counters":[{"col_start":0,"col_end":42,"count":0},{"col_start":45,"col_end":50,"count":0},{"col_start":50,"col_end":53,"count":0}]},{"line":"            inputs.append(&(is_new, || false));","counters":[{"col_start":0,"col_end":36,"count":0},{"col_start":39,"col_end":44,"count":0},{"col_start":44,"col_end":47,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl AccountPreconditions {","counters":[]},{"line":"        pub fn nonce(&self) -> Numeric<Nonce> {","counters":[{"col_start":8,"col_end":47,"count":0}]},{"line":"            match self {","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"                Self::Full(account) => account.nonce.clone(),","counters":[{"col_start":27,"col_end":60,"count":0}]},{"line":"                Self::Nonce(nonce) => Numeric::Check(ClosedInterval {","counters":[{"col_start":28,"col_end":69,"count":0}]},{"line":"                    lower: *nonce,","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"                    upper: *nonce,","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"                }),","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"                Self::Accept => Numeric::Ignore,","counters":[{"col_start":32,"col_end":47,"count":0}]},{"line":"            }","counters":[]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn to_full(&self) -> Account {","counters":[{"col_start":8,"col_end":42,"count":0}]},{"line":"            match self {","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"                AccountPreconditions::Full(s) => (**s).clone(),","counters":[{"col_start":43,"col_end":62,"count":0}]},{"line":"                AccountPreconditions::Nonce(nonce) => {","counters":[{"col_start":44,"col_end":55,"count":0}]},{"line":"                    let mut account = Account::accept();","counters":[{"col_start":0,"col_end":56,"count":0}]},{"line":"                    account.nonce = OrIgnore::Check(ClosedInterval {","counters":[{"col_start":0,"col_end":68,"count":0}]},{"line":"                        lower: *nonce,","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"                        upper: *nonce,","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"                    });","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"                    account","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"                }","counters":[]},{"line":"                AccountPreconditions::Accept => Account::accept(),","counters":[{"col_start":48,"col_end":65,"count":0}]},{"line":"            }","counters":[]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/mina_base/account_update.ml#L758","counters":[]},{"line":"    #[derive(Debug, Clone, PartialEq)]","counters":[{"col_start":13,"col_end":18,"count":107},{"col_start":20,"col_end":25,"count":0}]},{"line":"    pub struct Preconditions {","counters":[]},{"line":"        pub(crate) network: ZkAppPreconditions,","counters":[]},{"line":"        pub account: AccountPreconditions,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl ToInputs for Preconditions {","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/3fe924c80a4d01f418b69f27398f5f93eb652514/src/lib/mina_base/account_update.ml#L776","counters":[]},{"line":"        fn to_inputs(&self, inputs: &mut Inputs) {","counters":[{"col_start":8,"col_end":50,"count":0}]},{"line":"            let Self { network, account } = self;","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"            network.to_inputs(inputs);","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"            account.to_inputs(inputs);","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/mina_base/account_update.ml#L27","counters":[]},{"line":"    #[derive(Debug, Clone, PartialEq, Eq)]","counters":[{"col_start":13,"col_end":14,"count":0},{"col_start":17,"col_end":18,"count":0},{"col_start":20,"col_end":21,"count":0},{"col_start":24,"col_end":25,"count":0}]},{"line":"    pub enum AuthorizationKind {","counters":[]},{"line":"        NoneGiven,","counters":[]},{"line":"        Signature,","counters":[]},{"line":"        Proof,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl ToInputs for AuthorizationKind {","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/3fe924c80a4d01f418b69f27398f5f93eb652514/src/lib/mina_base/account_update.ml#L110","counters":[]},{"line":"        fn to_inputs(&self, inputs: &mut Inputs) {","counters":[{"col_start":8,"col_end":49,"count":0}]},{"line":"            // bits: [is_signed, is_proved]","counters":[]},{"line":"            let bits = match self {","counters":[{"col_start":16,"col_end":20,"count":0},{"col_start":29,"col_end":33,"count":0}]},{"line":"                AuthorizationKind::NoneGiven => [false, false],","counters":[{"col_start":48,"col_end":62,"count":0}]},{"line":"                AuthorizationKind::Signature => [true, false],","counters":[{"col_start":48,"col_end":61,"count":0}]},{"line":"                AuthorizationKind::Proof => [false, true],","counters":[{"col_start":44,"col_end":57,"count":0}]},{"line":"            };","counters":[]},{"line":"","counters":[]},{"line":"            for bit in bits {","counters":[{"col_start":16,"col_end":19,"count":0},{"col_start":23,"col_end":27,"count":0},{"col_start":28,"col_end":29,"count":0}]},{"line":"                inputs.append_bool(bit);","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/mina_base/account_update.ml#L981","counters":[]},{"line":"    #[derive(Debug, Clone, PartialEq)]","counters":[{"col_start":13,"col_end":18,"count":0},{"col_start":20,"col_end":25,"count":0}]},{"line":"    pub struct Body {","counters":[]},{"line":"        pub public_key: CompressedPubKey,","counters":[]},{"line":"        pub token_id: TokenId,","counters":[]},{"line":"        pub update: Update,","counters":[]},{"line":"        pub balance_change: Signed<Amount>,","counters":[]},{"line":"        pub increment_nonce: bool,","counters":[]},{"line":"        pub events: Events,","counters":[]},{"line":"        pub sequence_events: SequenceEvents,","counters":[]},{"line":"        pub call_data: Fp,","counters":[]},{"line":"        pub preconditions: Preconditions,","counters":[]},{"line":"        pub use_full_commitment: bool,","counters":[]},{"line":"        pub caller: TokenId,","counters":[]},{"line":"        pub authorization_kind: AuthorizationKind,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/mina_base/account_update.ml#L955","counters":[]},{"line":"    #[derive(Debug, Clone, PartialEq)]","counters":[{"col_start":13,"col_end":18,"count":0}]},{"line":"    pub struct BodySimple {","counters":[]},{"line":"        pub public_key: CompressedPubKey,","counters":[]},{"line":"        pub token_id: TokenId,","counters":[]},{"line":"        pub update: Update,","counters":[]},{"line":"        pub balance_change: Signed<Amount>,","counters":[]},{"line":"        pub increment_nonce: bool,","counters":[]},{"line":"        pub events: Events,","counters":[]},{"line":"        pub sequence_events: SequenceEvents,","counters":[]},{"line":"        pub call_data: Fp,","counters":[]},{"line":"        pub call_depth: usize,","counters":[]},{"line":"        pub preconditions: Preconditions,","counters":[]},{"line":"        pub use_full_commitment: bool,","counters":[]},{"line":"        pub caller: MinaBaseAccountUpdateCallTypeStableV1,","counters":[]},{"line":"        pub authorization_kind: AuthorizationKind,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// Notes:","counters":[]},{"line":"    /// The type in OCaml is this one:","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3fe924c80a4d01f418b69f27398f5f93eb652514/src/lib/pickles/proof.ml#L401","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// For now we use the type from `mina_p2p_messages`, but we need to use our own.","counters":[]},{"line":"    /// Lots of inner types are (BigInt, Bigint) which should be replaced with `Pallas<_>` etc.","counters":[]},{"line":"    /// Also, in OCaml it has custom `{to/from}_binable` implementation.","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/pickles/pickles_intf.ml#L316","counters":[]},{"line":"    pub type SideLoadedProof = Rc<mina_p2p_messages::v2::PicklesProofProofsVerifiedMaxStableV2>;","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/mina_base/control.ml#L11","counters":[]},{"line":"    #[derive(Debug, Clone, PartialEq)]","counters":[{"col_start":13,"col_end":14,"count":0},{"col_start":17,"col_end":18,"count":0},{"col_start":20,"col_end":21,"count":0},{"col_start":24,"col_end":25,"count":0}]},{"line":"    pub enum Control {","counters":[]},{"line":"        Proof(SideLoadedProof),","counters":[]},{"line":"        Signature(Signature),","counters":[]},{"line":"        NoneGiven,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl Control {","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/d7d4aa4d650eb34b45a42b29276554802683ce15/src/lib/mina_base/control.ml#L81","counters":[]},{"line":"        pub fn tag(&self) -> crate::ControlTag {","counters":[{"col_start":8,"col_end":48,"count":0}]},{"line":"            match self {","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"                Control::Proof(_) => crate::ControlTag::Proof,","counters":[{"col_start":37,"col_end":61,"count":0}]},{"line":"                Control::Signature(_) => crate::ControlTag::Signature,","counters":[{"col_start":41,"col_end":69,"count":0}]},{"line":"                Control::NoneGiven => crate::ControlTag::NoneGiven,","counters":[{"col_start":38,"col_end":66,"count":0}]},{"line":"            }","counters":[]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn dummy_of_tag(tag: ControlTag) -> Self {","counters":[{"col_start":8,"col_end":54,"count":0}]},{"line":"            match tag {","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"                ControlTag::Proof => Self::Proof(dummy::sideloaded_proof()),","counters":[{"col_start":37,"col_end":75,"count":0}]},{"line":"                ControlTag::Signature => Self::Signature(Signature::dummy()),","counters":[{"col_start":41,"col_end":76,"count":0}]},{"line":"                ControlTag::NoneGiven => Self::NoneGiven,","counters":[{"col_start":41,"col_end":56,"count":0}]},{"line":"            }","counters":[]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    pub struct CheckAuthorizationResult {","counters":[]},{"line":"        pub proof_verifies: bool,","counters":[]},{"line":"        pub signature_verifies: bool,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/mina_base/account_update.ml#L1437","counters":[]},{"line":"    #[derive(Debug, Clone, PartialEq)]","counters":[{"col_start":13,"col_end":18,"count":0},{"col_start":20,"col_end":25,"count":0}]},{"line":"    pub struct AccountUpdate {","counters":[]},{"line":"        pub body: Body,","counters":[]},{"line":"        pub authorization: Control,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/mina_base/account_update.ml#L1395","counters":[]},{"line":"    #[derive(Debug, Clone, PartialEq)]","counters":[{"col_start":13,"col_end":18,"count":0}]},{"line":"    pub struct AccountUpdateSimple {","counters":[]},{"line":"        pub body: BodySimple,","counters":[]},{"line":"        pub authorization: Control,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl ToInputs for AccountUpdate {","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/3fe924c80a4d01f418b69f27398f5f93eb652514/src/lib/mina_base/account_update.ml#L1297","counters":[]},{"line":"        fn to_inputs(&self, inputs: &mut Inputs) {","counters":[{"col_start":8,"col_end":50,"count":0}]},{"line":"            // Only the body is used","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"            let Self {","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"                body,","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"                authorization: _,","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"            } = self;","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"","counters":[]},{"line":"            let Body {","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"                public_key,","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"                token_id,","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"                update,","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"                balance_change,","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"                increment_nonce,","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"                events,","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"                sequence_events,","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"                call_data,","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"                preconditions,","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"                use_full_commitment,","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"                caller,","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"                authorization_kind,","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"            } = body;","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"","counters":[]},{"line":"            inputs.append(public_key);","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"            inputs.append(token_id);","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"","counters":[]},{"line":"            // `Body::update`","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"            {","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"                let Update {","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"                    app_state,","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"                    delegate,","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"                    verification_key,","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"                    permissions,","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"                    zkapp_uri,","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"                    token_symbol,","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"                    timing,","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"                    voting_for,","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"                } = update;","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"","counters":[]},{"line":"                for state in app_state {","counters":[{"col_start":20,"col_end":25,"count":0},{"col_start":29,"col_end":38,"count":0},{"col_start":39,"col_end":40,"count":0}]},{"line":"                    inputs.append(&(state, Fp::zero));","counters":[{"col_start":0,"col_end":54,"count":0}]},{"line":"                }","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"","counters":[]},{"line":"                inputs.append(&(delegate, CompressedPubKey::empty));","counters":[{"col_start":16,"col_end":68,"count":0}]},{"line":"                inputs.append(&(&verification_key.map(|w| w.hash), Fp::zero));","counters":[{"col_start":0,"col_end":54,"count":0},{"col_start":58,"col_end":64,"count":0},{"col_start":64,"col_end":78,"count":0}]},{"line":"                inputs.append(&(permissions, Permissions::user_default));","counters":[{"col_start":0,"col_end":73,"count":0}]},{"line":"                inputs.append(&(&zkapp_uri.map(Some), || Option::<&ZkAppUri>::None));","counters":[{"col_start":0,"col_end":54,"count":0},{"col_start":57,"col_end":82,"count":0},{"col_start":82,"col_end":85,"count":0}]},{"line":"                inputs.append(&(token_symbol, TokenSymbol::default));","counters":[{"col_start":0,"col_end":69,"count":0}]},{"line":"                inputs.append(&(timing, Timing::dummy));","counters":[{"col_start":0,"col_end":56,"count":0}]},{"line":"                inputs.append(&(voting_for, VotingFor::dummy));","counters":[{"col_start":0,"col_end":63,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"            inputs.append(balance_change);","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"            inputs.append(increment_nonce);","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"            inputs.append(events);","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"            inputs.append(sequence_events);","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"            inputs.append(call_data);","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"            inputs.append(preconditions);","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"            inputs.append(use_full_commitment);","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"            inputs.append(caller);","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"            inputs.append(authorization_kind);","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl AccountUpdate {","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/mina_base/account_update.ml#L1538","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/mina_base/account_update.ml#L1129","counters":[]},{"line":"        pub fn of_fee_payer(fee_payer: FeePayer) -> Self {","counters":[{"col_start":8,"col_end":58,"count":0}]},{"line":"            let FeePayer {","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"                body:","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"                    FeePayerBody {","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"                        public_key,","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"                        fee,","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"                        valid_until,","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"                        nonce,","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"                    },","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"                authorization,","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"            } = fee_payer;","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"","counters":[]},{"line":"            Self {","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"                body: Body {","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"                    public_key,","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"                    token_id: TokenId::default(),","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"                    update: Update::noop(),","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"                    balance_change: Signed {","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"                        magnitude: Amount::of_fee(&fee),","counters":[{"col_start":0,"col_end":56,"count":0}]},{"line":"                        sgn: Sgn::Neg,","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"                    },","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"                    increment_nonce: true,","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"                    events: Events::empty(),","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"                    sequence_events: SequenceEvents::empty(),","counters":[{"col_start":0,"col_end":61,"count":0}]},{"line":"                    call_data: Fp::zero(),","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"                    preconditions: Preconditions {","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"                        network: {","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"                            let mut network = ZkAppPreconditions::accept();","counters":[{"col_start":0,"col_end":75,"count":0}]},{"line":"","counters":[]},{"line":"                            let valid_util = valid_until.unwrap_or_else(Slot::max);","counters":[{"col_start":0,"col_end":83,"count":0}]},{"line":"                            network.global_slot_since_genesis = OrIgnore::Check(ClosedInterval {","counters":[{"col_start":0,"col_end":96,"count":0}]},{"line":"                                lower: Slot::zero(),","counters":[{"col_start":0,"col_end":52,"count":0}]},{"line":"                                upper: valid_util,","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"                            });","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"","counters":[]},{"line":"                            network","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"                        },","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"                        account: AccountPreconditions::Nonce(nonce),","counters":[{"col_start":0,"col_end":68,"count":0}]},{"line":"                    },","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"                    use_full_commitment: true,","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"                    caller: TokenId::default(),","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"                    authorization_kind: AuthorizationKind::Signature,","counters":[{"col_start":0,"col_end":69,"count":0}]},{"line":"                },","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"                authorization: Control::Signature(authorization),","counters":[{"col_start":0,"col_end":65,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/mina_base/account_update.ml#L1535","counters":[]},{"line":"        pub fn account_id(&self) -> AccountId {","counters":[{"col_start":8,"col_end":47,"count":0}]},{"line":"            AccountId::new(self.body.public_key.clone(), self.body.token_id.clone())","counters":[{"col_start":0,"col_end":84,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/3fe924c80a4d01f418b69f27398f5f93eb652514/src/lib/mina_base/account_update.ml#L1327","counters":[]},{"line":"        pub fn digest(&self) -> Fp {","counters":[{"col_start":8,"col_end":36,"count":0}]},{"line":"            let mut inputs = Inputs::new();","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"","counters":[]},{"line":"            self.to_inputs(&mut inputs);","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"            hash_with_kimchi(\"MinaZkappBody\", &inputs.to_fields())","counters":[{"col_start":0,"col_end":66,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn timing(&self) -> SetOrKeep<Timing> {","counters":[{"col_start":8,"col_end":51,"count":0}]},{"line":"            self.body.update.timing.clone()","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn caller(&self) -> TokenId {","counters":[{"col_start":8,"col_end":41,"count":0}]},{"line":"            self.body.caller.clone()","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn public_key(&self) -> CompressedPubKey {","counters":[{"col_start":8,"col_end":54,"count":0}]},{"line":"            self.body.public_key.clone()","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn token_id(&self) -> TokenId {","counters":[{"col_start":8,"col_end":43,"count":0}]},{"line":"            self.body.token_id.clone()","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn increment_nonce(&self) -> bool {","counters":[{"col_start":8,"col_end":47,"count":0}]},{"line":"            self.body.increment_nonce","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        // commitment and calls argument are ignored here, only used in the transaction snark","counters":[]},{"line":"        pub fn check_authorization(","counters":[{"col_start":8,"col_end":35,"count":0}]},{"line":"            &self,","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"            _commitment: Fp,","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"            _calls: CallForest<AccountUpdate>,","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"        ) -> CheckAuthorizationResult {","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"            match self.authorization {","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"                Control::Signature(_) => CheckAuthorizationResult {","counters":[{"col_start":41,"col_end":67,"count":0}]},{"line":"                    proof_verifies: false,","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"                    signature_verifies: true,","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"                },","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"                Control::Proof(_) => CheckAuthorizationResult {","counters":[{"col_start":37,"col_end":63,"count":0}]},{"line":"                    proof_verifies: true,","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"                    signature_verifies: false,","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"                },","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"                Control::NoneGiven => CheckAuthorizationResult {","counters":[{"col_start":38,"col_end":64,"count":0}]},{"line":"                    proof_verifies: false,","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"                    signature_verifies: false,","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"                },","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"            }","counters":[]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn permissions(&self) -> SetOrKeep<Permissions<AuthRequired>> {","counters":[{"col_start":8,"col_end":75,"count":0}]},{"line":"            self.body.update.permissions.clone()","counters":[{"col_start":0,"col_end":48,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn app_state(&self) -> [SetOrKeep<Fp>; 8] {","counters":[{"col_start":8,"col_end":55,"count":0}]},{"line":"            self.body.update.app_state.clone()","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn zkapp_uri(&self) -> SetOrKeep<ZkAppUri> {","counters":[{"col_start":8,"col_end":56,"count":0}]},{"line":"            self.body.update.zkapp_uri.clone()","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        /*","counters":[]},{"line":"        pub fn token_symbol(&self) -> SetOrKeep<[u8; 6]> {","counters":[]},{"line":"            self.body.update.token_symbol.clone()","counters":[]},{"line":"        }","counters":[]},{"line":"        */","counters":[]},{"line":"","counters":[]},{"line":"        pub fn token_symbol(&self) -> SetOrKeep<TokenSymbol> {","counters":[{"col_start":8,"col_end":62,"count":0}]},{"line":"            self.body.update.token_symbol.clone()","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn delegate(&self) -> SetOrKeep<CompressedPubKey> {","counters":[{"col_start":8,"col_end":63,"count":0}]},{"line":"            self.body.update.delegate.clone()","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn voting_for(&self) -> SetOrKeep<VotingFor> {","counters":[{"col_start":8,"col_end":58,"count":0}]},{"line":"            self.body.update.voting_for.clone()","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn verification_key(&self) -> SetOrKeep<VerificationKey> {","counters":[{"col_start":8,"col_end":70,"count":0}]},{"line":"            self.body.update.verification_key.map(|vk| vk.data.clone())","counters":[{"col_start":0,"col_end":50,"count":0},{"col_start":55,"col_end":70,"count":0},{"col_start":70,"col_end":71,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn sequence_events(&self) -> SequenceEvents {","counters":[{"col_start":8,"col_end":57,"count":0}]},{"line":"            self.body.sequence_events.clone()","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn balance_change(&self) -> Signed<Amount> {","counters":[{"col_start":8,"col_end":56,"count":0}]},{"line":"            self.body.balance_change","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"        pub fn use_full_commitment(&self) -> bool {","counters":[{"col_start":8,"col_end":51,"count":0}]},{"line":"            self.body.use_full_commitment","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn protocol_state_precondition(&self) -> ZkAppPreconditions {","counters":[{"col_start":8,"col_end":73,"count":0}]},{"line":"            self.body.preconditions.network.clone()","counters":[{"col_start":0,"col_end":51,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn account_precondition(&self) -> AccountPreconditions {","counters":[{"col_start":8,"col_end":68,"count":0}]},{"line":"            self.body.preconditions.account.clone()","counters":[{"col_start":0,"col_end":51,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn is_proved(&self) -> bool {","counters":[{"col_start":8,"col_end":41,"count":0}]},{"line":"            match self.body.authorization_kind {","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"                AuthorizationKind::Proof => true,","counters":[{"col_start":44,"col_end":48,"count":0}]},{"line":"                AuthorizationKind::Signature | AuthorizationKind::NoneGiven => false,","counters":[{"col_start":79,"col_end":84,"count":0}]},{"line":"            }","counters":[]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn is_signed(&self) -> bool {","counters":[{"col_start":8,"col_end":41,"count":0}]},{"line":"            match self.body.authorization_kind {","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"                AuthorizationKind::Signature => true,","counters":[{"col_start":48,"col_end":52,"count":0}]},{"line":"                AuthorizationKind::Proof | AuthorizationKind::NoneGiven => false,","counters":[{"col_start":75,"col_end":80,"count":0}]},{"line":"            }","counters":[]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/mina_base/zkapp_command.ml#L49","counters":[]},{"line":"    #[derive(Debug, Clone, PartialEq)]","counters":[{"col_start":13,"col_end":18,"count":0},{"col_start":20,"col_end":25,"count":0}]},{"line":"    pub struct Tree<AccUpdate: Clone> {","counters":[]},{"line":"        pub account_update: AccUpdate,","counters":[]},{"line":"        pub account_update_digest: Fp,","counters":[]},{"line":"        pub calls: CallForest<AccUpdate>,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl<AccUpdate: Clone> Tree<AccUpdate> {","counters":[]},{"line":"        pub fn digest(&self) -> Fp {","counters":[{"col_start":8,"col_end":35,"count":0}]},{"line":"            let stack_hash = match self.calls.0.first() {","counters":[{"col_start":16,"col_end":26,"count":0},{"col_start":35,"col_end":55,"count":0}]},{"line":"                Some(e) => e.stack_hash,","counters":[{"col_start":21,"col_end":39,"count":0}]},{"line":"                None => Fp::zero(),","counters":[{"col_start":24,"col_end":34,"count":0}]},{"line":"            };","counters":[]},{"line":"","counters":[]},{"line":"            // self.account_update_digest should have been updated in `CallForest::accumulate_hashes`","counters":[]},{"line":"            assert_ne!(self.account_update_digest, Fp::zero());","counters":[{"col_start":12,"col_end":62,"count":0}]},{"line":"","counters":[]},{"line":"            //println!(\">>> tree digest account_update_digest {:?} stack_hash {:?}\", self.account_update_digest, stack_hash);","counters":[]},{"line":"","counters":[]},{"line":"            hash_with_kimchi(","counters":[{"col_start":12,"col_end":29,"count":0}]},{"line":"                \"MinaAcctUpdateNode\",","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"                &[self.account_update_digest, stack_hash],","counters":[{"col_start":0,"col_end":58,"count":0}]},{"line":"            )","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        fn fold<F>(&self, init: Vec<AccountId>, f: &mut F) -> Vec<AccountId>","counters":[]},{"line":"        where","counters":[]},{"line":"            F: FnMut(Vec<AccountId>, &AccUpdate) -> Vec<AccountId>,","counters":[]},{"line":"        {","counters":[]},{"line":"            self.calls.fold(f(init, &self.account_update), f)","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/mina_base/with_stack_hash.ml#L6","counters":[]},{"line":"    #[derive(Debug, Clone, PartialEq)]","counters":[{"col_start":13,"col_end":18,"count":0},{"col_start":20,"col_end":25,"count":0}]},{"line":"    pub struct WithStackHash<AccUpdate: Clone> {","counters":[]},{"line":"        pub elt: Tree<AccUpdate>,","counters":[]},{"line":"        pub stack_hash: Fp,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/mina_base/zkapp_command.ml#L345","counters":[]},{"line":"    #[derive(Debug, Clone, PartialEq)]","counters":[{"col_start":13,"col_end":18,"count":20},{"col_start":20,"col_end":25,"count":0}]},{"line":"    pub struct CallForest<AccUpdate: Clone>(pub Vec<WithStackHash<AccUpdate>>);","counters":[]},{"line":"","counters":[]},{"line":"    impl<Data: Clone> Default for CallForest<Data> {","counters":[]},{"line":"        fn default() -> Self {","counters":[]},{"line":"            Self::new()","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    #[derive(Clone)]","counters":[{"col_start":13,"col_end":18,"count":0}]},{"line":"    struct CallForestContext {","counters":[]},{"line":"        caller: TokenId,","counters":[]},{"line":"        this: TokenId,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl<AccUpdate: Clone> CallForest<AccUpdate> {","counters":[]},{"line":"        pub fn new() -> Self {","counters":[{"col_start":8,"col_end":30,"count":0}]},{"line":"            Self(Vec::new())","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn is_empty(&self) -> bool {","counters":[{"col_start":8,"col_end":40,"count":0}]},{"line":"            self.0.is_empty()","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        // In OCaml push/pop to the head is cheap because they work with lists.","counters":[]},{"line":"        // In Rust we use vectors so we will push/pop to the tail.","counters":[]},{"line":"        // To work with the elements as if they were in the original order we need to iterate backwards","counters":[]},{"line":"        pub fn iter(&self) -> impl Iterator<Item = &WithStackHash<AccUpdate>> {","counters":[{"col_start":8,"col_end":79,"count":0}]},{"line":"            self.0.iter() //.rev()","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn hash(&self) -> Fp {","counters":[]},{"line":"            //for x in self.0.iter() {","counters":[]},{"line":"            //    println!(\"hash: {:?}\", x.stack_hash);","counters":[]},{"line":"            //}","counters":[]},{"line":"","counters":[]},{"line":"            if let Some(x) = self.0.first() {","counters":[{"col_start":24,"col_end":25,"count":0},{"col_start":29,"col_end":43,"count":0}]},{"line":"                x.stack_hash","counters":[{"col_start":16,"col_end":28,"count":0}]},{"line":"            } else {","counters":[]},{"line":"                Fp::zero()","counters":[{"col_start":16,"col_end":26,"count":0}]},{"line":"            }","counters":[]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        fn cons_tree(&self, tree: Tree<AccUpdate>) -> Self {","counters":[{"col_start":8,"col_end":60,"count":0}]},{"line":"            //println!(\"rust_print_backtrace=\\n{}\", crate::short_backtrace());","counters":[{"col_start":0,"col_end":78,"count":0}]},{"line":"            let hash = tree.digest();","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"            let h_tl = self.hash();","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"            //println!(\"rust >>>>> cons_tree hash-tree {:?} self-hash {:?}\", hash, h_tl);","counters":[{"col_start":0,"col_end":89,"count":0}]},{"line":"            let stack_hash = hash_with_kimchi(\"MinaAcctUpdateCons\", &[hash, h_tl]);","counters":[{"col_start":0,"col_end":83,"count":0}]},{"line":"            let node = WithStackHash::<AccUpdate> {","counters":[{"col_start":0,"col_end":51,"count":0}]},{"line":"                elt: tree,","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"                stack_hash,","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"            };","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"            let mut forest = Vec::with_capacity(self.0.len() + 1);","counters":[{"col_start":0,"col_end":66,"count":0}]},{"line":"            forest.push(node);","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"            forest.extend(self.0.iter().cloned());","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"","counters":[]},{"line":"            Self(forest)","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn pop_exn(&self) -> ((AccUpdate, CallForest<AccUpdate>), CallForest<AccUpdate>) {","counters":[{"col_start":8,"col_end":94,"count":0}]},{"line":"            if self.0.is_empty() {","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"                panic!()","counters":[{"col_start":16,"col_end":24,"count":0}]},{"line":"            }","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"            let Tree::<AccUpdate> {","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"                account_update,","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"                calls,","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"                ..","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"            } = self.0[0].elt.clone();","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"            (","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"                (account_update, calls),","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"                CallForest(Vec::from_iter(self.0[1..].iter().cloned())),","counters":[{"col_start":0,"col_end":72,"count":0}]},{"line":"            )","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/mina_base/zkapp_command.ml#L68","counters":[]},{"line":"        fn fold_impl<A, F>(&self, init: A, fun: &mut F) -> A","counters":[{"col_start":8,"col_end":60,"count":0}]},{"line":"        where","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"            F: FnMut(A, &AccUpdate) -> A,","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"        {","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"            let mut accum = init;","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"            for elem in self.iter() {","counters":[{"col_start":16,"col_end":20,"count":0},{"col_start":29,"col_end":35,"count":0},{"col_start":36,"col_end":37,"count":0}]},{"line":"                accum = fun(accum, &elem.elt.account_update);","counters":[{"col_start":0,"col_end":61,"count":0}]},{"line":"                accum = elem.elt.calls.fold_impl(accum, fun);","counters":[{"col_start":0,"col_end":61,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"            accum","counters":[{"col_start":12,"col_end":17,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn fold<A, F>(&self, init: A, mut fun: F) -> A","counters":[{"col_start":8,"col_end":58,"count":0}]},{"line":"        where","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"            F: FnMut(A, &AccUpdate) -> A,","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"        {","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"            self.fold_impl(init, &mut fun)","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        fn map_to_impl<F, AnotherAccUpdate: Clone>(&self, fun: &F) -> CallForest<AnotherAccUpdate>","counters":[{"col_start":8,"col_end":98,"count":0}]},{"line":"        where","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"            F: Fn(&AccUpdate) -> AnotherAccUpdate,","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"        {","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"            CallForest::<AnotherAccUpdate>(","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"                self.iter()","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"                    .map(|item| WithStackHash::<AnotherAccUpdate> {","counters":[{"col_start":0,"col_end":25,"count":0},{"col_start":32,"col_end":67,"count":0}]},{"line":"                        elt: Tree::<AnotherAccUpdate> {","counters":[{"col_start":0,"col_end":55,"count":0}]},{"line":"                            account_update: fun(&item.elt.account_update),","counters":[{"col_start":0,"col_end":74,"count":0}]},{"line":"                            account_update_digest: item.elt.account_update_digest,","counters":[{"col_start":0,"col_end":82,"count":0}]},{"line":"                            calls: item.elt.calls.map_to_impl(fun),","counters":[{"col_start":0,"col_end":67,"count":0}]},{"line":"                        },","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"                        stack_hash: item.stack_hash,","counters":[{"col_start":0,"col_end":52,"count":0}]},{"line":"                    })","counters":[{"col_start":0,"col_end":21,"count":0},{"col_start":21,"col_end":22,"count":0}]},{"line":"                    .collect(),","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"            )","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        #[must_use]","counters":[]},{"line":"        pub fn map_to<F, AnotherAccUpdate: Clone>(&self, fun: F) -> CallForest<AnotherAccUpdate>","counters":[{"col_start":8,"col_end":96,"count":0}]},{"line":"        where","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"            F: Fn(&AccUpdate) -> AnotherAccUpdate,","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"        {","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"            self.map_to_impl(&fun)","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        fn to_account_updates_impl(&self, accounts: &mut Vec<AccUpdate>) {","counters":[{"col_start":8,"col_end":73,"count":0}]},{"line":"            // TODO: Check iteration order in OCaml","counters":[]},{"line":"            for elem in self.iter() {","counters":[{"col_start":16,"col_end":20,"count":0},{"col_start":29,"col_end":35,"count":0},{"col_start":36,"col_end":37,"count":0}]},{"line":"                accounts.push(elem.elt.account_update.clone());","counters":[{"col_start":0,"col_end":63,"count":0}]},{"line":"                elem.elt.calls.to_account_updates_impl(accounts);","counters":[{"col_start":0,"col_end":65,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/mina_base/zkapp_command.ml#L436","counters":[]},{"line":"        pub fn to_account_updates(&self) -> Vec<AccUpdate> {","counters":[{"col_start":8,"col_end":60,"count":0}]},{"line":"            let mut accounts = Vec::with_capacity(128);","counters":[{"col_start":0,"col_end":55,"count":0}]},{"line":"            self.to_account_updates_impl(&mut accounts);","counters":[{"col_start":0,"col_end":56,"count":0}]},{"line":"            accounts","counters":[{"col_start":0,"col_end":20,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl CallForest<AccountUpdate> {","counters":[]},{"line":"        pub fn cons(","counters":[{"col_start":8,"col_end":20,"count":0}]},{"line":"            &self,","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"            calls: Option<CallForest<AccountUpdate>>,","counters":[{"col_start":0,"col_end":53,"count":0}]},{"line":"            account_update: AccountUpdate,","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"        ) -> Self {","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"            let account_update_digest = account_update.digest();","counters":[{"col_start":0,"col_end":64,"count":0}]},{"line":"            //println!(\">>> cons account_update_digest {:?}\", account_update_digest);","counters":[{"col_start":0,"col_end":85,"count":0}]},{"line":"","counters":[]},{"line":"            let tree = Tree::<AccountUpdate> {","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"                account_update,","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"                account_update_digest,","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"                calls: calls.unwrap_or_else(|| CallForest(Vec::new())),","counters":[{"col_start":0,"col_end":44,"count":0},{"col_start":47,"col_end":69,"count":0},{"col_start":69,"col_end":71,"count":0}]},{"line":"            };","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"            self.cons_tree(tree)","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        fn add_callers_impl<F, U>(","counters":[{"col_start":8,"col_end":34,"count":0}]},{"line":"            &mut self,","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"            wired: &[U],","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"            current_context: CallForestContext,","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"            account_update_id: &F,","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"        ) where","counters":[{"col_start":0,"col_end":15,"count":0}]},{"line":"            U: AsAccountUpdateWithHash,","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"            F: Fn(&MinaBaseAccountUpdateTWireStableV1) -> TokenId,","counters":[{"col_start":0,"col_end":66,"count":0}]},{"line":"        {","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"            use mina_p2p_messages::v2::MinaBaseAccountUpdateCallTypeStableV1::{","counters":[{"col_start":0,"col_end":79,"count":0}]},{"line":"                Call, DelegateCall,","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"            };","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"","counters":[]},{"line":"            assert_eq!(self.0.len(), wired.len());","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"","counters":[]},{"line":"            self.0.iter_mut().zip(wired).for_each(|(elem, wired)| {","counters":[{"col_start":12,"col_end":50,"count":0},{"col_start":66,"col_end":67,"count":0}]},{"line":"                let WithStackHash {","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"                    elt:","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"                        Tree::<AccountUpdate> {","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"                            account_update,","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"                            calls,","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"                            ..","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"                        },","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"                    ..","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"                } = elem;","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"","counters":[]},{"line":"                let child_context = match &wired.elt().account_update.body.caller {","counters":[{"col_start":20,"col_end":33,"count":0},{"col_start":42,"col_end":81,"count":0}]},{"line":"                    DelegateCall => current_context.clone(),","counters":[{"col_start":36,"col_end":59,"count":0}]},{"line":"                    Call => CallForestContext {","counters":[{"col_start":28,"col_end":47,"count":0}]},{"line":"                        caller: current_context.this.clone(),","counters":[{"col_start":0,"col_end":61,"count":0}]},{"line":"                        this: account_update_id(&wired.elt().account_update),","counters":[{"col_start":0,"col_end":77,"count":0}]},{"line":"                    },","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"                };","counters":[]},{"line":"","counters":[]},{"line":"                account_update.body.caller = child_context.caller.clone();","counters":[{"col_start":16,"col_end":74,"count":0}]},{"line":"                calls.add_callers_impl(&wired.elt().calls, child_context, account_update_id);","counters":[{"col_start":0,"col_end":93,"count":0}]},{"line":"            });","counters":[{"col_start":0,"col_end":13,"count":0},{"col_start":13,"col_end":15,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        /// Delegate_call means, preserve the current caller.","counters":[]},{"line":"        ///","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/3fe924c80a4d01f418b69f27398f5f93eb652514/src/lib/mina_base/zkapp_command.ml#L616","counters":[]},{"line":"        pub fn add_callers<F>(","counters":[{"col_start":8,"col_end":30,"count":0}]},{"line":"            &mut self,","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"            wired: &[MinaBaseZkappCommandTStableV1WireStableV1AccountUpdatesA],","counters":[{"col_start":0,"col_end":79,"count":0}]},{"line":"            account_update_id: F,","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"        ) where","counters":[{"col_start":0,"col_end":15,"count":0}]},{"line":"            F: Fn(&MinaBaseAccountUpdateTWireStableV1) -> TokenId,","counters":[{"col_start":0,"col_end":66,"count":0}]},{"line":"        {","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"            let current_context = CallForestContext {","counters":[{"col_start":0,"col_end":53,"count":0}]},{"line":"                caller: TokenId::default(),","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"                this: TokenId::default(),","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"            };","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"","counters":[]},{"line":"            self.add_callers_impl(wired, current_context, &account_update_id);","counters":[{"col_start":0,"col_end":78,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/3fe924c80a4d01f418b69f27398f5f93eb652514/src/lib/mina_base/zkapp_command.ml#L583","counters":[]},{"line":"        pub fn accumulate_hashes<F>(&mut self, hash_account_update: &F)","counters":[{"col_start":8,"col_end":71,"count":0}]},{"line":"        where","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"            F: Fn(&AccountUpdate) -> Fp,","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"        {","counters":[{"col_start":0,"col_end":8,"count":0}]},{"line":"            /// https://github.com/MinaProtocol/mina/blob/3fe924c80a4d01f418b69f27398f5f93eb652514/src/lib/mina_base/zkapp_command.ml#L293","counters":[]},{"line":"            fn cons(hash: Fp, h_tl: Fp) -> Fp {","counters":[{"col_start":12,"col_end":47,"count":0}]},{"line":"                hash_with_kimchi(\"MinaAcctUpdateCons\", &[hash, h_tl])","counters":[{"col_start":0,"col_end":69,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"            /// https://github.com/MinaProtocol/mina/blob/3fe924c80a4d01f418b69f27398f5f93eb652514/src/lib/mina_base/zkapp_command.ml#L561","counters":[]},{"line":"            fn hash<AccUpdate: Clone>(elem: Option<&WithStackHash<AccUpdate>>) -> Fp {","counters":[{"col_start":12,"col_end":86,"count":0}]},{"line":"                match elem {","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"                    Some(next) => next.stack_hash,","counters":[{"col_start":25,"col_end":49,"count":0}]},{"line":"                    None => Fp::zero(),","counters":[{"col_start":28,"col_end":38,"count":0}]},{"line":"                }","counters":[]},{"line":"            }","counters":[{"col_start":12,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"            // We traverse the list in reverse here (to get same behavior as OCaml recursivity)","counters":[]},{"line":"            // Note that reverse here means 0 to last, see `CallForest::iter` for explaination","counters":[]},{"line":"            //","counters":[]},{"line":"            // We use indexes to make the borrow checker happy","counters":[]},{"line":"","counters":[]},{"line":"            for index in 0..self.0.len() {","counters":[{"col_start":16,"col_end":21,"count":0},{"col_start":28,"col_end":40,"count":0},{"col_start":41,"col_end":42,"count":0}]},{"line":"                let elem = &mut self.0[index];","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"                let WithStackHash {","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"                    elt:","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"                        Tree::<AccountUpdate> {","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"                            account_update,","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"                            account_update_digest,","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"                            calls,","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"                            ..","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"                        },","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"                    ..","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"                } = elem;","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"                calls.accumulate_hashes(hash_account_update);","counters":[{"col_start":0,"col_end":61,"count":0}]},{"line":"                *account_update_digest = hash_account_update(account_update);","counters":[{"col_start":0,"col_end":77,"count":0}]},{"line":"","counters":[]},{"line":"                let node_hash = elem.elt.digest();","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"                let hash = hash(self.0.get(index + 1));","counters":[{"col_start":0,"col_end":55,"count":0}]},{"line":"                //println!(\"<<<<< accumulate_hashes node_hash {:?} hash {:?}\", node_hash, hash);","counters":[{"col_start":0,"col_end":96,"count":0}]},{"line":"","counters":[]},{"line":"                self.0[index].stack_hash = cons(node_hash, hash);","counters":[{"col_start":0,"col_end":65,"count":0}]},{"line":"                //println!(\"<<<<< accumulate_hashes stack_hash {:?}\", self.0[index].stack_hash);","counters":[{"col_start":0,"col_end":96,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn accumulate_hashes_predicated(&mut self) {","counters":[{"col_start":8,"col_end":56,"count":0}]},{"line":"            // Note: There seems to be no difference with `accumulate_hashes`","counters":[{"col_start":0,"col_end":77,"count":0}]},{"line":"            self.accumulate_hashes(&|account_update| account_update.digest());","counters":[{"col_start":0,"col_end":78,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/3fe924c80a4d01f418b69f27398f5f93eb652514/src/lib/mina_base/zkapp_command.ml#L672","counters":[]},{"line":"        fn remove_callers_impl<U>(","counters":[{"col_start":8,"col_end":34,"count":0}]},{"line":"            &self,","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"            wired: &mut [U],","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"            is_top_level: bool,","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"            parent_caller: &TokenId,","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"        ) where","counters":[{"col_start":0,"col_end":15,"count":0}]},{"line":"            U: AsAccountUpdateWithHash,","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"        {","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"            use mina_p2p_messages::v2::MinaBaseAccountUpdateCallTypeStableV1::{","counters":[{"col_start":0,"col_end":79,"count":0}]},{"line":"                Call, DelegateCall,","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"            };","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"","counters":[]},{"line":"            let call_type = |account_caller: &TokenId| {","counters":[{"col_start":0,"col_end":28,"count":0},{"col_start":55,"col_end":56,"count":0}]},{"line":"                if is_top_level {","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"                    Call","counters":[{"col_start":20,"col_end":24,"count":0}]},{"line":"                } else if account_caller == parent_caller {","counters":[{"col_start":26,"col_end":57,"count":0}]},{"line":"                    DelegateCall","counters":[{"col_start":20,"col_end":32,"count":0}]},{"line":"                } else {","counters":[]},{"line":"                    Call","counters":[{"col_start":20,"col_end":24,"count":0}]},{"line":"                }","counters":[]},{"line":"            };","counters":[{"col_start":12,"col_end":13,"count":0},{"col_start":13,"col_end":14,"count":0}]},{"line":"","counters":[]},{"line":"            wired.iter_mut().zip(&self.0).for_each(|(wired, this)| {","counters":[{"col_start":0,"col_end":51,"count":0},{"col_start":67,"col_end":68,"count":0}]},{"line":"                let WithStackHash {","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"                    elt:","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"                        Tree::<AccountUpdate> {","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"                            account_update,","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"                            calls,","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"                            ..","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"                        },","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"                    ..","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"                } = this;","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"                let wired = wired.elt_mut();","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"                let account_caller = &account_update.body.caller;","counters":[{"col_start":0,"col_end":65,"count":0}]},{"line":"","counters":[]},{"line":"                wired.account_update.body.caller = call_type(account_caller);","counters":[{"col_start":0,"col_end":77,"count":0}]},{"line":"","counters":[]},{"line":"                calls.remove_callers_impl(&mut wired.calls, false, account_caller);","counters":[{"col_start":0,"col_end":83,"count":0}]},{"line":"            });","counters":[{"col_start":0,"col_end":13,"count":0},{"col_start":13,"col_end":15,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        fn remove_callers(","counters":[{"col_start":8,"col_end":26,"count":0}]},{"line":"            &self,","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"            wired: &mut [MinaBaseZkappCommandTStableV1WireStableV1AccountUpdatesA],","counters":[{"col_start":0,"col_end":83,"count":0}]},{"line":"        ) {","counters":[{"col_start":0,"col_end":11,"count":0}]},{"line":"            self.remove_callers_impl(wired, true, &TokenId::default());","counters":[{"col_start":0,"col_end":71,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/3fe924c80a4d01f418b69f27398f5f93eb652514/src/lib/mina_base/zkapp_command.ml#L1079","counters":[]},{"line":"        pub fn of_wire(","counters":[{"col_start":8,"col_end":23,"count":0}]},{"line":"            &mut self,","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"            wired: &[MinaBaseZkappCommandTStableV1WireStableV1AccountUpdatesA],","counters":[{"col_start":0,"col_end":79,"count":0}]},{"line":"        ) {","counters":[{"col_start":0,"col_end":11,"count":0}]},{"line":"            self.add_callers(wired, |wired_update| {","counters":[{"col_start":0,"col_end":36,"count":0},{"col_start":51,"col_end":52,"count":0}]},{"line":"                let public_key: CompressedPubKey = (&wired_update.body.public_key).into();","counters":[{"col_start":0,"col_end":90,"count":0}]},{"line":"                let token_id: TokenId = (&*wired_update.body.token_id).into();","counters":[{"col_start":0,"col_end":78,"count":0}]},{"line":"","counters":[]},{"line":"                AccountId::new(public_key, token_id).derive_token_id()","counters":[{"col_start":0,"col_end":70,"count":0}]},{"line":"            });","counters":[{"col_start":0,"col_end":13,"count":0},{"col_start":13,"col_end":15,"count":0}]},{"line":"","counters":[]},{"line":"            self.accumulate_hashes(&|account_update| account_update.digest());","counters":[{"col_start":0,"col_end":78,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/3fe924c80a4d01f418b69f27398f5f93eb652514/src/lib/mina_base/zkapp_command.ml#L1096","counters":[]},{"line":"        pub fn to_wire(","counters":[{"col_start":8,"col_end":23,"count":0}]},{"line":"            &self,","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"            wired: &mut [MinaBaseZkappCommandTStableV1WireStableV1AccountUpdatesA],","counters":[{"col_start":0,"col_end":83,"count":0}]},{"line":"        ) {","counters":[{"col_start":0,"col_end":11,"count":0}]},{"line":"            self.remove_callers(wired);","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl CallForest<AccountUpdateSimple> {","counters":[]},{"line":"        fn into_add_callers_simple_impl(","counters":[{"col_start":8,"col_end":40,"count":0}]},{"line":"            self,","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"            current_context: CallForestContext,","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"        ) -> CallForest<AccountUpdate> {","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"            use mina_p2p_messages::v2::MinaBaseAccountUpdateCallTypeStableV1::{","counters":[{"col_start":0,"col_end":79,"count":0}]},{"line":"                Call, DelegateCall,","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"            };","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"","counters":[]},{"line":"            CallForest(","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"                self.0","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"                    .into_iter()","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"                    .map(|elem| {","counters":[{"col_start":0,"col_end":25,"count":0},{"col_start":32,"col_end":33,"count":0}]},{"line":"                        let WithStackHash {","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"                            elt:","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"                                Tree::<AccountUpdateSimple> {","counters":[{"col_start":0,"col_end":61,"count":0}]},{"line":"                                    account_update:","counters":[{"col_start":0,"col_end":51,"count":0}]},{"line":"                                        AccountUpdateSimple {","counters":[{"col_start":0,"col_end":61,"count":0}]},{"line":"                                            body:","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"                                                BodySimple {","counters":[{"col_start":0,"col_end":60,"count":0}]},{"line":"                                                    public_key,","counters":[{"col_start":0,"col_end":63,"count":0}]},{"line":"                                                    token_id,","counters":[{"col_start":0,"col_end":61,"count":0}]},{"line":"                                                    update,","counters":[{"col_start":0,"col_end":59,"count":0}]},{"line":"                                                    balance_change,","counters":[{"col_start":0,"col_end":67,"count":0}]},{"line":"                                                    increment_nonce,","counters":[{"col_start":0,"col_end":68,"count":0}]},{"line":"                                                    events,","counters":[{"col_start":0,"col_end":59,"count":0}]},{"line":"                                                    sequence_events,","counters":[{"col_start":0,"col_end":68,"count":0}]},{"line":"                                                    call_data,","counters":[{"col_start":0,"col_end":62,"count":0}]},{"line":"                                                    call_depth: _,","counters":[{"col_start":0,"col_end":66,"count":0}]},{"line":"                                                    preconditions,","counters":[{"col_start":0,"col_end":66,"count":0}]},{"line":"                                                    use_full_commitment,","counters":[{"col_start":0,"col_end":72,"count":0}]},{"line":"                                                    caller,","counters":[{"col_start":0,"col_end":59,"count":0}]},{"line":"                                                    authorization_kind,","counters":[{"col_start":0,"col_end":71,"count":0}]},{"line":"                                                },","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"                                            authorization,","counters":[{"col_start":0,"col_end":58,"count":0}]},{"line":"                                        },","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"                                    calls,","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"                                    account_update_digest,","counters":[{"col_start":0,"col_end":58,"count":0}]},{"line":"                                },","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"                            stack_hash,","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"                        } = elem;","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"","counters":[]},{"line":"                        let child_context = match &caller {","counters":[{"col_start":28,"col_end":41,"count":0},{"col_start":50,"col_end":57,"count":0}]},{"line":"                            DelegateCall => current_context.clone(),","counters":[{"col_start":44,"col_end":67,"count":0}]},{"line":"                            Call => CallForestContext {","counters":[{"col_start":36,"col_end":55,"count":0}]},{"line":"                                caller: current_context.this.clone(),","counters":[{"col_start":0,"col_end":69,"count":0}]},{"line":"                                this: AccountId::create(public_key.clone(), token_id.clone())","counters":[{"col_start":0,"col_end":93,"count":0}]},{"line":"                                    .derive_token_id(),","counters":[{"col_start":0,"col_end":55,"count":0}]},{"line":"                            },","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"                        };","counters":[]},{"line":"","counters":[]},{"line":"                        WithStackHash {","counters":[{"col_start":24,"col_end":39,"count":0}]},{"line":"                            elt: Tree::<AccountUpdate> {","counters":[{"col_start":0,"col_end":56,"count":0}]},{"line":"                                account_update: AccountUpdate {","counters":[{"col_start":0,"col_end":63,"count":0}]},{"line":"                                    body: Body {","counters":[{"col_start":0,"col_end":48,"count":0}]},{"line":"                                        public_key,","counters":[{"col_start":0,"col_end":51,"count":0}]},{"line":"                                        token_id,","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"                                        update,","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"                                        balance_change,","counters":[{"col_start":0,"col_end":55,"count":0}]},{"line":"                                        increment_nonce,","counters":[{"col_start":0,"col_end":56,"count":0}]},{"line":"                                        events,","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"                                        sequence_events,","counters":[{"col_start":0,"col_end":56,"count":0}]},{"line":"                                        call_data,","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"                                        preconditions,","counters":[{"col_start":0,"col_end":54,"count":0}]},{"line":"                                        use_full_commitment,","counters":[{"col_start":0,"col_end":60,"count":0}]},{"line":"                                        caller: child_context.caller.clone(),","counters":[{"col_start":0,"col_end":77,"count":0}]},{"line":"                                        authorization_kind,","counters":[{"col_start":0,"col_end":59,"count":0}]},{"line":"                                    },","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"                                    authorization,","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"                                },","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"                                account_update_digest,","counters":[{"col_start":0,"col_end":54,"count":0}]},{"line":"                                calls: calls.into_add_callers_simple_impl(child_context),","counters":[{"col_start":0,"col_end":89,"count":0}]},{"line":"                            },","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"                            stack_hash,","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"                        }","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"                    })","counters":[{"col_start":0,"col_end":21,"count":0},{"col_start":21,"col_end":22,"count":0}]},{"line":"                    .collect(),","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"            )","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/3fe924c80a4d01f418b69f27398f5f93eb652514/src/lib/mina_base/zkapp_command.ml#L665","counters":[]},{"line":"        pub fn into_add_callers_simple(self) -> CallForest<AccountUpdate> {","counters":[{"col_start":8,"col_end":75,"count":0}]},{"line":"            let current_context = CallForestContext {","counters":[{"col_start":0,"col_end":53,"count":0}]},{"line":"                caller: TokenId::default(),","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"                this: TokenId::default(),","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"            };","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"","counters":[]},{"line":"            self.into_add_callers_simple_impl(current_context)","counters":[{"col_start":0,"col_end":62,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/mina_base/account_update.ml#L1081","counters":[]},{"line":"    #[derive(Debug, Clone, PartialEq, Eq)]","counters":[{"col_start":13,"col_end":18,"count":0},{"col_start":20,"col_end":25,"count":0}]},{"line":"    pub struct FeePayerBody {","counters":[]},{"line":"        pub public_key: CompressedPubKey,","counters":[]},{"line":"        pub fee: Fee,","counters":[]},{"line":"        pub valid_until: Option<Slot>,","counters":[]},{"line":"        pub nonce: Nonce,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/mina_base/account_update.ml#L1484","counters":[]},{"line":"    #[derive(Debug, Clone, PartialEq, Eq)]","counters":[{"col_start":13,"col_end":18,"count":0},{"col_start":20,"col_end":25,"count":0}]},{"line":"    pub struct FeePayer {","counters":[]},{"line":"        pub body: FeePayerBody,","counters":[]},{"line":"        pub authorization: Signature,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/mina_base/zkapp_command.ml#L959","counters":[]},{"line":"    #[derive(Debug, Clone, PartialEq)]","counters":[{"col_start":13,"col_end":18,"count":0},{"col_start":20,"col_end":25,"count":0}]},{"line":"    pub struct ZkAppCommand {","counters":[]},{"line":"        pub fee_payer: FeePayer,","counters":[]},{"line":"        pub account_updates: CallForest<AccountUpdate>,","counters":[]},{"line":"        pub memo: Memo,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl ZkAppCommand {","counters":[]},{"line":"        pub fn fee_payer(&self) -> AccountId {","counters":[{"col_start":8,"col_end":46,"count":0}]},{"line":"            let public_key = self.fee_payer.body.public_key.clone();","counters":[{"col_start":0,"col_end":68,"count":0}]},{"line":"            AccountId::new(public_key, self.fee_token())","counters":[{"col_start":0,"col_end":56,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn fee_token(&self) -> TokenId {","counters":[{"col_start":8,"col_end":44,"count":0}]},{"line":"            TokenId::default()","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn fee(&self) -> Fee {","counters":[{"col_start":8,"col_end":34,"count":0}]},{"line":"            self.fee_payer.body.fee","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn fee_excess(&self) -> FeeExcess {","counters":[{"col_start":8,"col_end":47,"count":0}]},{"line":"            FeeExcess::of_single((self.fee_token(), Signed::<Fee>::of_unsigned(self.fee())))","counters":[{"col_start":0,"col_end":92,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/mina_base/zkapp_command.ml#L1241","counters":[]},{"line":"        pub fn accounts_accessed(&self, status: TransactionStatus) -> Vec<AccountId> {","counters":[{"col_start":8,"col_end":86,"count":0}]},{"line":"            use TransactionStatus::*;","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"            match status {","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"                Applied => {","counters":[]},{"line":"                    let mut init_vec = Vec::with_capacity(256);","counters":[{"col_start":24,"col_end":63,"count":0}]},{"line":"                    init_vec.push(self.fee_payer());","counters":[{"col_start":0,"col_end":52,"count":0}]},{"line":"                    self.account_updates","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"                        .fold(init_vec, |mut accum, account_update| {","counters":[{"col_start":0,"col_end":40,"count":0},{"col_start":68,"col_end":69,"count":0}]},{"line":"                            accum.push(account_update.account_id());","counters":[{"col_start":0,"col_end":68,"count":0}]},{"line":"                            accum","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"                        })","counters":[{"col_start":0,"col_end":25,"count":0},{"col_start":25,"col_end":26,"count":0}]},{"line":"                        .iter()","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"                        .unique()","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"                        .cloned()","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"                        .collect()","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"                }","counters":[]},{"line":"                Failed(_) => vec![self.fee_payer()],","counters":[{"col_start":29,"col_end":51,"count":0}]},{"line":"            }","counters":[]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/mina_base/zkapp_command.ml#L1251","counters":[]},{"line":"        pub fn accounts_referenced(&self) -> Vec<AccountId> {","counters":[{"col_start":8,"col_end":61,"count":0}]},{"line":"            self.accounts_accessed(TransactionStatus::Applied)","counters":[{"col_start":0,"col_end":62,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/mina_base/zkapp_command.ml#L1346","counters":[]},{"line":"        pub fn of_verifiable(verifiable: verifiable::ZkAppCommand) -> Self {","counters":[{"col_start":8,"col_end":76,"count":0}]},{"line":"            Self {","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"                fee_payer: verifiable.fee_payer,","counters":[{"col_start":0,"col_end":48,"count":0}]},{"line":"                account_updates: verifiable.account_updates.map_to(|(acc, _)| acc.clone()),","counters":[{"col_start":0,"col_end":67,"count":0},{"col_start":78,"col_end":89,"count":0},{"col_start":89,"col_end":91,"count":0}]},{"line":"                memo: verifiable.memo,","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/mina_base/zkapp_command.ml#L1386","counters":[]},{"line":"        pub fn account_updates_hash(&self) -> Fp {","counters":[{"col_start":8,"col_end":50,"count":0}]},{"line":"            self.account_updates.hash()","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    pub mod verifiable {","counters":[]},{"line":"        use super::*;","counters":[]},{"line":"        use crate::VerificationKey;","counters":[]},{"line":"","counters":[]},{"line":"        #[derive(Debug, Clone)]","counters":[{"col_start":17,"col_end":22,"count":0}]},{"line":"        pub struct ZkAppCommand {","counters":[]},{"line":"            pub fee_payer: FeePayer,","counters":[]},{"line":"            pub account_updates: CallForest<(AccountUpdate, Option<WithHash<VerificationKey>>)>,","counters":[]},{"line":"            pub memo: Memo,","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    pub mod valid {","counters":[]},{"line":"        use std::collections::HashMap;","counters":[]},{"line":"","counters":[]},{"line":"        use crate::scan_state::transaction_logic::valid::VerificationKeyHash;","counters":[]},{"line":"","counters":[]},{"line":"        use super::*;","counters":[]},{"line":"","counters":[]},{"line":"        #[derive(Clone, Debug, PartialEq)]","counters":[{"col_start":17,"col_end":22,"count":0},{"col_start":24,"col_end":29,"count":0}]},{"line":"        pub struct ZkAppCommand {","counters":[]},{"line":"            pub zkapp_command: super::ZkAppCommand,","counters":[]},{"line":"            pub verification_keys: Vec<(AccountId, VerificationKeyHash)>,","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        impl ZkAppCommand {","counters":[]},{"line":"            pub fn forget(self) -> super::ZkAppCommand {","counters":[{"col_start":12,"col_end":56,"count":0}]},{"line":"                self.zkapp_command","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/mina_base/zkapp_command.ml#L1486","counters":[]},{"line":"        pub fn of_verifiable(cmd: verifiable::ZkAppCommand) -> Option<ZkAppCommand> {","counters":[{"col_start":8,"col_end":85,"count":0}]},{"line":"            use AuthorizationKind as AK;","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"            use Control as C;","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"            let mut keys = HashMap::with_capacity(256);","counters":[{"col_start":0,"col_end":55,"count":0}]},{"line":"","counters":[]},{"line":"            cmd.account_updates.fold(Some(()), |accum, (p, vk_opt)| {","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"                accum?;","counters":[{"col_start":16,"col_end":21,"count":0},{"col_start":21,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"                match (&p.authorization, &p.body.authorization_kind) {","counters":[{"col_start":23,"col_end":67,"count":0}]},{"line":"                    (C::NoneGiven, AK::NoneGiven)","counters":[]},{"line":"                    | (C::Proof(_), AK::Proof)","counters":[]},{"line":"                    | (C::Signature(_), AK::Signature) => {}","counters":[{"col_start":58,"col_end":60,"count":0}]},{"line":"                    _ => return None,","counters":[{"col_start":32,"col_end":36,"count":0}]},{"line":"                }","counters":[]},{"line":"","counters":[]},{"line":"                if let C::Proof(_) = &p.authorization {","counters":[{"col_start":23,"col_end":53,"count":0},{"col_start":54,"col_end":55,"count":0}]},{"line":"                    let hash = vk_opt.as_ref()?.hash;","counters":[{"col_start":0,"col_end":28,"count":0},{"col_start":31,"col_end":46,"count":0},{"col_start":46,"col_end":47,"count":0}]},{"line":"                    keys.insert(p.account_id(), VerificationKeyHash(hash));","counters":[{"col_start":20,"col_end":74,"count":0}]},{"line":"                };","counters":[{"col_start":17,"col_end":18,"count":0}]},{"line":"                Some(())","counters":[{"col_start":16,"col_end":24,"count":0}]},{"line":"            })?;","counters":[{"col_start":12,"col_end":13,"count":0},{"col_start":13,"col_end":14,"count":0},{"col_start":14,"col_end":15,"count":0}]},{"line":"","counters":[]},{"line":"            Some(ZkAppCommand {","counters":[{"col_start":12,"col_end":31,"count":0}]},{"line":"                zkapp_command: super::ZkAppCommand::of_verifiable(cmd),","counters":[{"col_start":0,"col_end":71,"count":0}]},{"line":"                verification_keys: keys.into_iter().collect(),","counters":[{"col_start":0,"col_end":62,"count":0}]},{"line":"            })","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/mina_base/zkapp_command.ml#L1518","counters":[]},{"line":"        pub fn to_valid(","counters":[{"col_start":8,"col_end":24,"count":0}]},{"line":"            zkapp_command: super::ZkAppCommand,","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"            ledger: &impl BaseLedger,","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"        ) -> Option<ZkAppCommand> {","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"            let find_vk = |account_id: &AccountId| -> Option<VerificationKey> {","counters":[{"col_start":0,"col_end":23,"count":0},{"col_start":78,"col_end":79,"count":0}]},{"line":"                let addr = ledger.location_of_account(account_id)?;","counters":[{"col_start":20,"col_end":24,"count":0},{"col_start":27,"col_end":65,"count":0},{"col_start":65,"col_end":66,"count":0}]},{"line":"                let account = ledger.get(addr)?;","counters":[{"col_start":20,"col_end":27,"count":0},{"col_start":30,"col_end":46,"count":0},{"col_start":46,"col_end":47,"count":0}]},{"line":"                account.zkapp.as_ref()?.verification_key.clone()","counters":[{"col_start":16,"col_end":38,"count":0},{"col_start":38,"col_end":39,"count":0},{"col_start":57,"col_end":64,"count":0}]},{"line":"            };","counters":[{"col_start":12,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"            let mut tbl = HashMap::with_capacity(64);","counters":[{"col_start":16,"col_end":53,"count":0}]},{"line":"","counters":[]},{"line":"            zkapp_command.account_updates.fold(Some(()), |accum, p| {","counters":[{"col_start":0,"col_end":57,"count":0}]},{"line":"                accum?;","counters":[{"col_start":16,"col_end":21,"count":0},{"col_start":21,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"                if let ControlTag::Proof = p.authorization.tag() {","counters":[{"col_start":23,"col_end":64,"count":0}]},{"line":"                    let account_id = p.account_id();","counters":[{"col_start":24,"col_end":52,"count":0}]},{"line":"                    find_vk(&account_id).map(|vk| {","counters":[{"col_start":0,"col_end":45,"count":0},{"col_start":50,"col_end":51,"count":0}]},{"line":"                        // TODO: The hash should be beside the vk here","counters":[{"col_start":0,"col_end":70,"count":0}]},{"line":"                        tbl.insert(account_id, VerificationKeyHash(vk.hash()));","counters":[{"col_start":0,"col_end":79,"count":0}]},{"line":"                    })","counters":[{"col_start":0,"col_end":21,"count":0},{"col_start":21,"col_end":22,"count":0}]},{"line":"                } else {","counters":[]},{"line":"                    accum","counters":[{"col_start":20,"col_end":25,"count":0}]},{"line":"                }","counters":[]},{"line":"            })?;","counters":[{"col_start":12,"col_end":13,"count":0},{"col_start":13,"col_end":14,"count":0},{"col_start":14,"col_end":15,"count":0}]},{"line":"","counters":[]},{"line":"            Some(ZkAppCommand {","counters":[{"col_start":12,"col_end":31,"count":0}]},{"line":"                zkapp_command,","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"                verification_keys: tbl.into_iter().collect(),","counters":[{"col_start":0,"col_end":61,"count":0}]},{"line":"            })","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"pub mod verifiable {","counters":[]},{"line":"    use std::ops::Neg;","counters":[]},{"line":"","counters":[]},{"line":"    use ark_ff::{BigInteger, PrimeField};","counters":[]},{"line":"    use mina_signer::Signer;","counters":[]},{"line":"","counters":[]},{"line":"    use super::*;","counters":[]},{"line":"","counters":[]},{"line":"    #[derive(Debug)]","counters":[{"col_start":13,"col_end":14,"count":0},{"col_start":17,"col_end":18,"count":0}]},{"line":"    pub enum UserCommand {","counters":[]},{"line":"        SignedCommand(Box<signed_command::SignedCommand>),","counters":[]},{"line":"        ZkAppCommand(Box<zkapp_command::verifiable::ZkAppCommand>),","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn compressed_to_pubkey(pubkey: &CompressedPubKey) -> mina_signer::PubKey {","counters":[{"col_start":4,"col_end":79,"count":0}]},{"line":"        // Taken from https://github.com/o1-labs/proof-systems/blob/e3fc04ce87f8695288de167115dea80050ab33f4/signer/src/pubkey.rs#L95-L106","counters":[{"col_start":0,"col_end":138,"count":0}]},{"line":"        let mut pt = mina_signer::CurvePoint::get_point_from_x(pubkey.x, pubkey.is_odd).unwrap();","counters":[{"col_start":0,"col_end":97,"count":0}]},{"line":"","counters":[]},{"line":"        if pt.y.into_repr().is_even() == pubkey.is_odd {","counters":[{"col_start":0,"col_end":54,"count":0},{"col_start":55,"col_end":56,"count":0}]},{"line":"            pt.y = pt.y.neg();","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0},{"col_start":9,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"        assert!(pt.is_on_curve());","counters":[{"col_start":8,"col_end":33,"count":0}]},{"line":"","counters":[]},{"line":"        // Safe now because we checked point pt is on curve","counters":[]},{"line":"        mina_signer::PubKey::from_point_unsafe(pt)","counters":[{"col_start":8,"col_end":50,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/mina_base/signed_command.ml#L436","counters":[]},{"line":"    pub fn check_only_for_signature(","counters":[{"col_start":4,"col_end":36,"count":0}]},{"line":"        cmd: Box<signed_command::SignedCommand>,","counters":[{"col_start":0,"col_end":48,"count":0}]},{"line":"    ) -> Result<valid::UserCommand, Box<signed_command::SignedCommand>> {","counters":[{"col_start":0,"col_end":73,"count":0}]},{"line":"        // https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/mina_base/signed_command.ml#L396","counters":[{"col_start":0,"col_end":134,"count":0}]},{"line":"","counters":[]},{"line":"        let signed_command::SignedCommand {","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"            payload,","counters":[{"col_start":0,"col_end":20,"count":0}]},{"line":"            signer: pubkey,","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"            signature,","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"        } = &*cmd;","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"","counters":[]},{"line":"        let payload = TransactionUnionPayload::of_user_command_payload(payload);","counters":[{"col_start":0,"col_end":80,"count":0}]},{"line":"        let pubkey = compressed_to_pubkey(pubkey);","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"","counters":[]},{"line":"        let mut signer = mina_signer::create_legacy(mina_signer::NetworkId::TESTNET);","counters":[{"col_start":0,"col_end":85,"count":0}]},{"line":"","counters":[]},{"line":"        if signer.verify(signature, &pubkey, &payload) {","counters":[{"col_start":0,"col_end":54,"count":0}]},{"line":"            Ok(valid::UserCommand::SignedCommand(cmd))","counters":[{"col_start":12,"col_end":54,"count":0}]},{"line":"        } else {","counters":[]},{"line":"            Err(cmd)","counters":[{"col_start":12,"col_end":20,"count":0}]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"#[derive(Clone, Debug, PartialEq)]","counters":[{"col_start":9,"col_end":10,"count":0},{"col_start":13,"col_end":14,"count":0},{"col_start":16,"col_end":17,"count":0},{"col_start":20,"col_end":21,"count":0}]},{"line":"pub enum UserCommand {","counters":[]},{"line":"    SignedCommand(Box<signed_command::SignedCommand>),","counters":[]},{"line":"    ZkAppCommand(Box<zkapp_command::ZkAppCommand>),","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl From<&UserCommand> for MinaBaseUserCommandStableV2 {","counters":[]},{"line":"    fn from(user_command: &UserCommand) -> Self {","counters":[{"col_start":4,"col_end":49,"count":0}]},{"line":"        match user_command {","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"            UserCommand::SignedCommand(signed_command) => {","counters":[{"col_start":39,"col_end":59,"count":0}]},{"line":"                MinaBaseUserCommandStableV2::SignedCommand((&(*(signed_command.clone()))).into())","counters":[{"col_start":0,"col_end":97,"count":0}]},{"line":"            }","counters":[]},{"line":"            UserCommand::ZkAppCommand(zkapp_command) => {","counters":[{"col_start":38,"col_end":57,"count":0}]},{"line":"                MinaBaseUserCommandStableV2::ZkappCommand((&(*(zkapp_command.clone()))).into())","counters":[{"col_start":0,"col_end":95,"count":0}]},{"line":"            }","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl From<&MinaBaseUserCommandStableV2> for UserCommand {","counters":[]},{"line":"    fn from(user_command: &MinaBaseUserCommandStableV2) -> Self {","counters":[{"col_start":4,"col_end":65,"count":0}]},{"line":"        match user_command {","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"            MinaBaseUserCommandStableV2::SignedCommand(signed_command) => {","counters":[{"col_start":55,"col_end":75,"count":0}]},{"line":"                UserCommand::SignedCommand(Box::new(signed_command.into()))","counters":[{"col_start":0,"col_end":75,"count":0}]},{"line":"            }","counters":[]},{"line":"            MinaBaseUserCommandStableV2::ZkappCommand(zkapp_command) => {","counters":[{"col_start":54,"col_end":73,"count":0}]},{"line":"                UserCommand::ZkAppCommand(Box::new(zkapp_command.into()))","counters":[{"col_start":0,"col_end":73,"count":0}]},{"line":"            }","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl binprot::BinProtWrite for UserCommand {","counters":[]},{"line":"    fn binprot_write<W: std::io::Write>(&self, w: &mut W) -> std::io::Result<()> {","counters":[{"col_start":4,"col_end":82,"count":0}]},{"line":"        let p2p: MinaBaseUserCommandStableV2 = self.into();","counters":[{"col_start":0,"col_end":59,"count":0}]},{"line":"        p2p.binprot_write(w)","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl binprot::BinProtRead for UserCommand {","counters":[]},{"line":"    fn binprot_read<R: std::io::Read + ?Sized>(r: &mut R) -> Result<Self, binprot::Error> {","counters":[{"col_start":4,"col_end":90,"count":0}]},{"line":"        let p2p = MinaBaseUserCommandStableV2::binprot_read(r)?;","counters":[{"col_start":12,"col_end":15,"count":0},{"col_start":18,"col_end":62,"count":0},{"col_start":62,"col_end":63,"count":0}]},{"line":"        Ok(UserCommand::from(&p2p))","counters":[{"col_start":8,"col_end":35,"count":0}]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl UserCommand {","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/mina_base/user_command.ml#L203","counters":[]},{"line":"    pub fn accounts_accessed(&self, status: TransactionStatus) -> Vec<AccountId> {","counters":[{"col_start":4,"col_end":82,"count":0}]},{"line":"        match self {","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"            UserCommand::SignedCommand(cmd) => cmd.accounts_accessed(status),","counters":[{"col_start":39,"col_end":76,"count":0}]},{"line":"            UserCommand::ZkAppCommand(cmd) => cmd.accounts_accessed(status),","counters":[{"col_start":38,"col_end":75,"count":0}]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/mina_base/user_command.ml#L210","counters":[]},{"line":"    pub fn accounts_referenced(&self) -> Vec<AccountId> {","counters":[{"col_start":4,"col_end":57,"count":0}]},{"line":"        self.accounts_accessed(TransactionStatus::Applied)","counters":[{"col_start":0,"col_end":58,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/mina_base/user_command.ml#L192","counters":[]},{"line":"    pub fn fee(&self) -> Fee {","counters":[{"col_start":4,"col_end":30,"count":0}]},{"line":"        match self {","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"            UserCommand::SignedCommand(cmd) => cmd.fee(),","counters":[{"col_start":39,"col_end":56,"count":0}]},{"line":"            UserCommand::ZkAppCommand(cmd) => cmd.fee(),","counters":[{"col_start":38,"col_end":55,"count":0}]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3fe924c80a4d01f418b69f27398f5f93eb652514/src/lib/mina_base/user_command.ml#L162","counters":[]},{"line":"    pub fn to_verifiable(&self, ledger: &impl BaseLedger) -> verifiable::UserCommand {","counters":[]},{"line":"        let find_vk = |acc: &zkapp_command::AccountUpdate| -> Option<VerificationKey> {","counters":[]},{"line":"            let account_id = acc.account_id();","counters":[]},{"line":"            let addr = ledger.location_of_account(&account_id)?;","counters":[]},{"line":"            let account = ledger.get(addr)?;","counters":[]},{"line":"            account.zkapp.as_ref()?.verification_key.clone()","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        match self {","counters":[]},{"line":"            UserCommand::SignedCommand(cmd) => verifiable::UserCommand::SignedCommand(cmd.clone()),","counters":[]},{"line":"            UserCommand::ZkAppCommand(cmd) => {","counters":[]},{"line":"                let zkapp_command::ZkAppCommand {","counters":[]},{"line":"                    fee_payer,","counters":[]},{"line":"                    account_updates,","counters":[]},{"line":"                    memo,","counters":[]},{"line":"                } = &**cmd;","counters":[]},{"line":"","counters":[]},{"line":"                let zkapp = zkapp_command::verifiable::ZkAppCommand {","counters":[]},{"line":"                    fee_payer: fee_payer.clone(),","counters":[]},{"line":"                    account_updates: account_updates.map_to(|account_update| {","counters":[]},{"line":"                        let vk_with_hash = find_vk(account_update).map(|vk| {","counters":[]},{"line":"                            let hash = vk.hash();","counters":[]},{"line":"                            WithHash { data: vk, hash }","counters":[]},{"line":"                        });","counters":[]},{"line":"","counters":[]},{"line":"                        (account_update.clone(), vk_with_hash)","counters":[]},{"line":"                    }),","counters":[]},{"line":"                    memo: memo.clone(),","counters":[]},{"line":"                };","counters":[]},{"line":"","counters":[]},{"line":"                verifiable::UserCommand::ZkAppCommand(Box::new(zkapp))","counters":[]},{"line":"            }","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl GenericCommand for UserCommand {","counters":[]},{"line":"    fn fee(&self) -> Fee {","counters":[{"col_start":4,"col_end":26,"count":0}]},{"line":"        match self {","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"            UserCommand::SignedCommand(cmd) => cmd.fee(),","counters":[{"col_start":39,"col_end":56,"count":0}]},{"line":"            UserCommand::ZkAppCommand(cmd) => cmd.fee(),","counters":[{"col_start":38,"col_end":55,"count":0}]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn forget(&self) -> UserCommand {","counters":[{"col_start":4,"col_end":37,"count":0}]},{"line":"        self.clone()","counters":[{"col_start":0,"col_end":20,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl GenericTransaction for Transaction {","counters":[]},{"line":"    fn is_fee_transfer(&self) -> bool {","counters":[{"col_start":4,"col_end":38,"count":0}]},{"line":"        matches!(self, Transaction::FeeTransfer(_))","counters":[{"col_start":8,"col_end":16,"count":0},{"col_start":17,"col_end":21,"count":0}]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"    fn is_coinbase(&self) -> bool {","counters":[{"col_start":4,"col_end":34,"count":0}]},{"line":"        matches!(self, Transaction::Coinbase(_))","counters":[{"col_start":8,"col_end":16,"count":0},{"col_start":17,"col_end":21,"count":0}]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"    fn is_command(&self) -> bool {","counters":[{"col_start":4,"col_end":33,"count":0}]},{"line":"        matches!(self, Transaction::Command(_))","counters":[{"col_start":8,"col_end":16,"count":0},{"col_start":17,"col_end":21,"count":0}]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"#[derive(Clone, Debug, derive_more::From)]","counters":[{"col_start":9,"col_end":10,"count":0},{"col_start":13,"col_end":14,"count":0},{"col_start":16,"col_end":17,"count":0},{"col_start":20,"col_end":21,"count":0},{"col_start":23,"col_end":40,"count":0}]},{"line":"pub enum Transaction {","counters":[]},{"line":"    Command(UserCommand),","counters":[]},{"line":"    FeeTransfer(FeeTransfer),","counters":[]},{"line":"    Coinbase(Coinbase),","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Transaction {","counters":[]},{"line":"    pub fn fee_excess(&self) -> Result<FeeExcess, String> {","counters":[]},{"line":"        use Transaction::*;","counters":[]},{"line":"        use UserCommand::*;","counters":[]},{"line":"","counters":[]},{"line":"        match self {","counters":[{"col_start":14,"col_end":18,"count":0}]},{"line":"            Command(SignedCommand(cmd)) => Ok(cmd.fee_excess()),","counters":[{"col_start":34,"col_end":63,"count":0}]},{"line":"            Command(ZkAppCommand(cmd)) => Ok(cmd.fee_excess()),","counters":[{"col_start":33,"col_end":62,"count":0}]},{"line":"            FeeTransfer(ft) => ft.fee_excess(),","counters":[{"col_start":24,"col_end":46,"count":0}]},{"line":"            Coinbase(cb) => cb.fee_excess(),","counters":[{"col_start":21,"col_end":43,"count":0}]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/transaction/transaction.ml#L85","counters":[]},{"line":"    pub fn public_keys(&self) -> Vec<CompressedPubKey> {","counters":[{"col_start":4,"col_end":56,"count":0}]},{"line":"        use Transaction::*;","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"        use UserCommand::*;","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"","counters":[]},{"line":"        let to_pks = |ids: Vec<AccountId>| ids.into_iter().map(|id| id.public_key).collect();","counters":[{"col_start":0,"col_end":18,"count":0},{"col_start":43,"col_end":63,"count":0},{"col_start":68,"col_end":81,"count":0},{"col_start":81,"col_end":92,"count":0}]},{"line":"","counters":[]},{"line":"        match self {","counters":[{"col_start":14,"col_end":18,"count":0}]},{"line":"            Command(SignedCommand(cmd)) => [cmd.fee_payer_pk(), cmd.source_pk(), cmd.receiver_pk()]","counters":[{"col_start":34,"col_end":99,"count":0}]},{"line":"                .into_iter()","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"                .cloned()","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"                .collect(),","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"            Command(ZkAppCommand(cmd)) => to_pks(cmd.accounts_referenced()),","counters":[{"col_start":33,"col_end":75,"count":0}]},{"line":"            FeeTransfer(ft) => ft.receiver_pks().cloned().collect(),","counters":[{"col_start":24,"col_end":67,"count":0}]},{"line":"            Coinbase(cb) => to_pks(cb.accounts_accessed()),","counters":[{"col_start":21,"col_end":58,"count":0}]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"pub mod transaction_applied {","counters":[]},{"line":"    use crate::{Account, AccountId};","counters":[]},{"line":"","counters":[]},{"line":"    use super::*;","counters":[]},{"line":"","counters":[]},{"line":"    pub mod signed_command_applied {","counters":[]},{"line":"        use super::*;","counters":[]},{"line":"","counters":[]},{"line":"        #[derive(Debug, Clone)]","counters":[{"col_start":17,"col_end":22,"count":0},{"col_start":24,"col_end":29,"count":0}]},{"line":"        pub struct Common {","counters":[]},{"line":"            pub user_command: WithStatus<signed_command::SignedCommand>,","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        #[derive(Debug, Clone)]","counters":[{"col_start":17,"col_end":18,"count":0},{"col_start":21,"col_end":22,"count":0},{"col_start":24,"col_end":25,"count":0},{"col_start":28,"col_end":29,"count":0}]},{"line":"        pub enum Body {","counters":[]},{"line":"            Payments {","counters":[]},{"line":"                new_accounts: Vec<AccountId>,","counters":[]},{"line":"            },","counters":[]},{"line":"            StakeDelegation {","counters":[]},{"line":"                previous_delegate: Option<CompressedPubKey>,","counters":[]},{"line":"            },","counters":[]},{"line":"            Failed,","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        #[derive(Debug, Clone)]","counters":[{"col_start":17,"col_end":22,"count":0},{"col_start":24,"col_end":29,"count":0}]},{"line":"        pub struct SignedCommandApplied {","counters":[]},{"line":"            pub common: Common,","counters":[]},{"line":"            pub body: Body,","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    pub use signed_command_applied::SignedCommandApplied;","counters":[]},{"line":"","counters":[]},{"line":"    impl SignedCommandApplied {","counters":[]},{"line":"        pub fn new_accounts(&self) -> &[AccountId] {","counters":[{"col_start":8,"col_end":52,"count":0}]},{"line":"            use signed_command_applied::Body::*;","counters":[{"col_start":0,"col_end":48,"count":0}]},{"line":"","counters":[]},{"line":"            match &self.body {","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"                Payments { new_accounts } => new_accounts.as_slice(),","counters":[{"col_start":27,"col_end":68,"count":0}]},{"line":"                StakeDelegation { .. } | Failed => &[],","counters":[{"col_start":51,"col_end":54,"count":0}]},{"line":"            }","counters":[]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/transaction_logic/mina_transaction_logic.ml#L65","counters":[]},{"line":"    #[derive(Debug, Clone)]","counters":[{"col_start":13,"col_end":18,"count":0},{"col_start":20,"col_end":25,"count":0}]},{"line":"    pub struct ZkappCommandApplied {","counters":[]},{"line":"        pub accounts: Vec<(AccountId, Option<Account>)>,","counters":[]},{"line":"        pub command: WithStatus<zkapp_command::ZkAppCommand>,","counters":[]},{"line":"        pub new_accounts: Vec<AccountId>,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/transaction_logic/mina_transaction_logic.ml#L82","counters":[]},{"line":"    #[derive(Debug, Clone)]","counters":[{"col_start":13,"col_end":14,"count":0},{"col_start":17,"col_end":18,"count":0},{"col_start":20,"col_end":21,"count":0},{"col_start":24,"col_end":25,"count":0}]},{"line":"    pub enum CommandApplied {","counters":[]},{"line":"        SignedCommand(Box<SignedCommandApplied>),","counters":[]},{"line":"        ZkappCommand(Box<ZkappCommandApplied>),","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/transaction_logic/mina_transaction_logic.ml#L96","counters":[]},{"line":"    #[derive(Debug, Clone)]","counters":[{"col_start":13,"col_end":18,"count":0},{"col_start":20,"col_end":25,"count":0}]},{"line":"    pub struct FeeTransferApplied {","counters":[]},{"line":"        pub fee_transfer: WithStatus<FeeTransfer>,","counters":[]},{"line":"        pub new_accounts: Vec<AccountId>,","counters":[]},{"line":"        pub burned_tokens: Amount,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/transaction_logic/mina_transaction_logic.ml#L112","counters":[]},{"line":"    #[derive(Debug, Clone)]","counters":[{"col_start":13,"col_end":18,"count":0},{"col_start":20,"col_end":25,"count":0}]},{"line":"    pub struct CoinbaseApplied {","counters":[]},{"line":"        pub coinbase: WithStatus<Coinbase>,","counters":[]},{"line":"        pub new_accounts: Vec<AccountId>,","counters":[]},{"line":"        pub burned_tokens: Amount,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/transaction_logic/mina_transaction_logic.ml#L142","counters":[]},{"line":"    #[derive(Debug, Clone)]","counters":[{"col_start":13,"col_end":14,"count":0},{"col_start":17,"col_end":18,"count":0},{"col_start":20,"col_end":21,"count":0},{"col_start":24,"col_end":25,"count":0}]},{"line":"    pub enum Varying {","counters":[]},{"line":"        Command(CommandApplied),","counters":[]},{"line":"        FeeTransfer(FeeTransferApplied),","counters":[]},{"line":"        Coinbase(CoinbaseApplied),","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/transaction_logic/mina_transaction_logic.ml#L142","counters":[]},{"line":"    #[derive(Debug, Clone)]","counters":[{"col_start":13,"col_end":18,"count":0},{"col_start":20,"col_end":25,"count":0}]},{"line":"    pub struct TransactionApplied {","counters":[]},{"line":"        pub previous_hash: Fp,","counters":[]},{"line":"        pub varying: Varying,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl TransactionApplied {","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/transaction_logic/mina_transaction_logic.ml#L639","counters":[]},{"line":"        pub fn transaction(&self) -> WithStatus<Transaction> {","counters":[]},{"line":"            use CommandApplied::*;","counters":[]},{"line":"            use Varying::*;","counters":[]},{"line":"","counters":[]},{"line":"            match &self.varying {","counters":[{"col_start":18,"col_end":31,"count":0}]},{"line":"                Command(SignedCommand(cmd)) => cmd","counters":[{"col_start":38,"col_end":50,"count":228}]},{"line":"                    .common","counters":[{"col_start":0,"col_end":27,"count":228}]},{"line":"                    .user_command","counters":[{"col_start":0,"col_end":33,"count":228}]},{"line":"                    .map(|c| Transaction::Command(UserCommand::SignedCommand(Box::new(c.clone())))),","counters":[{"col_start":0,"col_end":25,"count":228},{"col_start":29,"col_end":98,"count":0},{"col_start":98,"col_end":99,"count":228}]},{"line":"                Command(ZkappCommand(cmd)) => cmd","counters":[{"col_start":37,"col_end":49,"count":0}]},{"line":"                    .command","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"                    .map(|c| Transaction::Command(UserCommand::ZkAppCommand(Box::new(c.clone())))),","counters":[{"col_start":0,"col_end":25,"count":0},{"col_start":29,"col_end":97,"count":0},{"col_start":97,"col_end":98,"count":0}]},{"line":"                FeeTransfer(f) => f.fee_transfer.map(|f| Transaction::FeeTransfer(f.clone())),","counters":[{"col_start":28,"col_end":53,"count":76},{"col_start":57,"col_end":92,"count":0},{"col_start":92,"col_end":93,"count":76}]},{"line":"                Coinbase(c) => c.coinbase.map(|c| Transaction::Coinbase(c.clone())),","counters":[{"col_start":25,"col_end":46,"count":0},{"col_start":50,"col_end":82,"count":0},{"col_start":82,"col_end":83,"count":0}]},{"line":"            }","counters":[]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":304}]},{"line":"","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/transaction_logic/mina_transaction_logic.ml#L662","counters":[]},{"line":"        pub fn transaction_status(&self) -> &TransactionStatus {","counters":[{"col_start":8,"col_end":63,"count":0}]},{"line":"            use CommandApplied::*;","counters":[]},{"line":"            use Varying::*;","counters":[]},{"line":"","counters":[]},{"line":"            match &self.varying {","counters":[{"col_start":18,"col_end":31,"count":0}]},{"line":"                Command(SignedCommand(cmd)) => &cmd.common.user_command.status,","counters":[{"col_start":38,"col_end":78,"count":0}]},{"line":"                Command(ZkappCommand(cmd)) => &cmd.command.status,","counters":[{"col_start":37,"col_end":65,"count":6}]},{"line":"                FeeTransfer(f) => &f.fee_transfer.status,","counters":[{"col_start":28,"col_end":56,"count":0}]},{"line":"                Coinbase(c) => &c.coinbase.status,","counters":[{"col_start":25,"col_end":49,"count":0}]},{"line":"            }","counters":[]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":6}]},{"line":"","counters":[]},{"line":"        pub fn burned_tokens(&self) -> Amount {","counters":[{"col_start":8,"col_end":47,"count":0}]},{"line":"            match &self.varying {","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"                Varying::Command(_) => Amount::zero(),","counters":[{"col_start":39,"col_end":53,"count":0}]},{"line":"                Varying::FeeTransfer(f) => f.burned_tokens,","counters":[{"col_start":37,"col_end":58,"count":0}]},{"line":"                Varying::Coinbase(c) => c.burned_tokens,","counters":[{"col_start":34,"col_end":55,"count":0}]},{"line":"            }","counters":[]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn new_accounts(&self) -> &[AccountId] {","counters":[{"col_start":8,"col_end":51,"count":0}]},{"line":"            use CommandApplied::*;","counters":[]},{"line":"            use Varying::*;","counters":[]},{"line":"","counters":[]},{"line":"            match &self.varying {","counters":[{"col_start":18,"col_end":31,"count":0}]},{"line":"                Command(SignedCommand(cmd)) => cmd.new_accounts(),","counters":[{"col_start":38,"col_end":65,"count":0}]},{"line":"                Command(ZkappCommand(cmd)) => cmd.new_accounts.as_slice(),","counters":[{"col_start":37,"col_end":73,"count":0}]},{"line":"                FeeTransfer(f) => f.new_accounts.as_slice(),","counters":[{"col_start":28,"col_end":59,"count":0}]},{"line":"                Coinbase(cb) => cb.new_accounts.as_slice(),","counters":[{"col_start":25,"col_end":58,"count":0}]},{"line":"            }","counters":[]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/e5183ca1dde1c085b4c5d37d1d9987e24c294c32/src/lib/transaction_logic/mina_transaction_logic.ml#L176","counters":[]},{"line":"        pub fn supply_increase(","counters":[{"col_start":8,"col_end":31,"count":2}]},{"line":"            &self,","counters":[{"col_start":0,"col_end":18,"count":2}]},{"line":"            constraint_constants: &ConstraintConstants,","counters":[{"col_start":0,"col_end":55,"count":2}]},{"line":"        ) -> Result<Signed<Amount>, String> {","counters":[{"col_start":0,"col_end":45,"count":2}]},{"line":"            let burned_tokens = Signed::<Amount>::of_unsigned(self.burned_tokens());","counters":[{"col_start":0,"col_end":84,"count":2}]},{"line":"","counters":[]},{"line":"            let account_creation_fees = {","counters":[{"col_start":0,"col_end":41,"count":2}]},{"line":"                let account_creation_fee_int = constraint_constants.account_creation_fee.as_u64();","counters":[{"col_start":0,"col_end":98,"count":2}]},{"line":"                let num_accounts_created = self.new_accounts().len() as u64;","counters":[{"col_start":0,"col_end":76,"count":2}]},{"line":"","counters":[]},{"line":"                // int type is OK, no danger of overflow","counters":[{"col_start":0,"col_end":56,"count":2}]},{"line":"                let amount = account_creation_fee_int","counters":[{"col_start":0,"col_end":53,"count":2}]},{"line":"                    .checked_mul(num_accounts_created)","counters":[{"col_start":0,"col_end":54,"count":2}]},{"line":"                    .unwrap();","counters":[{"col_start":0,"col_end":30,"count":2}]},{"line":"                Signed::<Amount>::of_unsigned(Amount::from_u64(amount))","counters":[{"col_start":0,"col_end":71,"count":2}]},{"line":"            };","counters":[]},{"line":"","counters":[]},{"line":"            let expected_supply_increase = match &self.varying {","counters":[{"col_start":16,"col_end":40,"count":1},{"col_start":49,"col_end":62,"count":2}]},{"line":"                Varying::Coinbase(cb) => cb.coinbase.data.expected_supply_increase()?,","counters":[{"col_start":34,"col_end":84,"count":2},{"col_start":84,"col_end":85,"count":0}]},{"line":"                _ => Amount::zero(),","counters":[{"col_start":21,"col_end":35,"count":0}]},{"line":"            };","counters":[]},{"line":"            let expected_supply_increase = Signed::<Amount>::of_unsigned(expected_supply_increase);","counters":[{"col_start":16,"col_end":99,"count":1}]},{"line":"","counters":[]},{"line":"            // TODO: Make sure it's correct","counters":[{"col_start":0,"col_end":43,"count":1}]},{"line":"            let total = [burned_tokens, account_creation_fees]","counters":[{"col_start":0,"col_end":62,"count":1}]},{"line":"                .into_iter()","counters":[{"col_start":0,"col_end":28,"count":1}]},{"line":"                .fold(Some(expected_supply_increase), |total, amt| {","counters":[{"col_start":0,"col_end":54,"count":1},{"col_start":67,"col_end":68,"count":0}]},{"line":"                    amt.negate().add(&total?)","counters":[{"col_start":0,"col_end":43,"count":0},{"col_start":43,"col_end":44,"count":12}]},{"line":"                });","counters":[{"col_start":16,"col_end":17,"count":0},{"col_start":17,"col_end":19,"count":1}]},{"line":"","counters":[]},{"line":"            total.ok_or_else(|| \"overflow\".to_string())","counters":[{"col_start":0,"col_end":29,"count":1},{"col_start":32,"col_end":54,"count":0},{"col_start":54,"col_end":55,"count":1}]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":1}]},{"line":"    }","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"pub mod transaction_witness {","counters":[]},{"line":"    use mina_p2p_messages::v2::MinaStateProtocolStateBodyValueStableV2;","counters":[]},{"line":"","counters":[]},{"line":"    use crate::scan_state::pending_coinbase::Stack;","counters":[]},{"line":"","counters":[]},{"line":"    use super::*;","counters":[]},{"line":"","counters":[]},{"line":"    #[derive(Debug)]","counters":[{"col_start":13,"col_end":18,"count":0}]},{"line":"    pub struct TransactionWitness {","counters":[]},{"line":"        pub transaction: Transaction,","counters":[]},{"line":"        pub ledger: SparseLedger<AccountId, Account>,","counters":[]},{"line":"        pub protocol_state_body: MinaStateProtocolStateBodyValueStableV2,","counters":[]},{"line":"        pub init_stack: Stack,","counters":[]},{"line":"        pub status: TransactionStatus,","counters":[]},{"line":"    }","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"pub mod protocol_state {","counters":[]},{"line":"    use mina_p2p_messages::v2::MinaStateProtocolStateValueStableV2;","counters":[]},{"line":"","counters":[]},{"line":"    use super::*;","counters":[]},{"line":"","counters":[]},{"line":"    #[derive(Debug, Clone)]","counters":[{"col_start":13,"col_end":18,"count":0},{"col_start":20,"col_end":25,"count":0}]},{"line":"    pub struct EpochLedger {","counters":[]},{"line":"        pub hash: Fp,","counters":[]},{"line":"        pub total_currency: Amount,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    #[derive(Debug, Clone)]","counters":[{"col_start":13,"col_end":18,"count":0},{"col_start":20,"col_end":25,"count":0}]},{"line":"    pub struct EpochData {","counters":[]},{"line":"        pub ledger: EpochLedger,","counters":[]},{"line":"        pub seed: Fp,","counters":[]},{"line":"        pub start_checkpoint: Fp,","counters":[]},{"line":"        pub lock_checkpoint: Fp,","counters":[]},{"line":"        pub epoch_length: Length,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    #[derive(Debug, Clone)]","counters":[{"col_start":13,"col_end":18,"count":0},{"col_start":20,"col_end":25,"count":0}]},{"line":"    pub struct ProtocolStateView {","counters":[]},{"line":"        pub snarked_ledger_hash: Fp,","counters":[]},{"line":"        pub timestamp: BlockTime,","counters":[]},{"line":"        pub blockchain_length: Length,","counters":[]},{"line":"        pub min_window_density: Length,","counters":[]},{"line":"        pub last_vrf_output: (), // It's not defined in OCAml","counters":[]},{"line":"        pub total_currency: Amount,","counters":[]},{"line":"        pub global_slot_since_hard_fork: Slot,","counters":[]},{"line":"        pub global_slot_since_genesis: Slot,","counters":[]},{"line":"        pub staking_epoch_data: EpochData,","counters":[]},{"line":"        pub next_epoch_data: EpochData,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    pub fn protocol_state_view(state: &MinaStateProtocolStateValueStableV2) -> ProtocolStateView {","counters":[{"col_start":4,"col_end":98,"count":0}]},{"line":"        let cs = &state.body.consensus_state;","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"        let sed = &cs.staking_epoch_data;","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"        let ned = &cs.staking_epoch_data;","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"","counters":[]},{"line":"        ProtocolStateView {","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"            snarked_ledger_hash: state.body.blockchain_state.registers.ledger.to_field(),","counters":[{"col_start":0,"col_end":89,"count":0}]},{"line":"            timestamp: BlockTime(state.body.blockchain_state.timestamp.as_u64()),","counters":[{"col_start":0,"col_end":81,"count":0}]},{"line":"            blockchain_length: Length(cs.blockchain_length.as_u32()),","counters":[{"col_start":0,"col_end":69,"count":0}]},{"line":"            min_window_density: Length(cs.min_window_density.as_u32()),","counters":[{"col_start":0,"col_end":71,"count":0}]},{"line":"            last_vrf_output: (),","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"            total_currency: Amount(cs.total_currency.as_u64()),","counters":[{"col_start":0,"col_end":63,"count":0}]},{"line":"            global_slot_since_hard_fork: Slot(cs.curr_global_slot.slot_number.as_u32()), // TODO: Check if it's correct","counters":[{"col_start":0,"col_end":119,"count":0}]},{"line":"            global_slot_since_genesis: Slot(cs.global_slot_since_genesis.as_u32()),","counters":[{"col_start":0,"col_end":83,"count":0}]},{"line":"            staking_epoch_data: EpochData {","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"                ledger: EpochLedger {","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"                    hash: sed.ledger.hash.to_field(),","counters":[{"col_start":0,"col_end":53,"count":0}]},{"line":"                    total_currency: Amount(sed.ledger.total_currency.as_u64()),","counters":[{"col_start":0,"col_end":79,"count":0}]},{"line":"                },","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"                seed: sed.seed.to_field(),","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"                start_checkpoint: sed.start_checkpoint.to_field(),","counters":[{"col_start":0,"col_end":66,"count":0}]},{"line":"                lock_checkpoint: sed.lock_checkpoint.to_field(),","counters":[{"col_start":0,"col_end":64,"count":0}]},{"line":"                epoch_length: Length(sed.epoch_length.as_u32()),","counters":[{"col_start":0,"col_end":64,"count":0}]},{"line":"            },","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"            next_epoch_data: EpochData {","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"                ledger: EpochLedger {","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"                    hash: ned.ledger.hash.to_field(),","counters":[{"col_start":0,"col_end":53,"count":0}]},{"line":"                    total_currency: Amount(ned.ledger.total_currency.as_u64()),","counters":[{"col_start":0,"col_end":79,"count":0}]},{"line":"                },","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"                seed: ned.seed.to_field(),","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"                start_checkpoint: ned.start_checkpoint.to_field(),","counters":[{"col_start":0,"col_end":66,"count":0}]},{"line":"                lock_checkpoint: ned.lock_checkpoint.to_field(),","counters":[{"col_start":0,"col_end":64,"count":0}]},{"line":"                epoch_length: Length(ned.epoch_length.as_u32()),","counters":[{"col_start":0,"col_end":64,"count":0}]},{"line":"            },","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    #[derive(Clone)]","counters":[{"col_start":13,"col_end":18,"count":0}]},{"line":"    pub struct GlobalState<L: LedgerIntf + Clone> {","counters":[]},{"line":"        pub ledger: L,","counters":[]},{"line":"        pub fee_excess: Signed<Fee>,","counters":[]},{"line":"        pub protocol_state: ProtocolStateView,","counters":[]},{"line":"    }","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"pub mod local_state {","counters":[]},{"line":"    use ark_ff::Zero;","counters":[]},{"line":"","counters":[]},{"line":"    use crate::{","counters":[]},{"line":"        hash_with_kimchi,","counters":[]},{"line":"        scan_state::currency::{Index, Signed},","counters":[]},{"line":"        Inputs,","counters":[]},{"line":"    };","counters":[]},{"line":"","counters":[]},{"line":"    use super::{zkapp_command::CallForest, *};","counters":[]},{"line":"","counters":[]},{"line":"    #[derive(Clone)]","counters":[{"col_start":13,"col_end":18,"count":0}]},{"line":"    pub struct StackFrame {","counters":[]},{"line":"        pub caller: TokenId,","counters":[]},{"line":"        pub caller_caller: TokenId,","counters":[]},{"line":"        pub calls: CallForest<AccountUpdate>, // TODO","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl Default for StackFrame {","counters":[]},{"line":"        fn default() -> Self {","counters":[{"col_start":8,"col_end":30,"count":0}]},{"line":"            StackFrame {","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"                caller: TokenId::default(),","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"                caller_caller: TokenId::default(),","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"                calls: CallForest::new(),","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl StackFrame {","counters":[]},{"line":"        pub fn empty() -> Self {","counters":[{"col_start":8,"col_end":32,"count":0}]},{"line":"            Self {","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"                caller: TokenId::default(),","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"                caller_caller: TokenId::default(),","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"                calls: CallForest(Vec::new()),","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        /// TODO: this needs to be tested","counters":[]},{"line":"        ///","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/mina_base/stack_frame.ml#L90","counters":[]},{"line":"        pub fn hash(&self) -> Fp {","counters":[{"col_start":8,"col_end":34,"count":0}]},{"line":"            let mut inputs = Inputs::new();","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"","counters":[]},{"line":"            inputs.append_field(self.caller.0);","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"            inputs.append_field(self.caller_caller.0);","counters":[{"col_start":0,"col_end":53,"count":0}]},{"line":"","counters":[]},{"line":"            let field = match self.calls.0.get(0) {","counters":[{"col_start":16,"col_end":21,"count":0},{"col_start":30,"col_end":49,"count":0}]},{"line":"                None => Fp::zero(),","counters":[{"col_start":24,"col_end":34,"count":0}]},{"line":"                Some(call) => call.stack_hash,","counters":[{"col_start":21,"col_end":45,"count":0}]},{"line":"            };","counters":[]},{"line":"            inputs.append_field(field);","counters":[{"col_start":12,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"            hash_with_kimchi(\"MinaAcctUpdStckFrm\", &inputs.to_fields())","counters":[{"col_start":0,"col_end":71,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    #[derive(Clone)]","counters":[{"col_start":13,"col_end":18,"count":0}]},{"line":"    pub struct CallStack(Vec<StackFrame>);","counters":[]},{"line":"","counters":[]},{"line":"    impl CallStack {","counters":[]},{"line":"        pub fn new() -> Self {","counters":[{"col_start":8,"col_end":30,"count":0}]},{"line":"            CallStack(Vec::new())","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn is_empty(&self) -> bool {","counters":[{"col_start":8,"col_end":40,"count":0}]},{"line":"            self.0.is_empty()","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn iter(&self) -> impl Iterator<Item = &StackFrame> {","counters":[{"col_start":8,"col_end":65,"count":0}]},{"line":"            self.0.iter().rev()","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn push(&self, stack_frame: &StackFrame) -> Self {","counters":[{"col_start":8,"col_end":62,"count":0}]},{"line":"            let mut ret = self.0.clone();","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"            ret.push(stack_frame.clone());","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"            Self(ret)","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn pop(&self) -> Option<(StackFrame, CallStack)> {","counters":[{"col_start":8,"col_end":62,"count":0}]},{"line":"            let mut ret = self.0.clone();","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"            if let Some(frame) = ret.pop() {","counters":[{"col_start":24,"col_end":29,"count":0},{"col_start":33,"col_end":42,"count":0}]},{"line":"                Some((frame, Self(ret)))","counters":[{"col_start":16,"col_end":40,"count":0}]},{"line":"            } else {","counters":[]},{"line":"                None","counters":[{"col_start":16,"col_end":20,"count":0}]},{"line":"            }","counters":[]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn pop_exn(&self) -> (StackFrame, CallStack) {","counters":[{"col_start":8,"col_end":58,"count":0}]},{"line":"            let mut ret = self.0.clone();","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"            if let Some(frame) = ret.pop() {","counters":[{"col_start":24,"col_end":29,"count":0},{"col_start":33,"col_end":42,"count":0}]},{"line":"                (frame, Self(ret))","counters":[{"col_start":16,"col_end":34,"count":0}]},{"line":"            } else {","counters":[]},{"line":"                panic!()","counters":[{"col_start":16,"col_end":24,"count":0}]},{"line":"            }","counters":[]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// NOTE: It looks like there are different instances of the polymorphic LocalEnv type","counters":[]},{"line":"    /// One with concrete types for the stack frame, call stack, and ledger. Created from the Env","counters":[]},{"line":"    /// And the other with their hashes. To differentiate them I renamed the first LocalStateEnv","counters":[]},{"line":"    /// Maybe a better solution is to keep the LocalState name and put it under a different module","counters":[]},{"line":"    #[derive(Clone)]","counters":[{"col_start":13,"col_end":18,"count":0}]},{"line":"    pub struct LocalStateEnv<L: LedgerIntf + Clone> {","counters":[]},{"line":"        pub stack_frame: StackFrame,","counters":[]},{"line":"        pub call_stack: CallStack,","counters":[]},{"line":"        pub transaction_commitment: ReceiptChainHash,","counters":[]},{"line":"        pub full_transaction_commitment: ReceiptChainHash,","counters":[]},{"line":"        pub token_id: TokenId,","counters":[]},{"line":"        pub excess: Signed<Fee>,","counters":[]},{"line":"        pub ledger: L,","counters":[]},{"line":"        pub success: bool,","counters":[]},{"line":"        pub account_update_index: Index,","counters":[]},{"line":"        // TODO: optimize by reversing the insertion order","counters":[]},{"line":"        pub failure_status_tbl: Vec<Vec<TransactionFailure>>,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl<L: LedgerIntf + Clone> LocalStateEnv<L> {","counters":[]},{"line":"        pub fn add_new_failure_status_bucket(&self) -> Self {","counters":[{"col_start":8,"col_end":61,"count":0}]},{"line":"            let mut failure_status_tbl = self.failure_status_tbl.clone();","counters":[{"col_start":0,"col_end":73,"count":0}]},{"line":"            failure_status_tbl.insert(0, Vec::new());","counters":[{"col_start":0,"col_end":53,"count":0}]},{"line":"            Self {","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"                failure_status_tbl,","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"                ..self.clone()","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn add_check(&self, failure: TransactionFailure, b: bool) -> Self {","counters":[{"col_start":8,"col_end":78,"count":0}]},{"line":"            let failure_status_tbl = if let false = b {","counters":[{"col_start":16,"col_end":34,"count":0},{"col_start":52,"col_end":53,"count":0}]},{"line":"                let mut failure_status_tbl = self.failure_status_tbl.clone();","counters":[{"col_start":20,"col_end":77,"count":0}]},{"line":"                failure_status_tbl[0].insert(0, failure);","counters":[{"col_start":0,"col_end":57,"count":0}]},{"line":"                failure_status_tbl","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"            } else {","counters":[]},{"line":"                self.failure_status_tbl.clone()","counters":[{"col_start":16,"col_end":47,"count":0}]},{"line":"            };","counters":[]},{"line":"","counters":[]},{"line":"            Self {","counters":[]},{"line":"                failure_status_tbl,","counters":[{"col_start":16,"col_end":35,"count":0}]},{"line":"                success: self.success && b,","counters":[{"col_start":0,"col_end":37,"count":0},{"col_start":41,"col_end":42,"count":0}]},{"line":"                ..self.clone()","counters":[{"col_start":18,"col_end":30,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    #[derive(Debug, Clone, PartialEq, Eq)]","counters":[{"col_start":13,"col_end":18,"count":0},{"col_start":20,"col_end":25,"count":0},{"col_start":27,"col_end":28,"count":0},{"col_start":35,"col_end":36,"count":0}]},{"line":"    pub struct LocalState {","counters":[]},{"line":"        pub stack_frame: Fp,","counters":[]},{"line":"        pub call_stack: Fp,","counters":[]},{"line":"        pub transaction_commitment: Fp,","counters":[]},{"line":"        pub full_transaction_commitment: Fp,","counters":[]},{"line":"        pub token_id: TokenId,","counters":[]},{"line":"        pub excess: Signed<Amount>,","counters":[]},{"line":"        pub supply_increase: Signed<Amount>,","counters":[]},{"line":"        pub ledger: Fp,","counters":[]},{"line":"        pub success: bool,","counters":[]},{"line":"        pub account_update_index: Index,","counters":[]},{"line":"        pub failure_status_tbl: Vec<Vec<TransactionFailure>>,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl LocalState {","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/mina_state/local_state.ml#L63","counters":[]},{"line":"        pub fn dummy() -> Self {","counters":[{"col_start":8,"col_end":32,"count":0}]},{"line":"            Self {","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"                stack_frame: StackFrame::empty().hash(),","counters":[{"col_start":0,"col_end":56,"count":0}]},{"line":"                call_stack: Fp::zero(),","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"                transaction_commitment: Fp::zero(),","counters":[{"col_start":0,"col_end":51,"count":0}]},{"line":"                full_transaction_commitment: Fp::zero(),","counters":[{"col_start":0,"col_end":56,"count":0}]},{"line":"                token_id: TokenId::default(),","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"                excess: Signed::<Amount>::zero(),","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"                supply_increase: Signed::<Amount>::zero(),","counters":[{"col_start":0,"col_end":58,"count":0}]},{"line":"                ledger: Fp::zero(),","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"                success: true,","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"                account_update_index: Index::zero(),","counters":[{"col_start":0,"col_end":52,"count":0}]},{"line":"                failure_status_tbl: Vec::new(),","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn empty() -> Self {","counters":[{"col_start":8,"col_end":32,"count":0}]},{"line":"            Self::dummy()","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"pub enum Eff<L: LedgerIntf + Clone> {","counters":[]},{"line":"    CheckAccountPrecondition(AccountUpdate, Account, bool, LocalStateEnv<L>),","counters":[]},{"line":"    CheckProtocolStatePrecondition(ZkAppPreconditions, GlobalState<L>),","counters":[]},{"line":"    InitAccount(AccountUpdate, Account),","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"pub struct Env<L: LedgerIntf + Clone> {","counters":[]},{"line":"    account_update: AccountUpdate,","counters":[]},{"line":"    zkapp_command: ZkAppCommand,","counters":[]},{"line":"    account: Account,","counters":[]},{"line":"    ledger: L,","counters":[]},{"line":"    amount: Amount,","counters":[]},{"line":"    signed_amount: Signed<Amount>,","counters":[]},{"line":"    bool: bool,","counters":[]},{"line":"    token_id: TokenId,","counters":[]},{"line":"    global_state: GlobalState<L>,","counters":[]},{"line":"    local_state: LocalStateEnv<L>,","counters":[]},{"line":"    protocol_state_precondition: ZkAppPreconditions,","counters":[]},{"line":"    transaction_commitment: Fp,","counters":[]},{"line":"    full_transaction_commitment: Fp,","counters":[]},{"line":"    field: Fp,","counters":[]},{"line":"    failure: Option<TransactionFailure>,","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"pub enum PerformResult<L: LedgerIntf + Clone> {","counters":[]},{"line":"    Bool(bool),","counters":[]},{"line":"    LocalState(LocalStateEnv<L>),","counters":[]},{"line":"    Account(Account),","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl<L> Env<L>","counters":[]},{"line":"where","counters":[]},{"line":"    L: LedgerIntf + Clone,","counters":[]},{"line":"{","counters":[]},{"line":"    pub fn perform(eff: Eff<L>) -> PerformResult<L> {","counters":[{"col_start":4,"col_end":53,"count":1}]},{"line":"        match eff {","counters":[{"col_start":0,"col_end":17,"count":1}]},{"line":"            Eff::CheckProtocolStatePrecondition(pred, global_state) => {","counters":[{"col_start":48,"col_end":72,"count":0}]},{"line":"                PerformResult::Bool(pred.check(global_state.protocol_state).is_ok())","counters":[{"col_start":0,"col_end":84,"count":0}]},{"line":"            }","counters":[]},{"line":"            Eff::CheckAccountPrecondition(account_update, account, new_account, local_state) => {","counters":[{"col_start":42,"col_end":91,"count":0}]},{"line":"                let local_state = match account_update.body.preconditions.account {","counters":[{"col_start":20,"col_end":31,"count":0},{"col_start":40,"col_end":81,"count":0}]},{"line":"                    AccountPreconditions::Accept => local_state,","counters":[{"col_start":52,"col_end":63,"count":0}]},{"line":"                    AccountPreconditions::Nonce(n) => local_state.add_check(","counters":[{"col_start":48,"col_end":76,"count":0}]},{"line":"                        TransactionFailure::AccountNoncePreconditionUnsatisfied,","counters":[{"col_start":0,"col_end":80,"count":0}]},{"line":"                        account.nonce == n,","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"                    ),","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"                    AccountPreconditions::Full(precondition_account) => {","counters":[{"col_start":47,"col_end":73,"count":0}]},{"line":"                        let mut _local_state = local_state;","counters":[{"col_start":0,"col_end":59,"count":0}]},{"line":"                        let check = |failure, b| {","counters":[{"col_start":0,"col_end":36,"count":0},{"col_start":49,"col_end":50,"count":0}]},{"line":"                            _local_state = _local_state.add_check(failure, b);","counters":[{"col_start":0,"col_end":78,"count":0}]},{"line":"                        };","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"                        precondition_account.check(new_account, check, account);","counters":[{"col_start":24,"col_end":80,"count":0}]},{"line":"                        _local_state","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"                    }","counters":[]},{"line":"                };","counters":[]},{"line":"                PerformResult::LocalState(local_state)","counters":[{"col_start":16,"col_end":54,"count":0}]},{"line":"            }","counters":[]},{"line":"            Eff::InitAccount(_account_update, a) => PerformResult::Account(a),","counters":[{"col_start":29,"col_end":77,"count":2}]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":2}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"fn step_all<L>(","counters":[{"col_start":0,"col_end":15,"count":0}]},{"line":"    constraint_constants: &ConstraintConstants,","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"    f: fn(","counters":[{"col_start":0,"col_end":10,"count":0}]},{"line":"        Option<(LocalStateEnv<L>, Signed<Fee>)>,","counters":[{"col_start":0,"col_end":48,"count":0}]},{"line":"        (GlobalState<L>, LocalStateEnv<L>),","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"    ) -> Option<(LocalStateEnv<L>, Signed<Fee>)>,","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"    h: fn(Eff<L>) -> PerformResult<L>,","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"    user_acc: Option<(LocalStateEnv<L>, Signed<Fee>)>,","counters":[{"col_start":0,"col_end":54,"count":0}]},{"line":"    (g_state, l_state): (GlobalState<L>, LocalStateEnv<L>),","counters":[{"col_start":0,"col_end":59,"count":0}]},{"line":") -> Result<","counters":[{"col_start":0,"col_end":12,"count":0}]},{"line":"    (","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"        Option<(LocalStateEnv<L>, Signed<Fee>)>,","counters":[{"col_start":0,"col_end":48,"count":0}]},{"line":"        Vec<Vec<TransactionFailure>>,","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"    ),","counters":[{"col_start":0,"col_end":6,"count":0}]},{"line":"    String,","counters":[{"col_start":0,"col_end":11,"count":0}]},{"line":">","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"where","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"    L: LedgerIntf + Clone,","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"{","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"    if l_state.stack_frame.calls.is_empty() {","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"        Ok((user_acc, l_state.failure_status_tbl))","counters":[{"col_start":8,"col_end":50,"count":0}]},{"line":"    } else {","counters":[]},{"line":"        let states = apply(","counters":[{"col_start":12,"col_end":18,"count":7},{"col_start":21,"col_end":27,"count":0}]},{"line":"            constraint_constants,","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"            IsStart::No,","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"            Handler { perform: h },","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"            (g_state, l_state),","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"        )?;","counters":[{"col_start":0,"col_end":9,"count":0},{"col_start":9,"col_end":10,"count":0}]},{"line":"        step_all(","counters":[{"col_start":8,"col_end":17,"count":7}]},{"line":"            constraint_constants,","counters":[{"col_start":0,"col_end":33,"count":7}]},{"line":"            f,","counters":[{"col_start":0,"col_end":14,"count":7}]},{"line":"            h,","counters":[{"col_start":0,"col_end":14,"count":7}]},{"line":"            f(user_acc, states.clone()),","counters":[{"col_start":0,"col_end":40,"count":7}]},{"line":"            states,","counters":[{"col_start":0,"col_end":19,"count":7}]},{"line":"        )","counters":[{"col_start":0,"col_end":9,"count":7}]},{"line":"    }","counters":[]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":7}]},{"line":"","counters":[]},{"line":"fn apply_zkapp_command_unchecked<L>(","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"    constraint_constants: &ConstraintConstants,","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"    state_view: &ProtocolStateView,","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"    ledger: &mut L,","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"    c: &ZkAppCommand,","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":") -> Result<(ZkappCommandApplied, (LocalStateEnv<L>, Signed<Fee>)), String>","counters":[{"col_start":0,"col_end":75,"count":0}]},{"line":"where","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"    L: LedgerIntf + Clone,","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"{","counters":[{"col_start":0,"col_end":0,"count":0},{"col_start":0,"col_end":0,"count":0},{"col_start":0,"col_end":0,"count":0}]},{"line":"    let (account_update_applied, state_res) = apply_zkapp_command_unchecked_aux(","counters":[{"col_start":9,"col_end":42,"count":0},{"col_start":46,"col_end":80,"count":0}]},{"line":"        constraint_constants,","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"        state_view,","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"        None,","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        |_acc, (global_state, local_state)| Some((local_state, global_state.fee_excess)),","counters":[{"col_start":0,"col_end":8,"count":0},{"col_start":44,"col_end":88,"count":0},{"col_start":88,"col_end":89,"count":0}]},{"line":"        None,","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        ledger,","counters":[{"col_start":0,"col_end":15,"count":0}]},{"line":"        c,","counters":[{"col_start":0,"col_end":10,"count":0}]},{"line":"    )?;","counters":[{"col_start":0,"col_end":5,"count":0},{"col_start":5,"col_end":6,"count":2}]},{"line":"","counters":[]},{"line":"    Ok((account_update_applied, state_res.unwrap()))","counters":[{"col_start":4,"col_end":52,"count":0}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"fn apply_zkapp_command_unchecked_aux<L>(","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"    constraint_constants: &ConstraintConstants,","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"    state_view: &ProtocolStateView,","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"    init: Option<(LocalStateEnv<L>, Signed<Fee>)>,","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"    f: fn(","counters":[{"col_start":0,"col_end":10,"count":0}]},{"line":"        Option<(LocalStateEnv<L>, Signed<Fee>)>,","counters":[{"col_start":0,"col_end":48,"count":0}]},{"line":"        (GlobalState<L>, LocalStateEnv<L>),","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"    ) -> Option<(LocalStateEnv<L>, Signed<Fee>)>,","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"    fee_excess: Option<Signed<Fee>>,","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"    ledger: &mut L,","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"    c: &ZkAppCommand,","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":") -> Result<(ZkappCommandApplied, Option<(LocalStateEnv<L>, Signed<Fee>)>), String>","counters":[{"col_start":0,"col_end":83,"count":0}]},{"line":"where","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"    L: LedgerIntf + Clone,","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"{","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"    let fee_excess = fee_excess.unwrap_or_else(Signed::<Fee>::zero);","counters":[{"col_start":0,"col_end":68,"count":0}]},{"line":"    let perform = |eff| Env::perform(eff);","counters":[{"col_start":0,"col_end":15,"count":0},{"col_start":24,"col_end":41,"count":0}]},{"line":"    let accounts_accessed = c.accounts_accessed(TransactionStatus::Applied);","counters":[{"col_start":8,"col_end":76,"count":0}]},{"line":"    let original_account_states: Vec<(AccountId, Option<(L::Location, Account)>)> =","counters":[{"col_start":0,"col_end":83,"count":0}]},{"line":"        accounts_accessed","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"            .iter()","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"            .map(|id| {","counters":[{"col_start":0,"col_end":17,"count":0},{"col_start":22,"col_end":23,"count":0}]},{"line":"                (id.clone(), {","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"                    //println!(","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"                    //    \"apply_zkapp_command_unchecked_aux -> location_of_account {:?}\",","counters":[{"col_start":0,"col_end":90,"count":0}]},{"line":"                    //    id","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"                    //);","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"                    let loc = ledger.location_of_account(id);","counters":[{"col_start":0,"col_end":61,"count":0}]},{"line":"                    //println!(","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"                    //    \"apply_zkapp_command_unchecked_aux merkle root {:?}\",","counters":[{"col_start":0,"col_end":79,"count":0}]},{"line":"                    //    ledger.merkle_root()","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"                    //);","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"                    //println!(\"apply_zkapp_command_unchecked_aux -> get {:?}\", loc);","counters":[{"col_start":0,"col_end":85,"count":0}]},{"line":"                    let account = loc.as_ref().and_then(|loc| ledger.get(loc));","counters":[{"col_start":0,"col_end":56,"count":0},{"col_start":62,"col_end":77,"count":0},{"col_start":77,"col_end":79,"count":0}]},{"line":"                    //println!(","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"                    //    \"apply_zkapp_command_unchecked_aux merkle root {:?}\",","counters":[{"col_start":0,"col_end":79,"count":0}]},{"line":"                    //    ledger.merkle_root()","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"                    //);","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"                    loc.zip(account)","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"                })","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"            })","counters":[{"col_start":0,"col_end":13,"count":0},{"col_start":13,"col_end":14,"count":0}]},{"line":"            .collect();","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"    //println!(\">> original_account_states {:?}\", original_account_states);","counters":[{"col_start":0,"col_end":75,"count":0}]},{"line":"    let initial_state = (","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"        GlobalState {","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"            ledger: ledger.clone(),","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"            fee_excess,","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"            protocol_state: state_view.clone(),","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"        },","counters":[{"col_start":0,"col_end":10,"count":0}]},{"line":"        LocalStateEnv {","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"            stack_frame: StackFrame::default(),","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"            call_stack: CallStack::new(),","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"            transaction_commitment: ReceiptChainHash(Fp::zero()),","counters":[{"col_start":0,"col_end":65,"count":0}]},{"line":"            full_transaction_commitment: ReceiptChainHash(Fp::zero()),","counters":[{"col_start":0,"col_end":70,"count":0}]},{"line":"            token_id: TokenId::default(),","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"            excess: Signed::<Fee>::zero(),","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"            ledger: ledger.clone(),","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"            success: true,","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"            account_update_index: Index::zero(),","counters":[{"col_start":0,"col_end":48,"count":0}]},{"line":"            failure_status_tbl: Vec::new(),","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"        },","counters":[{"col_start":0,"col_end":10,"count":0}]},{"line":"    );","counters":[{"col_start":0,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let user_acc = f(init, initial_state.clone());","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"    let start = {","counters":[{"col_start":8,"col_end":13,"count":0}]},{"line":"        let zkapp_command = c","counters":[{"col_start":12,"col_end":29,"count":0}]},{"line":"            .account_updates","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"            .cons(None, AccountUpdate::of_fee_payer(c.fee_payer.clone()));","counters":[{"col_start":0,"col_end":74,"count":0}]},{"line":"","counters":[]},{"line":"        apply(","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"            constraint_constants,","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"            IsStart::Yes(StartData {","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"                zkapp_command,","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"                memo_hash: c.memo.hash(),","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"            }),","counters":[{"col_start":0,"col_end":15,"count":0}]},{"line":"            Handler { perform },","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"            initial_state,","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"        )?","counters":[{"col_start":0,"col_end":9,"count":0},{"col_start":9,"col_end":10,"count":0}]},{"line":"    };","counters":[]},{"line":"","counters":[]},{"line":"    let accounts_accessed = c.accounts_accessed(TransactionStatus::Applied);","counters":[{"col_start":8,"col_end":76,"count":0}]},{"line":"    //println!(\">> accounts_accessed {:?}\", accounts_accessed);","counters":[{"col_start":0,"col_end":63,"count":0}]},{"line":"","counters":[]},{"line":"    let account_states_after_fee_payer: Vec<(AccountId, Option<(L::Location, Account)>)> =","counters":[{"col_start":0,"col_end":90,"count":0}]},{"line":"        accounts_accessed","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"            .iter()","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"            .map(|id| {","counters":[{"col_start":0,"col_end":17,"count":0},{"col_start":22,"col_end":23,"count":0}]},{"line":"                //println!(","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"                //    \"apply_zkapp_command_unchecked_aux 2 -> location_of_account {:?}\",","counters":[{"col_start":0,"col_end":88,"count":0}]},{"line":"                //    id","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"                //);","counters":[{"col_start":0,"col_end":20,"count":0}]},{"line":"                let loc = ledger.location_of_account(id);","counters":[{"col_start":0,"col_end":57,"count":0}]},{"line":"                //println!(","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"                //    \"apply_zkapp_command_unchecked_aux merkle root {:?}\",","counters":[{"col_start":0,"col_end":75,"count":0}]},{"line":"                //    ledger.merkle_root()","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"                //);","counters":[{"col_start":0,"col_end":20,"count":0}]},{"line":"                //println!(\"apply_zkapp_command_unchecked_aux 2 -> get {:?}\", loc);","counters":[{"col_start":0,"col_end":83,"count":0}]},{"line":"                let a = loc.as_ref().and_then(|loc| ledger.get(loc));","counters":[{"col_start":0,"col_end":46,"count":0},{"col_start":52,"col_end":67,"count":0},{"col_start":67,"col_end":69,"count":0}]},{"line":"                //println!(","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"                //    \"apply_zkapp_command_unchecked_aux merkle root {:?}\",","counters":[{"col_start":0,"col_end":75,"count":0}]},{"line":"                //    ledger.merkle_root()","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"                //);","counters":[{"col_start":0,"col_end":20,"count":0}]},{"line":"                match a {","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"                    Some(a) => (id.clone(), Some((loc.unwrap(), a))),","counters":[{"col_start":25,"col_end":68,"count":0}]},{"line":"                    None => (id.clone(), None),","counters":[{"col_start":28,"col_end":46,"count":0}]},{"line":"                }","counters":[]},{"line":"            })","counters":[{"col_start":12,"col_end":13,"count":0},{"col_start":13,"col_end":14,"count":0}]},{"line":"            .collect();","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"    //println!(\">> account_states_after_fee_payer {:?}\", account_states_after_fee_payer);","counters":[{"col_start":0,"col_end":89,"count":0}]},{"line":"","counters":[]},{"line":"    let _original_account_states = original_account_states.clone();","counters":[{"col_start":0,"col_end":67,"count":0}]},{"line":"    /*","counters":[{"col_start":0,"col_end":6,"count":0}]},{"line":"        let accounts = || {","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"            _original_account_states.iter().map(","counters":[{"col_start":0,"col_end":48,"count":0}]},{"line":"                |(id, account)| (","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"                    id.clone(),","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"                    account.map(|(_loc, acc)| acc)))","counters":[{"col_start":0,"col_end":52,"count":0}]},{"line":"        };","counters":[{"col_start":0,"col_end":10,"count":0}]},{"line":"    */","counters":[{"col_start":0,"col_end":6,"count":0}]},{"line":"    match step_all(","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"        constraint_constants,","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"        f,","counters":[{"col_start":0,"col_end":10,"count":0}]},{"line":"        perform,","counters":[{"col_start":0,"col_end":16,"count":0}]},{"line":"        f(user_acc, start.clone()),","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"        start,","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"    ) {","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"        Err(e) => Err(e),","counters":[{"col_start":12,"col_end":24,"count":0}]},{"line":"        Ok((s, failure_status_tbl)) => {","counters":[{"col_start":12,"col_end":40,"count":0}]},{"line":"            let account_ids_originally_not_in_ledger =","counters":[{"col_start":0,"col_end":54,"count":0}]},{"line":"                original_account_states","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"                    .iter()","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"                    .filter_map(|(acct_id, loc_and_acct)| {","counters":[{"col_start":0,"col_end":32,"count":0},{"col_start":58,"col_end":59,"count":0}]},{"line":"                        if loc_and_acct.is_none() {","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"                            Some(acct_id)","counters":[{"col_start":28,"col_end":41,"count":0}]},{"line":"                        } else {","counters":[]},{"line":"                            None","counters":[{"col_start":28,"col_end":32,"count":0}]},{"line":"                        }","counters":[]},{"line":"                    });","counters":[{"col_start":20,"col_end":21,"count":0},{"col_start":21,"col_end":23,"count":0}]},{"line":"            let successfully_applied = failure_status_tbl.iter().all(|x| x.is_empty());","counters":[{"col_start":0,"col_end":69,"count":0},{"col_start":73,"col_end":85,"count":0},{"col_start":85,"col_end":87,"count":0}]},{"line":"            let new_accounts = account_ids_originally_not_in_ledger","counters":[{"col_start":0,"col_end":67,"count":0}]},{"line":"                .filter_map(|acct_id| {","counters":[{"col_start":0,"col_end":28,"count":0},{"col_start":38,"col_end":39,"count":0}]},{"line":"                    //println!(","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"                    //    \"apply_zkapp_command_unchecked_aux 3 -> location_of_account {:?}\",","counters":[{"col_start":0,"col_end":92,"count":0}]},{"line":"                    //    acct_id","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"                    //);","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"                    let loc = ledger.location_of_account(&acct_id);","counters":[{"col_start":0,"col_end":67,"count":0}]},{"line":"                    //println!(","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"                    //    \"apply_zkapp_command_unchecked_aux merkle root {:?}\",","counters":[{"col_start":0,"col_end":79,"count":0}]},{"line":"                    //    ledger.merkle_root()","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"                    //);","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"                    //println!(\"apply_zkapp_command_unchecked_aux 3 -> get {:?}\", loc);","counters":[{"col_start":0,"col_end":87,"count":0}]},{"line":"                    let acc = loc.and_then(|loc| ledger.get(&loc));","counters":[{"col_start":0,"col_end":43,"count":0},{"col_start":49,"col_end":65,"count":0},{"col_start":65,"col_end":66,"count":0}]},{"line":"                    //println!(","counters":[]},{"line":"                    //    \"apply_zkapp_command_unchecked_aux merkle root {:?}\",","counters":[]},{"line":"                    //    ledger.merkle_root()","counters":[]},{"line":"                    //);","counters":[]},{"line":"                    match acc {","counters":[{"col_start":26,"col_end":29,"count":0}]},{"line":"                        Some(acc) if acc.id() == acct_id.clone() => Some(acct_id.clone()),","counters":[{"col_start":29,"col_end":32,"count":0},{"col_start":37,"col_end":45,"count":0},{"col_start":63,"col_end":89,"count":0}]},{"line":"                        _ => None,","counters":[{"col_start":29,"col_end":33,"count":0}]},{"line":"                    }","counters":[]},{"line":"                })","counters":[{"col_start":16,"col_end":17,"count":0},{"col_start":17,"col_end":18,"count":0}]},{"line":"                .collect::<Vec<AccountId>>();","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"            let valid_result = Ok((","counters":[{"col_start":16,"col_end":28,"count":0}]},{"line":"                ZkappCommandApplied {","counters":[]},{"line":"                    accounts: _original_account_states","counters":[{"col_start":30,"col_end":54,"count":0}]},{"line":"                        .iter()","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"                        .map(|(id, account)| (id.clone(), account.clone().map(|(_loc, acc)| acc)))","counters":[{"col_start":0,"col_end":29,"count":0},{"col_start":45,"col_end":78,"count":0},{"col_start":92,"col_end":95,"count":0},{"col_start":95,"col_end":97,"count":0},{"col_start":97,"col_end":98,"count":0}]},{"line":"                        .collect(),","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"                    command: WithStatus::<ZkAppCommand> {","counters":[{"col_start":0,"col_end":57,"count":0}]},{"line":"                        data: c.clone(),","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"                        status: if successfully_applied {","counters":[{"col_start":0,"col_end":55,"count":0}]},{"line":"                            TransactionStatus::Applied","counters":[{"col_start":28,"col_end":54,"count":0}]},{"line":"                        } else {","counters":[]},{"line":"                            TransactionStatus::Failed(failure_status_tbl)","counters":[{"col_start":28,"col_end":73,"count":0}]},{"line":"                        },","counters":[]},{"line":"                    },","counters":[]},{"line":"                    new_accounts: new_accounts.clone(),","counters":[{"col_start":34,"col_end":55,"count":0}]},{"line":"                },","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"                s,","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"            ));","counters":[{"col_start":0,"col_end":15,"count":0}]},{"line":"","counters":[]},{"line":"            if successfully_applied {","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"                valid_result","counters":[{"col_start":16,"col_end":28,"count":0}]},{"line":"            } else {","counters":[]},{"line":"                let other_account_update_accounts_unchanged = account_states_after_fee_payer","counters":[{"col_start":20,"col_end":92,"count":0}]},{"line":"                    .iter()","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"                    .fold_while(true, |acc, (_, loc_opt)| match loc_opt {","counters":[{"col_start":0,"col_end":38,"count":0},{"col_start":58,"col_end":71,"count":1}]},{"line":"                        Some((loc, a)) => {","counters":[{"col_start":30,"col_end":36,"count":1}]},{"line":"                            //println!(\"apply_zkapp_command_unchecked_aux 4 -> get {:?}\", loc);","counters":[]},{"line":"                            let ret = match ledger.get(&loc) {","counters":[{"col_start":32,"col_end":35,"count":6},{"col_start":51,"col_end":60,"count":1}]},{"line":"                                Some(a_) if (*a != a_) => {","counters":[{"col_start":37,"col_end":39,"count":6},{"col_start":44,"col_end":53,"count":1},{"col_start":53,"col_end":59,"count":6}]},{"line":"                                    //println!(\"[rust] other_account_update_accounts_unchanged: a {:?} a_ {:?}\", a, a_);","counters":[{"col_start":0,"col_end":120,"count":6}]},{"line":"                                    Done(false)","counters":[{"col_start":0,"col_end":47,"count":6}]},{"line":"                                }","counters":[]},{"line":"                                _ => Continue(acc),","counters":[{"col_start":37,"col_end":50,"count":0}]},{"line":"                            };","counters":[]},{"line":"                            //println!(","counters":[]},{"line":"                            //    \"apply_zkapp_command_unchecked_aux merkle root {:?}\",","counters":[]},{"line":"                            //    ledger.merkle_root()","counters":[]},{"line":"                            //);","counters":[]},{"line":"                            ret","counters":[{"col_start":28,"col_end":31,"count":6}]},{"line":"                        }","counters":[]},{"line":"                        _ => Continue(acc),","counters":[{"col_start":29,"col_end":42,"count":0}]},{"line":"                    })","counters":[{"col_start":20,"col_end":21,"count":6},{"col_start":21,"col_end":22,"count":0}]},{"line":"                    .into_inner();","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"                /*","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"                println!(","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"                    \">>> new_accounts {:?} other_account_update_accounts_unchanged {:?}\",","counters":[{"col_start":0,"col_end":89,"count":0}]},{"line":"                    new_accounts.is_empty(),","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"                    other_account_update_accounts_unchanged","counters":[{"col_start":0,"col_end":59,"count":0}]},{"line":"                );","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"                */","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"                if new_accounts.is_empty() && other_account_update_accounts_unchanged {","counters":[{"col_start":0,"col_end":42,"count":0},{"col_start":46,"col_end":85,"count":0}]},{"line":"                    valid_result","counters":[{"col_start":20,"col_end":32,"count":0}]},{"line":"                } else {","counters":[]},{"line":"                    Err(\"Zkapp_command application failed but new accounts created or some of the other account_update updates applied\".to_string())","counters":[{"col_start":20,"col_end":148,"count":0}]},{"line":"                }","counters":[]},{"line":"            }","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"pub fn apply_transaction<L>(","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"    constraint_constants: &ConstraintConstants,","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"    txn_state_view: &ProtocolStateView,","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"    ledger: &mut L,","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"    transaction: &Transaction,","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":") -> Result<TransactionApplied, String>","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"where","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"    L: LedgerIntf + Clone,","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"{","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"    use Transaction::*;","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"    use UserCommand::*;","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"    let previous_hash = ledger.merkle_root();","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"    let txn_global_slot = &txn_state_view.global_slot_since_genesis;","counters":[{"col_start":0,"col_end":67,"count":0}]},{"line":"","counters":[]},{"line":"    match transaction {","counters":[{"col_start":10,"col_end":21,"count":0}]},{"line":"        Command(SignedCommand(cmd)) => apply_user_command(","counters":[{"col_start":30,"col_end":58,"count":0}]},{"line":"            constraint_constants,","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"            txn_state_view,","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"            txn_global_slot,","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"            ledger,","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"            cmd,","counters":[{"col_start":0,"col_end":16,"count":0}]},{"line":"        )","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"        .map(|applied| Varying::Command(CommandApplied::SignedCommand(Box::new(applied)))),","counters":[{"col_start":0,"col_end":13,"count":0},{"col_start":23,"col_end":89,"count":0},{"col_start":89,"col_end":90,"count":0}]},{"line":"        Command(ZkAppCommand(c)) => {","counters":[{"col_start":29,"col_end":37,"count":0}]},{"line":"            apply_zkapp_command_unchecked(constraint_constants, txn_state_view, ledger, c).map(","counters":[{"col_start":0,"col_end":95,"count":0}]},{"line":"                |(applied, _)| Varying::Command(CommandApplied::ZkappCommand(Box::new(applied))),","counters":[{"col_start":0,"col_end":16,"count":0},{"col_start":31,"col_end":96,"count":0},{"col_start":96,"col_end":97,"count":0}]},{"line":"            )","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        }","counters":[]},{"line":"        FeeTransfer(fee_transfer) => {","counters":[{"col_start":20,"col_end":38,"count":0}]},{"line":"            apply_fee_transfer(constraint_constants, txn_global_slot, ledger, fee_transfer)","counters":[{"col_start":0,"col_end":91,"count":0}]},{"line":"                .map(Varying::FeeTransfer)","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"        }","counters":[]},{"line":"        Coinbase(coinbase) => {","counters":[{"col_start":17,"col_end":31,"count":0}]},{"line":"            apply_coinbase(constraint_constants, txn_global_slot, ledger, coinbase)","counters":[{"col_start":0,"col_end":83,"count":0}]},{"line":"                .map(Varying::Coinbase)","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"    .map(|varying| TransactionApplied {","counters":[{"col_start":5,"col_end":9,"count":0},{"col_start":19,"col_end":39,"count":0}]},{"line":"        previous_hash,","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"        varying,","counters":[{"col_start":0,"col_end":16,"count":0}]},{"line":"    })","counters":[{"col_start":0,"col_end":5,"count":0},{"col_start":5,"col_end":6,"count":0}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"/// Structure of the failure status:","counters":[]},{"line":"///  I. No fee transfer and coinbase transfer fails: [[failure]]","counters":[]},{"line":"///  II. With fee transfer-","counters":[]},{"line":"///   Both fee transfer and coinbase fails:","counters":[]},{"line":"///     [[failure-of-fee-transfer]; [failure-of-coinbase]]","counters":[]},{"line":"///   Fee transfer succeeds and coinbase fails:","counters":[]},{"line":"///     [[];[failure-of-coinbase]]","counters":[]},{"line":"///   Fee transfer fails and coinbase succeeds:","counters":[]},{"line":"///     [[failure-of-fee-transfer];[]]","counters":[]},{"line":"///","counters":[]},{"line":"/// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/transaction_logic/mina_transaction_logic.ml#L2022","counters":[]},{"line":"fn apply_coinbase<L>(","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"    constraint_constants: &ConstraintConstants,","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"    txn_global_slot: &Slot,","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"    ledger: &mut L,","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"    coinbase: &Coinbase,","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":") -> Result<transaction_applied::CoinbaseApplied, String>","counters":[{"col_start":0,"col_end":57,"count":0}]},{"line":"where","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"    L: LedgerIntf,","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"{","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"    let Coinbase {","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"        receiver,","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"        amount: coinbase_amount,","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"        fee_transfer,","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"    } = &coinbase;","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"","counters":[]},{"line":"    let (","counters":[]},{"line":"        receiver_reward,","counters":[{"col_start":8,"col_end":24,"count":0}]},{"line":"        new_accounts1,","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"        transferee_update,","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"        transferee_timing_prev,","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"        failures1,","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"        burned_tokens1,","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"    ) = match fee_transfer {","counters":[{"col_start":14,"col_end":26,"count":0}]},{"line":"        None => (*coinbase_amount, None, None, None, vec![], Amount::zero()),","counters":[{"col_start":16,"col_end":76,"count":0}]},{"line":"        Some(","counters":[]},{"line":"            ft @ CoinbaseFeeTransfer {","counters":[{"col_start":12,"col_end":38,"count":0}]},{"line":"                receiver_pk: transferee,","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"                fee,","counters":[{"col_start":0,"col_end":20,"count":0}]},{"line":"            },","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"        ) => {","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"            assert_ne!(transferee, receiver);","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"            let transferee_id = ft.receiver();","counters":[{"col_start":16,"col_end":46,"count":0}]},{"line":"            let fee = Amount::of_fee(fee);","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"","counters":[]},{"line":"            let receiver_reward = coinbase_amount","counters":[{"col_start":16,"col_end":31,"count":0},{"col_start":34,"col_end":49,"count":0}]},{"line":"                .checked_sub(&fee)","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"                .ok_or_else(|| \"Coinbase fee transfer too large\".to_string())?;","counters":[{"col_start":0,"col_end":28,"count":0},{"col_start":31,"col_end":76,"count":0},{"col_start":76,"col_end":77,"count":0},{"col_start":77,"col_end":78,"count":0}]},{"line":"","counters":[]},{"line":"            let (transferee_account, action, can_receive) =","counters":[{"col_start":17,"col_end":59,"count":0}]},{"line":"                has_permission_to_receive(ledger, &transferee_id);","counters":[{"col_start":0,"col_end":66,"count":0}]},{"line":"            let new_accounts = get_new_accounts(action, transferee_id.clone());","counters":[{"col_start":0,"col_end":78,"count":0}]},{"line":"","counters":[]},{"line":"            let timing = update_timing_when_no_deduction(txn_global_slot, &transferee_account)?;","counters":[{"col_start":16,"col_end":22,"count":0},{"col_start":25,"col_end":94,"count":0},{"col_start":94,"col_end":95,"count":0}]},{"line":"","counters":[]},{"line":"            let balance = {","counters":[{"col_start":16,"col_end":23,"count":0}]},{"line":"                let amount = sub_account_creation_fee(constraint_constants, action, fee)?;","counters":[{"col_start":20,"col_end":26,"count":0},{"col_start":29,"col_end":88,"count":0},{"col_start":88,"col_end":89,"count":0}]},{"line":"                add_amount(transferee_account.balance, amount)?","counters":[{"col_start":16,"col_end":62,"count":0},{"col_start":62,"col_end":63,"count":0}]},{"line":"            };","counters":[]},{"line":"","counters":[]},{"line":"            if can_receive.0 {","counters":[{"col_start":15,"col_end":28,"count":0}]},{"line":"                let (_, mut transferee_account, transferee_location) =","counters":[{"col_start":24,"col_end":67,"count":0}]},{"line":"                    ledger.get_or_create(&transferee_id)?;","counters":[{"col_start":20,"col_end":56,"count":0},{"col_start":56,"col_end":57,"count":0}]},{"line":"","counters":[]},{"line":"                transferee_account.balance = balance;","counters":[{"col_start":16,"col_end":53,"count":0}]},{"line":"                transferee_account.timing = timing;","counters":[{"col_start":0,"col_end":51,"count":0}]},{"line":"","counters":[]},{"line":"                let timing = transferee_account.timing.clone();","counters":[{"col_start":0,"col_end":63,"count":0}]},{"line":"","counters":[]},{"line":"                (","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"                    receiver_reward,","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"                    new_accounts,","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"                    Some((transferee_location, transferee_account)),","counters":[{"col_start":0,"col_end":68,"count":0}]},{"line":"                    Some(timing),","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"                    vec![],","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"                    Amount::zero(),","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"                )","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"            } else {","counters":[]},{"line":"                (","counters":[{"col_start":16,"col_end":17,"count":0}]},{"line":"                    receiver_reward,","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"                    None,","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"                    None,","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"                    None,","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"                    vec![TransactionFailure::UpdateNotPermittedBalance],","counters":[{"col_start":0,"col_end":72,"count":0}]},{"line":"                    fee,","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"                )","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"            }","counters":[]},{"line":"        }","counters":[]},{"line":"    };","counters":[]},{"line":"","counters":[]},{"line":"    let receiver_id = AccountId::new(receiver.clone(), TokenId::default());","counters":[{"col_start":8,"col_end":75,"count":0}]},{"line":"    let (receiver_account, action2, can_receive) = has_permission_to_receive(ledger, &receiver_id);","counters":[{"col_start":0,"col_end":99,"count":0}]},{"line":"    let new_accounts2 = get_new_accounts(action2, receiver_id.clone());","counters":[{"col_start":0,"col_end":70,"count":0}]},{"line":"","counters":[]},{"line":"    // Note: Updating coinbase receiver timing only if there is no fee transfer.","counters":[]},{"line":"    // This is so as to not add any extra constraints in transaction snark for checking","counters":[]},{"line":"    // \"receiver\" timings. This is OK because timing rules will not be violated when","counters":[]},{"line":"    // balance increases and will be checked whenever an amount is deducted from the","counters":[]},{"line":"    // account (#5973)","counters":[]},{"line":"","counters":[]},{"line":"    let coinbase_receiver_timing = match transferee_timing_prev {","counters":[{"col_start":8,"col_end":32,"count":0},{"col_start":41,"col_end":63,"count":0}]},{"line":"        None => update_timing_when_no_deduction(txn_global_slot, &receiver_account)?,","counters":[{"col_start":16,"col_end":83,"count":0},{"col_start":83,"col_end":84,"count":0}]},{"line":"        Some(_) => receiver_account.timing.clone(),","counters":[{"col_start":19,"col_end":50,"count":0}]},{"line":"    };","counters":[]},{"line":"","counters":[]},{"line":"    let receiver_balance = {","counters":[{"col_start":8,"col_end":24,"count":0}]},{"line":"        let amount = sub_account_creation_fee(constraint_constants, action2, receiver_reward)?;","counters":[{"col_start":12,"col_end":18,"count":0},{"col_start":21,"col_end":93,"count":0},{"col_start":93,"col_end":94,"count":0}]},{"line":"        add_amount(receiver_account.balance, amount)?","counters":[{"col_start":8,"col_end":52,"count":0},{"col_start":52,"col_end":53,"count":0}]},{"line":"    };","counters":[]},{"line":"","counters":[]},{"line":"    let (failures2, burned_tokens2) = if can_receive.0 {","counters":[{"col_start":9,"col_end":34,"count":0},{"col_start":41,"col_end":54,"count":0}]},{"line":"        let (_action2, mut receiver_account, receiver_location) =","counters":[{"col_start":13,"col_end":62,"count":0}]},{"line":"            ledger.get_or_create(&receiver_id)?;","counters":[{"col_start":12,"col_end":46,"count":0},{"col_start":46,"col_end":47,"count":0}]},{"line":"","counters":[]},{"line":"        receiver_account.balance = receiver_balance;","counters":[{"col_start":8,"col_end":52,"count":0}]},{"line":"        receiver_account.timing = coinbase_receiver_timing;","counters":[{"col_start":0,"col_end":59,"count":0}]},{"line":"","counters":[]},{"line":"        ledger.set(&receiver_location, receiver_account);","counters":[{"col_start":0,"col_end":57,"count":0}]},{"line":"","counters":[]},{"line":"        (vec![], Amount::zero())","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"    } else {","counters":[]},{"line":"        (","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"            vec![TransactionFailure::UpdateNotPermittedBalance],","counters":[{"col_start":0,"col_end":64,"count":0}]},{"line":"            receiver_reward,","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"        )","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    };","counters":[]},{"line":"","counters":[]},{"line":"    if let Some((addr, account)) = transferee_update {","counters":[{"col_start":17,"col_end":30,"count":0},{"col_start":35,"col_end":52,"count":0},{"col_start":53,"col_end":54,"count":0}]},{"line":"        ledger.set(&addr, account);","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"    };","counters":[{"col_start":0,"col_end":5,"count":0},{"col_start":5,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let burned_tokens = burned_tokens1","counters":[{"col_start":8,"col_end":21,"count":0},{"col_start":24,"col_end":38,"count":0}]},{"line":"        .checked_add(&burned_tokens2)","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"        .ok_or_else(|| \"burned tokens overflow\".to_string())?;","counters":[{"col_start":0,"col_end":20,"count":0},{"col_start":23,"col_end":59,"count":0},{"col_start":59,"col_end":60,"count":0},{"col_start":60,"col_end":61,"count":0}]},{"line":"","counters":[]},{"line":"    let failures = vec![failures1, failures2];","counters":[{"col_start":8,"col_end":45,"count":0}]},{"line":"    let status = if failures.iter().all(Vec::is_empty) {","counters":[{"col_start":8,"col_end":14,"count":0},{"col_start":20,"col_end":54,"count":0}]},{"line":"        TransactionStatus::Applied","counters":[{"col_start":8,"col_end":34,"count":0}]},{"line":"    } else {","counters":[]},{"line":"        TransactionStatus::Failed(failures)","counters":[{"col_start":8,"col_end":43,"count":0}]},{"line":"    };","counters":[]},{"line":"","counters":[]},{"line":"    let new_accounts: Vec<_> = [new_accounts1, new_accounts2]","counters":[{"col_start":8,"col_end":61,"count":0}]},{"line":"        .into_iter()","counters":[{"col_start":0,"col_end":20,"count":0}]},{"line":"        .flatten()","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"        .collect();","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"","counters":[]},{"line":"    Ok(transaction_applied::CoinbaseApplied {","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"        coinbase: WithStatus {","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"            data: coinbase.clone(),","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"            status,","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"        },","counters":[{"col_start":0,"col_end":10,"count":0}]},{"line":"        new_accounts,","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"        burned_tokens,","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"    })","counters":[{"col_start":0,"col_end":6,"count":0}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"/// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/transaction_logic/mina_transaction_logic.ml#L1991","counters":[]},{"line":"fn apply_fee_transfer<L>(","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"    constraint_constants: &ConstraintConstants,","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"    txn_global_slot: &Slot,","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"    ledger: &mut L,","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"    fee_transfer: &FeeTransfer,","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":") -> Result<transaction_applied::FeeTransferApplied, String>","counters":[{"col_start":0,"col_end":60,"count":0}]},{"line":"where","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"    L: LedgerIntf,","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"{","counters":[{"col_start":0,"col_end":0,"count":0},{"col_start":0,"col_end":0,"count":0},{"col_start":0,"col_end":0,"count":0}]},{"line":"    let (new_accounts, failures, burned_tokens) = process_fee_transfer(","counters":[{"col_start":9,"col_end":46,"count":0},{"col_start":50,"col_end":71,"count":0}]},{"line":"        ledger,","counters":[{"col_start":0,"col_end":15,"count":0}]},{"line":"        fee_transfer,","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"        |action, _, balance, fee| {","counters":[{"col_start":0,"col_end":8,"count":0},{"col_start":34,"col_end":35,"count":0}]},{"line":"            let amount = {","counters":[{"col_start":16,"col_end":22,"count":0}]},{"line":"                let amount = Amount::of_fee(fee);","counters":[{"col_start":20,"col_end":49,"count":0}]},{"line":"                sub_account_creation_fee(constraint_constants, action, amount)?","counters":[{"col_start":0,"col_end":78,"count":0},{"col_start":78,"col_end":79,"count":0}]},{"line":"            };","counters":[]},{"line":"            add_amount(balance, amount)","counters":[{"col_start":12,"col_end":39,"count":0}]},{"line":"        },","counters":[{"col_start":8,"col_end":9,"count":0},{"col_start":9,"col_end":10,"count":0}]},{"line":"        |account| update_timing_when_no_deduction(txn_global_slot, account),","counters":[{"col_start":0,"col_end":8,"count":0},{"col_start":18,"col_end":75,"count":0},{"col_start":75,"col_end":76,"count":0}]},{"line":"    )?;","counters":[{"col_start":0,"col_end":5,"count":0},{"col_start":5,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let status = if failures.iter().all(Vec::is_empty) {","counters":[{"col_start":8,"col_end":14,"count":0},{"col_start":20,"col_end":54,"count":0}]},{"line":"        TransactionStatus::Applied","counters":[{"col_start":8,"col_end":34,"count":0}]},{"line":"    } else {","counters":[]},{"line":"        TransactionStatus::Failed(failures)","counters":[{"col_start":8,"col_end":43,"count":0}]},{"line":"    };","counters":[]},{"line":"","counters":[]},{"line":"    Ok(transaction_applied::FeeTransferApplied {","counters":[{"col_start":4,"col_end":48,"count":0}]},{"line":"        fee_transfer: WithStatus {","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"            data: fee_transfer.clone(),","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"            status,","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"        },","counters":[{"col_start":0,"col_end":10,"count":0}]},{"line":"        new_accounts,","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"        burned_tokens,","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"    })","counters":[{"col_start":0,"col_end":6,"count":0}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"/// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/transaction_logic/mina_transaction_logic.ml#L607","counters":[]},{"line":"fn sub_account_creation_fee(","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"    constraint_constants: &ConstraintConstants,","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"    action: AccountState,","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"    amount: Amount,","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":") -> Result<Amount, String> {","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"    let fee = &constraint_constants.account_creation_fee;","counters":[{"col_start":0,"col_end":57,"count":0}]},{"line":"","counters":[]},{"line":"    match action {","counters":[{"col_start":0,"col_end":16,"count":0}]},{"line":"        AccountState::Added => {","counters":[]},{"line":"            if let Some(amount) = amount.checked_sub(&Amount::of_fee(fee)) {","counters":[{"col_start":24,"col_end":30,"count":0},{"col_start":34,"col_end":74,"count":0}]},{"line":"                return Ok(amount);","counters":[{"col_start":23,"col_end":33,"count":0}]},{"line":"            }","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"            Err(format!(","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"                \"Error subtracting account creation fee {:?}; transaction amount {:?} insufficient\",","counters":[{"col_start":0,"col_end":100,"count":0}]},{"line":"                fee, amount","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"            ))","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"        }","counters":[]},{"line":"        AccountState::Existed => Ok(amount),","counters":[{"col_start":33,"col_end":43,"count":0}]},{"line":"    }","counters":[]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"fn update_timing_when_no_deduction(","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"    txn_global_slot: &Slot,","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"    account: &Account,","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":") -> Result<Timing, String> {","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"    validate_timing(account, Amount::zero(), txn_global_slot)","counters":[{"col_start":0,"col_end":61,"count":0}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"// /// TODO: Move this to the ledger","counters":[]},{"line":"// /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/mina_ledger/ledger.ml#L311","counters":[]},{"line":"// fn get_or_create<L>(","counters":[]},{"line":"//     ledger: &mut L,","counters":[]},{"line":"//     account_id: &AccountId,","counters":[]},{"line":"// ) -> Result<(AccountState, Account, Address), String>","counters":[]},{"line":"// where","counters":[]},{"line":"//     L: LedgerIntf,","counters":[]},{"line":"// {","counters":[]},{"line":"//     let location = ledger","counters":[]},{"line":"//         .get_or_create_account(account_id.clone(), Account::initialize(account_id))","counters":[]},{"line":"//         .map_err(|e| format!(\"{:?}\", e))?;","counters":[]},{"line":"","counters":[]},{"line":"//     let action = match location {","counters":[]},{"line":"//         GetOrCreated::Added(_) => AccountState::Added,","counters":[]},{"line":"//         GetOrCreated::Existed(_) => AccountState::Existed,","counters":[]},{"line":"//     };","counters":[]},{"line":"","counters":[]},{"line":"//     let addr = location.addr();","counters":[]},{"line":"","counters":[]},{"line":"//     let account = ledger","counters":[]},{"line":"//         .get(addr.clone())","counters":[]},{"line":"//         .expect(\"get_or_create: Account was not found in the ledger after creation\");","counters":[]},{"line":"","counters":[]},{"line":"//     Ok((action, account, addr))","counters":[]},{"line":"// }","counters":[]},{"line":"","counters":[]},{"line":"fn get_new_accounts<T>(action: AccountState, data: T) -> Option<T> {","counters":[{"col_start":0,"col_end":68,"count":0}]},{"line":"    match action {","counters":[{"col_start":0,"col_end":16,"count":0}]},{"line":"        AccountState::Added => Some(data),","counters":[{"col_start":31,"col_end":41,"count":0}]},{"line":"        AccountState::Existed => None,","counters":[{"col_start":33,"col_end":37,"count":0}]},{"line":"    }","counters":[]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"/// Structure of the failure status:","counters":[]},{"line":"///  I. Only one fee transfer in the transaction (`One) and it fails:","counters":[]},{"line":"///     [[failure]]","counters":[]},{"line":"///  II. Two fee transfers in the transaction (`Two)-","counters":[]},{"line":"///   Both fee transfers fail:","counters":[]},{"line":"///     [[failure-of-first-fee-transfer]; [failure-of-second-fee-transfer]]","counters":[]},{"line":"///   First succeeds and second one fails:","counters":[]},{"line":"///     [[];[failure-of-second-fee-transfer]]","counters":[]},{"line":"///   First fails and second succeeds:","counters":[]},{"line":"///     [[failure-of-first-fee-transfer];[]]","counters":[]},{"line":"fn process_fee_transfer<L, FunBalance, FunTiming>(","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"    ledger: &mut L,","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"    fee_transfer: &FeeTransfer,","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"    modify_balance: FunBalance,","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"    modify_timing: FunTiming,","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":") -> Result<(Vec<AccountId>, Vec<Vec<TransactionFailure>>, Amount), String>","counters":[{"col_start":0,"col_end":75,"count":0}]},{"line":"where","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"    L: LedgerIntf,","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"    FunTiming: Fn(&Account) -> Result<Timing, String>,","counters":[{"col_start":0,"col_end":54,"count":0}]},{"line":"    FunBalance: Fn(AccountState, &AccountId, Balance, &Fee) -> Result<Balance, String>,","counters":[{"col_start":0,"col_end":87,"count":0}]},{"line":"{","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"    if !fee_transfer.fee_tokens().all(TokenId::is_default) {","counters":[{"col_start":0,"col_end":58,"count":0}]},{"line":"        return Err(\"Cannot pay fees in non-default tokens.\".to_string());","counters":[{"col_start":15,"col_end":72,"count":0}]},{"line":"    }","counters":[{"col_start":5,"col_end":5,"count":0},{"col_start":5,"col_end":5,"count":0},{"col_start":5,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    match &**fee_transfer {","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"        OneOrTwo::One(fee_transfer) => {","counters":[{"col_start":22,"col_end":40,"count":0}]},{"line":"            let account_id = fee_transfer.receiver();","counters":[{"col_start":0,"col_end":53,"count":0}]},{"line":"            let (a, action, can_receive) = has_permission_to_receive(ledger, &account_id);","counters":[{"col_start":0,"col_end":89,"count":0}]},{"line":"","counters":[]},{"line":"            let timing = modify_timing(&a)?;","counters":[{"col_start":16,"col_end":22,"count":0},{"col_start":25,"col_end":42,"count":0},{"col_start":42,"col_end":43,"count":0}]},{"line":"            let balance = modify_balance(action, &account_id, a.balance, &fee_transfer.fee)?;","counters":[{"col_start":16,"col_end":23,"count":0},{"col_start":26,"col_end":91,"count":0},{"col_start":91,"col_end":92,"count":0}]},{"line":"","counters":[]},{"line":"            if can_receive.0 {","counters":[{"col_start":15,"col_end":28,"count":0}]},{"line":"                let (_, mut account, loc) = ledger.get_or_create(&account_id)?;","counters":[{"col_start":24,"col_end":40,"count":0},{"col_start":44,"col_end":77,"count":0},{"col_start":77,"col_end":78,"count":0}]},{"line":"                let new_accounts = get_new_accounts(action, account_id.clone());","counters":[{"col_start":20,"col_end":80,"count":0}]},{"line":"","counters":[]},{"line":"                account.balance = balance;","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"                account.timing = timing;","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"                ledger.set(&loc, account);","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"","counters":[]},{"line":"                let new_accounts: Vec<_> = new_accounts.into_iter().collect();","counters":[{"col_start":0,"col_end":78,"count":0}]},{"line":"                Ok((new_accounts, vec![], Amount::zero()))","counters":[{"col_start":0,"col_end":58,"count":0}]},{"line":"            } else {","counters":[]},{"line":"                Ok((vec![], single_failure(), Amount::of_fee(&fee_transfer.fee)))","counters":[{"col_start":16,"col_end":81,"count":0}]},{"line":"            }","counters":[]},{"line":"        }","counters":[]},{"line":"        OneOrTwo::Two((fee_transfer1, fee_transfer2)) => {","counters":[{"col_start":23,"col_end":58,"count":0}]},{"line":"            let account_id1 = fee_transfer1.receiver();","counters":[{"col_start":0,"col_end":55,"count":0}]},{"line":"            let (a1, action1, can_receive1) = has_permission_to_receive(ledger, &account_id1);","counters":[{"col_start":0,"col_end":94,"count":0}]},{"line":"","counters":[]},{"line":"            let account_id2 = fee_transfer2.receiver();","counters":[{"col_start":0,"col_end":55,"count":0}]},{"line":"","counters":[]},{"line":"            if account_id1 == account_id2 {","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"                let fee = fee_transfer1","counters":[{"col_start":20,"col_end":23,"count":0},{"col_start":26,"col_end":39,"count":0}]},{"line":"                    .fee","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"                    .checked_add(&fee_transfer2.fee)","counters":[{"col_start":0,"col_end":52,"count":0}]},{"line":"                    .ok_or_else(|| \"Overflow\".to_string())?;","counters":[{"col_start":0,"col_end":32,"count":0},{"col_start":35,"col_end":57,"count":0},{"col_start":57,"col_end":58,"count":0},{"col_start":58,"col_end":59,"count":0}]},{"line":"","counters":[]},{"line":"                let timing = modify_timing(&a1)?;","counters":[{"col_start":20,"col_end":26,"count":0},{"col_start":29,"col_end":47,"count":0},{"col_start":47,"col_end":48,"count":0}]},{"line":"                let balance = modify_balance(action1, &account_id1, a1.balance, &fee)?;","counters":[{"col_start":20,"col_end":27,"count":0},{"col_start":30,"col_end":85,"count":0},{"col_start":85,"col_end":86,"count":0}]},{"line":"","counters":[]},{"line":"                if can_receive1.0 {","counters":[{"col_start":19,"col_end":33,"count":0}]},{"line":"                    let (_, mut a1, l1) = ledger.get_or_create(&account_id1)?;","counters":[{"col_start":28,"col_end":38,"count":0},{"col_start":42,"col_end":76,"count":0},{"col_start":76,"col_end":77,"count":0}]},{"line":"                    let new_accounts1 = get_new_accounts(action1, account_id1);","counters":[{"col_start":24,"col_end":79,"count":0}]},{"line":"","counters":[]},{"line":"                    a1.balance = balance;","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"                    a1.timing = timing;","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"                    ledger.set(&l1, a1);","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"                    let new_accounts: Vec<_> = new_accounts1.into_iter().collect();","counters":[{"col_start":0,"col_end":83,"count":0}]},{"line":"                    Ok((new_accounts, vec![vec![], vec![]], Amount::zero()))","counters":[{"col_start":0,"col_end":76,"count":0}]},{"line":"                } else {","counters":[]},{"line":"                    // failure for each fee transfer single","counters":[]},{"line":"","counters":[]},{"line":"                    Ok((","counters":[{"col_start":20,"col_end":24,"count":0}]},{"line":"                        vec![],","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"                        vec![","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"                            vec![TransactionFailure::UpdateNotPermittedBalance],","counters":[{"col_start":0,"col_end":80,"count":0}]},{"line":"                            vec![TransactionFailure::UpdateNotPermittedBalance],","counters":[{"col_start":0,"col_end":80,"count":0}]},{"line":"                        ],","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"                        Amount::of_fee(&fee),","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"                    ))","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"                }","counters":[]},{"line":"            } else {","counters":[]},{"line":"                let (a2, action2, can_receive2) = has_permission_to_receive(ledger, &account_id2);","counters":[{"col_start":21,"col_end":97,"count":0}]},{"line":"","counters":[]},{"line":"                let balance1 =","counters":[{"col_start":20,"col_end":28,"count":0}]},{"line":"                    modify_balance(action1, &account_id1, a1.balance, &fee_transfer1.fee)?;","counters":[{"col_start":20,"col_end":89,"count":0},{"col_start":89,"col_end":90,"count":0}]},{"line":"","counters":[]},{"line":"                // Note: Not updating the timing field of a1 to avoid additional check","counters":[]},{"line":"                // in transactions snark (check_timing for \"receiver\"). This is OK","counters":[]},{"line":"                // because timing rules will not be violated when balance increases","counters":[]},{"line":"                // and will be checked whenever an amount is deducted from the account. (#5973)*)","counters":[]},{"line":"","counters":[]},{"line":"                let timing2 = modify_timing(&a2)?;","counters":[{"col_start":20,"col_end":27,"count":0},{"col_start":30,"col_end":48,"count":0},{"col_start":48,"col_end":49,"count":0}]},{"line":"                let balance2 =","counters":[{"col_start":20,"col_end":28,"count":0}]},{"line":"                    modify_balance(action2, &account_id2, a2.balance, &fee_transfer2.fee)?;","counters":[{"col_start":20,"col_end":89,"count":0},{"col_start":89,"col_end":90,"count":0}]},{"line":"","counters":[]},{"line":"                let (new_accounts1, failures1, burned_tokens1) = if can_receive1.0 {","counters":[{"col_start":21,"col_end":61,"count":0},{"col_start":68,"col_end":82,"count":0}]},{"line":"                    let (_, mut a1, l1) = ledger.get_or_create(&account_id1)?;","counters":[{"col_start":28,"col_end":38,"count":0},{"col_start":42,"col_end":76,"count":0},{"col_start":76,"col_end":77,"count":0}]},{"line":"                    let new_accounts1 = get_new_accounts(action1, account_id1);","counters":[{"col_start":24,"col_end":79,"count":0}]},{"line":"","counters":[]},{"line":"                    a1.balance = balance1;","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"                    ledger.set(&l1, a1);","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"                    (new_accounts1, vec![], Amount::zero())","counters":[{"col_start":0,"col_end":59,"count":0}]},{"line":"                } else {","counters":[]},{"line":"                    (","counters":[{"col_start":20,"col_end":21,"count":0}]},{"line":"                        None,","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"                        vec![TransactionFailure::UpdateNotPermittedBalance],","counters":[{"col_start":0,"col_end":76,"count":0}]},{"line":"                        Amount::of_fee(&fee_transfer1.fee),","counters":[{"col_start":0,"col_end":59,"count":0}]},{"line":"                    )","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"                };","counters":[]},{"line":"","counters":[]},{"line":"                let (new_accounts2, failures2, burned_tokens2) = if can_receive2.0 {","counters":[{"col_start":21,"col_end":61,"count":0},{"col_start":68,"col_end":82,"count":0}]},{"line":"                    let (_, mut a2, l2) = ledger.get_or_create(&account_id2)?;","counters":[{"col_start":28,"col_end":38,"count":0},{"col_start":42,"col_end":76,"count":0},{"col_start":76,"col_end":77,"count":0}]},{"line":"                    let new_accounts2 = get_new_accounts(action2, account_id2);","counters":[{"col_start":24,"col_end":79,"count":0}]},{"line":"","counters":[]},{"line":"                    a2.balance = balance2;","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"                    a2.timing = timing2;","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"                    ledger.set(&l2, a2);","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"                    (new_accounts2, vec![], Amount::zero())","counters":[{"col_start":0,"col_end":59,"count":0}]},{"line":"                } else {","counters":[]},{"line":"                    (","counters":[{"col_start":20,"col_end":21,"count":0}]},{"line":"                        None,","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"                        vec![TransactionFailure::UpdateNotPermittedBalance],","counters":[{"col_start":0,"col_end":76,"count":0}]},{"line":"                        Amount::of_fee(&fee_transfer2.fee),","counters":[{"col_start":0,"col_end":59,"count":0}]},{"line":"                    )","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"                };","counters":[]},{"line":"","counters":[]},{"line":"                let burned_tokens = burned_tokens1","counters":[{"col_start":20,"col_end":33,"count":0},{"col_start":36,"col_end":50,"count":0}]},{"line":"                    .checked_add(&burned_tokens2)","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"                    .ok_or_else(|| \"burned tokens overflow\".to_string())?;","counters":[{"col_start":0,"col_end":32,"count":0},{"col_start":35,"col_end":71,"count":0},{"col_start":71,"col_end":72,"count":0},{"col_start":72,"col_end":73,"count":0}]},{"line":"","counters":[]},{"line":"                let new_accounts: Vec<_> = [new_accounts1, new_accounts2]","counters":[{"col_start":20,"col_end":73,"count":0}]},{"line":"                    .into_iter()","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"                    .flatten()","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"                    .collect();","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"                let failures: Vec<_> = [failures1, failures2].into_iter().collect();","counters":[{"col_start":0,"col_end":84,"count":0}]},{"line":"","counters":[]},{"line":"                Ok((new_accounts, failures, burned_tokens))","counters":[{"col_start":0,"col_end":59,"count":0}]},{"line":"            }","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"#[derive(Copy, Clone, Debug)]","counters":[{"col_start":22,"col_end":23,"count":0},{"col_start":26,"col_end":27,"count":0}]},{"line":"pub enum AccountState {","counters":[]},{"line":"    Added,","counters":[]},{"line":"    Existed,","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"#[derive(Debug)]","counters":[{"col_start":9,"col_end":14,"count":0}]},{"line":"struct HasPermissionToReceive(bool);","counters":[]},{"line":"","counters":[]},{"line":"/// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/transaction_logic/mina_transaction_logic.ml#L1852","counters":[]},{"line":"fn has_permission_to_receive<L>(","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"    ledger: &mut L,","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"    receiver_account_id: &AccountId,","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":") -> (Account, AccountState, HasPermissionToReceive)","counters":[{"col_start":0,"col_end":52,"count":0}]},{"line":"where","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"    L: LedgerIntf,","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"{","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"    use crate::PermissionTo::*;","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"    use AccountState::*;","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"","counters":[]},{"line":"    let init_account = Account::initialize(receiver_account_id);","counters":[{"col_start":0,"col_end":64,"count":0}]},{"line":"","counters":[]},{"line":"    match ledger.location_of_account(receiver_account_id) {","counters":[{"col_start":0,"col_end":57,"count":0}]},{"line":"        None => {","counters":[]},{"line":"            // new account, check that default permissions allow receiving","counters":[]},{"line":"            let perm = init_account.has_permission_to(Receive);","counters":[{"col_start":16,"col_end":63,"count":0}]},{"line":"            (init_account, Added, HasPermissionToReceive(perm))","counters":[{"col_start":0,"col_end":63,"count":0}]},{"line":"        }","counters":[]},{"line":"        Some(location) => match ledger.get(&location) {","counters":[{"col_start":13,"col_end":53,"count":0}]},{"line":"            None => panic!(\"Ledger location with no account\"),","counters":[{"col_start":20,"col_end":61,"count":0}]},{"line":"            Some(receiver_account) => {","counters":[{"col_start":17,"col_end":39,"count":0}]},{"line":"                let perm = receiver_account.has_permission_to(Receive);","counters":[{"col_start":0,"col_end":71,"count":0}]},{"line":"                (receiver_account, Existed, HasPermissionToReceive(perm))","counters":[{"col_start":0,"col_end":73,"count":0}]},{"line":"            }","counters":[]},{"line":"        },","counters":[]},{"line":"    }","counters":[]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"pub fn validate_time(valid_until: &Slot, current_global_slot: &Slot) -> Result<(), String> {","counters":[{"col_start":0,"col_end":92,"count":0}]},{"line":"    if current_global_slot <= valid_until {","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"        return Ok(());","counters":[{"col_start":15,"col_end":21,"count":0}]},{"line":"    }","counters":[{"col_start":5,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    Err(format!(","counters":[{"col_start":0,"col_end":16,"count":0}]},{"line":"        \"Current global slot {:?} greater than transaction expiry slot {:?}\",","counters":[{"col_start":0,"col_end":77,"count":0}]},{"line":"        current_global_slot, valid_until","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"    ))","counters":[{"col_start":0,"col_end":6,"count":0}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"pub fn is_timed(a: &Account) -> bool {","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"    matches!(&a.timing, Timing::Timed { .. })","counters":[{"col_start":4,"col_end":12,"count":0},{"col_start":13,"col_end":22,"count":0}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"pub fn set_with_location<L>(","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"    ledger: &mut L,","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"    location: &ExistingOrNew<L::Location>,","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"    account: Account,","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":") -> Result<(), String>","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"where","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"    L: LedgerIntf,","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"{","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"    match location {","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"        ExistingOrNew::Existing(location) => {","counters":[{"col_start":32,"col_end":46,"count":0}]},{"line":"            //println!(\"rust_print_backtrace=\\n{}\", crate::short_backtrace());","counters":[{"col_start":0,"col_end":78,"count":0}]},{"line":"            //println!(\"set_with_location -> set {:?}\", account);","counters":[{"col_start":0,"col_end":65,"count":0}]},{"line":"            ledger.set(location, account);","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"            //println!(","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"            //    \"set_with_location merkle root {:?}\",","counters":[{"col_start":0,"col_end":55,"count":0}]},{"line":"            //    ledger.merkle_root()","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"            //);","counters":[{"col_start":0,"col_end":16,"count":0}]},{"line":"","counters":[]},{"line":"            Ok(())","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"        }","counters":[]},{"line":"        ExistingOrNew::New => {","counters":[]},{"line":"            /*","counters":[]},{"line":"            println!(","counters":[]},{"line":"                \"set_with_location -> create_new_account {:?} {:?}\",","counters":[]},{"line":"                account.id(),","counters":[]},{"line":"                account","counters":[]},{"line":"            );","counters":[]},{"line":"            */","counters":[]},{"line":"            ledger","counters":[{"col_start":12,"col_end":18,"count":0}]},{"line":"                .create_new_account(account.id(), account)","counters":[{"col_start":0,"col_end":58,"count":0}]},{"line":"                .map_err(|_| \"set_with_location\".to_string())","counters":[{"col_start":0,"col_end":25,"count":0},{"col_start":29,"col_end":60,"count":0},{"col_start":60,"col_end":61,"count":0}]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"pub struct Updates<Location> {","counters":[]},{"line":"    pub located_accounts: Vec<(ExistingOrNew<Location>, Account)>,","counters":[]},{"line":"    pub applied_body: signed_command_applied::Body,","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"pub fn compute_updates<L>(","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"    constraint_constants: &ConstraintConstants,","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"    source: AccountId,","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"    receiver: AccountId,","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"    ledger: &mut L,","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"    current_global_slot: &Slot,","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"    user_command: &SignedCommand,","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"    fee_payer: &AccountId,","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"    reject_command: &mut bool,","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":") -> Result<Updates<L::Location>, TransactionFailure>","counters":[{"col_start":0,"col_end":53,"count":0}]},{"line":"where","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"    L: LedgerIntf,","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"{","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"    match &user_command.payload.body {","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"        signed_command::Body::StakeDelegation(_) => {","counters":[]},{"line":"            let (source_location, mut source_account) = get_with_location(ledger, &source).unwrap();","counters":[{"col_start":17,"col_end":100,"count":0}]},{"line":"","counters":[]},{"line":"            if !source_account.has_permission_to(PermissionTo::SetDelegate) {","counters":[{"col_start":0,"col_end":75,"count":0}]},{"line":"                return Err(TransactionFailure::UpdateNotPermittedDelegate);","counters":[{"col_start":23,"col_end":74,"count":0}]},{"line":"            }","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":13,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"            if let ExistingOrNew::New = source_location {","counters":[{"col_start":0,"col_end":55,"count":0}]},{"line":"                return Err(TransactionFailure::SourceNotPresent);","counters":[{"col_start":23,"col_end":64,"count":0}]},{"line":"            }","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":13,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"            let (receiver_location, _) = get_with_location(ledger, &receiver).unwrap();","counters":[{"col_start":0,"col_end":87,"count":0}]},{"line":"","counters":[]},{"line":"            if let ExistingOrNew::New = receiver_location {","counters":[{"col_start":0,"col_end":57,"count":0}]},{"line":"                return Err(TransactionFailure::ReceiverNotPresent);","counters":[{"col_start":23,"col_end":66,"count":0}]},{"line":"            }","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":13,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"            let previous_delegate = source_account.delegate.clone();","counters":[{"col_start":0,"col_end":67,"count":0}]},{"line":"            let timing = timing_error_to_user_command_status(validate_timing(","counters":[{"col_start":16,"col_end":22,"count":0},{"col_start":25,"col_end":77,"count":0}]},{"line":"                &source_account,","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"                Amount::zero(),","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"                current_global_slot,","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"            ))?;","counters":[{"col_start":0,"col_end":14,"count":0},{"col_start":14,"col_end":15,"count":0}]},{"line":"","counters":[]},{"line":"            source_account.delegate = Some(receiver.public_key.clone());","counters":[{"col_start":12,"col_end":72,"count":0}]},{"line":"            source_account.timing = timing;","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"","counters":[]},{"line":"            Ok(Updates {","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"                located_accounts: vec![(source_location, source_account)],","counters":[{"col_start":0,"col_end":74,"count":0}]},{"line":"                applied_body: signed_command_applied::Body::StakeDelegation { previous_delegate },","counters":[{"col_start":0,"col_end":98,"count":0}]},{"line":"            })","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"        }","counters":[]},{"line":"        signed_command::Body::Payment(payment) => {","counters":[{"col_start":38,"col_end":51,"count":0}]},{"line":"            let (receiver_location, mut receiver_account) =","counters":[{"col_start":0,"col_end":59,"count":0}]},{"line":"                get_with_location(ledger, &receiver).unwrap();","counters":[{"col_start":0,"col_end":62,"count":0}]},{"line":"","counters":[]},{"line":"            if !receiver_account.has_permission_to(PermissionTo::Receive) {","counters":[{"col_start":0,"col_end":73,"count":0}]},{"line":"                return Err(TransactionFailure::UpdateNotPermittedBalance);","counters":[{"col_start":23,"col_end":73,"count":0}]},{"line":"            }","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":13,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"            let mut get_source = || {","counters":[{"col_start":0,"col_end":33,"count":0},{"col_start":36,"col_end":37,"count":0}]},{"line":"                if source == receiver {","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"                    let addr = match receiver_location.clone() {","counters":[{"col_start":24,"col_end":28,"count":0},{"col_start":37,"col_end":62,"count":0}]},{"line":"                        ExistingOrNew::Existing(addr) => addr,","counters":[{"col_start":48,"col_end":61,"count":0}]},{"line":"                        ExistingOrNew::New => return Err(TransactionFailure::SourceNotPresent),","counters":[{"col_start":53,"col_end":94,"count":0}]},{"line":"                    };","counters":[]},{"line":"","counters":[]},{"line":"                    let timing = timing_error_to_user_command_status(validate_timing(","counters":[{"col_start":24,"col_end":30,"count":0},{"col_start":33,"col_end":85,"count":0}]},{"line":"                        &receiver_account,","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"                        payment.amount,","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"                        current_global_slot,","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"                    ))?;","counters":[{"col_start":0,"col_end":22,"count":0},{"col_start":22,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"                    receiver_account.timing = timing;","counters":[{"col_start":20,"col_end":53,"count":0}]},{"line":"","counters":[]},{"line":"                    Ok((ExistingOrNew::Existing(addr), receiver_account.clone()))","counters":[{"col_start":0,"col_end":81,"count":0}]},{"line":"                } else {","counters":[]},{"line":"                    let (location, mut account) = get_with_location(ledger, &source).unwrap();","counters":[{"col_start":25,"col_end":94,"count":0}]},{"line":"","counters":[]},{"line":"                    if let ExistingOrNew::New = location {","counters":[{"col_start":0,"col_end":56,"count":0}]},{"line":"                        return Err(TransactionFailure::SourceNotPresent);","counters":[{"col_start":31,"col_end":72,"count":0}]},{"line":"                    }","counters":[{"col_start":21,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"                    let timing = timing_error_to_user_command_status(validate_timing(","counters":[{"col_start":24,"col_end":30,"count":0},{"col_start":33,"col_end":85,"count":0}]},{"line":"                        &account,","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"                        payment.amount,","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"                        current_global_slot,","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"                    ))?;","counters":[{"col_start":0,"col_end":22,"count":0},{"col_start":22,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"                    let balance = match account.balance.sub_amount(payment.amount) {","counters":[{"col_start":24,"col_end":31,"count":0},{"col_start":40,"col_end":82,"count":0}]},{"line":"                        Some(balance) => balance,","counters":[{"col_start":29,"col_end":48,"count":0}]},{"line":"                        None => return Err(TransactionFailure::SourceInsufficientBalance),","counters":[{"col_start":39,"col_end":89,"count":0}]},{"line":"                    };","counters":[]},{"line":"","counters":[]},{"line":"                    account.timing = timing;","counters":[{"col_start":20,"col_end":44,"count":0}]},{"line":"                    account.balance = balance;","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"","counters":[]},{"line":"                    Ok((location, account))","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"                }","counters":[]},{"line":"            };","counters":[{"col_start":12,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"            let (source_location, source_account) = {","counters":[{"col_start":17,"col_end":48,"count":0}]},{"line":"                // OCaml throw an exception when `fee_payer == source`.","counters":[]},{"line":"                // Here in Rust we set `reject_command` to differentiate the 3 cases (Ok, Err, exception)","counters":[]},{"line":"                //","counters":[]},{"line":"                // https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/transaction_logic/mina_transaction_logic.ml#L886-L898","counters":[]},{"line":"                let ret = get_source();","counters":[{"col_start":20,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"                // Don't process transactions with insufficient balance from the","counters":[{"col_start":0,"col_end":80,"count":0}]},{"line":"                // fee-payer.","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"                if ret.is_err() && fee_payer == &source {","counters":[{"col_start":0,"col_end":31,"count":0},{"col_start":35,"col_end":55,"count":0},{"col_start":56,"col_end":57,"count":0}]},{"line":"                    *reject_command = true;","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"                }","counters":[{"col_start":0,"col_end":17,"count":0},{"col_start":17,"col_end":18,"count":0}]},{"line":"","counters":[]},{"line":"                ret?","counters":[{"col_start":16,"col_end":19,"count":0},{"col_start":19,"col_end":20,"count":0}]},{"line":"            };","counters":[]},{"line":"","counters":[]},{"line":"            if !source_account.has_permission_to(PermissionTo::Send) {","counters":[{"col_start":15,"col_end":68,"count":0}]},{"line":"                return Err(TransactionFailure::UpdateNotPermittedBalance);","counters":[{"col_start":23,"col_end":73,"count":0}]},{"line":"            }","counters":[{"col_start":13,"col_end":14,"count":0}]},{"line":"","counters":[]},{"line":"            let receiver_amount = match &receiver_location {","counters":[{"col_start":16,"col_end":31,"count":0},{"col_start":40,"col_end":58,"count":0}]},{"line":"                ExistingOrNew::Existing(_) => payment.amount,","counters":[{"col_start":46,"col_end":60,"count":0}]},{"line":"                ExistingOrNew::New => {","counters":[]},{"line":"                    match payment","counters":[{"col_start":26,"col_end":33,"count":0}]},{"line":"                        .amount","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"                        .checked_sub(&Amount::of_fee(&constraint_constants.account_creation_fee))","counters":[{"col_start":0,"col_end":97,"count":0}]},{"line":"                    {","counters":[]},{"line":"                        Some(amount) => amount,","counters":[{"col_start":29,"col_end":46,"count":0}]},{"line":"                        None => return Err(TransactionFailure::AmountInsufficientToCreateAccount),","counters":[{"col_start":39,"col_end":97,"count":0}]},{"line":"                    }","counters":[]},{"line":"                }","counters":[]},{"line":"            };","counters":[]},{"line":"","counters":[]},{"line":"            let balance = match receiver_account.balance.add_amount(receiver_amount) {","counters":[{"col_start":16,"col_end":23,"count":0},{"col_start":32,"col_end":84,"count":0}]},{"line":"                Some(balance) => balance,","counters":[{"col_start":21,"col_end":40,"count":0}]},{"line":"                None => return Err(TransactionFailure::Overflow),","counters":[{"col_start":31,"col_end":64,"count":0}]},{"line":"            };","counters":[]},{"line":"","counters":[]},{"line":"            let new_accounts = match receiver_location {","counters":[{"col_start":16,"col_end":28,"count":0},{"col_start":37,"col_end":54,"count":0}]},{"line":"                ExistingOrNew::New => vec![receiver.clone()],","counters":[{"col_start":38,"col_end":60,"count":0}]},{"line":"                ExistingOrNew::Existing(_) => vec![],","counters":[{"col_start":46,"col_end":52,"count":0}]},{"line":"            };","counters":[]},{"line":"","counters":[]},{"line":"            receiver_account.balance = balance;","counters":[{"col_start":12,"col_end":47,"count":0}]},{"line":"","counters":[]},{"line":"            Ok(Updates {","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"                located_accounts: vec![","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"                    (receiver_location, receiver_account),","counters":[{"col_start":0,"col_end":58,"count":0}]},{"line":"                    (source_location, source_account),","counters":[{"col_start":0,"col_end":54,"count":0}]},{"line":"                ],","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"                applied_body: signed_command_applied::Body::Payments { new_accounts },","counters":[{"col_start":0,"col_end":86,"count":0}]},{"line":"            })","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"pub fn apply_user_command_unchecked<L>(","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"    constraint_constants: &ConstraintConstants,","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"    _txn_state_view: &ProtocolStateView,","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"    txn_global_slot: &Slot,","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"    ledger: &mut L,","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"    user_command: &SignedCommand,","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":") -> Result<SignedCommandApplied, String>","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"where","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"    L: LedgerIntf,","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"{","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"    let SignedCommand {","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"        payload: _,","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"        signer: signer_pk,","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"        signature: _,","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"    } = &user_command;","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"    let current_global_slot = txn_global_slot;","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"","counters":[]},{"line":"    let valid_until = user_command.valid_until();","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"    validate_time(&valid_until, current_global_slot)?;","counters":[{"col_start":0,"col_end":52,"count":0},{"col_start":52,"col_end":53,"count":0}]},{"line":"","counters":[]},{"line":"    // Fee-payer information","counters":[]},{"line":"    let fee_payer = user_command.fee_payer();","counters":[{"col_start":8,"col_end":44,"count":0}]},{"line":"    let (fee_payer_location, fee_payer_account) =","counters":[{"col_start":9,"col_end":46,"count":0}]},{"line":"        pay_fee(user_command, signer_pk, ledger, current_global_slot)?;","counters":[{"col_start":8,"col_end":69,"count":0},{"col_start":69,"col_end":70,"count":0}]},{"line":"","counters":[]},{"line":"    if !fee_payer_account.has_permission_to(PermissionTo::Send) {","counters":[{"col_start":7,"col_end":63,"count":0}]},{"line":"        return Err(TransactionFailure::UpdateNotPermittedBalance.to_string());","counters":[{"col_start":15,"col_end":77,"count":0}]},{"line":"    }","counters":[{"col_start":5,"col_end":5,"count":0},{"col_start":5,"col_end":5,"count":0},{"col_start":5,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    set_with_location(ledger, &fee_payer_location, fee_payer_account)?;","counters":[{"col_start":0,"col_end":69,"count":0},{"col_start":69,"col_end":70,"count":0}]},{"line":"","counters":[]},{"line":"    let source = user_command.source();","counters":[{"col_start":8,"col_end":39,"count":0}]},{"line":"    let receiver = user_command.receiver();","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"","counters":[]},{"line":"    let mut reject_command = false;","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"    match compute_updates(","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"        constraint_constants,","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"        source,","counters":[{"col_start":0,"col_end":15,"count":0}]},{"line":"        receiver,","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"        ledger,","counters":[{"col_start":0,"col_end":15,"count":0}]},{"line":"        current_global_slot,","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"        user_command,","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"        &fee_payer,","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"        &mut reject_command,","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"    ) {","counters":[]},{"line":"        Ok(Updates {","counters":[]},{"line":"            located_accounts,","counters":[{"col_start":12,"col_end":29,"count":0}]},{"line":"            applied_body,","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"        }) => {","counters":[]},{"line":"            for (location, account) in located_accounts {","counters":[{"col_start":17,"col_end":34,"count":0},{"col_start":39,"col_end":55,"count":0}]},{"line":"                set_with_location(ledger, &location, account)?;","counters":[{"col_start":16,"col_end":61,"count":0},{"col_start":61,"col_end":62,"count":0}]},{"line":"            }","counters":[]},{"line":"","counters":[]},{"line":"            Ok(SignedCommandApplied {","counters":[{"col_start":12,"col_end":37,"count":0}]},{"line":"                common: signed_command_applied::Common {","counters":[{"col_start":0,"col_end":56,"count":0}]},{"line":"                    user_command: WithStatus::<SignedCommand> {","counters":[{"col_start":0,"col_end":63,"count":0}]},{"line":"                        data: user_command.clone(),","counters":[{"col_start":0,"col_end":51,"count":0}]},{"line":"                        status: TransactionStatus::Applied,","counters":[{"col_start":0,"col_end":59,"count":0}]},{"line":"                    },","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"                },","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"                body: applied_body,","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"            })","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"        }","counters":[]},{"line":"        Err(failure) if !reject_command => Ok(SignedCommandApplied {","counters":[{"col_start":12,"col_end":68,"count":0}]},{"line":"            common: signed_command_applied::Common {","counters":[{"col_start":0,"col_end":52,"count":0}]},{"line":"                user_command: WithStatus::<SignedCommand> {","counters":[{"col_start":0,"col_end":59,"count":0}]},{"line":"                    data: user_command.clone(),","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"                    status: TransactionStatus::Failed(vec![vec![failure]]),","counters":[{"col_start":0,"col_end":75,"count":0}]},{"line":"                },","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"            },","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"            body: signed_command_applied::Body::Failed,","counters":[{"col_start":0,"col_end":55,"count":0}]},{"line":"        }),","counters":[{"col_start":0,"col_end":10,"count":0}]},{"line":"        Err(failure) => {","counters":[{"col_start":12,"col_end":25,"count":0}]},{"line":"            // This case occurs when an exception is throwned in OCaml","counters":[{"col_start":0,"col_end":70,"count":0}]},{"line":"            // https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/transaction_logic/mina_transaction_logic.ml#L964","counters":[{"col_start":0,"col_end":154,"count":0}]},{"line":"            assert!(reject_command);","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"            Err(failure.to_string())","counters":[{"col_start":12,"col_end":36,"count":0}]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"pub fn apply_user_command<L>(","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"    constraint_constants: &ConstraintConstants,","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"    txn_state_view: &ProtocolStateView,","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"    txn_global_slot: &Slot,","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"    ledger: &mut L,","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"    user_command: &SignedCommand,","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":") -> Result<SignedCommandApplied, String>","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"where","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"    L: LedgerIntf,","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"{","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"    apply_user_command_unchecked(","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"        constraint_constants,","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"        txn_state_view,","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"        txn_global_slot,","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"        ledger,","counters":[{"col_start":0,"col_end":15,"count":0}]},{"line":"        user_command,","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"    )","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"pub fn pay_fee<L, Loc>(","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"    user_command: &SignedCommand,","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"    signer_pk: &CompressedPubKey,","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"    ledger: &mut L,","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"    current_global_slot: &Slot,","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":") -> Result<(ExistingOrNew<Loc>, Account), String>","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"where","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"    L: LedgerIntf<Location = Loc>,","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"{","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"    let nonce = user_command.nonce();","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"    let fee_payer = user_command.fee_payer();","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"    let fee_token = user_command.fee_token();","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"","counters":[]},{"line":"    if &fee_payer.public_key != signer_pk {","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"        return Err(\"Cannot pay fees from a public key that did not sign the transaction\".into());","counters":[{"col_start":15,"col_end":96,"count":0}]},{"line":"    }","counters":[{"col_start":5,"col_end":5,"count":0},{"col_start":5,"col_end":5,"count":0},{"col_start":5,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    if fee_token != TokenId::default() {","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"        return Err(\"Cannot create transactions with fee_token different from the default\".into());","counters":[{"col_start":15,"col_end":97,"count":0}]},{"line":"    }","counters":[{"col_start":5,"col_end":5,"count":0},{"col_start":5,"col_end":5,"count":0},{"col_start":5,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pay_fee_impl(","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"        &user_command.payload,","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"        nonce,","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"        fee_payer,","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"        user_command.fee(),","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"        ledger,","counters":[{"col_start":0,"col_end":15,"count":0}]},{"line":"        current_global_slot,","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"    )","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"fn pay_fee_impl<L>(","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"    command: &SignedCommandPayload,","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"    nonce: Nonce,","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"    fee_payer: AccountId,","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"    fee: Fee,","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"    ledger: &mut L,","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"    current_global_slot: &Slot,","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":") -> Result<(ExistingOrNew<L::Location>, Account), String>","counters":[{"col_start":0,"col_end":58,"count":0}]},{"line":"where","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"    L: LedgerIntf,","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"{","counters":[{"col_start":0,"col_end":0,"count":0},{"col_start":0,"col_end":0,"count":0},{"col_start":0,"col_end":0,"count":0}]},{"line":"    // Fee-payer information","counters":[]},{"line":"    let (location, mut account) = get_with_location(ledger, &fee_payer)?;","counters":[{"col_start":9,"col_end":30,"count":0},{"col_start":34,"col_end":71,"count":0},{"col_start":71,"col_end":72,"count":0}]},{"line":"","counters":[]},{"line":"    if let ExistingOrNew::New = location {","counters":[{"col_start":11,"col_end":40,"count":0}]},{"line":"        return Err(\"The fee-payer account does not exist\".to_string());","counters":[{"col_start":15,"col_end":70,"count":0}]},{"line":"    };","counters":[{"col_start":5,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let fee = Amount::of_fee(&fee);","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"    let balance = sub_amount(account.balance, fee)?;","counters":[{"col_start":8,"col_end":15,"count":0},{"col_start":18,"col_end":50,"count":0},{"col_start":50,"col_end":51,"count":0}]},{"line":"","counters":[]},{"line":"    validate_nonces(nonce, account.nonce)?;","counters":[{"col_start":4,"col_end":41,"count":0},{"col_start":41,"col_end":42,"count":0}]},{"line":"    let timing = validate_timing(&account, fee, current_global_slot)?;","counters":[{"col_start":8,"col_end":14,"count":0},{"col_start":17,"col_end":68,"count":0},{"col_start":68,"col_end":69,"count":0}]},{"line":"","counters":[]},{"line":"    account.balance = balance;","counters":[{"col_start":4,"col_end":30,"count":0}]},{"line":"    account.nonce = account.nonce.incr(); // TODO: Not sure if OCaml wraps","counters":[{"col_start":0,"col_end":74,"count":0}]},{"line":"                                          //println!(\"pay_fee_impl prev receipt_chain_hash {:?}\", account.receipt_chain_hash);","counters":[{"col_start":0,"col_end":126,"count":0}]},{"line":"    account.receipt_chain_hash = cons_signed_command_payload(command, account.receipt_chain_hash);","counters":[{"col_start":0,"col_end":98,"count":0}]},{"line":"    //println!(\"pay_fee_impl new receipt_chain_hash {:?}\", account.receipt_chain_hash);","counters":[{"col_start":0,"col_end":87,"count":0}]},{"line":"    account.timing = timing;","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"","counters":[]},{"line":"    Ok((location, account))","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"","counters":[]},{"line":"    // in","counters":[]},{"line":"    // ( location","counters":[]},{"line":"    // , { account with","counters":[]},{"line":"    //     balance","counters":[]},{"line":"    //   ; nonce = Account.Nonce.succ account.nonce","counters":[]},{"line":"    //   ; receipt_chain_hash =","counters":[]},{"line":"    //       Receipt.Chain_hash.cons_signed_command_payload command","counters":[]},{"line":"    //         account.receipt_chain_hash","counters":[]},{"line":"    //   ; timing","counters":[]},{"line":"    //   } )","counters":[]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"pub mod transaction_union_payload {","counters":[]},{"line":"    use ark_ff::PrimeField;","counters":[]},{"line":"    use mina_hasher::{Hashable, ROInput as LegacyInput};","counters":[]},{"line":"    use mina_signer::NetworkId;","counters":[]},{"line":"","counters":[]},{"line":"    use crate::scan_state::transaction_logic::signed_command::{","counters":[]},{"line":"        PaymentPayload, StakeDelegationPayload,","counters":[]},{"line":"    };","counters":[]},{"line":"","counters":[]},{"line":"    use super::*;","counters":[]},{"line":"","counters":[]},{"line":"    #[derive(Clone)]","counters":[{"col_start":13,"col_end":18,"count":0}]},{"line":"    struct Common {","counters":[]},{"line":"        fee: Fee,","counters":[]},{"line":"        fee_token: TokenId,","counters":[]},{"line":"        fee_payer_pk: CompressedPubKey,","counters":[]},{"line":"        nonce: Nonce,","counters":[]},{"line":"        valid_until: Slot,","counters":[]},{"line":"        memo: Memo,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    #[derive(Clone, Debug)]","counters":[{"col_start":13,"col_end":14,"count":0},{"col_start":17,"col_end":18,"count":0},{"col_start":20,"col_end":21,"count":0},{"col_start":24,"col_end":25,"count":0}]},{"line":"    enum Tag {","counters":[]},{"line":"        Payment = 0,","counters":[]},{"line":"        StakeDelegation = 1,","counters":[]},{"line":"        CreateAccount = 2,","counters":[]},{"line":"        MintTokens = 3,","counters":[]},{"line":"        FeeTransfer = 4,","counters":[]},{"line":"        Coinbase = 5,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    #[derive(Clone)]","counters":[{"col_start":13,"col_end":18,"count":0}]},{"line":"    struct Body {","counters":[]},{"line":"        tag: Tag,","counters":[]},{"line":"        source_pk: CompressedPubKey,","counters":[]},{"line":"        receiver_pk: CompressedPubKey,","counters":[]},{"line":"        token_id: TokenId,","counters":[]},{"line":"        amount: Amount,","counters":[]},{"line":"        token_locked: bool,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    #[derive(Clone)]","counters":[{"col_start":13,"col_end":18,"count":0}]},{"line":"    pub struct TransactionUnionPayload {","counters":[]},{"line":"        common: Common,","counters":[]},{"line":"        body: Body,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl Hashable for TransactionUnionPayload {","counters":[]},{"line":"        type D = NetworkId;","counters":[]},{"line":"","counters":[]},{"line":"        fn to_roinput(&self) -> LegacyInput {","counters":[{"col_start":8,"col_end":45,"count":0}]},{"line":"            /*","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"                Payment transactions only use the default token-id value 1.","counters":[{"col_start":0,"col_end":75,"count":0}]},{"line":"                The old transaction format encoded the token-id as an u64,","counters":[{"col_start":0,"col_end":74,"count":0}]},{"line":"                however zkApps encode the token-id as a Fp.","counters":[{"col_start":0,"col_end":59,"count":0}]},{"line":"","counters":[]},{"line":"                For testing/fuzzing purposes we want the ability to encode","counters":[{"col_start":0,"col_end":74,"count":0}]},{"line":"                arbitrary values different from the default token-id, for this","counters":[{"col_start":0,"col_end":78,"count":0}]},{"line":"                we will extract the LS u64 of the token-id.","counters":[{"col_start":0,"col_end":59,"count":0}]},{"line":"            */","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"            let fee_token_id = self.common.fee_token.0.into_repr().0[0];","counters":[{"col_start":0,"col_end":72,"count":0}]},{"line":"            let token_id = self.body.token_id.0.into_repr().0[0];","counters":[{"col_start":0,"col_end":65,"count":0}]},{"line":"","counters":[]},{"line":"            let mut roi = LegacyInput::new()","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"                .append_field(self.common.fee_payer_pk.x)","counters":[{"col_start":0,"col_end":57,"count":0}]},{"line":"                .append_field(self.body.source_pk.x)","counters":[{"col_start":0,"col_end":52,"count":0}]},{"line":"                .append_field(self.body.receiver_pk.x)","counters":[{"col_start":0,"col_end":54,"count":0}]},{"line":"                .append_u64(self.common.fee.as_u64())","counters":[{"col_start":0,"col_end":53,"count":0}]},{"line":"                .append_u64(fee_token_id)","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"                .append_bool(self.common.fee_payer_pk.is_odd)","counters":[{"col_start":0,"col_end":61,"count":0}]},{"line":"                .append_u32(self.common.nonce.as_u32())","counters":[{"col_start":0,"col_end":55,"count":0}]},{"line":"                .append_u32(self.common.valid_until.as_u32())","counters":[{"col_start":0,"col_end":61,"count":0}]},{"line":"                .append_bytes(&self.common.memo.0);","counters":[{"col_start":0,"col_end":51,"count":0}]},{"line":"","counters":[]},{"line":"            let tag = self.body.tag.clone() as u8;","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"            for bit in [4, 2, 1] {","counters":[{"col_start":16,"col_end":19,"count":0},{"col_start":23,"col_end":32,"count":0},{"col_start":33,"col_end":34,"count":0}]},{"line":"                roi = roi.append_bool(tag & bit != 0);","counters":[{"col_start":0,"col_end":54,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"            roi.append_bool(self.body.source_pk.is_odd)","counters":[{"col_start":12,"col_end":55,"count":0}]},{"line":"                .append_bool(self.body.receiver_pk.is_odd)","counters":[{"col_start":0,"col_end":58,"count":0}]},{"line":"                .append_u64(token_id)","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"                .append_u64(self.body.amount.as_u64())","counters":[{"col_start":0,"col_end":54,"count":0}]},{"line":"                .append_bool(self.body.token_locked)","counters":[{"col_start":0,"col_end":52,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        fn domain_string(network_id: NetworkId) -> Option<String> {","counters":[{"col_start":8,"col_end":67,"count":0}]},{"line":"            // Domain strings must have length <= 20","counters":[{"col_start":0,"col_end":52,"count":0}]},{"line":"            match network_id {","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"                NetworkId::MAINNET => \"MinaSignatureMainnet\",","counters":[{"col_start":38,"col_end":60,"count":0}]},{"line":"                NetworkId::TESTNET => \"CodaSignature\",","counters":[{"col_start":38,"col_end":53,"count":0}]},{"line":"            }","counters":[]},{"line":"            .to_string()","counters":[{"col_start":13,"col_end":24,"count":0}]},{"line":"            .into()","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl TransactionUnionPayload {","counters":[]},{"line":"        pub fn of_user_command_payload(payload: &SignedCommandPayload) -> Self {","counters":[{"col_start":8,"col_end":80,"count":0}]},{"line":"            use signed_command::Body::{Payment, StakeDelegation};","counters":[{"col_start":0,"col_end":65,"count":0}]},{"line":"","counters":[]},{"line":"            Self {","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"                common: Common {","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"                    fee: payload.common.fee,","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"                    fee_token: TokenId::default(),","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"                    fee_payer_pk: payload.common.fee_payer_pk.clone(),","counters":[{"col_start":0,"col_end":70,"count":0}]},{"line":"                    nonce: payload.common.nonce,","counters":[{"col_start":0,"col_end":48,"count":0}]},{"line":"                    valid_until: payload.common.valid_until,","counters":[{"col_start":0,"col_end":60,"count":0}]},{"line":"                    memo: payload.common.memo.clone(),","counters":[{"col_start":0,"col_end":54,"count":0}]},{"line":"                },","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"                body: match &payload.body {","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"                    Payment(PaymentPayload {","counters":[]},{"line":"                        source_pk,","counters":[{"col_start":24,"col_end":34,"count":0}]},{"line":"                        receiver_pk,","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"                        amount,","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"                    }) => Body {","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"                        tag: Tag::Payment,","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"                        source_pk: source_pk.clone(),","counters":[{"col_start":0,"col_end":53,"count":0}]},{"line":"                        receiver_pk: receiver_pk.clone(),","counters":[{"col_start":0,"col_end":57,"count":0}]},{"line":"                        token_id: TokenId::default(),","counters":[{"col_start":0,"col_end":53,"count":0}]},{"line":"                        amount: *amount,","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"                        token_locked: false,","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"                    },","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"                    StakeDelegation(StakeDelegationPayload::SetDelegate {","counters":[]},{"line":"                        delegator,","counters":[{"col_start":24,"col_end":34,"count":0}]},{"line":"                        new_delegate,","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"                    }) => Body {","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"                        tag: Tag::StakeDelegation,","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"                        source_pk: delegator.clone(),","counters":[{"col_start":0,"col_end":53,"count":0}]},{"line":"                        receiver_pk: new_delegate.clone(),","counters":[{"col_start":0,"col_end":58,"count":0}]},{"line":"                        token_id: TokenId::default(),","counters":[{"col_start":0,"col_end":53,"count":0}]},{"line":"                        amount: Amount::zero(),","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"                        token_locked: false,","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"                    },","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"                },","counters":[]},{"line":"            }","counters":[]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/mina_base/transaction_union_payload.ml#L309","counters":[]},{"line":"        pub fn to_input_legacy(&self) -> LegacyInput {","counters":[{"col_start":8,"col_end":54,"count":0}]},{"line":"            let mut roi = LegacyInput::new();","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"","counters":[]},{"line":"            // Self.common","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"            {","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"                roi = roi.append_u64(self.common.fee.0);","counters":[{"col_start":0,"col_end":56,"count":0}]},{"line":"","counters":[]},{"line":"                // TokenId.default","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"                // https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/mina_base/signed_command_payload.ml#L19","counters":[{"col_start":0,"col_end":149,"count":0}]},{"line":"                roi = roi.append_bool(true);","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"                for _ in 0..63 {","counters":[{"col_start":25,"col_end":30,"count":0},{"col_start":31,"col_end":32,"count":0}]},{"line":"                    roi = roi.append_bool(false);","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"                }","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"","counters":[]},{"line":"                // fee_payer_pk","counters":[]},{"line":"                roi = roi.append_field(self.common.fee_payer_pk.x);","counters":[{"col_start":16,"col_end":67,"count":0}]},{"line":"                roi = roi.append_bool(self.common.fee_payer_pk.is_odd);","counters":[{"col_start":0,"col_end":71,"count":0}]},{"line":"","counters":[]},{"line":"                // nonce","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"                roi = roi.append_u32(self.common.nonce.0);","counters":[{"col_start":0,"col_end":58,"count":0}]},{"line":"","counters":[]},{"line":"                // valid_until","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"                roi = roi.append_u32(self.common.valid_until.0);","counters":[{"col_start":0,"col_end":64,"count":0}]},{"line":"","counters":[]},{"line":"                // memo","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"                roi = roi.append_bytes(&self.common.memo.0);","counters":[{"col_start":0,"col_end":60,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"            // Self.body","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"            {","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"                // tag","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"                let tag = self.body.tag.clone() as u8;","counters":[{"col_start":0,"col_end":53,"count":0}]},{"line":"                for bit in [4, 2, 1] {","counters":[{"col_start":20,"col_end":23,"count":0},{"col_start":27,"col_end":36,"count":0},{"col_start":37,"col_end":38,"count":0}]},{"line":"                    roi = roi.append_bool(tag & bit != 0);","counters":[{"col_start":0,"col_end":58,"count":0}]},{"line":"                }","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"","counters":[]},{"line":"                // source_pk","counters":[]},{"line":"                roi = roi.append_field(self.body.source_pk.x);","counters":[{"col_start":16,"col_end":62,"count":0}]},{"line":"                roi = roi.append_bool(self.body.source_pk.is_odd);","counters":[{"col_start":0,"col_end":66,"count":0}]},{"line":"","counters":[]},{"line":"                // receiver_pk","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"                roi = roi.append_field(self.body.receiver_pk.x);","counters":[{"col_start":0,"col_end":64,"count":0}]},{"line":"                roi = roi.append_bool(self.body.receiver_pk.is_odd);","counters":[{"col_start":0,"col_end":68,"count":0}]},{"line":"","counters":[]},{"line":"                // default token_id","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"                roi = roi.append_u64(1);","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"                // amount","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"                roi = roi.append_u64(self.body.amount.0);","counters":[{"col_start":0,"col_end":57,"count":0}]},{"line":"","counters":[]},{"line":"                // token_locked","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"                roi = roi.append_bool(self.body.token_locked);","counters":[{"col_start":0,"col_end":62,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"            roi","counters":[{"col_start":0,"col_end":15,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"/// Returns the new `receipt_chain_hash`","counters":[]},{"line":"pub fn cons_signed_command_payload(","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"    command_payload: &SignedCommandPayload,","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"    last_receipt_chain_hash: ReceiptChainHash,","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":") -> ReceiptChainHash {","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"    // Note: Not sure why the use the legacy way of hashing here","counters":[{"col_start":0,"col_end":64,"count":0}]},{"line":"","counters":[]},{"line":"    use mina_hasher::ROInput as LegacyInput;","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"    let union = TransactionUnionPayload::of_user_command_payload(command_payload);","counters":[{"col_start":0,"col_end":82,"count":0}]},{"line":"","counters":[]},{"line":"    let inputs = union.to_input_legacy();","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"    let inputs = inputs.append_field(last_receipt_chain_hash.0);","counters":[{"col_start":0,"col_end":64,"count":0}]},{"line":"","counters":[]},{"line":"    use mina_hasher::{create_legacy, Hashable, Hasher, ROInput};","counters":[{"col_start":0,"col_end":64,"count":0}]},{"line":"","counters":[]},{"line":"    #[derive(Clone)]","counters":[{"col_start":0,"col_end":20,"count":0}]},{"line":"    struct MyInput(LegacyInput);","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"","counters":[]},{"line":"    impl Hashable for MyInput {","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"        type D = ();","counters":[{"col_start":0,"col_end":20,"count":0}]},{"line":"","counters":[]},{"line":"        fn to_roinput(&self) -> ROInput {","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"            self.0.clone()","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        fn domain_string(_: Self::D) -> Option<String> {","counters":[{"col_start":0,"col_end":56,"count":0}]},{"line":"            Some(\"MinaReceiptUC\".to_string())","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    let mut hasher = create_legacy::<MyInput>(());","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"    hasher.update(&MyInput(inputs));","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"    ReceiptChainHash(hasher.digest())","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"/*","counters":[]},{"line":"// TODO: This probably needs to be in its own file","counters":[]},{"line":"pub mod receipt {","counters":[]},{"line":"    use super::*;","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/mina_base/receipt.ml#L14","counters":[]},{"line":"    #[derive(Clone, Debug)]","counters":[]},{"line":"    pub enum ZkappCommandElt {","counters":[]},{"line":"        ZkappCommandCommitment(Fp),","counters":[]},{"line":"    }","counters":[]},{"line":"}","counters":[]},{"line":"*/","counters":[]},{"line":"","counters":[]},{"line":"/// prepend account_update index computed by Zkapp_command_logic.apply","counters":[]},{"line":"///","counters":[]},{"line":"/// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/mina_base/receipt.ml#L66","counters":[]},{"line":"pub fn cons_zkapp_command_commitment(","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"    index: Index,","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"    e: ZkAppCommandElt,","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"    receipt_hash: &ReceiptChainHash,","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":") -> ReceiptChainHash {","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"    let ZkAppCommandElt::ZkAppCommandCommitment(x) = e;","counters":[{"col_start":0,"col_end":55,"count":0}]},{"line":"","counters":[]},{"line":"    let mut inputs = Inputs::new();","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"    inputs.append(&index);","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"    inputs.append_field(x.0);","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"    inputs.append(receipt_hash);","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"","counters":[]},{"line":"    //println!(\"cons_zkapp_command_commitment {:?}\", inputs);","counters":[{"col_start":0,"col_end":61,"count":0}]},{"line":"","counters":[]},{"line":"    let ret = ReceiptChainHash(hash_with_kimchi(\"MinaReceiptUC\", &inputs.to_fields()));","counters":[{"col_start":0,"col_end":87,"count":0}]},{"line":"","counters":[]},{"line":"    //println!(\"cons_zkapp_command_commitment result {:?}\", ret);","counters":[{"col_start":0,"col_end":65,"count":0}]},{"line":"    ret","counters":[{"col_start":0,"col_end":7,"count":0}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"fn validate_nonces(txn_nonce: Nonce, account_nonce: Nonce) -> Result<(), String> {","counters":[{"col_start":0,"col_end":82,"count":0}]},{"line":"    if account_nonce == txn_nonce {","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"        return Ok(());","counters":[{"col_start":15,"col_end":21,"count":0}]},{"line":"    }","counters":[{"col_start":5,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    Err(format!(","counters":[{"col_start":0,"col_end":16,"count":0}]},{"line":"        \"Nonce in account {:?} different from nonce in transaction {:?}\",","counters":[{"col_start":0,"col_end":73,"count":0}]},{"line":"        account_nonce, txn_nonce,","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"    ))","counters":[{"col_start":0,"col_end":6,"count":0}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"pub fn validate_timing(","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"    account: &Account,","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"    txn_amount: Amount,","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"    txn_global_slot: &Slot,","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":") -> Result<Timing, String> {","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"    let (timing, _) = validate_timing_with_min_balance(account, txn_amount, txn_global_slot)?;","counters":[{"col_start":9,"col_end":15,"count":0},{"col_start":22,"col_end":92,"count":0},{"col_start":92,"col_end":93,"count":0}]},{"line":"","counters":[]},{"line":"    Ok(timing)","counters":[{"col_start":4,"col_end":14,"count":0}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"pub fn account_check_timing(","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"    txn_global_slot: &Slot,","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"    account: &Account,","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":") -> (TimingValidation, Timing) {","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"    let (invalid_timing, timing, _) =","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"        validate_timing_with_min_balance_impl(&account, Amount::from_u64(0), txn_global_slot);","counters":[{"col_start":0,"col_end":94,"count":0}]},{"line":"    // TODO: In OCaml the returned Timing is actually converted to None/Some(fields of Timing structure)","counters":[{"col_start":0,"col_end":104,"count":0}]},{"line":"    (invalid_timing, timing)","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"fn validate_timing_with_min_balance(","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"    account: &Account,","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"    txn_amount: Amount,","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"    txn_global_slot: &Slot,","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":") -> Result<(Timing, MinBalance), String> {","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"    use TimingValidation::*;","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"","counters":[]},{"line":"    let (possibly_error, timing, min_balance) =","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"        validate_timing_with_min_balance_impl(account, txn_amount, txn_global_slot);","counters":[{"col_start":0,"col_end":84,"count":0}]},{"line":"","counters":[]},{"line":"    match possibly_error {","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"        InsufficientBalance(true) => Err(format!(","counters":[{"col_start":37,"col_end":49,"count":0}]},{"line":"            \"For timed account, the requested transaction for amount {:?} \\","counters":[{"col_start":0,"col_end":75,"count":0}]},{"line":"             at global slot {:?}, the balance {:?} \\","counters":[{"col_start":0,"col_end":52,"count":0}]},{"line":"             is insufficient\",","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"            txn_amount, txn_global_slot, account.balance","counters":[{"col_start":0,"col_end":56,"count":0}]},{"line":"        )),","counters":[{"col_start":0,"col_end":10,"count":0}]},{"line":"        InvalidTiming(true) => Err(format!(","counters":[{"col_start":31,"col_end":43,"count":0}]},{"line":"            \"For timed account, the requested transaction for amount {:?} \\","counters":[{"col_start":0,"col_end":75,"count":0}]},{"line":"             at global slot {:?}, applying the transaction would put the \\","counters":[{"col_start":0,"col_end":74,"count":0}]},{"line":"             balance below the calculated minimum balance of {:?}\",","counters":[{"col_start":0,"col_end":67,"count":0}]},{"line":"            txn_amount, txn_global_slot, min_balance.0","counters":[{"col_start":0,"col_end":54,"count":0}]},{"line":"        )),","counters":[{"col_start":0,"col_end":10,"count":0}]},{"line":"        InsufficientBalance(false) => {","counters":[]},{"line":"            panic!(\"Broken invariant in validate_timing_with_min_balance'\")","counters":[{"col_start":12,"col_end":75,"count":0}]},{"line":"        }","counters":[]},{"line":"        InvalidTiming(false) => Ok((timing, min_balance)),","counters":[{"col_start":32,"col_end":57,"count":0}]},{"line":"    }","counters":[]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"pub fn timing_error_to_user_command_status(","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"    timing_result: Result<Timing, String>,","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":") -> Result<Timing, TransactionFailure> {","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"    match timing_result {","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"        Ok(timing) => Ok(timing),","counters":[{"col_start":11,"col_end":32,"count":0}]},{"line":"        Err(err_str) => {","counters":[{"col_start":12,"col_end":25,"count":0}]},{"line":"            /*","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"                HACK: we are matching over the full error string instead","counters":[{"col_start":0,"col_end":72,"count":0}]},{"line":"                of including an extra tag string to the Err variant","counters":[{"col_start":0,"col_end":67,"count":0}]},{"line":"            */","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"            if err_str.contains(\"minimum balance\") {","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"                return Err(TransactionFailure::SourceMinimumBalanceViolation);","counters":[{"col_start":23,"col_end":77,"count":0}]},{"line":"            }","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"            if err_str.contains(\"is insufficient\") {","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"                return Err(TransactionFailure::SourceInsufficientBalance);","counters":[{"col_start":23,"col_end":73,"count":0}]},{"line":"            }","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"            panic!(\"Unexpected timed account validation error\")","counters":[{"col_start":0,"col_end":63,"count":0}]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"pub enum TimingValidation {","counters":[]},{"line":"    InsufficientBalance(bool),","counters":[]},{"line":"    InvalidTiming(bool),","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"#[derive(Debug)]","counters":[{"col_start":9,"col_end":14,"count":0}]},{"line":"struct MinBalance(Balance);","counters":[]},{"line":"","counters":[]},{"line":"fn validate_timing_with_min_balance_impl(","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"    account: &Account,","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"    txn_amount: Amount,","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"    txn_global_slot: &Slot,","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":") -> (TimingValidation, Timing, MinBalance) {","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"    use crate::Timing::*;","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"    use TimingValidation::*;","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"","counters":[]},{"line":"    match &account.timing {","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"        Untimed => {","counters":[]},{"line":"            // no time restrictions","counters":[]},{"line":"            match account.balance.sub_amount(txn_amount) {","counters":[{"col_start":18,"col_end":56,"count":0}]},{"line":"                None => (","counters":[{"col_start":24,"col_end":25,"count":0}]},{"line":"                    InsufficientBalance(true),","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"                    Untimed,","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"                    MinBalance(Balance::zero()),","counters":[{"col_start":0,"col_end":48,"count":0}]},{"line":"                ),","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"                Some(_) => (InvalidTiming(false), Untimed, MinBalance(Balance::zero())),","counters":[{"col_start":27,"col_end":87,"count":0}]},{"line":"            }","counters":[]},{"line":"        }","counters":[]},{"line":"        Timed {","counters":[]},{"line":"            initial_minimum_balance,","counters":[{"col_start":12,"col_end":36,"count":0}]},{"line":"            cliff_time,","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"            cliff_amount,","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"            vesting_period,","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"            vesting_increment,","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"        } => {","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"            let account_balance = account.balance;","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"            let initial_minimum_balance = initial_minimum_balance;","counters":[{"col_start":0,"col_end":65,"count":0}]},{"line":"","counters":[]},{"line":"            let (invalid_balance, invalid_timing, curr_min_balance) =","counters":[{"col_start":17,"col_end":66,"count":0}]},{"line":"                match account_balance.sub_amount(txn_amount) {","counters":[{"col_start":22,"col_end":60,"count":0}]},{"line":"                    None => {","counters":[]},{"line":"                        // NB: The [initial_minimum_balance] here is the incorrect value,","counters":[]},{"line":"                        // but:","counters":[]},{"line":"                        // * we don't use it anywhere in this error case; and","counters":[]},{"line":"                        // * we don't want to waste time computing it if it will be unused.","counters":[]},{"line":"                        (true, false, *initial_minimum_balance)","counters":[{"col_start":24,"col_end":63,"count":0}]},{"line":"                    }","counters":[]},{"line":"                    Some(proposed_new_balance) => {","counters":[{"col_start":25,"col_end":51,"count":0}]},{"line":"                        let cliff_time = cliff_time;","counters":[{"col_start":0,"col_end":52,"count":0}]},{"line":"                        let cliff_amount = cliff_amount;","counters":[{"col_start":0,"col_end":56,"count":0}]},{"line":"                        let vesting_period = vesting_period;","counters":[{"col_start":0,"col_end":60,"count":0}]},{"line":"                        let vesting_increment = vesting_increment;","counters":[{"col_start":0,"col_end":66,"count":0}]},{"line":"","counters":[]},{"line":"                        let curr_min_balance = account_min_balance_at_slot(","counters":[{"col_start":0,"col_end":75,"count":0}]},{"line":"                            *txn_global_slot,","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"                            *cliff_time,","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"                            *cliff_amount,","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"                            *vesting_period,","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"                            *vesting_increment,","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"                            *initial_minimum_balance,","counters":[{"col_start":0,"col_end":53,"count":0}]},{"line":"                        );","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"","counters":[]},{"line":"                        if proposed_new_balance < curr_min_balance {","counters":[{"col_start":0,"col_end":66,"count":0}]},{"line":"                            (false, true, curr_min_balance)","counters":[{"col_start":28,"col_end":59,"count":0}]},{"line":"                        } else {","counters":[]},{"line":"                            (false, false, curr_min_balance)","counters":[{"col_start":28,"col_end":60,"count":0}]},{"line":"                        }","counters":[]},{"line":"                    }","counters":[]},{"line":"                };","counters":[]},{"line":"","counters":[]},{"line":"            // once the calculated minimum balance becomes zero, the account becomes untimed","counters":[]},{"line":"            let possibly_error = if invalid_balance {","counters":[{"col_start":16,"col_end":30,"count":0},{"col_start":36,"col_end":51,"count":0}]},{"line":"                InsufficientBalance(invalid_balance)","counters":[{"col_start":16,"col_end":52,"count":0}]},{"line":"            } else {","counters":[]},{"line":"                InvalidTiming(invalid_timing)","counters":[{"col_start":16,"col_end":45,"count":0}]},{"line":"            };","counters":[]},{"line":"","counters":[]},{"line":"            if curr_min_balance > Balance::zero() {","counters":[{"col_start":15,"col_end":49,"count":0}]},{"line":"                (","counters":[{"col_start":16,"col_end":17,"count":0}]},{"line":"                    possibly_error,","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"                    account.timing.clone(),","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"                    MinBalance(curr_min_balance),","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"                )","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"            } else {","counters":[]},{"line":"                (possibly_error, Untimed, MinBalance(Balance::zero()))","counters":[{"col_start":16,"col_end":70,"count":0}]},{"line":"            }","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"// TODO: This should be in `account.rs`","counters":[]},{"line":"pub fn account_min_balance_at_slot(","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"    global_slot: Slot,","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"    cliff_time: Slot,","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"    cliff_amount: Amount,","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"    vesting_period: Slot,","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"    vesting_increment: Amount,","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"    initial_minimum_balance: Balance,","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":") -> Balance {","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"    if global_slot < cliff_time {","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"        initial_minimum_balance","counters":[{"col_start":8,"col_end":31,"count":0}]},{"line":"    } else if vesting_period.is_zero() {","counters":[{"col_start":14,"col_end":38,"count":0}]},{"line":"        // If vesting period is zero then everything vests immediately at the cliff","counters":[]},{"line":"        Balance::zero()","counters":[{"col_start":8,"col_end":23,"count":0}]},{"line":"    } else {","counters":[]},{"line":"        match initial_minimum_balance.sub_amount(cliff_amount) {","counters":[{"col_start":14,"col_end":62,"count":0}]},{"line":"            None => Balance::zero(),","counters":[{"col_start":20,"col_end":35,"count":0}]},{"line":"            Some(min_balance_past_cliff) => {","counters":[{"col_start":17,"col_end":45,"count":0}]},{"line":"                // take advantage of fact that global slots are uint32's","counters":[{"col_start":0,"col_end":72,"count":0}]},{"line":"","counters":[]},{"line":"                let num_periods =","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"                    (global_slot.as_u32() - cliff_time.as_u32()) / vesting_period.as_u32();","counters":[{"col_start":0,"col_end":91,"count":0}]},{"line":"                let num_periods: u64 = num_periods.try_into().unwrap();","counters":[{"col_start":0,"col_end":70,"count":0}]},{"line":"","counters":[]},{"line":"                let vesting_decrement = {","counters":[{"col_start":20,"col_end":37,"count":0}]},{"line":"                    let vesting_increment = vesting_increment.as_u64();","counters":[{"col_start":24,"col_end":71,"count":0}]},{"line":"","counters":[]},{"line":"                    if u64::MAX","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"                        .checked_div(num_periods)","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"                        .map(|res| matches!(res.cmp(&vesting_increment), std::cmp::Ordering::Less))","counters":[{"col_start":0,"col_end":29,"count":0},{"col_start":35,"col_end":43,"count":0},{"col_start":44,"col_end":71,"count":0},{"col_start":97,"col_end":98,"count":0},{"col_start":98,"col_end":99,"count":0}]},{"line":"                        .unwrap_or(false)","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"                    {","counters":[]},{"line":"                        // The vesting decrement will overflow, use [max_int] instead.","counters":[]},{"line":"                        Amount::from_u64(u64::MAX)","counters":[{"col_start":24,"col_end":50,"count":0}]},{"line":"                    } else {","counters":[]},{"line":"                        Amount::from_u64(num_periods.checked_mul(vesting_increment).unwrap())","counters":[{"col_start":24,"col_end":93,"count":0}]},{"line":"                    }","counters":[]},{"line":"                };","counters":[]},{"line":"","counters":[]},{"line":"                match min_balance_past_cliff.sub_amount(vesting_decrement) {","counters":[{"col_start":22,"col_end":74,"count":0}]},{"line":"                    None => Balance::zero(),","counters":[{"col_start":28,"col_end":43,"count":0}]},{"line":"                    Some(amount) => amount,","counters":[{"col_start":25,"col_end":42,"count":0}]},{"line":"                }","counters":[]},{"line":"            }","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"fn sub_amount(balance: Balance, amount: Amount) -> Result<Balance, String> {","counters":[{"col_start":0,"col_end":76,"count":0}]},{"line":"    balance","counters":[{"col_start":0,"col_end":11,"count":0}]},{"line":"        .sub_amount(amount)","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"        .ok_or_else(|| \"insufficient funds\".to_string())","counters":[{"col_start":0,"col_end":20,"count":0},{"col_start":23,"col_end":55,"count":0},{"col_start":55,"col_end":56,"count":0}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"fn add_amount(balance: Balance, amount: Amount) -> Result<Balance, String> {","counters":[{"col_start":0,"col_end":76,"count":0}]},{"line":"    balance","counters":[{"col_start":0,"col_end":11,"count":0}]},{"line":"        .add_amount(amount)","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"        .ok_or_else(|| \"overflow\".to_string())","counters":[{"col_start":0,"col_end":20,"count":0},{"col_start":23,"col_end":45,"count":0},{"col_start":45,"col_end":46,"count":0}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"#[derive(Clone, Debug)]","counters":[{"col_start":9,"col_end":10,"count":0},{"col_start":13,"col_end":14,"count":0}]},{"line":"pub enum ExistingOrNew<Loc> {","counters":[]},{"line":"    Existing(Loc),","counters":[]},{"line":"    New,","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"fn get_with_location<L>(","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"    ledger: &mut L,","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"    account_id: &AccountId,","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":") -> Result<(ExistingOrNew<L::Location>, Account), String>","counters":[{"col_start":0,"col_end":58,"count":0}]},{"line":"where","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"    L: LedgerIntf,","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"{","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"    //println!(\"get_with_location -> location_of_account {:?}\", account_id);","counters":[{"col_start":0,"col_end":76,"count":0}]},{"line":"","counters":[]},{"line":"    match ledger.location_of_account(account_id) {","counters":[{"col_start":0,"col_end":48,"count":0}]},{"line":"        Some(location) => match ledger.get(&location) {","counters":[{"col_start":13,"col_end":53,"count":0}]},{"line":"            Some(account) => Ok((ExistingOrNew::Existing(location), account)),","counters":[{"col_start":17,"col_end":77,"count":0}]},{"line":"            None => panic!(\"Ledger location with no account\"),","counters":[{"col_start":20,"col_end":61,"count":0}]},{"line":"        },","counters":[]},{"line":"        None => {","counters":[]},{"line":"            //println!(\"get_with_location -> create_with {:?}\", account_id);","counters":[]},{"line":"            Ok((","counters":[{"col_start":12,"col_end":16,"count":0}]},{"line":"                ExistingOrNew::New,","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"                Account::create_with(account_id.clone(), Balance::zero()),","counters":[{"col_start":0,"col_end":74,"count":0}]},{"line":"            ))","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"pub fn get_account<L>(","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"    ledger: &mut L,","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"    account_id: AccountId,","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":") -> (Account, ExistingOrNew<L::Location>)","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"where","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"    L: LedgerIntf,","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"{","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"    let (loc, account) = get_with_location(ledger, &account_id).unwrap();","counters":[{"col_start":0,"col_end":73,"count":0}]},{"line":"    (account, loc)","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"pub fn set_account<'a, L>(","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"    l: &'a mut L,","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"    (a, loc): (Account, &ExistingOrNew<L::Location>),","counters":[{"col_start":0,"col_end":53,"count":0}]},{"line":") -> &'a mut L","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"where","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"    L: LedgerIntf,","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"{","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"    //println!(\"set_account -> set_with_location {:?} {:?}\", loc, a);","counters":[{"col_start":0,"col_end":69,"count":0}]},{"line":"    set_with_location(l, loc, a).unwrap();","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"    //println!(","counters":[{"col_start":0,"col_end":15,"count":0}]},{"line":"    //    \"set_account merkle root {:?}\",","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"    //    l.merkle_root()","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"    //);","counters":[{"col_start":0,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"    l","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"pub mod for_tests {","counters":[]},{"line":"    use std::collections::{HashMap, HashSet};","counters":[]},{"line":"","counters":[]},{"line":"    use mina_signer::Keypair;","counters":[]},{"line":"    use rand::Rng;","counters":[]},{"line":"    // use o1_utils::math::ceil_log2;","counters":[]},{"line":"","counters":[]},{"line":"    use crate::{","counters":[]},{"line":"        gen_keypair, scan_state::parallel_scan::ceil_log2,","counters":[]},{"line":"        staged_ledger::pre_diff_info::HashableCompressedPubKey, AuthRequired, Mask, Permissions,","counters":[]},{"line":"        ZkAppAccount,","counters":[]},{"line":"    };","counters":[]},{"line":"","counters":[]},{"line":"    use super::*;","counters":[]},{"line":"","counters":[]},{"line":"    const MIN_INIT_BALANCE: u64 = 8000000000;","counters":[]},{"line":"    const MAX_INIT_BALANCE: u64 = 8000000000000;","counters":[]},{"line":"    const NUM_ACCOUNTS: u64 = 10;","counters":[]},{"line":"    const NUM_TRANSACTIONS: u64 = 10;","counters":[]},{"line":"    const DEPTH: u64 = ceil_log2(NUM_ACCOUNTS + NUM_TRANSACTIONS);","counters":[]},{"line":"","counters":[]},{"line":"    #[derive(Debug, PartialEq, Eq)]","counters":[{"col_start":13,"col_end":18,"count":0},{"col_start":20,"col_end":29,"count":0}]},{"line":"    pub struct HashableKeypair(pub Keypair);","counters":[]},{"line":"","counters":[]},{"line":"    impl std::hash::Hash for HashableKeypair {","counters":[]},{"line":"        fn hash<H: std::hash::Hasher>(&self, state: &mut H) {","counters":[{"col_start":8,"col_end":61,"count":0}]},{"line":"            let compressed = self.0.public.into_compressed();","counters":[{"col_start":0,"col_end":61,"count":0}]},{"line":"            HashableCompressedPubKey(compressed).hash(state);","counters":[{"col_start":0,"col_end":61,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/transaction_logic/mina_transaction_logic.ml#L2194","counters":[]},{"line":"    #[derive(Debug)]","counters":[{"col_start":13,"col_end":18,"count":0}]},{"line":"    pub struct InitLedger(pub Vec<(Keypair, u64)>);","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/transaction_logic/mina_transaction_logic.ml#L2230","counters":[]},{"line":"    #[derive(Debug)]","counters":[{"col_start":13,"col_end":18,"count":0}]},{"line":"    pub struct TransactionSpec {","counters":[]},{"line":"        pub fee: Fee,","counters":[]},{"line":"        pub sender: (Keypair, Nonce),","counters":[]},{"line":"        pub receiver: CompressedPubKey,","counters":[]},{"line":"        pub amount: Amount,","counters":[]},{"line":"        pub receiver_is_new: bool,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/transaction_logic/mina_transaction_logic.ml#L2283","counters":[]},{"line":"    #[derive(Debug)]","counters":[{"col_start":13,"col_end":18,"count":0}]},{"line":"    pub struct TestSpec {","counters":[]},{"line":"        pub init_ledger: InitLedger,","counters":[]},{"line":"        pub specs: Vec<TransactionSpec>,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl InitLedger {","counters":[]},{"line":"        pub fn init(&self, ledger: &mut impl LedgerIntf) {","counters":[]},{"line":"            self.0.iter().for_each(|(kp, amount)| {","counters":[]},{"line":"                let (_tag, mut account, loc) = ledger","counters":[]},{"line":"                    .get_or_create(&AccountId::new(","counters":[]},{"line":"                        kp.public.into_compressed(),","counters":[]},{"line":"                        TokenId::default(),","counters":[]},{"line":"                    ))","counters":[]},{"line":"                    .unwrap();","counters":[]},{"line":"                account.balance = Balance::from_u64(*amount);","counters":[]},{"line":"                ledger.set(&loc, account);","counters":[]},{"line":"            });","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        pub fn gen() -> Self {","counters":[{"col_start":8,"col_end":30,"count":0}]},{"line":"            let mut rng = rand::thread_rng();","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"","counters":[]},{"line":"            let mut tbl = HashSet::with_capacity(256);","counters":[{"col_start":0,"col_end":54,"count":0}]},{"line":"","counters":[]},{"line":"            let init = (0..NUM_ACCOUNTS)","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"                .map(|_| {","counters":[{"col_start":0,"col_end":21,"count":0},{"col_start":25,"col_end":26,"count":0}]},{"line":"                    let kp = loop {","counters":[{"col_start":24,"col_end":26,"count":0},{"col_start":29,"col_end":35,"count":0}]},{"line":"                        let keypair = gen_keypair();","counters":[{"col_start":0,"col_end":52,"count":0}]},{"line":"                        let compressed = keypair.public.into_compressed();","counters":[{"col_start":0,"col_end":74,"count":0}]},{"line":"                        if !tbl.contains(&HashableCompressedPubKey(compressed)) {","counters":[{"col_start":0,"col_end":79,"count":0}]},{"line":"                            break keypair;","counters":[{"col_start":34,"col_end":41,"count":0}]},{"line":"                        }","counters":[{"col_start":25,"col_end":26,"count":0}]},{"line":"                    };","counters":[]},{"line":"","counters":[]},{"line":"                    let amount = rng.gen_range(MIN_INIT_BALANCE..MAX_INIT_BALANCE);","counters":[{"col_start":24,"col_end":83,"count":0}]},{"line":"                    tbl.insert(HashableCompressedPubKey(kp.public.into_compressed()));","counters":[{"col_start":0,"col_end":86,"count":0}]},{"line":"                    (kp, amount)","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"                })","counters":[{"col_start":0,"col_end":17,"count":0},{"col_start":17,"col_end":18,"count":0}]},{"line":"                .collect();","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"","counters":[]},{"line":"            Self(init)","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl TransactionSpec {","counters":[]},{"line":"        pub fn gen(init_ledger: &InitLedger, nonces: &mut HashMap<HashableKeypair, Nonce>) -> Self {","counters":[{"col_start":8,"col_end":100,"count":0}]},{"line":"            let mut rng = rand::thread_rng();","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"","counters":[]},{"line":"            let pk = |(kp, _): (Keypair, u64)| kp.public.into_compressed();","counters":[{"col_start":0,"col_end":18,"count":0},{"col_start":47,"col_end":74,"count":0}]},{"line":"","counters":[]},{"line":"            let receiver_is_new: bool = rng.gen();","counters":[{"col_start":16,"col_end":50,"count":0}]},{"line":"","counters":[]},{"line":"            let mut gen_index = || rng.gen_range(0..init_ledger.0.len().checked_sub(1).unwrap());","counters":[{"col_start":0,"col_end":29,"count":0},{"col_start":35,"col_end":96,"count":0}]},{"line":"","counters":[]},{"line":"            let receiver_index = if receiver_is_new {","counters":[{"col_start":16,"col_end":30,"count":0},{"col_start":36,"col_end":51,"count":0}]},{"line":"                None","counters":[{"col_start":16,"col_end":20,"count":0}]},{"line":"            } else {","counters":[]},{"line":"                Some(gen_index())","counters":[{"col_start":16,"col_end":33,"count":0}]},{"line":"            };","counters":[]},{"line":"","counters":[]},{"line":"            let receiver = match receiver_index {","counters":[{"col_start":16,"col_end":24,"count":0},{"col_start":33,"col_end":47,"count":0}]},{"line":"                None => gen_keypair().public.into_compressed(),","counters":[{"col_start":24,"col_end":62,"count":0}]},{"line":"                Some(i) => pk(init_ledger.0[i].clone()),","counters":[{"col_start":21,"col_end":55,"count":0}]},{"line":"            };","counters":[]},{"line":"","counters":[]},{"line":"            let sender = {","counters":[{"col_start":16,"col_end":26,"count":0}]},{"line":"                let i = match receiver_index {","counters":[{"col_start":0,"col_end":21,"count":0},{"col_start":30,"col_end":44,"count":0}]},{"line":"                    None => gen_index(),","counters":[{"col_start":28,"col_end":39,"count":0}]},{"line":"                    Some(j) => loop {","counters":[{"col_start":25,"col_end":26,"count":0},{"col_start":31,"col_end":37,"count":0}]},{"line":"                        let i = gen_index();","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"                        if i != j {","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"                            break i;","counters":[{"col_start":34,"col_end":35,"count":0}]},{"line":"                        }","counters":[{"col_start":25,"col_end":26,"count":0}]},{"line":"                    },","counters":[]},{"line":"                };","counters":[]},{"line":"                init_ledger.0[i].0.clone()","counters":[{"col_start":16,"col_end":42,"count":0}]},{"line":"            };","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"","counters":[]},{"line":"            let nonce = nonces","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"                .get(&HashableKeypair(sender.clone()))","counters":[{"col_start":0,"col_end":54,"count":0}]},{"line":"                .cloned()","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"                .unwrap();","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"","counters":[]},{"line":"            let amount = Amount::from_u64(rng.gen_range(1_000_000..100_000_000));","counters":[{"col_start":0,"col_end":81,"count":0}]},{"line":"            let fee = Fee::from_u64(rng.gen_range(1_000_000..100_000_000));","counters":[{"col_start":0,"col_end":75,"count":0}]},{"line":"","counters":[]},{"line":"            let old = nonces.get_mut(&HashableKeypair(sender.clone())).unwrap();","counters":[{"col_start":0,"col_end":80,"count":0}]},{"line":"            *old = old.incr();","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"","counters":[]},{"line":"            Self {","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"                fee,","counters":[{"col_start":0,"col_end":20,"count":0}]},{"line":"                sender: (sender, nonce),","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"                receiver,","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"                amount,","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"                receiver_is_new,","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl TestSpec {","counters":[]},{"line":"        fn mk_gen(num_transactions: Option<u64>) -> TestSpec {","counters":[{"col_start":8,"col_end":62,"count":0}]},{"line":"            let num_transactions = num_transactions.unwrap_or(NUM_TRANSACTIONS);","counters":[{"col_start":0,"col_end":80,"count":0}]},{"line":"","counters":[]},{"line":"            let init_ledger = InitLedger::gen();","counters":[{"col_start":0,"col_end":48,"count":0}]},{"line":"","counters":[]},{"line":"            let mut map = init_ledger","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"                .0","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"                .iter()","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"                .map(|(kp, _)| (HashableKeypair(kp.clone()), Nonce::zero()))","counters":[{"col_start":0,"col_end":21,"count":0},{"col_start":31,"col_end":75,"count":0},{"col_start":75,"col_end":76,"count":0}]},{"line":"                .collect();","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"","counters":[]},{"line":"            let specs = (0..num_transactions)","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"                .map(|_| TransactionSpec::gen(&init_ledger, &mut map))","counters":[{"col_start":0,"col_end":21,"count":0},{"col_start":25,"col_end":69,"count":0},{"col_start":69,"col_end":70,"count":0}]},{"line":"                .collect();","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"","counters":[]},{"line":"            Self { init_ledger, specs }","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn gen() -> Self {","counters":[{"col_start":8,"col_end":30,"count":0}]},{"line":"            Self::mk_gen(Some(NUM_TRANSACTIONS))","counters":[{"col_start":0,"col_end":48,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    #[derive(Debug)]","counters":[{"col_start":13,"col_end":18,"count":0}]},{"line":"    pub struct UpdateStatesSpec {","counters":[]},{"line":"        pub fee: Fee,","counters":[]},{"line":"        pub sender: (Keypair, Nonce),","counters":[]},{"line":"        pub fee_payer: Option<(Keypair, Nonce)>,","counters":[]},{"line":"        pub receivers: Vec<(CompressedPubKey, Amount)>,","counters":[]},{"line":"        pub amount: Amount,","counters":[]},{"line":"        pub zkapp_account_keypairs: Vec<Keypair>,","counters":[]},{"line":"        pub memo: Memo,","counters":[]},{"line":"        pub new_zkapp_account: bool,","counters":[]},{"line":"        pub snapp_update: zkapp_command::Update,","counters":[]},{"line":"        // Authorization for the update being performed","counters":[]},{"line":"        pub current_auth: AuthRequired,","counters":[]},{"line":"        pub sequence_events: Vec<Vec<Fp>>,","counters":[]},{"line":"        pub events: Vec<Vec<Fp>>,","counters":[]},{"line":"        pub call_data: Fp,","counters":[]},{"line":"        pub preconditions: Option<zkapp_command::Preconditions>,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    pub fn trivial_zkapp_account(","counters":[{"col_start":4,"col_end":33,"count":0}]},{"line":"        permissions: Option<Permissions<AuthRequired>>,","counters":[{"col_start":0,"col_end":55,"count":0}]},{"line":"        vk: VerificationKey,","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"        pk: CompressedPubKey,","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"    ) -> Account {","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"        let id = AccountId::new(pk, TokenId::default());","counters":[{"col_start":0,"col_end":56,"count":0}]},{"line":"        let mut account = Account::create_with(id, Balance::from_u64(1_000_000_000_000_000));","counters":[{"col_start":0,"col_end":93,"count":0}]},{"line":"        account.permissions = permissions.unwrap_or_else(Permissions::user_default);","counters":[{"col_start":0,"col_end":84,"count":0}]},{"line":"        account.zkapp = Some(ZkAppAccount {","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"            verification_key: Some(vk),","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"            ..Default::default()","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"        });","counters":[{"col_start":0,"col_end":11,"count":0}]},{"line":"        account","counters":[{"col_start":0,"col_end":15,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn create_trivial_zkapp_account(","counters":[{"col_start":4,"col_end":40,"count":0}]},{"line":"        permissions: Option<Permissions<AuthRequired>>,","counters":[{"col_start":0,"col_end":55,"count":0}]},{"line":"        vk: VerificationKey,","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"        ledger: &mut Mask,","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"        pk: CompressedPubKey,","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"    ) {","counters":[{"col_start":0,"col_end":7,"count":0}]},{"line":"        let id = AccountId::new(pk.clone(), TokenId::default());","counters":[{"col_start":0,"col_end":64,"count":0}]},{"line":"        let account = trivial_zkapp_account(permissions, vk, pk);","counters":[{"col_start":0,"col_end":65,"count":0}]},{"line":"        assert!(BaseLedger::location_of_account(ledger, &id).is_none());","counters":[{"col_start":0,"col_end":71,"count":0}]},{"line":"        ledger.get_or_create_account(id, account).unwrap();","counters":[{"col_start":8,"col_end":59,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"#[cfg(test)]","counters":[]},{"line":"mod tests {","counters":[]},{"line":"    use std::str::FromStr;","counters":[]},{"line":"","counters":[]},{"line":"    use o1_utils::FieldHelpers;","counters":[]},{"line":"","counters":[]},{"line":"    #[cfg(target_family = \"wasm\")]","counters":[]},{"line":"    use wasm_bindgen_test::wasm_bindgen_test as test;","counters":[]},{"line":"","counters":[]},{"line":"    use super::{","counters":[]},{"line":"        signed_command::{Body, Common, PaymentPayload},","counters":[]},{"line":"        *,","counters":[]},{"line":"    };","counters":[]},{"line":"","counters":[]},{"line":"    fn pub_key(address: &str) -> CompressedPubKey {","counters":[]},{"line":"        mina_signer::PubKey::from_address(address)","counters":[]},{"line":"            .unwrap()","counters":[]},{"line":"            .into_compressed()","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// Test using same values as here:","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3a78f0e0c1343d14e2729c8b00205baa2ec70c93/src/lib/mina_base/receipt.ml#L136","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn test_cons_receipt_hash_ocaml() {","counters":[]},{"line":"        let from = pub_key(\"B62qr71UxuyKpkSKYceCPsjw14nuaeLwWKZdMqaBMPber5AAF6nkowS\");","counters":[]},{"line":"        let to = pub_key(\"B62qnvGVnU7FXdy8GdkxL7yciZ8KattyCdq5J6mzo5NCxjgQPjL7BTH\");","counters":[]},{"line":"","counters":[]},{"line":"        let common = Common {","counters":[]},{"line":"            fee: Fee::from_u64(9758327274353182341),","counters":[]},{"line":"            fee_payer_pk: from.clone(),","counters":[]},{"line":"            nonce: Nonce::from_u32(1609569868),","counters":[]},{"line":"            valid_until: Slot::from_u32(2127252111),","counters":[]},{"line":"            memo: Memo([","counters":[]},{"line":"                1, 32, 101, 26, 225, 104, 115, 118, 55, 102, 76, 118, 108, 78, 114, 50, 0, 115,","counters":[]},{"line":"                110, 108, 53, 75, 109, 112, 50, 110, 88, 97, 76, 66, 76, 81, 235, 79,","counters":[]},{"line":"            ]),","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        let body = Body::Payment(PaymentPayload {","counters":[]},{"line":"            source_pk: from,","counters":[]},{"line":"            receiver_pk: to,","counters":[]},{"line":"            amount: Amount::from_u64(1155659205107036493),","counters":[]},{"line":"        });","counters":[]},{"line":"","counters":[]},{"line":"        let tx = SignedCommandPayload { common, body };","counters":[]},{"line":"","counters":[]},{"line":"        let prev = \"4918218371695029984164006552208340844155171097348169027410983585063546229555\";","counters":[]},{"line":"        let prev_receipt_chain_hash = ReceiptChainHash(Fp::from_str(prev).unwrap());","counters":[]},{"line":"","counters":[]},{"line":"        let next = \"11119245469205697592341599081188990695704663506019727849135180468159777463297\";","counters":[]},{"line":"        let next_receipt_chain_hash = ReceiptChainHash(Fp::from_str(next).unwrap());","counters":[]},{"line":"","counters":[]},{"line":"        let result = cons_signed_command_payload(&tx, prev_receipt_chain_hash);","counters":[]},{"line":"        assert_eq!(result, next_receipt_chain_hash);","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn test_receipt_hash_update() {","counters":[]},{"line":"        let from = pub_key(\"B62qmnY6m4c6bdgSPnQGZriSaj9vuSjsfh6qkveGTsFX3yGA5ywRaja\");","counters":[]},{"line":"        let to = pub_key(\"B62qjVQLxt9nYMWGn45mkgwYfcz8e8jvjNCBo11VKJb7vxDNwv5QLPS\");","counters":[]},{"line":"","counters":[]},{"line":"        let common = Common {","counters":[]},{"line":"            fee: Fee::from_u64(14500000),","counters":[]},{"line":"            fee_payer_pk: from.clone(),","counters":[]},{"line":"            nonce: Nonce::from_u32(15),","counters":[]},{"line":"            valid_until: Slot::from_u32(-1i32 as u32),","counters":[]},{"line":"            memo: Memo([","counters":[]},{"line":"                1, 7, 84, 104, 101, 32, 49, 48, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,","counters":[]},{"line":"                0, 0, 0, 0, 0, 0, 0, 0, 0,","counters":[]},{"line":"            ]),","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        let body = Body::Payment(PaymentPayload {","counters":[]},{"line":"            source_pk: from,","counters":[]},{"line":"            receiver_pk: to,","counters":[]},{"line":"            amount: Amount::from_u64(2354000000),","counters":[]},{"line":"        });","counters":[]},{"line":"","counters":[]},{"line":"        let tx = SignedCommandPayload { common, body };","counters":[]},{"line":"","counters":[]},{"line":"        let mut prev =","counters":[]},{"line":"            hex::decode(\"09ac04c9965b885acfc9c54141dbecfc63b2394a4532ea2c598d086b894bfb14\")","counters":[]},{"line":"                .unwrap();","counters":[]},{"line":"        prev.reverse();","counters":[]},{"line":"        let prev_receipt_chain_hash = ReceiptChainHash(Fp::from_bytes(&prev).unwrap());","counters":[]},{"line":"","counters":[]},{"line":"        let mut next =","counters":[]},{"line":"            hex::decode(\"0735169b96af4385c7345c94d4d65f83823309e95f72752d3f9d84f4282a53ac\")","counters":[]},{"line":"                .unwrap();","counters":[]},{"line":"        next.reverse();","counters":[]},{"line":"        let next_receipt_chain_hash = ReceiptChainHash(Fp::from_bytes(&next).unwrap());","counters":[]},{"line":"","counters":[]},{"line":"        let result = cons_signed_command_payload(&tx, prev_receipt_chain_hash);","counters":[]},{"line":"        assert_eq!(result, next_receipt_chain_hash);","counters":[]},{"line":"    }","counters":[]},{"line":"}","counters":[]}]}