{"filename":"src/lib/merkle_ledger/null_ledger.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"module type Inputs_intf = sig","counters":[]},{"line":"  include Base_inputs_intf.S","counters":[]},{"line":"","counters":[]},{"line":"  module Location : Location_intf.S","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Rust = Mina_tree.Rust","counters":[]},{"line":"","counters":[]},{"line":"module Make (Inputs : Inputs_intf) : sig","counters":[]},{"line":"  include","counters":[]},{"line":"    Base_ledger_intf.S","counters":[]},{"line":"      with module Addr = Inputs.Location.Addr","counters":[]},{"line":"      with module Location = Inputs.Location","counters":[]},{"line":"      with type key := Inputs.Key.t","counters":[]},{"line":"       and type token_id := Inputs.Token_id.t","counters":[]},{"line":"       and type token_id_set := Inputs.Token_id.Set.t","counters":[]},{"line":"       and type account_id := Inputs.Account_id.t","counters":[]},{"line":"       and type account_id_set := Inputs.Account_id.Set.t","counters":[]},{"line":"       and type hash := Inputs.Hash.t","counters":[]},{"line":"       and type root_hash := Inputs.Hash.t","counters":[]},{"line":"       and type account := Inputs.Account.t","counters":[]},{"line":"","counters":[]},{"line":"  val create : depth:int -> unit -> t","counters":[]},{"line":"end = struct","counters":[]},{"line":"  open Inputs","counters":[]},{"line":"","counters":[]},{"line":"  type t = { uuid : Uuid.t; depth : int } [@@deriving sexp_of]","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"","counters":[]},{"line":"  let t_of_sexp _ = failwith \"t_of_sexp unimplemented\"","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"","counters":[]},{"line":"  type index = int","counters":[]},{"line":"","counters":[]},{"line":"  module Location = Location","counters":[]},{"line":"  module Path = Merkle_path.Make (Hash)","counters":[]},{"line":"","counters":[]},{"line":"  type path = Path.t","counters":[]},{"line":"","counters":[]},{"line":"  module Addr = Location.Addr","counters":[]},{"line":"","counters":[]},{"line":"  external mask_create : int -> t = \"rust_mask_create\"","counters":[]},{"line":"","counters":[]},{"line":"  let create ~depth () =","counters":[]},{"line":"    let rust_mask = mask_create depth in","counters":[{"col_start":4,"col_end":4,"count":1}]},{"line":"    rust_mask","counters":[{"col_start":4,"col_end":4,"count":1}]},{"line":"  (* { uuid = Uuid_unix.create (); depth } *)","counters":[]},{"line":"","counters":[]},{"line":"  let remove_accounts_exn _t keys =","counters":[]},{"line":"    if List.is_empty keys then ()","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"    else failwith \"remove_accounts_exn: null ledgers cannot be mutated\"","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"  let empty_hash_at_height =","counters":[]},{"line":"    Empty_hashes.extensible_cache (module Hash) ~init_hash:Hash.empty_account","counters":[{"col_start":32,"col_end":32,"count":1}]},{"line":"","counters":[]},{"line":"  let merkle_path t location =","counters":[]},{"line":"    let location =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      if Location.is_account location then","counters":[]},{"line":"        Location.Hash (Location.to_path_exn location)","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"      else location","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"    in","counters":[]},{"line":"    assert (Location.is_hash location) ;","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"    let rec loop k =","counters":[]},{"line":"      let h = Location.height ~ledger_depth:t.depth k in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      if h >= t.depth then []","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"      else","counters":[]},{"line":"        let sibling_dir = Location.last_direction (Location.to_path_exn k) in","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":70,"col_end":70,"count":0}]},{"line":"        let hash = empty_hash_at_height h in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Direction.map sibling_dir ~left:(`Left hash) ~right:(`Right hash)","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":20,"col_end":20,"count":0}]},{"line":"        :: loop (Location.parent k)","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"    in","counters":[]},{"line":"    loop location","counters":[]},{"line":"","counters":[]},{"line":"  let merkle_root t = empty_hash_at_height t.depth","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"  let merkle_path_at_addr_exn t addr = merkle_path t (Location.Hash addr)","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"  let merkle_path_at_index_exn t index =","counters":[]},{"line":"    merkle_path_at_addr_exn t (Addr.of_int_exn ~ledger_depth:t.depth index)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"","counters":[]},{"line":"  let index_of_account_exn _t =","counters":[]},{"line":"    failwith \"index_of_account_exn: null ledgers are empty\"","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let set_at_index_exn _t =","counters":[]},{"line":"    failwith \"set_at_index_exn: null ledgers cannot be mutated\"","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let get_at_index_exn _t = failwith \"get_at_index_exn: null ledgers are empty\"","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"","counters":[]},{"line":"  let set_batch _t = failwith \"set_batch: null ledgers cannot be mutated\"","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"","counters":[]},{"line":"  let set _t = failwith \"set: null ledgers cannot be mutated\"","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"","counters":[]},{"line":"  let get _t _loc = None","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"","counters":[]},{"line":"  let get_batch _t locs = List.map locs ~f:(fun loc -> (loc, None))","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"","counters":[]},{"line":"  let get_uuid t = t.uuid","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"","counters":[]},{"line":"  let get_directory _ = None","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"","counters":[]},{"line":"  let last_filled _t = None","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"  let close _t = ()","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"","counters":[]},{"line":"  let get_or_create_account _t =","counters":[]},{"line":"    failwith \"get_or_create_account: null ledgers cannot be mutated\"","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let location_of_account _t _ = None","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"","counters":[]},{"line":"  let location_of_account_batch _t accts =","counters":[]},{"line":"    List.map accts ~f:(fun acct -> (acct, None))","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"  let accounts _t = Account_id.Set.empty","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"","counters":[]},{"line":"  let token_owner _t _tid = None","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"","counters":[]},{"line":"  let token_owners _t = Account_id.Set.empty","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"","counters":[]},{"line":"  let tokens _t _pk = Token_id.Set.empty","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"  let iteri _t ~f:_ = ()","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"  let fold_until _t ~init ~f:_ ~finish = finish init","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"","counters":[]},{"line":"  let foldi_with_ignored_accounts _t _ ~init ~f:_ = init","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"","counters":[]},{"line":"  let foldi _t ~init ~f:_ = init","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"","counters":[]},{"line":"  let to_list _t = []","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"","counters":[]},{"line":"  let make_space_for _t _tot = ()","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"","counters":[]},{"line":"  let get_all_accounts_rooted_at_exn t addr =","counters":[]},{"line":"    let first_node, last_node =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Addr.Range.subtree_range ~ledger_depth:t.depth addr","counters":[]},{"line":"    in","counters":[]},{"line":"    let first_index = Addr.to_int first_node in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let last_index = Addr.to_int last_node in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    List.(","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      zip_exn","counters":[]},{"line":"        (map","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"           ~f:(Addr.of_int_exn ~ledger_depth:t.depth)","counters":[]},{"line":"           (range first_index last_index) )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"        (init","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"           (1 lsl Addr.height ~ledger_depth:t.depth addr)","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"           ~f:(Fn.const Account.empty) ))","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"  let set_all_accounts_rooted_at_exn _t =","counters":[]},{"line":"    failwith \"set_all_accounts_rooted_at_exn: null ledgers cannot be mutated\"","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let set_batch_accounts _t =","counters":[]},{"line":"    failwith \"set_batch_accounts: null ledgers cannot be mutated\"","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let set_inner_hash_at_addr_exn _t =","counters":[]},{"line":"    failwith \"set_inner_hash_at_addr_exn: null ledgers cannot be mutated\"","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let get_inner_hash_at_addr_exn t addr =","counters":[]},{"line":"    empty_hash_at_height (Addr.height ~ledger_depth:t.depth addr)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"","counters":[]},{"line":"  let num_accounts _t = 0","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"","counters":[]},{"line":"  let depth t = t.depth","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"","counters":[]},{"line":"  let detached_signal _ = Async_kernel.Deferred.never ()","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}