{"filename":"src/lib/genesis_ledger/genesis_ledger.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Currency","counters":[]},{"line":"open Signature_lib","counters":[]},{"line":"open Mina_base","counters":[]},{"line":"module Ledger = Mina_ledger.Ledger","counters":[]},{"line":"module Intf = Intf","counters":[]},{"line":"","counters":[]},{"line":"let account_with_timing account_id balance (timing : Intf.Timing.t) =","counters":[]},{"line":"  match timing with","counters":[{"col_start":2,"col_end":2,"count":18}]},{"line":"  | Untimed ->","counters":[{"col_start":4,"col_end":4,"count":18}]},{"line":"      Account.create account_id balance","counters":[]},{"line":"  | Timed t ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let initial_minimum_balance =","counters":[]},{"line":"        Currency.Balance.of_int t.initial_minimum_balance","counters":[]},{"line":"      in","counters":[]},{"line":"      let cliff_time = Mina_numbers.Global_slot.of_int t.cliff_time in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let cliff_amount = Currency.Amount.of_int t.cliff_amount in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let vesting_increment = Currency.Amount.of_int t.vesting_increment in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let vesting_period = Mina_numbers.Global_slot.of_int t.vesting_period in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Account.create_timed account_id balance ~initial_minimum_balance","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ~cliff_time ~cliff_amount ~vesting_period ~vesting_increment","counters":[]},{"line":"      |> Or_error.ok_exn","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"module Private_accounts (Accounts : Intf.Private_accounts.S) = struct","counters":[]},{"line":"  include Accounts","counters":[]},{"line":"","counters":[]},{"line":"  let accounts =","counters":[]},{"line":"    let open Lazy.Let_syntax in","counters":[]},{"line":"    let%map accounts = accounts in","counters":[]},{"line":"    List.map accounts ~f:(fun { pk; sk; balance; timing } ->","counters":[{"col_start":4,"col_end":4,"count":1}]},{"line":"        let account_id = Account_id.create pk Token_id.default in","counters":[{"col_start":8,"col_end":8,"count":18}]},{"line":"        let balance = Balance.of_formatted_string (Int.to_string balance) in","counters":[{"col_start":8,"col_end":8,"count":18},{"col_start":63,"col_end":63,"count":18}]},{"line":"        (Some sk, account_with_timing account_id balance timing) )","counters":[{"col_start":8,"col_end":8,"count":18},{"col_start":36,"col_end":36,"count":18}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Public_accounts (Accounts : Intf.Public_accounts.S) = struct","counters":[]},{"line":"  include Accounts","counters":[]},{"line":"","counters":[]},{"line":"  let accounts =","counters":[]},{"line":"    let open Lazy.Let_syntax in","counters":[]},{"line":"    let%map accounts = Accounts.accounts in","counters":[]},{"line":"    List.map accounts ~f:(fun { pk; balance; delegate; timing } ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        let account_id = Account_id.create pk Token_id.default in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let balance = Balance.of_int balance in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let base_acct = account_with_timing account_id balance timing in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        (None, { base_acct with delegate = Option.value ~default:pk delegate }) )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(** Generate a ledger using the sample keypairs from [Mina_base] with the given","counters":[]},{"line":"    balances.","counters":[]},{"line":"*)","counters":[]},{"line":"module Balances (Balances : Intf.Named_balances_intf) = struct","counters":[]},{"line":"  open Intf.Private_accounts","counters":[]},{"line":"","counters":[]},{"line":"  include Private_accounts (struct","counters":[]},{"line":"    include Balances","counters":[]},{"line":"","counters":[]},{"line":"    let accounts =","counters":[]},{"line":"      let open Lazy.Let_syntax in","counters":[]},{"line":"      let%map balances = Balances.balances","counters":[]},{"line":"      and keypairs = Key_gen.Sample_keypairs.keypairs in","counters":[]},{"line":"      List.mapi balances ~f:(fun i b ->","counters":[{"col_start":6,"col_end":6,"count":1}]},{"line":"          { balance = b","counters":[{"col_start":10,"col_end":10,"count":18}]},{"line":"          ; pk = fst keypairs.(i)","counters":[{"col_start":19,"col_end":19,"count":18}]},{"line":"          ; sk = snd keypairs.(i)","counters":[{"col_start":19,"col_end":19,"count":18}]},{"line":"          ; timing = Untimed","counters":[]},{"line":"          } )","counters":[]},{"line":"  end)","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Utils = struct","counters":[]},{"line":"  let keypair_of_account_record_exn (private_key, account) =","counters":[]},{"line":"    let open Account in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let sk_error_msg =","counters":[]},{"line":"      \"cannot access genesis ledger account private key \"","counters":[]},{"line":"      ^ \"(HINT: did you forget to compile with `--profile=test`?)\"","counters":[]},{"line":"    in","counters":[]},{"line":"    let pk_error_msg = \"failed to decompress a genesis ledger public key\" in","counters":[]},{"line":"    let private_key = Option.value_exn private_key ~message:sk_error_msg in","counters":[]},{"line":"    let public_key =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Option.value_exn","counters":[]},{"line":"        (Public_key.decompress account.Poly.Stable.Latest.public_key)","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"        ~message:pk_error_msg","counters":[]},{"line":"    in","counters":[]},{"line":"    { Keypair.public_key; private_key }","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let id_of_account_record (_private_key, account) = Account.identifier account","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"","counters":[]},{"line":"  let pk_of_account_record (_private_key, account) = Account.public_key account","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"","counters":[]},{"line":"  let find_account_record_exn ~f accounts =","counters":[]},{"line":"    List.find_exn accounts ~f:(fun (_, account) -> f account)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"","counters":[]},{"line":"  let find_new_account_record_exn_ accounts old_account_pks =","counters":[]},{"line":"    find_account_record_exn accounts ~f:(fun new_account ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        not","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (List.mem ~equal:Public_key.Compressed.equal old_account_pks","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"             (Account.public_key new_account) ) )","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"","counters":[]},{"line":"  let find_new_account_record_exn accounts old_account_pks =","counters":[]},{"line":"    find_new_account_record_exn_ accounts","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (List.map ~f:Public_key.compress old_account_pks)","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"include Utils","counters":[]},{"line":"","counters":[]},{"line":"module Make (Inputs : Intf.Ledger_input_intf) : Intf.S = struct","counters":[]},{"line":"  include Inputs","counters":[]},{"line":"","counters":[]},{"line":"  (* TODO: #1488 compute this at compile time instead of lazily *)","counters":[]},{"line":"  let t =","counters":[]},{"line":"    let open Lazy.Let_syntax in","counters":[]},{"line":"    let%map ledger, insert_accounts =","counters":[]},{"line":"      match directory with","counters":[]},{"line":"      | `Ephemeral ->","counters":[{"col_start":8,"col_end":8,"count":2}]},{"line":"          lazy (Ledger.create_ephemeral ~depth (), true)","counters":[{"col_start":15,"col_end":15,"count":1},{"col_start":38,"col_end":38,"count":1}]},{"line":"      | `New ->","counters":[{"col_start":8,"col_end":8,"count":2}]},{"line":"          lazy (Ledger.create ~depth (), true)","counters":[{"col_start":15,"col_end":15,"count":2},{"col_start":28,"col_end":28,"count":2}]},{"line":"      | `Path directory_name ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          lazy (Ledger.create ~directory_name ~depth (), false)","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"    in","counters":[]},{"line":"    if insert_accounts then","counters":[{"col_start":4,"col_end":4,"count":3}]},{"line":"      List.iter (Lazy.force accounts) ~f:(fun (_, account) ->","counters":[{"col_start":6,"col_end":6,"count":3},{"col_start":14,"col_end":14,"count":3},{"col_start":26,"col_end":26,"count":3}]},{"line":"          Ledger.create_new_account_exn ledger","counters":[{"col_start":10,"col_end":10,"count":38}]},{"line":"            (Account.identifier account)","counters":[{"col_start":30,"col_end":30,"count":38}]},{"line":"            account ) ;","counters":[]},{"line":"    ledger","counters":[{"col_start":4,"col_end":4,"count":3}]},{"line":"","counters":[]},{"line":"  include Utils","counters":[]},{"line":"","counters":[]},{"line":"  let find_account_record_exn ~f =","counters":[]},{"line":"    find_account_record_exn ~f (Lazy.force accounts)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"","counters":[]},{"line":"  let find_new_account_record_exn_ old_account_pks =","counters":[]},{"line":"    find_new_account_record_exn_ (Lazy.force accounts) old_account_pks","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"","counters":[]},{"line":"  let find_new_account_record_exn old_account_pks =","counters":[]},{"line":"    find_new_account_record_exn (Lazy.force accounts) old_account_pks","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"","counters":[]},{"line":"  let largest_account_exn =","counters":[]},{"line":"    let error_msg =","counters":[]},{"line":"      \"cannot calculate largest account in genesis ledger: \"","counters":[]},{"line":"      ^ \"genesis ledger has no accounts\"","counters":[]},{"line":"    in","counters":[]},{"line":"    Memo.unit (fun () ->","counters":[{"col_start":12,"col_end":12,"count":4}]},{"line":"        List.max_elt (Lazy.force accounts) ~compare:(fun (_, a) (_, b) ->","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"            Balance.compare a.balance b.balance )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"        |> Option.value_exn ?here:None ?error:None ~message:error_msg )","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"","counters":[]},{"line":"  let largest_account_id_exn =","counters":[]},{"line":"    Memo.unit (fun () -> largest_account_exn () |> id_of_account_record)","counters":[{"col_start":12,"col_end":12,"count":4},{"col_start":25,"col_end":25,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"","counters":[]},{"line":"  let largest_account_pk_exn =","counters":[]},{"line":"    Memo.unit (fun () -> largest_account_exn () |> pk_of_account_record)","counters":[{"col_start":12,"col_end":12,"count":4},{"col_start":25,"col_end":25,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"","counters":[]},{"line":"  let largest_account_keypair_exn =","counters":[]},{"line":"    Memo.unit (fun () -> keypair_of_account_record_exn (largest_account_exn ()))","counters":[{"col_start":12,"col_end":12,"count":4},{"col_start":25,"col_end":25,"count":0},{"col_start":74,"col_end":74,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Packed = struct","counters":[]},{"line":"  type t = (module Intf.S)","counters":[]},{"line":"","counters":[]},{"line":"  let t ((module L) : t) = L.t","counters":[{"col_start":27,"col_end":27,"count":4}]},{"line":"","counters":[]},{"line":"  let depth ((module L) : t) = L.depth","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"","counters":[]},{"line":"  let accounts ((module L) : t) = L.accounts","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"","counters":[]},{"line":"  let find_account_record_exn ((module L) : t) = L.find_account_record_exn","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"","counters":[]},{"line":"  let find_new_account_record_exn_ ((module L) : t) =","counters":[]},{"line":"    L.find_new_account_record_exn_","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let find_new_account_record_exn ((module L) : t) =","counters":[]},{"line":"    L.find_new_account_record_exn","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let largest_account_exn ((module L) : t) = L.largest_account_exn ()","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"","counters":[]},{"line":"  let largest_account_id_exn ((module L) : t) = L.largest_account_id_exn ()","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"","counters":[]},{"line":"  let largest_account_pk_exn ((module L) : t) = L.largest_account_pk_exn ()","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"","counters":[]},{"line":"  let largest_account_keypair_exn ((module L) : t) =","counters":[]},{"line":"    L.largest_account_keypair_exn ()","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Of_ledger (T : sig","counters":[]},{"line":"  val t : Ledger.t Lazy.t","counters":[]},{"line":"","counters":[]},{"line":"  val depth : int","counters":[]},{"line":"end) : Intf.S = struct","counters":[]},{"line":"  include T","counters":[]},{"line":"","counters":[]},{"line":"  let accounts =","counters":[]},{"line":"    Lazy.map t","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"      ~f:(Ledger.foldi ~init:[] ~f:(fun _loc accs acc -> (None, acc) :: accs))","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"","counters":[]},{"line":"  include Utils","counters":[]},{"line":"","counters":[]},{"line":"  let find_account_record_exn ~f =","counters":[]},{"line":"    find_account_record_exn ~f (Lazy.force accounts)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"","counters":[]},{"line":"  let find_new_account_record_exn_ old_account_pks =","counters":[]},{"line":"    find_new_account_record_exn_ (Lazy.force accounts) old_account_pks","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"","counters":[]},{"line":"  let find_new_account_record_exn old_account_pks =","counters":[]},{"line":"    find_new_account_record_exn (Lazy.force accounts) old_account_pks","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"","counters":[]},{"line":"  let largest_account_exn =","counters":[]},{"line":"    let error_msg =","counters":[]},{"line":"      \"cannot calculate largest account in genesis ledger: \"","counters":[]},{"line":"      ^ \"genesis ledger has no accounts\"","counters":[]},{"line":"    in","counters":[]},{"line":"    Memo.unit (fun () ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"        List.max_elt (Lazy.force accounts) ~compare:(fun (_, a) (_, b) ->","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"            Balance.compare a.Account.Poly.balance b.Account.Poly.balance )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"        |> Option.value_exn ?here:None ?error:None ~message:error_msg )","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"","counters":[]},{"line":"  let largest_account_id_exn =","counters":[]},{"line":"    Memo.unit (fun () -> largest_account_exn () |> id_of_account_record)","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"","counters":[]},{"line":"  let largest_account_pk_exn =","counters":[]},{"line":"    Memo.unit (fun () -> largest_account_exn () |> pk_of_account_record)","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"","counters":[]},{"line":"  let largest_account_keypair_exn () =","counters":[]},{"line":"    failwith \"cannot access genesis ledger account private key\"","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let fetch_ledger, register_ledger =","counters":[]},{"line":"  let ledgers = ref String.Map.empty in","counters":[]},{"line":"  let register_ledger ((module Ledger : Intf.Named_accounts_intf) as l) =","counters":[]},{"line":"    ledgers := Map.add_exn !ledgers ~key:Ledger.name ~data:l","counters":[{"col_start":4,"col_end":4,"count":9},{"col_start":25,"col_end":25,"count":9}]},{"line":"  in","counters":[]},{"line":"  let fetch_ledger name = Map.find !ledgers name in","counters":[{"col_start":26,"col_end":26,"count":1}]},{"line":"  (fetch_ledger, register_ledger)","counters":[]},{"line":"","counters":[]},{"line":"let fetch_ledger_exn name = Option.value_exn (fetch_ledger name)","counters":[{"col_start":28,"col_end":28,"count":1},{"col_start":57,"col_end":57,"count":1}]},{"line":"","counters":[]},{"line":"module Register (Accounts : Intf.Named_accounts_intf) :","counters":[]},{"line":"  Intf.Named_accounts_intf = struct","counters":[]},{"line":"  let () = register_ledger (module Accounts)","counters":[{"col_start":25,"col_end":25,"count":9}]},{"line":"","counters":[]},{"line":"  include Accounts","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Testnet_postake = Register (Balances (Testnet_postake_ledger))","counters":[]},{"line":"","counters":[]},{"line":"module Testnet_postake_many_producers = Register (Balances (struct","counters":[]},{"line":"  let name = \"testnet_postake_many_producers\"","counters":[]},{"line":"","counters":[]},{"line":"  let balances =","counters":[]},{"line":"    lazy","counters":[]},{"line":"      (let high_balances = List.init 50 ~f:(Fn.const 5_000_000) in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"       let low_balances = List.init 10 ~f:(Fn.const 1_000) in","counters":[{"col_start":7,"col_end":7,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"       high_balances @ low_balances )","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"end))","counters":[]},{"line":"","counters":[]},{"line":"module Test = Register (Balances (Test_ledger))","counters":[]},{"line":"module Fuzz = Register (Balances (Fuzz_ledger))","counters":[]},{"line":"module Release = Register (Balances (Release_ledger))","counters":[]},{"line":"","counters":[]},{"line":"module Unit_test_ledger = Make (struct","counters":[]},{"line":"  include Test","counters":[]},{"line":"","counters":[]},{"line":"  let directory = `Ephemeral","counters":[]},{"line":"","counters":[]},{"line":"  let depth = Genesis_constants.Constraint_constants.for_unit_tests.ledger_depth","counters":[]},{"line":"end)","counters":[]},{"line":"","counters":[]},{"line":"let for_unit_tests : Packed.t = (module Unit_test_ledger)","counters":[]},{"line":"","counters":[]},{"line":"module Integration_tests = struct","counters":[]},{"line":"  module Delegation = Register (Balances (struct","counters":[]},{"line":"    let name = \"test_delegation\"","counters":[]},{"line":"","counters":[]},{"line":"    let balances =","counters":[]},{"line":"      lazy [ 0 (* delegatee *); 0 (* placeholder *); 5_000_000 (* delegator *) ]","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"  end))","counters":[]},{"line":"","counters":[]},{"line":"  module Five_even_stakes = Register (Balances (struct","counters":[]},{"line":"    let name = \"test_five_even_stakes\"","counters":[]},{"line":"","counters":[]},{"line":"    let balances =","counters":[]},{"line":"      lazy [ 1_000_000; 1_000_000; 1_000_000; 1_000_000; 1_000_000; 1_000 ]","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"  end))","counters":[]},{"line":"","counters":[]},{"line":"  module Split_two_stakes = Register (Balances (struct","counters":[]},{"line":"    let name = \"test_split_two_stakers\"","counters":[]},{"line":"","counters":[]},{"line":"    let balances =","counters":[]},{"line":"      lazy","counters":[]},{"line":"        (let high_balances = List.init 2 ~f:(Fn.const 5_000_000) in","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"         let low_balances = List.init 16 ~f:(Fn.const 1_000) in","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"         high_balances @ low_balances )","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"  end))","counters":[]},{"line":"","counters":[]},{"line":"  module Three_even_stakes = Register (Balances (struct","counters":[]},{"line":"    let name = \"test_three_even_stakes\"","counters":[]},{"line":"","counters":[]},{"line":"    let balances = lazy [ 1_000_000; 1_000_000; 1_000_000; 1000; 1000; 1000 ]","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"  end))","counters":[]},{"line":"end","counters":[]}]}