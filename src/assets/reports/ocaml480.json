{"filename":"src/lib/snark_params/snark_params.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Bitstring_lib","counters":[]},{"line":"open Snark_bits","counters":[]},{"line":"","counters":[]},{"line":"module Make_snarkable (Impl : Snarky_backendless.Snark_intf.S) = struct","counters":[]},{"line":"  open Impl","counters":[]},{"line":"","counters":[]},{"line":"  module type S = sig","counters":[]},{"line":"    type var","counters":[]},{"line":"","counters":[]},{"line":"    type value","counters":[]},{"line":"","counters":[]},{"line":"    val typ : (var, value) Typ.t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Bits = struct","counters":[]},{"line":"    module type Lossy =","counters":[]},{"line":"      Bits_intf.Snarkable.Lossy","counters":[]},{"line":"        with type ('a, 'b) typ := ('a, 'b) Typ.t","counters":[]},{"line":"         and type 'a checked := 'a Checked.t","counters":[]},{"line":"         and type boolean_var := Boolean.var","counters":[]},{"line":"","counters":[]},{"line":"    module type Faithful =","counters":[]},{"line":"      Bits_intf.Snarkable.Faithful","counters":[]},{"line":"        with type ('a, 'b) typ := ('a, 'b) Typ.t","counters":[]},{"line":"         and type 'a checked := 'a Checked.t","counters":[]},{"line":"         and type boolean_var := Boolean.var","counters":[]},{"line":"","counters":[]},{"line":"    module type Small =","counters":[]},{"line":"      Bits_intf.Snarkable.Small","counters":[]},{"line":"        with type ('a, 'b) typ := ('a, 'b) Typ.t","counters":[]},{"line":"         and type 'a checked := 'a Checked.t","counters":[]},{"line":"         and type boolean_var := Boolean.var","counters":[]},{"line":"         and type comparison_result := Field.Checked.comparison_result","counters":[]},{"line":"         and type field_var := Field.Var.t","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Tock0 = struct","counters":[]},{"line":"  include Crypto_params.Tock","counters":[]},{"line":"  module Snarkable = Make_snarkable (Crypto_params.Tock)","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Tick0 = struct","counters":[]},{"line":"  include Crypto_params.Tick","counters":[]},{"line":"  module Snarkable = Make_snarkable (Crypto_params.Tick)","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let%test_unit \"group-map test\" =","counters":[]},{"line":"  let params = Crypto_params.Tock.group_map_params () in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let module M = Crypto_params.Tick.Run in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  Quickcheck.test ~trials:3 Tick0.Field.gen ~f:(fun t ->","counters":[]},{"line":"      let checked_output =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        M.run_and_check (fun () ->","counters":[]},{"line":"            let x, y =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Snarky_group_map.Checked.to_group","counters":[]},{"line":"                (module M)","counters":[]},{"line":"                ~params (M.Field.constant t)","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"            in","counters":[]},{"line":"            fun () -> M.As_prover.(read_var x, read_var y) )","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":42,"col_end":42,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"        |> Or_error.ok_exn","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"      in","counters":[]},{"line":"      let ((x, y) as actual) =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Group_map.to_group (module Tick0.Field) ~params t","counters":[]},{"line":"      in","counters":[]},{"line":"      [%test_eq: Tick0.Field.t]","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"        Tick0.Field.(","counters":[]},{"line":"          (x * x * x)","counters":[]},{"line":"          + (Tick0.Inner_curve.Params.a * x)","counters":[]},{"line":"          + Tick0.Inner_curve.Params.b)","counters":[]},{"line":"        Tick0.Field.(y * y) ;","counters":[]},{"line":"      [%test_eq: Tick0.Field.t * Tick0.Field.t] checked_output actual )","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"","counters":[]},{"line":"module Make_inner_curve_scalar (Impl : Snark_intf.S) (Other_impl : Snark_intf.S) =","counters":[]},{"line":"struct","counters":[]},{"line":"  module T = Other_impl.Field","counters":[]},{"line":"","counters":[]},{"line":"  include (","counters":[]},{"line":"    T :","counters":[]},{"line":"      module type of T with module Var := T.Var and module Checked := T.Checked )","counters":[]},{"line":"","counters":[]},{"line":"  let of_bits = Other_impl.Field.project","counters":[]},{"line":"","counters":[]},{"line":"  let length_in_bits = size_in_bits","counters":[]},{"line":"","counters":[]},{"line":"  open Impl","counters":[]},{"line":"","counters":[]},{"line":"  type var = Boolean.var Bitstring.Lsb_first.t","counters":[]},{"line":"","counters":[]},{"line":"  let typ : (var, t) Typ.t =","counters":[]},{"line":"    Typ.transport_var","counters":[{"col_start":20,"col_end":20,"count":2}]},{"line":"      (Typ.transport","counters":[{"col_start":19,"col_end":19,"count":2}]},{"line":"         (Typ.list ~length:size_in_bits Boolean.typ)","counters":[{"col_start":17,"col_end":17,"count":2}]},{"line":"         ~there:unpack ~back:project )","counters":[]},{"line":"      ~there:Bitstring.Lsb_first.to_list ~back:Bitstring.Lsb_first.of_list","counters":[]},{"line":"","counters":[]},{"line":"  let gen : t Quickcheck.Generator.t =","counters":[]},{"line":"    Quickcheck.Generator.map","counters":[{"col_start":27,"col_end":27,"count":2}]},{"line":"      (Bignum_bigint.gen_incl Bignum_bigint.one","counters":[{"col_start":28,"col_end":28,"count":2}]},{"line":"         Bignum_bigint.(Other_impl.Field.size - one) )","counters":[]},{"line":"      ~f:(fun x -> Other_impl.Bigint.(to_field (of_bignum_bigint x)))","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"","counters":[]},{"line":"  let test_bit x i = Other_impl.Bigint.(test_bit (of_field x) i)","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"","counters":[]},{"line":"  module Checked = struct","counters":[]},{"line":"    let equal a b =","counters":[]},{"line":"      Bitstring_checked.equal","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (Bitstring.Lsb_first.to_list a)","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"        (Bitstring.Lsb_first.to_list b)","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"    let to_bits = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"    module Assert = struct","counters":[]},{"line":"      let equal : var -> var -> unit Checked.t =","counters":[]},{"line":"       fun a b ->","counters":[]},{"line":"        Bitstring_checked.Assert.equal","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (Bitstring.Lsb_first.to_list a)","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"          (Bitstring.Lsb_first.to_list b)","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"    end","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make_inner_curve_aux (Impl : Snark_intf.S) (Other_impl : Snark_intf.S) =","counters":[]},{"line":"struct","counters":[]},{"line":"  open Impl","counters":[]},{"line":"","counters":[]},{"line":"  type var = Field.Var.t * Field.Var.t","counters":[]},{"line":"","counters":[]},{"line":"  module Scalar = Make_inner_curve_scalar (Impl) (Other_impl)","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Tock = struct","counters":[]},{"line":"  include (","counters":[]},{"line":"    Tock0 : module type of Tock0 with module Inner_curve := Tock0.Inner_curve )","counters":[]},{"line":"","counters":[]},{"line":"  module Fq = Snarky_field_extensions.Field_extensions.F (Tock0)","counters":[]},{"line":"","counters":[]},{"line":"  module Inner_curve = struct","counters":[]},{"line":"    include Tock0.Inner_curve","counters":[]},{"line":"","counters":[]},{"line":"    include","counters":[]},{"line":"      Sexpable.Of_sexpable","counters":[]},{"line":"        (struct","counters":[]},{"line":"          type t = Field.t * Field.t [@@deriving sexp]","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"        end)","counters":[]},{"line":"        (struct","counters":[]},{"line":"          type nonrec t = t","counters":[]},{"line":"","counters":[]},{"line":"          let to_sexpable = to_affine_exn","counters":[]},{"line":"","counters":[]},{"line":"          let of_sexpable = of_affine","counters":[]},{"line":"        end)","counters":[]},{"line":"","counters":[]},{"line":"    include Make_inner_curve_aux (Tock0) (Tick0)","counters":[]},{"line":"","counters":[]},{"line":"    module Checked = struct","counters":[]},{"line":"      include","counters":[]},{"line":"        Snarky_curves.Make_weierstrass_checked (Fq) (Scalar)","counters":[]},{"line":"          (struct","counters":[]},{"line":"            include Tock0.Inner_curve","counters":[]},{"line":"          end)","counters":[]},{"line":"          (Params)","counters":[]},{"line":"          (struct","counters":[]},{"line":"            let add = None","counters":[]},{"line":"          end)","counters":[]},{"line":"","counters":[]},{"line":"      let add_known_unsafe t x = add_unsafe t (constant x)","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    let typ = Checked.typ","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Tick = struct","counters":[]},{"line":"  include (","counters":[]},{"line":"    Tick0 :","counters":[]},{"line":"      module type of Tick0","counters":[]},{"line":"        with module Field := Tick0.Field","counters":[]},{"line":"         and module Inner_curve := Tick0.Inner_curve )","counters":[]},{"line":"","counters":[]},{"line":"  module Field = struct","counters":[]},{"line":"    include Hashable.Make (Tick0.Field)","counters":[]},{"line":"    include Tick0.Field","counters":[]},{"line":"    module Bits = Bits.Make_field (Tick0.Field) (Tick0.Bigint)","counters":[]},{"line":"","counters":[]},{"line":"    let size_in_triples = Int.((size_in_bits + 2) / 3)","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Fq = Snarky_field_extensions.Field_extensions.F (Tick0)","counters":[]},{"line":"","counters":[]},{"line":"  module Inner_curve = struct","counters":[]},{"line":"    include Crypto_params.Tick.Inner_curve","counters":[]},{"line":"","counters":[]},{"line":"    include","counters":[]},{"line":"      Sexpable.Of_sexpable","counters":[]},{"line":"        (struct","counters":[]},{"line":"          type t = Field.t * Field.t [@@deriving sexp]","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"        end)","counters":[]},{"line":"        (struct","counters":[]},{"line":"          type nonrec t = t","counters":[]},{"line":"","counters":[]},{"line":"          let to_sexpable = to_affine_exn","counters":[]},{"line":"","counters":[]},{"line":"          let of_sexpable = of_affine","counters":[]},{"line":"        end)","counters":[]},{"line":"","counters":[]},{"line":"    include Make_inner_curve_aux (Tick0) (Tock0)","counters":[]},{"line":"","counters":[]},{"line":"    module Checked = struct","counters":[]},{"line":"      include","counters":[]},{"line":"        Snarky_curves.Make_weierstrass_checked (Fq) (Scalar)","counters":[]},{"line":"          (Crypto_params.Tick.Inner_curve)","counters":[]},{"line":"          (Params)","counters":[]},{"line":"          (struct","counters":[]},{"line":"            let add =","counters":[]},{"line":"              Some","counters":[]},{"line":"                (fun p1 p2 ->","counters":[]},{"line":"                  Run.make_checked (fun () ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                      Pickles.Step_main_inputs.Ops.add_fast p1 p2 ) )","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"          end)","counters":[]},{"line":"","counters":[]},{"line":"      let add_known_unsafe t x = add_unsafe t (constant x)","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    let typ = Checked.typ","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Util = Snark_util.Make (Tick0)","counters":[]},{"line":"","counters":[]},{"line":"  let m : Run.field Snarky_backendless.Snark.m = (module Run)","counters":[]},{"line":"","counters":[]},{"line":"  let make_checked c = Run.make_checked c","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(* Let n = Tick.Field.size_in_bits.","counters":[]},{"line":"   Let k = n - 3.","counters":[]},{"line":"   The reason k = n - 3 is as follows. Inside [meets_target], we compare","counters":[]},{"line":"   a value against 2^k. 2^k requires k + 1 bits. The comparison then unpacks","counters":[]},{"line":"   a (k + 1) + 1 bit number. This number cannot overflow so it is important that","counters":[]},{"line":"   k + 1 + 1 < n. Thus k < n - 2.","counters":[]},{"line":"","counters":[]},{"line":"   However, instead of using `Field.size_in_bits - 3` we choose `Field.size_in_bits - 8`","counters":[]},{"line":"   to clamp the easiness. To something not-to-quick on a personal laptop from mid 2010s.","counters":[]},{"line":"*)","counters":[]},{"line":"let target_bit_length = Tick.Field.size_in_bits - 8","counters":[]},{"line":"","counters":[]},{"line":"module type Snark_intf = Snark_intf.S","counters":[]},{"line":"","counters":[]},{"line":"module Group_map = struct","counters":[]},{"line":"  let to_group x =","counters":[]},{"line":"    Group_map.to_group (module Tick.Field) ~params:(Tock.group_map_params ()) x","counters":[{"col_start":4,"col_end":4,"count":2},{"col_start":72,"col_end":72,"count":2}]},{"line":"","counters":[]},{"line":"  module Checked = struct","counters":[]},{"line":"    let to_group x =","counters":[]},{"line":"      Snarky_group_map.Checked.to_group","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (module Tick.Run)","counters":[]},{"line":"        ~params:(Tock.group_map_params ()) x","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"  end","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":1}]}]}