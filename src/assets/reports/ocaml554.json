{"filename":"src/lib/transaction_logic/zkapp_command_logic.ml","lines":[{"line":"(* zkapp_command_logic.ml *)","counters":[]},{"line":"","counters":[]},{"line":"open Core_kernel","counters":[]},{"line":"open Mina_base","counters":[]},{"line":"","counters":[]},{"line":"module type Iffable = sig","counters":[]},{"line":"  type bool","counters":[]},{"line":"","counters":[]},{"line":"  type t","counters":[]},{"line":"","counters":[]},{"line":"  val if_ : bool -> then_:t -> else_:t -> t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type Bool_intf = sig","counters":[]},{"line":"  type t","counters":[]},{"line":"","counters":[]},{"line":"  include Iffable with type t := t and type bool := t","counters":[]},{"line":"","counters":[]},{"line":"  val true_ : t","counters":[]},{"line":"","counters":[]},{"line":"  val false_ : t","counters":[]},{"line":"","counters":[]},{"line":"  val equal : t -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"  val not : t -> t","counters":[]},{"line":"","counters":[]},{"line":"  val ( ||| ) : t -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"  val ( &&& ) : t -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"  module Assert : sig","counters":[]},{"line":"    (* [pos] is file,line,col,endcol from __POS__ *)","counters":[]},{"line":"    val is_true : pos:string * int * int * int -> t -> unit","counters":[]},{"line":"","counters":[]},{"line":"    (* [pos] is file,line,col,endcol from __POS__ *)","counters":[]},{"line":"    val any : pos:string * int * int * int -> t list -> unit","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  val display : t -> label:string -> string","counters":[]},{"line":"","counters":[]},{"line":"  val all : t list -> t","counters":[]},{"line":"","counters":[]},{"line":"  type failure_status","counters":[]},{"line":"","counters":[]},{"line":"  type failure_status_tbl","counters":[]},{"line":"","counters":[]},{"line":"  (* [pos] is file,line,col,endcol from __POS__ *)","counters":[]},{"line":"  val assert_with_failure_status_tbl :","counters":[]},{"line":"    pos:string * int * int * int -> t -> failure_status_tbl -> unit","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type Balance_intf = sig","counters":[]},{"line":"  include Iffable","counters":[]},{"line":"","counters":[]},{"line":"  type amount","counters":[]},{"line":"","counters":[]},{"line":"  type signed_amount","counters":[]},{"line":"","counters":[]},{"line":"  val sub_amount_flagged : t -> amount -> t * [ `Underflow of bool ]","counters":[]},{"line":"","counters":[]},{"line":"  val add_signed_amount_flagged : t -> signed_amount -> t * [ `Overflow of bool ]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type Receipt_chain_hash_intf = sig","counters":[]},{"line":"  include Iffable","counters":[]},{"line":"","counters":[]},{"line":"  type transaction_commitment","counters":[]},{"line":"","counters":[]},{"line":"  type index","counters":[]},{"line":"","counters":[]},{"line":"  module Elt : sig","counters":[]},{"line":"    type t","counters":[]},{"line":"","counters":[]},{"line":"    val of_transaction_commitment : transaction_commitment -> t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  val cons_zkapp_command_commitment : index -> Elt.t -> t -> t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type Amount_intf = sig","counters":[]},{"line":"  include Iffable","counters":[]},{"line":"","counters":[]},{"line":"  type unsigned = t","counters":[]},{"line":"","counters":[]},{"line":"  module Signed : sig","counters":[]},{"line":"    include Iffable with type bool := bool","counters":[]},{"line":"","counters":[]},{"line":"    val equal : t -> t -> bool","counters":[]},{"line":"","counters":[]},{"line":"    val is_pos : t -> bool","counters":[]},{"line":"","counters":[]},{"line":"    val negate : t -> t","counters":[]},{"line":"","counters":[]},{"line":"    val add_flagged : t -> t -> t * [ `Overflow of bool ]","counters":[]},{"line":"","counters":[]},{"line":"    val of_unsigned : unsigned -> t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  val zero : t","counters":[]},{"line":"","counters":[]},{"line":"  val equal : t -> t -> bool","counters":[]},{"line":"","counters":[]},{"line":"  val add_flagged : t -> t -> t * [ `Overflow of bool ]","counters":[]},{"line":"","counters":[]},{"line":"  val add_signed_flagged : t -> Signed.t -> t * [ `Overflow of bool ]","counters":[]},{"line":"","counters":[]},{"line":"  val of_constant_fee : Currency.Fee.t -> t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type Account_id_intf = sig","counters":[]},{"line":"  include Iffable","counters":[]},{"line":"","counters":[]},{"line":"  type public_key","counters":[]},{"line":"","counters":[]},{"line":"  type token_id","counters":[]},{"line":"","counters":[]},{"line":"  val invalid : t","counters":[]},{"line":"","counters":[]},{"line":"  val equal : t -> t -> bool","counters":[]},{"line":"","counters":[]},{"line":"  val create : public_key -> token_id -> t","counters":[]},{"line":"","counters":[]},{"line":"  val derive_token_id : owner:t -> token_id","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type Global_slot_intf = sig","counters":[]},{"line":"  include Iffable","counters":[]},{"line":"","counters":[]},{"line":"  val zero : t","counters":[]},{"line":"","counters":[]},{"line":"  val ( > ) : t -> t -> bool","counters":[]},{"line":"","counters":[]},{"line":"  val equal : t -> t -> bool","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type Timing_intf = sig","counters":[]},{"line":"  include Iffable","counters":[]},{"line":"","counters":[]},{"line":"  type global_slot","counters":[]},{"line":"","counters":[]},{"line":"  val vesting_period : t -> global_slot","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type Token_id_intf = sig","counters":[]},{"line":"  include Iffable","counters":[]},{"line":"","counters":[]},{"line":"  val equal : t -> t -> bool","counters":[]},{"line":"","counters":[]},{"line":"  val default : t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type Sequence_events_intf = sig","counters":[]},{"line":"  type t","counters":[]},{"line":"","counters":[]},{"line":"  type bool","counters":[]},{"line":"","counters":[]},{"line":"  type field","counters":[]},{"line":"","counters":[]},{"line":"  val is_empty : t -> bool","counters":[]},{"line":"","counters":[]},{"line":"  val push_events : field -> t -> field","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type Protocol_state_precondition_intf = sig","counters":[]},{"line":"  type t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Local_state = struct","counters":[]},{"line":"  open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type ( 'stack_frame","counters":[{"col_start":6,"col_end":6,"count":2}]},{"line":"           , 'call_stack","counters":[]},{"line":"           , 'token_id","counters":[]},{"line":"           , 'signed_amount","counters":[]},{"line":"           , 'ledger","counters":[]},{"line":"           , 'bool","counters":[]},{"line":"           , 'comm","counters":[]},{"line":"           , 'length","counters":[]},{"line":"           , 'failure_status_tbl )","counters":[]},{"line":"           t =","counters":[{"col_start":11,"col_end":11,"count":12}]},{"line":"            ( 'stack_frame","counters":[]},{"line":"            , 'call_stack","counters":[]},{"line":"            , 'token_id","counters":[]},{"line":"            , 'signed_amount","counters":[]},{"line":"            , 'ledger","counters":[]},{"line":"            , 'bool","counters":[]},{"line":"            , 'comm","counters":[]},{"line":"            , 'length","counters":[]},{"line":"            , 'failure_status_tbl )","counters":[]},{"line":"            Mina_wire_types.Mina_transaction_logic.Zkapp_command_logic","counters":[]},{"line":"            .Local_state","counters":[]},{"line":"            .V1","counters":[]},{"line":"            .t =","counters":[]},{"line":"        { stack_frame : 'stack_frame","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"        ; call_stack : 'call_stack","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"        ; transaction_commitment : 'comm","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"        ; full_transaction_commitment : 'comm","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"        ; token_id : 'token_id","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"        ; excess : 'signed_amount","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"        ; supply_increase : 'signed_amount","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"        ; ledger : 'ledger","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"        ; success : 'bool","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"        ; account_update_index : 'length","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"        ; failure_status_tbl : 'failure_status_tbl","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"        }","counters":[]},{"line":"      [@@deriving compare, equal, hash, sexp, yojson, fields, hlist]","counters":[{"col_start":67,"col_end":67,"count":5}]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  let typ stack_frame call_stack token_id excess supply_increase ledger bool","counters":[]},{"line":"      comm length failure_status_tbl =","counters":[]},{"line":"    Pickles.Impls.Step.Typ.of_hlistable","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      [ stack_frame","counters":[]},{"line":"      ; call_stack","counters":[]},{"line":"      ; comm","counters":[]},{"line":"      ; comm","counters":[]},{"line":"      ; token_id","counters":[]},{"line":"      ; excess","counters":[]},{"line":"      ; supply_increase","counters":[]},{"line":"      ; ledger","counters":[]},{"line":"      ; bool","counters":[]},{"line":"      ; length","counters":[]},{"line":"      ; failure_status_tbl","counters":[]},{"line":"      ]","counters":[]},{"line":"      ~var_to_hlist:to_hlist ~var_of_hlist:of_hlist ~value_to_hlist:to_hlist","counters":[]},{"line":"      ~value_of_hlist:of_hlist","counters":[]},{"line":"","counters":[]},{"line":"  module Value = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type t =","counters":[{"col_start":8,"col_end":8,"count":2},{"col_start":13,"col_end":13,"count":1}]},{"line":"          ( Mina_base.Stack_frame.Digest.Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":12,"col_end":12,"count":0}]},{"line":"          , Mina_base.Call_stack_digest.Stable.V1.t","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          , Token_id.Stable.V2.t","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          , ( Currency.Amount.Stable.V1.t","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":14,"col_end":14,"count":0}]},{"line":"            , Sgn.Stable.V1.t )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"            Currency.Signed_poly.Stable.V1.t","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          , Ledger_hash.Stable.V1.t","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          , bool","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          , Zkapp_command.Transaction_commitment.Stable.V1.t","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          , Mina_numbers.Index.Stable.V1.t","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          , Transaction_status.Failure.Collection.Stable.V1.t )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        [@@deriving equal, compare, hash, yojson, sexp]","counters":[{"col_start":54,"col_end":54,"count":5}]},{"line":"","counters":[]},{"line":"        let to_latest = Fn.id","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Checked = struct","counters":[]},{"line":"    open Pickles.Impls.Step","counters":[]},{"line":"","counters":[]},{"line":"    type t =","counters":[]},{"line":"      ( Stack_frame.Digest.Checked.t","counters":[]},{"line":"      , Call_stack_digest.Checked.t","counters":[]},{"line":"      , Token_id.Checked.t","counters":[]},{"line":"      , Currency.Amount.Signed.Checked.t","counters":[]},{"line":"      , Ledger_hash.var","counters":[]},{"line":"      , Boolean.var","counters":[]},{"line":"      , Zkapp_command.Transaction_commitment.Checked.t","counters":[]},{"line":"      , Mina_numbers.Index.Checked.t","counters":[]},{"line":"      , unit )","counters":[]},{"line":"      Stable.Latest.t","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type Set_or_keep_intf = sig","counters":[]},{"line":"  type _ t","counters":[]},{"line":"","counters":[]},{"line":"  type bool","counters":[]},{"line":"","counters":[]},{"line":"  val is_set : _ t -> bool","counters":[]},{"line":"","counters":[]},{"line":"  val is_keep : _ t -> bool","counters":[]},{"line":"","counters":[]},{"line":"  val set_or_keep : if_:(bool -> then_:'a -> else_:'a -> 'a) -> 'a t -> 'a -> 'a","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type Account_update_intf = sig","counters":[]},{"line":"  type t","counters":[]},{"line":"","counters":[]},{"line":"  type bool","counters":[]},{"line":"","counters":[]},{"line":"  type call_forest","counters":[]},{"line":"","counters":[]},{"line":"  type signed_amount","counters":[]},{"line":"","counters":[]},{"line":"  type transaction_commitment","counters":[]},{"line":"","counters":[]},{"line":"  type protocol_state_precondition","counters":[]},{"line":"","counters":[]},{"line":"  type public_key","counters":[]},{"line":"","counters":[]},{"line":"  type token_id","counters":[]},{"line":"","counters":[]},{"line":"  type account_id","counters":[]},{"line":"","counters":[]},{"line":"  type account","counters":[]},{"line":"","counters":[]},{"line":"  type nonce","counters":[]},{"line":"","counters":[]},{"line":"  type _ or_ignore","counters":[]},{"line":"","counters":[]},{"line":"  val balance_change : t -> signed_amount","counters":[]},{"line":"","counters":[]},{"line":"  val protocol_state_precondition : t -> protocol_state_precondition","counters":[]},{"line":"","counters":[]},{"line":"  val public_key : t -> public_key","counters":[]},{"line":"","counters":[]},{"line":"  val token_id : t -> token_id","counters":[]},{"line":"","counters":[]},{"line":"  val account_id : t -> account_id","counters":[]},{"line":"","counters":[]},{"line":"  val caller : t -> token_id","counters":[]},{"line":"","counters":[]},{"line":"  val use_full_commitment : t -> bool","counters":[]},{"line":"","counters":[]},{"line":"  val increment_nonce : t -> bool","counters":[]},{"line":"","counters":[]},{"line":"  val check_authorization :","counters":[]},{"line":"       commitment:transaction_commitment","counters":[]},{"line":"    -> calls:call_forest","counters":[]},{"line":"    -> t","counters":[]},{"line":"    -> [ `Proof_verifies of bool ] * [ `Signature_verifies of bool ]","counters":[]},{"line":"","counters":[]},{"line":"  val is_signed : t -> bool","counters":[]},{"line":"","counters":[]},{"line":"  val is_proved : t -> bool","counters":[]},{"line":"","counters":[]},{"line":"  module Update : sig","counters":[]},{"line":"    type _ set_or_keep","counters":[]},{"line":"","counters":[]},{"line":"    type timing","counters":[]},{"line":"","counters":[]},{"line":"    val timing : t -> timing set_or_keep","counters":[]},{"line":"","counters":[]},{"line":"    type field","counters":[]},{"line":"","counters":[]},{"line":"    val app_state : t -> field set_or_keep Zkapp_state.V.t","counters":[]},{"line":"","counters":[]},{"line":"    type verification_key","counters":[]},{"line":"","counters":[]},{"line":"    val verification_key : t -> verification_key set_or_keep","counters":[]},{"line":"","counters":[]},{"line":"    type sequence_events","counters":[]},{"line":"","counters":[]},{"line":"    val sequence_events : t -> sequence_events","counters":[]},{"line":"","counters":[]},{"line":"    type zkapp_uri","counters":[]},{"line":"","counters":[]},{"line":"    val zkapp_uri : t -> zkapp_uri set_or_keep","counters":[]},{"line":"","counters":[]},{"line":"    type token_symbol","counters":[]},{"line":"","counters":[]},{"line":"    val token_symbol : t -> token_symbol set_or_keep","counters":[]},{"line":"","counters":[]},{"line":"    val delegate : t -> public_key set_or_keep","counters":[]},{"line":"","counters":[]},{"line":"    type state_hash","counters":[]},{"line":"","counters":[]},{"line":"    val voting_for : t -> state_hash set_or_keep","counters":[]},{"line":"","counters":[]},{"line":"    type permissions","counters":[]},{"line":"","counters":[]},{"line":"    val permissions : t -> permissions set_or_keep","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Account_precondition : sig","counters":[]},{"line":"    val nonce : t -> nonce Zkapp_precondition.Closed_interval.t or_ignore","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type Opt_intf = sig","counters":[]},{"line":"  type bool","counters":[]},{"line":"","counters":[]},{"line":"  type 'a t","counters":[]},{"line":"","counters":[]},{"line":"  val is_some : 'a t -> bool","counters":[]},{"line":"","counters":[]},{"line":"  val map : 'a t -> f:('a -> 'b) -> 'b t","counters":[]},{"line":"","counters":[]},{"line":"  val or_default :","counters":[]},{"line":"    if_:(bool -> then_:'a -> else_:'a -> 'a) -> 'a t -> default:'a -> 'a","counters":[]},{"line":"","counters":[]},{"line":"  val or_exn : 'a t -> 'a","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type Stack_intf = sig","counters":[]},{"line":"  include Iffable","counters":[]},{"line":"","counters":[]},{"line":"  module Opt : Opt_intf with type bool := bool","counters":[]},{"line":"","counters":[]},{"line":"  type elt","counters":[]},{"line":"","counters":[]},{"line":"  val empty : unit -> t","counters":[]},{"line":"","counters":[]},{"line":"  val is_empty : t -> bool","counters":[]},{"line":"","counters":[]},{"line":"  val pop_exn : t -> elt * t","counters":[]},{"line":"","counters":[]},{"line":"  val pop : t -> (elt * t) Opt.t","counters":[]},{"line":"","counters":[]},{"line":"  val push : elt -> onto:t -> t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type Call_forest_intf = sig","counters":[]},{"line":"  include Iffable","counters":[]},{"line":"","counters":[]},{"line":"  type account_update","counters":[]},{"line":"","counters":[]},{"line":"  module Opt : Opt_intf with type bool := bool","counters":[]},{"line":"","counters":[]},{"line":"  val empty : unit -> t","counters":[]},{"line":"","counters":[]},{"line":"  val is_empty : t -> bool","counters":[]},{"line":"","counters":[]},{"line":"  val pop_exn : t -> (account_update * t) * t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type Stack_frame_intf = sig","counters":[]},{"line":"  type caller","counters":[]},{"line":"","counters":[]},{"line":"  type call_forest","counters":[]},{"line":"","counters":[]},{"line":"  include Iffable","counters":[]},{"line":"","counters":[]},{"line":"  val caller : t -> caller","counters":[]},{"line":"","counters":[]},{"line":"  val caller_caller : t -> caller","counters":[]},{"line":"","counters":[]},{"line":"  val calls : t -> call_forest","counters":[]},{"line":"","counters":[]},{"line":"  val make : caller:caller -> caller_caller:caller -> calls:call_forest -> t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type Call_stack_intf = sig","counters":[]},{"line":"  type stack_frame","counters":[]},{"line":"","counters":[]},{"line":"  include Stack_intf with type elt := stack_frame","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type Ledger_intf = sig","counters":[]},{"line":"  include Iffable","counters":[]},{"line":"","counters":[]},{"line":"  type public_key","counters":[]},{"line":"","counters":[]},{"line":"  type token_id","counters":[]},{"line":"","counters":[]},{"line":"  type account_update","counters":[]},{"line":"","counters":[]},{"line":"  type account","counters":[]},{"line":"","counters":[]},{"line":"  type inclusion_proof","counters":[]},{"line":"","counters":[]},{"line":"  val empty : depth:int -> unit -> t","counters":[]},{"line":"","counters":[]},{"line":"  val get_account : account_update -> t -> account * inclusion_proof","counters":[]},{"line":"","counters":[]},{"line":"  val set_account : t -> account * inclusion_proof -> t","counters":[]},{"line":"","counters":[]},{"line":"  val check_inclusion : t -> account * inclusion_proof -> unit","counters":[]},{"line":"","counters":[]},{"line":"  val check_account :","counters":[]},{"line":"    public_key -> token_id -> account * inclusion_proof -> [ `Is_new of bool ]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type Controller_intf = sig","counters":[]},{"line":"  include Iffable","counters":[]},{"line":"","counters":[]},{"line":"  val check : proof_verifies:bool -> signature_verifies:bool -> t -> bool","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type Account_intf = sig","counters":[]},{"line":"  type t","counters":[]},{"line":"","counters":[]},{"line":"  type bool","counters":[]},{"line":"","counters":[]},{"line":"  type public_key","counters":[]},{"line":"","counters":[]},{"line":"  type account_id","counters":[]},{"line":"","counters":[]},{"line":"  module Permissions : sig","counters":[]},{"line":"    type controller","counters":[]},{"line":"","counters":[]},{"line":"    val edit_state : t -> controller","counters":[]},{"line":"","counters":[]},{"line":"    val send : t -> controller","counters":[]},{"line":"","counters":[]},{"line":"    val receive : t -> controller","counters":[]},{"line":"","counters":[]},{"line":"    val set_delegate : t -> controller","counters":[]},{"line":"","counters":[]},{"line":"    val set_permissions : t -> controller","counters":[]},{"line":"","counters":[]},{"line":"    val set_verification_key : t -> controller","counters":[]},{"line":"","counters":[]},{"line":"    val set_zkapp_uri : t -> controller","counters":[]},{"line":"","counters":[]},{"line":"    val edit_sequence_state : t -> controller","counters":[]},{"line":"","counters":[]},{"line":"    val set_token_symbol : t -> controller","counters":[]},{"line":"","counters":[]},{"line":"    val increment_nonce : t -> controller","counters":[]},{"line":"","counters":[]},{"line":"    val set_voting_for : t -> controller","counters":[]},{"line":"","counters":[]},{"line":"    include Iffable with type bool := bool","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  type timing","counters":[]},{"line":"","counters":[]},{"line":"  type token_id","counters":[]},{"line":"","counters":[]},{"line":"  type receipt_chain_hash","counters":[]},{"line":"","counters":[]},{"line":"  val timing : t -> timing","counters":[]},{"line":"","counters":[]},{"line":"  val set_timing : t -> timing -> t","counters":[]},{"line":"","counters":[]},{"line":"  val is_timed : t -> bool","counters":[]},{"line":"","counters":[]},{"line":"  val set_token_id : t -> token_id -> t","counters":[]},{"line":"","counters":[]},{"line":"  type balance","counters":[]},{"line":"","counters":[]},{"line":"  val balance : t -> balance","counters":[]},{"line":"","counters":[]},{"line":"  val set_balance : balance -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"  type global_slot","counters":[]},{"line":"","counters":[]},{"line":"  val check_timing :","counters":[]},{"line":"       txn_global_slot:global_slot","counters":[]},{"line":"    -> t","counters":[]},{"line":"    -> [ `Invalid_timing of bool | `Insufficient_balance of bool ] * timing","counters":[]},{"line":"","counters":[]},{"line":"  val receipt_chain_hash : t -> receipt_chain_hash","counters":[]},{"line":"","counters":[]},{"line":"  val set_receipt_chain_hash : t -> receipt_chain_hash -> t","counters":[]},{"line":"","counters":[]},{"line":"  (** Fill the snapp field of the account if it's currently [None] *)","counters":[]},{"line":"  val make_zkapp : t -> t","counters":[]},{"line":"","counters":[]},{"line":"  (** If the current account has no snapp fields set, reset its snapp field to","counters":[]},{"line":"      [None].","counters":[]},{"line":"  *)","counters":[]},{"line":"  val unmake_zkapp : t -> t","counters":[]},{"line":"","counters":[]},{"line":"  val proved_state : t -> bool","counters":[]},{"line":"","counters":[]},{"line":"  val set_proved_state : bool -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"  type field","counters":[]},{"line":"","counters":[]},{"line":"  val app_state : t -> field Zkapp_state.V.t","counters":[]},{"line":"","counters":[]},{"line":"  val set_app_state : field Zkapp_state.V.t -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"  val register_verification_key : t -> unit","counters":[]},{"line":"","counters":[]},{"line":"  type verification_key","counters":[]},{"line":"","counters":[]},{"line":"  val verification_key : t -> verification_key","counters":[]},{"line":"","counters":[]},{"line":"  val set_verification_key : verification_key -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"  val last_sequence_slot : t -> global_slot","counters":[]},{"line":"","counters":[]},{"line":"  val set_last_sequence_slot : global_slot -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"  val sequence_state : t -> field Pickles_types.Vector.Vector_5.t","counters":[]},{"line":"","counters":[]},{"line":"  val set_sequence_state : field Pickles_types.Vector.Vector_5.t -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"  type zkapp_uri","counters":[]},{"line":"","counters":[]},{"line":"  val zkapp_uri : t -> zkapp_uri","counters":[]},{"line":"","counters":[]},{"line":"  val set_zkapp_uri : zkapp_uri -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"  type token_symbol","counters":[]},{"line":"","counters":[]},{"line":"  val token_symbol : t -> token_symbol","counters":[]},{"line":"","counters":[]},{"line":"  val set_token_symbol : token_symbol -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"  val public_key : t -> public_key","counters":[]},{"line":"","counters":[]},{"line":"  val set_public_key : public_key -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"  val delegate : t -> public_key","counters":[]},{"line":"","counters":[]},{"line":"  val set_delegate : public_key -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"  type nonce","counters":[]},{"line":"","counters":[]},{"line":"  val nonce : t -> nonce","counters":[]},{"line":"","counters":[]},{"line":"  val set_nonce : nonce -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"  type state_hash","counters":[]},{"line":"","counters":[]},{"line":"  val voting_for : t -> state_hash","counters":[]},{"line":"","counters":[]},{"line":"  val set_voting_for : state_hash -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"  val permissions : t -> Permissions.t","counters":[]},{"line":"","counters":[]},{"line":"  val set_permissions : Permissions.t -> t -> t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Eff = struct","counters":[]},{"line":"  type (_, _) t =","counters":[]},{"line":"    | Check_account_precondition :","counters":[]},{"line":"        (* the bool input is a new_account flag *)","counters":[]},{"line":"        'account_update","counters":[]},{"line":"        * 'account","counters":[]},{"line":"        * 'bool","counters":[]},{"line":"        * 'local_state","counters":[]},{"line":"        -> ( 'local_state","counters":[]},{"line":"           , < bool : 'bool","counters":[]},{"line":"             ; account_update : 'account_update","counters":[]},{"line":"             ; account : 'account","counters":[]},{"line":"             ; local_state : 'local_state","counters":[]},{"line":"             ; .. > )","counters":[]},{"line":"           t","counters":[]},{"line":"    | Check_protocol_state_precondition :","counters":[]},{"line":"        'protocol_state_pred * 'global_state","counters":[]},{"line":"        -> ( 'bool","counters":[]},{"line":"           , < bool : 'bool","counters":[]},{"line":"             ; global_state : 'global_state","counters":[]},{"line":"             ; protocol_state_precondition : 'protocol_state_pred","counters":[]},{"line":"             ; .. > )","counters":[]},{"line":"           t","counters":[]},{"line":"    | Init_account :","counters":[]},{"line":"        { account_update : 'account_update; account : 'account }","counters":[]},{"line":"        -> ( 'account","counters":[]},{"line":"           , < account_update : 'account_update ; account : 'account ; .. > )","counters":[]},{"line":"           t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"type 'e handler = { perform : 'r. ('r, 'e) Eff.t -> 'r }","counters":[]},{"line":"","counters":[]},{"line":"module type Inputs_intf = sig","counters":[]},{"line":"  val with_label : label:string -> (unit -> 'a) -> 'a","counters":[]},{"line":"","counters":[]},{"line":"  module Bool : Bool_intf","counters":[]},{"line":"","counters":[]},{"line":"  module Field : Iffable with type bool := Bool.t","counters":[]},{"line":"","counters":[]},{"line":"  module Amount : Amount_intf with type bool := Bool.t","counters":[]},{"line":"","counters":[]},{"line":"  module Balance :","counters":[]},{"line":"    Balance_intf","counters":[]},{"line":"      with type bool := Bool.t","counters":[]},{"line":"       and type amount := Amount.t","counters":[]},{"line":"       and type signed_amount := Amount.Signed.t","counters":[]},{"line":"","counters":[]},{"line":"  module Public_key : Iffable with type bool := Bool.t","counters":[]},{"line":"","counters":[]},{"line":"  module Token_id : Token_id_intf with type bool := Bool.t","counters":[]},{"line":"","counters":[]},{"line":"  module Account_id :","counters":[]},{"line":"    Account_id_intf","counters":[]},{"line":"      with type bool := Bool.t","counters":[]},{"line":"       and type public_key := Public_key.t","counters":[]},{"line":"       and type token_id := Token_id.t","counters":[]},{"line":"","counters":[]},{"line":"  module Set_or_keep : Set_or_keep_intf with type bool := Bool.t","counters":[]},{"line":"","counters":[]},{"line":"  module Protocol_state_precondition : Protocol_state_precondition_intf","counters":[]},{"line":"","counters":[]},{"line":"  module Controller : Controller_intf with type bool := Bool.t","counters":[]},{"line":"","counters":[]},{"line":"  module Global_slot : Global_slot_intf with type bool := Bool.t","counters":[]},{"line":"","counters":[]},{"line":"  module Nonce : sig","counters":[]},{"line":"    include Iffable with type bool := Bool.t","counters":[]},{"line":"","counters":[]},{"line":"    val succ : t -> t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module State_hash : Iffable with type bool := Bool.t","counters":[]},{"line":"","counters":[]},{"line":"  module Timing :","counters":[]},{"line":"    Timing_intf with type bool := Bool.t and type global_slot := Global_slot.t","counters":[]},{"line":"","counters":[]},{"line":"  module Verification_key : Iffable with type bool := Bool.t","counters":[]},{"line":"","counters":[]},{"line":"  module Zkapp_uri : Iffable with type bool := Bool.t","counters":[]},{"line":"","counters":[]},{"line":"  module Token_symbol : Iffable with type bool := Bool.t","counters":[]},{"line":"","counters":[]},{"line":"  module Opt : Opt_intf with type bool := Bool.t","counters":[]},{"line":"","counters":[]},{"line":"  module rec Receipt_chain_hash :","counters":[]},{"line":"    (Receipt_chain_hash_intf","counters":[]},{"line":"      with type bool := Bool.t","counters":[]},{"line":"       and type transaction_commitment := Transaction_commitment.t","counters":[]},{"line":"       and type index := Index.t)","counters":[]},{"line":"","counters":[]},{"line":"  and Account :","counters":[]},{"line":"    (Account_intf","counters":[]},{"line":"      with type Permissions.controller := Controller.t","counters":[]},{"line":"       and type timing := Timing.t","counters":[]},{"line":"       and type balance := Balance.t","counters":[]},{"line":"       and type receipt_chain_hash := Receipt_chain_hash.t","counters":[]},{"line":"       and type bool := Bool.t","counters":[]},{"line":"       and type global_slot := Global_slot.t","counters":[]},{"line":"       and type field := Field.t","counters":[]},{"line":"       and type verification_key := Verification_key.t","counters":[]},{"line":"       and type zkapp_uri := Zkapp_uri.t","counters":[]},{"line":"       and type token_symbol := Token_symbol.t","counters":[]},{"line":"       and type public_key := Public_key.t","counters":[]},{"line":"       and type nonce := Nonce.t","counters":[]},{"line":"       and type state_hash := State_hash.t","counters":[]},{"line":"       and type token_id := Token_id.t","counters":[]},{"line":"       and type account_id := Account_id.t)","counters":[]},{"line":"","counters":[]},{"line":"  and Sequence_events :","counters":[]},{"line":"    (Sequence_events_intf with type bool := Bool.t and type field := Field.t)","counters":[]},{"line":"","counters":[]},{"line":"  and Account_update :","counters":[]},{"line":"    (Account_update_intf","counters":[]},{"line":"      with type signed_amount := Amount.Signed.t","counters":[]},{"line":"       and type protocol_state_precondition := Protocol_state_precondition.t","counters":[]},{"line":"       and type token_id := Token_id.t","counters":[]},{"line":"       and type bool := Bool.t","counters":[]},{"line":"       and type account := Account.t","counters":[]},{"line":"       and type public_key := Public_key.t","counters":[]},{"line":"       and type nonce := Nonce.t","counters":[]},{"line":"       and type account_id := Account_id.t","counters":[]},{"line":"       and type Update.timing := Timing.t","counters":[]},{"line":"       and type 'a Update.set_or_keep := 'a Set_or_keep.t","counters":[]},{"line":"       and type Update.field := Field.t","counters":[]},{"line":"       and type Update.verification_key := Verification_key.t","counters":[]},{"line":"       and type Update.sequence_events := Sequence_events.t","counters":[]},{"line":"       and type Update.zkapp_uri := Zkapp_uri.t","counters":[]},{"line":"       and type Update.token_symbol := Token_symbol.t","counters":[]},{"line":"       and type Update.state_hash := State_hash.t","counters":[]},{"line":"       and type Update.permissions := Account.Permissions.t)","counters":[]},{"line":"","counters":[]},{"line":"  and Nonce_precondition : sig","counters":[]},{"line":"    val is_constant :","counters":[]},{"line":"         Nonce.t Zkapp_precondition.Closed_interval.t Account_update.or_ignore","counters":[]},{"line":"      -> Bool.t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  and Ledger :","counters":[]},{"line":"    (Ledger_intf","counters":[]},{"line":"      with type bool := Bool.t","counters":[]},{"line":"       and type account := Account.t","counters":[]},{"line":"       and type account_update := Account_update.t","counters":[]},{"line":"       and type token_id := Token_id.t","counters":[]},{"line":"       and type public_key := Public_key.t)","counters":[]},{"line":"","counters":[]},{"line":"  and Call_forest :","counters":[]},{"line":"    (Call_forest_intf","counters":[]},{"line":"      with type t = Account_update.call_forest","counters":[]},{"line":"       and type bool := Bool.t","counters":[]},{"line":"       and type account_update := Account_update.t","counters":[]},{"line":"       and module Opt := Opt)","counters":[]},{"line":"","counters":[]},{"line":"  and Stack_frame :","counters":[]},{"line":"    (Stack_frame_intf","counters":[]},{"line":"      with type bool := Bool.t","counters":[]},{"line":"       and type call_forest := Call_forest.t","counters":[]},{"line":"       and type caller := Token_id.t)","counters":[]},{"line":"","counters":[]},{"line":"  and Call_stack :","counters":[]},{"line":"    (Call_stack_intf","counters":[]},{"line":"      with type stack_frame := Stack_frame.t","counters":[]},{"line":"       and type bool := Bool.t","counters":[]},{"line":"       and module Opt := Opt)","counters":[]},{"line":"","counters":[]},{"line":"  and Transaction_commitment : sig","counters":[]},{"line":"    include","counters":[]},{"line":"      Iffable","counters":[]},{"line":"        with type bool := Bool.t","counters":[]},{"line":"         and type t = Account_update.transaction_commitment","counters":[]},{"line":"","counters":[]},{"line":"    val empty : t","counters":[]},{"line":"","counters":[]},{"line":"    val commitment : account_updates:Call_forest.t -> t","counters":[]},{"line":"","counters":[]},{"line":"    val full_commitment :","counters":[]},{"line":"      account_update:Account_update.t -> memo_hash:Field.t -> commitment:t -> t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  and Index : sig","counters":[]},{"line":"    include Iffable with type bool := Bool.t","counters":[]},{"line":"","counters":[]},{"line":"    val zero : t","counters":[]},{"line":"","counters":[]},{"line":"    val succ : t -> t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Local_state : sig","counters":[]},{"line":"    type t =","counters":[]},{"line":"      ( Stack_frame.t","counters":[]},{"line":"      , Call_stack.t","counters":[]},{"line":"      , Token_id.t","counters":[]},{"line":"      , Amount.Signed.t","counters":[]},{"line":"      , Ledger.t","counters":[]},{"line":"      , Bool.t","counters":[]},{"line":"      , Transaction_commitment.t","counters":[]},{"line":"      , Index.t","counters":[]},{"line":"      , Bool.failure_status_tbl )","counters":[]},{"line":"      Local_state.t","counters":[]},{"line":"","counters":[]},{"line":"    val add_check : t -> Transaction_status.Failure.t -> Bool.t -> t","counters":[]},{"line":"","counters":[]},{"line":"    val update_failure_status_tbl : t -> Bool.failure_status -> Bool.t -> t","counters":[]},{"line":"","counters":[]},{"line":"    val add_new_failure_status_bucket : t -> t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Global_state : sig","counters":[]},{"line":"    type t","counters":[]},{"line":"","counters":[]},{"line":"    val ledger : t -> Ledger.t","counters":[]},{"line":"","counters":[]},{"line":"    val set_ledger : should_update:Bool.t -> t -> Ledger.t -> t","counters":[]},{"line":"","counters":[]},{"line":"    val fee_excess : t -> Amount.Signed.t","counters":[]},{"line":"","counters":[]},{"line":"    val set_fee_excess : t -> Amount.Signed.t -> t","counters":[]},{"line":"","counters":[]},{"line":"    val supply_increase : t -> Amount.Signed.t","counters":[]},{"line":"","counters":[]},{"line":"    val set_supply_increase : t -> Amount.Signed.t -> t","counters":[]},{"line":"","counters":[]},{"line":"    val global_slot_since_genesis : t -> Global_slot.t","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Start_data = struct","counters":[]},{"line":"  open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type ('zkapp_command, 'field) t =","counters":[{"col_start":6,"col_end":6,"count":1},{"col_start":36,"col_end":36,"count":5}]},{"line":"        { zkapp_command : 'zkapp_command; memo_hash : 'field }","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":42,"col_end":42,"count":0},{"col_start":50,"col_end":50,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"      [@@deriving sexp, yojson]","counters":[{"col_start":30,"col_end":30,"count":3}]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make (Inputs : Inputs_intf) = struct","counters":[]},{"line":"  open Inputs","counters":[]},{"line":"","counters":[]},{"line":"  let default_caller = Token_id.default","counters":[]},{"line":"","counters":[]},{"line":"  let stack_frame_default () =","counters":[]},{"line":"    Stack_frame.make ~caller:default_caller ~caller_caller:default_caller","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ~calls:(Call_forest.empty ())","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"","counters":[]},{"line":"  let assert_ ~pos b = Bool.Assert.is_true ~pos b","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"  (* Pop from the call stack, returning dummy values if the stack is empty. *)","counters":[]},{"line":"  let pop_call_stack (s : Call_stack.t) : Stack_frame.t * Call_stack.t =","counters":[]},{"line":"    let res = Call_stack.pop s in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    (* Split out the option returned by Call_stack.pop into two options *)","counters":[]},{"line":"    let next_frame, next_call_stack =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (Opt.map ~f:fst res, Opt.map ~f:snd res)","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"    in","counters":[]},{"line":"    (* Handle the None cases *)","counters":[]},{"line":"    ( Opt.or_default ~if_:Stack_frame.if_ ~default:(stack_frame_default ())","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":70,"col_end":70,"count":0}]},{"line":"        next_frame","counters":[]},{"line":"    , Opt.or_default ~if_:Call_stack.if_ ~default:(Call_stack.empty ())","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"        next_call_stack )","counters":[]},{"line":"","counters":[]},{"line":"  type get_next_account_update_result =","counters":[]},{"line":"    { account_update : Account_update.t","counters":[]},{"line":"    ; account_update_forest : Call_forest.t","counters":[]},{"line":"    ; new_call_stack : Call_stack.t","counters":[]},{"line":"    ; new_frame : Stack_frame.t","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let get_next_account_update (current_forest : Stack_frame.t)","counters":[]},{"line":"      (* The stack for the most recent snapp *)","counters":[]},{"line":"        (call_stack : Call_stack.t) (* The partially-completed parent stacks *)","counters":[]},{"line":"      : get_next_account_update_result =","counters":[]},{"line":"    (* If the current stack is complete, 'return' to the previous","counters":[]},{"line":"       partially-completed one.","counters":[]},{"line":"    *)","counters":[]},{"line":"    let current_forest, call_stack =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let next_forest, next_call_stack =","counters":[]},{"line":"        (* Invariant: call_stack contains only non-empty forests. *)","counters":[]},{"line":"        pop_call_stack call_stack","counters":[]},{"line":"      in","counters":[]},{"line":"      (* TODO: I believe current should only be empty for the first account_update in","counters":[]},{"line":"         a transaction. *)","counters":[]},{"line":"      let current_is_empty =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Call_forest.is_empty (Stack_frame.calls current_forest)","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"      in","counters":[]},{"line":"      ( Stack_frame.if_ current_is_empty ~then_:next_forest ~else_:current_forest","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"      , Call_stack.if_ current_is_empty ~then_:next_call_stack ~else_:call_stack","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"      )","counters":[]},{"line":"    in","counters":[]},{"line":"    let (account_update, account_update_forest), remainder_of_current_forest =","counters":[]},{"line":"      Call_forest.pop_exn (Stack_frame.calls current_forest)","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"    in","counters":[]},{"line":"    let account_update_caller = Account_update.caller account_update in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let is_normal_call =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Token_id.equal account_update_caller (Stack_frame.caller current_forest)","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"    in","counters":[]},{"line":"    let () =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      with_label ~label:\"check valid caller\" (fun () ->","counters":[]},{"line":"          let is_delegate_call =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Token_id.equal account_update_caller","counters":[]},{"line":"              (Stack_frame.caller_caller current_forest)","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"          in","counters":[]},{"line":"          (* Check that account_update has a valid caller. *)","counters":[]},{"line":"          assert_ ~pos:__POS__ Bool.(is_normal_call ||| is_delegate_call) )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"    in","counters":[]},{"line":"    (* Cases:","counters":[]},{"line":"       - [account_update_forest] is empty, [remainder_of_current_forest] is empty.","counters":[]},{"line":"       Pop from the call stack to get another forest, which is guaranteed to be non-empty.","counters":[]},{"line":"       The result of popping becomes the \"current forest\".","counters":[]},{"line":"       - [account_update_forest] is empty, [remainder_of_current_forest] is non-empty.","counters":[]},{"line":"       Push nothing to the stack. [remainder_of_current_forest] becomes new \"current forest\"","counters":[]},{"line":"       - [account_update_forest] is non-empty, [remainder_of_current_forest] is empty.","counters":[]},{"line":"       Push nothing to the stack. [account_update_forest] becomes new \"current forest\"","counters":[]},{"line":"       - [account_update_forest] is non-empty, [remainder_of_current_forest] is non-empty:","counters":[]},{"line":"       Push [remainder_of_current_forest] to the stack. [account_update_forest] becomes new \"current forest\".","counters":[]},{"line":"    *)","counters":[]},{"line":"    let account_update_forest_empty =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Call_forest.is_empty account_update_forest","counters":[]},{"line":"    in","counters":[]},{"line":"    let remainder_of_current_forest_empty =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Call_forest.is_empty remainder_of_current_forest","counters":[]},{"line":"    in","counters":[]},{"line":"    let newly_popped_frame, popped_call_stack = pop_call_stack call_stack in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let remainder_of_current_forest_frame : Stack_frame.t =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Stack_frame.make","counters":[]},{"line":"        ~caller:(Stack_frame.caller current_forest)","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"        ~caller_caller:(Stack_frame.caller_caller current_forest)","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"        ~calls:remainder_of_current_forest","counters":[]},{"line":"    in","counters":[]},{"line":"    let new_call_stack =","counters":[]},{"line":"      Call_stack.if_ account_update_forest_empty","counters":[]},{"line":"        ~then_:","counters":[]},{"line":"          (Call_stack.if_ remainder_of_current_forest_empty","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"             ~then_:","counters":[]},{"line":"               (* Don't actually need the or_default used in this case. *)","counters":[]},{"line":"               popped_call_stack ~else_:call_stack )","counters":[]},{"line":"        ~else_:","counters":[]},{"line":"          (Call_stack.if_ remainder_of_current_forest_empty ~then_:call_stack","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"             ~else_:","counters":[]},{"line":"               (Call_stack.push remainder_of_current_forest_frame","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                  ~onto:call_stack ) )","counters":[]},{"line":"    in","counters":[]},{"line":"    let new_frame =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Stack_frame.if_ account_update_forest_empty","counters":[]},{"line":"        ~then_:","counters":[]},{"line":"          (Stack_frame.if_ remainder_of_current_forest_empty","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"             ~then_:newly_popped_frame ~else_:remainder_of_current_forest_frame )","counters":[]},{"line":"        ~else_:","counters":[]},{"line":"          (let caller =","counters":[]},{"line":"             Token_id.if_ is_normal_call","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"               ~then_:","counters":[]},{"line":"                 (Account_id.derive_token_id","counters":[]},{"line":"                    ~owner:(Account_update.account_id account_update) )","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"               ~else_:(Stack_frame.caller current_forest)","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"           and caller_caller = account_update_caller in","counters":[]},{"line":"           Stack_frame.make ~calls:account_update_forest ~caller ~caller_caller","counters":[]},{"line":"          )","counters":[]},{"line":"    in","counters":[]},{"line":"    { account_update; account_update_forest; new_frame; new_call_stack }","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let update_sequence_state (sequence_state : _ Pickles_types.Vector.t)","counters":[]},{"line":"      sequence_events ~txn_global_slot ~last_sequence_slot =","counters":[]},{"line":"    (* Push events to s1. *)","counters":[]},{"line":"    let [ s1'; s2'; s3'; s4'; s5' ] = sequence_state in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let is_empty = Sequence_events.is_empty sequence_events in","counters":[]},{"line":"    let s1_updated = Sequence_events.push_events s1' sequence_events in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let s1 = Field.if_ is_empty ~then_:s1' ~else_:s1_updated in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    (* Shift along if not empty and last update wasn't this slot *)","counters":[]},{"line":"    let is_this_slot = Global_slot.equal txn_global_slot last_sequence_slot in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let is_empty_or_this_slot = Bool.(is_empty ||| is_this_slot) in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"    let s5 = Field.if_ is_empty_or_this_slot ~then_:s5' ~else_:s4' in","counters":[]},{"line":"    let s4 = Field.if_ is_empty_or_this_slot ~then_:s4' ~else_:s3' in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let s3 = Field.if_ is_empty_or_this_slot ~then_:s3' ~else_:s2' in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let s2 = Field.if_ is_empty_or_this_slot ~then_:s2' ~else_:s1' in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let last_sequence_slot =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Global_slot.if_ is_empty ~then_:last_sequence_slot ~else_:txn_global_slot","counters":[]},{"line":"    in","counters":[]},{"line":"    (([ s1; s2; s3; s4; s5 ] : _ Pickles_types.Vector.t), last_sequence_slot)","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let apply ~(constraint_constants : Genesis_constants.Constraint_constants.t)","counters":[]},{"line":"      ~(is_start : [ `Yes of _ Start_data.t | `No | `Compute of _ Start_data.t ])","counters":[]},{"line":"      (h :","counters":[]},{"line":"        (< global_state : Global_state.t","counters":[]},{"line":"         ; transaction_commitment : Transaction_commitment.t","counters":[]},{"line":"         ; full_transaction_commitment : Transaction_commitment.t","counters":[]},{"line":"         ; amount : Amount.t","counters":[]},{"line":"         ; bool : Bool.t","counters":[]},{"line":"         ; failure : Bool.failure_status","counters":[]},{"line":"         ; .. >","counters":[]},{"line":"         as","counters":[]},{"line":"         'env )","counters":[]},{"line":"        handler )","counters":[]},{"line":"      ((global_state : Global_state.t), (local_state : Local_state.t)) =","counters":[]},{"line":"    let open Inputs in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let is_start' =","counters":[]},{"line":"      let is_start' =","counters":[]},{"line":"        Call_forest.is_empty (Stack_frame.calls local_state.stack_frame)","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"      in","counters":[]},{"line":"      ( match is_start with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | `Compute _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ()","counters":[]},{"line":"      | `Yes _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          assert_ ~pos:__POS__ is_start'","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"      | `No ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          assert_ ~pos:__POS__ (Bool.not is_start') ) ;","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"      match is_start with","counters":[]},{"line":"      | `Yes _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Bool.true_","counters":[]},{"line":"      | `No ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Bool.false_","counters":[]},{"line":"      | `Compute _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          is_start'","counters":[]},{"line":"    in","counters":[]},{"line":"    let local_state =","counters":[]},{"line":"      { local_state with","counters":[]},{"line":"        ledger =","counters":[]},{"line":"          Inputs.Ledger.if_ is_start'","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"            ~then_:(Inputs.Global_state.ledger global_state)","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"            ~else_:local_state.ledger","counters":[]},{"line":"      }","counters":[]},{"line":"    in","counters":[]},{"line":"    let ( (account_update, remaining, call_stack)","counters":[]},{"line":"        , account_update_forest","counters":[]},{"line":"        , local_state","counters":[]},{"line":"        , (a, inclusion_proof) ) =","counters":[]},{"line":"      let to_pop, call_stack =","counters":[]},{"line":"        match is_start with","counters":[]},{"line":"        | `Compute start_data ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ( Stack_frame.if_ is_start'","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                ~then_:","counters":[]},{"line":"                  (Stack_frame.make ~calls:start_data.zkapp_command","counters":[]},{"line":"                     ~caller:default_caller ~caller_caller:default_caller )","counters":[]},{"line":"                ~else_:local_state.stack_frame","counters":[]},{"line":"            , Call_stack.if_ is_start' ~then_:(Call_stack.empty ())","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"                ~else_:local_state.call_stack )","counters":[]},{"line":"        | `Yes start_data ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ( Stack_frame.make ~calls:start_data.zkapp_command","counters":[]},{"line":"                ~caller:default_caller ~caller_caller:default_caller","counters":[]},{"line":"            , Call_stack.empty () )","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"        | `No ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (local_state.stack_frame, local_state.call_stack)","counters":[]},{"line":"      in","counters":[]},{"line":"      let { account_update","counters":[]},{"line":"          ; account_update_forest","counters":[]},{"line":"          ; new_frame = remaining","counters":[]},{"line":"          ; new_call_stack = call_stack","counters":[]},{"line":"          } =","counters":[]},{"line":"        with_label ~label:\"get next account update\" (fun () ->","counters":[]},{"line":"            (* TODO: Make the stack frame hashed inside of the local state *)","counters":[]},{"line":"            get_next_account_update to_pop call_stack )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"      in","counters":[]},{"line":"      let local_state =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        with_label ~label:\"token owner not caller\" (fun () ->","counters":[]},{"line":"            let default_token_or_token_owner_was_caller =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (* Check that the token owner was consulted if using a non-default","counters":[]},{"line":"                 token *)","counters":[]},{"line":"              let account_update_token_id =","counters":[]},{"line":"                Account_update.token_id account_update","counters":[]},{"line":"              in","counters":[]},{"line":"              Bool.( ||| )","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"                (Token_id.equal account_update_token_id Token_id.default)","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                (Token_id.equal account_update_token_id","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                   (Account_update.caller account_update) )","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"            in","counters":[]},{"line":"            Local_state.add_check local_state Token_owner_not_caller","counters":[]},{"line":"              default_token_or_token_owner_was_caller )","counters":[]},{"line":"      in","counters":[]},{"line":"      let ((a, inclusion_proof) as acct) =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        with_label ~label:\"get account\" (fun () ->","counters":[]},{"line":"            Inputs.Ledger.get_account account_update local_state.ledger )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"      in","counters":[]},{"line":"      Inputs.Ledger.check_inclusion local_state.ledger (a, inclusion_proof) ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let transaction_commitment, full_transaction_commitment =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        match is_start with","counters":[]},{"line":"        | `No ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ( local_state.transaction_commitment","counters":[]},{"line":"            , local_state.full_transaction_commitment )","counters":[]},{"line":"        | `Yes start_data | `Compute start_data ->","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"            let tx_commitment_on_start =","counters":[]},{"line":"              Transaction_commitment.commitment","counters":[]},{"line":"                ~account_updates:(Stack_frame.calls remaining)","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"            in","counters":[]},{"line":"            let full_tx_commitment_on_start =","counters":[]},{"line":"              Transaction_commitment.full_commitment ~account_update","counters":[]},{"line":"                ~memo_hash:start_data.memo_hash","counters":[]},{"line":"                ~commitment:tx_commitment_on_start","counters":[]},{"line":"            in","counters":[]},{"line":"            let tx_commitment =","counters":[]},{"line":"              Transaction_commitment.if_ is_start' ~then_:tx_commitment_on_start","counters":[]},{"line":"                ~else_:local_state.transaction_commitment","counters":[]},{"line":"            in","counters":[]},{"line":"            let full_tx_commitment =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Transaction_commitment.if_ is_start'","counters":[]},{"line":"                ~then_:full_tx_commitment_on_start","counters":[]},{"line":"                ~else_:local_state.full_transaction_commitment","counters":[]},{"line":"            in","counters":[]},{"line":"            (tx_commitment, full_tx_commitment)","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"      in","counters":[]},{"line":"      let local_state =","counters":[]},{"line":"        { local_state with","counters":[]},{"line":"          transaction_commitment","counters":[]},{"line":"        ; full_transaction_commitment","counters":[]},{"line":"        ; token_id =","counters":[]},{"line":"            Token_id.if_ is_start' ~then_:Token_id.default","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"              ~else_:local_state.token_id","counters":[]},{"line":"        }","counters":[]},{"line":"      in","counters":[]},{"line":"      ( (account_update, remaining, call_stack)","counters":[]},{"line":"      , account_update_forest","counters":[]},{"line":"      , local_state","counters":[]},{"line":"      , acct )","counters":[]},{"line":"    in","counters":[]},{"line":"    let local_state =","counters":[]},{"line":"      { local_state with stack_frame = remaining; call_stack }","counters":[]},{"line":"    in","counters":[]},{"line":"    let local_state = Local_state.add_new_failure_status_bucket local_state in","counters":[]},{"line":"    Inputs.Ledger.check_inclusion local_state.ledger (a, inclusion_proof) ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    (* Register verification key, in case it needs to be 'side-loaded' to","counters":[]},{"line":"       verify a zkapp proof.","counters":[]},{"line":"    *)","counters":[]},{"line":"    Account.register_verification_key a ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let (`Is_new account_is_new) =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Inputs.Ledger.check_account","counters":[]},{"line":"        (Account_update.public_key account_update)","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"        (Account_update.token_id account_update)","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"        (a, inclusion_proof)","counters":[]},{"line":"    in","counters":[]},{"line":"    let local_state =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      h.perform","counters":[]},{"line":"        (Check_account_precondition","counters":[]},{"line":"           (account_update, a, account_is_new, local_state) )","counters":[]},{"line":"    in","counters":[]},{"line":"    let protocol_state_predicate_satisfied =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      h.perform","counters":[]},{"line":"        (Check_protocol_state_precondition","counters":[]},{"line":"           ( Account_update.protocol_state_precondition account_update","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"           , global_state ) )","counters":[]},{"line":"    in","counters":[]},{"line":"    let local_state =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Local_state.add_check local_state Protocol_state_precondition_unsatisfied","counters":[]},{"line":"        protocol_state_predicate_satisfied","counters":[]},{"line":"    in","counters":[]},{"line":"    let `Proof_verifies proof_verifies, `Signature_verifies signature_verifies =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let commitment =","counters":[]},{"line":"        Inputs.Transaction_commitment.if_","counters":[]},{"line":"          (Inputs.Account_update.use_full_commitment account_update)","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"          ~then_:local_state.full_transaction_commitment","counters":[]},{"line":"          ~else_:local_state.transaction_commitment","counters":[]},{"line":"      in","counters":[]},{"line":"      Inputs.Account_update.check_authorization ~commitment","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"        ~calls:account_update_forest account_update","counters":[]},{"line":"    in","counters":[]},{"line":"    assert_ ~pos:__POS__","counters":[]},{"line":"      (Bool.equal proof_verifies (Account_update.is_proved account_update)) ;","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"    assert_ ~pos:__POS__","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (Bool.equal signature_verifies (Account_update.is_signed account_update)) ;","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"    (* The fee-payer must increment their nonce. *)","counters":[]},{"line":"    let local_state =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Local_state.add_check local_state Fee_payer_nonce_must_increase","counters":[]},{"line":"        Inputs.Bool.(","counters":[]},{"line":"          Inputs.Account_update.increment_nonce account_update ||| not is_start')","counters":[{"col_start":46,"col_end":46,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"    in","counters":[]},{"line":"    let local_state =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Local_state.add_check local_state Fee_payer_must_be_signed","counters":[]},{"line":"        Inputs.Bool.(signature_verifies ||| not is_start')","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"    in","counters":[]},{"line":"    let local_state =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let precondition_has_constant_nonce =","counters":[]},{"line":"        Inputs.Account_update.Account_precondition.nonce account_update","counters":[]},{"line":"        |> Inputs.Nonce_precondition.is_constant","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"      in","counters":[]},{"line":"      let increments_nonce_and_constrains_its_old_value =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Inputs.Bool.(","counters":[]},{"line":"          Inputs.Account_update.increment_nonce account_update","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"          &&& precondition_has_constant_nonce)","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"      in","counters":[]},{"line":"      let depends_on_the_fee_payers_nonce_and_isnt_the_fee_payer =","counters":[]},{"line":"        Inputs.Bool.(","counters":[]},{"line":"          Inputs.Account_update.use_full_commitment account_update","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"          &&& not is_start')","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"      in","counters":[]},{"line":"      let does_not_use_a_signature = Inputs.Bool.not signature_verifies in","counters":[]},{"line":"      Local_state.add_check local_state Zkapp_command_replay_check_failed","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"        Inputs.Bool.(","counters":[]},{"line":"          increments_nonce_and_constrains_its_old_value","counters":[]},{"line":"          ||| depends_on_the_fee_payers_nonce_and_isnt_the_fee_payer","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          ||| does_not_use_a_signature)","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"    in","counters":[]},{"line":"    let a = Account.set_token_id a (Account_update.token_id account_update) in","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"    let account_update_token = Account_update.token_id account_update in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let account_update_token_is_default =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Token_id.(equal default) account_update_token","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"    in","counters":[]},{"line":"    let account_is_untimed = Bool.not (Account.is_timed a) in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"    (* Set account timing for new accounts, if specified. *)","counters":[]},{"line":"    let a, local_state =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let timing = Account_update.Update.timing account_update in","counters":[]},{"line":"      let local_state =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Local_state.add_check local_state","counters":[]},{"line":"          Update_not_permitted_timing_existing_account","counters":[]},{"line":"          Bool.(","counters":[]},{"line":"            Set_or_keep.is_keep timing","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"            ||| (account_is_untimed &&& signature_verifies))","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"      in","counters":[]},{"line":"      let timing =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Set_or_keep.set_or_keep ~if_:Timing.if_ timing (Account.timing a)","counters":[{"col_start":69,"col_end":69,"count":0}]},{"line":"      in","counters":[]},{"line":"      let vesting_period = Timing.vesting_period timing in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      (* Assert that timing is valid, otherwise we may have a division by 0. *)","counters":[]},{"line":"      assert_ ~pos:__POS__ Global_slot.(vesting_period > zero) ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let a = Account.set_timing a timing in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      (a, local_state)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    in","counters":[]},{"line":"    (* Apply balance change. *)","counters":[]},{"line":"    let a, local_state =","counters":[]},{"line":"      let balance_change = Account_update.balance_change account_update in","counters":[]},{"line":"      let balance, `Overflow failed1 =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Balance.add_signed_amount_flagged (Account.balance a) balance_change","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"      in","counters":[]},{"line":"      (* TODO: Should this report 'insufficient balance'? *)","counters":[]},{"line":"      let local_state =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Local_state.add_check local_state Overflow (Bool.not failed1)","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"      in","counters":[]},{"line":"      let account_creation_fee =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Amount.of_constant_fee constraint_constants.account_creation_fee","counters":[]},{"line":"      in","counters":[]},{"line":"      let local_state =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (* Conditionally subtract account creation fee from fee excess *)","counters":[]},{"line":"        let excess_minus_creation_fee, `Overflow excess_update_failed =","counters":[]},{"line":"          Amount.Signed.add_flagged local_state.excess","counters":[]},{"line":"            Amount.Signed.(negate (of_unsigned account_creation_fee))","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"        in","counters":[]},{"line":"        Printf.eprintf \"Amount_insufficient_to_create_account HERE\\n%!\";","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let local_state =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Local_state.add_check local_state Local_excess_overflow","counters":[]},{"line":"            Bool.(not (account_is_new &&& excess_update_failed))","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"        in","counters":[]},{"line":"        { local_state with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          excess =","counters":[]},{"line":"            Amount.Signed.if_ account_is_new ~then_:excess_minus_creation_fee","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"              ~else_:local_state.excess","counters":[]},{"line":"        }","counters":[]},{"line":"      in","counters":[]},{"line":"      let local_state =","counters":[]},{"line":"        (* Conditionally subtract account creation fee from supply increase *)","counters":[]},{"line":"        let ( supply_increase_minus_creation_fee","counters":[]},{"line":"            , `Overflow supply_increase_update_failed ) =","counters":[]},{"line":"          Amount.Signed.add_flagged local_state.supply_increase","counters":[]},{"line":"            Amount.Signed.(negate (of_unsigned account_creation_fee))","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"        in","counters":[]},{"line":"        let local_state =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Local_state.add_check local_state Local_supply_increase_overflow","counters":[]},{"line":"            Bool.(not (account_is_new &&& supply_increase_update_failed))","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"        in","counters":[]},{"line":"        { local_state with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          supply_increase =","counters":[]},{"line":"            Amount.Signed.if_ account_is_new","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"              ~then_:supply_increase_minus_creation_fee","counters":[]},{"line":"              ~else_:local_state.supply_increase","counters":[]},{"line":"        }","counters":[]},{"line":"      in","counters":[]},{"line":"      let is_receiver = Amount.Signed.is_pos balance_change in","counters":[]},{"line":"      let local_state =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let controller =","counters":[]},{"line":"          Controller.if_ is_receiver","counters":[]},{"line":"            ~then_:(Account.Permissions.receive a)","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"            ~else_:(Account.Permissions.send a)","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"        in","counters":[]},{"line":"        let has_permission =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Controller.check ~proof_verifies ~signature_verifies controller","counters":[]},{"line":"        in","counters":[]},{"line":"        Local_state.add_check local_state Update_not_permitted_balance","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"          Bool.(","counters":[]},{"line":"            has_permission","counters":[]},{"line":"            ||| Amount.Signed.(equal (of_unsigned Amount.zero) balance_change))","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"      in","counters":[]},{"line":"      let a = Account.set_balance balance a in","counters":[]},{"line":"      (a, local_state)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    in","counters":[]},{"line":"    let txn_global_slot = Global_state.global_slot_since_genesis global_state in","counters":[]},{"line":"    (* Check timing with current balance *)","counters":[]},{"line":"    let a, local_state =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let `Invalid_timing invalid_timing, timing =","counters":[]},{"line":"        match Account.check_timing ~txn_global_slot a with","counters":[]},{"line":"        | `Insufficient_balance _, _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            failwith \"Did not propose a balance change at this timing check!\"","counters":[]},{"line":"        | `Invalid_timing invalid_timing, timing ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (* NB: Have to destructure to remove the possibility of","counters":[]},{"line":"               [`Insufficient_balance _] in the type.","counters":[]},{"line":"            *)","counters":[]},{"line":"            (`Invalid_timing invalid_timing, timing)","counters":[]},{"line":"      in","counters":[]},{"line":"      let local_state =","counters":[]},{"line":"        Local_state.add_check local_state Source_minimum_balance_violation","counters":[]},{"line":"          (Bool.not invalid_timing)","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"      in","counters":[]},{"line":"      let a = Account.set_timing a timing in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      (a, local_state)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    in","counters":[]},{"line":"    (* Transform into a zkApp account.","counters":[]},{"line":"       This must be done before updating zkApp fields!","counters":[]},{"line":"    *)","counters":[]},{"line":"    let a = Account.make_zkapp a in","counters":[]},{"line":"    (* Update app state. *)","counters":[]},{"line":"    let a, local_state =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let app_state = Account_update.Update.app_state account_update in","counters":[]},{"line":"      let keeping_app_state =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Bool.all","counters":[]},{"line":"          (List.map ~f:Set_or_keep.is_keep","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"             (Pickles_types.Vector.to_list app_state) )","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"      in","counters":[]},{"line":"      let changing_entire_app_state =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Bool.all","counters":[]},{"line":"          (List.map ~f:Set_or_keep.is_set","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"             (Pickles_types.Vector.to_list app_state) )","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"      in","counters":[]},{"line":"      let proved_state =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (* The [proved_state] tracks whether the app state has been entirely","counters":[]},{"line":"           determined by proofs ([true] if so), to allow zkApp authors to be","counters":[]},{"line":"           confident that their initialization logic has been run, rather than","counters":[]},{"line":"           some malicious deployer instantiating the snapp in an account with","counters":[]},{"line":"           some fake non-initial state.","counters":[]},{"line":"           The logic here is:","counters":[]},{"line":"           * if the state is unchanged, keep the previous value;","counters":[]},{"line":"           * if the state has been entriely replaced, and the authentication","counters":[]},{"line":"             was a proof, the state has been 'proved' and [proved_state] is set","counters":[]},{"line":"             to [true];","counters":[]},{"line":"           * if the state has been partially updated by a proof, the","counters":[]},{"line":"             [proved_state] is unchanged;","counters":[]},{"line":"           * if the state has been changed by some authentication other than a","counters":[]},{"line":"             proof, the state is considered to have been tampered with, and","counters":[]},{"line":"             [proved_state] is reset to [false].","counters":[]},{"line":"        *)","counters":[]},{"line":"        Bool.if_ keeping_app_state ~then_:(Account.proved_state a)","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"          ~else_:","counters":[]},{"line":"            (Bool.if_ proof_verifies","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"               ~then_:","counters":[]},{"line":"                 (Bool.if_ changing_entire_app_state ~then_:Bool.true_","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                    ~else_:(Account.proved_state a) )","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"               ~else_:Bool.false_ )","counters":[]},{"line":"      in","counters":[]},{"line":"      let a = Account.set_proved_state proved_state a in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let has_permission =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Controller.check ~proof_verifies ~signature_verifies","counters":[]},{"line":"          (Account.Permissions.edit_state a)","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"      in","counters":[]},{"line":"      let local_state =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Local_state.add_check local_state Update_not_permitted_app_state","counters":[]},{"line":"          Bool.(keeping_app_state ||| has_permission)","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"      in","counters":[]},{"line":"      let app_state =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Pickles_types.Vector.map2 app_state (Account.app_state a)","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"          ~f:(Set_or_keep.set_or_keep ~if_:Field.if_)","counters":[]},{"line":"      in","counters":[]},{"line":"      let a = Account.set_app_state app_state a in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      (a, local_state)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    in","counters":[]},{"line":"    (* Set verification key. *)","counters":[]},{"line":"    let a, local_state =","counters":[]},{"line":"      let verification_key =","counters":[]},{"line":"        Account_update.Update.verification_key account_update","counters":[]},{"line":"      in","counters":[]},{"line":"      let has_permission =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Controller.check ~proof_verifies ~signature_verifies","counters":[]},{"line":"          (Account.Permissions.set_verification_key a)","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"      in","counters":[]},{"line":"      let local_state =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Local_state.add_check local_state Update_not_permitted_verification_key","counters":[]},{"line":"          Bool.(Set_or_keep.is_keep verification_key ||| has_permission)","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"      in","counters":[]},{"line":"      let verification_key =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Set_or_keep.set_or_keep ~if_:Verification_key.if_ verification_key","counters":[]},{"line":"          (Account.verification_key a)","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"      in","counters":[]},{"line":"      let a = Account.set_verification_key verification_key a in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      (a, local_state)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    in","counters":[]},{"line":"    (* Update sequence state. *)","counters":[]},{"line":"    let a, local_state =","counters":[]},{"line":"      let sequence_events =","counters":[]},{"line":"        Account_update.Update.sequence_events account_update","counters":[]},{"line":"      in","counters":[]},{"line":"      let last_sequence_slot = Account.last_sequence_slot a in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let sequence_state, last_sequence_slot =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        update_sequence_state (Account.sequence_state a) sequence_events","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"          ~txn_global_slot ~last_sequence_slot","counters":[]},{"line":"      in","counters":[]},{"line":"      let is_empty =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (* also computed in update_sequence_state, but messy to return it *)","counters":[]},{"line":"        Sequence_events.is_empty sequence_events","counters":[]},{"line":"      in","counters":[]},{"line":"      let has_permission =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Controller.check ~proof_verifies ~signature_verifies","counters":[]},{"line":"          (Account.Permissions.edit_sequence_state a)","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"      in","counters":[]},{"line":"      let local_state =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Local_state.add_check local_state Update_not_permitted_sequence_state","counters":[]},{"line":"          Bool.(is_empty ||| has_permission)","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"      in","counters":[]},{"line":"      let a =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        a","counters":[]},{"line":"        |> Account.set_sequence_state sequence_state","counters":[]},{"line":"        |> Account.set_last_sequence_slot last_sequence_slot","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"      in","counters":[]},{"line":"      (a, local_state)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    in","counters":[]},{"line":"    (* Reset zkApp state to [None] if it is unmodified. *)","counters":[]},{"line":"    let a = Account.unmake_zkapp a in","counters":[]},{"line":"    (* Update zkApp URI. *)","counters":[]},{"line":"    let a, local_state =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let zkapp_uri = Account_update.Update.zkapp_uri account_update in","counters":[]},{"line":"      let has_permission =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Controller.check ~proof_verifies ~signature_verifies","counters":[]},{"line":"          (Account.Permissions.set_zkapp_uri a)","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"      in","counters":[]},{"line":"      let local_state =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Local_state.add_check local_state Update_not_permitted_zkapp_uri","counters":[]},{"line":"          Bool.(Set_or_keep.is_keep zkapp_uri ||| has_permission)","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"      in","counters":[]},{"line":"      let zkapp_uri =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Set_or_keep.set_or_keep ~if_:Zkapp_uri.if_ zkapp_uri","counters":[]},{"line":"          (Account.zkapp_uri a)","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"      in","counters":[]},{"line":"      let a = Account.set_zkapp_uri zkapp_uri a in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      (a, local_state)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    in","counters":[]},{"line":"    (* Update token symbol. *)","counters":[]},{"line":"    let a, local_state =","counters":[]},{"line":"      let token_symbol = Account_update.Update.token_symbol account_update in","counters":[]},{"line":"      let has_permission =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Controller.check ~proof_verifies ~signature_verifies","counters":[]},{"line":"          (Account.Permissions.set_token_symbol a)","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"      in","counters":[]},{"line":"      let local_state =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Local_state.add_check local_state Update_not_permitted_token_symbol","counters":[]},{"line":"          Bool.(Set_or_keep.is_keep token_symbol ||| has_permission)","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"      in","counters":[]},{"line":"      let token_symbol =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Set_or_keep.set_or_keep ~if_:Token_symbol.if_ token_symbol","counters":[]},{"line":"          (Account.token_symbol a)","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"      in","counters":[]},{"line":"      let a = Account.set_token_symbol token_symbol a in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      (a, local_state)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    in","counters":[]},{"line":"    (* Update delegate. *)","counters":[]},{"line":"    let a, local_state =","counters":[]},{"line":"      let delegate = Account_update.Update.delegate account_update in","counters":[]},{"line":"      let base_delegate =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let should_set_new_account_delegate =","counters":[]},{"line":"          (* Only accounts for the default token may delegate. *)","counters":[]},{"line":"          Bool.(account_is_new &&& account_update_token_is_default)","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"        in","counters":[]},{"line":"        (* New accounts should have the delegate equal to the public key of the","counters":[]},{"line":"           account.","counters":[]},{"line":"        *)","counters":[]},{"line":"        Public_key.if_ should_set_new_account_delegate","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"          ~then_:(Account_update.public_key account_update)","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"          ~else_:(Account.delegate a)","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"      in","counters":[]},{"line":"      let has_permission =","counters":[]},{"line":"        Controller.check ~proof_verifies ~signature_verifies","counters":[]},{"line":"          (Account.Permissions.set_delegate a)","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"      in","counters":[]},{"line":"      let local_state =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (* Note: only accounts for the default token can delegate. *)","counters":[]},{"line":"        Local_state.add_check local_state Update_not_permitted_delegate","counters":[]},{"line":"          Bool.(","counters":[]},{"line":"            Set_or_keep.is_keep delegate","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"            ||| (has_permission &&& account_update_token_is_default))","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"      in","counters":[]},{"line":"      let delegate =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Set_or_keep.set_or_keep ~if_:Public_key.if_ delegate base_delegate","counters":[]},{"line":"      in","counters":[]},{"line":"      let a = Account.set_delegate delegate a in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      (a, local_state)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    in","counters":[]},{"line":"    (* Update nonce. *)","counters":[]},{"line":"    let a, local_state =","counters":[]},{"line":"      let nonce = Account.nonce a in","counters":[]},{"line":"      let increment_nonce = Account_update.increment_nonce account_update in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let nonce =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Nonce.if_ increment_nonce ~then_:(Nonce.succ nonce) ~else_:nonce","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"      in","counters":[]},{"line":"      let has_permission =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Controller.check ~proof_verifies ~signature_verifies","counters":[]},{"line":"          (Account.Permissions.increment_nonce a)","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"      in","counters":[]},{"line":"      let local_state =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Local_state.add_check local_state Update_not_permitted_nonce","counters":[]},{"line":"          Bool.((not increment_nonce) ||| has_permission)","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"      in","counters":[]},{"line":"      let a = Account.set_nonce nonce a in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      (a, local_state)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    in","counters":[]},{"line":"    (* Update voting-for. *)","counters":[]},{"line":"    let a, local_state =","counters":[]},{"line":"      let voting_for = Account_update.Update.voting_for account_update in","counters":[]},{"line":"      let has_permission =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Controller.check ~proof_verifies ~signature_verifies","counters":[]},{"line":"          (Account.Permissions.set_voting_for a)","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"      in","counters":[]},{"line":"      let local_state =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Local_state.add_check local_state Update_not_permitted_voting_for","counters":[]},{"line":"          Bool.(Set_or_keep.is_keep voting_for ||| has_permission)","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"      in","counters":[]},{"line":"      let voting_for =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Set_or_keep.set_or_keep ~if_:State_hash.if_ voting_for","counters":[]},{"line":"          (Account.voting_for a)","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"      in","counters":[]},{"line":"      let a = Account.set_voting_for voting_for a in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      (a, local_state)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    in","counters":[]},{"line":"    (* Update receipt chain hash *)","counters":[]},{"line":"    let a =","counters":[]},{"line":"      let new_hash =","counters":[]},{"line":"        let old_hash = Account.receipt_chain_hash a in","counters":[]},{"line":"        Receipt_chain_hash.if_","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"          (let open Inputs.Bool in","counters":[]},{"line":"          signature_verifies ||| proof_verifies)","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"          ~then_:","counters":[]},{"line":"            (let elt =","counters":[]},{"line":"               local_state.full_transaction_commitment","counters":[]},{"line":"               |> Receipt_chain_hash.Elt.of_transaction_commitment","counters":[]},{"line":"             in","counters":[]},{"line":"             Receipt_chain_hash.cons_zkapp_command_commitment","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"               local_state.account_update_index elt old_hash )","counters":[]},{"line":"          ~else_:old_hash","counters":[]},{"line":"      in","counters":[]},{"line":"      Account.set_receipt_chain_hash a new_hash","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"    in","counters":[]},{"line":"    (* Finally, update permissions.","counters":[]},{"line":"       This should be the last update applied, to ensure that any earlier","counters":[]},{"line":"       updates use the account's existing permissions, and not permissions that","counters":[]},{"line":"       are specified by the account_update!","counters":[]},{"line":"    *)","counters":[]},{"line":"    let a, local_state =","counters":[]},{"line":"      let permissions = Account_update.Update.permissions account_update in","counters":[]},{"line":"      let has_permission =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Controller.check ~proof_verifies ~signature_verifies","counters":[]},{"line":"          (Account.Permissions.set_permissions a)","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"      in","counters":[]},{"line":"      let local_state =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Local_state.add_check local_state Update_not_permitted_permissions","counters":[]},{"line":"          Bool.(Set_or_keep.is_keep permissions ||| has_permission)","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"      in","counters":[]},{"line":"      let permissions =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Set_or_keep.set_or_keep ~if_:Account.Permissions.if_ permissions","counters":[]},{"line":"          (Account.permissions a)","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"      in","counters":[]},{"line":"      let a = Account.set_permissions permissions a in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      (a, local_state)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    in","counters":[]},{"line":"    (* Initialize account's pk, in case it is new. *)","counters":[]},{"line":"    let a = h.perform (Init_account { account_update; account = a }) in","counters":[]},{"line":"    (* DO NOT ADD ANY UPDATES HERE. They must be earlier in the code.","counters":[]},{"line":"       See comment above.","counters":[]},{"line":"    *)","counters":[]},{"line":"    let local_delta =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (* NOTE: It is *not* correct to use the actual change in balance here.","counters":[]},{"line":"         Indeed, if the account creation fee is paid, using that amount would","counters":[]},{"line":"         be equivalent to paying it out to the block producer.","counters":[]},{"line":"         In the case of a failure that prevents any updates from being applied,","counters":[]},{"line":"         every other account_update in this transaction will also fail, and the excess","counters":[]},{"line":"         will never be promoted to the global excess, so this amount is","counters":[]},{"line":"         irrelevant.","counters":[]},{"line":"      *)","counters":[]},{"line":"      Amount.Signed.negate (Account_update.balance_change account_update)","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"    in","counters":[]},{"line":"    let new_local_fee_excess, `Overflow overflowed =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let curr_token : Token_id.t = local_state.token_id in","counters":[]},{"line":"      let curr_is_default = Token_id.(equal default) curr_token in","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"      (* We only allow the default token for fees. *)","counters":[]},{"line":"      assert_ ~pos:__POS__ curr_is_default ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Bool.(","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        assert_ ~pos:__POS__","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"          ( (not is_start')","counters":[]},{"line":"          ||| ( account_update_token_is_default","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              &&& Amount.Signed.is_pos local_delta ) )) ;","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"      let new_local_fee_excess, `Overflow overflow =","counters":[]},{"line":"        Amount.Signed.add_flagged local_state.excess local_delta","counters":[]},{"line":"      in","counters":[]},{"line":"      ( Amount.Signed.if_ account_update_token_is_default","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"          ~then_:new_local_fee_excess ~else_:local_state.excess","counters":[]},{"line":"      , (* No overflow if we aren't using the result of the addition (which we don't in the case that account_update token is not default). *)","counters":[]},{"line":"        `Overflow (Bool.( &&& ) account_update_token_is_default overflow) )","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"    in","counters":[]},{"line":"    let local_state = { local_state with excess = new_local_fee_excess } in","counters":[]},{"line":"    let local_state =","counters":[]},{"line":"      Local_state.add_check local_state Local_excess_overflow","counters":[]},{"line":"        (Bool.not overflowed)","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"    in","counters":[]},{"line":"    (* If a's token ID differs from that in the local state, then","counters":[]},{"line":"       the local state excess gets moved into the execution state's fee excess.","counters":[]},{"line":"","counters":[]},{"line":"       If there are more zkapp_command to execute after this one, then the local delta gets","counters":[]},{"line":"       accumulated in the local state.","counters":[]},{"line":"","counters":[]},{"line":"       If there are no more zkapp_command to execute, then we do the same as if we switch tokens.","counters":[]},{"line":"       The local state excess (plus the local delta) gets moved to the fee excess if it is default token.","counters":[]},{"line":"    *)","counters":[]},{"line":"    let new_ledger =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Inputs.Ledger.set_account local_state.ledger (a, inclusion_proof)","counters":[]},{"line":"    in","counters":[]},{"line":"    let is_last_account_update =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Call_forest.is_empty (Stack_frame.calls remaining)","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"    in","counters":[]},{"line":"    let local_state =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      { local_state with","counters":[]},{"line":"        ledger = new_ledger","counters":[]},{"line":"      ; transaction_commitment =","counters":[]},{"line":"          Transaction_commitment.if_ is_last_account_update","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"            ~then_:Transaction_commitment.empty","counters":[]},{"line":"            ~else_:local_state.transaction_commitment","counters":[]},{"line":"      ; full_transaction_commitment =","counters":[]},{"line":"          Transaction_commitment.if_ is_last_account_update","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"            ~then_:Transaction_commitment.empty","counters":[]},{"line":"            ~else_:local_state.full_transaction_commitment","counters":[]},{"line":"      }","counters":[]},{"line":"    in","counters":[]},{"line":"    let valid_fee_excess =","counters":[]},{"line":"      let delta_settled =","counters":[]},{"line":"        Amount.Signed.equal local_state.excess Amount.(Signed.of_unsigned zero)","counters":[{"col_start":72,"col_end":72,"count":0}]},{"line":"      in","counters":[]},{"line":"      (* 1) ignore local excess if it is_start because it will be promoted to global","counters":[]},{"line":"             excess and then set to zero later in the code","counters":[]},{"line":"         2) ignore everything but last account update since the excess wouldn't have","counters":[]},{"line":"            been settled","counters":[]},{"line":"         3) Excess should be settled after the last account update has been applied.","counters":[]},{"line":"      *)","counters":[]},{"line":"      Bool.(is_start' ||| not is_last_account_update ||| delta_settled)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"    in","counters":[]},{"line":"    let local_state =","counters":[]},{"line":"      Local_state.add_check local_state Invalid_fee_excess valid_fee_excess","counters":[]},{"line":"    in","counters":[]},{"line":"    let is_start_or_last = Bool.(is_start' ||| is_last_account_update) in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"    let update_global_state = Bool.(is_start_or_last &&& local_state.success) in","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"    let global_state, global_excess_update_failed, update_global_state =","counters":[]},{"line":"      let amt = Global_state.fee_excess global_state in","counters":[]},{"line":"      let res, `Overflow overflow =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Amount.Signed.add_flagged amt local_state.excess","counters":[]},{"line":"      in","counters":[]},{"line":"      let global_excess_update_failed =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Bool.(update_global_state &&& overflow)","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"      in","counters":[]},{"line":"      let update_global_state = Bool.(update_global_state &&& not overflow) in","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"      let new_amt =","counters":[]},{"line":"        Amount.Signed.if_ update_global_state ~then_:res ~else_:amt","counters":[]},{"line":"      in","counters":[]},{"line":"      ( Global_state.set_fee_excess global_state new_amt","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"      , global_excess_update_failed","counters":[]},{"line":"      , update_global_state )","counters":[]},{"line":"    in","counters":[]},{"line":"    let local_state =","counters":[]},{"line":"      { local_state with","counters":[]},{"line":"        excess =","counters":[]},{"line":"          Amount.Signed.if_ is_start_or_last","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"            ~then_:Amount.(Signed.of_unsigned zero)","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"            ~else_:local_state.excess","counters":[]},{"line":"      }","counters":[]},{"line":"    in","counters":[]},{"line":"    let local_state =","counters":[]},{"line":"      Local_state.add_check local_state Global_excess_overflow","counters":[]},{"line":"        Bool.(not global_excess_update_failed)","counters":[]},{"line":"    in","counters":[]},{"line":"    (* add local supply increase in global state *)","counters":[]},{"line":"    let new_global_supply_increase, global_supply_increase_update_failed =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let res, `Overflow overflow =","counters":[]},{"line":"        Amount.Signed.add_flagged","counters":[]},{"line":"          (Global_state.supply_increase global_state)","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"          local_state.supply_increase","counters":[]},{"line":"      in","counters":[]},{"line":"      (res, overflow)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    in","counters":[]},{"line":"    let local_state =","counters":[]},{"line":"      Local_state.add_check local_state Global_supply_increase_overflow","counters":[]},{"line":"        Bool.(not global_supply_increase_update_failed)","counters":[]},{"line":"    in","counters":[]},{"line":"    let global_state =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Global_state.set_supply_increase global_state","counters":[]},{"line":"        (Amount.Signed.if_","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"           Bool.(is_last_account_update &&& local_state.success)","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"           ~then_:new_global_supply_increase","counters":[]},{"line":"           ~else_:(Global_state.supply_increase global_state) )","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"    in","counters":[]},{"line":"    (* The first account_update must succeed. *)","counters":[]},{"line":"    Bool.(","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      assert_with_failure_status_tbl ~pos:__POS__","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"        ((not is_start') ||| local_state.success)","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"        local_state.failure_status_tbl) ;","counters":[]},{"line":"    let global_state =","counters":[]},{"line":"      Global_state.set_ledger ~should_update:update_global_state global_state","counters":[]},{"line":"        local_state.ledger","counters":[]},{"line":"    in","counters":[]},{"line":"    let local_state =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (* Make sure to reset the local_state at the end of a transaction.","counters":[]},{"line":"         The following fields are already reset","counters":[]},{"line":"         - zkapp_command","counters":[]},{"line":"         - transaction_commitment","counters":[]},{"line":"         - full_transaction_commitment","counters":[]},{"line":"         - excess","counters":[]},{"line":"         so we need to reset","counters":[]},{"line":"         - token_id = Token_id.default","counters":[]},{"line":"         - ledger = Frozen_ledger_hash.empty_hash","counters":[]},{"line":"         - success = true","counters":[]},{"line":"         - account_update_index = Index.zero","counters":[]},{"line":"         - supply_increase = Amount.Signed.zero","counters":[]},{"line":"      *)","counters":[]},{"line":"      { local_state with","counters":[]},{"line":"        token_id =","counters":[]},{"line":"          Token_id.if_ is_last_account_update ~then_:Token_id.default","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"            ~else_:local_state.token_id","counters":[]},{"line":"      ; ledger =","counters":[]},{"line":"          Inputs.Ledger.if_ is_last_account_update","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"            ~then_:","counters":[]},{"line":"              (Inputs.Ledger.empty ~depth:constraint_constants.ledger_depth ())","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"            ~else_:local_state.ledger","counters":[]},{"line":"      ; success =","counters":[]},{"line":"          Bool.if_ is_last_account_update ~then_:Bool.true_","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"            ~else_:local_state.success","counters":[]},{"line":"      ; account_update_index =","counters":[]},{"line":"          Inputs.Index.if_ is_last_account_update ~then_:Inputs.Index.zero","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"            ~else_:(Inputs.Index.succ local_state.account_update_index)","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"      ; supply_increase =","counters":[]},{"line":"          Amount.Signed.if_ is_last_account_update","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"            ~then_:Amount.(Signed.of_unsigned zero)","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"            ~else_:local_state.supply_increase","counters":[]},{"line":"      }","counters":[]},{"line":"    in","counters":[]},{"line":"    (global_state, local_state)","counters":[]},{"line":"","counters":[]},{"line":"  let step h state = apply ~is_start:`No h state","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"","counters":[]},{"line":"  let start start_data h state = apply ~is_start:(`Yes start_data) h state","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"end","counters":[]}]}