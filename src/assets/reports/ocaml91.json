{"filename":"src/lib/mina_base/ledger_hash.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Mina_base_import","counters":[]},{"line":"open Snark_params","counters":[]},{"line":"open Snarky_backendless","counters":[]},{"line":"open Tick","counters":[]},{"line":"open Let_syntax","counters":[]},{"line":"","counters":[]},{"line":"let merge_var ~height h1 h2 =","counters":[]},{"line":"  Random_oracle.Checked.hash ~init:(Hash_prefix.merkle_tree height) [| h1; h2 |]","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"","counters":[]},{"line":"module Merkle_tree =","counters":[]},{"line":"  Snarky_backendless.Merkle_tree.Checked","counters":[]},{"line":"    (Tick)","counters":[]},{"line":"    (struct","counters":[]},{"line":"      type value = Field.t","counters":[]},{"line":"","counters":[]},{"line":"      type var = Field.Var.t","counters":[]},{"line":"","counters":[]},{"line":"      let typ = Field.typ","counters":[]},{"line":"","counters":[]},{"line":"      let merge ~height h1 h2 =","counters":[]},{"line":"        Tick.make_checked (fun () -> merge_var ~height h1 h2)","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"      let assert_equal h1 h2 = Field.Checked.Assert.equal h1 h2","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"","counters":[]},{"line":"      let if_ = Field.Checked.if_","counters":[]},{"line":"    end)","counters":[]},{"line":"    (struct","counters":[]},{"line":"      include Account","counters":[]},{"line":"","counters":[]},{"line":"      let hash = Checked.digest","counters":[]},{"line":"    end)","counters":[]},{"line":"","counters":[]},{"line":"include Ledger_hash0","counters":[]},{"line":"","counters":[]},{"line":"(* End boilerplate *)","counters":[]},{"line":"let merge ~height (h1 : t) (h2 : t) =","counters":[]},{"line":"  Random_oracle.hash","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"    ~init:(Hash_prefix.merkle_tree height)","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"    [| (h1 :> field); (h2 :> field) |]","counters":[]},{"line":"  |> of_hash","counters":[]},{"line":"","counters":[]},{"line":"let empty_hash = of_hash Outside_hash_image.t","counters":[{"col_start":23,"col_end":23,"count":1}]},{"line":"","counters":[]},{"line":"let%bench \"Ledger_hash.merge ~height:1 empty_hash empty_hash\" =","counters":[]},{"line":"  merge ~height:1 empty_hash empty_hash","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let of_digest = Fn.compose Fn.id of_hash","counters":[{"col_start":25,"col_end":25,"count":1}]},{"line":"","counters":[]},{"line":"type path = Random_oracle.Digest.t list","counters":[]},{"line":"","counters":[]},{"line":"type _ Request.t +=","counters":[]},{"line":"  | Get_path : Account.Index.t -> path Request.t","counters":[]},{"line":"  | Get_element : Account.Index.t -> (Account.t * path) Request.t","counters":[]},{"line":"  | Set : Account.Index.t * Account.t -> unit Request.t","counters":[]},{"line":"  | Find_index : Account_id.t -> Account.Index.t Request.t","counters":[]},{"line":"","counters":[]},{"line":"let reraise_merkle_requests (With { request; respond }) =","counters":[]},{"line":"  match request with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | Merkle_tree.Get_path addr ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      respond (Delegate (Get_path addr))","counters":[]},{"line":"  | Merkle_tree.Set (addr, account) ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      respond (Delegate (Set (addr, account)))","counters":[]},{"line":"  | Merkle_tree.Get_element addr ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      respond (Delegate (Get_element addr))","counters":[]},{"line":"  | _ ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      unhandled","counters":[]},{"line":"","counters":[]},{"line":"let get ~depth t addr =","counters":[]},{"line":"  handle","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    (fun () -> Merkle_tree.get_req ~depth (var_to_hash_packed t) addr)","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"    reraise_merkle_requests","counters":[]},{"line":"","counters":[]},{"line":"(*","counters":[]},{"line":"   [modify_account t aid ~filter ~f] implements the following spec:","counters":[]},{"line":"","counters":[]},{"line":"   - finds an account [account] in [t] for [aid] at path [addr] where [filter","counters":[]},{"line":"     account] holds.","counters":[]},{"line":"     note that the account is not guaranteed to have identifier [aid]; it might","counters":[]},{"line":"     be a new account created to satisfy this request.","counters":[]},{"line":"   - returns a root [t'] of a tree of depth [depth] which is [t] but with the","counters":[]},{"line":"     account [f account] at path [addr].","counters":[]},{"line":"*)","counters":[]},{"line":"let%snarkydef_ modify_account ~depth t aid","counters":[]},{"line":"    ~(filter : Account.var -> 'a Checked.t) ~f =","counters":[]},{"line":"  let%bind addr =","counters":[]},{"line":"    request_witness","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"      (Account.Index.Unpacked.typ ~ledger_depth:depth)","counters":[]},{"line":"      As_prover.(map (read Account_id.typ aid) ~f:(fun s -> Find_index s))","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"  in","counters":[]},{"line":"  handle","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":7,"col_end":7,"count":0}]},{"line":"    (fun () ->","counters":[]},{"line":"      Merkle_tree.modify_req ~depth (var_to_hash_packed t) addr","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"        ~f:(fun account ->","counters":[]},{"line":"          let%bind x = filter account in","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"          f x account ) )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    reraise_merkle_requests","counters":[]},{"line":"  >>| var_of_hash_packed","counters":[]},{"line":"","counters":[]},{"line":"(*","counters":[]},{"line":"   [modify_account_send t aid ~f] implements the following spec:","counters":[]},{"line":"","counters":[]},{"line":"   - finds an account [account] in [t] at path [addr] whose account id is [aid]","counters":[]},{"line":"     OR it is a fee transfer and is an empty account","counters":[]},{"line":"   - returns a root [t'] of a tree of depth [depth] which is [t] but with the","counters":[]},{"line":"     account [f account] at path [addr].","counters":[]},{"line":"*)","counters":[]},{"line":"let%snarkydef_ modify_account_send ~depth t aid ~is_writeable ~f =","counters":[]},{"line":"  modify_account ~depth t aid","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    ~filter:(fun account ->","counters":[]},{"line":"      [%with_label_ \"modify_account_send filter\"] (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":47,"col_end":47,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"          let%bind account_already_there =","counters":[]},{"line":"            Account_id.Checked.equal (Account.identifier_of_var account) aid","counters":[{"col_start":35,"col_end":35,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%bind account_not_there =","counters":[]},{"line":"            Public_key.Compressed.Checked.equal account.public_key","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"              Public_key.Compressed.(var_of_t empty)","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%bind not_there_but_writeable =","counters":[]},{"line":"            Boolean.(account_not_there && is_writeable)","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%bind () =","counters":[]},{"line":"            [%with_label_ \"account is either present or empty and writeable\"]","counters":[{"col_start":75,"col_end":75,"count":0},{"col_start":76,"col_end":76,"count":0}]},{"line":"              (fun () ->","counters":[]},{"line":"                Boolean.Assert.any","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  [ account_already_there; not_there_but_writeable ] )","counters":[]},{"line":"          in","counters":[]},{"line":"          return not_there_but_writeable ) )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    ~f:(fun is_empty_and_writeable x -> f ~is_empty_and_writeable x)","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"(*","counters":[]},{"line":"   [modify_account_recv t aid ~f] implements the following spec:","counters":[]},{"line":"","counters":[]},{"line":"   - finds an account [account] in [t] at path [addr] whose account id is [aid]","counters":[]},{"line":"     OR which is an empty account","counters":[]},{"line":"   - returns a root [t'] of a tree of depth [depth] which is [t] but with the","counters":[]},{"line":"     account [f account] at path [addr].","counters":[]},{"line":"*)","counters":[]},{"line":"let%snarkydef_ modify_account_recv ~depth t aid ~f =","counters":[]},{"line":"  modify_account ~depth t aid","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    ~filter:(fun account ->","counters":[]},{"line":"      [%with_label_ \"modify_account_recv filter\"] (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":47,"col_end":47,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"          let%bind account_already_there =","counters":[]},{"line":"            Account_id.Checked.equal (Account.identifier_of_var account) aid","counters":[{"col_start":35,"col_end":35,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%bind account_not_there =","counters":[]},{"line":"            Public_key.Compressed.Checked.equal account.public_key","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"              Public_key.Compressed.(var_of_t empty)","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%bind () =","counters":[]},{"line":"            [%with_label_ \"account is either present or empty\"] (fun () ->","counters":[{"col_start":61,"col_end":61,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"                Boolean.Assert.any [ account_already_there; account_not_there ] )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"          in","counters":[]},{"line":"          return account_not_there ) )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    ~f:(fun is_empty_and_writeable x -> f ~is_empty_and_writeable x)","counters":[{"col_start":40,"col_end":40,"count":0},{"col_start":67,"col_end":67,"count":1}]}]}