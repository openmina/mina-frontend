{"filename":"src/lib/consensus/vrf/consensus_vrf.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Fold_lib","counters":[]},{"line":"open Snark_params","counters":[]},{"line":"","counters":[]},{"line":"module Scalar = struct","counters":[]},{"line":"  type t = Tick.Inner_curve.Scalar.t","counters":[]},{"line":"","counters":[]},{"line":"  type value = t","counters":[]},{"line":"","counters":[]},{"line":"  type var = Tick.Inner_curve.Scalar.var","counters":[]},{"line":"","counters":[]},{"line":"  let to_string = Tick.Inner_curve.Scalar.to_string","counters":[]},{"line":"","counters":[]},{"line":"  let of_string = Tick.Inner_curve.Scalar.of_string","counters":[]},{"line":"","counters":[]},{"line":"  let to_yojson t = `String (to_string t)","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"  let of_yojson yojson =","counters":[]},{"line":"    match yojson with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | `String x ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Or_error.try_with (fun () -> of_string x)","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"        |> Result.map_error ~f:Error.to_string_hum","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"    | _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Error \"Consensus_vrf.of_yojson: Expected a string\"","counters":[]},{"line":"","counters":[]},{"line":"  let typ : (var, value) Tick.Typ.t = Tick.Inner_curve.Scalar.typ","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Group = struct","counters":[]},{"line":"  open Tick","counters":[]},{"line":"","counters":[]},{"line":"  type t = Inner_curve.t [@@deriving sexp]","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"  let to_yojson (t : t) = Inner_curve.(Affine.to_yojson (to_affine_exn t))","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"","counters":[]},{"line":"  let of_yojson json =","counters":[]},{"line":"    Result.map ~f:Inner_curve.of_affine (Inner_curve.Affine.of_yojson json)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"","counters":[]},{"line":"  let to_string_list_exn (t : t) =","counters":[]},{"line":"    let x, y = Inner_curve.to_affine_exn t in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    [ Field.to_string x; Field.to_string y ]","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"  let of_string_list_exn = function","counters":[]},{"line":"    | [ x; y ] ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Inner_curve.of_affine (Field.of_string x, Field.of_string y)","counters":[{"col_start":45,"col_end":45,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"    | _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        invalid_arg","counters":[]},{"line":"          \"Consensus_vrf.Group.of_string_list_exn: wrong number of field \\","counters":[]},{"line":"           elements given, expected 2\"","counters":[]},{"line":"","counters":[]},{"line":"  type value = Inner_curve.t","counters":[]},{"line":"","counters":[]},{"line":"  type var = Inner_curve.var","counters":[]},{"line":"","counters":[]},{"line":"  let scale = Inner_curve.scale","counters":[]},{"line":"","counters":[]},{"line":"  let typ = Inner_curve.typ","counters":[]},{"line":"","counters":[]},{"line":"  let generator = Inner_curve.one","counters":[]},{"line":"","counters":[]},{"line":"  let add = Inner_curve.add","counters":[]},{"line":"","counters":[]},{"line":"  let negate = Inner_curve.negate","counters":[]},{"line":"","counters":[]},{"line":"  let to_affine_exn = Inner_curve.to_affine_exn","counters":[]},{"line":"","counters":[]},{"line":"  let of_affine = Inner_curve.of_affine","counters":[]},{"line":"","counters":[]},{"line":"  module Checked = struct","counters":[]},{"line":"    include Inner_curve.Checked","counters":[]},{"line":"","counters":[]},{"line":"    let scale_generator shifted s ~init =","counters":[]},{"line":"      scale_known shifted Inner_curve.one s ~init","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Message = struct","counters":[]},{"line":"  module Global_slot = Mina_numbers.Global_slot","counters":[]},{"line":"","counters":[]},{"line":"  type ('global_slot, 'epoch_seed, 'delegator) t =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    { global_slot : 'global_slot; seed : 'epoch_seed; delegator : 'delegator }","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":54,"col_end":54,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"  [@@deriving sexp, hlist]","counters":[]},{"line":"","counters":[]},{"line":"  type value =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    (Global_slot.t, Mina_base.Epoch_seed.t, Mina_base.Account.Index.t) t","counters":[]},{"line":"  [@@deriving sexp]","counters":[]},{"line":"","counters":[]},{"line":"  type var =","counters":[]},{"line":"    ( Global_slot.Checked.t","counters":[]},{"line":"    , Mina_base.Epoch_seed.var","counters":[]},{"line":"    , Mina_base.Account.Index.Unpacked.var )","counters":[]},{"line":"    t","counters":[]},{"line":"","counters":[]},{"line":"  let to_input","counters":[]},{"line":"      ~(constraint_constants : Genesis_constants.Constraint_constants.t)","counters":[]},{"line":"      ({ global_slot; seed; delegator } : value) =","counters":[]},{"line":"    let open Random_oracle.Input.Chunked in","counters":[{"col_start":4,"col_end":4,"count":4}]},{"line":"    Array.reduce_exn ~f:append","counters":[]},{"line":"      [| field (seed :> Tick.field)","counters":[{"col_start":13,"col_end":13,"count":4}]},{"line":"       ; Global_slot.to_input global_slot","counters":[{"col_start":28,"col_end":28,"count":4}]},{"line":"       ; Mina_base.Account.Index.to_input","counters":[{"col_start":40,"col_end":40,"count":4}]},{"line":"           ~ledger_depth:constraint_constants.ledger_depth delegator","counters":[]},{"line":"      |]","counters":[]},{"line":"","counters":[]},{"line":"  let typ ~(constraint_constants : Genesis_constants.Constraint_constants.t) :","counters":[]},{"line":"      (var, value) Tick.Typ.t =","counters":[]},{"line":"    Tick.Typ.of_hlistable","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      [ Global_slot.typ","counters":[]},{"line":"      ; Mina_base.Epoch_seed.typ","counters":[]},{"line":"      ; Mina_base.Account.Index.Unpacked.typ","counters":[]},{"line":"          ~ledger_depth:constraint_constants.ledger_depth","counters":[]},{"line":"      ]","counters":[]},{"line":"      ~var_to_hlist:to_hlist ~var_of_hlist:of_hlist ~value_to_hlist:to_hlist","counters":[]},{"line":"      ~value_of_hlist:of_hlist","counters":[]},{"line":"","counters":[]},{"line":"  let hash_to_group ~constraint_constants msg =","counters":[]},{"line":"    Random_oracle.hash ~init:Mina_base.Hash_prefix.vrf_message","counters":[{"col_start":4,"col_end":4,"count":2}]},{"line":"      (Random_oracle.pack_input (to_input ~constraint_constants msg))","counters":[{"col_start":30,"col_end":30,"count":2},{"col_start":40,"col_end":40,"count":2}]},{"line":"    |> Group_map.to_group |> Tick.Inner_curve.of_affine","counters":[{"col_start":7,"col_end":7,"count":2},{"col_start":29,"col_end":29,"count":2}]},{"line":"","counters":[]},{"line":"  module Checked = struct","counters":[]},{"line":"    let to_input ({ global_slot; seed; delegator } : var) =","counters":[]},{"line":"      let open Random_oracle.Input.Chunked in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Array.reduce_exn ~f:append","counters":[]},{"line":"        [| field (Mina_base.Epoch_seed.var_to_hash_packed seed)","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"         ; Global_slot.Checked.to_input global_slot","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"         ; Mina_base.Account.Index.Unpacked.to_input delegator","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"        |]","counters":[]},{"line":"","counters":[]},{"line":"    let hash_to_group msg =","counters":[]},{"line":"      let input = to_input msg in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Tick.make_checked (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          Random_oracle.Checked.hash ~init:Mina_base.Hash_prefix.vrf_message","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (Random_oracle.Checked.pack_input input)","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"          |> Group_map.Checked.to_group )","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let gen ~(constraint_constants : Genesis_constants.Constraint_constants.t) =","counters":[]},{"line":"    let open Quickcheck.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let%map global_slot = Global_slot.gen","counters":[]},{"line":"    and seed = Mina_base.Epoch_seed.gen","counters":[]},{"line":"    and delegator =","counters":[]},{"line":"      Mina_base.Account.Index.gen","counters":[]},{"line":"        ~ledger_depth:constraint_constants.ledger_depth","counters":[]},{"line":"    in","counters":[]},{"line":"    { global_slot; seed; delegator }","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(* c is a constant factor on vrf-win likelihood *)","counters":[]},{"line":"(* c = 2^0 is production behavior *)","counters":[]},{"line":"(* c > 2^0 is a temporary hack for testnets *)","counters":[]},{"line":"let c = `Two_to_the 0","counters":[]},{"line":"","counters":[]},{"line":"let c_bias =","counters":[]},{"line":"  let (`Two_to_the i) = c in","counters":[]},{"line":"  fun xs -> List.drop xs i","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"","counters":[]},{"line":"module Output = struct","counters":[]},{"line":"  module Truncated = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type t = string [@@deriving sexp, equal, compare, hash]","counters":[{"col_start":8,"col_end":8,"count":2},{"col_start":13,"col_end":13,"count":1},{"col_start":62,"col_end":62,"count":5}]},{"line":"","counters":[]},{"line":"        let to_yojson t =","counters":[]},{"line":"          `String (Base64.encode_exn ~alphabet:Base64.uri_safe_alphabet t)","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"        let of_yojson = function","counters":[]},{"line":"          | `String s ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Result.map_error","counters":[]},{"line":"                  (Base64.decode ~alphabet:Base64.uri_safe_alphabet s)","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                  ~f:(function `Msg err ->","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                  sprintf","counters":[]},{"line":"                    \"Error decoding vrf output in \\","counters":[]},{"line":"                     Vrf.Output.Truncated.Stable.V1.of_yojson: %s\"","counters":[]},{"line":"                    err )","counters":[]},{"line":"          | _ ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Error","counters":[]},{"line":"                \"Vrf.Output.Truncated.Stable.V1.of_yojson: Expected a string\"","counters":[]},{"line":"","counters":[]},{"line":"        let to_latest = Fn.id","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    include Codable.Make_base58_check (struct","counters":[]},{"line":"      type t = Stable.Latest.t [@@deriving bin_io_unversioned]","counters":[{"col_start":6,"col_end":6,"count":1},{"col_start":11,"col_end":11,"count":1},{"col_start":61,"col_end":61,"count":4}]},{"line":"","counters":[]},{"line":"      let version_byte = Base58_check.Version_bytes.vrf_truncated_output","counters":[]},{"line":"","counters":[]},{"line":"      let description = \"Vrf Truncated Output\"","counters":[]},{"line":"    end)","counters":[]},{"line":"","counters":[]},{"line":"    open Tick","counters":[]},{"line":"","counters":[]},{"line":"    let length_in_bits = Int.min 256 (Field.size_in_bits - 2)","counters":[{"col_start":31,"col_end":31,"count":1}]},{"line":"","counters":[]},{"line":"    type var = Boolean.var array","counters":[]},{"line":"","counters":[]},{"line":"    let typ : (var, t) Typ.t =","counters":[]},{"line":"      Typ.array ~length:length_in_bits Boolean.typ","counters":[]},{"line":"      |> Typ.transport","counters":[{"col_start":9,"col_end":9,"count":1},{"col_start":21,"col_end":21,"count":1}]},{"line":"           ~there:(fun s ->","counters":[]},{"line":"             Array.sub (Blake2.string_to_bits s) ~pos:0 ~len:length_in_bits )","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"           ~back:Blake2.bits_to_string","counters":[]},{"line":"","counters":[]},{"line":"    let dummy =","counters":[]},{"line":"      String.init","counters":[{"col_start":16,"col_end":16,"count":1}]},{"line":"        (Base.Int.round ~dir:`Up ~to_multiple_of:8 length_in_bits / 8)","counters":[{"col_start":22,"col_end":22,"count":1}]},{"line":"        ~f:(fun _ -> '\\000')","counters":[{"col_start":21,"col_end":21,"count":32}]},{"line":"","counters":[]},{"line":"    let to_bits t =","counters":[]},{"line":"      Fold.(to_list (string_bits t)) |> Fn.flip List.take length_in_bits","counters":[{"col_start":6,"col_end":6,"count":5},{"col_start":18,"col_end":18,"count":5},{"col_start":31,"col_end":31,"count":5}]},{"line":"","counters":[]},{"line":"    (* vrf_output / 2^256 *)","counters":[]},{"line":"    let to_fraction vrf_output =","counters":[]},{"line":"      let open Bignum_bigint in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let n =","counters":[]},{"line":"        of_bits_lsb (c_bias (Array.to_list (Blake2.string_to_bits vrf_output)))","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"      in","counters":[]},{"line":"      Bignum.(","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        of_bigint n / of_bigint Bignum_bigint.(shift_left one length_in_bits))","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"","counters":[]},{"line":"    let to_input (t : t) =","counters":[]},{"line":"      List.map (to_bits t) ~f:(fun b -> (Mina_base.Util.field_of_bool b, 1))","counters":[{"col_start":6,"col_end":6,"count":5},{"col_start":22,"col_end":22,"count":5},{"col_start":40,"col_end":40,"count":1265},{"col_start":68,"col_end":68,"count":1265}]},{"line":"      |> List.to_array |> Random_oracle.Input.Chunked.packeds","counters":[{"col_start":9,"col_end":9,"count":5},{"col_start":26,"col_end":26,"count":5}]},{"line":"","counters":[]},{"line":"    let var_to_input (t : var) =","counters":[]},{"line":"      Array.map t ~f:(fun b -> ((b :> Tick.Field.Var.t), 1))","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"      |> Random_oracle.Input.Chunked.packeds","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  open Tick","counters":[]},{"line":"","counters":[]},{"line":"  let typ = Field.typ","counters":[]},{"line":"","counters":[]},{"line":"  let gen = Field.gen","counters":[]},{"line":"","counters":[]},{"line":"  let truncate x =","counters":[]},{"line":"    Random_oracle.Digest.to_bits ~length:Truncated.length_in_bits x","counters":[{"col_start":4,"col_end":4,"count":2}]},{"line":"    |> Array.of_list |> Blake2.bits_to_string","counters":[{"col_start":7,"col_end":7,"count":2},{"col_start":24,"col_end":24,"count":2}]},{"line":"","counters":[]},{"line":"  let hash ~constraint_constants msg g =","counters":[]},{"line":"    let x, y = Non_zero_curve_point.of_inner_curve_exn g in","counters":[{"col_start":4,"col_end":4,"count":2}]},{"line":"    let input =","counters":[{"col_start":4,"col_end":4,"count":2}]},{"line":"      Random_oracle.Input.Chunked.(","counters":[]},{"line":"        append","counters":[{"col_start":13,"col_end":13,"count":2}]},{"line":"          (Message.to_input ~constraint_constants msg)","counters":[{"col_start":26,"col_end":26,"count":2}]},{"line":"          (field_elements [| x; y |]))","counters":[{"col_start":24,"col_end":24,"count":2}]},{"line":"    in","counters":[]},{"line":"    let open Random_oracle in","counters":[]},{"line":"    hash ~init:Hash_prefix_states.vrf_output (pack_input input)","counters":[{"col_start":55,"col_end":55,"count":2}]},{"line":"","counters":[]},{"line":"  module Checked = struct","counters":[]},{"line":"    let truncate x =","counters":[]},{"line":"      Tick.make_checked (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          Random_oracle.Checked.Digest.to_bits ~length:Truncated.length_in_bits","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            x","counters":[]},{"line":"          |> Array.of_list )","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"    let hash msg (x, y) =","counters":[]},{"line":"      let msg = Message.Checked.to_input msg in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let input =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Random_oracle.Input.Chunked.(append msg (field_elements [| x; y |]))","counters":[{"col_start":42,"col_end":42,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"      in","counters":[]},{"line":"      make_checked (fun () ->","counters":[]},{"line":"          let open Random_oracle.Checked in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          hash ~init:Hash_prefix_states.vrf_output (pack_input input) )","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let%test_unit \"hash unchecked vs. checked equality\" =","counters":[]},{"line":"    let constraint_constants =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Genesis_constants.Constraint_constants.for_unit_tests","counters":[]},{"line":"    in","counters":[]},{"line":"    let gen_inner_curve_point =","counters":[]},{"line":"      let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"      let%map compressed = Non_zero_curve_point.gen in","counters":[]},{"line":"      Non_zero_curve_point.to_inner_curve compressed","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    in","counters":[]},{"line":"    let gen_message_and_curve_point =","counters":[]},{"line":"      let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"      let%map msg = Message.gen ~constraint_constants","counters":[]},{"line":"      and g = gen_inner_curve_point in","counters":[]},{"line":"      (msg, g)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    in","counters":[]},{"line":"    Quickcheck.test ~trials:10 gen_message_and_curve_point","counters":[]},{"line":"      ~f:","counters":[]},{"line":"        (Test_util.test_equal ~equal:Field.equal","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"           Snark_params.Tick.Typ.(","counters":[]},{"line":"             Message.typ ~constraint_constants","counters":[]},{"line":"             * Snark_params.Tick.Inner_curve.typ)","counters":[]},{"line":"           typ","counters":[]},{"line":"           (fun (msg, g) -> Checked.hash msg g)","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"           (fun (msg, g) -> hash ~constraint_constants msg g) )","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Threshold = struct","counters":[]},{"line":"  open Unsigned","counters":[]},{"line":"","counters":[]},{"line":"  (* f determines the fraction of slots that will have blocks if c = 2^0 *)","counters":[]},{"line":"  let f = Bignum.(of_int 3 / of_int 4)","counters":[{"col_start":23,"col_end":23,"count":1},{"col_start":34,"col_end":34,"count":1}]},{"line":"","counters":[]},{"line":"  let base = Bignum.(of_int 1 - f)","counters":[{"col_start":26,"col_end":26,"count":1}]},{"line":"","counters":[]},{"line":"  let params =","counters":[]},{"line":"    Snarky_taylor.Exp.params ~base","counters":[]},{"line":"      ~field_size_in_bits:Snark_params.Tick.Field.size_in_bits","counters":[]},{"line":"","counters":[]},{"line":"  let bigint_of_uint64 = Fn.compose Bigint.of_string UInt64.to_string","counters":[{"col_start":34,"col_end":34,"count":1}]},{"line":"","counters":[]},{"line":"  (* Check if","counters":[]},{"line":"     vrf_output / 2^256 <= c * (1 - (1 - f)^(amount / total_stake))","counters":[]},{"line":"  *)","counters":[]},{"line":"  let is_satisfied ~my_stake ~total_stake vrf_output =","counters":[]},{"line":"    let open Currency in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let input =","counters":[]},{"line":"      (* get first params.per_term_precision bits of top / bottom.","counters":[]},{"line":"","counters":[]},{"line":"         This is equal to","counters":[]},{"line":"","counters":[]},{"line":"         floor(2^params.per_term_precision * top / bottom) / 2^params.per_term_precision","counters":[]},{"line":"      *)","counters":[]},{"line":"      let k = params.per_term_precision in","counters":[]},{"line":"      let top = bigint_of_uint64 (Balance.to_uint64 my_stake) in","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"      let bottom = bigint_of_uint64 (Amount.to_uint64 total_stake) in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"      Bignum.(","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        of_bigint Bignum_bigint.(shift_left top k / bottom)","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"        / of_bigint Bignum_bigint.(shift_left one k))","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"    in","counters":[]},{"line":"    let rhs = Snarky_taylor.Exp.Unchecked.one_minus_exp params input in","counters":[]},{"line":"    let lhs = Output.Truncated.to_fraction vrf_output in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Bignum.(lhs <= rhs)","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  module Checked = struct","counters":[]},{"line":"    let balance_upper_bound =","counters":[]},{"line":"      Bignum_bigint.(one lsl Currency.Balance.length_in_bits)","counters":[]},{"line":"","counters":[]},{"line":"    let amount_upper_bound =","counters":[]},{"line":"      Bignum_bigint.(one lsl Currency.Amount.length_in_bits)","counters":[]},{"line":"","counters":[]},{"line":"    let is_satisfied ~(my_stake : Currency.Balance.var)","counters":[]},{"line":"        ~(total_stake : Currency.Amount.var) (vrf_output : Output.Truncated.var)","counters":[]},{"line":"        =","counters":[]},{"line":"      let open Currency in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let open Snark_params.Tick in","counters":[]},{"line":"      let open Snarky_integer in","counters":[]},{"line":"      let open Snarky_taylor in","counters":[]},{"line":"      make_checked (fun () ->","counters":[]},{"line":"          let open Run in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let rhs =","counters":[]},{"line":"            Exp.one_minus_exp ~m params","counters":[]},{"line":"              (Floating_point.of_quotient ~m","counters":[]},{"line":"                 ~precision:params.per_term_precision","counters":[]},{"line":"                 ~top:","counters":[]},{"line":"                   (Integer.create","counters":[]},{"line":"                      ~value:(Balance.pack_var my_stake)","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"                      ~upper_bound:balance_upper_bound )","counters":[]},{"line":"                 ~bottom:","counters":[]},{"line":"                   (Integer.create","counters":[]},{"line":"                      ~value:(Amount.pack_var total_stake)","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"                      ~upper_bound:amount_upper_bound )","counters":[]},{"line":"                 ~top_is_less_than_bottom:() )","counters":[]},{"line":"          in","counters":[]},{"line":"          let vrf_output = Array.to_list (vrf_output :> Boolean.var array) in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let lhs = c_bias vrf_output in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          Floating_point.(","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            le ~m","counters":[]},{"line":"              (of_bits ~m lhs ~precision:Output.Truncated.length_in_bits)","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"              rhs) )","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Evaluation_hash = struct","counters":[]},{"line":"  let hash_for_proof ~constraint_constants message public_key g1 g2 =","counters":[]},{"line":"    let input =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let g_to_input g =","counters":[]},{"line":"        let f1, f2 = Group.to_affine_exn g in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Random_oracle_input.Chunked.field_elements [| f1; f2 |]","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      in","counters":[]},{"line":"      Array.reduce_exn ~f:Random_oracle_input.Chunked.append","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"        [| Message.to_input ~constraint_constants message","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"         ; g_to_input public_key","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"         ; g_to_input g1","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"         ; g_to_input g2","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"        |]","counters":[]},{"line":"    in","counters":[]},{"line":"    let tick_output =","counters":[]},{"line":"      Random_oracle.hash ~init:Mina_base.Hash_prefix.vrf_evaluation","counters":[]},{"line":"        (Random_oracle.pack_input input)","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"    in","counters":[]},{"line":"    (* This isn't great cryptographic practice.. *)","counters":[]},{"line":"    Tick.Field.unpack tick_output |> Tick.Inner_curve.Scalar.project","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"  module Checked = struct","counters":[]},{"line":"    let hash_for_proof message public_key g1 g2 =","counters":[]},{"line":"      let open Tick.Checked.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let input =","counters":[]},{"line":"        let g_to_input (f1, f2) =","counters":[]},{"line":"          Random_oracle_input.Chunked.field_elements [| f1; f2 |]","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        in","counters":[]},{"line":"        Array.reduce_exn ~f:Random_oracle_input.Chunked.append","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"          [| Message.Checked.to_input message","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"           ; g_to_input public_key","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"           ; g_to_input g1","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"           ; g_to_input g2","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"          |]","counters":[]},{"line":"      in","counters":[]},{"line":"      let%bind tick_output =","counters":[]},{"line":"        Tick.make_checked (fun () ->","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"            Random_oracle.Checked.hash","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              ~init:Mina_base.Hash_prefix.vrf_evaluation","counters":[]},{"line":"              (Random_oracle.Checked.pack_input input) )","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"      in","counters":[]},{"line":"      (* This isn't great cryptographic practice.. *)","counters":[]},{"line":"      Tick.Field.Checked.unpack_full tick_output","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Output_hash = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    [@@@no_toplevel_latest_type]","counters":[]},{"line":"","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      module T = struct","counters":[{"col_start":6,"col_end":6,"count":2}]},{"line":"        type t = (Snark_params.Tick.Field.t[@version_asserted])","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":13,"col_end":13,"count":1}]},{"line":"        [@@deriving sexp, compare, hash]","counters":[]},{"line":"      end","counters":[{"col_start":8,"col_end":8,"count":5}]},{"line":"","counters":[]},{"line":"      include T","counters":[]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  type t = Stable.Latest.t [@@deriving sexp, compare]","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"  type var = Random_oracle.Checked.Digest.t","counters":[]},{"line":"","counters":[]},{"line":"  let hash = Output.hash","counters":[]},{"line":"","counters":[]},{"line":"  module Checked = struct","counters":[]},{"line":"    let hash = Output.Checked.hash","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Integrated =","counters":[]},{"line":"  Vrf_lib.Integrated.Make (Tick) (Scalar) (Group) (Message) (Output_hash)","counters":[]},{"line":"","counters":[]},{"line":"module Standalone (Constraint_constants : sig","counters":[]},{"line":"  val constraint_constants : Genesis_constants.Constraint_constants.t","counters":[]},{"line":"end) =","counters":[]},{"line":"struct","counters":[]},{"line":"  open Constraint_constants","counters":[]},{"line":"","counters":[]},{"line":"  include","counters":[]},{"line":"    Vrf_lib.Standalone.Make (Tick) (Tick.Inner_curve.Scalar) (Group)","counters":[]},{"line":"      (struct","counters":[]},{"line":"        include Message","counters":[]},{"line":"","counters":[]},{"line":"        let typ = typ ~constraint_constants","counters":[]},{"line":"","counters":[]},{"line":"        let hash_to_group = hash_to_group ~constraint_constants","counters":[]},{"line":"      end)","counters":[]},{"line":"      (struct","counters":[]},{"line":"        include Output_hash","counters":[]},{"line":"","counters":[]},{"line":"        let hash = hash ~constraint_constants","counters":[]},{"line":"      end)","counters":[]},{"line":"      (struct","counters":[]},{"line":"        include Evaluation_hash","counters":[]},{"line":"","counters":[]},{"line":"        let hash_for_proof = hash_for_proof ~constraint_constants","counters":[]},{"line":"      end)","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"type evaluation =","counters":[]},{"line":"  ( Pasta_bindings.Pallas.t","counters":[]},{"line":"  , Pasta_bindings.Fq.t","counters":[]},{"line":"    Vrf_lib.Standalone.Evaluation.Discrete_log_equality.Poly.t )","counters":[]},{"line":"  Vrf_lib.Standalone.Evaluation.Poly.t","counters":[]},{"line":"","counters":[]},{"line":"type context =","counters":[]},{"line":"  ( (Unsigned.uint32, Pasta_bindings.Fp.t, int) Message.t","counters":[]},{"line":"  , Pasta_bindings.Pallas.t )","counters":[]},{"line":"  Vrf_lib.Standalone.Context.t","counters":[]},{"line":"","counters":[]},{"line":"module Layout = struct","counters":[]},{"line":"  (* NB: These types are carefully structured to match the GraphQL","counters":[]},{"line":"         representation. By keeping these in sync, we are able to pass the","counters":[]},{"line":"         output of GraphQL commands to the input of command line tools and vice","counters":[]},{"line":"         versa.","counters":[]},{"line":"  *)","counters":[]},{"line":"  module Message = struct","counters":[]},{"line":"    type t =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      { global_slot : Mina_numbers.Global_slot.t [@key \"globalSlot\"]","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"      ; epoch_seed : Mina_base.Epoch_seed.t [@key \"epochSeed\"]","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"      ; delegator_index : int [@key \"delegatorIndex\"]","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"      }","counters":[]},{"line":"    [@@deriving yojson]","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"    let to_message (t : t) : Message.value =","counters":[]},{"line":"      { global_slot = t.global_slot","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      ; seed = t.epoch_seed","counters":[]},{"line":"      ; delegator = t.delegator_index","counters":[]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    let of_message (t : Message.value) : t =","counters":[]},{"line":"      { global_slot = t.global_slot","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      ; epoch_seed = t.seed","counters":[]},{"line":"      ; delegator_index = t.delegator","counters":[]},{"line":"      }","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Threshold = struct","counters":[]},{"line":"    type t =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      { delegated_stake : Currency.Balance.t [@key \"delegatedStake\"]","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"      ; total_stake : Currency.Amount.t [@key \"totalStake\"]","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"      }","counters":[]},{"line":"    [@@deriving yojson]","counters":[]},{"line":"","counters":[]},{"line":"    let is_satisfied vrf_output t =","counters":[]},{"line":"      Threshold.is_satisfied ~my_stake:t.delegated_stake","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ~total_stake:t.total_stake vrf_output","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Evaluation = struct","counters":[]},{"line":"    type t =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      { message : Message.t","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"      ; public_key : Signature_lib.Public_key.t [@key \"publicKey\"]","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"      ; c : Scalar.t","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":12,"col_end":12,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"      ; s : Scalar.t","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":12,"col_end":12,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"      ; scaled_message_hash : Group.t [@key \"ScaledMessageHash\"]","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"      ; vrf_threshold : Threshold.t option [@default None] [@key \"vrfThreshold\"]","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"      ; vrf_output : Output.Truncated.t option","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"            [@default None] [@key \"vrfOutput\"]","counters":[]},{"line":"      ; vrf_output_fractional : float option","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"            [@default None] [@key \"vrfOutputFractional\"]","counters":[]},{"line":"      ; threshold_met : bool option [@default None] [@key \"thresholdMet\"]","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"      }","counters":[]},{"line":"    [@@deriving yojson]","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"    let to_evaluation_and_context (t : t) : evaluation * context =","counters":[]},{"line":"      ( { discrete_log_equality = { c = t.c; s = t.s }","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ; scaled_message_hash = t.scaled_message_hash","counters":[]},{"line":"        }","counters":[]},{"line":"      , { message = Message.to_message t.message","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"        ; public_key = Group.of_affine t.public_key","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"        } )","counters":[]},{"line":"","counters":[]},{"line":"    let of_evaluation_and_context ((evaluation, context) : evaluation * context)","counters":[]},{"line":"        : t =","counters":[]},{"line":"      { message = Message.of_message context.message","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"      ; public_key = Group.to_affine_exn context.public_key","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"      ; c = evaluation.discrete_log_equality.c","counters":[]},{"line":"      ; s = evaluation.discrete_log_equality.s","counters":[]},{"line":"      ; scaled_message_hash = evaluation.scaled_message_hash","counters":[]},{"line":"      ; vrf_threshold = None","counters":[]},{"line":"      ; vrf_output = None","counters":[]},{"line":"      ; vrf_output_fractional = None","counters":[]},{"line":"      ; threshold_met = None","counters":[]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    let of_message_and_sk ~constraint_constants (message : Message.t)","counters":[]},{"line":"        (private_key : Signature_lib.Private_key.t) =","counters":[]},{"line":"      let module Standalone = Standalone (struct","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let constraint_constants = constraint_constants","counters":[]},{"line":"      end) in","counters":[]},{"line":"      let message = Message.to_message message in","counters":[]},{"line":"      let standalone_eval = Standalone.Evaluation.create private_key message in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let context : Standalone.Context.t =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { message","counters":[]},{"line":"        ; public_key =","counters":[]},{"line":"            Signature_lib.Public_key.of_private_key_exn private_key","counters":[]},{"line":"            |> Group.of_affine","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"        }","counters":[]},{"line":"      in","counters":[]},{"line":"      of_evaluation_and_context (standalone_eval, context)","counters":[]},{"line":"","counters":[]},{"line":"    let to_vrf ~constraint_constants (t : t) =","counters":[]},{"line":"      let module Standalone = Standalone (struct","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let constraint_constants = constraint_constants","counters":[]},{"line":"      end) in","counters":[]},{"line":"      let standalone_eval, context = to_evaluation_and_context t in","counters":[]},{"line":"      Standalone.Evaluation.verified_output standalone_eval context","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let compute_vrf ~constraint_constants ?delegated_stake ?total_stake (t : t)","counters":[]},{"line":"        =","counters":[]},{"line":"      match to_vrf ~constraint_constants t with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          { t with","counters":[]},{"line":"            vrf_output = None","counters":[]},{"line":"          ; vrf_output_fractional = None","counters":[]},{"line":"          ; threshold_met = None","counters":[]},{"line":"          }","counters":[]},{"line":"      | Some vrf ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let vrf_output = Output.truncate vrf in","counters":[]},{"line":"          let vrf_output_fractional =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Output.Truncated.to_fraction vrf_output |> Bignum.to_float","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"          in","counters":[]},{"line":"          let vrf_threshold =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            match (delegated_stake, total_stake) with","counters":[]},{"line":"            | Some delegated_stake, Some total_stake ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Some { Threshold.delegated_stake; total_stake }","counters":[]},{"line":"            | _ ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                t.vrf_threshold","counters":[]},{"line":"          in","counters":[]},{"line":"          let threshold_met =","counters":[]},{"line":"            Option.map ~f:(Threshold.is_satisfied vrf_output) vrf_threshold","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"          in","counters":[]},{"line":"          { t with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            vrf_threshold","counters":[]},{"line":"          ; vrf_output = Some vrf_output","counters":[]},{"line":"          ; vrf_output_fractional = Some vrf_output_fractional","counters":[]},{"line":"          ; threshold_met","counters":[]},{"line":"          }","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let%test_unit \"Standalone and integrates vrfs are consistent\" =","counters":[]},{"line":"  let constraint_constants = Genesis_constants.Constraint_constants.compiled in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let module Standalone = Standalone (struct","counters":[]},{"line":"    let constraint_constants = constraint_constants","counters":[]},{"line":"  end) in","counters":[]},{"line":"  let inputs =","counters":[]},{"line":"    let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"    let%bind private_key = Signature_lib.Private_key.gen in","counters":[]},{"line":"    let%map message = Message.gen ~constraint_constants in","counters":[]},{"line":"    (private_key, message)","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  in","counters":[]},{"line":"  Quickcheck.test ~seed:(`Deterministic \"\") inputs","counters":[]},{"line":"    ~f:(fun (private_key, message) ->","counters":[]},{"line":"      let integrated_vrf =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Integrated.eval ~constraint_constants ~private_key message","counters":[]},{"line":"      in","counters":[]},{"line":"      let standalone_eval = Standalone.Evaluation.create private_key message in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let context : Standalone.Context.t =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { message","counters":[]},{"line":"        ; public_key =","counters":[]},{"line":"            Signature_lib.Public_key.of_private_key_exn private_key","counters":[]},{"line":"            |> Group.of_affine","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"        }","counters":[]},{"line":"      in","counters":[]},{"line":"      let standalone_vrf =","counters":[]},{"line":"        Standalone.Evaluation.verified_output standalone_eval context","counters":[]},{"line":"      in","counters":[]},{"line":"      [%test_eq: Output_hash.t option] (Some integrated_vrf) standalone_vrf )","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":76,"col_end":76,"count":1}]}]}