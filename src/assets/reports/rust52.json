{"filename":"src/fuzzing/coverage.rs","lines":[{"line":"use crate::coverage::cov::{Cov, FileCounters};","counters":[]},{"line":"use crate::coverage::reports::CoverageReport;","counters":[]},{"line":"use crate::coverage::stats::Stats;","counters":[]},{"line":"","counters":[]},{"line":"pub struct CoverageStats {","counters":[]},{"line":"    cov: Cov,","counters":[]},{"line":"    file_counters: Vec<FileCounters>,","counters":[]},{"line":"    pub rust: Option<Stats>,","counters":[]},{"line":"    pub ocaml: Option<Stats>,","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl CoverageStats {","counters":[]},{"line":"    pub fn new() -> Self {","counters":[{"col_start":4,"col_end":26,"count":0}]},{"line":"        let mut cov = Cov::new();","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"        let file_counters = cov.get_file_counters();","counters":[{"col_start":0,"col_end":52,"count":0}]},{"line":"        Self {","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"            cov,","counters":[{"col_start":0,"col_end":16,"count":0}]},{"line":"            file_counters,","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"            rust: None,","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"            ocaml: None,","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn update_ocaml(&mut self, bisect_dump: &Vec<(String, Vec<i64>, Vec<i64>)>) -> bool {","counters":[{"col_start":4,"col_end":93,"count":0}]},{"line":"        let caml_cov_stats = Stats::from_bisect_dump(&bisect_dump);","counters":[{"col_start":0,"col_end":66,"count":0}]},{"line":"        let coverage_increased = self.ocaml.is_none()","counters":[{"col_start":12,"col_end":30,"count":0},{"col_start":33,"col_end":53,"count":0}]},{"line":"        || caml_cov_stats.has_coverage_increased(&self.ocaml.as_ref().unwrap());","counters":[{"col_start":11,"col_end":79,"count":0}]},{"line":"","counters":[]},{"line":"        if coverage_increased","counters":[{"col_start":11,"col_end":29,"count":0}]},{"line":"        {","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"            let report_ocaml = CoverageReport::from_bisect_dump(&bisect_dump);","counters":[{"col_start":0,"col_end":78,"count":0}]},{"line":"            //println!(\"{}\", report_ocaml);","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"            println!(\"Saving coverage report (OCaml)\");","counters":[{"col_start":0,"col_end":55,"count":0}]},{"line":"            report_ocaml.write_files(\"ocaml\".to_string());","counters":[{"col_start":0,"col_end":58,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0},{"col_start":9,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"        self.ocaml = Some(caml_cov_stats);","counters":[{"col_start":8,"col_end":42,"count":0}]},{"line":"        coverage_increased","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn update_rust(&mut self) -> bool {","counters":[{"col_start":4,"col_end":43,"count":0}]},{"line":"        let rust_cov_stats = Stats::from_file_counters(&self.file_counters);","counters":[{"col_start":0,"col_end":75,"count":0}]},{"line":"        let coverage_increased = self.rust.is_none()","counters":[{"col_start":12,"col_end":30,"count":0},{"col_start":33,"col_end":52,"count":0}]},{"line":"        || rust_cov_stats.has_coverage_increased(&self.rust.as_ref().unwrap());","counters":[{"col_start":11,"col_end":78,"count":0}]},{"line":"","counters":[]},{"line":"        if coverage_increased","counters":[{"col_start":11,"col_end":29,"count":0}]},{"line":"        {","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"            let llvm_dump = self.cov.dump();","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"            let report_rust = CoverageReport::from_llvm_dump(&llvm_dump);","counters":[{"col_start":0,"col_end":73,"count":0}]},{"line":"            //println!(\"{}\", report_rust);","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"            println!(\"Saving coverage report (Rust)\");","counters":[{"col_start":0,"col_end":54,"count":0}]},{"line":"            report_rust.write_files(\"rust\".to_string());","counters":[{"col_start":0,"col_end":56,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0},{"col_start":9,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"        self.rust = Some(rust_cov_stats);","counters":[{"col_start":8,"col_end":41,"count":0}]},{"line":"        coverage_increased","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn print(&self) {","counters":[]},{"line":"        if let Some(stats) = &self.rust {","counters":[{"col_start":20,"col_end":25,"count":0},{"col_start":29,"col_end":39,"count":0},{"col_start":40,"col_end":41,"count":0}]},{"line":"            let rust_sources = vec![","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"                \"scan_state/transaction_logic.rs\",","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"                \"scan_state/zkapp_logic.rs\",","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"            ];","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"","counters":[]},{"line":"            let stats = stats.filter_filenames(&rust_sources);","counters":[{"col_start":0,"col_end":62,"count":0}]},{"line":"            println!(\"=== COV Rust ===\\n{}\", stats);","counters":[{"col_start":0,"col_end":52,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0},{"col_start":9,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"        if let Some(stats) = &self.ocaml {","counters":[{"col_start":20,"col_end":25,"count":0},{"col_start":29,"col_end":40,"count":0},{"col_start":41,"col_end":42,"count":0}]},{"line":"            let ocaml_sources = vec![","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"                \"lib/transaction_logic/mina_transaction_logic.ml\",","counters":[{"col_start":0,"col_end":66,"count":0}]},{"line":"                \"lib/transaction_logic/zkapp_command_logic.ml\",","counters":[{"col_start":0,"col_end":63,"count":0}]},{"line":"                \"lib/mina_base/zkapp_command.ml\",","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"                \"lib/mina_base/account_update.ml\",","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"                \"lib/mina_base/zkapp_precondition.ml\",","counters":[{"col_start":0,"col_end":54,"count":0}]},{"line":"            ];","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"","counters":[]},{"line":"            let stats = stats.filter_filenames(&ocaml_sources);","counters":[{"col_start":0,"col_end":63,"count":0}]},{"line":"            println!(\"=== COV OCaml ===\\n{}\", stats);","counters":[{"col_start":0,"col_end":53,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0},{"col_start":9,"col_end":10,"count":0}]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"}","counters":[]}]}