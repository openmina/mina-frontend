{"filename":"src/lib/pickles/wrap_main.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Pickles_types","counters":[]},{"line":"open Hlist","counters":[]},{"line":"open Common","counters":[]},{"line":"open Import","counters":[]},{"line":"open Types","counters":[]},{"line":"open Wrap_main_inputs","counters":[]},{"line":"open Impl","counters":[]},{"line":"module SC = Scalar_challenge","counters":[]},{"line":"","counters":[]},{"line":"(* Let's define an OCaml encoding for inductive NP sets. Let A be an inductive NP set.","counters":[]},{"line":"","counters":[]},{"line":"   To encode A, we require types [var(A)] and [value(A)] corresponding to","counters":[]},{"line":"   \\mathcal{U}(A) the underlying set of A.","counters":[]},{"line":"","counters":[]},{"line":"   Let r_1, ..., r_n be the inductive rules of A.","counters":[]},{"line":"   For each i, let (A_{i, 1}, ..., A_{i, k_i}) be the predecessor inductive sets for rule i.","counters":[]},{"line":"","counters":[]},{"line":"   We define a few type level lists.","counters":[]},{"line":"","counters":[]},{"line":"   - For each rule r_i,","counters":[]},{"line":"     [prev_vars(r_i) := var(A_{i, 1}) * (var(A_{i, 2}) * (... * var(A_{i, k_i})))]","counters":[]},{"line":"     [prev_values(r_i) := value(A_{i, 1}) * (value(A_{i, 2}) * (... * value(A_{i, k_i})))]","counters":[]},{"line":"","counters":[]},{"line":"   - [prev_varss(A) := map prev_vars (r_1, ..., r_n)]","counters":[]},{"line":"   - [prev_valuess(A) := map prev_values (r_1, ..., r_n)]","counters":[]},{"line":"","counters":[]},{"line":"   We use corresponding type variable names throughout this file.","counters":[]},{"line":"*)","counters":[]},{"line":"","counters":[]},{"line":"include Wrap_verifier.Make (Wrap_main_inputs)","counters":[]},{"line":"","counters":[]},{"line":"module Old_bulletproof_chals = struct","counters":[]},{"line":"  type t =","counters":[]},{"line":"    | T :","counters":[]},{"line":"        'max_local_max_proofs_verified Nat.t","counters":[]},{"line":"        * 'max_local_max_proofs_verified Challenges_vector.t","counters":[]},{"line":"        -> t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let pack_statement max_proofs_verified ~lookup t =","counters":[]},{"line":"  let open Types.Step in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  Spec.pack","counters":[]},{"line":"    (module Impl)","counters":[]},{"line":"    (Statement.spec","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"       (module Impl)","counters":[]},{"line":"       max_proofs_verified Backend.Tock.Rounds.n lookup )","counters":[]},{"line":"    (Statement.to_data t ~option_map:Plonk_types.Opt.map)","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"","counters":[]},{"line":"let shifts ~log2_size = Common.tock_shifts ~log2_size","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"","counters":[]},{"line":"let domain_generator ~log2_size =","counters":[]},{"line":"  Backend.Tock.Field.domain_generator ~log2_size |> Impl.Field.constant","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let split_field_typ : (Field.t * Boolean.var, Field.Constant.t) Typ.t =","counters":[]},{"line":"  Typ.transport","counters":[{"col_start":14,"col_end":14,"count":1}]},{"line":"    Typ.(field * Boolean.typ)","counters":[]},{"line":"    ~there:(fun (x : Field.Constant.t) ->","counters":[]},{"line":"      let n = Bigint.of_field x in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let is_odd = Bigint.test_bit n 0 in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let y = Field.Constant.((if is_odd then x - one else x) / of_int 2) in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":46,"col_end":46,"count":0},{"col_start":59,"col_end":59,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"      (y, is_odd) )","counters":[]},{"line":"    ~back:(fun (hi, is_odd) ->","counters":[]},{"line":"      let open Field.Constant in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let x = hi + hi in","counters":[]},{"line":"      if is_odd then x + one else x )","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"","counters":[]},{"line":"(* Split a field element into its high bits (packed) and the low bit.","counters":[]},{"line":"","counters":[]},{"line":"   It does not check that the \"high bits\" actually fit into n - 1 bits,","counters":[]},{"line":"   this is deferred to a call to scale_fast2, which performs this check.","counters":[]},{"line":"*)","counters":[]},{"line":"let split_field (x : Field.t) : Field.t * Boolean.var =","counters":[]},{"line":"  let ((y, is_odd) as res) =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    exists","counters":[]},{"line":"      Typ.(field * Boolean.typ)","counters":[]},{"line":"      ~compute:(fun () ->","counters":[]},{"line":"        let x = As_prover.read_var x in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let n = Bigint.of_field x in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let is_odd = Bigint.test_bit n 0 in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let y = Field.Constant.((if is_odd then x - one else x) / of_int 2) in","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":48,"col_end":48,"count":0},{"col_start":61,"col_end":61,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"        (y, is_odd) )","counters":[]},{"line":"  in","counters":[]},{"line":"  Field.(Assert.equal ((of_int 2 * y) + (is_odd :> t)) x) ;","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"  res","counters":[]},{"line":"","counters":[]},{"line":"let lookup_config = { Plonk_types.Lookup_config.lookup = No; runtime = No }","counters":[]},{"line":"","counters":[]},{"line":"let commitment_lookup_config =","counters":[]},{"line":"  { Plonk_types.Lookup_config.lookup = No; runtime = No }","counters":[]},{"line":"","counters":[]},{"line":"let lookup_config_for_pack =","counters":[]},{"line":"  { Types.Wrap.Lookup_parameters.zero = Common.Lookup_parameters.tock_zero","counters":[]},{"line":"  ; use = No","counters":[]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"(* The SNARK function for wrapping any proof coming from the given set of keys *)","counters":[]},{"line":"let wrap_main","counters":[]},{"line":"    (type max_proofs_verified branches prev_varss prev_valuess env","counters":[]},{"line":"    max_local_max_proofs_verifieds )","counters":[]},{"line":"    (full_signature :","counters":[]},{"line":"      ( max_proofs_verified","counters":[]},{"line":"      , branches","counters":[]},{"line":"      , max_local_max_proofs_verifieds )","counters":[]},{"line":"      Full_signature.t ) (pi_branches : (prev_varss, branches) Hlist.Length.t)","counters":[]},{"line":"    (step_keys :","counters":[]},{"line":"      (Wrap_main_inputs.Inner_curve.Constant.t index, branches) Vector.t Lazy.t","counters":[]},{"line":"      ) (step_widths : (int, branches) Vector.t)","counters":[]},{"line":"    (step_domains : (Domains.t, branches) Vector.t)","counters":[]},{"line":"    (max_proofs_verified :","counters":[]},{"line":"      (module Nat.Add.Intf with type n = max_proofs_verified) ) :","counters":[]},{"line":"    (max_proofs_verified, max_local_max_proofs_verifieds) Requests.Wrap.t","counters":[]},{"line":"    * (   ( _","counters":[]},{"line":"          , _","counters":[]},{"line":"          , _ Shifted_value.Type1.t","counters":[]},{"line":"          , _","counters":[]},{"line":"          , _","counters":[]},{"line":"          , _","counters":[]},{"line":"          , _","counters":[]},{"line":"          , _","counters":[]},{"line":"          , _ )","counters":[]},{"line":"          Types.Wrap.Statement.In_circuit.t","counters":[]},{"line":"       -> unit ) =","counters":[]},{"line":"  Timer.clock __LOC__ ;","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let module Max_proofs_verified = ( val max_proofs_verified : Nat.Add.Intf","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"                                       with type n = max_proofs_verified )","counters":[]},{"line":"  in","counters":[]},{"line":"  let T = Max_proofs_verified.eq in","counters":[]},{"line":"  let branches = Hlist.Length.to_nat pi_branches in","counters":[]},{"line":"  Timer.clock __LOC__ ;","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let (module Req) =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Requests.Wrap.(","counters":[]},{"line":"      (create () : (max_proofs_verified, max_local_max_proofs_verifieds) t))","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"  in","counters":[]},{"line":"  Timer.clock __LOC__ ;","counters":[]},{"line":"  let { Full_signature.padded; maxes = (module Max_widths_by_slot) } =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    full_signature","counters":[]},{"line":"  in","counters":[]},{"line":"  Timer.clock __LOC__ ;","counters":[]},{"line":"  let main","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      ({ proof_state =","counters":[]},{"line":"           { deferred_values =","counters":[]},{"line":"               { plonk","counters":[]},{"line":"               ; xi","counters":[]},{"line":"               ; combined_inner_product","counters":[]},{"line":"               ; b","counters":[]},{"line":"               ; branch_data","counters":[]},{"line":"               ; bulletproof_challenges","counters":[]},{"line":"               }","counters":[]},{"line":"           ; sponge_digest_before_evaluations","counters":[]},{"line":"           ; messages_for_next_wrap_proof = messages_for_next_wrap_proof_digest","counters":[]},{"line":"           }","counters":[]},{"line":"       ; messages_for_next_step_proof","counters":[]},{"line":"       } :","counters":[]},{"line":"        ( _","counters":[]},{"line":"        , _","counters":[]},{"line":"        , _ Shifted_value.Type1.t","counters":[]},{"line":"        , _","counters":[]},{"line":"        , _","counters":[]},{"line":"        , _","counters":[]},{"line":"        , _","counters":[]},{"line":"        , _","counters":[]},{"line":"        , Field.t )","counters":[]},{"line":"        Types.Wrap.Statement.In_circuit.t ) =","counters":[]},{"line":"    with_label __LOC__ (fun () ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        let which_branch' =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          exists","counters":[]},{"line":"            (Typ.transport Field.typ ~there:Field.Constant.of_int","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"               ~back:(fun _ -> failwith \"unimplemented\") )","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"            ~request:(fun () -> Req.Which_branch)","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"        in","counters":[]},{"line":"        let which_branch =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          One_hot_vector.of_index which_branch' ~length:branches","counters":[]},{"line":"        in","counters":[]},{"line":"        let actual_proofs_verified_mask =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Util.ones_vector","counters":[]},{"line":"            (module Impl)","counters":[]},{"line":"            ~first_zero:","counters":[]},{"line":"              (Pseudo.choose (which_branch, step_widths) ~f:Field.of_int)","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"            Max_proofs_verified.n","counters":[]},{"line":"        in","counters":[]},{"line":"        let domain_log2 =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Pseudo.choose","counters":[]},{"line":"            ( which_branch","counters":[]},{"line":"            , Vector.map ~f:(fun ds -> Domain.log2_size ds.h) step_domains )","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"            ~f:Field.of_int","counters":[]},{"line":"        in","counters":[]},{"line":"        let () =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (* Check that the branch_data public-input is correct *)","counters":[]},{"line":"          Branch_data.Checked.pack","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"            (module Impl)","counters":[]},{"line":"            { proofs_verified_mask =","counters":[]},{"line":"                Vector.extend_exn actual_proofs_verified_mask Nat.N2.n","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                  Boolean.false_","counters":[]},{"line":"            ; domain_log2","counters":[]},{"line":"            }","counters":[]},{"line":"          |> Field.Assert.equal branch_data","counters":[]},{"line":"        in","counters":[]},{"line":"        let prev_proof_state =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          with_label __LOC__ (fun () ->","counters":[]},{"line":"              let open Types.Step.Proof_state in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              let typ =","counters":[]},{"line":"                typ","counters":[]},{"line":"                  (module Impl)","counters":[]},{"line":"                  Common.Lookup_parameters.tock_zero","counters":[]},{"line":"                  ~assert_16_bits:(assert_n_bits ~n:16)","counters":[]},{"line":"                  (Vector.init Max_proofs_verified.n ~f:(fun _ ->","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                       Plonk_types.Opt.Flag.No ) )","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                  (Shifted_value.Type2.typ Field.typ)","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"              in","counters":[]},{"line":"              exists typ ~request:(fun () -> Req.Proof_state) )","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"        in","counters":[]},{"line":"        let step_plonk_index =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          with_label __LOC__ (fun () ->","counters":[]},{"line":"              choose_key which_branch","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (Vector.map (Lazy.force step_keys)","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"                   ~f:(Plonk_verification_key_evals.map ~f:Inner_curve.constant) ) )","counters":[]},{"line":"        in","counters":[]},{"line":"        let prev_step_accs =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          with_label __LOC__ (fun () ->","counters":[]},{"line":"              exists (Vector.typ Inner_curve.typ Max_proofs_verified.n)","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"                ~request:(fun () -> Req.Step_accs) )","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"        in","counters":[]},{"line":"        let old_bp_chals =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          with_label __LOC__ (fun () ->","counters":[]},{"line":"              let typ =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                let module T =","counters":[]},{"line":"                  H1.Typ (Impls.Wrap) (Nat) (Challenges_vector)","counters":[]},{"line":"                    (Challenges_vector.Constant)","counters":[]},{"line":"                    (struct","counters":[]},{"line":"                      let f (type n) (n : n Nat.t) =","counters":[]},{"line":"                        Vector.typ","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          (Vector.typ Field.typ Backend.Tock.Rounds.n)","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"                          n","counters":[]},{"line":"                    end)","counters":[]},{"line":"                in","counters":[]},{"line":"                T.f Max_widths_by_slot.maxes","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"              in","counters":[]},{"line":"              let module Z = H1.Zip (Nat) (Challenges_vector) in","counters":[]},{"line":"              let module M =","counters":[]},{"line":"                H1.Map","counters":[]},{"line":"                  (H1.Tuple2 (Nat) (Challenges_vector))","counters":[]},{"line":"                     (E01 (Old_bulletproof_chals))","counters":[]},{"line":"                  (struct","counters":[]},{"line":"                    let f (type n)","counters":[]},{"line":"                        ((n, v) : n H1.Tuple2(Nat)(Challenges_vector).t) =","counters":[]},{"line":"                      Old_bulletproof_chals.T (n, v)","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                  end)","counters":[]},{"line":"              in","counters":[]},{"line":"              let module V = H1.To_vector (Old_bulletproof_chals) in","counters":[]},{"line":"              Z.f Max_widths_by_slot.maxes","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                (exists typ ~request:(fun () -> Req.Old_bulletproof_challenges))","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"              |> M.f","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"              |> V.f Max_widths_by_slot.length )","counters":[]},{"line":"        in","counters":[]},{"line":"        let new_bulletproof_challenges =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          with_label __LOC__ (fun () ->","counters":[]},{"line":"              let evals =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                let ty =","counters":[]},{"line":"                  let ty =","counters":[]},{"line":"                    Plonk_types.All_evals.typ (module Impl) lookup_config","counters":[]},{"line":"                  in","counters":[]},{"line":"                  Vector.typ ty Max_proofs_verified.n","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"                in","counters":[]},{"line":"                exists ty ~request:(fun () -> Req.Evals)","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"              in","counters":[]},{"line":"              let chals =","counters":[]},{"line":"                let wrap_domains =","counters":[]},{"line":"                  let all_possible_domains =","counters":[]},{"line":"                    Wrap_verifier.all_possible_domains ()","counters":[]},{"line":"                  in","counters":[]},{"line":"                  let wrap_domain_indices =","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    exists (Vector.typ Field.typ Max_proofs_verified.n)","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                      ~request:(fun () -> Req.Wrap_domain_indices)","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"                  in","counters":[]},{"line":"                  Vector.map wrap_domain_indices ~f:(fun index ->","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"                      let which_branch =","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        One_hot_vector.of_index index","counters":[]},{"line":"                          ~length:Wrap_verifier.num_possible_domains","counters":[]},{"line":"                      in","counters":[]},{"line":"                      Pseudo.Domain.to_domain ~shifts ~domain_generator","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        (which_branch, all_possible_domains) )","counters":[]},{"line":"                in","counters":[]},{"line":"                Vector.mapn","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                  [ (* This is padded to max_proofs_verified for the benefit of wrapping with dummy unfinalized proofs *)","counters":[]},{"line":"                    prev_proof_state.unfinalized_proofs","counters":[]},{"line":"                  ; old_bp_chals","counters":[]},{"line":"                  ; evals","counters":[]},{"line":"                  ; wrap_domains","counters":[]},{"line":"                  ]","counters":[]},{"line":"                  ~f:(fun","counters":[]},{"line":"                       [ { deferred_values","counters":[]},{"line":"                         ; sponge_digest_before_evaluations","counters":[]},{"line":"                         ; should_finalize","counters":[]},{"line":"                         }","counters":[]},{"line":"                       ; old_bulletproof_challenges","counters":[]},{"line":"                       ; evals","counters":[]},{"line":"                       ; wrap_domain","counters":[]},{"line":"                       ]","counters":[]},{"line":"                     ->","counters":[]},{"line":"                    let sponge =","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      let s = Sponge.create sponge_params in","counters":[]},{"line":"                      Sponge.absorb s sponge_digest_before_evaluations ;","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                      s","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                    in","counters":[]},{"line":"","counters":[]},{"line":"                    (* the type of the local max proofs-verified depends on","counters":[]},{"line":"                       which kind of step proof we are wrapping. *)","counters":[]},{"line":"                    (* For each i in [0..max_proofs_verified-1], we have","counters":[]},{"line":"                       max_local_max_proofs_verified, which is the largest","counters":[]},{"line":"                       Local_max_proofs_verified which is the i^th inner proof of a step proof.","counters":[]},{"line":"","counters":[]},{"line":"                       Need to compute this value from the which_branch.","counters":[]},{"line":"                    *)","counters":[]},{"line":"                    let (T","counters":[]},{"line":"                          ( max_local_max_proofs_verified","counters":[]},{"line":"                          , old_bulletproof_challenges ) ) =","counters":[]},{"line":"                      old_bulletproof_challenges","counters":[]},{"line":"                    in","counters":[]},{"line":"                    let old_bulletproof_challenges =","counters":[]},{"line":"                      Wrap_hack.Checked.pad_challenges","counters":[]},{"line":"                        old_bulletproof_challenges","counters":[]},{"line":"                    in","counters":[]},{"line":"                    let finalized, chals =","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      with_label __LOC__ (fun () ->","counters":[]},{"line":"                          finalize_other_proof","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            (module Wrap_hack.Padded_length)","counters":[]},{"line":"                            ~domain:(wrap_domain :> _ Plonk_checks.plonk_domain)","counters":[]},{"line":"                            ~sponge ~old_bulletproof_challenges deferred_values","counters":[]},{"line":"                            evals )","counters":[]},{"line":"                    in","counters":[]},{"line":"                    Boolean.(Assert.any [ finalized; not should_finalize ]) ;","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"                    chals )","counters":[]},{"line":"              in","counters":[]},{"line":"              chals )","counters":[]},{"line":"        in","counters":[]},{"line":"        let prev_statement =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let prev_messages_for_next_wrap_proof =","counters":[]},{"line":"            Vector.map2 prev_step_accs old_bp_chals","counters":[]},{"line":"              ~f:(fun sacc (T (max_local_max_proofs_verified, chals)) ->","counters":[]},{"line":"                Wrap_hack.Checked.hash_messages_for_next_wrap_proof","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  max_local_max_proofs_verified","counters":[]},{"line":"                  { challenge_polynomial_commitment = sacc","counters":[]},{"line":"                  ; old_bulletproof_challenges = chals","counters":[]},{"line":"                  } )","counters":[]},{"line":"          in","counters":[]},{"line":"          { Types.Step.Statement.messages_for_next_wrap_proof =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              prev_messages_for_next_wrap_proof","counters":[]},{"line":"          ; proof_state = prev_proof_state","counters":[]},{"line":"          }","counters":[]},{"line":"        in","counters":[]},{"line":"        let openings_proof =","counters":[]},{"line":"          let shift = Shifts.tick1 in","counters":[]},{"line":"          exists","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"            (Plonk_types.Openings.Bulletproof.typ","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"               ( Typ.transport Other_field.Packed.typ","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                   ~there:(fun x ->","counters":[]},{"line":"                     (* When storing, make it a shifted value *)","counters":[]},{"line":"                     match","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                       Shifted_value.Type1.of_field","counters":[]},{"line":"                         (module Backend.Tick.Field)","counters":[]},{"line":"                         ~shift x","counters":[]},{"line":"                     with","counters":[]},{"line":"                     | Shifted_value x ->","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                         x )","counters":[]},{"line":"                   ~back:(fun x ->","counters":[]},{"line":"                     Shifted_value.Type1.to_field","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                       (module Backend.Tick.Field)","counters":[]},{"line":"                       ~shift (Shifted_value x) )","counters":[]},{"line":"               (* When reading, unshift *)","counters":[]},{"line":"               |> Typ.transport_var","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"                  (* For the var, we just wrap the now shifted underlying value. *)","counters":[]},{"line":"                    ~there:(fun (Shifted_value.Type1.Shifted_value x) -> x)","counters":[{"col_start":73,"col_end":73,"count":0}]},{"line":"                    ~back:(fun x -> Shifted_value x) )","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"               Inner_curve.typ","counters":[]},{"line":"               ~length:(Nat.to_int Backend.Tick.Rounds.n) )","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"            ~request:(fun () -> Req.Openings_proof)","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"        in","counters":[]},{"line":"        let ( sponge_digest_before_evaluations_actual","counters":[]},{"line":"            , (`Success bulletproof_success, bulletproof_challenges_actual) ) =","counters":[]},{"line":"          let messages =","counters":[]},{"line":"            with_label __LOC__ (fun () ->","counters":[]},{"line":"                exists","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  (Plonk_types.Messages.typ","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"                     (module Impl)","counters":[]},{"line":"                     Inner_curve.typ ~bool:Boolean.typ commitment_lookup_config","counters":[]},{"line":"                     ~dummy:Inner_curve.Params.one","counters":[]},{"line":"                     ~commitment_lengths:","counters":[]},{"line":"                       (Commitment_lengths.create ~of_int:Fn.id) )","counters":[]},{"line":"                  ~request:(fun () -> Req.Messages) )","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"          in","counters":[]},{"line":"          let sponge = Opt.create sponge_params in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          with_label __LOC__ (fun () ->","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"              incrementally_verify_proof max_proofs_verified","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ~actual_proofs_verified_mask ~step_domains","counters":[]},{"line":"                ~verification_key:step_plonk_index ~xi ~sponge","counters":[]},{"line":"                ~public_input:","counters":[]},{"line":"                  (Array.map","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                     (pack_statement Max_proofs_verified.n","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                        ~lookup:lookup_config_for_pack prev_statement )","counters":[]},{"line":"                     ~f:(function","counters":[]},{"line":"                    | `Field (Shifted_value x) ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        `Field (split_field x)","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"                    | `Packed_bits (x, n) ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        `Packed_bits (x, n) ) )","counters":[]},{"line":"                ~sg_old:prev_step_accs","counters":[]},{"line":"                ~advice:{ b; combined_inner_product }","counters":[]},{"line":"                ~messages ~which_branch ~openings_proof ~plonk )","counters":[]},{"line":"        in","counters":[]},{"line":"        with_label __LOC__ (fun () ->","counters":[]},{"line":"            Boolean.Assert.is_true bulletproof_success ) ;","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"        with_label __LOC__ (fun () ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            Field.Assert.equal messages_for_next_wrap_proof_digest","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (Wrap_hack.Checked.hash_messages_for_next_wrap_proof","counters":[{"col_start":65,"col_end":65,"count":0}]},{"line":"                 Max_proofs_verified.n","counters":[]},{"line":"                 { Types.Wrap.Proof_state.Messages_for_next_wrap_proof","counters":[]},{"line":"                   .challenge_polynomial_commitment =","counters":[]},{"line":"                     openings_proof.challenge_polynomial_commitment","counters":[]},{"line":"                 ; old_bulletproof_challenges = new_bulletproof_challenges","counters":[]},{"line":"                 } ) ) ;","counters":[]},{"line":"        with_label __LOC__ (fun () ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            Field.Assert.equal sponge_digest_before_evaluations","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              sponge_digest_before_evaluations_actual ) ;","counters":[]},{"line":"        Array.iter2_exn bulletproof_challenges_actual","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (Vector.to_array bulletproof_challenges)","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"          ~f:(fun","counters":[]},{"line":"               { prechallenge = { inner = x1 } }","counters":[]},{"line":"               ({ prechallenge = { inner = x2 } } :","counters":[]},{"line":"                 _ SC.t Bulletproof_challenge.t )","counters":[]},{"line":"             -> with_label __LOC__ (fun () -> Field.Assert.equal x1 x2) ) ;","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"        () )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"  in","counters":[]},{"line":"  Timer.clock __LOC__ ;","counters":[]},{"line":"  ((module Req), main)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":21,"col_end":21,"count":2}]}]}