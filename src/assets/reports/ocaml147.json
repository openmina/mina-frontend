{"filename":"src/lib/mina_ledger/ledger_transfer.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Mina_base","counters":[]},{"line":"","counters":[]},{"line":"module type Base_ledger_intf =","counters":[]},{"line":"  Merkle_ledger.Base_ledger_intf.S","counters":[]},{"line":"    with type account := Account.t","counters":[]},{"line":"     and type key := Signature_lib.Public_key.Compressed.t","counters":[]},{"line":"     and type token_id := Token_id.t","counters":[]},{"line":"     and type token_id_set := Token_id.Set.t","counters":[]},{"line":"     and type account_id := Account_id.t","counters":[]},{"line":"     and type account_id_set := Account_id.Set.t","counters":[]},{"line":"     and type hash := Ledger_hash.t","counters":[]},{"line":"     and type root_hash := Ledger_hash.t","counters":[]},{"line":"","counters":[]},{"line":"module Make","counters":[]},{"line":"    (Source : Base_ledger_intf)","counters":[]},{"line":"    (Dest : Base_ledger_intf with type Addr.t = Source.Addr.t) : sig","counters":[]},{"line":"  val transfer_accounts : src:Source.t -> dest:Dest.t -> Dest.t Or_error.t","counters":[]},{"line":"end = struct","counters":[]},{"line":"  let transfer_accounts ~src ~dest =","counters":[]},{"line":"    let accounts =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Source.foldi src ~init:[] ~f:(fun addr acc account ->","counters":[]},{"line":"          (* Printf.eprintf \"TRANSFER ADDR=%s\\n%!\" (Source.Addr.to_string addr) ; *)","counters":[]},{"line":"          (addr, account) :: acc )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    in","counters":[]},{"line":"    Dest.set_batch_accounts dest accounts ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let src_hash = Source.merkle_root src in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let dest_hash = Dest.merkle_root dest in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    if not (Ledger_hash.equal src_hash dest_hash) then","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"      Or_error.errorf","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        \"Merkle roots differ after transfer: expected %s, actual %s\"","counters":[]},{"line":"        (Ledger_hash.to_base58_check src_hash)","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"        (Ledger_hash.to_base58_check dest_hash)","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"    else Ok dest","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module From_sparse_ledger (Dest : Base_ledger_intf) : sig","counters":[]},{"line":"  val transfer_accounts :","counters":[]},{"line":"    src:Sparse_ledger.t -> dest:Dest.t -> Dest.t Or_error.t","counters":[]},{"line":"end = struct","counters":[]},{"line":"  let transfer_accounts ~src ~dest =","counters":[]},{"line":"    if Dest.depth dest = Sparse_ledger.depth src then","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"      let open Or_error.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%bind () =","counters":[]},{"line":"        Or_error.try_with (fun () ->","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"            Sparse_ledger.iteri src ~f:(fun _idx account ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"                let id = Account.identifier account in","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                ignore","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  ( Dest.get_or_create_account dest id account |> Or_error.ok_exn","counters":[{"col_start":66,"col_end":66,"count":0},{"col_start":80,"col_end":80,"count":0}]},{"line":"                    : [ `Added | `Existed ] * Dest.Location.t ) ) )","counters":[]},{"line":"      in","counters":[]},{"line":"      let src_hash = Sparse_ledger.merkle_root src in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let dest_hash = Dest.merkle_root dest in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      if not (Ledger_hash.equal src_hash dest_hash) then","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"        Or_error.errorf","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          \"Merkle roots differ after transfer: expected %s, actual %s\"","counters":[]},{"line":"          (Ledger_hash.to_base58_check src_hash)","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"          (Ledger_hash.to_base58_check dest_hash)","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"      else Ok dest","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"    else","counters":[]},{"line":"      Or_error.errorf","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        \"Ledger depth of src and dest doesn't match: src %d, dest %d\"","counters":[]},{"line":"        (Sparse_ledger.depth src) (Dest.depth dest)","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":1}]}]}