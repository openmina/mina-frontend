{"filename":"src/lib/merkle_list_prover/merkle_list_prover.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"module type Inputs_intf = sig","counters":[]},{"line":"  type value","counters":[]},{"line":"","counters":[]},{"line":"  type proof_elem","counters":[]},{"line":"","counters":[]},{"line":"  type context","counters":[]},{"line":"","counters":[]},{"line":"  module M : Monad.S","counters":[]},{"line":"","counters":[]},{"line":"  val to_proof_elem : value -> proof_elem","counters":[]},{"line":"","counters":[]},{"line":"  val get_previous : context:context -> value -> value option M.t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make_intf (M : Monad.S) (Input : Inputs_intf with module M := M) = struct","counters":[]},{"line":"  module type S = sig","counters":[]},{"line":"    val prove :","counters":[]},{"line":"         ?length:int","counters":[]},{"line":"      -> context:Input.context","counters":[]},{"line":"      -> Input.value","counters":[]},{"line":"      -> (Input.value * Input.proof_elem list) M.t","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make (M : Monad.S) (Input : Inputs_intf with module M := M) :","counters":[]},{"line":"  Make_intf(M)(Input).S = struct","counters":[]},{"line":"  let prove ?length ~context (last : Input.value) =","counters":[]},{"line":"    let rec find_path ~length value =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      if [%equal: int option] length (Some 0) then M.return (value, [])","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"      else","counters":[]},{"line":"        match%bind.M Input.get_previous ~context value with","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            M.return (value, [])","counters":[]},{"line":"        | Some parent ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let%map.M first, proofs =","counters":[]},{"line":"              find_path ~length:(Option.map length ~f:pred) parent","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"            in","counters":[]},{"line":"            (first, Input.to_proof_elem value :: proofs)","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"    in","counters":[]},{"line":"    let%map.M first, proofs = find_path ~length last in","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"    (first, List.rev proofs)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make_ident = Make (Monad.Ident)","counters":[{"col_start":37,"col_end":37,"count":2}]}]}