{"filename":"src/account/common.rs","lines":[{"line":"use ark_ff::{UniformRand, Zero};","counters":[]},{"line":"use mina_hasher::Fp;","counters":[]},{"line":"use o1_utils::{field_helpers::FieldHelpersError, FieldHelpers};","counters":[]},{"line":"","counters":[]},{"line":"use crate::{","counters":[]},{"line":"    hash::hash_noinputs,","counters":[]},{"line":"    scan_state::currency::{Amount, Balance, Slot},","counters":[]},{"line":"    ControlTag, ToInputs,","counters":[]},{"line":"};","counters":[]},{"line":"","counters":[]},{"line":"#[derive(Clone, Debug, Default, PartialEq, Eq)]","counters":[{"col_start":9,"col_end":14,"count":0},{"col_start":16,"col_end":21,"count":0},{"col_start":23,"col_end":30,"count":0},{"col_start":32,"col_end":41,"count":0}]},{"line":"pub struct VotingFor(pub Fp);","counters":[]},{"line":"","counters":[]},{"line":"impl VotingFor {","counters":[]},{"line":"    pub fn dummy() -> Self {","counters":[{"col_start":4,"col_end":28,"count":0}]},{"line":"        Self(Fp::zero())","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl ToInputs for VotingFor {","counters":[]},{"line":"    fn to_inputs(&self, inputs: &mut crate::Inputs) {","counters":[{"col_start":4,"col_end":53,"count":0}]},{"line":"        inputs.append_field(self.0);","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"#[derive(Clone, Debug, PartialEq, Eq)]","counters":[{"col_start":9,"col_end":14,"count":0},{"col_start":16,"col_end":21,"count":0},{"col_start":23,"col_end":32,"count":0}]},{"line":"pub struct ReceiptChainHash(pub Fp);","counters":[]},{"line":"","counters":[]},{"line":"impl ToInputs for ReceiptChainHash {","counters":[]},{"line":"    fn to_inputs(&self, inputs: &mut crate::Inputs) {","counters":[{"col_start":4,"col_end":53,"count":0}]},{"line":"        inputs.append_field(self.0);","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl ReceiptChainHash {","counters":[]},{"line":"    pub fn empty_legacy() -> Self {","counters":[{"col_start":4,"col_end":35,"count":0}]},{"line":"        // Value of `Receipt.Chain_hash.empty` in Ocaml (`compatible` branch)","counters":[{"col_start":0,"col_end":77,"count":0}]},{"line":"        Self::from_hex(\"0b143c0645497a5987a7b88f66340e03db943f0a0df48b69a3a82921ce97b10a\").unwrap()","counters":[{"col_start":0,"col_end":99,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn empty() -> Self {","counters":[{"col_start":4,"col_end":28,"count":0}]},{"line":"        Self(hash_noinputs(\"CodaReceiptEmpty\"))","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn from_hex(s: &str) -> Result<Self, FieldHelpersError> {","counters":[{"col_start":4,"col_end":65,"count":0}]},{"line":"        Fp::from_hex(s).map(|fp| Self(fp))","counters":[{"col_start":0,"col_end":28,"count":0},{"col_start":33,"col_end":41,"count":0},{"col_start":41,"col_end":42,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn gen() -> Self {","counters":[{"col_start":4,"col_end":26,"count":0}]},{"line":"        Self(Fp::rand(&mut rand::thread_rng()))","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Default for ReceiptChainHash {","counters":[]},{"line":"    fn default() -> Self {","counters":[{"col_start":4,"col_end":26,"count":0}]},{"line":"        Self::empty_legacy()","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"// CodaReceiptEmpty","counters":[]},{"line":"","counters":[]},{"line":"// https://github.com/MinaProtocol/mina/blob/develop/src/lib/mina_base/account_timing.ml#L31-L34","counters":[]},{"line":"#[derive(Clone, Debug, PartialEq, Eq)]","counters":[{"col_start":9,"col_end":10,"count":0},{"col_start":13,"col_end":14,"count":0},{"col_start":16,"col_end":17,"count":0},{"col_start":20,"col_end":21,"count":0},{"col_start":23,"col_end":24,"count":0},{"col_start":31,"col_end":32,"count":597}]},{"line":"pub enum Timing {","counters":[]},{"line":"    Untimed,","counters":[]},{"line":"    Timed {","counters":[]},{"line":"        initial_minimum_balance: Balance,","counters":[]},{"line":"        cliff_time: Slot,","counters":[]},{"line":"        cliff_amount: Amount,","counters":[]},{"line":"        vesting_period: Slot,","counters":[]},{"line":"        vesting_increment: Amount,","counters":[]},{"line":"    },","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"// https://github.com/MinaProtocol/mina/blob/develop/src/lib/mina_numbers/intf.ml#L155","counters":[]},{"line":"// pub type Nonce = u32;","counters":[]},{"line":"","counters":[]},{"line":"// https://github.com/MinaProtocol/mina/blob/develop/src/lib/mina_base/token_permissions.ml#L9","counters":[]},{"line":"#[derive(Clone, Debug, PartialEq, Eq)]","counters":[{"col_start":9,"col_end":10,"count":0},{"col_start":13,"col_end":14,"count":0},{"col_start":16,"col_end":17,"count":0},{"col_start":20,"col_end":21,"count":0},{"col_start":23,"col_end":24,"count":0},{"col_start":31,"col_end":32,"count":631}]},{"line":"pub enum TokenPermissions {","counters":[]},{"line":"    TokenOwned { disable_new_accounts: bool },","counters":[]},{"line":"    NotOwned { account_disabled: bool },","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Default for TokenPermissions {","counters":[]},{"line":"    fn default() -> Self {","counters":[{"col_start":4,"col_end":26,"count":0}]},{"line":"        Self::NotOwned {","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"            account_disabled: false,","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"// https://github.com/MinaProtocol/mina/blob/develop/src/lib/mina_base/permissions.mli#L10","counters":[]},{"line":"#[derive(Copy, Clone, Debug, PartialEq, Eq)]","counters":[{"col_start":15,"col_end":20,"count":0},{"col_start":22,"col_end":23,"count":0},{"col_start":26,"col_end":27,"count":0},{"col_start":29,"col_end":38,"count":0}]},{"line":"pub enum AuthRequired {","counters":[]},{"line":"    None,","counters":[]},{"line":"    Either,","counters":[]},{"line":"    Proof,","counters":[]},{"line":"    Signature,","counters":[]},{"line":"    Impossible,","counters":[]},{"line":"    Both, // Legacy only","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Default for AuthRequired {","counters":[]},{"line":"    fn default() -> Self {","counters":[{"col_start":4,"col_end":26,"count":0}]},{"line":"        Self::None","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl From<ControlTag> for AuthRequired {","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/mina_base/permissions.ml#L68","counters":[]},{"line":"    fn from(value: ControlTag) -> Self {","counters":[{"col_start":4,"col_end":40,"count":0}]},{"line":"        match value {","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"            ControlTag::Proof => Self::Proof,","counters":[{"col_start":33,"col_end":44,"count":0}]},{"line":"            ControlTag::Signature => Self::Signature,","counters":[{"col_start":37,"col_end":52,"count":0}]},{"line":"            ControlTag::NoneGiven => Self::None,","counters":[{"col_start":37,"col_end":47,"count":0}]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"#[derive(Copy, Clone, Debug)]","counters":[{"col_start":22,"col_end":27,"count":0}]},{"line":"pub struct AuthRequiredEncoded {","counters":[]},{"line":"    constant: bool,","counters":[]},{"line":"    signature_necessary: bool,","counters":[]},{"line":"    signature_sufficient: bool,","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl AuthRequired {","counters":[]},{"line":"    pub fn encode(self) -> AuthRequiredEncoded {","counters":[{"col_start":4,"col_end":47,"count":0}]},{"line":"        let (constant, signature_necessary, signature_sufficient) = match self {","counters":[{"col_start":13,"col_end":64,"count":0},{"col_start":74,"col_end":78,"count":0}]},{"line":"            AuthRequired::None => (true, false, true),","counters":[{"col_start":34,"col_end":53,"count":0}]},{"line":"            AuthRequired::Either => (false, false, true),","counters":[{"col_start":36,"col_end":56,"count":0}]},{"line":"            AuthRequired::Proof => (false, false, false),","counters":[{"col_start":35,"col_end":56,"count":0}]},{"line":"            AuthRequired::Signature => (false, true, true),","counters":[{"col_start":39,"col_end":58,"count":0}]},{"line":"            AuthRequired::Impossible => (true, true, false),","counters":[{"col_start":40,"col_end":59,"count":0}]},{"line":"            AuthRequired::Both => (false, true, false),","counters":[{"col_start":34,"col_end":54,"count":0}]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        AuthRequiredEncoded {","counters":[{"col_start":8,"col_end":29,"count":0}]},{"line":"            constant,","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"            signature_necessary,","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"            signature_sufficient,","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    /// permissions such that [check permission (Proof _)] is true","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/mina_base/permissions.ml#L78","counters":[]},{"line":"    pub fn gen_for_proof_authorization(rng: &mut rand::rngs::ThreadRng) -> Self {","counters":[{"col_start":4,"col_end":81,"count":0}]},{"line":"        use rand::seq::SliceRandom;","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"        [Self::None, Self::Either, Self::Proof]","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"            .choose(rng)","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"            .cloned()","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"            .unwrap()","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    /// permissions such that [check permission (Signature _)] is true","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/mina_base/permissions.ml#L82","counters":[]},{"line":"    pub fn gen_for_signature_authorization(rng: &mut rand::rngs::ThreadRng) -> Self {","counters":[{"col_start":4,"col_end":85,"count":0}]},{"line":"        use rand::seq::SliceRandom;","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"        [Self::None, Self::Either, Self::Signature]","counters":[{"col_start":0,"col_end":51,"count":0}]},{"line":"            .choose(rng)","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"            .cloned()","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"            .unwrap()","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    /// permissions such that [check permission None_given] is true","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/mina_base/permissions.ml#L86","counters":[]},{"line":"    pub fn gen_for_none_given_authorization(_rng: &mut rand::rngs::ThreadRng) -> Self {","counters":[{"col_start":4,"col_end":87,"count":0}]},{"line":"        Self::None","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl AuthRequiredEncoded {","counters":[]},{"line":"    pub fn decode(self) -> AuthRequired {","counters":[{"col_start":4,"col_end":41,"count":0}]},{"line":"        match (","counters":[{"col_start":0,"col_end":15,"count":0}]},{"line":"            self.constant,","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"            self.signature_necessary,","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"            self.signature_sufficient,","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"        ) {","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"            (true, _, false) => AuthRequired::Impossible,","counters":[{"col_start":32,"col_end":56,"count":0}]},{"line":"            (true, _, true) => AuthRequired::None,","counters":[{"col_start":31,"col_end":49,"count":0}]},{"line":"            (false, false, false) => AuthRequired::Proof,","counters":[{"col_start":37,"col_end":56,"count":0}]},{"line":"            (false, true, true) => AuthRequired::Signature,","counters":[{"col_start":35,"col_end":58,"count":0}]},{"line":"            (false, false, true) => AuthRequired::Either,","counters":[{"col_start":36,"col_end":56,"count":0}]},{"line":"            (false, true, false) => AuthRequired::Both,","counters":[{"col_start":36,"col_end":54,"count":0}]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn to_bits(self) -> [bool; 3] {","counters":[{"col_start":4,"col_end":39,"count":0}]},{"line":"        [","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"            self.constant,","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"            self.signature_necessary,","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"            self.signature_sufficient,","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"        ]","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]}]}