{"filename":"src/lib/mina_net2/libp2p_helper.ml","lines":[{"line":"open Async","counters":[]},{"line":"open Core","counters":[]},{"line":"open Pipe_lib","counters":[]},{"line":"","counters":[]},{"line":"exception Libp2p_helper_died_unexpectedly","counters":[]},{"line":"","counters":[]},{"line":"module Go_log = struct","counters":[]},{"line":"  let ours_of_go lvl =","counters":[]},{"line":"    let open Logger.Level in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    match lvl with","counters":[]},{"line":"    | \"error\" | \"panic\" | \"fatal\" ->","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"        Error","counters":[]},{"line":"    | \"warn\" ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Debug","counters":[]},{"line":"    | \"info\" ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (* this is intentionally debug, because the go info logs are too verbose for our info *)","counters":[]},{"line":"        Debug","counters":[]},{"line":"    | \"debug\" ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Spam","counters":[]},{"line":"    | _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Spam","counters":[]},{"line":"","counters":[]},{"line":"  (* there should be no other levels. *)","counters":[]},{"line":"","counters":[]},{"line":"  type record =","counters":[]},{"line":"    { ts : string","counters":[]},{"line":"    ; module_ : string [@key \"logger\"]","counters":[]},{"line":"    ; level : string","counters":[]},{"line":"    ; msg : string","counters":[]},{"line":"    ; metadata : Yojson.Safe.t String.Map.t","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let record_of_yojson (json : Yojson.Safe.t) =","counters":[]},{"line":"    let open Result.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let prefix = \"Mina_net2.Go_log.record_of_yojson: \" in","counters":[]},{"line":"    let string_of_yojson = function","counters":[]},{"line":"      | `String s ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Ok s","counters":[]},{"line":"      | _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Error \"Expected a string\"","counters":[]},{"line":"    in","counters":[]},{"line":"    let take_string map key =","counters":[]},{"line":"      match Map.find map key with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Some json -> (","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          match string_of_yojson json with","counters":[]},{"line":"          | Ok value ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Ok (value, Map.remove map key)","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"          | Error err ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Error","counters":[]},{"line":"                (Printf.sprintf \"%sCould not parse field '%s': %s\" prefix key","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                   err ) )","counters":[]},{"line":"      | None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Error (Printf.sprintf \"%sField '%s' is required\" prefix key)","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"    in","counters":[]},{"line":"    let rewrite_key map bad_key good_key =","counters":[]},{"line":"      match Map.find map bad_key with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Some data -> (","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          match Map.remove map bad_key |> Map.add ~key:good_key ~data with","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"          | `Ok map' ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Ok map'","counters":[]},{"line":"          | `Duplicate ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Error","counters":[]},{"line":"                (Printf.sprintf \"%sField '%s' should not already exist\" prefix","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                   good_key ) )","counters":[]},{"line":"      | None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Ok map","counters":[]},{"line":"    in","counters":[]},{"line":"    match json with","counters":[]},{"line":"    | `Assoc fields ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let obj = String.Map.of_alist_exn fields in","counters":[]},{"line":"        let%bind ts, obj = take_string obj \"ts\" in","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"        let%bind module_, obj = take_string obj \"logger\" in","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"        let%bind level, obj = take_string obj \"level\" in","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"        let%bind msg, obj = take_string obj \"msg\" in","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"        let%map metadata = rewrite_key obj \"error\" \"go_error\" in","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"        { ts; module_; level; msg; metadata }","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    | _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Error (prefix ^ \"Expected a JSON object\")","counters":[]},{"line":"","counters":[]},{"line":"  let record_to_message r =","counters":[]},{"line":"    Logger.Message.","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      { timestamp = Time.of_string r.ts","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"      ; level = ours_of_go r.level","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"      ; source =","counters":[]},{"line":"          Some","counters":[]},{"line":"            (Logger.Source.create","counters":[]},{"line":"               ~module_:(sprintf \"Libp2p_helper.Go.%s\" r.module_)","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"               ~location:\"(not tracked)\" )","counters":[]},{"line":"      ; message = String.concat [ \"libp2p_helper: \"; r.msg ]","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"      ; metadata = r.metadata","counters":[]},{"line":"      ; event_id = None","counters":[]},{"line":"      }","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let%test \"record_of_yojson 1\" =","counters":[]},{"line":"  let lines =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    [ \"{\\\"level\\\":\\\"info\\\",\\\"ts\\\":\\\"2021-09-20T16:36:34.150+0300\\\",\\\"logger\\\":\\\"helper \\","counters":[]},{"line":"       top-level JSON handling\\\",\\\"msg\\\":\\\"libp2p_helper has the following \\","counters":[]},{"line":"       logging subsystems active: [badger swarm2 p2p-config dht blankhost \\","counters":[]},{"line":"       connmgr ipns mplex reuseport-transport tcp-tpt basichost autorelay \\","counters":[]},{"line":"       addrutil dht.pb providers dht/RtRefreshManager mdns routedhost table \\","counters":[]},{"line":"       routing/record peerstore/ds test-logger peerstore autonat helper \\","counters":[]},{"line":"       top-level JSON handling relay codanet.Helper eventlog discovery nat \\","counters":[]},{"line":"       net/identify ping pubsub stream-upgrader diversityFilter]\\\"}\"","counters":[]},{"line":"    ; \"2021/09/20 17:38:12 capnp: decode: too many segments to decode\"","counters":[]},{"line":"    ]","counters":[]},{"line":"  in","counters":[]},{"line":"  List.equal Bool.equal","counters":[]},{"line":"    (List.map","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"       ~f:(fun line ->","counters":[]},{"line":"         try","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"           match line |> Yojson.Safe.from_string |> Go_log.record_of_yojson with","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"           | Ok _ ->","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"               true","counters":[]},{"line":"           | Error _ ->","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"               false","counters":[]},{"line":"         with _ -> false )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"       lines )","counters":[]},{"line":"    [ true; false ]","counters":[]},{"line":"","counters":[]},{"line":"type t =","counters":[]},{"line":"  { process : Child_processes.t","counters":[]},{"line":"  ; logger : Logger.t","counters":[]},{"line":"  ; mutable finished : bool","counters":[]},{"line":"  ; outstanding_requests :","counters":[]},{"line":"      Libp2p_ipc.rpc_response_body Or_error.t Ivar.t","counters":[]},{"line":"      Libp2p_ipc.Sequence_number.Table.t","counters":[]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"let handle_libp2p_helper_termination t ~pids ~killed result =","counters":[]},{"line":"  Hashtbl.iter t.outstanding_requests ~f:(fun iv ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      Ivar.fill_if_empty iv","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (Or_error.error_string \"libp2p_helper process died before answering\") ) ;","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"  Hashtbl.clear t.outstanding_requests ;","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  Child_processes.Termination.remove pids (Child_processes.pid t.process) ;","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"  if (not killed) && not t.finished then (","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"    match result with","counters":[]},{"line":"    | Ok ((Error (`Exit_non_zero _) | Error (`Signal _)) as e) ->","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"        [%log' fatal t.logger]","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"          !\"libp2p_helper process died unexpectedly: $exit_status\"","counters":[]},{"line":"          ~metadata:","counters":[]},{"line":"            [ (\"exit_status\", `String (Unix.Exit_or_signal.to_string_hum e)) ] ;","counters":[{"col_start":71,"col_end":71,"count":0}]},{"line":"        t.finished <- true ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        raise Libp2p_helper_died_unexpectedly","counters":[]},{"line":"    | Error err ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [%log' fatal t.logger]","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"          !\"Child processes library could not track libp2p_helper process: $err\"","counters":[]},{"line":"          ~metadata:[ (\"err\", Error_json.error_to_yojson err) ] ;","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"        t.finished <- true ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let%map () = Deferred.ignore_m (Child_processes.kill t.process) in","counters":[{"col_start":37,"col_end":37,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"        raise Libp2p_helper_died_unexpectedly","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    | Ok (Ok ()) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [%log' error t.logger]","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"          \"libp2p helper process exited peacefully but it should have been \\","counters":[]},{"line":"           killed by shutdown!\" ;","counters":[]},{"line":"        Deferred.unit )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"  else","counters":[]},{"line":"    let exit_status =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      match result with","counters":[]},{"line":"      | Ok e ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          `String (Unix.Exit_or_signal.to_string_hum e)","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"      | Error err ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Error_json.error_to_yojson err","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"    in","counters":[]},{"line":"    [%log' info t.logger]","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"      !\"libp2p_helper process killed successfully: $exit_status\"","counters":[]},{"line":"      ~metadata:[ (\"exit_status\", exit_status) ] ;","counters":[]},{"line":"    Deferred.unit","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"let handle_incoming_message t msg ~handle_push_message =","counters":[]},{"line":"  let open Libp2p_ipc.Reader in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let open DaemonInterface.Message in","counters":[]},{"line":"  let record_message_delay time_sent_ipc =","counters":[]},{"line":"    let message_delay =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Time_ns.diff (Time_ns.now ())","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"        (Libp2p_ipc.unix_nano_to_time_span time_sent_ipc)","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"    in","counters":[]},{"line":"    Mina_metrics.Network.(","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Ipc_latency_histogram.observe ipc_latency_ns_summary","counters":[]},{"line":"        (Time_ns.Span.to_ns message_delay))","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"  in","counters":[]},{"line":"  match msg with","counters":[]},{"line":"  | RpcResponse rpc_response ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      O1trace.sync_thread \"handle_libp2p_ipc_rpc_response\" (fun () ->","counters":[]},{"line":"          let rpc_header =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Libp2pHelperInterface.RpcResponse.header_get rpc_response","counters":[]},{"line":"          in","counters":[]},{"line":"          let sequence_number =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            RpcMessageHeader.sequence_number_get rpc_header","counters":[]},{"line":"          in","counters":[]},{"line":"          record_message_delay (RpcMessageHeader.time_sent_get rpc_header) ;","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"          match Hashtbl.find t.outstanding_requests sequence_number with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | Some ivar ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              if Ivar.is_full ivar then","counters":[]},{"line":"                [%log' error t.logger]","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"                  \"Attempted fill outstanding libp2p_helper RPC request more \\","counters":[]},{"line":"                   than once\"","counters":[]},{"line":"              else","counters":[]},{"line":"                Ivar.fill ivar","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  (Libp2p_ipc.rpc_response_to_or_error rpc_response)","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              [%log' error t.logger]","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                \"Attempted to fill outstanding libp2p_helper RPC request, but \\","counters":[]},{"line":"                 not outstanding request was found\" ) ;","counters":[]},{"line":"      Deferred.unit","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  | PushMessage push_msg ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      O1trace.thread \"handle_libp2p_ipc_push\" (fun () ->","counters":[]},{"line":"          let push_header = DaemonInterface.PushMessage.header_get push_msg in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          record_message_delay (PushMessageHeader.time_sent_get push_header) ;","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"          handle_push_message t (DaemonInterface.PushMessage.get push_msg) )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"  | Undefined n ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Libp2p_ipc.undefined_union ~context:\"DaemonInterface.Message\" n ;","counters":[]},{"line":"      Deferred.unit","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"let spawn ~logger ~pids ~conf_dir ~handle_push_message =","counters":[]},{"line":"  let termination_handler = ref (fun ~killed:_ _result -> Deferred.unit) in","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"  match%map","counters":[]},{"line":"    O1trace.thread \"manage_libp2p_helper_subprocess\" (fun () ->","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"        Child_processes.start_custom ~logger ~name:\"libp2p_helper\"","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ~git_root_relative_path:","counters":[]},{"line":"            \"src/app/libp2p_helper/result/bin/libp2p_helper\" ~conf_dir ~args:[]","counters":[]},{"line":"          ~stdout:`Chunks ~stderr:`Lines","counters":[]},{"line":"          ~termination:","counters":[]},{"line":"            (`Handler","counters":[]},{"line":"              (fun ~killed _process result ->","counters":[]},{"line":"                !termination_handler ~killed result ) ) )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"  with","counters":[]},{"line":"  | Error e ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Or_error.tag (Error e)","counters":[]},{"line":"        ~tag:","counters":[]},{"line":"          \"Could not start libp2p_helper. If you are a dev, did you forget to \\","counters":[]},{"line":"           `make libp2p_helper` and set MINA_LIBP2P_HELPER_PATH? Try \\","counters":[]},{"line":"           MINA_LIBP2P_HELPER_PATH=$PWD/src/app/libp2p_helper/result/bin/libp2p_helper.\"","counters":[]},{"line":"  | Ok process ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Child_processes.register_process pids process Libp2p_helper ;","counters":[]},{"line":"      let t =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { process","counters":[]},{"line":"        ; logger","counters":[]},{"line":"        ; finished = false","counters":[]},{"line":"        ; outstanding_requests = Libp2p_ipc.Sequence_number.Table.create ()","counters":[{"col_start":71,"col_end":71,"count":0}]},{"line":"        }","counters":[]},{"line":"      in","counters":[]},{"line":"      termination_handler := handle_libp2p_helper_termination t ~pids ;","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"      O1trace.background_thread \"handle_libp2p_helper_subprocess_logs\"","counters":[]},{"line":"        (fun () ->","counters":[]},{"line":"          Child_processes.stderr process","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"          |> Strict_pipe.Reader.iter ~f:(fun line ->","counters":[]},{"line":"                 Mina_metrics.(","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                   Counter.inc_one Mina_metrics.Network.ipc_logs_received_total) ;","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"                 let record_result =","counters":[]},{"line":"                   try","counters":[]},{"line":"                     Some","counters":[]},{"line":"                       (Go_log.record_of_yojson @@ Yojson.Safe.from_string line)","counters":[{"col_start":46,"col_end":46,"count":0},{"col_start":73,"col_end":73,"count":0}]},{"line":"                   with Yojson.Json_error _error -> None","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                 in","counters":[]},{"line":"                 ( match record_result with","counters":[]},{"line":"                 | Some (Ok record) ->","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"                     record |> Go_log.record_to_message |> Logger.raw logger","counters":[{"col_start":54,"col_end":54,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"                 | Some (Error error) ->","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"                     [%log error]","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                       \"failed to parse record over libp2p_helper stderr: \\","counters":[]},{"line":"                        $error\"","counters":[]},{"line":"                       ~metadata:[ (\"error\", `String error) ]","counters":[]},{"line":"                 | None ->","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"                     Core.print_endline line ) ;","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"                 Deferred.unit ) ) ;","counters":[]},{"line":"      O1trace.background_thread \"handle_libp2p_ipc_incoming\" (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          Child_processes.stdout process","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"          |> Libp2p_ipc.read_incoming_messages","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"          |> Strict_pipe.Reader.iter ~f:(function","counters":[]},{"line":"               | Ok msg ->","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                   let msg =","counters":[]},{"line":"                     Libp2p_ipc.Reader.DaemonInterface.Message.get msg","counters":[]},{"line":"                   in","counters":[]},{"line":"                   handle_incoming_message t msg ~handle_push_message","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"               | Error error ->","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                   [%log error]","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                     \"failed to parse IPC message over libp2p_helper stdout: \\","counters":[]},{"line":"                      $error\"","counters":[]},{"line":"                     ~metadata:","counters":[]},{"line":"                       [ (\"error\", `String (Error.to_string_hum error)) ] ;","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"                   Deferred.unit ) ) ;","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"      Or_error.return t","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"let shutdown t =","counters":[]},{"line":"  t.finished <- true ;","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  Deferred.ignore_m (Child_processes.kill t.process)","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"let do_rpc (type a b) (t : t) ((module Rpc) : (a, b) Libp2p_ipc.Rpcs.rpc)","counters":[]},{"line":"    (request : a) : b Deferred.Or_error.t =","counters":[]},{"line":"  let open Deferred.Or_error.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  if","counters":[]},{"line":"    (not t.finished)","counters":[]},{"line":"    && (not @@ Writer.is_closed (Child_processes.stdin t.process))","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":10,"col_end":10,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"  then (","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"    [%log' spam t.logger] \"sending $message_type to libp2p_helper\"","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"      ~metadata:[ (\"message_type\", `String Rpc.name) ] ;","counters":[]},{"line":"    let ivar = Ivar.create () in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let sequence_number = Libp2p_ipc.Sequence_number.create () in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Hashtbl.add_exn t.outstanding_requests ~key:sequence_number ~data:ivar ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    request |> Rpc.Request.to_rpc_request_body","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"    |> Libp2p_ipc.create_rpc_request ~sequence_number","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"    |> Libp2p_ipc.rpc_request_to_outgoing_message","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"    |> Libp2p_ipc.write_outgoing_message (Child_processes.stdin t.process) ;","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"    let%bind response = Ivar.read ivar in","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"    match Rpc.Response.of_rpc_response_body response with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Some r ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Deferred.Or_error.return r","counters":[]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Deferred.Or_error.error_string \"invalid RPC response\" )","counters":[]},{"line":"  else","counters":[]},{"line":"    Deferred.Or_error.errorf \"helper process already exited (doing RPC %s)\"","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Rpc.name","counters":[]},{"line":"","counters":[]},{"line":"let send_push ~msg t =","counters":[]},{"line":"  if","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    (not t.finished)","counters":[]},{"line":"    && (not @@ Writer.is_closed (Child_processes.stdin t.process))","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":10,"col_end":10,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"  then","counters":[]},{"line":"    Libp2p_ipc.push_message_to_outgoing_message msg","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"    |> Libp2p_ipc.write_outgoing_message (Child_processes.stdin t.process)","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"","counters":[]},{"line":"let send_validation ~validation_id ~validation_result =","counters":[]},{"line":"  send_push","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    ~msg:","counters":[]},{"line":"      (Libp2p_ipc.create_validation_push_message ~validation_id","counters":[]},{"line":"         ~validation_result )","counters":[]},{"line":"","counters":[]},{"line":"let send_add_resource ~tag ~body =","counters":[]},{"line":"  let open Staged_ledger_diff in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let tag = Body.Tag.to_enum tag in","counters":[]},{"line":"  let data = Body.to_binio_bigstring body |> Bigstring.to_string in","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"  send_push ~msg:(Libp2p_ipc.create_add_resource_push_message ~tag ~data)","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let send_heartbeat ~peer_id =","counters":[]},{"line":"  send_push ~msg:(Libp2p_ipc.create_heartbeat_peer_push_message ~peer_id)","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let test_with_libp2p_helper ?(logger = Logger.null ())","counters":[{"col_start":39,"col_end":39,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"    ?(handle_push_message = fun _ -> assert false) f =","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"  let pids = Pid.Table.create () in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  Thread_safe.block_on_async_exn (fun () ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      let%bind conf_dir = Async.Unix.mkdtemp \"libp2p_helper_test\" in","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"      let%bind helper =","counters":[]},{"line":"        spawn ~logger ~pids ~conf_dir ~handle_push_message >>| Or_error.ok_exn","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"      in","counters":[]},{"line":"      Monitor.protect","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (fun () -> f conf_dir helper)","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"        ~finally:(fun () ->","counters":[]},{"line":"          let%bind () = shutdown helper in","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"          File_system.remove_dir conf_dir ) )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"let%test_module \"bitswap blocks\" =","counters":[]},{"line":"  ( module struct","counters":[]},{"line":"    open Staged_ledger_diff.Bitswap_block","counters":[]},{"line":"","counters":[]},{"line":"    let%test_unit \"forall x: libp2p_helper#decode (daemon#encode x) = x\" =","counters":[]},{"line":"      Quickcheck.test For_tests.gen ~trials:100","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ~f:(fun (max_block_size, data) ->","counters":[]},{"line":"          let blocks, root_block_hash = blocks_of_data ~max_block_size data in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let result =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            test_with_libp2p_helper (fun _ helper ->","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"                let open Libp2p_ipc.Rpcs in","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                let request =","counters":[]},{"line":"                  TestDecodeBitswapBlocks.create_request","counters":[]},{"line":"                    ~blocks:","counters":[]},{"line":"                      (blocks |> Map.map ~f:Bigstring.to_string |> Map.to_alist)","counters":[{"col_start":39,"col_end":39,"count":0},{"col_start":78,"col_end":78,"count":0}]},{"line":"                    ~root_block_hash","counters":[]},{"line":"                in","counters":[]},{"line":"                do_rpc helper (module TestDecodeBitswapBlocks) request )","counters":[]},{"line":"            |> Or_error.ok_exn","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"            |> Libp2p_ipc.Reader.Libp2pHelperInterface.TestDecodeBitswapBlocks","counters":[]},{"line":"               .Response","counters":[]},{"line":"               .decoded_data_get |> Bigstring.of_string","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"          in","counters":[]},{"line":"          [%test_eq: Bigstring.t] data result )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"forall x: daemon#decode (libp2p_helper#encode x) = x\" =","counters":[]},{"line":"      Quickcheck.test For_tests.gen ~trials:100","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ~f:(fun (max_block_size, data) ->","counters":[]},{"line":"          let blocks, root_block_hash =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let resp =","counters":[]},{"line":"              test_with_libp2p_helper (fun _ helper ->","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"                  let open Libp2p_ipc.Rpcs in","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  let request =","counters":[]},{"line":"                    TestEncodeBitswapBlocks.create_request ~max_block_size","counters":[]},{"line":"                      ~data:(Bigstring.to_string data)","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"                  in","counters":[]},{"line":"                  do_rpc helper (module TestEncodeBitswapBlocks) request )","counters":[]},{"line":"              |> Or_error.ok_exn","counters":[]},{"line":"            in","counters":[]},{"line":"            let open Libp2p_ipc.Reader in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let open Libp2pHelperInterface.TestEncodeBitswapBlocks in","counters":[]},{"line":"            let blocks =","counters":[]},{"line":"              Capnp.Array.map_list (Response.blocks_get resp)","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"                ~f:(fun block_with_id ->","counters":[]},{"line":"                  let hash =","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    Blake2.of_raw_string","counters":[]},{"line":"                    @@ BlockWithId.blake2b_hash_get block_with_id","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                  in","counters":[]},{"line":"                  let block =","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    Bigstring.of_string @@ BlockWithId.block_get block_with_id","counters":[{"col_start":63,"col_end":63,"count":0}]},{"line":"                  in","counters":[]},{"line":"                  (hash, block) )","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"            in","counters":[]},{"line":"            let root_block_hash =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Blake2.of_raw_string @@ RootBlockId.blake2b_hash_get","counters":[{"col_start":65,"col_end":65,"count":0}]},{"line":"              @@ Response.root_block_id_get resp","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"            in","counters":[]},{"line":"            (Blake2.Map.of_alist_exn blocks, root_block_hash)","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"          in","counters":[]},{"line":"          let result =","counters":[]},{"line":"            Or_error.ok_exn (data_of_blocks blocks root_block_hash)","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"          in","counters":[]},{"line":"          [%test_eq: Bigstring.t] data result )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"  end )","counters":[{"col_start":6,"col_end":6,"count":2}]}]}