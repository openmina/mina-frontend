{"filename":"src/lib/mina_base/fee_transfer.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Mina_base_import","counters":[]},{"line":"","counters":[]},{"line":"(** See documentation of the {!Mina_wire_types} library *)","counters":[]},{"line":"module Wire_types = Mina_wire_types.Mina_base.Fee_transfer","counters":[]},{"line":"","counters":[]},{"line":"module Make_sig (A : Wire_types.Types.S) = struct","counters":[]},{"line":"  module type S =","counters":[]},{"line":"    Fee_transfer_intf.Full","counters":[]},{"line":"      with type Single.Stable.V2.t = A.Single.V2.t","counters":[]},{"line":"       and type Stable.V2.t = A.V2.t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make_str (A : Wire_types.Concrete) = struct","counters":[]},{"line":"  module Single = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V2 = struct","counters":[]},{"line":"        type t = A.Single.V2.t =","counters":[{"col_start":8,"col_end":8,"count":2},{"col_start":13,"col_end":13,"count":2}]},{"line":"          { receiver_pk : Public_key.Compressed.Stable.V1.t","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"          ; fee : Currency.Fee.Stable.V1.t","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":14,"col_end":14,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"          ; fee_token : Token_id.Stable.V2.t","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"          }","counters":[]},{"line":"        [@@deriving sexp, compare, equal, yojson, hash]","counters":[{"col_start":54,"col_end":54,"count":5}]},{"line":"","counters":[]},{"line":"        let to_latest = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"        let description = \"Fee transfer Single\"","counters":[]},{"line":"","counters":[]},{"line":"        let version_byte = Base58_check.Version_bytes.fee_transfer_single","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    include Comparable.Make (Stable.Latest)","counters":[]},{"line":"    module Base58_check = Codable.Make_base58_check (Stable.Latest)","counters":[]},{"line":"","counters":[]},{"line":"    [%%define_locally","counters":[]},{"line":"    Base58_check.(to_base58_check, of_base58_check, of_base58_check_exn)]","counters":[]},{"line":"","counters":[]},{"line":"    let create ~receiver_pk ~fee ~fee_token = { receiver_pk; fee; fee_token }","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"","counters":[]},{"line":"    let receiver_pk { receiver_pk; _ } = receiver_pk","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"","counters":[]},{"line":"    let receiver { receiver_pk; fee_token; _ } =","counters":[]},{"line":"      Account_id.create receiver_pk fee_token","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let fee { fee; _ } = fee","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"    let fee_token { fee_token; _ } = fee_token","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"    module Gen = struct","counters":[]},{"line":"      let with_random_receivers ?(min_fee = 0) ~keys ~max_fee ~token :","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"          t Quickcheck.Generator.t =","counters":[]},{"line":"        let open Quickcheck.Generator.Let_syntax in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let%map receiver_pk =","counters":[]},{"line":"          let open Signature_lib in","counters":[]},{"line":"          Quickcheck_lib.of_array keys","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"          >>| fun keypair -> Public_key.compress keypair.Keypair.public_key","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"        and fee = Int.gen_incl min_fee max_fee >>| Currency.Fee.of_int","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"        and fee_token = token in","counters":[]},{"line":"        { receiver_pk; fee; fee_token }","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    end","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V2 = struct","counters":[]},{"line":"      type t = Single.Stable.V2.t One_or_two.Stable.V1.t","counters":[{"col_start":6,"col_end":6,"count":2},{"col_start":11,"col_end":11,"count":1},{"col_start":15,"col_end":15,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"      [@@deriving sexp, compare, equal, yojson, hash]","counters":[{"col_start":52,"col_end":52,"count":5}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  type single = Single.t =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    { receiver_pk : Public_key.Compressed.t","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"    ; fee : Currency.Fee.t","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":8,"col_end":8,"count":0},{"col_start":12,"col_end":12,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"    ; fee_token : Token_id.t","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":14,"col_end":14,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"    }","counters":[]},{"line":"  [@@deriving sexp, compare, yojson, hash]","counters":[]},{"line":"","counters":[]},{"line":"  let to_singles = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"  let of_singles = function","counters":[]},{"line":"    | `One _ as t ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Or_error.return t","counters":[]},{"line":"    | `Two (one, two) as t ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        if Token_id.equal one.fee_token two.fee_token then Or_error.return t","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"        else","counters":[]},{"line":"          (* Necessary invariant for the transaction snark: we should never have","counters":[]},{"line":"             fee excesses in multiple tokens simultaneously.","counters":[]},{"line":"          *)","counters":[]},{"line":"          Or_error.errorf","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            !\"Cannot combine single fee transfers with incompatible tokens: \\","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"              %{sexp: Token_id.t} <> %{sexp: Token_id.t}\"","counters":[]},{"line":"            one.fee_token two.fee_token","counters":[]},{"line":"","counters":[]},{"line":"  let create one two =","counters":[]},{"line":"    let singles =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      match two with None -> `One one | Some two -> `Two (one, two)","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"    in","counters":[]},{"line":"    of_singles singles","counters":[]},{"line":"","counters":[]},{"line":"  let create_single ~receiver_pk ~fee ~fee_token =","counters":[]},{"line":"    `One (Single.create ~receiver_pk ~fee ~fee_token)","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  include Comparable.Make (Stable.Latest)","counters":[]},{"line":"","counters":[]},{"line":"  let fee_excess ft =","counters":[]},{"line":"    ft","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    |> One_or_two.map ~f:(fun { fee_token; fee; _ } ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"           (fee_token, Currency.Fee.Signed.(negate (of_unsigned fee))) )","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":49,"col_end":49,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"    |> Fee_excess.of_one_or_two","counters":[]},{"line":"","counters":[]},{"line":"  let receiver_pks t =","counters":[]},{"line":"    One_or_two.to_list (One_or_two.map ~f:Single.receiver_pk t)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"  let receivers t = One_or_two.to_list (One_or_two.map ~f:Single.receiver t)","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"","counters":[]},{"line":"  (* This must match [Transaction_union].","counters":[]},{"line":"     TODO: enforce this.","counters":[]},{"line":"  *)","counters":[]},{"line":"  let fee_payer_pk ft =","counters":[]},{"line":"    match ft with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | `One ft ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Single.receiver_pk ft","counters":[]},{"line":"    | `Two (_, ft) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Single.receiver_pk ft","counters":[]},{"line":"","counters":[]},{"line":"  let fee_token = Single.fee_token","counters":[]},{"line":"","counters":[]},{"line":"  let fee_tokens = One_or_two.map ~f:Single.fee_token","counters":[]},{"line":"","counters":[]},{"line":"  let map = One_or_two.map","counters":[]},{"line":"","counters":[]},{"line":"  let fold = One_or_two.fold","counters":[]},{"line":"","counters":[]},{"line":"  let to_list = One_or_two.to_list","counters":[]},{"line":"","counters":[]},{"line":"  let to_numbered_list = One_or_two.to_numbered_list","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"include Wire_types.Make (Make_sig) (Make_str)","counters":[{"col_start":44,"col_end":44,"count":1}]}]}