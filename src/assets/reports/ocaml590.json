{"filename":"src/lib/mina_base/coinbase_fee_transfer.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Mina_base_import","counters":[]},{"line":"","counters":[]},{"line":"(** See documentation of the {!Mina_wire_types} library *)","counters":[]},{"line":"module Wire_types = Mina_wire_types.Mina_base.Coinbase_fee_transfer","counters":[]},{"line":"","counters":[]},{"line":"module Make_sig (A : Wire_types.Types.S) = struct","counters":[]},{"line":"  module type S = Coinbase_fee_transfer_intf.Full with type Stable.V1.t = A.V1.t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make_str (A : Wire_types.Concrete) = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type t = A.V1.t =","counters":[{"col_start":6,"col_end":6,"count":2},{"col_start":11,"col_end":11,"count":2}]},{"line":"        { receiver_pk : Public_key.Compressed.Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"        ; fee : Currency.Fee.Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":12,"col_end":12,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"        }","counters":[]},{"line":"      [@@deriving sexp, compare, equal, yojson, hash]","counters":[{"col_start":52,"col_end":52,"count":5}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"      let description = \"Coinbase fee transfer\"","counters":[]},{"line":"","counters":[]},{"line":"      let version_byte = Base58_check.Version_bytes.fee_transfer_single","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  let create ~receiver_pk ~fee = { receiver_pk; fee }","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"","counters":[]},{"line":"  include Comparable.Make (Stable.Latest)","counters":[]},{"line":"  module Base58_check = Codable.Make_base58_check (Stable.Latest)","counters":[]},{"line":"","counters":[]},{"line":"  [%%define_locally","counters":[]},{"line":"  Base58_check.(to_base58_check, of_base58_check, of_base58_check_exn)]","counters":[]},{"line":"","counters":[]},{"line":"  let receiver_pk { receiver_pk; _ } = receiver_pk","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"  let receiver { receiver_pk; _ } =","counters":[]},{"line":"    Account_id.create receiver_pk Token_id.default","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let fee { fee; _ } = fee","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"  let to_fee_transfer { receiver_pk; fee } =","counters":[]},{"line":"    Fee_transfer.Single.create ~receiver_pk ~fee ~fee_token:Token_id.default","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  module Gen = struct","counters":[]},{"line":"    let gen ?(min_fee = Currency.Fee.zero) max_fee : t Quickcheck.Generator.t =","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"      let open Quickcheck.Generator.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%bind receiver_pk = Public_key.Compressed.gen in","counters":[]},{"line":"      let%map fee = Currency.Fee.gen_incl min_fee max_fee in","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"      { receiver_pk; fee }","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let with_random_receivers ~keys ?(min_fee = Currency.Fee.zero)","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"        coinbase_amount : t Quickcheck.Generator.t =","counters":[]},{"line":"      let open Quickcheck.Generator.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let max_fee = Currency.Amount.to_fee coinbase_amount in","counters":[]},{"line":"      let%map receiver_pk =","counters":[]},{"line":"        let open Signature_lib in","counters":[]},{"line":"        Quickcheck_lib.of_array keys","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"        >>| fun keypair -> Public_key.compress keypair.Keypair.public_key","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"      and fee = Currency.Fee.gen_incl min_fee max_fee in","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"      { receiver_pk; fee }","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"include Wire_types.Make (Make_sig) (Make_str)","counters":[{"col_start":44,"col_end":44,"count":1}]}]}