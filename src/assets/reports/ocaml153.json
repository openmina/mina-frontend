{"filename":"src/lib/verifier/dummy.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Async_kernel","counters":[]},{"line":"open Mina_base","counters":[]},{"line":"","counters":[]},{"line":"type t =","counters":[]},{"line":"  { proof_level : Genesis_constants.Proof_level.t","counters":[]},{"line":"  ; constraint_constants : Genesis_constants.Constraint_constants.t","counters":[]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"type invalid = Common.invalid [@@deriving bin_io_unversioned, to_yojson]","counters":[{"col_start":0,"col_end":0,"count":1},{"col_start":11,"col_end":11,"count":1},{"col_start":15,"col_end":15,"count":0},{"col_start":71,"col_end":71,"count":4}]},{"line":"","counters":[]},{"line":"let invalid_to_string = Common.invalid_to_string","counters":[]},{"line":"","counters":[]},{"line":"type ledger_proof = Ledger_proof.t","counters":[]},{"line":"","counters":[]},{"line":"let create ~logger:_ ~proof_level ~constraint_constants ~pids:_ ~conf_dir:_ =","counters":[]},{"line":"  match proof_level with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | Genesis_constants.Proof_level.Full ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      failwith \"Unable to handle proof-level=Full\"","counters":[]},{"line":"  | Check | None ->","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":12,"col_end":12,"count":0}]},{"line":"      Deferred.return { proof_level; constraint_constants }","counters":[]},{"line":"","counters":[]},{"line":"let verify_blockchain_snarks _ _ = Deferred.Or_error.return true","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"(* N.B.: Valid_assuming is never returned, in fact; we assert a return type","counters":[]},{"line":"   containing Valid_assuming to match the expected type","counters":[]},{"line":"*)","counters":[]},{"line":"let verify_commands _ (cs : User_command.Verifiable.t list) :","counters":[]},{"line":"    [ `Valid of Mina_base.User_command.Valid.t","counters":[]},{"line":"    | `Valid_assuming of","counters":[]},{"line":"      ( Pickles.Side_loaded.Verification_key.t","counters":[]},{"line":"      * Mina_base.Zkapp_statement.t","counters":[]},{"line":"      * Pickles.Side_loaded.Proof.t )","counters":[]},{"line":"      list","counters":[]},{"line":"    | Common.invalid ]","counters":[]},{"line":"    list","counters":[]},{"line":"    Deferred.Or_error.t =","counters":[]},{"line":"  List.map cs ~f:(fun c ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      match Common.check c with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | `Valid c ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          `Valid c","counters":[]},{"line":"      | `Valid_assuming (c, _) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          `Valid c","counters":[]},{"line":"      | `Invalid_keys keys ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          `Invalid_keys keys","counters":[]},{"line":"      | `Invalid_signature keys ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          `Invalid_signature keys","counters":[]},{"line":"      | `Invalid_proof ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          `Invalid_proof","counters":[]},{"line":"      | `Missing_verification_key keys ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          `Missing_verification_key keys )","counters":[]},{"line":"  |> Deferred.Or_error.return","counters":[{"col_start":5,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"let verify_transaction_snarks _ ts =","counters":[]},{"line":"  (* Don't check if the proof has default sok, becasue they were probably not","counters":[]},{"line":"     intended to be checked. If it has some value then check that against the","counters":[]},{"line":"     message passed.","counters":[]},{"line":"     This is particularly used to test that invalid proofs are not added to the","counters":[]},{"line":"     snark pool","counters":[]},{"line":"  *)","counters":[]},{"line":"  List.for_all ts ~f:(fun (proof, message) ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      let msg_digest = Sok_message.digest message in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let sok_digest = Transaction_snark.sok_digest proof in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Sok_message.Digest.(equal sok_digest default)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"      || Mina_base.Sok_message.Digest.equal sok_digest msg_digest )","counters":[]},{"line":"  |> Deferred.Or_error.return","counters":[{"col_start":5,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"let get_blockchain_verification_key { proof_level; constraint_constants } =","counters":[]},{"line":"  Deferred.Or_error.try_with (fun () ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      let module T = Transaction_snark.Make (struct","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let constraint_constants = constraint_constants","counters":[]},{"line":"","counters":[]},{"line":"        let proof_level = proof_level","counters":[]},{"line":"      end) in","counters":[]},{"line":"      let module B = Blockchain_snark.Blockchain_snark_state.Make (struct","counters":[]},{"line":"        let tag = T.tag","counters":[]},{"line":"","counters":[]},{"line":"        let constraint_constants = constraint_constants","counters":[]},{"line":"","counters":[]},{"line":"        let proof_level = proof_level","counters":[]},{"line":"      end) in","counters":[]},{"line":"      Deferred.return @@ Lazy.force B.Proof.verification_key )","counters":[{"col_start":34,"col_end":34,"count":0}]}]}