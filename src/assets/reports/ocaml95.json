{"filename":"src/lib/best_tip_prover/best_tip_prover.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Mina_base","counters":[]},{"line":"open Mina_state","counters":[]},{"line":"open Async_kernel","counters":[]},{"line":"open Mina_block","counters":[]},{"line":"","counters":[]},{"line":"module type Inputs_intf = sig","counters":[]},{"line":"  module Transition_frontier : module type of Transition_frontier","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make (Inputs : Inputs_intf) :","counters":[]},{"line":"  Mina_intf.Best_tip_prover_intf","counters":[]},{"line":"    with type transition_frontier := Inputs.Transition_frontier.t = struct","counters":[]},{"line":"  open Inputs","counters":[]},{"line":"","counters":[]},{"line":"  module type CONTEXT = sig","counters":[]},{"line":"    val logger : Logger.t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Merkle_list_prover = Merkle_list_prover.Make_ident (struct","counters":[]},{"line":"    type value = Mina_block.Validated.t","counters":[]},{"line":"","counters":[]},{"line":"    type context = Transition_frontier.t","counters":[]},{"line":"","counters":[]},{"line":"    type proof_elem = State_body_hash.t","counters":[]},{"line":"","counters":[]},{"line":"    let to_proof_elem = Mina_block.Validated.state_body_hash","counters":[]},{"line":"","counters":[]},{"line":"    let get_previous ~context transition =","counters":[]},{"line":"      let parent_hash =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        transition |> Mina_block.Validated.header |> Header.protocol_state","counters":[{"col_start":48,"col_end":48,"count":0},{"col_start":73,"col_end":73,"count":0}]},{"line":"        |> Protocol_state.previous_state_hash","counters":[]},{"line":"      in","counters":[]},{"line":"      let open Option.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%map breadcrumb = Transition_frontier.find context parent_hash in","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"      Transition_frontier.Breadcrumb.validated_transition breadcrumb","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  end)","counters":[]},{"line":"","counters":[]},{"line":"  module Merkle_list_verifier = Merkle_list_verifier.Make (struct","counters":[]},{"line":"    type hash = State_hash.t [@@deriving equal]","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"    type proof_elem = State_body_hash.t","counters":[]},{"line":"","counters":[]},{"line":"    let hash acc body_hash =","counters":[]},{"line":"      (Protocol_state.hashes_abstract ~hash_body:Fn.id","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"         { previous_state_hash = acc; body = body_hash } )","counters":[]},{"line":"        .state_hash","counters":[]},{"line":"  end)","counters":[]},{"line":"","counters":[]},{"line":"  let prove ~context:(module Context : CONTEXT) frontier =","counters":[]},{"line":"    let open Context in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let open Option.Let_syntax in","counters":[]},{"line":"    let genesis_constants = Transition_frontier.genesis_constants frontier in","counters":[]},{"line":"    let root = Transition_frontier.root frontier in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let root_state_hash = Frontier_base.Breadcrumb.state_hash root in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let root_is_genesis =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      State_hash.(","counters":[]},{"line":"        root_state_hash = Transition_frontier.genesis_state_hash frontier)","counters":[{"col_start":63,"col_end":63,"count":0}]},{"line":"    in","counters":[]},{"line":"    let%map () =","counters":[]},{"line":"      Option.some_if","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"        ( Transition_frontier.best_tip_path_length_exn frontier","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"          = Transition_frontier.global_max_length genesis_constants","counters":[{"col_start":48,"col_end":48,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"        || root_is_genesis )","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"        ()","counters":[]},{"line":"    in","counters":[]},{"line":"    let best_tip_breadcrumb = Transition_frontier.best_tip frontier in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let best_verified_tip =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Transition_frontier.Breadcrumb.validated_transition best_tip_breadcrumb","counters":[]},{"line":"    in","counters":[]},{"line":"    let best_tip = Mina_block.Validated.forget best_verified_tip in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let root =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Transition_frontier.root frontier","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"      |> Transition_frontier.Breadcrumb.validated_transition","counters":[]},{"line":"    in","counters":[]},{"line":"    let _, merkle_list =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Merkle_list_prover.prove ~context:frontier best_verified_tip","counters":[]},{"line":"    in","counters":[]},{"line":"    [%log debug]","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"      ~metadata:","counters":[]},{"line":"        [ ( \"merkle_list\"","counters":[]},{"line":"          , `List (List.map ~f:State_body_hash.to_yojson merkle_list) )","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"        ]","counters":[]},{"line":"      \"Best tip prover produced a merkle list of $merkle_list\" ;","counters":[]},{"line":"    Proof_carrying_data.","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      { data = best_tip","counters":[]},{"line":"      ; proof = (merkle_list, With_hash.data @@ Mina_block.Validated.forget root)","counters":[{"col_start":43,"col_end":43,"count":0},{"col_start":74,"col_end":74,"count":0}]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"  let validate_proof ~verifier ~genesis_state_hash","counters":[]},{"line":"      (transition_with_hash : Mina_block.with_hash) :","counters":[]},{"line":"      Mina_block.initial_valid_block Deferred.Or_error.t =","counters":[]},{"line":"    let%map validation =","counters":[]},{"line":"      let open Deferred.Result.Let_syntax in","counters":[]},{"line":"      Validation.wrap transition_with_hash","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"      |> Validation.skip_time_received_validation","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"           `This_block_was_not_received_via_gossip","counters":[]},{"line":"      |> Validation.skip_delta_block_chain_validation","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"           `This_block_was_not_received_via_gossip","counters":[]},{"line":"      |> Fn.compose Deferred.return Validation.validate_protocol_versions","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"      >>= Fn.compose Deferred.return","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"            (Validation.validate_genesis_protocol_state ~genesis_state_hash)","counters":[]},{"line":"      >>= Validation.validate_single_proof ~verifier ~genesis_state_hash","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    in","counters":[]},{"line":"    match validation with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Ok block ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Ok block","counters":[]},{"line":"    | Error err ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Or_error.error_string","counters":[]},{"line":"          ( match err with","counters":[]},{"line":"          | `Invalid_genesis_protocol_state ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              \"invalid genesis state\"","counters":[]},{"line":"          | `Invalid_protocol_version | `Mismatched_protocol_version ->","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"              \"invalid protocol version\"","counters":[]},{"line":"          | `Invalid_proof ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              \"invalid proof\"","counters":[]},{"line":"          | `Verifier_error e ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Printf.sprintf \"verifier error: %s\" (Error.to_string_hum e) )","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"","counters":[]},{"line":"  let verify ~verifier ~genesis_constants ~precomputed_values","counters":[]},{"line":"      { Proof_carrying_data.data = best_tip; proof = merkle_list, root } =","counters":[]},{"line":"    let open Deferred.Or_error.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let merkle_list_length = List.length merkle_list in","counters":[]},{"line":"    let max_length = Transition_frontier.global_max_length genesis_constants in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let genesis_protocol_state =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Precomputed_values.genesis_state_with_hashes precomputed_values","counters":[]},{"line":"    in","counters":[]},{"line":"    let genesis_state_hash =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      State_hash.With_state_hashes.state_hash genesis_protocol_state","counters":[]},{"line":"    in","counters":[]},{"line":"    let state_hashes block =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Mina_block.header block |> Header.protocol_state |> Protocol_state.hashes","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"    in","counters":[]},{"line":"    let root_state_hash = (state_hashes root).state_hash in","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"    let root_is_genesis = State_hash.(root_state_hash = genesis_state_hash) in","counters":[]},{"line":"    let%bind () =","counters":[]},{"line":"      Deferred.return","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"        (Result.ok_if_true","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"           ~error:","counters":[]},{"line":"             ( Error.of_string","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"             @@ sprintf","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                  !\"Peer should have given a proof of length %d but got %d\"","counters":[]},{"line":"                  max_length merkle_list_length )","counters":[]},{"line":"           (Int.equal max_length merkle_list_length || root_is_genesis) )","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":50,"col_end":50,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"    in","counters":[]},{"line":"    let best_tip_with_hash =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      With_hash.of_data best_tip ~hash_data:state_hashes","counters":[]},{"line":"    in","counters":[]},{"line":"    let root_transition_with_hash =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      With_hash.of_data root ~hash_data:state_hashes","counters":[]},{"line":"    in","counters":[]},{"line":"    let%bind (_ : State_hash.t Non_empty_list.t) =","counters":[]},{"line":"      Deferred.return","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"        (Result.of_option","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"           (Merkle_list_verifier.verify","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"              ~init:","counters":[]},{"line":"                (State_hash.With_state_hashes.state_hash","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"                   root_transition_with_hash )","counters":[]},{"line":"              merkle_list","counters":[]},{"line":"              (State_hash.With_state_hashes.state_hash best_tip_with_hash) )","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"           ~error:","counters":[]},{"line":"             (Error.of_string","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                \"Peer should have given a valid merkle list proof for their \\","counters":[]},{"line":"                 best tip\" ) )","counters":[]},{"line":"    in","counters":[]},{"line":"    let%map root, best_tip =","counters":[]},{"line":"      Deferred.Or_error.both","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"        (validate_proof ~genesis_state_hash ~verifier root_transition_with_hash)","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"        (validate_proof ~genesis_state_hash ~verifier best_tip_with_hash)","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"    in","counters":[]},{"line":"    (`Root root, `Best_tip best_tip)","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"include Make (struct","counters":[]},{"line":"  module Transition_frontier = Transition_frontier","counters":[]},{"line":"end)","counters":[{"col_start":3,"col_end":3,"count":2}]}]}