{"filename":"src/lib/pickles/scalar_challenge.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Import","counters":[]},{"line":"module SC = Scalar_challenge","counters":[]},{"line":"","counters":[]},{"line":"(* Implementation of the algorithm described on page 29 of the Halo paper","counters":[]},{"line":"   https://eprint.iacr.org/2019/1021.pdf","counters":[]},{"line":"*)","counters":[]},{"line":"","counters":[]},{"line":"let num_bits = 128","counters":[]},{"line":"","counters":[]},{"line":"(* Has the side effect of checking that [scalar] fits in 128 bits. *)","counters":[]},{"line":"let to_field_checked' (type f) ?(num_bits = num_bits)","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"    (module Impl : Snarky_backendless.Snark_intf.Run with type field = f)","counters":[]},{"line":"    { SC.inner = (scalar : Impl.Field.t) } =","counters":[]},{"line":"  let open Impl in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let neg_one = Field.Constant.(negate one) in","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"  let a_func = function","counters":[]},{"line":"    | 0 ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Field.Constant.zero","counters":[]},{"line":"    | 1 ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Field.Constant.zero","counters":[]},{"line":"    | 2 ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        neg_one","counters":[]},{"line":"    | 3 ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Field.Constant.one","counters":[]},{"line":"    | _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        raise (Invalid_argument \"a_func\")","counters":[]},{"line":"  in","counters":[]},{"line":"  let b_func = function","counters":[]},{"line":"    | 0 ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        neg_one","counters":[]},{"line":"    | 1 ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Field.Constant.one","counters":[]},{"line":"    | 2 ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Field.Constant.zero","counters":[]},{"line":"    | 3 ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Field.Constant.zero","counters":[]},{"line":"    | _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        raise (Invalid_argument \"a_func\")","counters":[]},{"line":"  in","counters":[]},{"line":"  let ( !! ) = As_prover.read_var in","counters":[]},{"line":"  (* MSB bits *)","counters":[]},{"line":"  let bits_msb =","counters":[]},{"line":"    lazy","counters":[]},{"line":"      (let open Field.Constant in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      unpack !!scalar |> Fn.flip List.take num_bits |> Array.of_list_rev","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":14,"col_end":14,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"      (*","counters":[]},{"line":"    |> Array.of_list_rev_map ~f:(fun b -> if b then one else zero) *))","counters":[]},{"line":"  in","counters":[]},{"line":"  let nybbles_per_row = 8 in","counters":[]},{"line":"  let bits_per_row = 2 * nybbles_per_row in","counters":[]},{"line":"  [%test_eq: int] (num_bits mod bits_per_row) 0 ;","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"  let rows = num_bits / bits_per_row in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let nybbles_by_row =","counters":[]},{"line":"    lazy","counters":[]},{"line":"      (Array.init rows ~f:(fun i ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"           Array.init nybbles_per_row ~f:(fun j ->","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"               let bit = (bits_per_row * i) + (2 * j) in","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"               let b0 = (Lazy.force bits_msb).(bit + 1) in","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"               let b1 = (Lazy.force bits_msb).(bit) in","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"               Bool.to_int b0 + (2 * Bool.to_int b1) ) ) )","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"  in","counters":[]},{"line":"  let two = Field.of_int 2 in","counters":[]},{"line":"  let a = ref two in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let b = ref two in","counters":[]},{"line":"  let n = ref Field.zero in","counters":[]},{"line":"  let mk f = exists Field.typ ~compute:f in","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"  let state = ref [] in","counters":[]},{"line":"  for i = 0 to rows - 1 do","counters":[]},{"line":"    let n0 = !n in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let a0 = !a in","counters":[]},{"line":"    let b0 = !b in","counters":[]},{"line":"    let xs =","counters":[]},{"line":"      Array.init nybbles_per_row ~f:(fun j ->","counters":[]},{"line":"          mk (fun () ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              Field.Constant.of_int (Lazy.force nybbles_by_row).(i).(j) ) )","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"    in","counters":[]},{"line":"    let open Field.Constant in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let double x = x + x in","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"    let n8 =","counters":[]},{"line":"      mk (fun () ->","counters":[]},{"line":"          Array.fold xs ~init:!!n0 ~f:(fun acc x ->","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"              (acc |> double |> double) + !!x ) )","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"    in","counters":[]},{"line":"    let a8 =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      mk (fun () ->","counters":[]},{"line":"          Array.fold","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (Lazy.force nybbles_by_row).(i)","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"            ~init:!!a0","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"            ~f:(fun acc x -> (acc |> double) + a_func x) )","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":42,"col_end":42,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"    in","counters":[]},{"line":"    let b8 =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      mk (fun () ->","counters":[]},{"line":"          Array.fold","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (Lazy.force nybbles_by_row).(i)","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"            ~init:!!b0","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"            ~f:(fun acc x -> (acc |> double) + b_func x) )","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":42,"col_end":42,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"    in","counters":[]},{"line":"    state :=","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      { Kimchi_backend_common.Endoscale_scalar_round.a0","counters":[]},{"line":"      ; a8","counters":[]},{"line":"      ; b0","counters":[]},{"line":"      ; b8","counters":[]},{"line":"      ; n0","counters":[]},{"line":"      ; n8","counters":[]},{"line":"      ; x0 = xs.(0)","counters":[]},{"line":"      ; x1 = xs.(1)","counters":[]},{"line":"      ; x2 = xs.(2)","counters":[]},{"line":"      ; x3 = xs.(3)","counters":[]},{"line":"      ; x4 = xs.(4)","counters":[]},{"line":"      ; x5 = xs.(5)","counters":[]},{"line":"      ; x6 = xs.(6)","counters":[]},{"line":"      ; x7 = xs.(7)","counters":[]},{"line":"      }","counters":[]},{"line":"      :: !state ;","counters":[]},{"line":"    n := n8 ;","counters":[]},{"line":"    a := a8 ;","counters":[]},{"line":"    b := b8 ;","counters":[]},{"line":"    ()","counters":[]},{"line":"  done ;","counters":[]},{"line":"  with_label __LOC__ (fun () ->","counters":[]},{"line":"      assert_","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { annotation = Some __LOC__","counters":[]},{"line":"        ; basic =","counters":[]},{"line":"            Kimchi_backend_common.Plonk_constraint_system.Plonk_constraint.(","counters":[]},{"line":"              T (EC_endoscalar { state = Array.of_list_rev !state }))","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"        } ) ;","counters":[]},{"line":"  (!a, !b, !n)","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let to_field_checked (type f) ?num_bits","counters":[]},{"line":"    (module Impl : Snarky_backendless.Snark_intf.Run with type field = f) ~endo","counters":[]},{"line":"    ({ SC.inner = (scalar : Impl.Field.t) } as s) =","counters":[]},{"line":"  let open Impl in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let a, b, n = to_field_checked' ?num_bits (module Impl) s in","counters":[]},{"line":"  Field.Assert.equal n scalar ;","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  Field.(scale a endo + b)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":13,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"let to_field_constant (type f) ~endo","counters":[]},{"line":"    (module F : Plonk_checks.Field_intf with type t = f) { SC.inner = c } =","counters":[]},{"line":"  let bits = Array.of_list (Challenge.Constant.to_bits c) in","counters":[{"col_start":2,"col_end":2,"count":31},{"col_start":53,"col_end":53,"count":31}]},{"line":"  let a = ref (F.of_int 2) in","counters":[{"col_start":2,"col_end":2,"count":31},{"col_start":22,"col_end":22,"count":31}]},{"line":"  let b = ref (F.of_int 2) in","counters":[{"col_start":22,"col_end":22,"count":31}]},{"line":"  let one = F.of_int 1 in","counters":[]},{"line":"  let neg_one = F.(of_int 0 - one) in","counters":[{"col_start":2,"col_end":2,"count":31},{"col_start":24,"col_end":24,"count":31}]},{"line":"  for i = (128 / 2) - 1 downto 0 do","counters":[]},{"line":"    let s = if bits.(2 * i) then one else neg_one in","counters":[{"col_start":4,"col_end":4,"count":1984},{"col_start":33,"col_end":33,"count":1005},{"col_start":42,"col_end":42,"count":979}]},{"line":"    (a := F.(!a + !a)) ;","counters":[]},{"line":"    (b := F.(!b + !b)) ;","counters":[]},{"line":"    let r_2i1 = bits.((2 * i) + 1) in","counters":[]},{"line":"    if r_2i1 then a := F.(!a + s) else b := F.(!b + s)","counters":[{"col_start":4,"col_end":4,"count":1984},{"col_start":18,"col_end":18,"count":1018},{"col_start":39,"col_end":39,"count":966}]},{"line":"  done ;","counters":[]},{"line":"  F.((!a * endo) + !b)","counters":[]},{"line":"","counters":[]},{"line":"let test (type f)","counters":[]},{"line":"    (module Impl : Snarky_backendless.Snark_intf.Run with type field = f)","counters":[]},{"line":"    ~(endo : f) =","counters":[]},{"line":"  let open Impl in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let module T = Internal_Basic in","counters":[]},{"line":"  let n = 128 in","counters":[]},{"line":"  Quickcheck.test ~trials:10","counters":[]},{"line":"    (Quickcheck.Generator.list_with_length n Bool.quickcheck_generator)","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"    ~f:(fun xs ->","counters":[]},{"line":"      try","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        T.Test.test_equal ~equal:Field.Constant.equal","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"          ~sexp_of_t:Field.Constant.sexp_of_t","counters":[]},{"line":"          (Typ.list ~length:n Boolean.typ)","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"          Field.typ","counters":[]},{"line":"          (fun s ->","counters":[]},{"line":"            make_checked (fun () ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"                to_field_checked","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  (module Impl)","counters":[]},{"line":"                  ~endo","counters":[]},{"line":"                  (SC.create (Impl.Field.pack s)) ) )","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"          (fun s ->","counters":[]},{"line":"            to_field_constant","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (module Field.Constant)","counters":[]},{"line":"              ~endo","counters":[]},{"line":"              (SC.create (Challenge.Constant.of_bits s)) )","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"          xs","counters":[]},{"line":"      with e ->","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"        eprintf !\"Input %{sexp: bool list}\\n%!\" xs ;","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"        raise e )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"module Make","counters":[]},{"line":"    (Impl : Snarky_backendless.Snark_intf.Run)","counters":[]},{"line":"    (G : Intf.Group(Impl).S with type t = Impl.Field.t * Impl.Field.t)","counters":[]},{"line":"    (Challenge : Challenge.S with module Impl := Impl) (Endo : sig","counters":[]},{"line":"      val base : Impl.Field.Constant.t","counters":[]},{"line":"","counters":[]},{"line":"      val scalar : G.Constant.Scalar.t","counters":[]},{"line":"    end) =","counters":[]},{"line":"struct","counters":[]},{"line":"  open Impl","counters":[]},{"line":"  module Scalar = G.Constant.Scalar","counters":[]},{"line":"","counters":[]},{"line":"  type t = Challenge.t SC.t","counters":[]},{"line":"","counters":[]},{"line":"  module Constant = struct","counters":[]},{"line":"    type t = Challenge.Constant.t SC.t","counters":[]},{"line":"","counters":[]},{"line":"    let to_field = to_field_constant ~endo:Endo.scalar (module Scalar)","counters":[{"col_start":35,"col_end":35,"count":2}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let typ : (t, Constant.t) Typ.t = SC.typ Challenge.typ","counters":[{"col_start":41,"col_end":41,"count":2}]},{"line":"","counters":[]},{"line":"  let num_bits = 128","counters":[]},{"line":"","counters":[]},{"line":"  let seal = Util.seal (module Impl)","counters":[{"col_start":21,"col_end":21,"count":2}]},{"line":"","counters":[]},{"line":"  let endo ?(num_bits = num_bits) t { SC.inner = (scalar : Field.t) } =","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"    let ( !! ) = As_prover.read_var in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    (* MSB bits *)","counters":[]},{"line":"    let bits =","counters":[]},{"line":"      lazy","counters":[]},{"line":"        (let open Field.Constant in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        unpack !!scalar |> Fn.flip List.take num_bits","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"        |> Array.of_list_rev_map ~f:(fun b -> if b then one else zero))","counters":[{"col_start":46,"col_end":46,"count":0},{"col_start":56,"col_end":56,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"    in","counters":[]},{"line":"    let bits () = Lazy.force bits in","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"    let xt, yt = Tuple_lib.Double.map t ~f:seal in","counters":[]},{"line":"    let bits_per_row = 4 in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let rows = num_bits / bits_per_row in","counters":[]},{"line":"    let acc =","counters":[]},{"line":"      with_label __LOC__ (fun () ->","counters":[]},{"line":"          let p = G.( + ) t (seal (Field.scale xt Endo.base), yt) in","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"          ref G.(p + p) )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    in","counters":[]},{"line":"    let n_acc = ref Field.zero in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let mk f = exists Field.typ ~compute:f in","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"    let rounds_rev = ref [] in","counters":[]},{"line":"    for i = 0 to rows - 1 do","counters":[]},{"line":"      let n_acc_prev = !n_acc in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let b1 = mk (fun () -> (bits ()).(i * bits_per_row)) in","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"      let b2 = mk (fun () -> (bits ()).((i * bits_per_row) + 1)) in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"      let b3 = mk (fun () -> (bits ()).((i * bits_per_row) + 2)) in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"      let b4 = mk (fun () -> (bits ()).((i * bits_per_row) + 3)) in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"      let open Field.Constant in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let double x = x + x in","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"      let xp, yp = !acc in","counters":[]},{"line":"      let xq1 = mk (fun () -> (one + ((Endo.base - one) * !!b1)) * !!xt) in","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":59,"col_end":59,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"      let yq1 = mk (fun () -> (double !!b2 - one) * !!yt) in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"","counters":[]},{"line":"      let s1 = mk (fun () -> (!!yq1 - !!yp) / (!!xq1 - !!xp)) in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":48,"col_end":48,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"      let s1_squared = mk (fun () -> square !!s1) in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"      let s2 =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        mk (fun () ->","counters":[]},{"line":"            (double !!yp / (double !!xp + !!xq1 - !!s1_squared)) - !!s1 )","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":43,"col_end":43,"count":0},{"col_start":51,"col_end":51,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"      in","counters":[]},{"line":"","counters":[]},{"line":"      let xr = mk (fun () -> !!xq1 + square !!s2 - !!s1_squared) in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":42,"col_end":42,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"      let yr = mk (fun () -> ((!!xp - !!xr) * !!s2) - !!yp) in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":47,"col_end":47,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"","counters":[]},{"line":"      let xq2 = mk (fun () -> (one + ((Endo.base - one) * !!b3)) * !!xt) in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":59,"col_end":59,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"      let yq2 = mk (fun () -> (double !!b4 - one) * !!yt) in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"      let s3 = mk (fun () -> (!!yq2 - !!yr) / (!!xq2 - !!xr)) in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":48,"col_end":48,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"      let s3_squared = mk (fun () -> square !!s3) in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"      let s4 =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        mk (fun () ->","counters":[]},{"line":"            (double !!yr / (double !!xr + !!xq2 - !!s3_squared)) - !!s3 )","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":43,"col_end":43,"count":0},{"col_start":51,"col_end":51,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"      in","counters":[]},{"line":"","counters":[]},{"line":"      let xs = mk (fun () -> !!xq2 + square !!s4 - !!s3_squared) in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":42,"col_end":42,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"      let ys = mk (fun () -> ((!!xr - !!xs) * !!s4) - !!yr) in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":47,"col_end":47,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"      acc := (xs, ys) ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      n_acc :=","counters":[]},{"line":"        mk (fun () ->","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"            !!n_acc_prev |> double |> ( + ) !!b1 |> double |> ( + ) !!b2","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":57,"col_end":57,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"            |> double |> ( + ) !!b3 |> double |> ( + ) !!b4 ) ;","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"      rounds_rev :=","counters":[]},{"line":"        { Kimchi_backend_common.Endoscale_round.xt","counters":[]},{"line":"        ; yt","counters":[]},{"line":"        ; xp","counters":[]},{"line":"        ; yp","counters":[]},{"line":"        ; n_acc = n_acc_prev","counters":[]},{"line":"        ; xr","counters":[]},{"line":"        ; yr","counters":[]},{"line":"        ; s1","counters":[]},{"line":"        ; s3","counters":[]},{"line":"        ; b1","counters":[]},{"line":"        ; b2","counters":[]},{"line":"        ; b3","counters":[]},{"line":"        ; b4","counters":[]},{"line":"        }","counters":[]},{"line":"        :: !rounds_rev","counters":[]},{"line":"    done ;","counters":[]},{"line":"    let xs, ys = !acc in","counters":[]},{"line":"    with_label __LOC__ (fun () ->","counters":[]},{"line":"        assert_","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          { annotation = Some __LOC__","counters":[]},{"line":"          ; basic =","counters":[]},{"line":"              Kimchi_backend_common.Plonk_constraint_system.Plonk_constraint.(","counters":[]},{"line":"                T","counters":[]},{"line":"                  (EC_endoscale","counters":[]},{"line":"                     { xs","counters":[]},{"line":"                     ; ys","counters":[]},{"line":"                     ; n_acc = !n_acc","counters":[]},{"line":"                     ; state = Array.of_list_rev !rounds_rev","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"                     } ))","counters":[]},{"line":"          } ) ;","counters":[]},{"line":"    with_label __LOC__ (fun () -> Field.Assert.equal !n_acc scalar) ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"    !acc","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let endo ?num_bits t s = with_label \"endo\" (fun () -> endo ?num_bits t s)","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"","counters":[]},{"line":"  let%test_unit \"endo\" =","counters":[]},{"line":"    let module T = Internal_Basic in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let random_point =","counters":[]},{"line":"      let rec pt x =","counters":[]},{"line":"        let y2 = G.Params.(T.Field.(b + (x * (a + (x * x))))) in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        if T.Field.is_square y2 then (x, T.Field.sqrt y2)","counters":[{"col_start":37,"col_end":37,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"        else pt T.Field.(x + one)","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"      in","counters":[]},{"line":"      G.Constant.of_affine (pt (T.Field.random ()))","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"    in","counters":[]},{"line":"    let n = 128 in","counters":[]},{"line":"    Quickcheck.test ~trials:10","counters":[]},{"line":"      (Quickcheck.Generator.list_with_length n Bool.quickcheck_generator)","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"      ~f:(fun xs ->","counters":[]},{"line":"        try","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          T.Test.test_equal ~equal:G.Constant.equal","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"            ~sexp_of_t:G.Constant.sexp_of_t","counters":[]},{"line":"            (Typ.tuple2 G.typ (Typ.list ~length:n Boolean.typ))","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"            G.typ","counters":[]},{"line":"            (fun (g, s) ->","counters":[]},{"line":"              make_checked (fun () -> endo g (SC.create (Field.pack s))) )","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":54,"col_end":54,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"            (fun (g, s) ->","counters":[]},{"line":"              let x =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Constant.to_field (SC.create (Challenge.Constant.of_bits s))","counters":[{"col_start":43,"col_end":43,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"              in","counters":[]},{"line":"              G.Constant.scale g x )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"            (random_point, xs)","counters":[]},{"line":"        with e ->","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"          eprintf !\"Input %{sexp: bool list}\\n%!\" xs ;","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"          raise e )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"  let endo_inv ((gx, gy) as g) chal =","counters":[]},{"line":"    let res =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      exists G.typ","counters":[]},{"line":"        ~compute:","counters":[]},{"line":"          As_prover.(","counters":[]},{"line":"            fun () ->","counters":[]},{"line":"              let x = Constant.to_field (read typ chal) in","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"              G.Constant.scale (read G.typ g) Scalar.(one / x))","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"    in","counters":[]},{"line":"    let x, y = endo res chal in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Field.Assert.(equal gx x ; equal gy y) ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"    res","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}