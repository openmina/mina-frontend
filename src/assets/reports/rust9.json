{"filename":"src/ffi/database.rs","lines":[{"line":"use std::{","counters":[]},{"line":"    borrow::Borrow,","counters":[]},{"line":"    cell::{Ref, RefCell},","counters":[]},{"line":"    collections::HashMap,","counters":[]},{"line":"    path::PathBuf,","counters":[]},{"line":"    rc::Rc,","counters":[]},{"line":"    str::FromStr,","counters":[]},{"line":"    sync::Mutex,","counters":[]},{"line":"};","counters":[]},{"line":"","counters":[]},{"line":"use mina_hasher::Fp;","counters":[]},{"line":"use mina_p2p_messages::{bigint::BigInt, v2::NonZeroCurvePointUncompressedStableV1};","counters":[]},{"line":"use ocaml_interop::{","counters":[]},{"line":"    impl_to_ocaml_polymorphic_variant, impl_to_ocaml_variant, ocaml_export, DynBox, OCaml,","counters":[]},{"line":"    OCamlBytes, OCamlInt, OCamlList, OCamlRef, OCamlRuntime, RawOCaml, ToOCaml,","counters":[]},{"line":"};","counters":[]},{"line":"use once_cell::sync::Lazy;","counters":[]},{"line":"","counters":[]},{"line":"use crate::{","counters":[]},{"line":"    account::{Account, AccountId},","counters":[]},{"line":"    address::Address,","counters":[]},{"line":"    base::{AccountIndex, BaseLedger, MerklePath},","counters":[]},{"line":"    database::Database,","counters":[]},{"line":"    ffi::util::*,","counters":[]},{"line":"    short_backtrace,","counters":[]},{"line":"    tree_version::V2,","counters":[]},{"line":"};","counters":[]},{"line":"","counters":[]},{"line":"static DATABASE: Lazy<Mutex<Database<V2>>> = Lazy::new(|| Mutex::new(Database::create(30)));","counters":[{"col_start":58,"col_end":90,"count":0}]},{"line":"","counters":[]},{"line":"// #[derive(Clone)]","counters":[]},{"line":"pub struct DatabaseFFI(pub Rc<RefCell<Option<Database<V2>>>>);","counters":[]},{"line":"","counters":[]},{"line":"impl Drop for DatabaseFFI {","counters":[]},{"line":"    fn drop(&mut self) {","counters":[{"col_start":4,"col_end":24,"count":0}]},{"line":"        let mask_id = RefCell::borrow(&self.0)","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"            .as_ref()","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"            .map(|mask| mask.get_uuid());","counters":[{"col_start":0,"col_end":17,"count":0},{"col_start":24,"col_end":39,"count":0},{"col_start":39,"col_end":41,"count":0}]},{"line":"        elog!(\"rust_database_drop {:?}\", mask_id);","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"fn with_db<F, R>(rt: &mut &mut OCamlRuntime, db: OCamlRef<DynBox<DatabaseFFI>>, fun: F) -> R","counters":[{"col_start":0,"col_end":92,"count":236}]},{"line":"where","counters":[{"col_start":0,"col_end":5,"count":236}]},{"line":"    F: FnOnce(&mut Database<V2>) -> R,","counters":[{"col_start":0,"col_end":38,"count":236}]},{"line":"{","counters":[{"col_start":0,"col_end":1,"count":236}]},{"line":"    let db = rt.get(db);","counters":[{"col_start":0,"col_end":24,"count":236}]},{"line":"    let db: &DatabaseFFI = db.borrow();","counters":[{"col_start":0,"col_end":39,"count":236}]},{"line":"    let mut db = db.0.borrow_mut();","counters":[{"col_start":0,"col_end":35,"count":236}]},{"line":"","counters":[]},{"line":"    fun(db.as_mut().unwrap())","counters":[{"col_start":0,"col_end":29,"count":236}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":236}]},{"line":"","counters":[]},{"line":"struct MyOCamlClosure(*const RawOCaml);","counters":[]},{"line":"","counters":[]},{"line":"// external database_get_or_create_account : database -> account_id -> account -> (([ `Added | `Existed ] * addr), rust_dberror) result = \"rust_database_get_or_create_account\"","counters":[]},{"line":"","counters":[]},{"line":"pub enum PolymorphicGetOrAdded {","counters":[]},{"line":"    Added,","counters":[]},{"line":"    Existed,","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl_to_ocaml_polymorphic_variant! {","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"    PolymorphicGetOrAdded {","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"        PolymorphicGetOrAdded::Added,","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"        PolymorphicGetOrAdded::Existed,","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"pub enum PolymorphicPath {","counters":[]},{"line":"    Left(Vec<u8>),","counters":[]},{"line":"    Right(Vec<u8>),","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl_to_ocaml_polymorphic_variant! {","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"    PolymorphicPath {","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"        PolymorphicPath::Left(hash: OCamlBytes),","counters":[{"col_start":0,"col_end":48,"count":0}]},{"line":"        PolymorphicPath::Right(hash: OCamlBytes),","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"#[derive(Debug, PartialEq, Eq)]","counters":[{"col_start":9,"col_end":14,"count":0}]},{"line":"pub enum DatabaseErrorFFI {","counters":[]},{"line":"    OutOfLeaves,","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl_to_ocaml_variant! {","counters":[]},{"line":"    DatabaseErrorFFI {","counters":[]},{"line":"        DatabaseErrorFFI::OutOfLeaves,","counters":[]},{"line":"    }","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"static DB_CLOSED: Lazy<Mutex<HashMap<PathBuf, Database<V2>>>> =","counters":[]},{"line":"    Lazy::new(|| Mutex::new(HashMap::with_capacity(16)));","counters":[{"col_start":17,"col_end":55,"count":0}]},{"line":"","counters":[]},{"line":"// static DB_CLOSED: Arc<Mutex<Option<HashMap<PathBuf, Database<V2>>>>> = Arc::new(Mutex::new(None));","counters":[]},{"line":"","counters":[]},{"line":"fn get_cloned_db(","counters":[]},{"line":"    rt: &mut &mut OCamlRuntime,","counters":[]},{"line":"    db: OCamlRef<DynBox<DatabaseFFI>>,","counters":[]},{"line":") -> Rc<RefCell<Option<Database<V2>>>> {","counters":[]},{"line":"    let db = rt.get(db);","counters":[]},{"line":"    let db: &DatabaseFFI = db.borrow();","counters":[]},{"line":"    // let mut db = db.0.borrow_mut();","counters":[]},{"line":"    Rc::clone(&db.0)","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"ocaml_export! {","counters":[]},{"line":"    fn rust_database_create(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        depth: OCamlRef<OCamlInt>,","counters":[]},{"line":"        dir_name: OCamlRef<Option<String>>","counters":[]},{"line":"    ) -> OCaml<DynBox<DatabaseFFI>> {","counters":[]},{"line":"        elog!(\"backtrace=\\n{}\", short_backtrace());","counters":[]},{"line":"","counters":[]},{"line":"        let depth: i64 = depth.to_rust(rt);","counters":[]},{"line":"        let depth: u8 = depth.try_into().unwrap();","counters":[]},{"line":"","counters":[]},{"line":"        let dir_name = rt.get(dir_name);","counters":[]},{"line":"        let dir_name = dir_name.to_rust::<Option<String>>().map(PathBuf::from);","counters":[]},{"line":"","counters":[]},{"line":"        let mut closed = DB_CLOSED.try_lock().unwrap();","counters":[]},{"line":"","counters":[]},{"line":"        let db = dir_name.as_ref().and_then(|dir_name| closed.remove(dir_name));","counters":[{"col_start":55,"col_end":78,"count":0}]},{"line":"","counters":[]},{"line":"        elog!(\"rust_database_create={:?} reuse={:?}\", dir_name, db.is_some());","counters":[]},{"line":"","counters":[]},{"line":"        let db = match db {","counters":[]},{"line":"            Some(db) => {","counters":[]},{"line":"                assert_eq!(db.depth(), depth);","counters":[]},{"line":"                db","counters":[]},{"line":"            },","counters":[]},{"line":"            None => {","counters":[]},{"line":"                Database::<V2>::create_with_dir(depth, dir_name)","counters":[]},{"line":"            }","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        let db = DatabaseFFI(Rc::new(RefCell::new(Some(db))));","counters":[]},{"line":"","counters":[]},{"line":"        OCaml::box_value(rt, db)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_database_get_uuid(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        db: OCamlRef<DynBox<DatabaseFFI>>","counters":[]},{"line":"    ) -> OCaml<String> {","counters":[]},{"line":"        let uuid = with_db(rt, db, |db| {","counters":[{"col_start":40,"col_end":41,"count":0}]},{"line":"            db.get_uuid()","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"        });","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        uuid.to_ocaml(rt)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_database_get_directory(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        db: OCamlRef<DynBox<DatabaseFFI>>","counters":[]},{"line":"    ) -> OCaml<Option<String>> {","counters":[]},{"line":"        let dir = with_db(rt, db, |db| {","counters":[{"col_start":39,"col_end":40,"count":0}]},{"line":"            db.get_directory().map(|d| d.into_os_string().into_string().unwrap())","counters":[{"col_start":0,"col_end":35,"count":0},{"col_start":39,"col_end":80,"count":0},{"col_start":80,"col_end":81,"count":0}]},{"line":"        });","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        dir.to_ocaml(rt)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_database_depth(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        db: OCamlRef<DynBox<DatabaseFFI>>","counters":[]},{"line":"    ) -> OCaml<OCamlInt> {","counters":[]},{"line":"        let depth = with_db(rt, db, |db| {","counters":[{"col_start":41,"col_end":42,"count":0}]},{"line":"            db.depth() as i64","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"        });","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        depth.to_ocaml(rt)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_database_create_checkpoint(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        db: OCamlRef<DynBox<DatabaseFFI>>,","counters":[]},{"line":"        directory_name: OCamlRef<String>,","counters":[]},{"line":"    ) -> OCaml<DynBox<DatabaseFFI>> {","counters":[]},{"line":"        let db = {","counters":[]},{"line":"            let db = rt.get(db);","counters":[]},{"line":"            let db: &DatabaseFFI = db.borrow();","counters":[]},{"line":"","counters":[]},{"line":"            let directory_name: String = directory_name.to_rust(rt);","counters":[]},{"line":"","counters":[]},{"line":"            {","counters":[]},{"line":"                let mut db = db.0.borrow_mut();","counters":[]},{"line":"                let db = db.as_mut().unwrap();","counters":[]},{"line":"                db.create_checkpoint(directory_name.clone());","counters":[]},{"line":"            }","counters":[]},{"line":"","counters":[]},{"line":"            let directory_name = PathBuf::from(directory_name);","counters":[]},{"line":"","counters":[]},{"line":"            let db: Ref<Option<Database<V2>>> = (*db.0).borrow();","counters":[]},{"line":"            let db_clone = db.as_ref().unwrap().clone_db(directory_name);","counters":[]},{"line":"","counters":[]},{"line":"            DatabaseFFI(Rc::new(RefCell::new(Some(db_clone))))","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        OCaml::box_value(rt, db)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_database_make_checkpoint(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        db: OCamlRef<DynBox<DatabaseFFI>>,","counters":[]},{"line":"        directory_name: OCamlRef<String>,","counters":[]},{"line":"    ) {","counters":[]},{"line":"        let db = rt.get(db);","counters":[]},{"line":"        let db: &DatabaseFFI = db.borrow();","counters":[]},{"line":"","counters":[]},{"line":"        let directory_name: String = directory_name.to_rust(rt);","counters":[]},{"line":"","counters":[]},{"line":"        {","counters":[]},{"line":"            let mut db = db.0.borrow_mut();","counters":[]},{"line":"            let db = db.as_mut().unwrap();","counters":[]},{"line":"            db.make_checkpoint(directory_name.clone());","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        let directory_name = PathBuf::from(directory_name);","counters":[]},{"line":"","counters":[]},{"line":"        let db: Ref<Option<Database<V2>>> = (*db.0).borrow();","counters":[]},{"line":"        let db_clone = db.as_ref().unwrap().clone_db(directory_name.clone());","counters":[]},{"line":"","counters":[]},{"line":"        let mut closed_dbs = DB_CLOSED.try_lock().unwrap();","counters":[]},{"line":"        closed_dbs.insert(directory_name, db_clone);","counters":[]},{"line":"","counters":[]},{"line":"        OCaml::unit()","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_database_close(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        db: OCamlRef<DynBox<DatabaseFFI>>","counters":[]},{"line":"    ) {","counters":[]},{"line":"        let db = rt.get(db);","counters":[]},{"line":"        let db: &DatabaseFFI = db.borrow();","counters":[]},{"line":"","counters":[]},{"line":"        let path = {","counters":[]},{"line":"            let mut db_ref = db.0.borrow_mut();","counters":[]},{"line":"            let db_ref = db_ref.as_mut().unwrap();","counters":[]},{"line":"            db_ref.close();","counters":[]},{"line":"            db_ref.get_directory().unwrap()","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        elog!(\"rust_database_close={:?}\", path);","counters":[]},{"line":"","counters":[]},{"line":"        let db = db.0.take().unwrap();","counters":[]},{"line":"        // let db: RefCell<Database<V2>> = Rc::try_unwrap(db).ok().unwrap();","counters":[]},{"line":"        // let db = db.into_inner();","counters":[]},{"line":"","counters":[]},{"line":"        let mut closed_dbs = DB_CLOSED.try_lock().unwrap();","counters":[]},{"line":"        closed_dbs.insert(path, db);","counters":[]},{"line":"","counters":[]},{"line":"        // with_db(rt, db, |db| {","counters":[]},{"line":"        // });","counters":[]},{"line":"","counters":[]},{"line":"        OCaml::unit()","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_add_account(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        account: OCamlRef<OCamlBytes>,","counters":[]},{"line":"    ) {","counters":[]},{"line":"        elog!(\"RUST BEGIN\");","counters":[]},{"line":"        let account_ref = rt.get(account);","counters":[]},{"line":"        let account = account_ref.as_bytes();","counters":[]},{"line":"","counters":[]},{"line":"        let account: Account = Account::deserialize(account);","counters":[]},{"line":"","counters":[]},{"line":"        elog!(\"account={:?}\", account);","counters":[]},{"line":"        elog!(\"account_hash={:?}\", account.hash().to_string());","counters":[]},{"line":"","counters":[]},{"line":"        elog!(\"RUST END 1\");","counters":[]},{"line":"        OCaml::unit()","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_get_random_account(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        validate_account: OCamlRef<fn (OCamlBytes) -> ()>,","counters":[]},{"line":"    ) -> OCaml<OCamlBytes> {","counters":[]},{"line":"        let mut account;","counters":[]},{"line":"        let mut bytes;","counters":[]},{"line":"        let validate_account = validate_account.to_boxroot(rt);","counters":[]},{"line":"","counters":[]},{"line":"        loop {","counters":[]},{"line":"            account = Account::rand();","counters":[]},{"line":"            bytes = account.serialize();","counters":[]},{"line":"","counters":[]},{"line":"            if validate_account.try_call(rt, &bytes).is_ok() {","counters":[]},{"line":"                break;","counters":[]},{"line":"            }","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        elog!(\"account={:?}\", account.id());","counters":[]},{"line":"        // std::thread::sleep_ms(2000);","counters":[]},{"line":"","counters":[]},{"line":"        bytes.to_ocaml(rt)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_test_random_accounts(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        get_hash_fun: OCamlRef<fn (OCamlBytes) -> OCamlBytes>,","counters":[]},{"line":"    ) {","counters":[]},{"line":"        let get_hash_fun = get_hash_fun.to_boxroot(rt);","counters":[]},{"line":"        let mut nchecked = 0;","counters":[]},{"line":"","counters":[]},{"line":"        for _ in 0..10_000 {","counters":[]},{"line":"            let account = Account::rand();","counters":[]},{"line":"            let rust_hash = account.hash();","counters":[]},{"line":"","counters":[]},{"line":"            let bytes = account.serialize();","counters":[]},{"line":"            let ocaml_hash: OCaml<OCamlBytes> = match get_hash_fun.try_call(rt, &bytes) {","counters":[]},{"line":"                Ok(hash) => hash,","counters":[]},{"line":"                Err(_) => continue, // random account is invalid","counters":[]},{"line":"            };","counters":[]},{"line":"","counters":[]},{"line":"            let ocaml_hash: Vec<u8> = ocaml_hash.to_rust();","counters":[]},{"line":"            let ocaml_hash: BigInt = deserialize(&ocaml_hash);","counters":[]},{"line":"            let ocaml_hash: Fp = ocaml_hash.into();","counters":[]},{"line":"","counters":[]},{"line":"            if ocaml_hash != rust_hash {","counters":[]},{"line":"                elog!(\"different hash ! bytes={:?}\", account);","counters":[]},{"line":"                elog!(\"ocaml_hash={}\", ocaml_hash);","counters":[]},{"line":"                elog!(\"rust_hash ={}\", rust_hash);","counters":[]},{"line":"                panic!(\"account={:#?}\", account);","counters":[]},{"line":"            }","counters":[]},{"line":"","counters":[]},{"line":"            nchecked += 1;","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        elog!(\"nchecked={:?}\", nchecked);","counters":[]},{"line":"","counters":[]},{"line":"        OCaml::unit()","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_add_account_with_hash(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        account: OCamlRef<OCamlBytes>,","counters":[]},{"line":"        hash: OCamlRef<String>,","counters":[]},{"line":"    ) {","counters":[]},{"line":"        // elog!(\"RUST BEGIN\");","counters":[]},{"line":"        let account_ref = rt.get(account);","counters":[]},{"line":"        let account = account_ref.as_bytes();","counters":[]},{"line":"        let account_bytes = account;","counters":[]},{"line":"        let _account_len = account.len();","counters":[]},{"line":"        let hash: String = hash.to_rust(rt);","counters":[]},{"line":"        let hash = Fp::from_str(&hash).unwrap();","counters":[]},{"line":"","counters":[]},{"line":"        let account: Account = Account::deserialize(account);","counters":[]},{"line":"        let account_hash = account.hash();","counters":[]},{"line":"","counters":[]},{"line":"        if hash != account_hash {","counters":[]},{"line":"            elog!(\"different hash ! bytes={:?}\", account_bytes);","counters":[]},{"line":"            elog!(\"ocaml_hash={:?}\", hash.to_string());","counters":[]},{"line":"            elog!(\"rust_hash ={:?}\", account_hash.to_string());","counters":[]},{"line":"            assert_eq!(hash, account_hash);","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        // elog!(\"hash={:?}\", hash.to_string());","counters":[]},{"line":"        // elog!(\"provided={:?}\", hash.to_string());","counters":[]},{"line":"        // elog!(\"computed={:?}\", account_hash.to_string());","counters":[]},{"line":"","counters":[]},{"line":"        let ser = account.serialize();","counters":[]},{"line":"","counters":[]},{"line":"        // elog!(\"from_ocaml={:?}\", account_bytes);","counters":[]},{"line":"        // elog!(\"rust_ocaml={:?}\", ser);","counters":[]},{"line":"","counters":[]},{"line":"        // assert_eq!(account_len, ser.len());","counters":[]},{"line":"","counters":[]},{"line":"        let account2: Account = Account::deserialize(&ser);","counters":[]},{"line":"        let account_hash2 = account2.hash();","counters":[]},{"line":"        assert_eq!(account_hash, account_hash2);","counters":[]},{"line":"","counters":[]},{"line":"        // elog!(\"account={:?}\", account);","counters":[]},{"line":"        // elog!(\"account_hash={:?}\", account.hash().to_string());","counters":[]},{"line":"","counters":[]},{"line":"        let mut db = DATABASE.try_lock().unwrap();","counters":[]},{"line":"        let id = account.id();","counters":[]},{"line":"        db.get_or_create_account(id, account).unwrap();","counters":[]},{"line":"","counters":[]},{"line":"        // elog!(\"RUST END\");","counters":[]},{"line":"        OCaml::unit()","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_root_hash(rt, ocaml_hash: OCamlRef<String>) {","counters":[]},{"line":"        let mut db = DATABASE.try_lock().unwrap();","counters":[]},{"line":"        let hash = db.root_hash();","counters":[]},{"line":"","counters":[]},{"line":"        let ocaml_hash: String = ocaml_hash.to_rust(rt);","counters":[]},{"line":"        let ocaml_hash = Fp::from_str(&ocaml_hash).unwrap();","counters":[]},{"line":"","counters":[]},{"line":"        elog!(\"naccounts ={:?}\", db.naccounts());","counters":[]},{"line":"        elog!(\"rust_root_hash ={:?}\", hash.to_string());","counters":[]},{"line":"        elog!(\"ocaml_root_hash={:?}\", ocaml_hash.to_string());","counters":[]},{"line":"","counters":[]},{"line":"        assert_eq!(hash, ocaml_hash);","counters":[]},{"line":"","counters":[]},{"line":"        OCaml::unit()","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_random_account(rt, _unused: OCamlRef<String>) -> OCaml<OCamlBytes> {","counters":[]},{"line":"        let res = impl_rust_random_account();","counters":[]},{"line":"        // elog!(\"rust_random_account begin\");","counters":[]},{"line":"","counters":[]},{"line":"        // // let account = Account::rand();","counters":[]},{"line":"        // // let ser = serde_binprot::to_vec(&account).unwrap();","counters":[]},{"line":"","counters":[]},{"line":"        // let ser: Vec<u8> = vec![178, 29, 73, 50, 85, 80, 131, 166, 53, 11, 48, 224, 103, 89, 161, 207, 149, 31, 170, 21, 165, 181, 94, 18, 149, 177, 54, 71, 185, 77, 109, 49, 1, 144, 247, 164, 171, 110, 24, 3, 12, 25, 163, 63, 125, 83, 66, 174, 2, 160, 62, 45, 137, 185, 47, 16, 129, 145, 190, 203, 124, 35, 119, 251, 26, 1, 1, 6, 49, 50, 56, 54, 56, 56, 252, 29, 154, 218, 214, 79, 98, 177, 181, 253, 181, 152, 127, 0, 145, 177, 91, 155, 59, 239, 161, 174, 217, 42, 201, 30, 46, 11, 187, 88, 49, 5, 111, 254, 222, 87, 42, 45, 90, 1, 236, 173, 205, 215, 241, 20, 0, 77, 12, 197, 234, 69, 202, 22, 55, 50, 183, 255, 238, 8, 29, 79, 199, 92, 12, 146, 223, 105, 45, 135, 77, 89, 73, 141, 11, 137, 28, 54, 21, 0, 1, 4, 4, 1, 0, 4, 3, 4, 3, 2, 3, 0, 6, 49, 49, 56, 54, 54, 51];","counters":[]},{"line":"","counters":[]},{"line":"        // let mut account2: Account = serde_binprot::from_slice(&ser).unwrap();","counters":[]},{"line":"","counters":[]},{"line":"        // let account_hash2 = account2.hash();","counters":[]},{"line":"","counters":[]},{"line":"        // elog!(\"HASH2={:?}\", account_hash2.to_string());","counters":[]},{"line":"","counters":[]},{"line":"        // let ser = serde_binprot::to_vec(&account2).unwrap();","counters":[]},{"line":"","counters":[]},{"line":"","counters":[]},{"line":"        // elog!(\"rust_random_account end\");","counters":[]},{"line":"","counters":[]},{"line":"        res.to_ocaml(rt)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_database_get(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        db: OCamlRef<DynBox<DatabaseFFI>>,","counters":[]},{"line":"        addr: OCamlRef<String>,","counters":[]},{"line":"    ) -> OCaml<Option<OCamlBytes>> {","counters":[]},{"line":"        let addr = get_addr(rt, addr);","counters":[]},{"line":"","counters":[]},{"line":"        let account = with_db(rt, db, |db| {","counters":[{"col_start":43,"col_end":44,"count":0}]},{"line":"            db.get(addr)","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"        }).map(|account| {","counters":[{"col_start":0,"col_end":9,"count":0},{"col_start":25,"col_end":26,"count":0}]},{"line":"            account.serialize()","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"        });","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        account.to_ocaml(rt)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_database_get_batch(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        db: OCamlRef<DynBox<DatabaseFFI>>,","counters":[]},{"line":"        addrs: OCamlRef<OCamlList<OCamlBytes>>,","counters":[]},{"line":"    ) -> OCaml<OCamlList<(String, Option<OCamlBytes>)>> {","counters":[]},{"line":"        let mut addrs_ref = rt.get(addrs);","counters":[]},{"line":"","counters":[]},{"line":"        let mut addrs = Vec::with_capacity(2048);","counters":[]},{"line":"        while let Some((head, tail)) = addrs_ref.uncons() {","counters":[]},{"line":"            let addr = Address::try_from(head.as_str()).unwrap();","counters":[]},{"line":"            addrs.push(addr);","counters":[]},{"line":"            addrs_ref = tail;","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        let accounts: Vec<(String, Option<Vec<u8>>)> = with_db(rt, db, |db| {","counters":[{"col_start":76,"col_end":77,"count":0}]},{"line":"            db.get_batch(&addrs)","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"        }).into_iter()","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"          .map(|(addr, opt_account)| {","counters":[{"col_start":37,"col_end":38,"count":0}]},{"line":"              let addr = addr.to_string();","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"              let opt_account = opt_account.map(|acc| acc.serialize());","counters":[{"col_start":0,"col_end":48,"count":0},{"col_start":54,"col_end":69,"count":0},{"col_start":69,"col_end":71,"count":0}]},{"line":"              (addr, opt_account)","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"          })","counters":[{"col_start":0,"col_end":11,"count":0}]},{"line":"          .collect();","counters":[]},{"line":"","counters":[]},{"line":"        accounts.to_ocaml(rt)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_database_get_list(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        db: OCamlRef<DynBox<DatabaseFFI>>,","counters":[]},{"line":"    ) -> OCaml<OCamlList<OCamlBytes>> {","counters":[]},{"line":"","counters":[]},{"line":"        let accounts: Vec<Vec<u8>> = with_db(rt, db, |db| {","counters":[{"col_start":58,"col_end":59,"count":0}]},{"line":"            db.to_list()","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"        }).into_iter()","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"          .map(|account| {","counters":[{"col_start":25,"col_end":26,"count":0}]},{"line":"              account.serialize()","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"          })","counters":[{"col_start":0,"col_end":11,"count":0}]},{"line":"          .collect();","counters":[]},{"line":"","counters":[]},{"line":"        accounts.to_ocaml(rt)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_database_accounts(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        db: OCamlRef<DynBox<DatabaseFFI>>,","counters":[]},{"line":"    ) -> OCaml<OCamlList<OCamlBytes>> {","counters":[]},{"line":"","counters":[]},{"line":"        let accounts: Vec<Vec<u8>> = with_db(rt, db, |db| {","counters":[{"col_start":58,"col_end":59,"count":0}]},{"line":"            db.accounts()","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"        }).into_iter()","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"          .map(|account_id| {","counters":[{"col_start":28,"col_end":29,"count":0}]},{"line":"              serialize(&account_id)","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"          })","counters":[{"col_start":0,"col_end":11,"count":0}]},{"line":"          .collect();","counters":[]},{"line":"","counters":[]},{"line":"        accounts.to_ocaml(rt)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_database_get_inner_hash_at_addr(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        db: OCamlRef<DynBox<DatabaseFFI>>,","counters":[]},{"line":"        addr: OCamlRef<String>,","counters":[]},{"line":"    ) -> OCaml<OCamlBytes> {","counters":[]},{"line":"        let addr = get_addr(rt, addr);","counters":[]},{"line":"","counters":[]},{"line":"        let hash = with_db(rt, db, |db| {","counters":[{"col_start":40,"col_end":41,"count":0}]},{"line":"            db.get_inner_hash_at_addr(addr)","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"        }).map(|hash| {","counters":[{"col_start":0,"col_end":9,"count":0},{"col_start":22,"col_end":23,"count":0}]},{"line":"              hash_to_ocaml(hash)","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"          })","counters":[{"col_start":0,"col_end":11,"count":0}]},{"line":"          .unwrap();","counters":[]},{"line":"","counters":[]},{"line":"        hash.to_ocaml(rt)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_database_set_inner_hash_at_addr(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        db: OCamlRef<DynBox<DatabaseFFI>>,","counters":[]},{"line":"        addr: OCamlRef<String>,","counters":[]},{"line":"        hash: OCamlRef<String>,","counters":[]},{"line":"    ) {","counters":[]},{"line":"        let addr = get_addr(rt, addr);","counters":[]},{"line":"","counters":[]},{"line":"        let hash: String = hash.to_rust(rt);","counters":[]},{"line":"        let hash = Fp::from_str(&hash).unwrap();","counters":[]},{"line":"","counters":[]},{"line":"        with_db(rt, db, |db| {","counters":[{"col_start":29,"col_end":30,"count":0}]},{"line":"            db.set_inner_hash_at_addr(addr, hash).unwrap()","counters":[{"col_start":0,"col_end":58,"count":0}]},{"line":"        });","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        OCaml::unit()","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_database_get_at_index(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        db: OCamlRef<DynBox<DatabaseFFI>>,","counters":[]},{"line":"        index: OCamlRef<OCamlInt>","counters":[]},{"line":"    ) -> OCaml<OCamlBytes> {","counters":[]},{"line":"        let index = get_index(rt, index);","counters":[]},{"line":"","counters":[]},{"line":"        let account = with_db(rt, db, |db| {","counters":[{"col_start":43,"col_end":44,"count":0}]},{"line":"            db.get_at_index(index).unwrap()","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"        });","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"        let account = account.serialize();","counters":[]},{"line":"","counters":[]},{"line":"        account.to_ocaml(rt)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_database_location_of_account(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        db: OCamlRef<DynBox<DatabaseFFI>>,","counters":[]},{"line":"        account_id: OCamlRef<OCamlBytes>","counters":[]},{"line":"    ) -> OCaml<Option<String>> {","counters":[]},{"line":"        let account_id = get(rt, account_id);","counters":[]},{"line":"","counters":[]},{"line":"        // eprintln!(\"database_location_of_account={:?}\", account_id);","counters":[]},{"line":"","counters":[]},{"line":"        let addr = with_db(rt, db, |db| {","counters":[{"col_start":40,"col_end":41,"count":0}]},{"line":"            db.location_of_account(&account_id)","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"        }).map(|addr| {","counters":[{"col_start":0,"col_end":9,"count":0},{"col_start":22,"col_end":23,"count":0}]},{"line":"            addr.to_string()","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"        });","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        addr.to_ocaml(rt)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_database_location_of_account_batch(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        db: OCamlRef<DynBox<DatabaseFFI>>,","counters":[]},{"line":"        account_ids: OCamlRef<OCamlList<OCamlBytes>>","counters":[]},{"line":"    ) -> OCaml<OCamlList<(OCamlBytes, Option<String>)>> {","counters":[]},{"line":"        let account_ids = get_list_of::<AccountId>(rt, account_ids);","counters":[]},{"line":"","counters":[]},{"line":"        // eprintln!(\"database_location_of_account_batch={:?}\", account_ids);","counters":[]},{"line":"","counters":[]},{"line":"        let addrs = with_db(rt, db, |db| {","counters":[{"col_start":41,"col_end":42,"count":0}]},{"line":"            db.location_of_account_batch(&account_ids)","counters":[{"col_start":0,"col_end":54,"count":0}]},{"line":"        }).into_iter()","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"          .map(|(account_id, opt_addr)| {","counters":[{"col_start":40,"col_end":41,"count":0}]},{"line":"              let account_id = serialize(&account_id);","counters":[{"col_start":0,"col_end":54,"count":0}]},{"line":"              let addr = opt_addr.map(|addr| addr.to_string());","counters":[{"col_start":0,"col_end":38,"count":0},{"col_start":45,"col_end":61,"count":0},{"col_start":61,"col_end":63,"count":0}]},{"line":"              (account_id, addr)","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"        })","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"          .collect::<Vec<_>>();","counters":[]},{"line":"","counters":[]},{"line":"        addrs.to_ocaml(rt)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_database_last_filled(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        db: OCamlRef<DynBox<DatabaseFFI>>,","counters":[]},{"line":"    ) -> OCaml<Option<String>> {","counters":[]},{"line":"        let addr = with_db(rt, db, |db| {","counters":[{"col_start":40,"col_end":41,"count":0}]},{"line":"            db.last_filled()","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"        }).map(|addr| {","counters":[{"col_start":0,"col_end":9,"count":0},{"col_start":22,"col_end":23,"count":0}]},{"line":"            addr.to_string()","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"        });","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        addr.to_ocaml(rt)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_database_token_owners(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        db: OCamlRef<DynBox<DatabaseFFI>>,","counters":[]},{"line":"    ) -> OCaml<OCamlList<OCamlBytes>> {","counters":[]},{"line":"        let owners = with_db(rt, db, |db| {","counters":[{"col_start":42,"col_end":43,"count":0}]},{"line":"            db.token_owners()","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"        }).iter()","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"          .map(|account_id| {","counters":[{"col_start":28,"col_end":29,"count":0}]},{"line":"              serialize(account_id)","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"        })","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"          .collect::<Vec<_>>();","counters":[]},{"line":"","counters":[]},{"line":"        owners.to_ocaml(rt)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_database_token_owner(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        db: OCamlRef<DynBox<DatabaseFFI>>,","counters":[]},{"line":"        token_id: OCamlRef<OCamlBytes>,","counters":[]},{"line":"    ) -> OCaml<Option<OCamlBytes>> {","counters":[]},{"line":"        let token_id = get(rt, token_id);","counters":[]},{"line":"","counters":[]},{"line":"        let owner = with_db(rt, db, |db| {","counters":[{"col_start":41,"col_end":42,"count":0}]},{"line":"            db.token_owner(token_id)","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"        }).map(|account_id| {","counters":[{"col_start":0,"col_end":9,"count":0},{"col_start":28,"col_end":29,"count":0}]},{"line":"            serialize(&account_id)","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"        });","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        owner.to_ocaml(rt)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_database_tokens(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        db: OCamlRef<DynBox<DatabaseFFI>>,","counters":[]},{"line":"        pubkey: OCamlRef<OCamlBytes>,","counters":[]},{"line":"    ) -> OCaml<OCamlList<OCamlBytes>> {","counters":[]},{"line":"        let pubkey: NonZeroCurvePointUncompressedStableV1 = get(rt, pubkey);","counters":[]},{"line":"","counters":[]},{"line":"        let tokens = with_db(rt, db, |db| {","counters":[{"col_start":42,"col_end":43,"count":0}]},{"line":"            db.tokens(pubkey.into())","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"        }).iter()","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"          .map(|token_id| {","counters":[{"col_start":26,"col_end":27,"count":0}]},{"line":"            serialize(token_id)","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"        })","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"          .collect::<Vec<_>>();","counters":[]},{"line":"","counters":[]},{"line":"        tokens.to_ocaml(rt)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_database_set(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        db: OCamlRef<DynBox<DatabaseFFI>>,","counters":[]},{"line":"        addr: OCamlRef<String>,","counters":[]},{"line":"        account: OCamlRef<OCamlBytes>,","counters":[]},{"line":"    ) {","counters":[]},{"line":"        let addr = get_addr(rt, addr);","counters":[]},{"line":"        let account = get(rt, account);","counters":[]},{"line":"","counters":[]},{"line":"        with_db(rt, db, |db| {","counters":[{"col_start":29,"col_end":30,"count":0}]},{"line":"            db.set(addr, account)","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"        });","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        OCaml::unit()","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_database_index_of_account(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        db: OCamlRef<DynBox<DatabaseFFI>>,","counters":[]},{"line":"        account_id: OCamlRef<OCamlBytes>","counters":[]},{"line":"    ) -> OCaml<OCamlInt> {","counters":[]},{"line":"        let account_id = get(rt, account_id);","counters":[]},{"line":"","counters":[]},{"line":"        // eprintln!(\"database_index_of_account={:?}\", account_id);","counters":[]},{"line":"","counters":[]},{"line":"        let index = with_db(rt, db, |db| {","counters":[{"col_start":41,"col_end":42,"count":0}]},{"line":"            db.index_of_account(account_id)","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"        }).map(|index| {","counters":[{"col_start":0,"col_end":9,"count":0},{"col_start":23,"col_end":24,"count":0}]},{"line":"            index.0 as i64","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"        })","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"          .unwrap();","counters":[]},{"line":"","counters":[]},{"line":"        index.to_ocaml(rt)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_database_set_at_index(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        db: OCamlRef<DynBox<DatabaseFFI>>,","counters":[]},{"line":"        index: OCamlRef<OCamlInt>,","counters":[]},{"line":"        account: OCamlRef<OCamlBytes>,","counters":[]},{"line":"    ) {","counters":[]},{"line":"        let index = get_index(rt, index);","counters":[]},{"line":"        let account = get(rt, account);","counters":[]},{"line":"","counters":[]},{"line":"        with_db(rt, db, |db| {","counters":[{"col_start":29,"col_end":30,"count":0}]},{"line":"            db.set_at_index(index, account)","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"        }).unwrap();","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        OCaml::unit()","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_database_get_or_create_account(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        db: OCamlRef<DynBox<DatabaseFFI>>,","counters":[]},{"line":"        account_id: OCamlRef<OCamlBytes>,","counters":[]},{"line":"        account: OCamlRef<OCamlBytes>,","counters":[]},{"line":"    ) -> OCaml<Result<(PolymorphicGetOrAdded, String), DatabaseErrorFFI>> {","counters":[]},{"line":"        let account_id = get(rt, account_id);","counters":[]},{"line":"        let account = get(rt, account);","counters":[]},{"line":"","counters":[]},{"line":"        // eprintln!(\"database_get_or_create_account={:?}\", account_id);","counters":[]},{"line":"","counters":[]},{"line":"        let result = with_db(rt, db, |db| {","counters":[{"col_start":42,"col_end":43,"count":0}]},{"line":"            db.get_or_create_account(account_id, account)","counters":[{"col_start":0,"col_end":57,"count":0}]},{"line":"        });","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        use crate::base::GetOrCreated::*;","counters":[]},{"line":"        use crate::database::DatabaseError::*;","counters":[]},{"line":"","counters":[]},{"line":"        let result = match result {","counters":[]},{"line":"            Ok(value) => {","counters":[]},{"line":"                let get_or_added = match value {","counters":[]},{"line":"                    Added(_) => PolymorphicGetOrAdded::Added,","counters":[]},{"line":"                    Existed(_) => PolymorphicGetOrAdded::Existed,","counters":[]},{"line":"                };","counters":[]},{"line":"                let addr = value.addr();","counters":[]},{"line":"                Ok((get_or_added, addr.to_string()))","counters":[]},{"line":"            },","counters":[]},{"line":"            Err(e) => match e {","counters":[]},{"line":"                OutOfLeaves => Err(DatabaseErrorFFI::OutOfLeaves),","counters":[]},{"line":"            },","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        result.to_ocaml(rt)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_database_num_accounts(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        db: OCamlRef<DynBox<DatabaseFFI>>","counters":[]},{"line":"    ) -> OCaml<OCamlInt> {","counters":[]},{"line":"        let num_accounts = with_db(rt, db, |db| {","counters":[{"col_start":48,"col_end":49,"count":0}]},{"line":"            db.num_accounts() as i64","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"        });","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        num_accounts.to_ocaml(rt)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_database_iter(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        db: OCamlRef<DynBox<DatabaseFFI>>,","counters":[]},{"line":"        ocaml_method: OCamlRef<fn(OCamlBytes)>,","counters":[]},{"line":"    ) {","counters":[]},{"line":"        let (num_accounts, depth) = with_db(rt, db, |db| {","counters":[{"col_start":57,"col_end":58,"count":0}]},{"line":"            (db.num_accounts(), db.depth())","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"        });","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        let ocaml_method = ocaml_method.to_boxroot(rt);","counters":[]},{"line":"","counters":[]},{"line":"        for index in 0..num_accounts {","counters":[]},{"line":"            let index = AccountIndex(index as u64);","counters":[]},{"line":"            let addr = Address::from_index(index, depth as usize);","counters":[]},{"line":"","counters":[]},{"line":"            let account = with_db(rt, db, |db| {","counters":[{"col_start":47,"col_end":48,"count":0}]},{"line":"                db.get(addr)","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"            });","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"            let account = match account {","counters":[]},{"line":"                Some(account) => account,","counters":[]},{"line":"                None => continue,","counters":[]},{"line":"            };","counters":[]},{"line":"","counters":[]},{"line":"            let account = account.serialize();","counters":[]},{"line":"","counters":[]},{"line":"            let _: Result<OCaml<()>, _> = ocaml_method.try_call(rt, &account);","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        OCaml::unit()","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_database_foldi(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        db: OCamlRef<DynBox<DatabaseFFI>>,","counters":[]},{"line":"        ocaml_method: OCamlRef<fn(String, OCamlBytes)>,","counters":[]},{"line":"    ) {","counters":[]},{"line":"        let (num_accounts, depth) = with_db(rt, db, |db| {","counters":[{"col_start":57,"col_end":58,"count":0}]},{"line":"            (db.num_accounts(), db.depth())","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"        });","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        let ocaml_method = ocaml_method.to_boxroot(rt);","counters":[]},{"line":"","counters":[]},{"line":"        for index in 0..num_accounts {","counters":[]},{"line":"            let index = AccountIndex(index as u64);","counters":[]},{"line":"            let addr = Address::from_index(index, depth as usize);","counters":[]},{"line":"","counters":[]},{"line":"            let account = with_db(rt, db, |db| {","counters":[{"col_start":47,"col_end":48,"count":0}]},{"line":"                db.get(addr.clone())","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"            });","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"            let account = match account {","counters":[]},{"line":"                Some(account) => account,","counters":[]},{"line":"                None => continue,","counters":[]},{"line":"            };","counters":[]},{"line":"","counters":[]},{"line":"            let account = serialize(&account);","counters":[]},{"line":"            let addr = addr.to_string();","counters":[]},{"line":"","counters":[]},{"line":"            let _: Result<OCaml<()>, _> = ocaml_method.try_call(rt, &addr, &account);","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        OCaml::unit()","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_database_foldi_with_ignored_accounts(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        db: OCamlRef<DynBox<DatabaseFFI>>,","counters":[]},{"line":"        ignored_accounts: OCamlRef<OCamlList<OCamlBytes>>,","counters":[]},{"line":"        ocaml_method: OCamlRef<fn(String, OCamlBytes)>,","counters":[]},{"line":"    ) {","counters":[]},{"line":"        let (num_accounts, depth) = with_db(rt, db, |db| {","counters":[{"col_start":57,"col_end":58,"count":0}]},{"line":"            (db.num_accounts(), db.depth())","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"        });","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        let ignored_accounts = get_set_of::<AccountId>(rt, ignored_accounts);","counters":[]},{"line":"        let ocaml_method = ocaml_method.to_boxroot(rt);","counters":[]},{"line":"","counters":[]},{"line":"        for index in 0..num_accounts {","counters":[]},{"line":"            let index = AccountIndex(index as u64);","counters":[]},{"line":"            let addr = Address::from_index(index, depth as usize);","counters":[]},{"line":"","counters":[]},{"line":"            let account = with_db(rt, db, |db| {","counters":[{"col_start":47,"col_end":48,"count":0}]},{"line":"                db.get(addr.clone())","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"            });","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"            let account = match account {","counters":[]},{"line":"                Some(account) => account,","counters":[]},{"line":"                None => continue,","counters":[]},{"line":"            };","counters":[]},{"line":"","counters":[]},{"line":"            if ignored_accounts.contains(&account.id()) {","counters":[]},{"line":"                continue;","counters":[]},{"line":"            }","counters":[]},{"line":"","counters":[]},{"line":"            let account = serialize(&account);","counters":[]},{"line":"            let addr = addr.to_string();","counters":[]},{"line":"","counters":[]},{"line":"            let _: Result<OCaml<()>, _> = ocaml_method.try_call(rt, &addr, &account);","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        OCaml::unit()","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_database_merkle_root(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        db: OCamlRef<DynBox<DatabaseFFI>>,","counters":[]},{"line":"    ) -> OCaml<OCamlBytes> {","counters":[]},{"line":"        let hash = with_db(rt, db, |db| {","counters":[{"col_start":40,"col_end":41,"count":0}]},{"line":"            db.merkle_root()","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"        });","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        let hash = hash_to_ocaml(hash);","counters":[]},{"line":"","counters":[]},{"line":"        hash.to_ocaml(rt)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_database_remove_accounts(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        db: OCamlRef<DynBox<DatabaseFFI>>,","counters":[]},{"line":"        account_ids: OCamlRef<OCamlList<OCamlBytes>>,","counters":[]},{"line":"    ) {","counters":[]},{"line":"        let account_ids = get_list_of(rt, account_ids);","counters":[]},{"line":"","counters":[]},{"line":"        // eprintln!(\"database_remove_account={:?}\", account_ids);","counters":[]},{"line":"","counters":[]},{"line":"        with_db(rt, db, |db| {","counters":[{"col_start":29,"col_end":30,"count":0}]},{"line":"            db.remove_accounts(&account_ids)","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"        });","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        OCaml::unit()","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_database_set_all_accounts_rooted_at(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        db: OCamlRef<DynBox<DatabaseFFI>>,","counters":[]},{"line":"        addr: OCamlRef<String>,","counters":[]},{"line":"        accounts: OCamlRef<OCamlList<OCamlBytes>>,","counters":[]},{"line":"    ) {","counters":[]},{"line":"        let addr = get_addr(rt, addr);","counters":[]},{"line":"        let accounts = get_list_of(rt, accounts);","counters":[]},{"line":"","counters":[]},{"line":"        with_db(rt, db, |db| {","counters":[{"col_start":29,"col_end":30,"count":0}]},{"line":"            db.set_all_accounts_rooted_at(addr, &accounts).unwrap()","counters":[{"col_start":0,"col_end":67,"count":0}]},{"line":"        });","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        OCaml::unit()","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_database_set_batch_accounts(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        db: OCamlRef<DynBox<DatabaseFFI>>,","counters":[]},{"line":"        accounts: OCamlRef<OCamlList<(String, OCamlBytes)>>,","counters":[]},{"line":"    ) {","counters":[]},{"line":"        let accounts = get_list_addr_account(rt, accounts);","counters":[]},{"line":"","counters":[]},{"line":"        with_db(rt, db, |db| {","counters":[{"col_start":29,"col_end":30,"count":0}]},{"line":"            db.set_batch_accounts(&accounts)","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"        });","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        OCaml::unit()","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_database_get_all_accounts_rooted_at(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        db: OCamlRef<DynBox<DatabaseFFI>>,","counters":[]},{"line":"        addr: OCamlRef<String>,","counters":[]},{"line":"    ) -> OCaml<OCamlList<(String, OCamlBytes)>> {","counters":[]},{"line":"        let addr = get_addr(rt, addr);","counters":[]},{"line":"","counters":[]},{"line":"        let accounts = with_db(rt, db, |db| {","counters":[{"col_start":44,"col_end":45,"count":0}]},{"line":"            db.get_all_accounts_rooted_at(addr)","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"        }).unwrap_or_default()","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"          .iter()","counters":[]},{"line":"            .map(|(addr, account)| {","counters":[{"col_start":35,"col_end":36,"count":0}]},{"line":"              let addr = addr.to_string();","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"              let account = serialize(account);","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"              (addr, account)","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"            })","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"            .collect::<Vec<_>>();","counters":[]},{"line":"","counters":[]},{"line":"        accounts.to_ocaml(rt)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_database_merkle_path(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        db: OCamlRef<DynBox<DatabaseFFI>>,","counters":[]},{"line":"        addr: OCamlRef<String>,","counters":[]},{"line":"    ) -> OCaml<OCamlList<PolymorphicPath>> {","counters":[]},{"line":"        let addr = get_addr(rt, addr);","counters":[]},{"line":"","counters":[]},{"line":"        let path = with_db(rt, db, |db| {","counters":[{"col_start":40,"col_end":41,"count":0}]},{"line":"            db.merkle_path(addr)","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"        }).into_iter()","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"          .map(|path| {","counters":[{"col_start":22,"col_end":23,"count":0}]},{"line":"              match path {","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"                  MerklePath::Left(hash) => PolymorphicPath::Left(hash_to_ocaml(hash)),","counters":[{"col_start":35,"col_end":86,"count":0}]},{"line":"                  MerklePath::Right(hash) => PolymorphicPath::Right(hash_to_ocaml(hash)),","counters":[{"col_start":36,"col_end":88,"count":0}]},{"line":"              }","counters":[]},{"line":"          })","counters":[{"col_start":10,"col_end":11,"count":0}]},{"line":"          .collect::<Vec<_>>();","counters":[]},{"line":"","counters":[]},{"line":"        path.to_ocaml(rt)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_database_merkle_path_at_addr(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        db: OCamlRef<DynBox<DatabaseFFI>>,","counters":[]},{"line":"        addr: OCamlRef<String>,","counters":[]},{"line":"    ) -> OCaml<OCamlList<PolymorphicPath>> {","counters":[]},{"line":"        let addr = get_addr(rt, addr);","counters":[]},{"line":"","counters":[]},{"line":"        let path = with_db(rt, db, |db| {","counters":[{"col_start":40,"col_end":41,"count":0}]},{"line":"            db.merkle_path(addr)","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"        }).into_iter()","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"          .map(|path| {","counters":[{"col_start":22,"col_end":23,"count":0}]},{"line":"              match path {","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"                  MerklePath::Left(hash) => PolymorphicPath::Left(hash_to_ocaml(hash)),","counters":[{"col_start":35,"col_end":86,"count":0}]},{"line":"                  MerklePath::Right(hash) => PolymorphicPath::Right(hash_to_ocaml(hash)),","counters":[{"col_start":36,"col_end":88,"count":0}]},{"line":"              }","counters":[]},{"line":"          })","counters":[{"col_start":10,"col_end":11,"count":0}]},{"line":"          .collect::<Vec<_>>();","counters":[]},{"line":"","counters":[]},{"line":"        path.to_ocaml(rt)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn rust_database_merkle_path_at_index(","counters":[]},{"line":"        rt,","counters":[]},{"line":"        db: OCamlRef<DynBox<DatabaseFFI>>,","counters":[]},{"line":"        index: OCamlRef<OCamlInt>,","counters":[]},{"line":"    ) -> OCaml<OCamlList<PolymorphicPath>> {","counters":[]},{"line":"        let index = get_index(rt, index);","counters":[]},{"line":"","counters":[]},{"line":"        let path = with_db(rt, db, |db| {","counters":[{"col_start":40,"col_end":41,"count":0}]},{"line":"            let depth = db.depth();","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"            let addr = Address::from_index(index, depth as usize);","counters":[{"col_start":0,"col_end":66,"count":0}]},{"line":"            db.merkle_path(addr)","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"        }).into_iter()","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"          .map(|path| {","counters":[{"col_start":22,"col_end":23,"count":0}]},{"line":"              match path {","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"                  MerklePath::Left(hash) => PolymorphicPath::Left(hash_to_ocaml(hash)),","counters":[{"col_start":35,"col_end":86,"count":0}]},{"line":"                  MerklePath::Right(hash) => PolymorphicPath::Right(hash_to_ocaml(hash)),","counters":[{"col_start":36,"col_end":88,"count":0}]},{"line":"                  // MerklePath::Left(hash) => PolymorphicPath::Left(hash.to_string()),","counters":[]},{"line":"                  // MerklePath::Right(hash) => PolymorphicPath::Right(hash.to_string()),","counters":[]},{"line":"              }","counters":[]},{"line":"          })","counters":[{"col_start":10,"col_end":11,"count":0}]},{"line":"          .collect::<Vec<_>>();","counters":[]},{"line":"","counters":[]},{"line":"        path.to_ocaml(rt)","counters":[]},{"line":"    }","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"// database_create : int -> database = \"rust_database_create\"","counters":[]},{"line":"// database_get_uuid : database -> string = \"rust_database_get_uuid\"","counters":[]},{"line":"// database_depth : database -> int = \"rust_database_depth\"","counters":[]},{"line":"// database_create_checkpoint : database -> database = \"rust_database_create_checkpoint\"","counters":[]},{"line":"// database_make_checkpoint : database -> unit = \"rust_database_make_checkpoint\"","counters":[]},{"line":"// database_close : database -> unit = \"rust_database_close\"","counters":[]},{"line":"// database_get : database -> addr -> account option = \"rust_database_get\"","counters":[]},{"line":"// database_get_batch : database -> addr list -> (addr * (account option)) list = \"rust_database_get_batch\"","counters":[]},{"line":"// database_get_list : database -> bytes list = \"rust_database_get_list\"","counters":[]},{"line":"// database_accounts : database -> bytes list = \"rust_database_accounts\"","counters":[]},{"line":"// database_get_inner_hash_at_addr : database -> addr -> bytes = \"rust_database_get_inner_hash_at_addr\"","counters":[]},{"line":"// database_set_inner_hash_at_addr : database -> addr -> bytes -> unit = \"rust_database_set_inner_hash_at_addr\"","counters":[]},{"line":"// database_get_at_index : database -> int -> account = \"rust_database_get_at_index\"","counters":[]},{"line":"// database_iter : database -> (int -> bytes -> unit) -> unit = \"rust_database_iter\"","counters":[]},{"line":"// database_location_of_account : database -> account_id -> addr option = \"rust_database_location_of_account\"","counters":[]},{"line":"// database_location_of_account_batch : database -> account_id list -> (account_id * (addr option)) list = \"rust_database_location_of_account_batch\"","counters":[]},{"line":"","counters":[]},{"line":"// database_last_filled : database -> addr option = \"rust_database_last_filled\"","counters":[]},{"line":"// database_token_owners : database -> bytes list = \"rust_database_token_owners\"","counters":[]},{"line":"// database_token_owner : database -> token_id -> account_id option = \"rust_database_token_owner\"","counters":[]},{"line":"// database_tokens : database -> pubkey -> token_id list = \"rust_database_tokens\"","counters":[]},{"line":"// database_set : database -> addr -> account -> unit = \"rust_database_set\"","counters":[]},{"line":"// database_index_of_account : database -> account_id -> int = \"rust_database_index_of_account\"","counters":[]},{"line":"// database_set_at_index : database -> int -> account -> unit = \"rust_database_set_at_index\"","counters":[]},{"line":"// database_get_or_create_account : database -> account_id -> account -> (([ `Added | `Existed ] * addr), rust_dberror) result = \"rust_database_get_or_create_account\"","counters":[]},{"line":"// database_num_accounts : database -> int = \"rust_database_num_accounts\"","counters":[]},{"line":"// database_fold_with_account_ids : database -> bytes list -> bytes -> (bytes -> unit) -> bytes = \"rust_database_fold_with_ignored_accounts\"","counters":[]},{"line":"// database_fold : database -> bytes -> (bytes -> unit) -> bytes = \"rust_database_fold\"","counters":[]},{"line":"// database_fold_until : database -> bytes -> (bytes -> bool) -> bytes = \"rust_database_fold_until\"","counters":[]},{"line":"// database_merkle_root : database -> bytes = \"rust_database_merkle_root\"","counters":[]},{"line":"// database_remove_accounts : database -> account_id list -> unit = \"rust_database_remove_accounts\"","counters":[]},{"line":"// database_merkle_path : database -> addr -> bytes list = \"rust_database_merkle_path\"","counters":[]},{"line":"// database_merkle_path_at_addr : database -> bytes -> bytes list = \"rust_database_merkle_path_at_addr\"","counters":[]},{"line":"// database_merkle_path_at_index : database -> int -> bytes list = \"rust_database_merkle_path_at_index\"","counters":[]},{"line":"// database_set_all_accounts_rooted_at : database -> addr -> bytes list -> unit = \"rust_database_set_all_accounts_rooted_at\"","counters":[]},{"line":"// database_set_batch_accounts : database -> (addr * account) list -> unit = \"rust_database_set_batch_accounts\"","counters":[]},{"line":"// database_get_all_accounts_rooted_at : database -> addr -> (addr * account) list = \"rust_database_get_all_accounts_rooted_at\"","counters":[]},{"line":"","counters":[]},{"line":"// (* TODO: Make those method *)","counters":[]},{"line":"// database_foldi : database -> (addr -> bytes -> unit) -> unit = \"rust_database_foldi\"","counters":[]},{"line":"// database_foldi_with_ignored_accounts : database -> account list -> (addr -> bytes -> unit) -> unit = \"rust_database_foldi_with_ignored_accounts\"","counters":[]},{"line":"","counters":[]},{"line":"#[allow(clippy::let_and_return)]","counters":[]},{"line":"fn impl_rust_random_account() -> Vec<u8> {","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"    // elog!(\"rust_random_account begin\");","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"","counters":[]},{"line":"    let account = Account::rand();","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"    let ser = serialize(&account);","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"","counters":[]},{"line":"    // let ser: Vec<u8> = vec![","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"    //     178, 29, 73, 50, 85, 80, 131, 166, 53, 11, 48, 224, 103, 89, 161, 207, 149, 31, 170, 21,","counters":[{"col_start":0,"col_end":99,"count":0}]},{"line":"    //     165, 181, 94, 18, 149, 177, 54, 71, 185, 77, 109, 49, 1, 144, 247, 164, 171, 110, 24, 3,","counters":[{"col_start":0,"col_end":99,"count":0}]},{"line":"    //     12, 25, 163, 63, 125, 83, 66, 174, 2, 160, 62, 45, 137, 185, 47, 16, 129, 145, 190, 203,","counters":[{"col_start":0,"col_end":99,"count":0}]},{"line":"    //     124, 35, 119, 251, 26, 1, 1, 6, 49, 50, 56, 54, 56, 56, 252, 29, 154, 218, 214, 79, 98,","counters":[{"col_start":0,"col_end":98,"count":0}]},{"line":"    //     177, 181, 253, 181, 152, 127, 0, 145, 177, 91, 155, 59, 239, 161, 174, 217, 42, 201, 30,","counters":[{"col_start":0,"col_end":99,"count":0}]},{"line":"    //     46, 11, 187, 88, 49, 5, 111, 254, 222, 87, 42, 45, 90, 1, 236, 173, 205, 215, 241, 20, 0,","counters":[{"col_start":0,"col_end":100,"count":0}]},{"line":"    //     77, 12, 197, 234, 69, 202, 22, 55, 50, 183, 255, 238, 8, 29, 79, 199, 92, 12, 146, 223,","counters":[{"col_start":0,"col_end":98,"count":0}]},{"line":"    //     105, 45, 135, 77, 89, 73, 141, 11, 137, 28, 54, 21, 0, 1, 4, 4, 1, 0, 4, 3, 4, 3, 2, 3, 0,","counters":[{"col_start":0,"col_end":101,"count":0}]},{"line":"    //     6, 49, 49, 56, 54, 54, 51,","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"    // ];","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"    // let account: Account = serde_binprot::from_slice(&ser).unwrap();","counters":[{"col_start":0,"col_end":71,"count":0}]},{"line":"","counters":[]},{"line":"    // // account2.permissions = Permissions::user_default();","counters":[{"col_start":0,"col_end":61,"count":0}]},{"line":"","counters":[]},{"line":"    // // let account_hash2 = account2.hash();","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"","counters":[]},{"line":"    // // elog!(\"HASH2={:?}\", account_hash2.to_string());","counters":[{"col_start":0,"col_end":57,"count":0}]},{"line":"","counters":[]},{"line":"    // // let mut account2 = Account::empty();","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"","counters":[]},{"line":"    // // account2.public_key = account.public_key;","counters":[{"col_start":0,"col_end":51,"count":0}]},{"line":"    // // account2.token_id = account.token_id;","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"    // // // account2.token_permissions = account.token_permissions;","counters":[{"col_start":0,"col_end":68,"count":0}]},{"line":"    // // account2.token_permissions = TokenPermissions::TokenOwned { disable_new_accounts: false };","counters":[{"col_start":0,"col_end":100,"count":0}]},{"line":"","counters":[]},{"line":"    // // elog!(\"ACCOUNT={:#?}\", account2);","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"","counters":[]},{"line":"    // let ser = serialize(&account)","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"","counters":[]},{"line":"    // elog!(\"rust_random_account end\");","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"    ser","counters":[{"col_start":0,"col_end":7,"count":0}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"// pub struct Account {","counters":[]},{"line":"//     pub public_key: CompressedPubKey,         // Public_key.Compressed.t","counters":[]},{"line":"//     pub token_id: TokenId,                    // Token_id.t","counters":[]},{"line":"//     pub token_permissions: TokenPermissions,  // Token_permissions.t","counters":[]},{"line":"//     pub token_symbol: TokenSymbol,            // Token_symbol.t","counters":[]},{"line":"//     pub balance: Balance,                     // Balance.t","counters":[]},{"line":"//     pub nonce: Nonce,                         // Nonce.t","counters":[]},{"line":"//     pub receipt_chain_hash: ReceiptChainHash, // Receipt.Chain_hash.t","counters":[]},{"line":"//     pub delegate: Option<CompressedPubKey>,   // Public_key.Compressed.t option","counters":[]},{"line":"//     pub voting_for: VotingFor,                // State_hash.t","counters":[]},{"line":"//     pub timing: Timing,                       // Timing.t","counters":[]},{"line":"//     pub permissions: Permissions<AuthRequired>, // Permissions.t","counters":[]},{"line":"//     pub zkapp: Option<ZkAppAccount>,          // Zkapp_account.t","counters":[]},{"line":"//     pub zkapp_uri: String,                    // string","counters":[]},{"line":"// }","counters":[]}]}