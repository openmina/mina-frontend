{"filename":"src/lib/downloader/downloader.ml","lines":[{"line":"open Async","counters":[]},{"line":"open Core","counters":[]},{"line":"open Pipe_lib","counters":[]},{"line":"open Network_peer","counters":[]},{"line":"","counters":[]},{"line":"module Job = struct","counters":[]},{"line":"  type ('key, 'attempt, 'a) t =","counters":[]},{"line":"    { key : 'key","counters":[]},{"line":"    ; attempts : 'attempt Peer.Map.t","counters":[]},{"line":"    ; res :","counters":[]},{"line":"        ('a Envelope.Incoming.t * 'attempt Peer.Map.t, [ `Finished ]) Result.t","counters":[]},{"line":"        Ivar.t","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let result t = Ivar.read t.res","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"type 'a pred = 'a -> bool [@@deriving sexp_of]","counters":[{"col_start":0,"col_end":0,"count":0}]},{"line":"","counters":[]},{"line":"let pred_to_yojson _f _x = `String \"<opaque>\"","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"","counters":[]},{"line":"let sexp_opaque_to_yojson _f _x = `String \"<opaque>\"","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"","counters":[]},{"line":"module Claimed_knowledge = struct","counters":[]},{"line":"  type 'key t = [ `All | `Some of 'key list | `Call of 'key pred [@sexp.opaque] ]","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":42,"col_end":42,"count":0},{"col_start":55,"col_end":55,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"  [@@deriving sexp_of, to_yojson]","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"","counters":[]},{"line":"  let to_yojson f t =","counters":[]},{"line":"    match t with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | `Some ks ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let n = List.length ks in","counters":[]},{"line":"        if n > 5 then to_yojson (fun x -> `Int x) (`Some [ n ])","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"        else to_yojson f t","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"    | _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        to_yojson f t","counters":[]},{"line":"","counters":[]},{"line":"  let check ~equal t k =","counters":[]},{"line":"    match t with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | `All ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        true","counters":[]},{"line":"    | `Some ks ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        List.mem ~equal ks k","counters":[]},{"line":"    | `Call f ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        f k","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make (Key : sig","counters":[]},{"line":"  type t [@@deriving to_yojson, hash, sexp, compare]","counters":[]},{"line":"","counters":[]},{"line":"  include Hashable.S with type t := t","counters":[]},{"line":"","counters":[]},{"line":"  include Comparable.S with type t := t","counters":[]},{"line":"end) (Attempt : sig","counters":[]},{"line":"  type t [@@deriving to_yojson]","counters":[]},{"line":"","counters":[]},{"line":"  val download : t","counters":[]},{"line":"","counters":[]},{"line":"  val worth_retrying : t -> bool","counters":[]},{"line":"end) (Result : sig","counters":[]},{"line":"  type t","counters":[]},{"line":"","counters":[]},{"line":"  val key : t -> Key.t","counters":[]},{"line":"end) (Knowledge_context : sig","counters":[]},{"line":"  type t","counters":[]},{"line":"end) : sig","counters":[]},{"line":"  type t [@@deriving to_yojson]","counters":[]},{"line":"","counters":[]},{"line":"  module Job : sig","counters":[]},{"line":"    type t = (Key.t, Attempt.t, Result.t) Job.t","counters":[]},{"line":"","counters":[]},{"line":"    val result :","counters":[]},{"line":"         t","counters":[]},{"line":"      -> ( Result.t Envelope.Incoming.t * Attempt.t Peer.Map.t","counters":[]},{"line":"         , [ `Finished ] )","counters":[]},{"line":"         Base.Result.t","counters":[]},{"line":"         Deferred.t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  val cancel : t -> Key.t -> unit","counters":[]},{"line":"","counters":[]},{"line":"  val create :","counters":[]},{"line":"       max_batch_size:int","counters":[]},{"line":"    -> stop:unit Deferred.t","counters":[]},{"line":"    -> trust_system:Trust_system.t","counters":[]},{"line":"    -> get:(Peer.t -> Key.t list -> Result.t list Deferred.Or_error.t)","counters":[]},{"line":"    -> knowledge_context:Knowledge_context.t Broadcast_pipe.Reader.t","counters":[]},{"line":"    -> knowledge:","counters":[]},{"line":"         (Knowledge_context.t -> Peer.t -> Key.t Claimed_knowledge.t Deferred.t)","counters":[]},{"line":"    -> peers:(unit -> Peer.t list Deferred.t)","counters":[]},{"line":"    -> preferred:Peer.t list","counters":[]},{"line":"    -> t Deferred.t","counters":[]},{"line":"","counters":[]},{"line":"  val download : t -> key:Key.t -> attempts:Attempt.t Peer.Map.t -> Job.t","counters":[]},{"line":"","counters":[]},{"line":"  val mark_preferred : t -> Peer.t -> now:Time.t -> unit","counters":[]},{"line":"","counters":[]},{"line":"  val add_knowledge : t -> Peer.t -> Key.t list -> unit","counters":[]},{"line":"","counters":[]},{"line":"  val update_knowledge : t -> Peer.t -> Key.t Claimed_knowledge.t -> unit","counters":[]},{"line":"","counters":[]},{"line":"  val total_jobs : t -> int","counters":[]},{"line":"","counters":[]},{"line":"  val check_invariant : t -> unit","counters":[]},{"line":"","counters":[]},{"line":"  val set_check_invariant : (t -> unit) -> unit","counters":[]},{"line":"end = struct","counters":[]},{"line":"  let max_wait = Time.Span.of_ms 100.","counters":[{"col_start":31,"col_end":31,"count":2}]},{"line":"","counters":[]},{"line":"  module J = Job","counters":[]},{"line":"","counters":[]},{"line":"  module Job = struct","counters":[]},{"line":"    type t = (Key.t, Attempt.t, Result.t) Job.t","counters":[]},{"line":"","counters":[]},{"line":"    let to_yojson ({ key; attempts; _ } : t) : Yojson.Safe.t =","counters":[]},{"line":"      `Assoc","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [ (\"key\", Key.to_yojson key)","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"        ; ( \"attempts\"","counters":[]},{"line":"          , `Assoc","counters":[]},{"line":"              (List.map (Map.to_alist attempts) ~f:(fun (p, a) ->","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"                   (Peer.to_multiaddr_string p, Attempt.to_yojson a) ) ) )","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":43,"col_end":43,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"        ]","counters":[]},{"line":"","counters":[]},{"line":"    let result = Job.result","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Make_hash_queue (Key : Hashable.S) = struct","counters":[]},{"line":"    module Key_value = struct","counters":[]},{"line":"      type 'a t = { key : Key.t; mutable value : 'a } [@@deriving fields]","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":14,"col_end":14,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    (* Hash_queue would be perfect, but it doesn't expose enough for","counters":[]},{"line":"         us to make sure the underlying queue is sorted by blockchain_length. *)","counters":[]},{"line":"    type 'a t =","counters":[]},{"line":"      { queue : 'a Key_value.t Doubly_linked.t","counters":[]},{"line":"      ; table : 'a Key_value.t Doubly_linked.Elt.t Key.Table.t","counters":[]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    let dequeue t =","counters":[]},{"line":"      Option.map (Doubly_linked.remove_first t.queue) ~f:(fun { key; value } ->","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"          Hashtbl.remove t.table key ; value )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"    let enqueue t (e : _ J.t) =","counters":[]},{"line":"      if Hashtbl.mem t.table e.key then `Key_already_present","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"      else","counters":[]},{"line":"        let kv = { Key_value.key = e.key; value = e } in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let elt =","counters":[]},{"line":"          match","counters":[]},{"line":"            Doubly_linked.find_elt t.queue ~f:(fun { value; _ } ->","counters":[]},{"line":"                Key.compare e.key value.J.key < 0 )","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"          with","counters":[]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (* e is >= everything. Put it at the back. *)","counters":[]},{"line":"              Doubly_linked.insert_last t.queue kv","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"          | Some pred ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Doubly_linked.insert_before t.queue pred kv","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"        in","counters":[]},{"line":"        Hashtbl.set t.table ~key:e.key ~data:elt ;","counters":[]},{"line":"        `Ok","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"    let lookup t k =","counters":[]},{"line":"      Option.map (Hashtbl.find t.table k) ~f:(fun x ->","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"          (Doubly_linked.Elt.value x).value )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"","counters":[]},{"line":"    let remove t k =","counters":[]},{"line":"      match Hashtbl.find_and_remove t.table k with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ()","counters":[]},{"line":"      | Some elt ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Doubly_linked.remove t.queue elt","counters":[]},{"line":"","counters":[]},{"line":"    let length t = Doubly_linked.length t.queue","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"","counters":[]},{"line":"    let to_list t = List.map (Doubly_linked.to_list t.queue) ~f:Key_value.value","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"","counters":[]},{"line":"    let create () =","counters":[]},{"line":"      { table = Key.Table.create (); queue = Doubly_linked.create () }","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Q = Make_hash_queue (Key)","counters":[]},{"line":"","counters":[]},{"line":"  module Knowledge = struct","counters":[]},{"line":"    module Key_set = struct","counters":[]},{"line":"      type t = Key.Hash_set.t [@@deriving sexp]","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"      let to_yojson t = `List (List.map (Hash_set.to_list t) ~f:Key.to_yojson)","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    type t =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      { claimed : Key.t Claimed_knowledge.t option","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"      ; tried_and_failed : Key_set.t","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"      }","counters":[]},{"line":"    [@@deriving sexp_of, to_yojson]","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"","counters":[]},{"line":"    let clear t = Hash_set.clear t.tried_and_failed","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"","counters":[]},{"line":"    let create () =","counters":[]},{"line":"      { claimed = None; tried_and_failed = Key.Hash_set.create () }","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"","counters":[]},{"line":"    let knows t k =","counters":[]},{"line":"      if Hash_set.mem t.tried_and_failed k then `No","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"      else","counters":[]},{"line":"        match t.claimed with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            `No_information","counters":[]},{"line":"        | Some claimed ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            if Claimed_knowledge.check ~equal:Key.equal claimed k then","counters":[]},{"line":"              `Claims_to","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"            else `No","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Useful_peers = struct","counters":[]},{"line":"    module Preferred_heap = struct","counters":[]},{"line":"      (* The preferred peers, sorted by the last time that they were useful to us. *)","counters":[]},{"line":"      type t =","counters":[]},{"line":"        { heap : (Peer.t * Time.t) Pairing_heap.t","counters":[]},{"line":"        ; table : (Peer.t * Time.t) Pairing_heap.Elt.t Peer.Table.t","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"      let cmp (p1, t1) (p2, t2) =","counters":[]},{"line":"        (* Later is smaller *)","counters":[]},{"line":"        match Int.neg (Time.compare t1 t2) with","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"        | 0 ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Peer.compare p1 p2","counters":[]},{"line":"        | c ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            c","counters":[]},{"line":"","counters":[]},{"line":"      let clear t =","counters":[]},{"line":"        let rec go t =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          match Pairing_heap.pop t with None -> () | Some _ -> go t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"        in","counters":[]},{"line":"        go t.heap ; Hashtbl.clear t.table","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"","counters":[]},{"line":"      let create () =","counters":[]},{"line":"        { heap = Pairing_heap.create ~cmp (); table = Peer.Table.create () }","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":70,"col_end":70,"count":0}]},{"line":"","counters":[]},{"line":"      let add t (p, time) =","counters":[]},{"line":"        Option.iter (Hashtbl.find t.table p) ~f:(fun elt ->","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"            Pairing_heap.remove t.heap elt ) ;","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"        Hashtbl.set t.table ~key:p","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ~data:(Pairing_heap.add_removable t.heap (p, time))","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"","counters":[]},{"line":"      let sexp_of_t (t : t) =","counters":[]},{"line":"        List.sexp_of_t [%sexp_of: Peer.t * Time.t] (Pairing_heap.to_list t.heap)","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"","counters":[]},{"line":"      let of_list xs =","counters":[]},{"line":"        let now = Time.now () in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let t = create () in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        List.iter xs ~f:(fun p -> add t (p, now)) ;","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"        t","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      let mem t p = Hashtbl.mem t.table p","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"","counters":[]},{"line":"      let fold t ~init ~f =","counters":[]},{"line":"        Pairing_heap.fold t.heap ~init ~f:(fun acc (p, _) -> f acc p)","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"","counters":[]},{"line":"      let to_list (t : t) = List.map ~f:fst (Pairing_heap.to_list t.heap)","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    type t =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      { downloading_peers : Peer.Hash_set.t","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      ; knowledge_requesting_peers : Peer.Hash_set.t","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      ; temporary_ignores :","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ((unit, unit) Clock.Event.t[@sexp.opaque]) Peer.Table.t","counters":[]},{"line":"      ; mutable all_preferred : Preferred_heap.t","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"      ; knowledge : Knowledge.t Peer.Table.t","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            (* Written to when something changes. *)","counters":[]},{"line":"      ; r : (unit Strict_pipe.Reader.t[@sexp.opaque])","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      ; w :","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (( unit","counters":[]},{"line":"           , Strict_pipe.drop_head Strict_pipe.buffered","counters":[]},{"line":"           , unit )","counters":[]},{"line":"           Strict_pipe.Writer.t","counters":[]},{"line":"          [@sexp.opaque] )","counters":[]},{"line":"      }","counters":[]},{"line":"    [@@deriving sexp_of]","counters":[]},{"line":"","counters":[]},{"line":"    let reset_knowledge t ~all_peers =","counters":[]},{"line":"      (* Reset preferred *)","counters":[]},{"line":"      Preferred_heap.clear t.all_preferred ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Hashtbl.filter_mapi_inplace t.knowledge ~f:(fun ~key:p ~data:k ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          Hash_set.clear k.tried_and_failed ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          if Set.mem all_peers p then Some { k with claimed = None } else None ) ;","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":74,"col_end":74,"count":0}]},{"line":"      Set.iter all_peers ~f:(fun p ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          if not (Hashtbl.mem t.knowledge p) then","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"            Hashtbl.add_exn t.knowledge ~key:p ~data:(Knowledge.create ()) ) ;","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"      Strict_pipe.Writer.write t.w ()","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let to_yojson","counters":[]},{"line":"        { knowledge","counters":[]},{"line":"        ; all_preferred","counters":[]},{"line":"        ; knowledge_requesting_peers","counters":[]},{"line":"        ; temporary_ignores","counters":[]},{"line":"        ; downloading_peers","counters":[]},{"line":"        ; r = _","counters":[]},{"line":"        ; w = _","counters":[]},{"line":"        } =","counters":[]},{"line":"      let list xs =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        `Assoc [ (\"length\", `Int (List.length xs)); (\"elts\", `List xs) ]","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"      in","counters":[]},{"line":"      let f q = Knowledge.to_yojson q in","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"      `Assoc","counters":[]},{"line":"        [ ( \"all\"","counters":[]},{"line":"          , `Assoc","counters":[]},{"line":"              (List.map (Hashtbl.to_alist knowledge) ~f:(fun (p, s) ->","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"                   (Peer.to_multiaddr_string p, f s) ) ) )","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":43,"col_end":43,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"        ; ( \"preferred\"","counters":[]},{"line":"          , `List","counters":[]},{"line":"              (List.map (Preferred_heap.to_list all_preferred) ~f:(fun p ->","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"                   `String (Peer.to_multiaddr_string p) ) ) )","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"        ; ( \"temporary_ignores\"","counters":[]},{"line":"          , list (List.map ~f:Peer.to_yojson (Hashtbl.keys temporary_ignores))","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"          )","counters":[]},{"line":"        ; ( \"downloading_peers\"","counters":[]},{"line":"          , list","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"              (List.map ~f:Peer.to_yojson (Hash_set.to_list downloading_peers))","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"          )","counters":[]},{"line":"        ; ( \"knowledge_requesting_peers\"","counters":[]},{"line":"          , list","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"              (List.map ~f:Peer.to_yojson","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                 (Hash_set.to_list knowledge_requesting_peers) ) )","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"        ]","counters":[]},{"line":"","counters":[]},{"line":"    let create ~preferred ~all_peers =","counters":[]},{"line":"      let knowledge =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Peer.Table.of_alist_exn","counters":[]},{"line":"          (List.map (List.dedup_and_sort ~compare:Peer.compare all_peers)","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"             ~f:(fun p -> (p, Knowledge.create ())) )","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"      in","counters":[]},{"line":"      let r, w =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Strict_pipe.create ~name:\"useful_peers-available\" ~warn_on_drop:false","counters":[]},{"line":"          (Buffered (`Capacity 0, `Overflow (Drop_head ignore)))","counters":[]},{"line":"      in","counters":[]},{"line":"      { downloading_peers = Peer.Hash_set.create ()","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"      ; knowledge_requesting_peers = Peer.Hash_set.create ()","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"      ; temporary_ignores = Peer.Table.create ()","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"      ; knowledge","counters":[]},{"line":"      ; r","counters":[]},{"line":"      ; w","counters":[]},{"line":"      ; all_preferred = Preferred_heap.of_list preferred","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    let tear_down","counters":[]},{"line":"        { downloading_peers","counters":[]},{"line":"        ; temporary_ignores","counters":[]},{"line":"        ; knowledge_requesting_peers","counters":[]},{"line":"        ; knowledge","counters":[]},{"line":"        ; r = _","counters":[]},{"line":"        ; w","counters":[]},{"line":"        ; all_preferred","counters":[]},{"line":"        } =","counters":[]},{"line":"      Hashtbl.iter temporary_ignores ~f:(fun e ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          Clock.Event.abort_if_possible e () ) ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"      Hashtbl.clear temporary_ignores ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Hash_set.clear downloading_peers ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Hash_set.clear knowledge_requesting_peers ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Hashtbl.iter knowledge ~f:Knowledge.clear ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Hashtbl.clear knowledge ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Preferred_heap.clear all_preferred ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Strict_pipe.Writer.close w","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    module Knowledge_summary = struct","counters":[]},{"line":"      type t = { no_information : int; no : int; claims_to : int }","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":11,"col_end":11,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"      [@@deriving fields]","counters":[]},{"line":"","counters":[]},{"line":"      (* Score needs revising -- should be more lexicographic *)","counters":[]},{"line":"      let score { no_information; no = _; claims_to } =","counters":[]},{"line":"        Float.of_int claims_to +. (0.1 *. Float.of_int no_information)","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    let maxes ~compare xs =","counters":[]},{"line":"      O1trace.sync_thread \"compute_downloader_maxes\" (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          Sequence.fold xs ~init:[] ~f:(fun acc x ->","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"              match acc with","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              | [] ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  [ x ]","counters":[]},{"line":"              | best :: _ ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  let c = compare best x in","counters":[]},{"line":"                  if c = 0 then x :: acc else if c < 0 then [ x ] else acc )","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":46,"col_end":46,"count":0},{"col_start":60,"col_end":60,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"          |> List.rev )","counters":[]},{"line":"","counters":[]},{"line":"    let useful_peer t ~pending_jobs =","counters":[]},{"line":"      O1trace.sync_thread \"compute_downloader_useful_peers\" (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          let ts =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            List.rev","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"              (Preferred_heap.fold t.all_preferred ~init:[] ~f:(fun acc p ->","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"                   match Hashtbl.find t.knowledge p with","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"                   | None ->","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                       acc","counters":[]},{"line":"                   | Some k ->","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                       (p, k) :: acc ) )","counters":[]},{"line":"            @ Hashtbl.fold t.knowledge ~init:[] ~f:(fun ~key:p ~data:k acc ->","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                  if not (Preferred_heap.mem t.all_preferred p) then","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"                    (p, k) :: acc","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                  else acc )","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"          in","counters":[]},{"line":"          (*","counters":[]},{"line":"           Algorithm:","counters":[]},{"line":"           - Look at the pending jobs","counters":[]},{"line":"           - Find all peers who have the best claim to knowing the first job in the queue.","counters":[]},{"line":"           - If there are any, pick the one of those who has the best total knowledge score.","counters":[]},{"line":"           - If there are none, pick the one of all the peers who has the best total knowledge score.","counters":[]},{"line":"        *)","counters":[]},{"line":"          let with_best_claim_to_knowing_first_job =","counters":[]},{"line":"            match List.hd pending_jobs with","counters":[]},{"line":"            | None ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                []","counters":[]},{"line":"            | Some j ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Sequence.filter_map (Sequence.of_list ts) ~f:(fun (p, k) ->","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"                    match Knowledge.knows k j.J.key with","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                    | `No ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        None","counters":[]},{"line":"                    | `Claims_to ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        Some ((p, k), `Claims_to)","counters":[]},{"line":"                    | `No_information ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        Some ((p, k), `No_information) )","counters":[]},{"line":"                |> maxes ~compare:(fun (_, c1) (_, c2) ->","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                       match (c1, c2) with","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                       | `Claims_to, `Claims_to","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                       | `No_information, `No_information ->","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                           0","counters":[]},{"line":"                       | `Claims_to, `No_information ->","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                           1","counters":[]},{"line":"                       | `No_information, `Claims_to ->","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                           -1 )","counters":[]},{"line":"                |> List.map ~f:fst","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"          in","counters":[]},{"line":"          let ts =","counters":[]},{"line":"            match with_best_claim_to_knowing_first_job with","counters":[]},{"line":"            | [] ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ts","counters":[]},{"line":"            | _ :: _ ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                with_best_claim_to_knowing_first_job","counters":[]},{"line":"          in","counters":[]},{"line":"          let knowledge =","counters":[]},{"line":"            List.map ts ~f:(fun (p, k) ->","counters":[]},{"line":"                let summary, js =","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  List.fold","counters":[]},{"line":"                    ~init:","counters":[]},{"line":"                      ( { Knowledge_summary.no_information = 0","counters":[]},{"line":"                        ; no = 0","counters":[]},{"line":"                        ; claims_to = 0","counters":[]},{"line":"                        }","counters":[]},{"line":"                      , [] )","counters":[]},{"line":"                    pending_jobs","counters":[]},{"line":"                    ~f:(fun (acc, js) j ->","counters":[]},{"line":"                      let field, js =","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        let open Knowledge_summary.Fields in","counters":[]},{"line":"                        match Knowledge.knows k j.J.key with","counters":[]},{"line":"                        | `Claims_to ->","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            (claims_to, j :: js)","counters":[]},{"line":"                        | `No ->","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            (no, js)","counters":[]},{"line":"                        | `No_information ->","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            (no_information, j :: js)","counters":[]},{"line":"                      in","counters":[]},{"line":"                      (Field.map field acc ~f:(( + ) 1), js) )","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                in","counters":[]},{"line":"                ((p, List.rev js), Knowledge_summary.score summary) )","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"          in","counters":[]},{"line":"          let useful_exists =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            List.exists knowledge ~f:(fun (_, s) -> Float.(s > 0.))","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"          in","counters":[]},{"line":"          let best =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            List.max_elt","counters":[]},{"line":"              (List.filter knowledge ~f:(fun ((p, _), _) ->","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                   (not (Hashtbl.mem t.temporary_ignores p))","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"                   && (not (Hash_set.mem t.downloading_peers p))","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"                   && not (Hash_set.mem t.knowledge_requesting_peers p) ) )","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"              ~compare:(fun (_, s1) (_, s2) -> Float.compare s1 s2)","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"          in","counters":[]},{"line":"          match best with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              if useful_exists then `Useful_but_busy else `No_peers","counters":[{"col_start":36,"col_end":36,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"          | Some ((p, k), score) ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              if Float.(score <= 0.) then `Stalled else `Useful (p, k) )","counters":[{"col_start":42,"col_end":42,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"","counters":[]},{"line":"    type update =","counters":[]},{"line":"      | Refreshed_peers of { all_peers : Peer.Set.t }","counters":[]},{"line":"      | Download_finished of","counters":[]},{"line":"          Peer.t","counters":[]},{"line":"          * [ `Successful of Key.t list ]","counters":[]},{"line":"          * [ `Unsuccessful of Key.t list ]","counters":[]},{"line":"      | Download_starting of Peer.t","counters":[]},{"line":"      | Job_cancelled of Key.t","counters":[]},{"line":"      | Add_knowledge of","counters":[]},{"line":"          { peer : Peer.t; claimed : Key.t list; out_of_band : bool }","counters":[]},{"line":"      | Knowledge_request_starting of Peer.t","counters":[]},{"line":"      | Knowledge of","counters":[]},{"line":"          { peer : Peer.t","counters":[]},{"line":"          ; claimed : Key.t Claimed_knowledge.t","counters":[]},{"line":"          ; active_jobs : Job.t list","counters":[]},{"line":"          ; out_of_band : bool","counters":[]},{"line":"          }","counters":[]},{"line":"","counters":[]},{"line":"    let jobs_no_longer_needed t ks =","counters":[]},{"line":"      Hashtbl.iter t.knowledge ~f:(fun s ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          List.iter ks ~f:(Hash_set.remove s.tried_and_failed) )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"","counters":[]},{"line":"    let ignore_period = Time.Span.of_min 2.","counters":[{"col_start":39,"col_end":39,"count":2}]},{"line":"","counters":[]},{"line":"    let update t u =","counters":[]},{"line":"      O1trace.sync_thread \"update_downloader\" (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          match u with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | Add_knowledge { peer; claimed; out_of_band } ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              if not out_of_band then","counters":[]},{"line":"                Hash_set.remove t.knowledge_requesting_peers peer ;","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"              Hashtbl.update t.knowledge peer ~f:(function","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                | None ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    { Knowledge.claimed = Some (`Some claimed)","counters":[]},{"line":"                    ; tried_and_failed = Key.Hash_set.create ()","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"                    }","counters":[]},{"line":"                | Some k ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    let claimed =","counters":[]},{"line":"                      match k.claimed with","counters":[]},{"line":"                      | None ->","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          `Some claimed","counters":[]},{"line":"                      | Some (`Some claimed') ->","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          `Some","counters":[]},{"line":"                            (List.dedup_and_sort ~compare:Key.compare","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"                               (claimed' @ claimed) )","counters":[]},{"line":"                      | Some `All ->","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          `All","counters":[]},{"line":"                      | Some (`Call f) ->","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          let s = Key.Hash_set.of_list claimed in","counters":[]},{"line":"                          `Call (fun key -> f key || Hash_set.mem s key)","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"                    in","counters":[]},{"line":"                    { k with claimed = Some claimed } )","counters":[]},{"line":"          | Knowledge_request_starting peer ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Hash_set.add t.knowledge_requesting_peers peer","counters":[]},{"line":"          | Knowledge { peer; claimed; active_jobs; out_of_band } ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              if not out_of_band then","counters":[]},{"line":"                Hash_set.remove t.knowledge_requesting_peers peer ;","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"              let tried_and_failed =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                let s =","counters":[]},{"line":"                  match Hashtbl.find t.knowledge peer with","counters":[]},{"line":"                  | None ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      Key.Hash_set.create ()","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"                  | Some { tried_and_failed; _ } ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      tried_and_failed","counters":[]},{"line":"                in","counters":[]},{"line":"                List.iter active_jobs ~f:(fun j ->","counters":[]},{"line":"                    match Map.find j.J.attempts peer with","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                    | None ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        ()","counters":[]},{"line":"                    | Some a ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        if not (Attempt.worth_retrying a) then","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"                          Hash_set.add s j.key ) ;","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                s","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"              in","counters":[]},{"line":"              Hashtbl.set t.knowledge ~key:peer","counters":[]},{"line":"                ~data:{ Knowledge.claimed = Some claimed; tried_and_failed }","counters":[]},{"line":"          | Job_cancelled h ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              jobs_no_longer_needed t [ h ] ;","counters":[]},{"line":"              Hashtbl.iter t.knowledge ~f:(fun s ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                  Hash_set.remove s.tried_and_failed h )","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"          | Download_starting peer ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Hash_set.add t.downloading_peers peer","counters":[]},{"line":"          | Download_finished (peer0, `Successful succs, `Unsuccessful unsuccs)","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            -> (","counters":[]},{"line":"              (let cancel =","counters":[]},{"line":"                 Option.iter ~f:(fun e -> Clock.Event.abort_if_possible e ())","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"               in","counters":[]},{"line":"               if List.is_empty succs then","counters":[]},{"line":"                 Hashtbl.update t.temporary_ignores peer0 ~f:(fun x ->","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"                     cancel x ;","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                     Clock.Event.run_after ignore_period","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                       (fun () ->","counters":[]},{"line":"                         Hashtbl.remove t.temporary_ignores peer0 ;","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                         if not (Strict_pipe.Writer.is_closed t.w) then","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"                           Strict_pipe.Writer.write t.w () )","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                       () )","counters":[]},{"line":"               else (","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                 Hashtbl.find_and_remove t.temporary_ignores peer0 |> cancel ;","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"                 Preferred_heap.add t.all_preferred (peer0, Time.now ()) ) ) ;","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"              Hash_set.remove t.downloading_peers peer0 ;","counters":[]},{"line":"              jobs_no_longer_needed t succs ;","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              match Hashtbl.find t.knowledge peer0 with","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              | None ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  ()","counters":[]},{"line":"              | Some { tried_and_failed; claimed = _ } ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  List.iter unsuccs ~f:(Hash_set.add tried_and_failed) )","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"          | Refreshed_peers { all_peers } ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Hashtbl.filter_keys_inplace t.knowledge ~f:(Set.mem all_peers) ;","counters":[{"col_start":64,"col_end":64,"count":0}]},{"line":"              Set.iter all_peers ~f:(fun p ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                  if not (Hashtbl.mem t.knowledge p) then","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"                    Hashtbl.add_exn t.knowledge ~key:p","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      ~data:","counters":[]},{"line":"                        { Knowledge.claimed = None","counters":[]},{"line":"                        ; tried_and_failed = Key.Hash_set.create ()","counters":[{"col_start":63,"col_end":63,"count":0}]},{"line":"                        } ) )","counters":[]},{"line":"","counters":[]},{"line":"    let update t u : unit =","counters":[]},{"line":"      update t u ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      if not (Strict_pipe.Writer.is_closed t.w) then","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"        Strict_pipe.Writer.write t.w ()","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  type t =","counters":[]},{"line":"    { mutable next_flush : (unit, unit) Clock.Event.t option","counters":[]},{"line":"    ; mutable all_peers : Peer.Set.t","counters":[]},{"line":"    ; pending : Job.t Q.t","counters":[]},{"line":"    ; downloading : (Peer.t * Job.t * Time.t) Key.Table.t","counters":[]},{"line":"    ; useful_peers : Useful_peers.t","counters":[]},{"line":"    ; flush_r : unit Strict_pipe.Reader.t (* Single reader *)","counters":[]},{"line":"    ; flush_w :","counters":[]},{"line":"        ( unit","counters":[]},{"line":"        , Strict_pipe.drop_head Strict_pipe.buffered","counters":[]},{"line":"        , unit )","counters":[]},{"line":"        Strict_pipe.Writer.t","counters":[]},{"line":"          (* buffer of length 0 *)","counters":[]},{"line":"    ; jobs_added_bvar : (unit, read_write) Bvar.t","counters":[]},{"line":"    ; get : Peer.t -> Key.t list -> Result.t list Deferred.Or_error.t","counters":[]},{"line":"    ; max_batch_size : int","counters":[]},{"line":"          (* A peer is useful if there is a job in the pending queue which has not","counters":[]},{"line":"             been attempted with that peer. *)","counters":[]},{"line":"    ; got_new_peers_w :","counters":[]},{"line":"        ( unit","counters":[]},{"line":"        , Strict_pipe.drop_head Strict_pipe.buffered","counters":[]},{"line":"        , unit )","counters":[]},{"line":"        Strict_pipe.Writer.t","counters":[]},{"line":"          (* buffer of length 0 *)","counters":[]},{"line":"    ; got_new_peers_r : unit Strict_pipe.Reader.t","counters":[]},{"line":"    ; logger : Logger.t","counters":[]},{"line":"    ; trust_system : Trust_system.t","counters":[]},{"line":"    ; stop : unit Deferred.t","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let jobs_added t = Bvar.broadcast t.jobs_added_bvar ()","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"","counters":[]},{"line":"  let total_jobs (t : t) = Q.length t.pending + Hashtbl.length t.downloading","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"","counters":[]},{"line":"  (* Checks disjointness *)","counters":[]},{"line":"  let check_invariant (t : t) =","counters":[]},{"line":"    Set.length","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":13,"col_end":13,"count":0}]},{"line":"      (Key.Set.union_list","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"         [ Q.to_list t.pending","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"           |> List.map ~f:(fun j -> j.key)","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"           |> Key.Set.of_list","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"         ; Key.Set.of_hashtbl_keys t.downloading","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"         ] )","counters":[]},{"line":"    |> [%test_eq: int] (total_jobs t)","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"","counters":[]},{"line":"  let check_invariant_r = ref check_invariant","counters":[]},{"line":"","counters":[]},{"line":"  let set_check_invariant f = check_invariant_r := f","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"","counters":[]},{"line":"  let job_finished t j x =","counters":[]},{"line":"    Hashtbl.remove t.downloading j.J.key ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Ivar.fill_if_empty j.res x ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    try !check_invariant_r t","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"    with e ->","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"      [%log' debug t.logger]","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"        ~metadata:[ (\"exn\", `String (Exn.to_string e)) ]","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"        \"job_finished $exn\"","counters":[]},{"line":"","counters":[]},{"line":"  let kill_job _t j = Ivar.fill_if_empty j.J.res (Error `Finished)","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"  let flush_soon t =","counters":[]},{"line":"    Option.iter t.next_flush ~f:(fun e -> Clock.Event.abort_if_possible e ()) ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"    t.next_flush <-","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Some","counters":[]},{"line":"        (Clock.Event.run_after max_wait","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"           (* <-- TODO: pretty sure this is a bug (this can infinitely delay flushes *)","counters":[]},{"line":"             (fun () ->","counters":[]},{"line":"             if not (Strict_pipe.Writer.is_closed t.flush_w) then","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"               Strict_pipe.Writer.write t.flush_w () )","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"           () )","counters":[]},{"line":"","counters":[]},{"line":"  let cancel t h =","counters":[]},{"line":"    let job =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      List.find_map ~f:Lazy.force","counters":[]},{"line":"        [ lazy (Q.lookup t.pending h)","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"        ; lazy","counters":[]},{"line":"            (Option.map ~f:(fun (_, j, _) -> j) (Hashtbl.find t.downloading h))","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"        ]","counters":[]},{"line":"    in","counters":[]},{"line":"    Q.remove t.pending h ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Hashtbl.remove t.downloading h ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    match job with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ()","counters":[]},{"line":"    | Some j ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        kill_job t j ;","counters":[]},{"line":"        Useful_peers.update t.useful_peers (Job_cancelled h)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"  let enqueue t e =","counters":[]},{"line":"    match Q.enqueue t.pending e with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | `Ok ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        jobs_added t ; `Ok","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"    | `Key_already_present ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        `Key_already_present","counters":[]},{"line":"","counters":[]},{"line":"  let enqueue_exn t e =","counters":[]},{"line":"    assert ([%equal: [ `Ok | `Key_already_present ]] (enqueue t e) `Ok)","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"","counters":[]},{"line":"  let active_jobs t =","counters":[]},{"line":"    Q.to_list t.pending","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":12,"col_end":12,"count":0}]},{"line":"    @ List.map (Hashtbl.data t.downloading) ~f:(fun (_, j, _) -> j)","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"","counters":[]},{"line":"  let refresh_peers t peers =","counters":[]},{"line":"    Broadcast_pipe.Reader.iter peers ~f:(fun peers ->","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"        O1trace.sync_thread \"refresh_downloader_peers\" (fun () ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            let peers' = Peer.Set.of_list peers in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let new_peers = Set.diff peers' t.all_peers in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            Useful_peers.update t.useful_peers","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (Refreshed_peers { all_peers = peers' }) ;","counters":[]},{"line":"            if","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (not (Set.is_empty new_peers))","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"              && not (Strict_pipe.Writer.is_closed t.got_new_peers_w)","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"            then Strict_pipe.Writer.write t.got_new_peers_w () ;","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"            t.all_peers <- Peer.Set.of_list peers ) ;","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"        Deferred.unit )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    |> don't_wait_for","counters":[]},{"line":"","counters":[]},{"line":"  let tear_down","counters":[]},{"line":"      ( { next_flush","counters":[]},{"line":"        ; all_peers = _","counters":[]},{"line":"        ; flush_w","counters":[]},{"line":"        ; get = _","counters":[]},{"line":"        ; got_new_peers_w","counters":[]},{"line":"        ; flush_r = _","counters":[]},{"line":"        ; jobs_added_bvar = _","counters":[]},{"line":"        ; useful_peers","counters":[]},{"line":"        ; got_new_peers_r = _","counters":[]},{"line":"        ; pending","counters":[]},{"line":"        ; downloading","counters":[]},{"line":"        ; max_batch_size = _","counters":[]},{"line":"        ; logger = _","counters":[]},{"line":"        ; trust_system = _","counters":[]},{"line":"        ; stop = _","counters":[]},{"line":"        } as t ) =","counters":[]},{"line":"    let rec clear_queue q =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      match Q.dequeue q with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ()","counters":[]},{"line":"      | Some j ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          kill_job t j ; clear_queue q","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"    in","counters":[]},{"line":"    Option.iter next_flush ~f:(fun e -> Clock.Event.abort_if_possible e ()) ;","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"    Strict_pipe.Writer.close flush_w ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Useful_peers.tear_down useful_peers ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Strict_pipe.Writer.close got_new_peers_w ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Hashtbl.iter downloading ~f:(fun (_, j, _) -> kill_job t j) ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"    Hashtbl.clear downloading ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    clear_queue pending","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let download t peer xs =","counters":[]},{"line":"    O1trace.thread \"download\" (fun () ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        let f xs =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let n = List.length xs in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          `Assoc","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ( (\"length\", `Int n)","counters":[]},{"line":"            ::","counters":[]},{"line":"            ( if n > 8 then []","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"            else","counters":[]},{"line":"              [ (\"elts\", `List (List.map xs ~f:(fun j -> Key.to_yojson j.J.key)))","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"              ] ) )","counters":[]},{"line":"        in","counters":[]},{"line":"        let keys = List.map xs ~f:(fun x -> x.J.key) in","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"        let fail (e : Error.t) =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let e = Error.to_string_hum e in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          [%log' debug t.logger]","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"            \"Downloading from $peer failed ($error) on $keys\"","counters":[]},{"line":"            ~metadata:","counters":[]},{"line":"              [ (\"peer\", Peer.to_yojson peer)","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"              ; (\"error\", `String e)","counters":[]},{"line":"              ; (\"keys\", f xs)","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"              ] ;","counters":[]},{"line":"          List.iter xs ~f:(fun x ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              enqueue_exn t","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                { x with","counters":[]},{"line":"                  attempts = Map.set x.attempts ~key:peer ~data:Attempt.download","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                } ) ;","counters":[]},{"line":"          flush_soon t","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        in","counters":[]},{"line":"        List.iter xs ~f:(fun x ->","counters":[]},{"line":"            Hashtbl.set t.downloading ~key:x.key ~data:(peer, x, Time.now ()) ) ;","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":72,"col_end":72,"count":0}]},{"line":"        jobs_added t ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Useful_peers.update t.useful_peers (Download_starting peer) ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let download_deferred = t.get peer keys in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        upon download_deferred (fun res ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            let succs, unsuccs =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              match res with","counters":[]},{"line":"              | Error _ ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  ([], keys)","counters":[]},{"line":"              | Ok rs ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  let all = Key.Hash_set.of_list keys in","counters":[]},{"line":"                  let succ =","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    List.filter_map rs ~f:(fun r ->","counters":[]},{"line":"                        let k = Result.key r in","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                        if Hash_set.mem all k then Some k else None )","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":51,"col_end":51,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"                  in","counters":[]},{"line":"                  List.iter succ ~f:(Hash_set.remove all) ;","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"                  (succ, Hash_set.to_list all)","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"            in","counters":[]},{"line":"            Useful_peers.update t.useful_peers","counters":[]},{"line":"              (Download_finished (peer, `Successful succs, `Unsuccessful unsuccs)","counters":[]},{"line":"              ) ) ;","counters":[]},{"line":"        let%map res =","counters":[]},{"line":"          Deferred.choose","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"            [ Deferred.choice download_deferred (fun x -> `Not_stopped x)","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"            ; Deferred.choice t.stop (fun () -> `Stopped)","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"            ; Deferred.choice","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                (* This happens if all the jobs are cancelled. *)","counters":[]},{"line":"                (Deferred.List.map xs ~f:(fun x -> Ivar.read x.res))","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"                (fun _ -> `Stopped)","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"            ]","counters":[]},{"line":"        in","counters":[]},{"line":"        List.iter xs ~f:(fun j -> Hashtbl.remove t.downloading j.key) ;","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"        match res with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | `Stopped ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            List.iter xs ~f:(kill_job t)","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"        | `Not_stopped r -> (","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            match r with","counters":[]},{"line":"            | Error e ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                fail e","counters":[]},{"line":"            | Ok rs ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                [%log' debug t.logger] \"result is $result\"","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                  ~metadata:","counters":[]},{"line":"                    [ (\"result\", f xs)","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"                    ; (\"peer\", `String (Peer.to_multiaddr_string peer))","counters":[{"col_start":63,"col_end":63,"count":0}]},{"line":"                    ] ;","counters":[]},{"line":"                let received_at = Time.now () in","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                let jobs =","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Key.Table.of_alist_exn (List.map xs ~f:(fun x -> (x.key, x)))","counters":[{"col_start":49,"col_end":49,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"                in","counters":[]},{"line":"                List.iter rs ~f:(fun r ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                    match Hashtbl.find jobs (Result.key r) with","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"                    | None ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        (* Got something we didn't ask for. *)","counters":[]},{"line":"                        Trust_system.(","counters":[]},{"line":"                          record t.trust_system t.logger peer","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                            Actions.(Violated_protocol, None))","counters":[]},{"line":"                        |> don't_wait_for","counters":[]},{"line":"                    | Some j ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        Hashtbl.remove jobs j.key ;","counters":[]},{"line":"                        job_finished t j","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          (Ok","counters":[]},{"line":"                             ( { Envelope.Incoming.data = r","counters":[]},{"line":"                               ; received_at","counters":[]},{"line":"                               ; sender = Remote peer","counters":[]},{"line":"                               }","counters":[]},{"line":"                             , j.attempts ) ) ) ;","counters":[]},{"line":"                (* Anything left in jobs, we did not get results for :( *)","counters":[]},{"line":"                Hashtbl.iter jobs ~f:(fun x ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                    Hashtbl.remove t.downloading x.J.key ;","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                    enqueue_exn t","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      { x with","counters":[]},{"line":"                        attempts =","counters":[]},{"line":"                          Map.set x.attempts ~key:peer ~data:Attempt.download","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                      } ) ;","counters":[]},{"line":"                flush_soon t ) )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"","counters":[]},{"line":"  let to_yojson t : Yojson.Safe.t =","counters":[]},{"line":"    check_invariant t ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let list xs =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      `Assoc [ (\"length\", `Int (List.length xs)); (\"elts\", `List xs) ]","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"    in","counters":[]},{"line":"    let now = Time.now () in","counters":[]},{"line":"    let f q = list (List.map ~f:Job.to_yojson (Q.to_list q)) in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":14,"col_end":14,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"    `Assoc","counters":[]},{"line":"      [ (\"total_jobs\", `Int (total_jobs t))","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"      ; (\"useful_peers\", Useful_peers.to_yojson t.useful_peers)","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"      ; (\"pending\", f t.pending)","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"      ; ( \"downloading\"","counters":[]},{"line":"        , list","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"            (List.map (Hashtbl.to_alist t.downloading)","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"               ~f:(fun (h, (p, _, start)) ->","counters":[]},{"line":"                 `Assoc","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                   [ (\"hash\", Key.to_yojson h)","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"                   ; (\"start\", `String (Time.to_string start))","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"                   ; ( \"time_since_start\"","counters":[]},{"line":"                     , `String (Time.Span.to_string_hum (Time.diff now start))","counters":[{"col_start":54,"col_end":54,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"                     )","counters":[]},{"line":"                   ; (\"peer\", `String (Peer.to_multiaddr_string p))","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"                   ] ) ) )","counters":[]},{"line":"      ]","counters":[]},{"line":"","counters":[]},{"line":"  let post_stall_retry_delay = Time.Span.of_min 1.","counters":[{"col_start":46,"col_end":46,"count":2}]},{"line":"","counters":[]},{"line":"  let rec step t =","counters":[]},{"line":"    if Q.length t.pending = 0 then (","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":14,"col_end":14,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"      [%log' debug t.logger] \"Downloader: no jobs. waiting\" ;","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"      match%bind Strict_pipe.Reader.read t.flush_r with","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"      | `Eof ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          [%log' debug t.logger] \"Downloader: flush eof\" ;","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"          Deferred.unit","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"      | `Ok () ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          step t )","counters":[]},{"line":"    else","counters":[]},{"line":"      match","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Useful_peers.useful_peer t.useful_peers","counters":[]},{"line":"          ~pending_jobs:(Q.to_list t.pending)","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"      with","counters":[]},{"line":"      | `No_peers -> (","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          match%bind Strict_pipe.Reader.read t.got_new_peers_r with","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"          | `Eof ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              [%log' debug t.logger] \"Downloader: new peers eof\" ;","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"              Deferred.unit","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"          | `Ok () ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              step t )","counters":[]},{"line":"      | `Useful_but_busy -> (","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          [%log' debug t.logger] \"Downloader: Waiting. All useful peers busy\" ;","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"          let read p =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Pipe.read_choice_single_consumer_exn","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (Strict_pipe.Reader.to_linear_pipe p).pipe [%here]","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"          in","counters":[]},{"line":"          match%bind","counters":[]},{"line":"            Deferred.choose [ read t.flush_r; read t.useful_peers.r ]","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"          with","counters":[]},{"line":"          | `Eof ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              [%log' debug t.logger] \"Downloader: flush eof\" ;","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"              Deferred.unit","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"          | `Ok () ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (* Try again, something might have changed *)","counters":[]},{"line":"              step t )","counters":[]},{"line":"      | `Stalled ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          [%log' debug t.logger]","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"            \"Downloader: all stalled. Resetting knowledge, waiting %s and then \\","counters":[]},{"line":"             retrying.\"","counters":[]},{"line":"            (Time.Span.to_string_hum post_stall_retry_delay) ;","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"          Useful_peers.reset_knowledge t.useful_peers ~all_peers:t.all_peers ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let%bind () = after post_stall_retry_delay in","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"          [%log' debug t.logger] \"Downloader: continuing after reset\" ;","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"          step t","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"      | `Useful (peer, might_know) -> (","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let to_download = List.take might_know t.max_batch_size in","counters":[]},{"line":"          [%log' debug t.logger] \"Downloader: downloading $n from $peer\"","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"            ~metadata:","counters":[]},{"line":"              [ (\"n\", `Int (List.length to_download))","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"              ; (\"peer\", Peer.to_yojson peer)","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"              ] ;","counters":[]},{"line":"          List.iter to_download ~f:(fun j -> Q.remove t.pending j.key) ;","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"          match to_download with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | [] ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              step t","counters":[]},{"line":"          | _ :: _ ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              don't_wait_for (download t peer to_download) ;","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"              step t )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"","counters":[]},{"line":"  let add_knowledge t peer claimed =","counters":[]},{"line":"    Useful_peers.update t.useful_peers","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (Add_knowledge { peer; claimed; out_of_band = true })","counters":[]},{"line":"","counters":[]},{"line":"  let update_knowledge t peer claimed =","counters":[]},{"line":"    Useful_peers.update t.useful_peers","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (Knowledge","counters":[]},{"line":"         { peer; claimed; active_jobs = active_jobs t; out_of_band = true } )","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"","counters":[]},{"line":"  let mark_preferred t peer ~now =","counters":[]},{"line":"    Useful_peers.Preferred_heap.add t.useful_peers.all_preferred (peer, now)","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let create ~max_batch_size ~stop ~trust_system ~get ~knowledge_context","counters":[]},{"line":"      ~knowledge ~peers ~preferred =","counters":[]},{"line":"    let%map all_peers = peers () in","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"    let pipe ~name c =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Strict_pipe.create ~warn_on_drop:false ~name","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (Buffered (`Capacity c, `Overflow (Drop_head ignore)))","counters":[]},{"line":"    in","counters":[]},{"line":"    let flush_r, flush_w = pipe ~name:\"flush\" 0 in","counters":[]},{"line":"    let got_new_peers_r, got_new_peers_w = pipe ~name:\"got_new_peers\" 0 in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let t =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      { all_peers = Peer.Set.of_list all_peers","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"      ; pending = Q.create ()","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"      ; next_flush = None","counters":[]},{"line":"      ; flush_r","counters":[]},{"line":"      ; flush_w","counters":[]},{"line":"      ; jobs_added_bvar = Bvar.create ()","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"      ; got_new_peers_r","counters":[]},{"line":"      ; got_new_peers_w","counters":[]},{"line":"      ; useful_peers = Useful_peers.create ~all_peers ~preferred","counters":[]},{"line":"      ; get","counters":[]},{"line":"      ; max_batch_size","counters":[]},{"line":"      ; logger = Logger.create ()","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"      ; trust_system","counters":[]},{"line":"      ; downloading = Key.Table.create ()","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"      ; stop","counters":[]},{"line":"      }","counters":[]},{"line":"    in","counters":[]},{"line":"    let peers =","counters":[]},{"line":"      let r, w = Broadcast_pipe.create [] in","counters":[]},{"line":"      upon stop (fun () -> Broadcast_pipe.Writer.close w) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"      Clock.every' ~stop (Time.Span.of_min 1.) (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"          peers ()","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":14,"col_end":14,"count":0}]},{"line":"          >>= fun ps ->","counters":[]},{"line":"          try Broadcast_pipe.Writer.write w ps","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"          with Broadcast_pipe.Already_closed _ -> Deferred.unit ) ;","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"      r","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    in","counters":[]},{"line":"    let rec jobs_to_download stop =","counters":[]},{"line":"      O1trace.thread \"wait_for_jobs_to_download\" (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          if total_jobs t <> 0 then return `Ok","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"          else","counters":[]},{"line":"            match%bind","counters":[]},{"line":"              Deferred.choose","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                [ choice stop (Fn.const `Eof)","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"                ; choice (Bvar.wait t.jobs_added_bvar) (Fn.const `Ok)","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"                ]","counters":[]},{"line":"            with","counters":[]},{"line":"            | `Eof ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                return `Finished","counters":[]},{"line":"            | `Ok ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                jobs_to_download stop )","counters":[]},{"line":"    in","counters":[]},{"line":"    let request_r, request_w =","counters":[]},{"line":"      Strict_pipe.create ~name:\"knowledge-requests\" Strict_pipe.Synchronous","counters":[]},{"line":"    in","counters":[]},{"line":"    upon stop (fun () -> Strict_pipe.Writer.close request_w) ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"    let refresh_knowledge stop peer =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Clock.every' (Time.Span.of_min 7.) ~stop (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"          match%bind jobs_to_download stop with","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"          | `Finished ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Deferred.unit","counters":[]},{"line":"          | `Ok ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              if not (Strict_pipe.Writer.is_closed request_w) then","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"                Strict_pipe.Writer.write request_w peer","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"              else Deferred.unit )","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"    in","counters":[]},{"line":"    let ps : unit Ivar.t Peer.Table.t = Peer.Table.create () in","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"    Broadcast_pipe.Reader.iter peers ~f:(fun peers ->","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"        O1trace.sync_thread \"maintain_downloader_peers\" (fun () ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            let peers = Peer.Hash_set.of_list peers in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            Hashtbl.filteri_inplace ps ~f:(fun ~key:p ~data:finished ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"                let keep = Hash_set.mem peers p in","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                if not keep then Ivar.fill_if_empty finished () ;","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"                keep ) ;","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"            Hash_set.iter peers ~f:(fun p ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"                if not (Hashtbl.mem ps p) then (","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"                  let finished = Ivar.create () in","counters":[]},{"line":"                  refresh_knowledge (Ivar.read finished) p ;","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"                  Hashtbl.add_exn ps ~key:p ~data:finished ) ) ) ;","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"        Deferred.unit )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    |> don't_wait_for ;","counters":[]},{"line":"    let throttle =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Throttle.create ~continue_on_error:true ~max_concurrent_jobs:8","counters":[]},{"line":"    in","counters":[]},{"line":"    let get_knowledge ctx peer =","counters":[]},{"line":"      Throttle.enqueue throttle (fun () -> knowledge ctx peer)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"    in","counters":[]},{"line":"    O1trace.background_thread \"refresh_downloader_knowledge\" (fun () ->","counters":[]},{"line":"        Broadcast_pipe.Reader.iter knowledge_context ~f:(fun _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            O1trace.sync_thread \"refresh_downloader_knowledge\" (fun () ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"                Hashtbl.mapi_inplace ps ~f:(fun ~key:p ~data:finished ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                    Ivar.fill_if_empty finished () ;","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                    let finished = Ivar.create () in","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                    refresh_knowledge (Ivar.read finished) p ;","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"                    finished ) ) ;","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"            Deferred.unit ) ) ;","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"    O1trace.background_thread \"dispatch_downloader_requests\" (fun () ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        Strict_pipe.Reader.iter request_r ~f:(fun peer ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            (* TODO: The pipe/clock logic is not quite right, but it is good enough. *)","counters":[]},{"line":"            if Deferred.is_determined stop then Deferred.unit","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"            else","counters":[]},{"line":"              let%map () = Throttle.capacity_available throttle in","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"              don't_wait_for","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (let ctx = Broadcast_pipe.Reader.peek knowledge_context in","counters":[]},{"line":"                 (* TODO: Check if already downloading a job from them here. *)","counters":[]},{"line":"                 Useful_peers.update t.useful_peers","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                   (Knowledge_request_starting peer) ;","counters":[]},{"line":"                 let%map k = get_knowledge ctx peer in","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"                 Useful_peers.update t.useful_peers","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                   (Knowledge","counters":[]},{"line":"                      { out_of_band = false","counters":[]},{"line":"                      ; peer","counters":[]},{"line":"                      ; claimed = k","counters":[]},{"line":"                      ; active_jobs = active_jobs t","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"                      } ) ) ) ) ;","counters":[]},{"line":"    O1trace.background_thread \"execute_downlader_node_fstm\" (fun () -> step t) ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"    upon stop (fun () -> tear_down t) ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"    every ~stop (Time.Span.of_sec 30.) (fun () ->","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"        [%log' debug t.logger]","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"          ~metadata:[ (\"jobs\", to_yojson t) ]","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"          \"Downloader jobs\" ) ;","counters":[]},{"line":"    refresh_peers t peers ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    t","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  (* After calling download, if no one else has called within time [max_wait],","counters":[]},{"line":"       we flush our queue. *)","counters":[]},{"line":"  let download t ~key ~attempts : Job.t =","counters":[]},{"line":"    match (Q.lookup t.pending key, Hashtbl.find t.downloading key) with","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"    | Some _, Some _ ->","counters":[]},{"line":"        assert false","counters":[]},{"line":"    | Some x, None | None, Some (_, x, _) ->","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"        x","counters":[]},{"line":"    | None, None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        flush_soon t ;","counters":[]},{"line":"        let e = { J.key; attempts; res = Ivar.create () } in","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"        enqueue_exn t e ; e","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}