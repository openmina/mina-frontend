{"filename":"src/lib/pickles/inductive_rule.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Pickles_types.Poly_types","counters":[]},{"line":"open Pickles_types.Hlist","counters":[]},{"line":"","counters":[]},{"line":"module B = struct","counters":[]},{"line":"  type t = Impls.Step.Boolean.var","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Previous_proof_statement = struct","counters":[]},{"line":"  type ('prev_var, 'width) t =","counters":[]},{"line":"    { public_input : 'prev_var","counters":[]},{"line":"    ; proof : ('width, 'width) Proof.t Impls.Step.As_prover.Ref.t","counters":[]},{"line":"    ; proof_must_verify : B.t","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  module Constant = struct","counters":[]},{"line":"    type ('prev_value, 'width) t =","counters":[]},{"line":"      { public_input : 'prev_value","counters":[]},{"line":"      ; proof : ('width, 'width) Proof.t","counters":[]},{"line":"      ; proof_must_verify : bool","counters":[]},{"line":"      }","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(** This type relates the types of the input and output types of an inductive","counters":[]},{"line":"    rule's [main] function to the type of the public input to the resulting","counters":[]},{"line":"    circuit.","counters":[]},{"line":"*)","counters":[]},{"line":"type ('var, 'value, 'input_var, 'input_value, 'ret_var, 'ret_value) public_input =","counters":[]},{"line":"  | Input :","counters":[]},{"line":"      ('var, 'value) Impls.Step.Typ.t","counters":[]},{"line":"      -> ('var, 'value, 'var, 'value, unit, unit) public_input","counters":[]},{"line":"  | Output :","counters":[]},{"line":"      ('ret_var, 'ret_value) Impls.Step.Typ.t","counters":[]},{"line":"      -> ('ret_var, 'ret_value, unit, unit, 'ret_var, 'ret_value) public_input","counters":[]},{"line":"  | Input_and_output :","counters":[]},{"line":"      ('var, 'value) Impls.Step.Typ.t * ('ret_var, 'ret_value) Impls.Step.Typ.t","counters":[]},{"line":"      -> ( 'var * 'ret_var","counters":[]},{"line":"         , 'value * 'ret_value","counters":[]},{"line":"         , 'var","counters":[]},{"line":"         , 'value","counters":[]},{"line":"         , 'ret_var","counters":[]},{"line":"         , 'ret_value )","counters":[]},{"line":"         public_input","counters":[]},{"line":"","counters":[]},{"line":"(** The input type of an inductive rule's main function. *)","counters":[]},{"line":"type 'public_input main_input =","counters":[]},{"line":"  { public_input : 'public_input","counters":[]},{"line":"        (** The publicly-exposed input to the circuit's main function. *)","counters":[]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"(** The return type of an inductive rule's main function. *)","counters":[]},{"line":"type ('prev_vars, 'widths, 'public_output, 'auxiliary_output) main_return =","counters":[]},{"line":"  { previous_proof_statements :","counters":[]},{"line":"      ('prev_vars, 'widths) H2.T(Previous_proof_statement).t","counters":[]},{"line":"        (** A list of booleans, determining whether each previous proof must","counters":[]},{"line":"            verify.","counters":[]},{"line":"        *)","counters":[]},{"line":"  ; public_output : 'public_output","counters":[]},{"line":"        (** The publicly-exposed output from the circuit's main function. *)","counters":[]},{"line":"  ; auxiliary_output : 'auxiliary_output","counters":[]},{"line":"        (** The auxiliary output from the circuit's main function. This value","counters":[]},{"line":"            is returned to the prover, but not exposed to or used by verifiers.","counters":[]},{"line":"        *)","counters":[]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"(** This type models an \"inductive rule\". It includes","counters":[]},{"line":"    - the list of previous statements which this one assumes","counters":[]},{"line":"    - the snarky main function","counters":[]},{"line":"","counters":[]},{"line":"    The types parameters are:","counters":[]},{"line":"    - ['prev_vars] the tuple-list of public input circuit types to the previous","counters":[]},{"line":"      proofs.","counters":[]},{"line":"      - For example, [Boolean.var * (Boolean.var * unit)] represents 2 previous","counters":[]},{"line":"        proofs whose public inputs are booleans","counters":[]},{"line":"    - ['prev_values] the tuple-list of public input non-circuit types to the","counters":[]},{"line":"      previous proofs.","counters":[]},{"line":"      - For example, [bool * (bool * unit)] represents 2 previous proofs whose","counters":[]},{"line":"        public inputs are booleans.","counters":[]},{"line":"    - ['widths] is a tuple list of the maximum number of previous proofs each","counters":[]},{"line":"      previous proof itself had.","counters":[]},{"line":"      - For example, [Nat.z Nat.s * (Nat.z * unit)] represents 2 previous","counters":[]},{"line":"        proofs where the first has at most 1 previous proof and the second had","counters":[]},{"line":"        zero previous proofs.","counters":[]},{"line":"    - ['heights] is a tuple list of the number of inductive rules in each of","counters":[]},{"line":"      the previous proofs","counters":[]},{"line":"      - For example, [Nat.z Nat.s Nat.s * (Nat.z Nat.s * unit)] represents 2","counters":[]},{"line":"        previous proofs where the first had 2 inductive rules and the second","counters":[]},{"line":"        had 1.","counters":[]},{"line":"    - ['a_var] is the in-circuit type of the [main] function's public input.","counters":[]},{"line":"    - ['a_value] is the out-of-circuit type of the [main] function's public","counters":[]},{"line":"      input.","counters":[]},{"line":"    - ['ret_var] is the in-circuit type of the [main] function's public output.","counters":[]},{"line":"    - ['ret_value] is the out-of-circuit type of the [main] function's public","counters":[]},{"line":"      output.","counters":[]},{"line":"    - ['auxiliary_var] is the in-circuit type of the [main] function's","counters":[]},{"line":"      auxiliary data, to be returned to the prover but not exposed in the","counters":[]},{"line":"      public input.","counters":[]},{"line":"    - ['auxiliary_value] is the out-of-circuit type of the [main] function's","counters":[]},{"line":"      auxiliary data, to be returned to the prover but not exposed in the","counters":[]},{"line":"      public input.","counters":[]},{"line":"*)","counters":[]},{"line":"type ( 'prev_vars","counters":[]},{"line":"     , 'prev_values","counters":[]},{"line":"     , 'widths","counters":[]},{"line":"     , 'heights","counters":[]},{"line":"     , 'a_var","counters":[]},{"line":"     , 'a_value","counters":[]},{"line":"     , 'ret_var","counters":[]},{"line":"     , 'ret_value","counters":[]},{"line":"     , 'auxiliary_var","counters":[]},{"line":"     , 'auxiliary_value )","counters":[]},{"line":"     t =","counters":[]},{"line":"  { identifier : string","counters":[]},{"line":"  ; prevs : ('prev_vars, 'prev_values, 'widths, 'heights) H4.T(Tag).t","counters":[]},{"line":"  ; main :","counters":[]},{"line":"         'a_var main_input","counters":[]},{"line":"      -> ('prev_vars, 'widths, 'ret_var, 'auxiliary_var) main_return","counters":[]},{"line":"  ; uses_lookup : bool","counters":[]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"module T","counters":[]},{"line":"    (Statement : T0)","counters":[]},{"line":"    (Statement_value : T0)","counters":[]},{"line":"    (Return_var : T0)","counters":[]},{"line":"    (Return_value : T0)","counters":[]},{"line":"    (Auxiliary_var : T0)","counters":[]},{"line":"    (Auxiliary_value : T0) =","counters":[]},{"line":"struct","counters":[]},{"line":"  type nonrec ('prev_vars, 'prev_values, 'widths, 'heights) t =","counters":[]},{"line":"    ( 'prev_vars","counters":[]},{"line":"    , 'prev_values","counters":[]},{"line":"    , 'widths","counters":[]},{"line":"    , 'heights","counters":[]},{"line":"    , Statement.t","counters":[]},{"line":"    , Statement_value.t","counters":[]},{"line":"    , Return_var.t","counters":[]},{"line":"    , Return_value.t","counters":[]},{"line":"    , Auxiliary_var.t","counters":[]},{"line":"    , Auxiliary_value.t )","counters":[]},{"line":"    t","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}