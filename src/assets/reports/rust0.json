{"filename":"src/fuzzing/generator.rs","lines":[{"line":"use crate::{","counters":[]},{"line":"    account,","counters":[]},{"line":"    scan_state::{","counters":[]},{"line":"        currency::{","counters":[]},{"line":"            Amount, Balance, BlockTime, Fee, Length, Magnitude, MinMax, Nonce, Sgn, Signed, Slot,","counters":[]},{"line":"        },","counters":[]},{"line":"        transaction_logic::{","counters":[]},{"line":"            signed_command::{self, PaymentPayload, SignedCommand, SignedCommandPayload},","counters":[]},{"line":"            transaction_union_payload::TransactionUnionPayload,","counters":[]},{"line":"            zkapp_command::{","counters":[]},{"line":"                self, AccountPreconditions, AccountUpdate, ClosedInterval, FeePayer, FeePayerBody,","counters":[]},{"line":"                Numeric, OrIgnore, SetOrKeep, Update, ZkAppCommand,","counters":[]},{"line":"            },","counters":[]},{"line":"            Memo, Transaction, UserCommand,","counters":[]},{"line":"        },","counters":[]},{"line":"    },","counters":[]},{"line":"    Account, AuthRequired, CurveAffine, Permissions, PlonkVerificationKeyEvals, ProofVerified,","counters":[]},{"line":"    TokenId, TokenSymbol, VotingFor, ZkAppUri,","counters":[]},{"line":"};","counters":[]},{"line":"use ark_ec::{AffineCurve, ProjectiveCurve};","counters":[]},{"line":"use ark_ff::{Field, SquareRootField, UniformRand};","counters":[]},{"line":"use mina_curves::pasta::Fq;","counters":[]},{"line":"use mina_hasher::Fp;","counters":[]},{"line":"use mina_p2p_messages::{","counters":[]},{"line":"    number::Number,","counters":[]},{"line":"    pseq::PaddedSeq,","counters":[]},{"line":"    v2::{","counters":[]},{"line":"        CompositionTypesBranchDataDomainLog2StableV1, CompositionTypesBranchDataStableV1,","counters":[]},{"line":"        CompositionTypesDigestConstantStableV1, LimbVectorConstantHex64StableV1,","counters":[]},{"line":"        PicklesBaseProofsVerifiedStableV1,","counters":[]},{"line":"        PicklesProofProofsVerified2ReprStableV2MessagesForNextStepProof,","counters":[]},{"line":"        PicklesProofProofsVerified2ReprStableV2MessagesForNextWrapProof,","counters":[]},{"line":"        PicklesProofProofsVerified2ReprStableV2PrevEvals,","counters":[]},{"line":"        PicklesProofProofsVerified2ReprStableV2PrevEvalsEvals,","counters":[]},{"line":"        PicklesProofProofsVerified2ReprStableV2PrevEvalsEvalsEvals,","counters":[]},{"line":"        PicklesProofProofsVerified2ReprStableV2PrevEvalsEvalsEvalsLookupA,","counters":[]},{"line":"        PicklesProofProofsVerified2ReprStableV2Proof,","counters":[]},{"line":"        PicklesProofProofsVerified2ReprStableV2ProofMessages,","counters":[]},{"line":"        PicklesProofProofsVerified2ReprStableV2ProofMessagesLookupA,","counters":[]},{"line":"        PicklesProofProofsVerified2ReprStableV2ProofOpenings,","counters":[]},{"line":"        PicklesProofProofsVerified2ReprStableV2ProofOpeningsProof,","counters":[]},{"line":"        PicklesProofProofsVerified2ReprStableV2Statement,","counters":[]},{"line":"        PicklesProofProofsVerified2ReprStableV2StatementFp,","counters":[]},{"line":"        PicklesProofProofsVerified2ReprStableV2StatementPlonk,","counters":[]},{"line":"        PicklesProofProofsVerified2ReprStableV2StatementProofState,","counters":[]},{"line":"        PicklesProofProofsVerified2ReprStableV2StatementProofStateDeferredValues,","counters":[]},{"line":"        PicklesProofProofsVerifiedMaxStableV2,","counters":[]},{"line":"        PicklesReducedMessagesForNextProofOverSameFieldWrapChallengesVectorStableV2,","counters":[]},{"line":"        PicklesReducedMessagesForNextProofOverSameFieldWrapChallengesVectorStableV2A,","counters":[]},{"line":"        PicklesReducedMessagesForNextProofOverSameFieldWrapChallengesVectorStableV2AChallenge,","counters":[]},{"line":"    },","counters":[]},{"line":"};","counters":[]},{"line":"use mina_signer::{","counters":[]},{"line":"    CompressedPubKey, CurvePoint, Keypair, NetworkId, ScalarField, SecKey, Signature, Signer,","counters":[]},{"line":"};","counters":[]},{"line":"use rand::distributions::DistString;","counters":[]},{"line":"use rand::Rng;","counters":[]},{"line":"use rand::{distributions::Alphanumeric, seq::SliceRandom};","counters":[]},{"line":"use std::{array, iter, ops::RangeInclusive, rc::Rc};","counters":[]},{"line":"use tuple_map::TupleMap2;","counters":[]},{"line":"","counters":[]},{"line":"use super::context::{FuzzerCtx, PermissionModel};","counters":[]},{"line":"","counters":[]},{"line":"pub trait Generator<T> {","counters":[]},{"line":"    fn gen(&mut self) -> T;","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<bool> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> bool {","counters":[{"col_start":4,"col_end":31,"count":0}]},{"line":"        self.rng.gen_bool(0.5)","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"/*","counters":[]},{"line":"impl Generator<Fp> for FuzzerCtx {","counters":[]},{"line":"    // rnd_base_field","counters":[]},{"line":"    fn gen(&mut self) -> Fp {","counters":[]},{"line":"        let mut bf = None;","counters":[]},{"line":"","counters":[]},{"line":"        // TODO: optimize by masking out MSBs from bytes and remove loop","counters":[]},{"line":"        while bf.is_none() {","counters":[]},{"line":"            let bytes = self.rng.gen::<[u8; 32]>();","counters":[]},{"line":"            bf = Fp::from_random_bytes_with_flags::<ark_serialize::EmptyFlags>(&bytes);","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        bf.unwrap().0","counters":[]},{"line":"    }","counters":[]},{"line":"}","counters":[]},{"line":"*/","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<Fp> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> Fp {","counters":[{"col_start":4,"col_end":29,"count":0}]},{"line":"        Fp::rand(&mut self.rng)","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<Slot> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> Slot {","counters":[{"col_start":4,"col_end":31,"count":0}]},{"line":"        Slot::from_u32(self.rng.gen_range(","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"            self.txn_state_view.global_slot_since_genesis.as_u32()..Slot::max().as_u32(),","counters":[{"col_start":0,"col_end":89,"count":0}]},{"line":"        ))","counters":[{"col_start":0,"col_end":10,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<SecKey> for FuzzerCtx {","counters":[]},{"line":"    /*","counters":[]},{"line":"        Reimplement random key generation w/o the restriction on CryptoRgn trait.","counters":[]},{"line":"        Since we are only using this for fuzzing we want a faster (unsafe) Rng like SmallRng.","counters":[]},{"line":"    */","counters":[]},{"line":"    fn gen(&mut self) -> SecKey {","counters":[{"col_start":4,"col_end":33,"count":0}]},{"line":"        let secret: ScalarField = ScalarField::rand(&mut self.rng);","counters":[{"col_start":0,"col_end":67,"count":0}]},{"line":"        SecKey::new(secret)","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<Keypair> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> Keypair {","counters":[{"col_start":4,"col_end":34,"count":0}]},{"line":"        let sec_key: SecKey = self.gen();","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"        let scalar = sec_key.into_scalar();","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"        let public = CurvePoint::prime_subgroup_generator()","counters":[{"col_start":0,"col_end":59,"count":0}]},{"line":"            .mul(scalar)","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"            .into_affine();","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"","counters":[]},{"line":"        let keypair = Keypair::from_parts_unsafe(scalar, public);","counters":[{"col_start":0,"col_end":65,"count":0}]},{"line":"","counters":[]},{"line":"        if !self","counters":[{"col_start":0,"col_end":16,"count":0}]},{"line":"            .state.potential_senders","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"            .iter()","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"            .any(|x| x.public == keypair.public)","counters":[{"col_start":0,"col_end":17,"count":0},{"col_start":21,"col_end":47,"count":0},{"col_start":47,"col_end":48,"count":0}]},{"line":"        {","counters":[]},{"line":"            self.state.potential_new_accounts.push(keypair.clone())","counters":[{"col_start":12,"col_end":67,"count":0}]},{"line":"        }","counters":[{"col_start":9,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"        keypair","counters":[{"col_start":8,"col_end":15,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<CompressedPubKey> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> CompressedPubKey {","counters":[{"col_start":4,"col_end":42,"count":0}]},{"line":"        let keypair = if self.rng.gen_bool(0.9) {","counters":[{"col_start":12,"col_end":19,"count":0},{"col_start":25,"col_end":47,"count":0}]},{"line":"            // use existing account","counters":[]},{"line":"            self.random_keypair()","counters":[{"col_start":12,"col_end":33,"count":0}]},{"line":"        } else {","counters":[]},{"line":"            // create new account","counters":[]},{"line":"            self.gen()","counters":[{"col_start":12,"col_end":22,"count":0}]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        keypair.public.into_compressed()","counters":[{"col_start":8,"col_end":40,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<Memo> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> Memo {","counters":[{"col_start":4,"col_end":31,"count":0}]},{"line":"        Memo::with_number(self.rng.gen())","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl<F: Field + SquareRootField + From<i32>> Generator<(F, F)> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> (F, F) {","counters":[{"col_start":4,"col_end":33,"count":0}]},{"line":"        /*","counters":[{"col_start":0,"col_end":10,"count":0}]},{"line":"            WARNING: we need to generate valid curve points to avoid binprot deserializarion","counters":[{"col_start":0,"col_end":92,"count":0}]},{"line":"            exceptions in the OCaml side. However this is an expensive task.","counters":[{"col_start":0,"col_end":76,"count":0}]},{"line":"","counters":[]},{"line":"            TODO: a more efficient way of doing this?","counters":[{"col_start":0,"col_end":53,"count":0}]},{"line":"        */","counters":[{"col_start":0,"col_end":10,"count":0}]},{"line":"        let mut x = F::rand(&mut self.rng);","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"","counters":[]},{"line":"        loop {","counters":[]},{"line":"            let y_squared = x.square().mul(x).add(Into::<F>::into(5));","counters":[{"col_start":16,"col_end":69,"count":0}]},{"line":"","counters":[]},{"line":"            if let Some(y) = y_squared.sqrt() {","counters":[{"col_start":24,"col_end":25,"count":0},{"col_start":29,"col_end":45,"count":0}]},{"line":"                return (x, y);","counters":[{"col_start":23,"col_end":29,"count":0}]},{"line":"            }","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":13,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"            x.add_assign(F::one());","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<CurveAffine<Fp>> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> CurveAffine<Fp> {","counters":[{"col_start":4,"col_end":42,"count":0}]},{"line":"        let (x, y) = self.gen();","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"        CurveAffine::<Fp>(x, y)","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<PlonkVerificationKeyEvals> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> PlonkVerificationKeyEvals {","counters":[{"col_start":4,"col_end":52,"count":186}]},{"line":"        PlonkVerificationKeyEvals {","counters":[{"col_start":0,"col_end":35,"count":186}]},{"line":"            sigma: array::from_fn(|_| self.gen()),","counters":[{"col_start":0,"col_end":34,"count":186},{"col_start":38,"col_end":48,"count":29},{"col_start":48,"col_end":50,"count":186}]},{"line":"            coefficients: array::from_fn(|_| self.gen()),","counters":[{"col_start":0,"col_end":41,"count":186},{"col_start":45,"col_end":55,"count":20},{"col_start":55,"col_end":57,"count":186}]},{"line":"            generic: self.gen(),","counters":[{"col_start":0,"col_end":32,"count":186}]},{"line":"            psm: self.gen(),","counters":[{"col_start":0,"col_end":28,"count":186}]},{"line":"            complete_add: self.gen(),","counters":[{"col_start":0,"col_end":37,"count":186}]},{"line":"            mul: self.gen(),","counters":[{"col_start":0,"col_end":28,"count":186}]},{"line":"            emul: self.gen(),","counters":[{"col_start":0,"col_end":29,"count":186}]},{"line":"            endomul_scalar: self.gen(),","counters":[{"col_start":0,"col_end":39,"count":186}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":186}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":186}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<account::VerificationKey> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> account::VerificationKey {","counters":[{"col_start":4,"col_end":51,"count":0}]},{"line":"        account::VerificationKey {","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"            max_proofs_verified: vec![ProofVerified::N0, ProofVerified::N1, ProofVerified::N2]","counters":[{"col_start":0,"col_end":94,"count":0}]},{"line":"                .choose(&mut self.rng)","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"                .unwrap()","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"                .clone(),","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"            wrap_index: self.gen(),","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"            wrap_vk: None, // TODO","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"/*","counters":[]},{"line":"impl<T: Hasher<T> + Hashable> Generator<zkapp_command::WithHash<T>> for FuzzerCtx","counters":[]},{"line":"where","counters":[]},{"line":"    FuzzerCtx: Generator<T>,","counters":[]},{"line":"{","counters":[]},{"line":"    fn gen(&mut self) -> zkapp_command::WithHash<T> {","counters":[]},{"line":"        let data: T = self.gen();","counters":[]},{"line":"        let hash = data.digest();","counters":[]},{"line":"        zkapp_command::WithHash { data, hash }","counters":[]},{"line":"    }","counters":[]},{"line":"}","counters":[]},{"line":"*/","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<zkapp_command::WithHash<account::VerificationKey>> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> zkapp_command::WithHash<account::VerificationKey> {","counters":[{"col_start":4,"col_end":76,"count":0}]},{"line":"        let data: account::VerificationKey = self.gen();","counters":[{"col_start":0,"col_end":56,"count":0}]},{"line":"        let hash = data.digest();","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"        zkapp_command::WithHash { data, hash }","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<account::AuthRequired> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> account::AuthRequired {","counters":[{"col_start":4,"col_end":48,"count":0}]},{"line":"        *vec![","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"            account::AuthRequired::None,","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"            account::AuthRequired::Either,","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"            account::AuthRequired::Proof,","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"            account::AuthRequired::Signature,","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"            account::AuthRequired::Impossible,","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"            //account::AuthRequired::Both,","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"        ]","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"        .choose(&mut self.rng)","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"        .unwrap()","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<Permissions<AuthRequired>> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> Permissions<AuthRequired> {","counters":[{"col_start":4,"col_end":52,"count":0}]},{"line":"        match self.permission_model {","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"            PermissionModel::Any => Permissions::<AuthRequired> {","counters":[{"col_start":36,"col_end":65,"count":0}]},{"line":"                edit_state: self.gen(),","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"                send: self.gen(),","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"                receive: self.gen(),","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"                set_delegate: self.gen(),","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"                set_permissions: self.gen(),","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"                set_verification_key: self.gen(),","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"                set_zkapp_uri: self.gen(),","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"                edit_sequence_state: self.gen(),","counters":[{"col_start":0,"col_end":48,"count":0}]},{"line":"                set_token_symbol: self.gen(),","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"                increment_nonce: self.gen(),","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"                set_voting_for: self.gen(),","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"            },","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"            PermissionModel::Empty => Permissions::<AuthRequired> {","counters":[{"col_start":38,"col_end":67,"count":0}]},{"line":"                edit_state: AuthRequired::None,","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"                send: AuthRequired::None,","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"                receive: AuthRequired::None,","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"                set_delegate: AuthRequired::None,","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"                set_permissions: AuthRequired::None,","counters":[{"col_start":0,"col_end":52,"count":0}]},{"line":"                set_verification_key: AuthRequired::None,","counters":[{"col_start":0,"col_end":57,"count":0}]},{"line":"                set_zkapp_uri: AuthRequired::None,","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"                edit_sequence_state: AuthRequired::None,","counters":[{"col_start":0,"col_end":56,"count":0}]},{"line":"                set_token_symbol: AuthRequired::None,","counters":[{"col_start":0,"col_end":53,"count":0}]},{"line":"                increment_nonce: AuthRequired::None,","counters":[{"col_start":0,"col_end":52,"count":0}]},{"line":"                set_voting_for: AuthRequired::None,","counters":[{"col_start":0,"col_end":51,"count":0}]},{"line":"            },","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"            PermissionModel::Initial => Permissions::<AuthRequired>::user_default(),","counters":[{"col_start":40,"col_end":83,"count":0}]},{"line":"            PermissionModel::Default => Permissions::<AuthRequired> {","counters":[{"col_start":40,"col_end":69,"count":0}]},{"line":"                edit_state: AuthRequired::Proof,","counters":[{"col_start":0,"col_end":48,"count":0}]},{"line":"                send: AuthRequired::Signature,","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"                receive: AuthRequired::None,","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"                set_delegate: AuthRequired::Signature,","counters":[{"col_start":0,"col_end":54,"count":0}]},{"line":"                set_permissions: AuthRequired::Signature,","counters":[{"col_start":0,"col_end":57,"count":0}]},{"line":"                set_verification_key: AuthRequired::Signature,","counters":[{"col_start":0,"col_end":62,"count":0}]},{"line":"                set_zkapp_uri: AuthRequired::Signature,","counters":[{"col_start":0,"col_end":55,"count":0}]},{"line":"                edit_sequence_state: AuthRequired::Proof,","counters":[{"col_start":0,"col_end":57,"count":0}]},{"line":"                set_token_symbol: AuthRequired::Signature,","counters":[{"col_start":0,"col_end":58,"count":0}]},{"line":"                increment_nonce: AuthRequired::Signature,","counters":[{"col_start":0,"col_end":57,"count":0}]},{"line":"                set_voting_for: AuthRequired::Signature,","counters":[{"col_start":0,"col_end":56,"count":0}]},{"line":"            },","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<ZkAppUri> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> ZkAppUri {","counters":[{"col_start":4,"col_end":35,"count":0}]},{"line":"        /*","counters":[{"col_start":0,"col_end":10,"count":0}]},{"line":"            TODO: this needs to be fixed (assign a boundary) in the protocol since it is","counters":[{"col_start":0,"col_end":88,"count":0}]},{"line":"            possible to set a zkApp URI of arbitrary size.","counters":[{"col_start":0,"col_end":58,"count":0}]},{"line":"","counters":[]},{"line":"            Since the field is opaque to the Mina protocol logic, randomly generating","counters":[{"col_start":0,"col_end":85,"count":0}]},{"line":"            URIs makes little sense and will consume a significant amount of ledger space.","counters":[{"col_start":0,"col_end":90,"count":0}]},{"line":"        */","counters":[{"col_start":0,"col_end":10,"count":0}]},{"line":"        ZkAppUri::new()","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<TokenSymbol> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> TokenSymbol {","counters":[{"col_start":4,"col_end":38,"count":0}]},{"line":"        /*","counters":[{"col_start":0,"col_end":10,"count":0}]},{"line":"            TokenSymbol must be <= 6 **bytes**. This boundary doesn't exist at type-level,","counters":[{"col_start":0,"col_end":90,"count":0}]},{"line":"            instead it is check by binprot after deserializing the *string* object:","counters":[{"col_start":0,"col_end":83,"count":0}]},{"line":"            https://github.com/MinaProtocol/mina/blob/develop/src/lib/mina_base/account.ml#L124","counters":[{"col_start":0,"col_end":95,"count":0}]},{"line":"","counters":[]},{"line":"            We will let this function generate strings larger than 6 bytes with low probability,","counters":[{"col_start":0,"col_end":96,"count":0}]},{"line":"            just to cover the error handling code, but must of the time we want to avoid failing","counters":[{"col_start":0,"col_end":96,"count":0}]},{"line":"            this check.","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"        */","counters":[{"col_start":0,"col_end":10,"count":0}]},{"line":"        if self.rng.gen_bool(0.9) {","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"            TokenSymbol::default()","counters":[{"col_start":12,"col_end":34,"count":0}]},{"line":"        } else {","counters":[]},{"line":"            let rnd_len = self.rng.gen_range(1..=6);","counters":[{"col_start":16,"col_end":52,"count":0}]},{"line":"            // TODO: fix n random chars for n random bytes","counters":[{"col_start":0,"col_end":58,"count":0}]},{"line":"            TokenSymbol(Alphanumeric.sample_string(&mut self.rng, rnd_len))","counters":[{"col_start":0,"col_end":75,"count":0}]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<VotingFor> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> VotingFor {","counters":[{"col_start":4,"col_end":36,"count":0}]},{"line":"        VotingFor(self.gen())","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<zkapp_command::Events> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> zkapp_command::Events {","counters":[{"col_start":4,"col_end":48,"count":0}]},{"line":"        /*","counters":[{"col_start":0,"col_end":10,"count":0}]},{"line":"           An Event is a list of arrays of Fp, there doesn't seem to be any limit","counters":[{"col_start":0,"col_end":81,"count":0}]},{"line":"           neither in the size of the list or the array's size. The total size should","counters":[{"col_start":0,"col_end":85,"count":0}]},{"line":"           be bounded by the transport protocol (currently libp2p, ~32MB).","counters":[{"col_start":0,"col_end":74,"count":0}]},{"line":"","counters":[]},{"line":"           Since this field is ignored by nodes (except maybe for archive nodes), we","counters":[{"col_start":0,"col_end":84,"count":0}]},{"line":"           we will generate empty events (at least for the moment).","counters":[{"col_start":0,"col_end":67,"count":0}]},{"line":"        */","counters":[{"col_start":0,"col_end":10,"count":0}]},{"line":"        zkapp_command::Events(Vec::new())","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<zkapp_command::SequenceEvents> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> zkapp_command::SequenceEvents {","counters":[{"col_start":4,"col_end":56,"count":0}]},{"line":"        // See comment in generator above","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"        zkapp_command::SequenceEvents(Vec::new())","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<BlockTime> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> BlockTime {","counters":[{"col_start":4,"col_end":36,"count":0}]},{"line":"        self.rng.gen()","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<Length> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> Length {","counters":[{"col_start":4,"col_end":33,"count":10}]},{"line":"        self.rng.gen()","counters":[{"col_start":0,"col_end":22,"count":10}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":10}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"pub trait GeneratorRange32<T> {","counters":[]},{"line":"    fn gen_range(&mut self, range: RangeInclusive<u32>) -> T;","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"pub trait GeneratorRange64<T> {","counters":[]},{"line":"    fn gen_range(&mut self, range: RangeInclusive<u64>) -> T;","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl GeneratorRange64<Balance> for FuzzerCtx {","counters":[]},{"line":"    fn gen_range(&mut self, range: RangeInclusive<u64>) -> Balance {","counters":[{"col_start":4,"col_end":68,"count":0}]},{"line":"        Balance::from_u64(self.rng.gen_range(range))","counters":[{"col_start":0,"col_end":52,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl GeneratorRange64<Fee> for FuzzerCtx {","counters":[]},{"line":"    fn gen_range(&mut self, range: RangeInclusive<u64>) -> Fee {","counters":[{"col_start":4,"col_end":64,"count":0}]},{"line":"        Fee::from_u64(self.rng.gen_range(range))","counters":[{"col_start":0,"col_end":48,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl GeneratorRange64<Amount> for FuzzerCtx {","counters":[]},{"line":"    fn gen_range(&mut self, range: RangeInclusive<u64>) -> Amount {","counters":[{"col_start":4,"col_end":67,"count":0}]},{"line":"        Amount::from_u64(self.rng.gen_range(range))","counters":[{"col_start":0,"col_end":51,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl GeneratorRange32<Nonce> for FuzzerCtx {","counters":[]},{"line":"    fn gen_range(&mut self, range: RangeInclusive<u32>) -> Nonce {","counters":[{"col_start":4,"col_end":66,"count":0}]},{"line":"        Nonce::from_u32(self.rng.gen_range(range))","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl GeneratorRange32<Length> for FuzzerCtx {","counters":[]},{"line":"    fn gen_range(&mut self, range: RangeInclusive<u32>) -> Length {","counters":[{"col_start":4,"col_end":67,"count":0}]},{"line":"        Length::from_u32(self.rng.gen_range(range))","counters":[{"col_start":0,"col_end":51,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"pub trait GeneratorWrapper<W, T, F: FnMut(&mut Self) -> T> {","counters":[]},{"line":"    fn gen_wrap(&mut self, f: F) -> W;","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl<T: Clone, F: FnMut(&mut Self) -> T> GeneratorWrapper<Option<T>, T, F> for FuzzerCtx {","counters":[]},{"line":"    fn gen_wrap(&mut self, mut f: F) -> Option<T> {","counters":[{"col_start":4,"col_end":51,"count":1240}]},{"line":"        if self.rng.gen_bool(0.9) {","counters":[{"col_start":0,"col_end":33,"count":1240}]},{"line":"            None","counters":[{"col_start":12,"col_end":16,"count":775}]},{"line":"        } else {","counters":[]},{"line":"            Some(f(self))","counters":[{"col_start":12,"col_end":25,"count":1240}]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":1240}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl<T: Clone, F: FnMut(&mut Self) -> T> GeneratorWrapper<OrIgnore<T>, T, F> for FuzzerCtx {","counters":[]},{"line":"    fn gen_wrap(&mut self, mut f: F) -> OrIgnore<T> {","counters":[{"col_start":4,"col_end":53,"count":1705}]},{"line":"        if self.rng.gen_bool(0.9) {","counters":[{"col_start":0,"col_end":33,"count":1705}]},{"line":"            OrIgnore::Ignore","counters":[{"col_start":12,"col_end":28,"count":38}]},{"line":"        } else {","counters":[]},{"line":"            OrIgnore::Check(f(self))","counters":[{"col_start":12,"col_end":36,"count":1705}]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":1705}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl<T: Clone, F: FnMut(&mut Self) -> T> GeneratorWrapper<SetOrKeep<T>, T, F> for FuzzerCtx {","counters":[]},{"line":"    fn gen_wrap(&mut self, mut f: F) -> SetOrKeep<T> {","counters":[{"col_start":4,"col_end":54,"count":418}]},{"line":"        if self.rng.gen_bool(0.9) {","counters":[{"col_start":0,"col_end":33,"count":418}]},{"line":"            SetOrKeep::Keep","counters":[{"col_start":12,"col_end":27,"count":22}]},{"line":"        } else {","counters":[]},{"line":"            SetOrKeep::Set(f(self))","counters":[{"col_start":12,"col_end":35,"count":418}]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":418}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl<T: Clone + MinMax, F: FnMut(&mut Self) -> T> GeneratorWrapper<ClosedInterval<T>, T, F>","counters":[]},{"line":"    for FuzzerCtx","counters":[]},{"line":"{","counters":[]},{"line":"    fn gen_wrap(&mut self, mut f: F) -> ClosedInterval<T> {","counters":[{"col_start":4,"col_end":59,"count":252}]},{"line":"        ClosedInterval {","counters":[{"col_start":0,"col_end":24,"count":252}]},{"line":"            lower: f(self),","counters":[{"col_start":0,"col_end":27,"count":252}]},{"line":"            upper: f(self),","counters":[{"col_start":0,"col_end":27,"count":252}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":252}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":252}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl<T: Clone + Magnitude + Ord, F: FnMut(&mut Self) -> T> GeneratorWrapper<Signed<T>, T, F>","counters":[]},{"line":"    for FuzzerCtx","counters":[]},{"line":"{","counters":[]},{"line":"    fn gen_wrap(&mut self, mut f: F) -> Signed<T> {","counters":[{"col_start":4,"col_end":50,"count":1}]},{"line":"        let sgn = if self.rng.gen_bool(0.5) {","counters":[{"col_start":12,"col_end":15,"count":1},{"col_start":21,"col_end":43,"count":1}]},{"line":"            Sgn::Pos","counters":[{"col_start":12,"col_end":20,"count":1}]},{"line":"        } else {","counters":[]},{"line":"            Sgn::Neg","counters":[{"col_start":12,"col_end":20,"count":1}]},{"line":"        };","counters":[]},{"line":"        Signed::create(f(self), sgn)","counters":[{"col_start":8,"col_end":36,"count":1}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":1}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"pub trait GeneratorWrapperMany<W, T, F: FnMut(&mut Self) -> T> {","counters":[]},{"line":"    fn gen_wrap_many(&mut self, f: F, count: usize) -> W;","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl<T, F: FnMut(&mut Self) -> T> GeneratorWrapperMany<Vec<T>, T, F> for FuzzerCtx {","counters":[]},{"line":"    fn gen_wrap_many(&mut self, mut f: F, count: usize) -> Vec<T> {","counters":[{"col_start":4,"col_end":67,"count":2}]},{"line":"        //let count = self.rng.gen_range(0..=count);","counters":[{"col_start":0,"col_end":52,"count":2}]},{"line":"        iter::repeat_with(|| f(self)).take(count).collect()","counters":[{"col_start":0,"col_end":26,"count":2},{"col_start":29,"col_end":36,"count":0},{"col_start":36,"col_end":59,"count":2}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":2}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<Numeric<Amount>> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> Numeric<Amount> {","counters":[{"col_start":4,"col_end":42,"count":0}]},{"line":"        self.gen_wrap(|x| {","counters":[{"col_start":0,"col_end":22,"count":0},{"col_start":26,"col_end":27,"count":0}]},{"line":"            x.gen_wrap(|x| -> Amount { GeneratorRange64::gen_range(x, 0..=u64::MAX) })","counters":[{"col_start":0,"col_end":23,"count":0},{"col_start":37,"col_end":85,"count":0},{"col_start":85,"col_end":86,"count":0}]},{"line":"        })","counters":[{"col_start":0,"col_end":9,"count":0},{"col_start":9,"col_end":10,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<Numeric<Length>> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> Numeric<Length> {","counters":[{"col_start":4,"col_end":42,"count":0}]},{"line":"        self.gen_wrap(|x| {","counters":[{"col_start":0,"col_end":22,"count":0},{"col_start":26,"col_end":27,"count":0}]},{"line":"            x.gen_wrap(|x| -> Length { GeneratorRange32::gen_range(x, 0..=u32::MAX) })","counters":[{"col_start":0,"col_end":23,"count":0},{"col_start":37,"col_end":85,"count":0},{"col_start":85,"col_end":86,"count":0}]},{"line":"        })","counters":[{"col_start":0,"col_end":9,"count":0},{"col_start":9,"col_end":10,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<FeePayer> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> FeePayer {","counters":[{"col_start":4,"col_end":35,"count":0}]},{"line":"        let public_key = self.random_keypair().public.into_compressed();","counters":[{"col_start":0,"col_end":72,"count":0}]},{"line":"        let account = self.get_account(&public_key).unwrap();","counters":[{"col_start":0,"col_end":61,"count":0}]},{"line":"        FeePayer {","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"            body: FeePayerBody {","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"                public_key,","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"                fee: GeneratorRange64::gen_range(self, 0..=account.balance.as_u64()),","counters":[{"col_start":0,"col_end":85,"count":0}]},{"line":"                valid_until: self.gen_wrap(|x| -> Slot { x.gen() }),","counters":[{"col_start":0,"col_end":43,"count":0},{"col_start":55,"col_end":66,"count":0},{"col_start":66,"col_end":68,"count":0}]},{"line":"                nonce: account.nonce,","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"            },","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"            // filled later when tx is complete","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"            authorization: Signature::dummy(),","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<zkapp_command::EpochData> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> zkapp_command::EpochData {","counters":[{"col_start":4,"col_end":51,"count":0}]},{"line":"        zkapp_command::EpochData {","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"            ledger: zkapp_command::EpochLedger {","counters":[{"col_start":0,"col_end":48,"count":0}]},{"line":"                hash: self.gen_wrap(|x| x.gen()),","counters":[{"col_start":0,"col_end":36,"count":0},{"col_start":40,"col_end":47,"count":0},{"col_start":47,"col_end":49,"count":0}]},{"line":"                total_currency: self.gen(),","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"            },","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"            seed: self.gen_wrap(|x| x.gen()),","counters":[{"col_start":0,"col_end":32,"count":0},{"col_start":36,"col_end":43,"count":0},{"col_start":43,"col_end":45,"count":0}]},{"line":"            start_checkpoint: self.gen_wrap(|x| x.gen()),","counters":[{"col_start":0,"col_end":44,"count":0},{"col_start":48,"col_end":55,"count":0},{"col_start":55,"col_end":57,"count":0}]},{"line":"            lock_checkpoint: self.gen_wrap(|x| x.gen()),","counters":[{"col_start":0,"col_end":43,"count":0},{"col_start":47,"col_end":54,"count":0},{"col_start":54,"col_end":56,"count":0}]},{"line":"            epoch_length: self.gen(),","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<zkapp_command::AuthorizationKind> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> zkapp_command::AuthorizationKind {","counters":[{"col_start":4,"col_end":58,"count":0}]},{"line":"        let options = match self.permission_model {","counters":[{"col_start":12,"col_end":19,"count":0},{"col_start":28,"col_end":49,"count":0}]},{"line":"            PermissionModel::Any => vec![","counters":[{"col_start":36,"col_end":41,"count":-1}]},{"line":"                zkapp_command::AuthorizationKind::NoneGiven,","counters":[{"col_start":0,"col_end":60,"count":-1}]},{"line":"                zkapp_command::AuthorizationKind::Signature,","counters":[{"col_start":0,"col_end":60,"count":-1}]},{"line":"                zkapp_command::AuthorizationKind::Proof,","counters":[{"col_start":0,"col_end":56,"count":-1}]},{"line":"            ],","counters":[{"col_start":0,"col_end":13,"count":-1}]},{"line":"            PermissionModel::Empty => vec![zkapp_command::AuthorizationKind::NoneGiven],","counters":[{"col_start":38,"col_end":87,"count":0}]},{"line":"            PermissionModel::Initial => vec![","counters":[{"col_start":40,"col_end":45,"count":0}]},{"line":"                zkapp_command::AuthorizationKind::NoneGiven,","counters":[{"col_start":0,"col_end":60,"count":0}]},{"line":"                zkapp_command::AuthorizationKind::Signature,","counters":[{"col_start":0,"col_end":60,"count":0}]},{"line":"            ],","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"            PermissionModel::Default => vec![","counters":[{"col_start":40,"col_end":45,"count":1}]},{"line":"                zkapp_command::AuthorizationKind::NoneGiven,","counters":[{"col_start":0,"col_end":60,"count":1}]},{"line":"                zkapp_command::AuthorizationKind::Signature,","counters":[{"col_start":0,"col_end":60,"count":1}]},{"line":"                zkapp_command::AuthorizationKind::Proof,","counters":[{"col_start":0,"col_end":56,"count":1}]},{"line":"            ],","counters":[{"col_start":0,"col_end":13,"count":1}]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        options.choose(&mut self.rng).unwrap().clone()","counters":[{"col_start":8,"col_end":54,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<LimbVectorConstantHex64StableV1> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> LimbVectorConstantHex64StableV1 {","counters":[{"col_start":4,"col_end":58,"count":10}]},{"line":"        LimbVectorConstantHex64StableV1(Number(self.rng.gen()))","counters":[{"col_start":0,"col_end":63,"count":10}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":10}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<PicklesProofProofsVerified2ReprStableV2StatementPlonk> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> PicklesProofProofsVerified2ReprStableV2StatementPlonk {","counters":[{"col_start":4,"col_end":80,"count":0}]},{"line":"        PicklesProofProofsVerified2ReprStableV2StatementPlonk {","counters":[{"col_start":0,"col_end":63,"count":0}]},{"line":"            alpha: self.gen(),","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"            beta: self.gen(),","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"            gamma: self.gen(),","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"            zeta: self.gen(),","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"            joint_combiner: self.gen_wrap(|x| x.gen()),","counters":[{"col_start":0,"col_end":42,"count":0},{"col_start":46,"col_end":53,"count":0},{"col_start":53,"col_end":55,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<mina_p2p_messages::bigint::BigInt> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> mina_p2p_messages::bigint::BigInt {","counters":[{"col_start":4,"col_end":60,"count":0}]},{"line":"        mina_p2p_messages::bigint::BigInt::from(Generator::<Fp>::gen(self))","counters":[{"col_start":0,"col_end":75,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<PicklesProofProofsVerified2ReprStableV2StatementFp> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> PicklesProofProofsVerified2ReprStableV2StatementFp {","counters":[{"col_start":4,"col_end":77,"count":0}]},{"line":"        PicklesProofProofsVerified2ReprStableV2StatementFp::ShiftedValue(self.gen())","counters":[{"col_start":0,"col_end":84,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<PicklesReducedMessagesForNextProofOverSameFieldWrapChallengesVectorStableV2A>","counters":[]},{"line":"    for FuzzerCtx","counters":[]},{"line":"{","counters":[]},{"line":"    fn gen(","counters":[{"col_start":4,"col_end":11,"count":0}]},{"line":"        &mut self,","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"    ) -> PicklesReducedMessagesForNextProofOverSameFieldWrapChallengesVectorStableV2A {","counters":[{"col_start":0,"col_end":87,"count":0}]},{"line":"        PicklesReducedMessagesForNextProofOverSameFieldWrapChallengesVectorStableV2A {","counters":[{"col_start":0,"col_end":86,"count":0}]},{"line":"            prechallenge: self.gen(),","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl<T, const N: usize> Generator<PaddedSeq<T, N>> for FuzzerCtx","counters":[]},{"line":"where","counters":[]},{"line":"    FuzzerCtx: Generator<T>,","counters":[]},{"line":"{","counters":[]},{"line":"    fn gen(&mut self) -> PaddedSeq<T, N> {","counters":[{"col_start":4,"col_end":42,"count":0}]},{"line":"        PaddedSeq::<T, N>(array::from_fn(|_| self.gen()))","counters":[{"col_start":0,"col_end":41,"count":0},{"col_start":45,"col_end":55,"count":1},{"col_start":55,"col_end":57,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl<T: Clone, F: FnMut(&mut Self) -> T, const N: usize> GeneratorWrapper<PaddedSeq<T, N>, T, F>","counters":[]},{"line":"    for FuzzerCtx","counters":[]},{"line":"{","counters":[]},{"line":"    fn gen_wrap(&mut self, mut f: F) -> PaddedSeq<T, N> {","counters":[{"col_start":4,"col_end":57,"count":2}]},{"line":"        PaddedSeq::<T, N>(array::from_fn(|_| f(self)))","counters":[{"col_start":0,"col_end":41,"count":2},{"col_start":45,"col_end":52,"count":0},{"col_start":52,"col_end":54,"count":2}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":2}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl","counters":[]},{"line":"    Generator<PicklesReducedMessagesForNextProofOverSameFieldWrapChallengesVectorStableV2AChallenge>","counters":[]},{"line":"    for FuzzerCtx","counters":[]},{"line":"{","counters":[]},{"line":"    fn gen(","counters":[{"col_start":4,"col_end":11,"count":0}]},{"line":"        &mut self,","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"    ) -> PicklesReducedMessagesForNextProofOverSameFieldWrapChallengesVectorStableV2AChallenge {","counters":[{"col_start":0,"col_end":96,"count":0}]},{"line":"        PicklesReducedMessagesForNextProofOverSameFieldWrapChallengesVectorStableV2AChallenge {","counters":[{"col_start":0,"col_end":95,"count":0}]},{"line":"            inner: self.gen(),","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<CompositionTypesBranchDataDomainLog2StableV1> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> CompositionTypesBranchDataDomainLog2StableV1 {","counters":[{"col_start":4,"col_end":71,"count":0}]},{"line":"        CompositionTypesBranchDataDomainLog2StableV1(mina_p2p_messages::char::Char(self.rng.gen()))","counters":[{"col_start":0,"col_end":99,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<CompositionTypesBranchDataStableV1> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> CompositionTypesBranchDataStableV1 {","counters":[{"col_start":4,"col_end":61,"count":0}]},{"line":"        CompositionTypesBranchDataStableV1 {","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"            proofs_verified: (vec![","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"                PicklesBaseProofsVerifiedStableV1::N0,","counters":[{"col_start":0,"col_end":54,"count":0}]},{"line":"                PicklesBaseProofsVerifiedStableV1::N1,","counters":[{"col_start":0,"col_end":54,"count":0}]},{"line":"                PicklesBaseProofsVerifiedStableV1::N2,","counters":[{"col_start":0,"col_end":54,"count":0}]},{"line":"            ]","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"            .choose(&mut self.rng)","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"            .unwrap()","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"            .clone(),),","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"            domain_log2: self.gen(),","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<PicklesProofProofsVerified2ReprStableV2StatementProofStateDeferredValues>","counters":[]},{"line":"    for FuzzerCtx","counters":[]},{"line":"{","counters":[]},{"line":"    fn gen(&mut self) -> PicklesProofProofsVerified2ReprStableV2StatementProofStateDeferredValues {","counters":[{"col_start":4,"col_end":99,"count":0}]},{"line":"        PicklesProofProofsVerified2ReprStableV2StatementProofStateDeferredValues {","counters":[{"col_start":0,"col_end":82,"count":0}]},{"line":"            plonk: self.gen(),","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"            combined_inner_product: self.gen(),","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"            b: self.gen(),","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"            xi: self.gen(),","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"            bulletproof_challenges: self.gen(),","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"            branch_data: self.gen(),","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<CompositionTypesDigestConstantStableV1> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> CompositionTypesDigestConstantStableV1 {","counters":[{"col_start":4,"col_end":65,"count":0}]},{"line":"        CompositionTypesDigestConstantStableV1(self.gen())","counters":[{"col_start":0,"col_end":58,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<PicklesReducedMessagesForNextProofOverSameFieldWrapChallengesVectorStableV2>","counters":[]},{"line":"    for FuzzerCtx","counters":[]},{"line":"{","counters":[]},{"line":"    fn gen(","counters":[{"col_start":4,"col_end":11,"count":0}]},{"line":"        &mut self,","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"    ) -> PicklesReducedMessagesForNextProofOverSameFieldWrapChallengesVectorStableV2 {","counters":[{"col_start":0,"col_end":86,"count":0}]},{"line":"        PicklesReducedMessagesForNextProofOverSameFieldWrapChallengesVectorStableV2(self.gen())","counters":[{"col_start":0,"col_end":95,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"fn gen_curve_point<T: Field + SquareRootField + From<i32>>(","counters":[{"col_start":0,"col_end":59,"count":0}]},{"line":"    ctx: &mut impl Generator<(T, T)>,","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":") -> (","counters":[{"col_start":0,"col_end":6,"count":0}]},{"line":"    mina_p2p_messages::bigint::BigInt,","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"    mina_p2p_messages::bigint::BigInt,","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":")","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"where","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"    mina_p2p_messages::bigint::BigInt: From<T>,","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"{","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"    Generator::<(T, T)>::gen(ctx).map(mina_p2p_messages::bigint::BigInt::from)","counters":[{"col_start":0,"col_end":78,"count":0}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"fn gen_curve_point_many<T: Field + SquareRootField + From<i32>>(","counters":[{"col_start":0,"col_end":64,"count":0}]},{"line":"    ctx: &mut FuzzerCtx,","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"    count: usize,","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":") -> Vec<(","counters":[{"col_start":0,"col_end":10,"count":0}]},{"line":"    mina_p2p_messages::bigint::BigInt,","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"    mina_p2p_messages::bigint::BigInt,","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":")>","counters":[{"col_start":0,"col_end":2,"count":0}]},{"line":"where","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"    mina_p2p_messages::bigint::BigInt: From<T>,","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"{","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"    ctx.gen_wrap_many(|x| gen_curve_point::<T>(x), count)","counters":[{"col_start":0,"col_end":22,"count":0},{"col_start":26,"col_end":49,"count":0},{"col_start":49,"col_end":57,"count":0}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"fn gen_curve_point_many_unzip<T: Field + SquareRootField + From<i32>>(","counters":[{"col_start":0,"col_end":70,"count":0}]},{"line":"    ctx: &mut FuzzerCtx,","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"    count: usize,","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":") -> (","counters":[{"col_start":0,"col_end":6,"count":0}]},{"line":"    Vec<mina_p2p_messages::bigint::BigInt>,","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"    Vec<mina_p2p_messages::bigint::BigInt>,","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":")","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"where","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"    mina_p2p_messages::bigint::BigInt: From<T>,","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"{","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"    gen_curve_point_many::<Fp>(ctx, count).into_iter().unzip()","counters":[{"col_start":0,"col_end":62,"count":0}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"impl Generator<PicklesProofProofsVerified2ReprStableV2MessagesForNextWrapProof> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> PicklesProofProofsVerified2ReprStableV2MessagesForNextWrapProof {","counters":[{"col_start":4,"col_end":90,"count":0}]},{"line":"        PicklesProofProofsVerified2ReprStableV2MessagesForNextWrapProof {","counters":[{"col_start":0,"col_end":73,"count":0}]},{"line":"            challenge_polynomial_commitment: gen_curve_point::<Fq>(self),","counters":[{"col_start":0,"col_end":73,"count":0}]},{"line":"            old_bulletproof_challenges: self.gen(),","counters":[{"col_start":0,"col_end":51,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<PicklesProofProofsVerified2ReprStableV2StatementProofState> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> PicklesProofProofsVerified2ReprStableV2StatementProofState {","counters":[{"col_start":4,"col_end":85,"count":0}]},{"line":"        PicklesProofProofsVerified2ReprStableV2StatementProofState {","counters":[{"col_start":0,"col_end":68,"count":0}]},{"line":"            deferred_values: self.gen(),","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"            sponge_digest_before_evaluations: self.gen(),","counters":[{"col_start":0,"col_end":57,"count":0}]},{"line":"            messages_for_next_wrap_proof: self.gen(),","counters":[{"col_start":0,"col_end":53,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<PicklesProofProofsVerified2ReprStableV2MessagesForNextStepProof> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> PicklesProofProofsVerified2ReprStableV2MessagesForNextStepProof {","counters":[{"col_start":4,"col_end":90,"count":0}]},{"line":"        PicklesProofProofsVerified2ReprStableV2MessagesForNextStepProof {","counters":[{"col_start":0,"col_end":73,"count":0}]},{"line":"            app_state: (),","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"            challenge_polynomial_commitments: gen_curve_point_many::<Fp>(self, 1),","counters":[{"col_start":0,"col_end":82,"count":0}]},{"line":"            old_bulletproof_challenges: self.gen_wrap_many(|x| x.gen(), 1),","counters":[{"col_start":0,"col_end":59,"count":0},{"col_start":63,"col_end":70,"count":0},{"col_start":70,"col_end":75,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<PicklesProofProofsVerified2ReprStableV2Statement> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> PicklesProofProofsVerified2ReprStableV2Statement {","counters":[{"col_start":4,"col_end":75,"count":0}]},{"line":"        PicklesProofProofsVerified2ReprStableV2Statement {","counters":[{"col_start":0,"col_end":58,"count":0}]},{"line":"            proof_state: self.gen(),","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"            messages_for_next_step_proof: self.gen(),","counters":[{"col_start":0,"col_end":53,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<PicklesProofProofsVerified2ReprStableV2PrevEvalsEvalsEvalsLookupA> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> PicklesProofProofsVerified2ReprStableV2PrevEvalsEvalsEvalsLookupA {","counters":[{"col_start":4,"col_end":92,"count":0}]},{"line":"        PicklesProofProofsVerified2ReprStableV2PrevEvalsEvalsEvalsLookupA {","counters":[{"col_start":0,"col_end":75,"count":0}]},{"line":"            sorted: self.gen_wrap_many(|x| gen_curve_point_many_unzip::<Fp>(x, 1), 1),","counters":[{"col_start":0,"col_end":39,"count":0},{"col_start":43,"col_end":81,"count":0},{"col_start":81,"col_end":86,"count":0}]},{"line":"            aggreg: gen_curve_point_many_unzip::<Fp>(self, 1),","counters":[{"col_start":0,"col_end":62,"count":0}]},{"line":"            table: gen_curve_point_many_unzip::<Fp>(self, 1),","counters":[{"col_start":0,"col_end":61,"count":0}]},{"line":"            runtime: self.gen_wrap(|x| gen_curve_point_many_unzip::<Fp>(x, 1)),","counters":[{"col_start":0,"col_end":35,"count":0},{"col_start":39,"col_end":77,"count":0},{"col_start":77,"col_end":79,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<PicklesProofProofsVerified2ReprStableV2PrevEvalsEvalsEvals> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> PicklesProofProofsVerified2ReprStableV2PrevEvalsEvalsEvals {","counters":[{"col_start":4,"col_end":85,"count":0}]},{"line":"        PicklesProofProofsVerified2ReprStableV2PrevEvalsEvalsEvals {","counters":[{"col_start":0,"col_end":68,"count":0}]},{"line":"            w: self.gen_wrap(|x| gen_curve_point_many_unzip::<Fp>(x, 1)),","counters":[{"col_start":0,"col_end":29,"count":0},{"col_start":33,"col_end":71,"count":0},{"col_start":71,"col_end":73,"count":0}]},{"line":"            z: gen_curve_point_many_unzip::<Fp>(self, 1),","counters":[{"col_start":0,"col_end":57,"count":0}]},{"line":"            s: self.gen_wrap(|x| gen_curve_point_many_unzip::<Fp>(x, 1)),","counters":[{"col_start":0,"col_end":29,"count":0},{"col_start":33,"col_end":71,"count":0},{"col_start":71,"col_end":73,"count":0}]},{"line":"            generic_selector: gen_curve_point_many_unzip::<Fp>(self, 1),","counters":[{"col_start":0,"col_end":72,"count":0}]},{"line":"            poseidon_selector: gen_curve_point_many_unzip::<Fp>(self, 1),","counters":[{"col_start":0,"col_end":73,"count":0}]},{"line":"            lookup: self.gen_wrap(|x| x.gen()),","counters":[{"col_start":0,"col_end":34,"count":0},{"col_start":38,"col_end":45,"count":0},{"col_start":45,"col_end":47,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<PicklesProofProofsVerified2ReprStableV2PrevEvalsEvals> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> PicklesProofProofsVerified2ReprStableV2PrevEvalsEvals {","counters":[{"col_start":4,"col_end":80,"count":0}]},{"line":"        PicklesProofProofsVerified2ReprStableV2PrevEvalsEvals {","counters":[{"col_start":0,"col_end":63,"count":0}]},{"line":"            public_input: gen_curve_point::<Fp>(self),","counters":[{"col_start":0,"col_end":54,"count":0}]},{"line":"            evals: self.gen(),","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<PicklesProofProofsVerified2ReprStableV2PrevEvals> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> PicklesProofProofsVerified2ReprStableV2PrevEvals {","counters":[{"col_start":4,"col_end":75,"count":0}]},{"line":"        PicklesProofProofsVerified2ReprStableV2PrevEvals {","counters":[{"col_start":0,"col_end":58,"count":0}]},{"line":"            evals: self.gen(),","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"            ft_eval1: mina_p2p_messages::bigint::BigInt::from(Generator::<Fp>::gen(self)),","counters":[{"col_start":0,"col_end":90,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<PicklesProofProofsVerified2ReprStableV2ProofMessagesLookupA> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> PicklesProofProofsVerified2ReprStableV2ProofMessagesLookupA {","counters":[{"col_start":4,"col_end":86,"count":0}]},{"line":"        PicklesProofProofsVerified2ReprStableV2ProofMessagesLookupA {","counters":[{"col_start":0,"col_end":69,"count":0}]},{"line":"            sorted: self.gen_wrap_many(|x| gen_curve_point_many::<Fp>(x, 1), 1),","counters":[{"col_start":0,"col_end":39,"count":0},{"col_start":43,"col_end":75,"count":0},{"col_start":75,"col_end":80,"count":0}]},{"line":"            aggreg: gen_curve_point_many::<Fp>(self, 1),","counters":[{"col_start":0,"col_end":56,"count":0}]},{"line":"            runtime: self.gen_wrap(|x| gen_curve_point_many::<Fp>(x, 1)),","counters":[{"col_start":0,"col_end":35,"count":0},{"col_start":39,"col_end":71,"count":0},{"col_start":71,"col_end":73,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<PicklesProofProofsVerified2ReprStableV2ProofMessages> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> PicklesProofProofsVerified2ReprStableV2ProofMessages {","counters":[{"col_start":4,"col_end":79,"count":0}]},{"line":"        PicklesProofProofsVerified2ReprStableV2ProofMessages {","counters":[{"col_start":0,"col_end":62,"count":0}]},{"line":"            w_comm: self.gen_wrap(|x| gen_curve_point_many::<Fp>(x, 1)),","counters":[{"col_start":0,"col_end":34,"count":0},{"col_start":38,"col_end":70,"count":0},{"col_start":70,"col_end":72,"count":0}]},{"line":"            z_comm: gen_curve_point_many::<Fp>(self, 1),","counters":[{"col_start":0,"col_end":56,"count":0}]},{"line":"            t_comm: gen_curve_point_many::<Fp>(self, 1),","counters":[{"col_start":0,"col_end":56,"count":0}]},{"line":"            lookup: self.gen_wrap(|x| x.gen()),","counters":[{"col_start":0,"col_end":34,"count":0},{"col_start":38,"col_end":45,"count":0},{"col_start":45,"col_end":47,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<PicklesProofProofsVerified2ReprStableV2ProofOpeningsProof> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> PicklesProofProofsVerified2ReprStableV2ProofOpeningsProof {","counters":[{"col_start":4,"col_end":84,"count":0}]},{"line":"        PicklesProofProofsVerified2ReprStableV2ProofOpeningsProof {","counters":[{"col_start":0,"col_end":67,"count":0}]},{"line":"            lr: self.gen_wrap_many(|x| (gen_curve_point::<Fp>(x), gen_curve_point::<Fp>(x)), 1),","counters":[{"col_start":0,"col_end":35,"count":0},{"col_start":39,"col_end":91,"count":0},{"col_start":91,"col_end":96,"count":0}]},{"line":"            z_1: self.gen(),","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"            z_2: self.gen(),","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"            delta: gen_curve_point::<Fp>(self),","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"            challenge_polynomial_commitment: gen_curve_point::<Fp>(self),","counters":[{"col_start":0,"col_end":73,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<PicklesProofProofsVerified2ReprStableV2ProofOpenings> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> PicklesProofProofsVerified2ReprStableV2ProofOpenings {","counters":[{"col_start":4,"col_end":79,"count":0}]},{"line":"        PicklesProofProofsVerified2ReprStableV2ProofOpenings {","counters":[{"col_start":0,"col_end":62,"count":0}]},{"line":"            proof: self.gen(),","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"            evals: self.gen(),","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"            ft_eval1: self.gen(),","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<PicklesProofProofsVerified2ReprStableV2Proof> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> PicklesProofProofsVerified2ReprStableV2Proof {","counters":[{"col_start":4,"col_end":71,"count":0}]},{"line":"        PicklesProofProofsVerified2ReprStableV2Proof {","counters":[{"col_start":0,"col_end":54,"count":0}]},{"line":"            messages: self.gen(),","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"            openings: self.gen(),","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<PicklesProofProofsVerifiedMaxStableV2> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> PicklesProofProofsVerifiedMaxStableV2 {","counters":[{"col_start":4,"col_end":64,"count":0}]},{"line":"        PicklesProofProofsVerifiedMaxStableV2 {","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"            statement: self.gen(),","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"            prev_evals: self.gen(),","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"            proof: self.gen(),","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<zkapp_command::SideLoadedProof> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> zkapp_command::SideLoadedProof {","counters":[{"col_start":4,"col_end":57,"count":0}]},{"line":"        Rc::new(self.gen())","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<zkapp_command::Control> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> zkapp_command::Control {","counters":[{"col_start":4,"col_end":48,"count":10}]},{"line":"        let options = match self.permission_model {","counters":[{"col_start":12,"col_end":19,"count":10},{"col_start":28,"col_end":49,"count":10}]},{"line":"            PermissionModel::Any => vec![0, 1, 2],","counters":[{"col_start":36,"col_end":49,"count":-35}]},{"line":"            PermissionModel::Empty => vec![0],","counters":[{"col_start":38,"col_end":45,"count":0}]},{"line":"            PermissionModel::Initial => vec![0, 1],","counters":[{"col_start":40,"col_end":50,"count":45}]},{"line":"            PermissionModel::Default => vec![0, 1, 2],","counters":[{"col_start":40,"col_end":53,"count":0}]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        match options.choose(&mut self.rng).unwrap() {","counters":[{"col_start":14,"col_end":52,"count":10}]},{"line":"            0 => zkapp_command::Control::NoneGiven,","counters":[{"col_start":17,"col_end":50,"count":10}]},{"line":"            // TODO: calculate signature after building the transaction","counters":[]},{"line":"            1 => zkapp_command::Control::Signature(Signature::dummy()),","counters":[{"col_start":17,"col_end":70,"count":0}]},{"line":"            2 => zkapp_command::Control::Proof(self.gen()),","counters":[{"col_start":17,"col_end":58,"count":0}]},{"line":"            _ => unimplemented!(),","counters":[{"col_start":17,"col_end":33,"count":0}]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":10}]},{"line":"}","counters":[]},{"line":"pub trait GeneratorFromAccount<T> {","counters":[]},{"line":"    fn gen_from_account(&mut self, account: &Account) -> T;","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl<T: Clone + MinMax> GeneratorFromAccount<ClosedInterval<T>> for FuzzerCtx","counters":[]},{"line":"where","counters":[]},{"line":"    FuzzerCtx: GeneratorFromAccount<T>,","counters":[]},{"line":"{","counters":[]},{"line":"    fn gen_from_account(&mut self, account: &Account) -> ClosedInterval<T> {","counters":[{"col_start":4,"col_end":76,"count":0}]},{"line":"        ClosedInterval {","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"            lower: self.gen_from_account(account),","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"            upper: self.gen_from_account(account),","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl GeneratorFromAccount<Fee> for FuzzerCtx {","counters":[]},{"line":"    fn gen_from_account(&mut self, account: &Account) -> Fee {","counters":[{"col_start":4,"col_end":62,"count":0}]},{"line":"        GeneratorRange64::<Fee>::gen_range(self, 0..=account.balance.as_u64())","counters":[{"col_start":0,"col_end":78,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl GeneratorFromAccount<Balance> for FuzzerCtx {","counters":[]},{"line":"    fn gen_from_account(&mut self, account: &Account) -> Balance {","counters":[{"col_start":4,"col_end":66,"count":0}]},{"line":"        GeneratorRange64::<Balance>::gen_range(self, 0..=account.balance.as_u64())","counters":[{"col_start":0,"col_end":82,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl GeneratorFromAccount<Amount> for FuzzerCtx {","counters":[]},{"line":"    fn gen_from_account(&mut self, account: &Account) -> Amount {","counters":[{"col_start":4,"col_end":65,"count":0}]},{"line":"        GeneratorRange64::<Amount>::gen_range(self, 0..=account.balance.as_u64())","counters":[{"col_start":0,"col_end":81,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl GeneratorFromAccount<zkapp_command::Timing> for FuzzerCtx {","counters":[]},{"line":"    fn gen_from_account(&mut self, account: &Account) -> zkapp_command::Timing {","counters":[{"col_start":4,"col_end":80,"count":0}]},{"line":"        zkapp_command::Timing {","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"            initial_minimum_balance: self.gen_from_account(account),","counters":[{"col_start":0,"col_end":68,"count":0}]},{"line":"            cliff_time: self.gen(),","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"            cliff_amount: self.gen_from_account(account),","counters":[{"col_start":0,"col_end":57,"count":0}]},{"line":"            vesting_period: self.gen(),","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"            vesting_increment: self.gen_from_account(account),","counters":[{"col_start":0,"col_end":62,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl GeneratorFromAccount<Nonce> for FuzzerCtx {","counters":[]},{"line":"    fn gen_from_account(&mut self, account: &Account) -> Nonce {","counters":[{"col_start":4,"col_end":64,"count":0}]},{"line":"        if self.rng.gen_bool(0.9) {","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"            account.nonce.clone()","counters":[{"col_start":12,"col_end":33,"count":0}]},{"line":"        } else {","counters":[]},{"line":"            GeneratorRange32::<Nonce>::gen_range(self, 0..=u32::MAX)","counters":[{"col_start":12,"col_end":68,"count":0}]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl GeneratorFromAccount<Update> for FuzzerCtx {","counters":[]},{"line":"    fn gen_from_account(&mut self, account: &Account) -> Update {","counters":[{"col_start":4,"col_end":65,"count":0}]},{"line":"        Update {","counters":[{"col_start":0,"col_end":16,"count":0}]},{"line":"            app_state: array::from_fn(|_| self.gen_wrap(|x| x.gen())),","counters":[{"col_start":0,"col_end":38,"count":0},{"col_start":42,"col_end":56,"count":0},{"col_start":60,"col_end":67,"count":0},{"col_start":67,"col_end":68,"count":0},{"col_start":68,"col_end":70,"count":0}]},{"line":"            delegate: self.gen_wrap(|x| x.gen()),","counters":[{"col_start":0,"col_end":36,"count":0},{"col_start":40,"col_end":47,"count":0},{"col_start":47,"col_end":49,"count":0}]},{"line":"            verification_key: self.gen_wrap(|x| x.gen()),","counters":[{"col_start":0,"col_end":44,"count":0},{"col_start":48,"col_end":55,"count":0},{"col_start":55,"col_end":57,"count":0}]},{"line":"            permissions: self.gen_wrap(|x| x.gen()),","counters":[{"col_start":0,"col_end":39,"count":0},{"col_start":43,"col_end":50,"count":0},{"col_start":50,"col_end":52,"count":0}]},{"line":"            zkapp_uri: self.gen_wrap(|x| x.gen()),","counters":[{"col_start":0,"col_end":37,"count":0},{"col_start":41,"col_end":48,"count":0},{"col_start":48,"col_end":50,"count":0}]},{"line":"            token_symbol: self.gen_wrap(|x| x.gen()),","counters":[{"col_start":0,"col_end":40,"count":0},{"col_start":44,"col_end":51,"count":0},{"col_start":51,"col_end":53,"count":0}]},{"line":"            timing: self.gen_wrap(|x| x.gen_from_account(account)),","counters":[{"col_start":0,"col_end":34,"count":0},{"col_start":38,"col_end":65,"count":0},{"col_start":65,"col_end":67,"count":0}]},{"line":"            voting_for: self.gen_wrap(|x| x.gen()),","counters":[{"col_start":0,"col_end":38,"count":0},{"col_start":42,"col_end":49,"count":0},{"col_start":49,"col_end":51,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl GeneratorFromAccount<zkapp_command::ZkAppPreconditions> for FuzzerCtx {","counters":[]},{"line":"    fn gen_from_account(&mut self, account: &Account) -> zkapp_command::ZkAppPreconditions {","counters":[{"col_start":4,"col_end":92,"count":0}]},{"line":"        zkapp_command::ZkAppPreconditions {","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"            snarked_ledger_hash: self.gen_wrap(|x| x.gen()),","counters":[{"col_start":0,"col_end":47,"count":0},{"col_start":51,"col_end":58,"count":0},{"col_start":58,"col_end":60,"count":0}]},{"line":"            timestamp: self.gen_wrap(|x| x.gen_wrap(|x| x.gen())),","counters":[{"col_start":0,"col_end":37,"count":0},{"col_start":41,"col_end":52,"count":0},{"col_start":56,"col_end":63,"count":10},{"col_start":63,"col_end":64,"count":0},{"col_start":64,"col_end":66,"count":0}]},{"line":"            blockchain_length: self.gen_wrap(|x| x.gen_wrap(|x| x.gen())),","counters":[{"col_start":0,"col_end":45,"count":0},{"col_start":49,"col_end":60,"count":0},{"col_start":64,"col_end":71,"count":0},{"col_start":71,"col_end":72,"count":0},{"col_start":72,"col_end":74,"count":0}]},{"line":"            min_window_density: self.gen_wrap(|x| x.gen_wrap(|x| x.gen())),","counters":[{"col_start":0,"col_end":46,"count":0},{"col_start":50,"col_end":61,"count":10},{"col_start":65,"col_end":72,"count":0},{"col_start":72,"col_end":73,"count":10},{"col_start":73,"col_end":75,"count":0}]},{"line":"            last_vrf_output: (),","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"            total_currency: self.gen_wrap(|x| x.gen_wrap(|x| x.gen_from_account(account))),","counters":[{"col_start":0,"col_end":42,"count":0},{"col_start":46,"col_end":57,"count":0},{"col_start":61,"col_end":88,"count":0},{"col_start":88,"col_end":89,"count":0},{"col_start":89,"col_end":91,"count":0}]},{"line":"            global_slot_since_hard_fork: self.gen_wrap(|x| x.gen_wrap(|x| x.gen())),","counters":[{"col_start":0,"col_end":55,"count":0},{"col_start":59,"col_end":70,"count":0},{"col_start":74,"col_end":81,"count":0},{"col_start":81,"col_end":82,"count":0},{"col_start":82,"col_end":84,"count":0}]},{"line":"            global_slot_since_genesis: self.gen_wrap(|x| x.gen_wrap(|x| x.gen())),","counters":[{"col_start":0,"col_end":53,"count":0},{"col_start":57,"col_end":68,"count":0},{"col_start":72,"col_end":79,"count":0},{"col_start":79,"col_end":80,"count":0},{"col_start":80,"col_end":82,"count":0}]},{"line":"            staking_epoch_data: self.gen(),","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"            next_epoch_data: self.gen(),","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl GeneratorFromAccount<zkapp_command::Account> for FuzzerCtx {","counters":[]},{"line":"    fn gen_from_account(&mut self, account: &Account) -> zkapp_command::Account {","counters":[{"col_start":4,"col_end":81,"count":0}]},{"line":"        zkapp_command::Account {","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"            balance: self.gen_wrap(|x| x.gen_wrap(|x| x.gen_from_account(account))),","counters":[{"col_start":0,"col_end":35,"count":0},{"col_start":39,"col_end":50,"count":0},{"col_start":54,"col_end":81,"count":0},{"col_start":81,"col_end":82,"count":0},{"col_start":82,"col_end":84,"count":0}]},{"line":"            nonce: self.gen_wrap(|x| x.gen_wrap(|x| x.gen_from_account(account))),","counters":[{"col_start":0,"col_end":33,"count":0},{"col_start":37,"col_end":48,"count":0},{"col_start":52,"col_end":79,"count":0},{"col_start":79,"col_end":80,"count":0},{"col_start":80,"col_end":82,"count":0}]},{"line":"            receipt_chain_hash: self.gen_wrap(|x| x.gen()),","counters":[{"col_start":0,"col_end":46,"count":0},{"col_start":50,"col_end":57,"count":0},{"col_start":57,"col_end":59,"count":0}]},{"line":"            delegate: self.gen_wrap(|x| x.gen()),","counters":[{"col_start":0,"col_end":36,"count":0},{"col_start":40,"col_end":47,"count":0},{"col_start":47,"col_end":49,"count":0}]},{"line":"            state: array::from_fn(|_| self.gen_wrap(|x| x.gen())),","counters":[{"col_start":0,"col_end":34,"count":0},{"col_start":38,"col_end":52,"count":0},{"col_start":56,"col_end":63,"count":0},{"col_start":63,"col_end":64,"count":0},{"col_start":64,"col_end":66,"count":0}]},{"line":"            sequence_state: self.gen_wrap(|x| x.gen()),","counters":[{"col_start":0,"col_end":42,"count":0},{"col_start":46,"col_end":53,"count":0},{"col_start":53,"col_end":55,"count":0}]},{"line":"            proved_state: self.gen_wrap(|x| x.rng.gen_bool(0.1)),","counters":[{"col_start":0,"col_end":40,"count":0},{"col_start":44,"col_end":63,"count":0},{"col_start":63,"col_end":65,"count":0}]},{"line":"            is_new: self.gen_wrap(|x| x.rng.gen_bool(0.1)),","counters":[{"col_start":0,"col_end":34,"count":0},{"col_start":38,"col_end":57,"count":0},{"col_start":57,"col_end":59,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl GeneratorFromAccount<AccountPreconditions> for FuzzerCtx {","counters":[]},{"line":"    fn gen_from_account(&mut self, account: &Account) -> AccountPreconditions {","counters":[{"col_start":4,"col_end":79,"count":0}]},{"line":"        match vec![0, 1, 2].choose(&mut self.rng).unwrap() {","counters":[{"col_start":0,"col_end":58,"count":0}]},{"line":"            0 => AccountPreconditions::Accept,","counters":[{"col_start":17,"col_end":45,"count":0}]},{"line":"            1 => AccountPreconditions::Nonce(self.gen_from_account(account)),","counters":[{"col_start":17,"col_end":76,"count":0}]},{"line":"            2 => AccountPreconditions::Full(Box::new(self.gen_from_account(account))),","counters":[{"col_start":17,"col_end":85,"count":0}]},{"line":"            _ => unimplemented!(),","counters":[{"col_start":17,"col_end":33,"count":0}]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl GeneratorFromAccount<zkapp_command::Preconditions> for FuzzerCtx {","counters":[]},{"line":"    fn gen_from_account(&mut self, account: &Account) -> zkapp_command::Preconditions {","counters":[{"col_start":4,"col_end":87,"count":0}]},{"line":"        zkapp_command::Preconditions {","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"            network: self.gen_from_account(account),","counters":[{"col_start":0,"col_end":52,"count":0}]},{"line":"            account: self.gen_from_account(account),","counters":[{"col_start":0,"col_end":52,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<TokenId> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> TokenId {","counters":[{"col_start":4,"col_end":34,"count":0}]},{"line":"        // TODO: randomize","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"        TokenId::default()","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<zkapp_command::Body> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> zkapp_command::Body {","counters":[{"col_start":4,"col_end":46,"count":0}]},{"line":"        let public_key = self.random_keypair().public.into_compressed();","counters":[{"col_start":0,"col_end":72,"count":0}]},{"line":"        let account = self.get_account(&public_key).unwrap();","counters":[{"col_start":0,"col_end":61,"count":0}]},{"line":"","counters":[]},{"line":"        zkapp_command::Body {","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"            public_key,","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"            token_id: self.gen(),","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"            update: self.gen_from_account(&account),","counters":[{"col_start":0,"col_end":52,"count":0}]},{"line":"            balance_change: self.gen_wrap(|x| x.gen_from_account(&account)),","counters":[{"col_start":0,"col_end":42,"count":0},{"col_start":46,"col_end":74,"count":0},{"col_start":74,"col_end":76,"count":0}]},{"line":"            increment_nonce: self.rng.gen_bool(0.9),","counters":[{"col_start":0,"col_end":52,"count":0}]},{"line":"            events: self.gen(),","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"            sequence_events: self.gen(),","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"            call_data: self.gen(),","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"            preconditions: self.gen_from_account(&account),","counters":[{"col_start":0,"col_end":59,"count":0}]},{"line":"            use_full_commitment: self.rng.gen_bool(0.1),","counters":[{"col_start":0,"col_end":56,"count":0}]},{"line":"            caller: self.gen(),","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"            authorization_kind: self.gen(),","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<AccountUpdate> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> AccountUpdate {","counters":[{"col_start":4,"col_end":40,"count":0}]},{"line":"        AccountUpdate {","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"            body: self.gen(),","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"            authorization: self.gen(),","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<zkapp_command::CallForest<AccountUpdate>> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> zkapp_command::CallForest<AccountUpdate> {","counters":[{"col_start":4,"col_end":67,"count":0}]},{"line":"        let mut forest = zkapp_command::CallForest::<AccountUpdate>::new();","counters":[{"col_start":0,"col_end":75,"count":0}]},{"line":"        let count = self.rng.gen_range(0..=8);","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"","counters":[]},{"line":"        for _ in 0..count {","counters":[{"col_start":0,"col_end":25,"count":0},{"col_start":26,"col_end":27,"count":0}]},{"line":"            let calls = if self.rng.gen_bool(0.9) {","counters":[{"col_start":0,"col_end":21,"count":0},{"col_start":27,"col_end":49,"count":0}]},{"line":"                None","counters":[{"col_start":16,"col_end":20,"count":0}]},{"line":"            } else {","counters":[]},{"line":"                // recursion","counters":[]},{"line":"                Some(self.gen())","counters":[{"col_start":16,"col_end":32,"count":0}]},{"line":"            };","counters":[]},{"line":"","counters":[]},{"line":"            forest = forest.cons(calls, self.gen());","counters":[{"col_start":12,"col_end":51,"count":0}]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        forest","counters":[{"col_start":8,"col_end":14,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<ZkAppCommand> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> ZkAppCommand {","counters":[{"col_start":4,"col_end":39,"count":0}]},{"line":"        ZkAppCommand {","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"            fee_payer: self.gen(),","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"            account_updates: self.gen(),","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"            memo: self.gen(),","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl GeneratorFromAccount<PaymentPayload> for FuzzerCtx {","counters":[]},{"line":"    fn gen_from_account(&mut self, account: &Account) -> PaymentPayload {","counters":[{"col_start":4,"col_end":73,"count":0}]},{"line":"        PaymentPayload {","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"            source_pk: account.public_key.clone(),","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"            receiver_pk: self.gen(),","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"            amount: self.gen_from_account(account),","counters":[{"col_start":0,"col_end":51,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"fn sign_payload(keypair: &Keypair, payload: &SignedCommandPayload) -> Signature {","counters":[{"col_start":0,"col_end":81,"count":0}]},{"line":"    let tx = TransactionUnionPayload::of_user_command_payload(payload);","counters":[{"col_start":0,"col_end":71,"count":0}]},{"line":"    let mut signer = mina_signer::create_legacy(NetworkId::TESTNET);","counters":[{"col_start":0,"col_end":68,"count":0}]},{"line":"    signer.sign(keypair, &tx)","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"impl Generator<SignedCommandPayload> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> SignedCommandPayload {","counters":[{"col_start":4,"col_end":47,"count":0}]},{"line":"        let fee_payer_pk = self.random_keypair().public.into_compressed();","counters":[{"col_start":0,"col_end":74,"count":0}]},{"line":"        let account = self.get_account(&fee_payer_pk).unwrap();","counters":[{"col_start":0,"col_end":63,"count":0}]},{"line":"","counters":[]},{"line":"        SignedCommandPayload::create(","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"            self.gen_from_account(&account),","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"            fee_payer_pk,","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"            self.gen_from_account(&account),","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"            self.gen_wrap(|x| x.gen()),","counters":[{"col_start":0,"col_end":26,"count":0},{"col_start":30,"col_end":37,"count":0},{"col_start":37,"col_end":39,"count":0}]},{"line":"            self.gen(),","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"            signed_command::Body::Payment(self.gen_from_account(&account)),","counters":[{"col_start":0,"col_end":75,"count":0}]},{"line":"        )","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<SignedCommand> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> SignedCommand {","counters":[{"col_start":4,"col_end":40,"count":0}]},{"line":"        let payload: SignedCommandPayload = self.gen();","counters":[{"col_start":0,"col_end":55,"count":0}]},{"line":"        let keypair = self.find_keypair(&payload.common.fee_payer_pk).unwrap();","counters":[{"col_start":0,"col_end":79,"count":0}]},{"line":"        let signature = sign_payload(keypair, &payload);","counters":[{"col_start":0,"col_end":56,"count":0}]},{"line":"","counters":[]},{"line":"        SignedCommand {","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"            payload,","counters":[{"col_start":0,"col_end":20,"count":0}]},{"line":"            signer: keypair.public.into_compressed(),","counters":[{"col_start":0,"col_end":53,"count":0}]},{"line":"            signature,","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Generator<Transaction> for FuzzerCtx {","counters":[]},{"line":"    fn gen(&mut self) -> Transaction {","counters":[{"col_start":4,"col_end":37,"count":0}]},{"line":"        let command = match vec![/*0,*/ 1].choose(&mut self.rng).unwrap() {","counters":[{"col_start":12,"col_end":19,"count":0},{"col_start":28,"col_end":73,"count":0}]},{"line":"            0 => UserCommand::SignedCommand(Box::new(self.gen())),","counters":[{"col_start":17,"col_end":65,"count":0}]},{"line":"            1 => UserCommand::ZkAppCommand(Box::new(self.gen())),","counters":[{"col_start":17,"col_end":64,"count":0}]},{"line":"            _ => unimplemented!(),","counters":[{"col_start":17,"col_end":33,"count":0}]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        Transaction::Command(command)","counters":[{"col_start":8,"col_end":37,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]}]}