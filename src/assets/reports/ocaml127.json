{"filename":"src/lib/network_pool/intf.ml","lines":[{"line":"open Async_kernel","counters":[]},{"line":"open Core_kernel","counters":[]},{"line":"open Mina_base","counters":[]},{"line":"open Mina_transaction","counters":[]},{"line":"open Pipe_lib","counters":[]},{"line":"open Network_peer","counters":[]},{"line":"","counters":[]},{"line":"(** A [Resource_pool_base_intf] is a mutable pool of resources that supports","counters":[]},{"line":" *  mutation via some [Resource_pool_diff_intf]. A [Resource_pool_base_intf]","counters":[]},{"line":" *  can only be initialized, and any interaction with it must go through","counters":[]},{"line":" *  its [Resource_pool_diff_intf] *)","counters":[]},{"line":"module type Resource_pool_base_intf = sig","counters":[]},{"line":"  type t [@@deriving sexp_of]","counters":[]},{"line":"","counters":[]},{"line":"  val label : string","counters":[]},{"line":"","counters":[]},{"line":"  type transition_frontier_diff","counters":[]},{"line":"","counters":[]},{"line":"  type transition_frontier","counters":[]},{"line":"","counters":[]},{"line":"  module Config : sig","counters":[]},{"line":"    type t [@@deriving sexp_of]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  (** Diff from a transition frontier extension that would update the resource pool*)","counters":[]},{"line":"  val handle_transition_frontier_diff :","counters":[]},{"line":"    transition_frontier_diff -> t -> unit Deferred.t","counters":[]},{"line":"","counters":[]},{"line":"  val create :","counters":[]},{"line":"       constraint_constants:Genesis_constants.Constraint_constants.t","counters":[]},{"line":"    -> consensus_constants:Consensus.Constants.t","counters":[]},{"line":"    -> time_controller:Block_time.Controller.t","counters":[]},{"line":"    -> expiry_ns:Time_ns.Span.t","counters":[]},{"line":"    -> frontier_broadcast_pipe:","counters":[]},{"line":"         transition_frontier Option.t Broadcast_pipe.Reader.t","counters":[]},{"line":"    -> config:Config.t","counters":[]},{"line":"    -> logger:Logger.t","counters":[]},{"line":"    -> tf_diff_writer:","counters":[]},{"line":"         ( transition_frontier_diff","counters":[]},{"line":"         , Strict_pipe.synchronous","counters":[]},{"line":"         , unit Deferred.t )","counters":[]},{"line":"         Strict_pipe.Writer.t","counters":[]},{"line":"    -> t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(** A [Resource_pool_diff_intf] is a representation of a mutation to","counters":[]},{"line":" *  perform on a [Resource_pool_base_intf]. It includes the logic for","counters":[]},{"line":" *  processing this mutation and applying it to an underlying","counters":[]},{"line":" *  [Resource_pool_base_intf]. *)","counters":[]},{"line":"module type Resource_pool_diff_intf = sig","counters":[]},{"line":"  type pool","counters":[]},{"line":"","counters":[]},{"line":"  type t [@@deriving sexp, to_yojson]","counters":[]},{"line":"","counters":[]},{"line":"  type verified [@@deriving sexp, to_yojson]","counters":[]},{"line":"","counters":[]},{"line":"  (** Part of the diff that was not added to the resource pool*)","counters":[]},{"line":"  type rejected [@@deriving sexp, to_yojson]","counters":[]},{"line":"","counters":[]},{"line":"  val empty : t","counters":[]},{"line":"","counters":[]},{"line":"  val reject_overloaded_diff : verified -> rejected","counters":[]},{"line":"","counters":[]},{"line":"  (** Used to check whether or not information was filtered out of diffs","counters":[]},{"line":"   *  during diff application. Assumes that diff size will be the equal or","counters":[]},{"line":"   *  smaller after application is completed. *)","counters":[]},{"line":"  val size : t -> int","counters":[]},{"line":"","counters":[]},{"line":"  (* TODO","counters":[]},{"line":"     val verified_size : verified -> int","counters":[]},{"line":"  *)","counters":[]},{"line":"","counters":[]},{"line":"  (** How big to consider this diff for purposes of metering. *)","counters":[]},{"line":"  val score : t -> int","counters":[]},{"line":"","counters":[]},{"line":"  (** The maximum \"diff score\" permitted per IP/peer-id per 15 seconds. *)","counters":[]},{"line":"  val max_per_15_seconds : int","counters":[]},{"line":"","counters":[]},{"line":"  val summary : t -> string","counters":[]},{"line":"","counters":[]},{"line":"  (** Warning: It must be safe to call this function asynchronously! *)","counters":[]},{"line":"  val verify :","counters":[]},{"line":"       pool","counters":[]},{"line":"    -> t Envelope.Incoming.t","counters":[]},{"line":"    -> verified Envelope.Incoming.t Deferred.Or_error.t","counters":[]},{"line":"","counters":[]},{"line":"  (** Warning: Using this directly could corrupt the resource pool if it","counters":[]},{"line":"      conincides with applying locally generated diffs or diffs from the network","counters":[]},{"line":"      or diffs from transition frontier extensions.*)","counters":[]},{"line":"  val unsafe_apply :","counters":[]},{"line":"       pool","counters":[]},{"line":"    -> verified Envelope.Incoming.t","counters":[]},{"line":"    -> ( [ `Accept | `Reject ] * t * rejected","counters":[]},{"line":"       , [ `Locally_generated of t * rejected | `Other of Error.t ] )","counters":[]},{"line":"       Deferred.Result.t","counters":[]},{"line":"","counters":[]},{"line":"  val is_empty : t -> bool","counters":[]},{"line":"","counters":[]},{"line":"  val update_metrics :","counters":[]},{"line":"       t Envelope.Incoming.t","counters":[]},{"line":"    -> Mina_net2.Validation_callback.t","counters":[]},{"line":"    -> Logger.t option","counters":[]},{"line":"    -> unit","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(** A [Resource_pool_intf] ties together an associated pair of","counters":[]},{"line":" *  [Resource_pool_base_intf] and [Resource_pool_diff_intf]. *)","counters":[]},{"line":"module type Resource_pool_intf = sig","counters":[]},{"line":"  include Resource_pool_base_intf","counters":[]},{"line":"","counters":[]},{"line":"  module Diff : Resource_pool_diff_intf with type pool := t","counters":[]},{"line":"","counters":[]},{"line":"  (** Locally generated items (user commands and snarks) should be periodically","counters":[]},{"line":"      rebroadcast, to ensure network unreliability doesn't mean they're never","counters":[]},{"line":"      included in a block. This function gets the locally generated items that","counters":[]},{"line":"      are currently rebroadcastable. [has_timed_out] is a function that returns","counters":[]},{"line":"      true if an item that was added at a given time should not be rebroadcast","counters":[]},{"line":"      anymore. If it does, the implementation should not return that item, and","counters":[]},{"line":"      remove it from the set of potentially-rebroadcastable item.","counters":[]},{"line":"  *)","counters":[]},{"line":"  val get_rebroadcastable :","counters":[]},{"line":"    t -> has_timed_out:(Time.t -> [ `Timed_out | `Ok ]) -> Diff.t list","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type Broadcast_callback = sig","counters":[]},{"line":"  type resource_pool_diff","counters":[]},{"line":"","counters":[]},{"line":"  type rejected_diff","counters":[]},{"line":"","counters":[]},{"line":"  type t =","counters":[]},{"line":"    | Local of","counters":[]},{"line":"        (   ( [ `Broadcasted | `Not_broadcasted ]","counters":[]},{"line":"            * resource_pool_diff","counters":[]},{"line":"            * rejected_diff )","counters":[]},{"line":"            Or_error.t","counters":[]},{"line":"         -> unit )","counters":[]},{"line":"    | External of Mina_net2.Validation_callback.t","counters":[]},{"line":"","counters":[]},{"line":"  val drop : resource_pool_diff -> rejected_diff -> t -> unit Deferred.t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(** A [Network_pool_base_intf] is the core implementation of a","counters":[]},{"line":" *  network pool on top of a [Resource_pool_intf]. It wraps","counters":[]},{"line":" *  some [Resource_pool_intf] and provides a generic interface","counters":[]},{"line":" *  for interacting with the [Resource_pool_intf] using the","counters":[]},{"line":" *  network. A [Network_pool_base_intf] wires the [Resource_pool_intf]","counters":[]},{"line":" *  into the network using pipes of diffs and transition frontiers.","counters":[]},{"line":" *  It also provides a way to apply new diffs and rebroadcast them","counters":[]},{"line":" *  to the network if necessary. *)","counters":[]},{"line":"module type Network_pool_base_intf = sig","counters":[]},{"line":"  type t","counters":[]},{"line":"","counters":[]},{"line":"  type resource_pool","counters":[]},{"line":"","counters":[]},{"line":"  type resource_pool_diff","counters":[]},{"line":"","counters":[]},{"line":"  type resource_pool_diff_verified","counters":[]},{"line":"","counters":[]},{"line":"  type rejected_diff","counters":[]},{"line":"","counters":[]},{"line":"  type transition_frontier_diff","counters":[]},{"line":"","counters":[]},{"line":"  type config","counters":[]},{"line":"","counters":[]},{"line":"  type transition_frontier","counters":[]},{"line":"","counters":[]},{"line":"  module Local_sink :","counters":[]},{"line":"    Mina_net2.Sink.S_with_void","counters":[]},{"line":"      with type msg :=","counters":[]},{"line":"        resource_pool_diff","counters":[]},{"line":"        * (   ( [ `Broadcasted | `Not_broadcasted ]","counters":[]},{"line":"              * resource_pool_diff","counters":[]},{"line":"              * rejected_diff )","counters":[]},{"line":"              Or_error.t","counters":[]},{"line":"           -> unit )","counters":[]},{"line":"","counters":[]},{"line":"  module Remote_sink :","counters":[]},{"line":"    Mina_net2.Sink.S_with_void","counters":[]},{"line":"      with type msg :=","counters":[]},{"line":"        resource_pool_diff Envelope.Incoming.t * Mina_net2.Validation_callback.t","counters":[]},{"line":"","counters":[]},{"line":"  module Broadcast_callback :","counters":[]},{"line":"    Broadcast_callback","counters":[]},{"line":"      with type resource_pool_diff := resource_pool_diff","counters":[]},{"line":"       and type rejected_diff := rejected_diff","counters":[]},{"line":"","counters":[]},{"line":"  val create :","counters":[]},{"line":"       config:config","counters":[]},{"line":"    -> constraint_constants:Genesis_constants.Constraint_constants.t","counters":[]},{"line":"    -> consensus_constants:Consensus.Constants.t","counters":[]},{"line":"    -> time_controller:Block_time.Controller.t","counters":[]},{"line":"    -> expiry_ns:Time_ns.Span.t","counters":[]},{"line":"    -> frontier_broadcast_pipe:","counters":[]},{"line":"         transition_frontier Option.t Broadcast_pipe.Reader.t","counters":[]},{"line":"    -> logger:Logger.t","counters":[]},{"line":"    -> log_gossip_heard:bool","counters":[]},{"line":"    -> on_remote_push:(unit -> unit Deferred.t)","counters":[]},{"line":"    -> t * Remote_sink.t * Local_sink.t","counters":[]},{"line":"","counters":[]},{"line":"  val of_resource_pool_and_diffs :","counters":[]},{"line":"       resource_pool","counters":[]},{"line":"    -> logger:Logger.t","counters":[]},{"line":"    -> constraint_constants:Genesis_constants.Constraint_constants.t","counters":[]},{"line":"    -> tf_diffs:transition_frontier_diff Strict_pipe.Reader.t","counters":[]},{"line":"    -> log_gossip_heard:bool","counters":[]},{"line":"    -> on_remote_push:(unit -> unit Deferred.t)","counters":[]},{"line":"    -> t * Remote_sink.t * Local_sink.t","counters":[]},{"line":"","counters":[]},{"line":"  val resource_pool : t -> resource_pool","counters":[]},{"line":"","counters":[]},{"line":"  val broadcasts : t -> resource_pool_diff Linear_pipe.Reader.t","counters":[]},{"line":"","counters":[]},{"line":"  val create_rate_limiter : unit -> Rate_limiter.t","counters":[]},{"line":"","counters":[]},{"line":"  val apply_and_broadcast :","counters":[]},{"line":"       t","counters":[]},{"line":"    -> resource_pool_diff_verified Envelope.Incoming.t","counters":[]},{"line":"    -> Broadcast_callback.t","counters":[]},{"line":"    -> unit Deferred.t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(** A [Snark_resource_pool_intf] is a superset of a","counters":[]},{"line":" *  [Resource_pool_intf] specifically for handling snarks. *)","counters":[]},{"line":"module type Snark_resource_pool_intf = sig","counters":[]},{"line":"  include Resource_pool_base_intf","counters":[]},{"line":"","counters":[]},{"line":"  val make_config :","counters":[]},{"line":"       trust_system:Trust_system.t","counters":[]},{"line":"    -> verifier:Verifier.t","counters":[]},{"line":"    -> disk_location:string","counters":[]},{"line":"    -> Config.t","counters":[]},{"line":"","counters":[]},{"line":"  val add_snark :","counters":[]},{"line":"       ?is_local:bool","counters":[]},{"line":"    -> t","counters":[]},{"line":"    -> work:Transaction_snark_work.Statement.t","counters":[]},{"line":"    -> proof:Ledger_proof.t One_or_two.t","counters":[]},{"line":"    -> fee:Fee_with_prover.t","counters":[]},{"line":"    -> [ `Added | `Statement_not_referenced ] Deferred.t","counters":[]},{"line":"","counters":[]},{"line":"  val request_proof :","counters":[]},{"line":"       t","counters":[]},{"line":"    -> Transaction_snark_work.Statement.t","counters":[]},{"line":"    -> Ledger_proof.t One_or_two.t Priced_proof.t option","counters":[]},{"line":"","counters":[]},{"line":"  val verify_and_act :","counters":[]},{"line":"       t","counters":[]},{"line":"    -> work:","counters":[]},{"line":"         Transaction_snark_work.Statement.t","counters":[]},{"line":"         * Ledger_proof.t One_or_two.t Priced_proof.t","counters":[]},{"line":"    -> sender:Envelope.Sender.t","counters":[]},{"line":"    -> bool Deferred.t","counters":[]},{"line":"","counters":[]},{"line":"  val snark_pool_json : t -> Yojson.Safe.t","counters":[]},{"line":"","counters":[]},{"line":"  val all_completed_work : t -> Transaction_snark_work.Info.t list","counters":[]},{"line":"","counters":[]},{"line":"  val get_logger : t -> Logger.t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(** A [Snark_pool_diff_intf] is the resource pool diff for","counters":[]},{"line":" *  a [Snark_resource_pool_intf]. *)","counters":[]},{"line":"module type Snark_pool_diff_intf = sig","counters":[]},{"line":"  type resource_pool","counters":[]},{"line":"","counters":[]},{"line":"  type t = Mina_wire_types.Network_pool.Snark_pool.Diff_versioned.V2.t =","counters":[]},{"line":"    | Add_solved_work of","counters":[]},{"line":"        Transaction_snark_work.Statement.t","counters":[]},{"line":"        * Ledger_proof.t One_or_two.t Priced_proof.t","counters":[]},{"line":"    | Empty","counters":[]},{"line":"  [@@deriving compare, sexp]","counters":[]},{"line":"","counters":[]},{"line":"  type verified = t [@@deriving compare, sexp]","counters":[]},{"line":"","counters":[]},{"line":"  type compact =","counters":[]},{"line":"    { work : Transaction_snark_work.Statement.t","counters":[]},{"line":"    ; fee : Currency.Fee.t","counters":[]},{"line":"    ; prover : Signature_lib.Public_key.Compressed.t","counters":[]},{"line":"    }","counters":[]},{"line":"  [@@deriving yojson, hash]","counters":[]},{"line":"","counters":[]},{"line":"  type Structured_log_events.t +=","counters":[]},{"line":"    | Snark_work_received of { work : compact; sender : Envelope.Sender.t }","counters":[]},{"line":"    [@@deriving register_event]","counters":[]},{"line":"","counters":[]},{"line":"  include","counters":[]},{"line":"    Resource_pool_diff_intf","counters":[]},{"line":"      with type t := t","counters":[]},{"line":"       and type verified := t","counters":[]},{"line":"       and type pool := resource_pool","counters":[]},{"line":"","counters":[]},{"line":"  val to_compact : t -> compact option","counters":[]},{"line":"","counters":[]},{"line":"  val compact_json : t -> Yojson.Safe.t option","counters":[]},{"line":"","counters":[]},{"line":"  val of_result :","counters":[]},{"line":"       ( (_, _) Snark_work_lib.Work.Single.Spec.t Snark_work_lib.Work.Spec.t","counters":[]},{"line":"       , Ledger_proof.t )","counters":[]},{"line":"       Snark_work_lib.Work.Result.t","counters":[]},{"line":"    -> t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type Transaction_pool_diff_intf = sig","counters":[]},{"line":"  type resource_pool","counters":[]},{"line":"","counters":[]},{"line":"  type t = User_command.t list [@@deriving sexp, of_yojson]","counters":[]},{"line":"","counters":[]},{"line":"  module Diff_error : sig","counters":[]},{"line":"    type t =","counters":[]},{"line":"      | Insufficient_replace_fee","counters":[]},{"line":"      | Duplicate","counters":[]},{"line":"      | Invalid_nonce","counters":[]},{"line":"      | Insufficient_funds","counters":[]},{"line":"      | Overflow","counters":[]},{"line":"      | Bad_token","counters":[]},{"line":"      | Unwanted_fee_token","counters":[]},{"line":"      | Expired","counters":[]},{"line":"      | Overloaded","counters":[]},{"line":"      | Fee_payer_account_not_found","counters":[]},{"line":"      | Fee_payer_not_permitted_to_send","counters":[]},{"line":"    [@@deriving sexp, yojson]","counters":[]},{"line":"","counters":[]},{"line":"    val to_string_hum : t -> string","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Rejected : sig","counters":[]},{"line":"    type t = (User_command.t * Diff_error.t) list [@@deriving sexp, yojson]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  type Structured_log_events.t +=","counters":[]},{"line":"    | Transactions_received of { txns : t; sender : Envelope.Sender.t }","counters":[]},{"line":"    [@@deriving register_event]","counters":[]},{"line":"","counters":[]},{"line":"  include","counters":[]},{"line":"    Resource_pool_diff_intf","counters":[]},{"line":"      with type t := t","counters":[]},{"line":"       and type pool := resource_pool","counters":[]},{"line":"       and type rejected = Rejected.t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type Transaction_resource_pool_intf = sig","counters":[]},{"line":"  type t","counters":[]},{"line":"","counters":[]},{"line":"  include Resource_pool_base_intf with type t := t","counters":[]},{"line":"","counters":[]},{"line":"  val make_config :","counters":[]},{"line":"       trust_system:Trust_system.t","counters":[]},{"line":"    -> pool_max_size:int","counters":[]},{"line":"    -> verifier:Verifier.t","counters":[]},{"line":"    -> genesis_constants:Genesis_constants.t","counters":[]},{"line":"    -> Config.t","counters":[]},{"line":"","counters":[]},{"line":"  val member : t -> Transaction_hash.User_command_with_valid_signature.t -> bool","counters":[]},{"line":"","counters":[]},{"line":"  val transactions :","counters":[]},{"line":"    t -> Transaction_hash.User_command_with_valid_signature.t Sequence.t","counters":[]},{"line":"","counters":[]},{"line":"  val all_from_account :","counters":[]},{"line":"       t","counters":[]},{"line":"    -> Account_id.t","counters":[]},{"line":"    -> Transaction_hash.User_command_with_valid_signature.t list","counters":[]},{"line":"","counters":[]},{"line":"  val get_all : t -> Transaction_hash.User_command_with_valid_signature.t list","counters":[]},{"line":"","counters":[]},{"line":"  val find_by_hash :","counters":[]},{"line":"       t","counters":[]},{"line":"    -> Transaction_hash.t","counters":[]},{"line":"    -> Transaction_hash.User_command_with_valid_signature.t option","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type Base_ledger_intf = sig","counters":[]},{"line":"  type t","counters":[]},{"line":"","counters":[]},{"line":"  module Location : sig","counters":[]},{"line":"    type t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  val location_of_account : t -> Account_id.t -> Location.t option","counters":[]},{"line":"","counters":[]},{"line":"  val location_of_account_batch :","counters":[]},{"line":"    t -> Account_id.t list -> (Account_id.t * Location.t option) list","counters":[]},{"line":"","counters":[]},{"line":"  val get : t -> Location.t -> Account.t option","counters":[]},{"line":"","counters":[]},{"line":"  val accounts : t -> Account_id.Set.t","counters":[]},{"line":"","counters":[]},{"line":"  val get_batch : t -> Location.t list -> (Location.t * Account.t option) list","counters":[]},{"line":"","counters":[]},{"line":"  val detached_signal : t -> unit Deferred.t","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":1}]}]}