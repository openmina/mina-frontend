{"filename":"src/lib/pickles/pseudo/pseudo.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Pickles_types","counters":[]},{"line":"module Domain = Plonk_checks.Domain","counters":[]},{"line":"","counters":[]},{"line":"module Make (Impl : Snarky_backendless.Snark_intf.Run) = struct","counters":[]},{"line":"  open Impl","counters":[]},{"line":"","counters":[]},{"line":"  type ('a, 'n) t = 'n One_hot_vector.T(Impl).t * ('a, 'n) Vector.t","counters":[]},{"line":"","counters":[]},{"line":"  (* TODO: Use version in common. *)","counters":[]},{"line":"  let seal (x : Impl.Field.t) : Impl.Field.t =","counters":[]},{"line":"    let open Impl in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    match Field.to_constant_and_terms x with","counters":[]},{"line":"    | None, [ (x, i) ] when Field.Constant.(equal x one) ->","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"        Snarky_backendless.Cvar.Var i","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    | Some c, [] ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Field.constant c","counters":[]},{"line":"    | _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let y = exists Field.typ ~compute:As_prover.(fun () -> read_var x) in","counters":[{"col_start":63,"col_end":63,"count":0}]},{"line":"        Field.Assert.equal x y ; y","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"","counters":[]},{"line":"  let mask (type n) (bits : n One_hot_vector.T(Impl).t) xs =","counters":[]},{"line":"    with_label __LOC__ (fun () ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        Vector.map","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"          (Vector.zip (bits :> (Boolean.var, n) Vector.t) xs)","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"          ~f:(fun (b, x) -> Field.((b :> t) * x))","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"        |> Vector.fold ~init:Field.zero ~f:Field.( + ) )","counters":[]},{"line":"","counters":[]},{"line":"  let choose : type a n. (a, n) t -> f:(a -> Field.t) -> Field.t =","counters":[]},{"line":"   fun (bits, xs) ~f -> mask bits (Vector.map xs ~f)","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"  module Degree_bound = struct","counters":[]},{"line":"    type nonrec 'n t = (int, 'n) t","counters":[]},{"line":"","counters":[]},{"line":"    let shifted_pow ~crs_max_degree t x =","counters":[]},{"line":"      let pow = Field.(Pcs_batch.pow ~one ~mul) in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      choose t ~f:(fun deg ->","counters":[]},{"line":"          let d = deg mod crs_max_degree in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          pow x (crs_max_degree - d) )","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Domain = struct","counters":[]},{"line":"    let num_shifts = Nat.to_int Pickles_types.Plonk_types.Permuts.n","counters":[{"col_start":30,"col_end":30,"count":2}]},{"line":"","counters":[]},{"line":"    (** Compute the 'shifts' used by the kimchi permutation argument.","counters":[]},{"line":"","counters":[]},{"line":"        These values are selected deterministically-randomly to appear outside","counters":[]},{"line":"        of the domain, so that every choice of [i] and [shift] results in a","counters":[]},{"line":"        distinct value for [shift * domain_generator ^ i].","counters":[]},{"line":"","counters":[]},{"line":"        Note that, for each different domain size, we attempt to use the same","counters":[]},{"line":"        [shifts], and only sample different ones if the shifts are already a","counters":[]},{"line":"        member of the domain (ie. there exists some [i] such that","counters":[]},{"line":"        [shift = domain_generator ^ i]). This ensures that the invariant above","counters":[]},{"line":"        is satisfied.","counters":[]},{"line":"        Optimisation: since the shifts for the domains that we use in practise","counters":[]},{"line":"        are all the same -- none of them have 2-adic order < largest domain","counters":[]},{"line":"        size -- we can hard-code the shifts instead of using a one-hot mask,","counters":[]},{"line":"        and this function adds no constraints to the circuit.","counters":[]},{"line":"    *)","counters":[]},{"line":"    let shifts (type n) ((which, log2s) : (int, n) t)","counters":[]},{"line":"        ~(shifts : log2_size:int -> Field.Constant.t array) :","counters":[]},{"line":"        Field.t Pickles_types.Plonk_types.Shifts.t =","counters":[]},{"line":"      let all_shifts = Vector.map log2s ~f:(fun d -> shifts ~log2_size:d) in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"      match all_shifts with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | [] ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          failwith \"Pseudo.Domain.shifts: no domains were given\"","counters":[]},{"line":"      | shifts :: other_shiftss ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (* Runtime check that the shifts across all domains are consistent.","counters":[]},{"line":"             The optimisation below will not work if this is not true; if the","counters":[]},{"line":"             domain size or the shifts are modified such that this becomes","counters":[]},{"line":"             false, [disabled_not_the_same] can be set to true to enable","counters":[]},{"line":"             dynamic selection within the circuit.","counters":[]},{"line":"          *)","counters":[]},{"line":"          let all_the_same =","counters":[]},{"line":"            Vector.for_all other_shiftss","counters":[]},{"line":"              ~f:(Array.for_all2_exn ~f:Field.Constant.equal shifts)","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"          in","counters":[]},{"line":"          (* Set to true if we do not want to allow dynamic selection of the","counters":[]},{"line":"             shifts at runtime.","counters":[]},{"line":"             This is possible because of the optimisation outlined in the","counters":[]},{"line":"             doc-comment above, but this option and the original code is left","counters":[]},{"line":"             here in case we transition to a larger domain size that uses","counters":[]},{"line":"             different shifts than those for smaller domains.","counters":[]},{"line":"          *)","counters":[]},{"line":"          let disabled_not_the_same = true in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          if all_the_same then Array.map ~f:Field.constant shifts","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"          else if disabled_not_the_same then","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"            failwith \"Pseudo.Domain.shifts: found variable shifts\"","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          else","counters":[]},{"line":"            let open Pickles_types.Plonk_types.Shifts in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let get_ith_shift i =","counters":[]},{"line":"              mask which","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (Vector.map all_shifts ~f:(fun a -> Field.constant a.(i)))","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"            in","counters":[]},{"line":"            Array.init num_shifts ~f:get_ith_shift","counters":[]},{"line":"","counters":[]},{"line":"    let generator (type n) ((which, log2s) : (int, n) t) ~domain_generator =","counters":[]},{"line":"      mask which (Vector.map log2s ~f:(fun d -> domain_generator ~log2_size:d))","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"","counters":[]},{"line":"    type nonrec 'n t = (Domain.t, 'n) t","counters":[]},{"line":"","counters":[]},{"line":"    let to_domain ~shifts:s ~domain_generator (type n) (t : n t) :","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"        Field.t Plonk_checks.plonk_domain =","counters":[]},{"line":"      let log2_sizes = Vector.map (snd t) ~f:Domain.log2_size in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"      let shifts = shifts (fst t, log2_sizes) ~shifts:s in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"      let generator = generator (fst t, log2_sizes) ~domain_generator in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"      let max_log2 =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let _, ds = t in","counters":[]},{"line":"        List.fold (Vector.to_list ds) ~init:0 ~f:(fun acc d ->","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"            Int.max acc (Domain.log2_size d) )","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"      in","counters":[]},{"line":"      object","counters":[]},{"line":"        method shifts = shifts","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"","counters":[]},{"line":"        method generator = generator","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"","counters":[]},{"line":"        method vanishing_polynomial x =","counters":[]},{"line":"          let pow2_pows =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let res = Array.create ~len:(max_log2 + 1) x in","counters":[]},{"line":"            for i = 1 to max_log2 do","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              res.(i) <- Field.square res.(i - 1)","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"            done ;","counters":[]},{"line":"            res","counters":[]},{"line":"          in","counters":[]},{"line":"          let open Field in","counters":[]},{"line":"          seal (choose t ~f:(fun d -> pow2_pows.(Domain.log2_size d)) - one)","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"      end","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}