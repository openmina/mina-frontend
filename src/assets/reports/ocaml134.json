{"filename":"src/lib/merkle_ledger/base_ledger_intf.ml","lines":[{"line":"open Core","counters":[]},{"line":"","counters":[]},{"line":"module type S = sig","counters":[]},{"line":"  (** a Merkle hash associated with the root node *)","counters":[]},{"line":"  type root_hash","counters":[]},{"line":"","counters":[]},{"line":"  (** a Merkle hash associated any non-root node *)","counters":[]},{"line":"  type hash","counters":[]},{"line":"","counters":[]},{"line":"  type account","counters":[]},{"line":"","counters":[]},{"line":"  type key","counters":[]},{"line":"","counters":[]},{"line":"  type token_id","counters":[]},{"line":"","counters":[]},{"line":"  type token_id_set","counters":[]},{"line":"","counters":[]},{"line":"  type account_id","counters":[]},{"line":"","counters":[]},{"line":"  type account_id_set","counters":[]},{"line":"","counters":[]},{"line":"  type index = int","counters":[]},{"line":"","counters":[]},{"line":"  (** no deriving, purposely; signatures that include this one may add deriving *)","counters":[]},{"line":"  type t","counters":[]},{"line":"","counters":[]},{"line":"  module Addr : module type of Merkle_address","counters":[]},{"line":"","counters":[]},{"line":"  module Path : Merkle_path.S with type hash := hash","counters":[]},{"line":"","counters":[]},{"line":"  module Location : sig","counters":[]},{"line":"    type t [@@deriving sexp, compare, hash]","counters":[]},{"line":"","counters":[]},{"line":"    include Comparable.S with type t := t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  include","counters":[]},{"line":"    Syncable_intf.S","counters":[]},{"line":"      with type root_hash := root_hash","counters":[]},{"line":"       and type hash := hash","counters":[]},{"line":"       and type account := account","counters":[]},{"line":"       and type addr := Addr.t","counters":[]},{"line":"       and type path = Path.t","counters":[]},{"line":"       and type t := t","counters":[]},{"line":"","counters":[]},{"line":"  (** list of accounts in the ledger *)","counters":[]},{"line":"  val to_list : t -> account list","counters":[]},{"line":"","counters":[]},{"line":"  (** iterate over all indexes and accounts *)","counters":[]},{"line":"  val iteri : t -> f:(index -> account -> unit) -> unit","counters":[]},{"line":"","counters":[]},{"line":"  (** fold over accounts in the ledger, passing the Merkle address *)","counters":[]},{"line":"  val foldi :","counters":[]},{"line":"    t -> init:'accum -> f:(Addr.t -> 'accum -> account -> 'accum) -> 'accum","counters":[]},{"line":"","counters":[]},{"line":"  (** the set of [account_id]s are ledger elements to skip during the fold,","counters":[]},{"line":"      because they're in a mask","counters":[]},{"line":"  *)","counters":[]},{"line":"  val foldi_with_ignored_accounts :","counters":[]},{"line":"       t","counters":[]},{"line":"    -> account_id_set","counters":[]},{"line":"    -> init:'accum","counters":[]},{"line":"    -> f:(Addr.t -> 'accum -> account -> 'accum)","counters":[]},{"line":"    -> 'accum","counters":[]},{"line":"","counters":[]},{"line":"  (** fold over accounts until stop condition reached when calling [f]; calls [finish] for","counters":[]},{"line":"     result","counters":[]},{"line":" *)","counters":[]},{"line":"  val fold_until :","counters":[]},{"line":"       t","counters":[]},{"line":"    -> init:'accum","counters":[]},{"line":"    -> f:('accum -> account -> ('accum, 'stop) Base.Continue_or_stop.t)","counters":[]},{"line":"    -> finish:('accum -> 'stop)","counters":[]},{"line":"    -> 'stop","counters":[]},{"line":"","counters":[]},{"line":"  (** set of account ids associated with accounts *)","counters":[]},{"line":"  val accounts : t -> account_id_set","counters":[]},{"line":"","counters":[]},{"line":"  (** Get the account id that owns a token. *)","counters":[]},{"line":"  val token_owner : t -> token_id -> account_id option","counters":[]},{"line":"","counters":[]},{"line":"  (** Get the set of all accounts which own a token. *)","counters":[]},{"line":"  val token_owners : t -> account_id_set","counters":[]},{"line":"","counters":[]},{"line":"  (** Get all of the tokens for which a public key has accounts. *)","counters":[]},{"line":"  val tokens : t -> key -> token_id_set","counters":[]},{"line":"","counters":[]},{"line":"  val location_of_account : t -> account_id -> Location.t option","counters":[]},{"line":"","counters":[]},{"line":"  val location_of_account_batch :","counters":[]},{"line":"    t -> account_id list -> (account_id * Location.t option) list","counters":[]},{"line":"","counters":[]},{"line":"  (** This may return an error if the ledger is full. *)","counters":[]},{"line":"  val get_or_create_account :","counters":[]},{"line":"       t","counters":[]},{"line":"    -> account_id","counters":[]},{"line":"    -> account","counters":[]},{"line":"    -> ([ `Added | `Existed ] * Location.t) Or_error.t","counters":[]},{"line":"","counters":[]},{"line":"  (** the ledger should not be used after calling [close] *)","counters":[]},{"line":"  val close : t -> unit","counters":[]},{"line":"","counters":[]},{"line":"  (** for account locations in the ledger, the last (rightmost) filled location *)","counters":[]},{"line":"  val last_filled : t -> Location.t option","counters":[]},{"line":"","counters":[]},{"line":"  val get_uuid : t -> Uuid.t","counters":[]},{"line":"","counters":[]},{"line":"  (** return Some [directory] for ledgers that use a file system, else None *)","counters":[]},{"line":"  val get_directory : t -> string option","counters":[]},{"line":"","counters":[]},{"line":"  val get : t -> Location.t -> account option","counters":[]},{"line":"","counters":[]},{"line":"  val get_batch : t -> Location.t list -> (Location.t * account option) list","counters":[]},{"line":"","counters":[]},{"line":"  val set : t -> Location.t -> account -> unit","counters":[]},{"line":"","counters":[]},{"line":"  val set_batch : t -> (Location.t * account) list -> unit","counters":[]},{"line":"","counters":[]},{"line":"  val get_at_index_exn : t -> int -> account","counters":[]},{"line":"","counters":[]},{"line":"  val set_at_index_exn : t -> int -> account -> unit","counters":[]},{"line":"","counters":[]},{"line":"  val index_of_account_exn : t -> account_id -> int","counters":[]},{"line":"","counters":[]},{"line":"  (** meant to be a fast operation: the root hash is stored, rather","counters":[]},{"line":"      than calculated dynamically","counters":[]},{"line":"  *)","counters":[]},{"line":"  val merkle_root : t -> root_hash","counters":[]},{"line":"","counters":[]},{"line":"  val merkle_path : t -> Location.t -> Path.t","counters":[]},{"line":"","counters":[]},{"line":"  val merkle_path_at_index_exn : t -> int -> Path.t","counters":[]},{"line":"","counters":[]},{"line":"  val remove_accounts_exn : t -> account_id list -> unit","counters":[]},{"line":"","counters":[]},{"line":"  (** Triggers when the ledger has been detached and should no longer be","counters":[]},{"line":"      accessed.","counters":[]},{"line":"  *)","counters":[]},{"line":"  val detached_signal : t -> unit Async_kernel.Deferred.t","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}