{"filename":"src/lib/transition_frontier/full_frontier/full_frontier.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Mina_base","counters":[]},{"line":"module Ledger = Mina_ledger.Ledger","counters":[]},{"line":"open Mina_state","counters":[]},{"line":"open Frontier_base","counters":[]},{"line":"","counters":[]},{"line":"module type CONTEXT = sig","counters":[]},{"line":"  val logger : Logger.t","counters":[]},{"line":"","counters":[]},{"line":"  val precomputed_values : Precomputed_values.t","counters":[]},{"line":"","counters":[]},{"line":"  val constraint_constants : Genesis_constants.Constraint_constants.t","counters":[]},{"line":"","counters":[]},{"line":"  val consensus_constants : Consensus.Constants.t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Node = struct","counters":[]},{"line":"  type t =","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":7,"col_end":7,"count":0}]},{"line":"    { breadcrumb : Breadcrumb.t","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"    ; successor_hashes : State_hash.t list","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"    ; length : int","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":11,"col_end":11,"count":0}]},{"line":"    }","counters":[]},{"line":"  [@@deriving sexp, fields]","counters":[]},{"line":"","counters":[]},{"line":"  type display =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    { length : int","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"    ; state_hash : string","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"    ; blockchain_state : Blockchain_state.display","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"    ; consensus_state : Consensus.Data.Consensus_state.display","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"    }","counters":[]},{"line":"  [@@deriving yojson]","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"","counters":[]},{"line":"  let equal node1 node2 = Breadcrumb.equal node1.breadcrumb node2.breadcrumb","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"","counters":[]},{"line":"  let hash node = Breadcrumb.hash node.breadcrumb","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"","counters":[]},{"line":"  let compare node1 node2 = Breadcrumb.compare node1.breadcrumb node2.breadcrumb","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"","counters":[]},{"line":"  let name t = Breadcrumb.name t.breadcrumb","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"","counters":[]},{"line":"  let display t =","counters":[]},{"line":"    let { Breadcrumb.state_hash; consensus_state; blockchain_state; _ } =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Breadcrumb.display t.breadcrumb","counters":[]},{"line":"    in","counters":[]},{"line":"    { state_hash; blockchain_state; length = t.length; consensus_state }","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Protocol_states_for_root_scan_state = struct","counters":[]},{"line":"  type t = Protocol_state.value State_hash.With_state_hashes.t State_hash.Map.t","counters":[]},{"line":"","counters":[]},{"line":"  let protocol_states_for_next_root_scan_state protocol_states_for_old_root","counters":[]},{"line":"      ~new_scan_state","counters":[]},{"line":"      ~(old_root_state : Protocol_state.value State_hash.With_state_hashes.t) =","counters":[]},{"line":"    let required_state_hashes =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Staged_ledger.Scan_state.required_state_hashes new_scan_state","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"      |> State_hash.Set.to_list","counters":[]},{"line":"    in","counters":[]},{"line":"    let protocol_state_map =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (*Note: Protocol states for the next root should all be in this map","counters":[]},{"line":"        assuming roots transition to their successors and do not skip any node in","counters":[]},{"line":"        between*)","counters":[]},{"line":"      State_hash.Map.set protocol_states_for_old_root","counters":[]},{"line":"        ~key:(State_hash.With_state_hashes.state_hash old_root_state)","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"        ~data:old_root_state","counters":[]},{"line":"    in","counters":[]},{"line":"    List.map required_state_hashes","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ~f:(State_hash.Map.find_exn protocol_state_map)","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(* Invariant: The path from the root to the tip inclusively, will be max_length *)","counters":[]},{"line":"type t =","counters":[]},{"line":"  { root_ledger : Ledger.Any_ledger.witness","counters":[]},{"line":"  ; mutable root : State_hash.t","counters":[]},{"line":"  ; mutable best_tip : State_hash.t","counters":[]},{"line":"  ; logger : Logger.t","counters":[]},{"line":"  ; table : Node.t State_hash.Table.t","counters":[]},{"line":"  ; mutable protocol_states_for_root_scan_state :","counters":[]},{"line":"      Protocol_states_for_root_scan_state.t","counters":[]},{"line":"  ; consensus_local_state : Consensus.Data.Local_state.t","counters":[]},{"line":"  ; max_length : int","counters":[]},{"line":"  ; context : (module CONTEXT)","counters":[]},{"line":"  ; time_controller : Block_time.Controller.t","counters":[]},{"line":"  ; persistent_root_instance : Persistent_root.Instance.t","counters":[]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"let persistent_root_instance { persistent_root_instance; _ } =","counters":[]},{"line":"  persistent_root_instance","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let consensus_local_state { consensus_local_state; _ } = consensus_local_state","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"","counters":[]},{"line":"let all_breadcrumbs t =","counters":[]},{"line":"  List.map (Hashtbl.data t.table) ~f:(fun { breadcrumb; _ } -> breadcrumb)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"","counters":[]},{"line":"let find t hash =","counters":[]},{"line":"  let open Option.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%map node = Hashtbl.find t.table hash in","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"  node.breadcrumb","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let find_exn t hash =","counters":[]},{"line":"  let node = Hashtbl.find_exn t.table hash in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  node.breadcrumb","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let find_protocol_state (t : t) hash =","counters":[]},{"line":"  match find t hash with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | None ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let%map.Option s =","counters":[]},{"line":"        State_hash.Map.find t.protocol_states_for_root_scan_state hash","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"      in","counters":[]},{"line":"      With_hash.data s","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  | Some breadcrumb ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Some","counters":[]},{"line":"        ( breadcrumb |> Breadcrumb.block |> Mina_block.header","counters":[{"col_start":39,"col_end":39,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"        |> Mina_block.Header.protocol_state )","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"","counters":[]},{"line":"let root t = find_exn t t.root","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"let protocol_states_for_root_scan_state t =","counters":[]},{"line":"  t.protocol_states_for_root_scan_state","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let best_tip t = find_exn t t.best_tip","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"","counters":[]},{"line":"let close ~loc _t =","counters":[]},{"line":"  let _loc = loc in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  Mina_metrics.(Gauge.set Transition_frontier.active_breadcrumbs 0.0) ;","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"  ignore ()","counters":[]},{"line":"","counters":[]},{"line":"let create ~context:(module Context : CONTEXT) ~root_data ~root_ledger","counters":[]},{"line":"    ~consensus_local_state ~max_length ~persistent_root_instance","counters":[]},{"line":"    ~time_controller =","counters":[]},{"line":"  (*Printf.eprintf \"MY_LOG.FULL_FRONTIER.CREATE\\n%!\" ;*)","counters":[]},{"line":"  let open Context in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let open Root_data in","counters":[]},{"line":"  let transition_receipt_time = None in","counters":[]},{"line":"  let validated_transition = root_data.transition in","counters":[]},{"line":"  let root_hash = Mina_block.Validated.state_hash validated_transition in","counters":[]},{"line":"  let protocol_states_for_root_scan_state =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    root_data.protocol_states","counters":[]},{"line":"    |> List.map ~f:(fun s -> (State_hash.With_state_hashes.state_hash s, s))","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"    |> State_hash.Map.of_alist_exn","counters":[]},{"line":"  in","counters":[]},{"line":"  let root_protocol_state =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    validated_transition |> Mina_block.Validated.forget |> With_hash.data","counters":[{"col_start":54,"col_end":54,"count":0},{"col_start":72,"col_end":72,"count":0}]},{"line":"    |> Mina_block.header |> Mina_block.Header.protocol_state","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"  in","counters":[]},{"line":"  let root_blockchain_state =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Protocol_state.blockchain_state root_protocol_state","counters":[]},{"line":"  in","counters":[]},{"line":"  let root_blockchain_state_ledger_hash =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Blockchain_state.snarked_ledger_hash root_blockchain_state","counters":[]},{"line":"  in","counters":[]},{"line":"  (*Printf.eprintf \"MY_LOG.FULL_FRONTIER.CREATE1\\n%!\" ;*)","counters":[]},{"line":"  assert (","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":9,"col_end":9,"count":0}]},{"line":"    Frozen_ledger_hash.equal","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"      (Frozen_ledger_hash.of_ledger_hash","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"         (Ledger.Any_ledger.M.merkle_root root_ledger) )","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"      root_blockchain_state_ledger_hash ) ;","counters":[]},{"line":"  let root_breadcrumb =","counters":[]},{"line":"    Breadcrumb.create ~validated_transition","counters":[]},{"line":"      ~staged_ledger:root_data.staged_ledger ~just_emitted_a_proof:false","counters":[]},{"line":"      ~transition_receipt_time","counters":[]},{"line":"  in","counters":[]},{"line":"  let root_node =","counters":[]},{"line":"    { Node.breadcrumb = root_breadcrumb; successor_hashes = []; length = 0 }","counters":[]},{"line":"  in","counters":[]},{"line":"  let table = State_hash.Table.of_alist_exn [ (root_hash, root_node) ] in","counters":[]},{"line":"  Mina_metrics.(Gauge.set Transition_frontier.active_breadcrumbs 1.0) ;","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"  { logger","counters":[]},{"line":"  ; root_ledger","counters":[]},{"line":"  ; root = root_hash","counters":[]},{"line":"  ; best_tip = root_hash","counters":[]},{"line":"  ; table","counters":[]},{"line":"  ; consensus_local_state","counters":[]},{"line":"  ; max_length","counters":[]},{"line":"  ; context = (module Context)","counters":[]},{"line":"  ; protocol_states_for_root_scan_state","counters":[]},{"line":"  ; persistent_root_instance","counters":[]},{"line":"  ; time_controller","counters":[]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"let root_data t =","counters":[]},{"line":"  let open Root_data in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let root = root t in","counters":[]},{"line":"  { transition = Breadcrumb.validated_transition root","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"  ; staged_ledger = Breadcrumb.staged_ledger root","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"  ; protocol_states = State_hash.Map.data t.protocol_states_for_root_scan_state","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"let max_length { max_length; _ } = max_length","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"let root_length t = (Hashtbl.find_exn t.table t.root).length","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"","counters":[]},{"line":"let successor_hashes t hash =","counters":[]},{"line":"  let node = Hashtbl.find_exn t.table hash in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  node.successor_hashes","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let rec successor_hashes_rec t hash =","counters":[]},{"line":"  List.bind (successor_hashes t hash) ~f:(fun succ_hash ->","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"      succ_hash :: successor_hashes_rec t succ_hash )","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"","counters":[]},{"line":"let successors t breadcrumb =","counters":[]},{"line":"  List.map","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    (successor_hashes t (Breadcrumb.state_hash breadcrumb))","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"    ~f:(find_exn t)","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"","counters":[]},{"line":"let rec successors_rec t breadcrumb =","counters":[]},{"line":"  List.bind (successors t breadcrumb) ~f:(fun succ ->","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"      succ :: successors_rec t succ )","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"","counters":[]},{"line":"let path_map ?max_length t breadcrumb ~f =","counters":[]},{"line":"  let rec find_path b count_opt acc =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    match count_opt with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Some count when count <= 0 ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        acc","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    | _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let count_opt = Option.map ~f:(fun x -> x - 1) count_opt in","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"        let elem = f b in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let parent_hash = Breadcrumb.parent_hash b in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        if State_hash.equal (Breadcrumb.state_hash b) t.root then acc","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":49,"col_end":49,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"        else if State_hash.equal parent_hash t.root then elem :: acc","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"        else find_path (find_exn t parent_hash) count_opt (elem :: acc)","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"  in","counters":[]},{"line":"  find_path breadcrumb max_length []","counters":[]},{"line":"","counters":[]},{"line":"let best_tip_path ?max_length t = path_map ?max_length t (best_tip t) ~f:Fn.id","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"","counters":[]},{"line":"let hash_path t breadcrumb = path_map t breadcrumb ~f:Breadcrumb.state_hash","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"let precomputed_values { context = (module Context); _ } =","counters":[]},{"line":"  Context.precomputed_values","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let genesis_constants { context = (module Context); _ } =","counters":[]},{"line":"  Context.precomputed_values.genesis_constants","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let iter t ~f = Hashtbl.iter t.table ~f:(fun n -> f n.breadcrumb)","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"","counters":[]},{"line":"let best_tip_path_length_exn { table; root; best_tip; _ } =","counters":[]},{"line":"  let open Option.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let result =","counters":[]},{"line":"    let%bind best_tip_node = Hashtbl.find table best_tip in","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"    let%map root_node = Hashtbl.find table root in","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"    best_tip_node.length - root_node.length","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  in","counters":[]},{"line":"  result |> Option.value_exn","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let common_ancestor t (bc1 : Breadcrumb.t) (bc2 : Breadcrumb.t) : State_hash.t =","counters":[]},{"line":"  let rec go ancestors1 ancestors2 b1 b2 =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    let sh1 = Breadcrumb.state_hash b1 in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let sh2 = Breadcrumb.state_hash b2 in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Hash_set.add ancestors1 sh1 ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Hash_set.add ancestors2 sh2 ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    if Hash_set.mem ancestors1 sh2 then sh2","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"    else if Hash_set.mem ancestors2 sh1 then sh1","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"    else","counters":[]},{"line":"      let parent_unless_root breadcrumb =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        if State_hash.equal (Breadcrumb.state_hash breadcrumb) t.root then","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"          breadcrumb","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        else find_exn t (Breadcrumb.parent_hash breadcrumb)","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"      in","counters":[]},{"line":"      go ancestors1 ancestors2 (parent_unless_root b1) (parent_unless_root b2)","counters":[{"col_start":49,"col_end":49,"count":0},{"col_start":73,"col_end":73,"count":0}]},{"line":"  in","counters":[]},{"line":"  go","counters":[]},{"line":"    (Hash_set.create (module State_hash))","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"    (Hash_set.create (module State_hash))","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"    bc1 bc2","counters":[]},{"line":"","counters":[]},{"line":"(* TODO: separate visualizer? *)","counters":[]},{"line":"(* Visualize the structure of the transition frontier or a particular node","counters":[]},{"line":" * within the frontier (for debugging purposes). *)","counters":[]},{"line":"module Visualizor = struct","counters":[]},{"line":"  let fold t ~f = Hashtbl.fold t.table ~f:(fun ~key:_ ~data -> f data)","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"","counters":[]},{"line":"  include Visualization.Make_ocamlgraph (Node)","counters":[]},{"line":"","counters":[]},{"line":"  let to_graph t =","counters":[]},{"line":"    fold t ~init:empty ~f:(fun (node : Node.t) graph ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        let graph_with_node = add_vertex graph node in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        List.fold node.successor_hashes ~init:graph_with_node","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ~f:(fun acc_graph successor_state_hash ->","counters":[]},{"line":"            match State_hash.Table.find t.table successor_state_hash with","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            | Some child_node ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                add_edge acc_graph node child_node","counters":[]},{"line":"            | None ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                [%log' debug t.logger]","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                  ~metadata:","counters":[]},{"line":"                    [ (\"state_hash\", State_hash.to_yojson successor_state_hash)","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"                    ; (\"error\", `String \"missing from frontier\")","counters":[]},{"line":"                    ]","counters":[]},{"line":"                  \"Could not visualize state $state_hash: $error\" ;","counters":[]},{"line":"                acc_graph ) )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let visualize ~filename (t : t) =","counters":[]},{"line":"  Out_channel.with_file filename ~f:(fun output_channel ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      let graph = Visualizor.to_graph t in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Visualizor.output_graph output_channel graph )","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"let visualize_to_string t =","counters":[]},{"line":"  let graph = Visualizor.to_graph t in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let buf = Buffer.create 0 in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let formatter = Format.formatter_of_buffer buf in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  Visualizor.fprint_graph formatter graph ;","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  Format.pp_print_flush formatter () ;","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  Buffer.contents buf","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"(* given an heir, calculate the diff that will transition the root to that heir *)","counters":[]},{"line":"let calculate_root_transition_diff t heir =","counters":[]},{"line":"  let root = root t in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let heir_hash = Breadcrumb.state_hash heir in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let heir_transition = Breadcrumb.validated_transition heir in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let heir_staged_ledger = Breadcrumb.staged_ledger heir in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let heir_siblings =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    List.filter (successors t root) ~f:(fun breadcrumb ->","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"        not (State_hash.equal heir_hash (Breadcrumb.state_hash breadcrumb)) )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"  in","counters":[]},{"line":"  let garbage_breadcrumbs =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    List.bind heir_siblings ~f:(fun sibling ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"        sibling :: successors_rec t sibling )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"    |> List.rev","counters":[]},{"line":"  in","counters":[]},{"line":"  let garbage_nodes =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    List.map garbage_breadcrumbs ~f:(fun breadcrumb ->","counters":[]},{"line":"        let open Diff.Node_list in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let transition = Breadcrumb.validated_transition breadcrumb in","counters":[]},{"line":"        let scan_state =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Staged_ledger.scan_state (Breadcrumb.staged_ledger breadcrumb)","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"        in","counters":[]},{"line":"        { transition; scan_state } )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"  in","counters":[]},{"line":"  let protocol_states =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Protocol_states_for_root_scan_state.protocol_states_for_next_root_scan_state","counters":[]},{"line":"      t.protocol_states_for_root_scan_state","counters":[]},{"line":"      ~new_scan_state:(Staged_ledger.scan_state heir_staged_ledger)","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"      ~old_root_state:(Breadcrumb.protocol_state_with_hashes root)","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"  in","counters":[]},{"line":"  let new_root_data =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Root_data.Limited.create ~transition:heir_transition","counters":[]},{"line":"      ~scan_state:(Staged_ledger.scan_state heir_staged_ledger)","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"      ~pending_coinbase:","counters":[]},{"line":"        (Staged_ledger.pending_coinbase_collection heir_staged_ledger)","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"      ~protocol_states","counters":[]},{"line":"  in","counters":[]},{"line":"  let just_emitted_a_proof = Breadcrumb.just_emitted_a_proof heir in","counters":[]},{"line":"  Diff.Full.E.E","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    (Root_transitioned","counters":[]},{"line":"       { new_root = new_root_data","counters":[]},{"line":"       ; garbage = Full garbage_nodes","counters":[]},{"line":"       ; just_emitted_a_proof","counters":[]},{"line":"       } )","counters":[]},{"line":"","counters":[]},{"line":"let move_root ({ context = (module Context); _ } as t) ~new_root_hash","counters":[]},{"line":"    ~new_root_protocol_states ~garbage ~enable_epoch_ledger_sync =","counters":[]},{"line":"  let open Context in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  (* The transition frontier at this point in time has the following mask topology:","counters":[]},{"line":"   *","counters":[]},{"line":"   *   (`s` represents a snarked ledger, `m` represents a mask)","counters":[]},{"line":"   *","counters":[]},{"line":"   *     garbage","counters":[]},{"line":"   *     [m...]","counters":[]},{"line":"   *       ^","counters":[]},{"line":"   *       |          successors","counters":[]},{"line":"   *       m0 -> m1 -> [m...]","counters":[]},{"line":"   *       ^","counters":[]},{"line":"   *       |","counters":[]},{"line":"   *       s","counters":[]},{"line":"   *","counters":[]},{"line":"   * In this diagram, the old root's mask (`m0`) is parented off of the root snarked","counters":[]},{"line":"   * ledger database, and the new root's mask (`m1`) is parented off of the `m0`.","counters":[]},{"line":"   * There is also some garbage parented off of `m0`, and some successors that will","counters":[]},{"line":"   * be kept in the tree after transition which are parented off of `m1`.","counters":[]},{"line":"   *","counters":[]},{"line":"   * In order to move the root, we must form a mask `m1'` with the same merkle root","counters":[]},{"line":"   * as `m1`, except that it is parented directly off of the root snarked ledger","counters":[]},{"line":"   * instead of `m0`. Furthermore, the root snarked ledger `s` may update to another","counters":[]},{"line":"   * merkle root as `s'` if there is a proof emitted in the transition between `m0`","counters":[]},{"line":"   * and `m1`.","counters":[]},{"line":"   *","counters":[]},{"line":"   * To form a mask `m1'` and update the snarked ledger from `s` to `s'` (which is a","counters":[]},{"line":"   * noop in the case of no ledger proof emitted between `m0` and `m1`), we must perform","counters":[]},{"line":"   * the following operations on masks in order:","counters":[]},{"line":"   *","counters":[]},{"line":"   *     0) notify consensus that root transitioned","counters":[]},{"line":"   *     1) unattach and destroy all the garbage (to avoid unecessary trickling of","counters":[]},{"line":"   *        invalidations from `m0` during the next step)","counters":[]},{"line":"   *     2) commit `m1` into `m0`, making `m0` into `m1'` (same merkle root as `m1`), and","counters":[]},{"line":"   *        making `m1` into an identity mask (an empty mask on top of `m1'`).","counters":[]},{"line":"   *     3) safely remove `m1` and reparent all the successors of `m1` onto `m1'`","counters":[]},{"line":"   *     4) create a new temporary mask `mt` with `s` as it's parent","counters":[]},{"line":"   *     5) apply any transactions to `mt` that appear in the transition between `s` and `s'`","counters":[]},{"line":"   *     6) commit `mt` into `s`, turning `s` into `s'`","counters":[]},{"line":"   *     7) unattach and destroy `mt`","counters":[]},{"line":"   *)","counters":[]},{"line":"  let old_root_node = Hashtbl.find_exn t.table t.root in","counters":[]},{"line":"  let new_root_node = Hashtbl.find_exn t.table new_root_hash in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let genesis_ledger_hash =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    old_root_node.breadcrumb |> Breadcrumb.protocol_state","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"    |> Protocol_state.blockchain_state |> Blockchain_state.genesis_ledger_hash","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"  in","counters":[]},{"line":"  (* STEP 0 *)","counters":[]},{"line":"  let () =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    match enable_epoch_ledger_sync with","counters":[]},{"line":"    | `Enabled snarked_ledger ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        O1trace.sync_thread \"update_consensus_local_state\" (fun () ->","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"            Consensus.Hooks.frontier_root_transition","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (Breadcrumb.consensus_state old_root_node.breadcrumb)","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"              (Breadcrumb.consensus_state new_root_node.breadcrumb)","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"              ~local_state:t.consensus_local_state ~snarked_ledger","counters":[]},{"line":"              ~genesis_ledger_hash )","counters":[]},{"line":"    | `Disabled ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ()","counters":[]},{"line":"  in","counters":[]},{"line":"  let new_staged_ledger =","counters":[]},{"line":"    let m0 = Breadcrumb.mask old_root_node.breadcrumb in","counters":[]},{"line":"    let m1 = Breadcrumb.mask new_root_node.breadcrumb in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let m1_hash_pre_commit = Ledger.merkle_root m1 in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    (* STEP 1 *)","counters":[]},{"line":"    List.iter garbage ~f:(fun node ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        let open Diff.Node_list in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let hash = Mina_block.Validated.state_hash node.transition in","counters":[]},{"line":"        let breadcrumb = find_exn t hash in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let mask = Breadcrumb.mask breadcrumb in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        (* this should get garbage collected and should not require additional destruction *)","counters":[]},{"line":"        ignore","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ( Ledger.Maskable.unregister_mask_exn ~loc:__LOC__ mask","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"            : Ledger.unattached_mask ) ;","counters":[]},{"line":"        Hashtbl.remove t.table hash ) ;","counters":[]},{"line":"    (* STEP 2 *)","counters":[]},{"line":"    (* go ahead and remove the old root from the frontier *)","counters":[]},{"line":"    Hashtbl.remove t.table t.root ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    O1trace.sync_thread \"commit_frontier_root_snarked_ledger\" (fun () ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        Ledger.commit m1 ) ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    [%test_result: Ledger_hash.t]","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"      ~message:","counters":[]},{"line":"        \"Merkle root of new root's staged ledger mask is the same after \\","counters":[]},{"line":"         committing\"","counters":[]},{"line":"      ~expect:m1_hash_pre_commit (Ledger.merkle_root m1) ;","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"    [%test_result: Ledger_hash.t]","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"      ~message:","counters":[]},{"line":"        \"Merkle root of old root's staged ledger mask is the same as the new \\","counters":[]},{"line":"         root's staged ledger mask after committing\"","counters":[]},{"line":"      ~expect:m1_hash_pre_commit (Ledger.merkle_root m0) ;","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"    (* STEP 3 *)","counters":[]},{"line":"    (* the staged ledger's mask needs replaced before m1 is made invalid *)","counters":[]},{"line":"    let new_staged_ledger =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Staged_ledger.replace_ledger_exn","counters":[]},{"line":"        (Breadcrumb.staged_ledger new_root_node.breadcrumb)","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"        m0","counters":[]},{"line":"    in","counters":[]},{"line":"    Ledger.remove_and_reparent_exn m1 m1 ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    (* STEPS 4-7 *)","counters":[]},{"line":"    (* we need to perform steps 4-7 iff there was a proof emitted in the scan","counters":[]},{"line":"     * state we are transitioning to *)","counters":[]},{"line":"    if Breadcrumb.just_emitted_a_proof new_root_node.breadcrumb then (","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"      let location =","counters":[]},{"line":"        Persistent_root.Locations.potential_snarked_ledger","counters":[]},{"line":"          t.persistent_root_instance.factory.directory","counters":[]},{"line":"      in","counters":[]},{"line":"      let () =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Ledger.Db.make_checkpoint t.persistent_root_instance.snarked_ledger","counters":[]},{"line":"          ~directory_name:location","counters":[]},{"line":"      in","counters":[]},{"line":"      [%log' info t.logger]","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"        ~metadata:","counters":[]},{"line":"          [ ( \"potential_snarked_ledger_hash\"","counters":[]},{"line":"            , Frozen_ledger_hash.to_yojson @@ Frozen_ledger_hash.of_ledger_hash","counters":[{"col_start":41,"col_end":41,"count":0},{"col_start":78,"col_end":78,"count":0}]},{"line":"              @@ Ledger.Db.merkle_root t.persistent_root_instance.snarked_ledger","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"            )","counters":[]},{"line":"          ]","counters":[]},{"line":"        \"Enqueued a snarked ledger\" ;","counters":[]},{"line":"      Persistent_root.Instance.enqueue_snarked_ledger ~location","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        t.persistent_root_instance ;","counters":[]},{"line":"      let s = t.root_ledger in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      (* STEP 4 *)","counters":[]},{"line":"      let mt =","counters":[]},{"line":"        Ledger.Maskable.register_mask s","counters":[]},{"line":"          (Ledger.Mask.create ~depth:(Ledger.Any_ledger.M.depth s) ())","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"      in","counters":[]},{"line":"      (* STEP 5 *)","counters":[]},{"line":"      Non_empty_list.iter","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (Option.value_exn","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"           (Staged_ledger.proof_txns_with_state_hashes","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"              (Breadcrumb.staged_ledger new_root_node.breadcrumb) ) )","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"        ~f:(fun (txn, state_hash) ->","counters":[]},{"line":"          (*Validate transactions against the protocol state associated with the transaction*)","counters":[]},{"line":"          let txn_state_view =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            find_protocol_state t state_hash","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"            |> Option.value_exn |> Protocol_state.body","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"            |> Protocol_state.Body.view","counters":[]},{"line":"          in","counters":[]},{"line":"          ignore","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ( Or_error.ok_exn","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                (Ledger.apply_transaction ~constraint_constants ~txn_state_view","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"                   mt txn.data )","counters":[]},{"line":"              : Ledger.Transaction_applied.t ) ) ;","counters":[]},{"line":"      (* STEP 6 *)","counters":[]},{"line":"      Ledger.commit mt ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      (* STEP 7 *)","counters":[]},{"line":"      ignore","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ( Ledger.Maskable.unregister_mask_exn ~loc:__LOC__ mt","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"          : Ledger.unattached_mask ) ) ;","counters":[]},{"line":"    new_staged_ledger","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  in","counters":[]},{"line":"  (* rewrite the new root breadcrumb to contain the new root mask *)","counters":[]},{"line":"  let new_root_breadcrumb =","counters":[]},{"line":"    Breadcrumb.create","counters":[]},{"line":"      ~validated_transition:","counters":[]},{"line":"        (Breadcrumb.validated_transition new_root_node.breadcrumb)","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"      ~staged_ledger:new_staged_ledger","counters":[]},{"line":"      ~just_emitted_a_proof:","counters":[]},{"line":"        (Breadcrumb.just_emitted_a_proof new_root_node.breadcrumb)","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"      ~transition_receipt_time:","counters":[]},{"line":"        (Breadcrumb.transition_receipt_time new_root_node.breadcrumb)","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"  in","counters":[]},{"line":"  (*Update the protocol states required for scan state at the new root.","counters":[]},{"line":"    Note: this should be after applying the transactions to the snarked ledger (Step 5)","counters":[]},{"line":"    because the protocol states corresponding to those transactions won't be part","counters":[]},{"line":"    of the new_root_protocol_states since those transactions would have been","counters":[]},{"line":"    deleted from the scan state after emitting the proof*)","counters":[]},{"line":"  let new_protocol_states_map =","counters":[]},{"line":"    new_root_protocol_states","counters":[]},{"line":"    |> List.map ~f:(fun s -> (State_hash.With_state_hashes.state_hash s, s))","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"    |> State_hash.Map.of_alist_exn","counters":[]},{"line":"  in","counters":[]},{"line":"  t.protocol_states_for_root_scan_state <- new_protocol_states_map ;","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let new_root_node = { new_root_node with breadcrumb = new_root_breadcrumb } in","counters":[]},{"line":"  (* update the new root breadcrumb in the frontier *)","counters":[]},{"line":"  Hashtbl.set t.table ~key:new_root_hash ~data:new_root_node ;","counters":[]},{"line":"  (* rewrite the root pointer to the new root hash *)","counters":[]},{"line":"  t.root <- new_root_hash","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"(* calculates the diffs which need to be applied in order to add a breadcrumb to the frontier *)","counters":[]},{"line":"let calculate_diffs ({ context = (module Context); _ } as t) breadcrumb =","counters":[]},{"line":"  let module Context = struct","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    include Context","counters":[]},{"line":"","counters":[]},{"line":"    let logger =","counters":[]},{"line":"      Logger.extend t.logger","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"        [ (\"selection_context\", `String \"comparing new breadcrumb to best tip\")","counters":[]},{"line":"        ]","counters":[]},{"line":"  end in","counters":[]},{"line":"  let open Diff in","counters":[]},{"line":"  O1trace.sync_thread \"calculate_diff_frontier_diffs\" (fun () ->","counters":[]},{"line":"      let breadcrumb_hash = Breadcrumb.state_hash breadcrumb in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let parent_node =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Hashtbl.find_exn t.table (Breadcrumb.parent_hash breadcrumb)","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"      in","counters":[]},{"line":"      let root_node = Hashtbl.find_exn t.table t.root in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let current_best_tip = best_tip t in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let diffs = [ Full.E.E (New_node (Full breadcrumb)) ] in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      (* check if new breadcrumb extends frontier to longer than k *)","counters":[]},{"line":"      let diffs =","counters":[]},{"line":"        if parent_node.length + 1 - root_node.length > t.max_length then","counters":[]},{"line":"          let heir = find_exn t (List.hd_exn (hash_path t breadcrumb)) in","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":43,"col_end":43,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"          calculate_root_transition_diff t heir :: diffs","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"        else diffs","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"      in","counters":[]},{"line":"      (* check if new breadcrumb will be best tip *)","counters":[]},{"line":"      let diffs =","counters":[]},{"line":"        if","counters":[]},{"line":"          Consensus.Hooks.equal_select_status","counters":[]},{"line":"            (Consensus.Hooks.select","counters":[]},{"line":"               ~context:(module Context)","counters":[]},{"line":"               ~existing:","counters":[]},{"line":"                 (Breadcrumb.consensus_state_with_hashes current_best_tip)","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"               ~candidate:(Breadcrumb.consensus_state_with_hashes breadcrumb) )","counters":[{"col_start":64,"col_end":64,"count":0}]},{"line":"            `Take","counters":[]},{"line":"        then Full.E.E (Best_tip_changed breadcrumb_hash) :: diffs","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"        else diffs","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"      in","counters":[]},{"line":"      (* reverse diffs so that they are applied in the correct order *)","counters":[]},{"line":"      List.rev diffs )","counters":[]},{"line":"","counters":[]},{"line":"(* TODO: refactor metrics tracking outside of apply_diff (could maybe even be an extension?) *)","counters":[]},{"line":"let apply_diff (type mutant) t (diff : (Diff.full, mutant) Diff.t)","counters":[]},{"line":"    ~enable_epoch_ledger_sync : mutant * State_hash.t option =","counters":[]},{"line":"  match diff with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | New_node (Full breadcrumb) ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let breadcrumb_hash = Breadcrumb.state_hash breadcrumb in","counters":[]},{"line":"      let parent_hash = Breadcrumb.parent_hash breadcrumb in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let parent_node = Hashtbl.find_exn t.table parent_hash in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let node =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { Node.breadcrumb","counters":[]},{"line":"        ; successor_hashes = []","counters":[]},{"line":"        ; length = parent_node.length + 1","counters":[]},{"line":"        }","counters":[]},{"line":"      in","counters":[]},{"line":"      ( match Hashtbl.add t.table ~key:breadcrumb_hash ~data:node with","counters":[]},{"line":"      | `Duplicate ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          [%log' error t.logger]","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"            \"Same block ($state_hash) was applied to transition frontier more \\","counters":[]},{"line":"             than once; this could indicate that you are running multiple \\","counters":[]},{"line":"             block producers with the same keypair\"","counters":[]},{"line":"            ~metadata:[ (\"state_hash\", State_hash.to_yojson breadcrumb_hash) ]","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"      | `Ok ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Hashtbl.set t.table ~key:parent_hash","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"            ~data:","counters":[]},{"line":"              { parent_node with","counters":[]},{"line":"                successor_hashes =","counters":[]},{"line":"                  breadcrumb_hash :: parent_node.successor_hashes","counters":[]},{"line":"              } ) ;","counters":[]},{"line":"      ((), None)","counters":[]},{"line":"  | Best_tip_changed new_best_tip ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let old_best_tip = t.best_tip in","counters":[]},{"line":"      t.best_tip <- new_best_tip ;","counters":[]},{"line":"      (old_best_tip, None)","counters":[]},{"line":"  | Root_transitioned { new_root; garbage = Full garbage; _ } ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let new_root_hash = (Root_data.Limited.hashes new_root).state_hash in","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"      let old_root_hash = t.root in","counters":[]},{"line":"      let new_root_protocol_states =","counters":[]},{"line":"        Root_data.Limited.protocol_states new_root","counters":[]},{"line":"      in","counters":[]},{"line":"      move_root t ~new_root_hash ~new_root_protocol_states ~garbage","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ~enable_epoch_ledger_sync ;","counters":[]},{"line":"      (old_root_hash, Some new_root_hash)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"module Metrics = struct","counters":[]},{"line":"  (* The max length of a path disjoint from the best tip path. O(n) *)","counters":[]},{"line":"  let longest_fork t =","counters":[]},{"line":"    let children : Breadcrumb.t -> Breadcrumb.t list =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let tbl = State_hash.Table.create () in","counters":[]},{"line":"      Hashtbl.iter t.table ~f:(fun node ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          let b = node.breadcrumb in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          Hashtbl.add_multi tbl ~key:(Breadcrumb.parent_hash b) ~data:b ) ;","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"      fun b -> Hashtbl.find_multi tbl (Breadcrumb.state_hash b)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"    in","counters":[]},{"line":"    let on_best_tip_path : Breadcrumb.t -> bool =","counters":[]},{"line":"      let s = State_hash.Hash_set.create () in","counters":[]},{"line":"      List.iter (best_tip_path t) ~f:(fun b ->","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"          Hash_set.add s (Breadcrumb.state_hash b) ) ;","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"      fun b -> Hash_set.mem s (Breadcrumb.state_hash b)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"    in","counters":[]},{"line":"    let rec longest_fork subtree_root =","counters":[]},{"line":"      (* TODO: Make tail recursive *)","counters":[]},{"line":"      List.map (children subtree_root) ~f:(fun child ->","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"          if on_best_tip_path child then longest_fork child","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"          else 1 + longest_fork child )","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"      |> List.max_elt ~compare:Int.compare","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"      |> Option.value ~default:0","counters":[]},{"line":"    in","counters":[]},{"line":"    longest_fork (find_exn t t.root)","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"  let parent t b = find t (Breadcrumb.parent_hash b)","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"","counters":[]},{"line":"  let empty_blocks_at_best_tip t =","counters":[]},{"line":"    let rec go acc b =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      if","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        not","counters":[]},{"line":"          (List.is_empty","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"             ( Breadcrumb.validated_transition b","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"             |> Mina_block.Validated.valid_commands ) )","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"      then acc","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"      else match parent t b with None -> acc | Some b -> go (acc + 1) b","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"    in","counters":[]},{"line":"    go 0 (best_tip t)","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"","counters":[]},{"line":"  let slot_time { context = (module Context); _ } b =","counters":[]},{"line":"    let open Context in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Breadcrumb.consensus_state b","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"    |> Consensus.Data.Consensus_state.consensus_time","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"    |> Consensus.Data.Consensus_time.to_time ~constants:consensus_constants","counters":[]},{"line":"","counters":[]},{"line":"  let slot_time_to_offset_time_span s =","counters":[]},{"line":"    let r =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Block_time.to_span_since_epoch s","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"      |> Block_time.Span.to_ms","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"      |> (fun x -> Int64.(x / of_int 1000))","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"      |> Int64.to_float","counters":[]},{"line":"    in","counters":[]},{"line":"    r -. Mina_metrics.time_offset_sec","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let has_coinbase b =","counters":[]},{"line":"    let d1, d2 =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ( Breadcrumb.block b |> Mina_block.body","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"      |> Mina_block.Body.staged_ledger_diff )","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"        .diff","counters":[]},{"line":"    in","counters":[]},{"line":"    match (d1.coinbase, d2) with","counters":[]},{"line":"    | Zero, None | Zero, Some { coinbase = Zero; _ } ->","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"        false","counters":[]},{"line":"    | Zero, Some { coinbase = One _; _ } | One _, _ | Two _, _ ->","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":43,"col_end":43,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"        true","counters":[]},{"line":"","counters":[]},{"line":"  let intprop f b = Unsigned.UInt32.to_int (f (Breadcrumb.consensus_state b))","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":72,"col_end":72,"count":0}]},{"line":"","counters":[]},{"line":"  (* Rate of slots filled on the main chain in the k slots preceeding the best tip. *)","counters":[]},{"line":"  let slot_fill_rate ({ context = (module Context); _ } as t) =","counters":[]},{"line":"    let open Context in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let open Consensus.Data.Consensus_state in","counters":[]},{"line":"    let best_tip = best_tip t in","counters":[]},{"line":"    let rec find_ancestor ~f b =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      if f b then `Found b","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"      else","counters":[]},{"line":"        match find t (Breadcrumb.parent_hash b) with","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            `Ended_search_at b","counters":[]},{"line":"        | Some parent ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            find_ancestor ~f parent","counters":[]},{"line":"    in","counters":[]},{"line":"    let start =","counters":[]},{"line":"      let open Consensus.Data.Consensus_state in","counters":[]},{"line":"      let slot = intprop curr_global_slot in","counters":[]},{"line":"      let best_tip_slot = slot best_tip in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let k = Unsigned.UInt32.to_int consensus_constants.k in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      match","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        find_ancestor best_tip ~f:(fun b -> best_tip_slot - slot b >= k)","counters":[{"col_start":44,"col_end":44,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"      with","counters":[]},{"line":"      | `Found b | `Ended_search_at b ->","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"          b","counters":[]},{"line":"    in","counters":[]},{"line":"    let change f = intprop f best_tip - intprop f start in","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"    let length_change = change blockchain_length in","counters":[]},{"line":"    let slot_change = change curr_global_slot in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    if slot_change = 0 then 1.","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"    else Float.of_int length_change /. Float.of_int slot_change","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let update_metrics_with_diff (type mutant)","counters":[]},{"line":"    ({ context = (module Context); _ } as t) (diff : (Diff.full, mutant) Diff.t)","counters":[]},{"line":"    : unit =","counters":[]},{"line":"  let open Context in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let open Metrics in","counters":[]},{"line":"  match diff with","counters":[]},{"line":"  | New_node (Full b) ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Mina_metrics.(","counters":[]},{"line":"        Gauge.inc_one Transition_frontier.active_breadcrumbs ;","counters":[]},{"line":"        Counter.inc_one Transition_frontier.total_breadcrumbs ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Gauge.set Transition_frontier.accepted_block_slot_time_sec","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (slot_time t b |> slot_time_to_offset_time_span))","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"  | Root_transitioned { garbage = Full garbage_breadcrumbs; _ } ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let new_root_breadcrumb = root t in","counters":[]},{"line":"      Mina_metrics.(","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let num_breadcrumbs_removed =","counters":[]},{"line":"          Int.to_float (1 + List.length garbage_breadcrumbs)","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"        in","counters":[]},{"line":"        let num_finalized_staged_txns =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Int.to_float","counters":[]},{"line":"            (List.length","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"               ( Breadcrumb.validated_transition new_root_breadcrumb","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"               |> Mina_block.Validated.valid_commands ) )","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"        in","counters":[]},{"line":"        Gauge.dec Transition_frontier.active_breadcrumbs num_breadcrumbs_removed ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Gauge.set Transition_frontier.recently_finalized_staged_txns","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          num_finalized_staged_txns ;","counters":[]},{"line":"        Counter.inc Transition_frontier.finalized_staged_txns","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          num_finalized_staged_txns ;","counters":[]},{"line":"        Counter.inc_one Transition_frontier.root_transitions ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Transition_frontier.TPS_30min.update num_finalized_staged_txns)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      (* TODO: optimize and add these metrics back in (#2850) *)","counters":[]},{"line":"      (*","counters":[]},{"line":"        let root_snarked_ledger_accounts =","counters":[]},{"line":"          Ledger.Any_ledger.M.to_list t.root_ledger","counters":[]},{"line":"        in","counters":[]},{"line":"        let num_root_snarked_ledger_accounts =","counters":[]},{"line":"          Int.to_float (List.length root_snarked_ledger_accounts)","counters":[]},{"line":"        in","counters":[]},{"line":"        let root_snarked_ledger_total_currency =","counters":[]},{"line":"          Int.to_float","counters":[]},{"line":"            (List.fold_left root_snarked_ledger_accounts ~init:0","counters":[]},{"line":"               ~f:(fun sum account ->","counters":[]},{"line":"                 sum + Currency.Balance.to_int account.balance ))","counters":[]},{"line":"        in","counters":[]},{"line":"        Gauge.set Transition_frontier.root_snarked_ledger_accounts","counters":[]},{"line":"          num_root_snarked_ledger_accounts ;","counters":[]},{"line":"        Gauge.set Transition_frontier.root_snarked_ledger_total_currency","counters":[]},{"line":"          root_snarked_ledger_total_currency ;","counters":[]},{"line":"        *)","counters":[]},{"line":"  | Best_tip_changed _old_best_tip ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let best_tip = best_tip t in","counters":[]},{"line":"      let open Consensus.Data.Consensus_state in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let slot_time = slot_time t best_tip in","counters":[]},{"line":"      let height = blockchain_length (Breadcrumb.consensus_state best_tip) in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"      let is_recent_block =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let now = Block_time.now t.time_controller in","counters":[]},{"line":"        let two_slots =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let one_slot = consensus_constants.block_window_duration_ms in","counters":[]},{"line":"          Block_time.Span.(one_slot + one_slot)","counters":[]},{"line":"        in","counters":[]},{"line":"        Block_time.Span.( <= ) (Block_time.diff now slot_time) two_slots","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"      in","counters":[]},{"line":"      let valid_commands =","counters":[]},{"line":"        Breadcrumb.validated_transition best_tip","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"        |> Mina_block.Validated.valid_commands","counters":[]},{"line":"      in","counters":[]},{"line":"      Mina_metrics.(","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Gauge.set Transition_frontier.best_tip_user_txns","counters":[]},{"line":"          (Int.to_float (List.length valid_commands)) ;","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"        Mina_metrics.(","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Gauge.set Transition_frontier.best_tip_zkapp_txns","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"            (Int.to_float","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"               (List.fold ~init:0","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                  ~f:(fun c cmd ->","counters":[]},{"line":"                    match cmd.data with","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                    | Mina_base.User_command.Poly.Zkapp_command _ ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        c + 1","counters":[]},{"line":"                    | _ ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        c )","counters":[]},{"line":"                  valid_commands ) )) ;","counters":[]},{"line":"        if is_recent_block then","counters":[]},{"line":"          Gauge.set Transition_frontier.best_tip_coinbase","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"            (if has_coinbase best_tip then 1. else 0.) ;","counters":[{"col_start":43,"col_end":43,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"        Gauge.set Transition_frontier.slot_fill_rate (slot_fill_rate t) ;","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"        Gauge.set Transition_frontier.min_window_density","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (Int.to_float (intprop min_window_density best_tip)) ;","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"        Gauge.set Transition_frontier.longest_fork","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (Int.to_float (longest_fork t)) ;","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"        Gauge.set Transition_frontier.best_tip_slot_time_sec","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (slot_time_to_offset_time_span slot_time) ;","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"        Gauge.set Transition_frontier.best_tip_block_height","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (Mina_numbers.Length.to_int height |> Int.to_float) ;","counters":[{"col_start":36,"col_end":36,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"        Gauge.set Transition_frontier.empty_blocks_at_best_tip","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (Int.to_float (empty_blocks_at_best_tip t)))","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"","counters":[]},{"line":"let apply_diffs ({ context = (module Context); _ } as t) diffs","counters":[]},{"line":"    ~enable_epoch_ledger_sync ~has_long_catchup_job =","counters":[]},{"line":"  let open Context in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let open Root_identifier.Stable.Latest in","counters":[]},{"line":"  [%log' trace t.logger] \"Applying %d diffs to full frontier \"","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"    (List.length diffs) ;","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"  let local_state_was_synced_at_start =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Consensus.Hooks.required_local_state_sync ~constants:consensus_constants","counters":[]},{"line":"      ~consensus_state:(Breadcrumb.consensus_state (best_tip t))","counters":[{"col_start":49,"col_end":49,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"      ~local_state:t.consensus_local_state","counters":[]},{"line":"    |> Option.is_none","counters":[]},{"line":"  in","counters":[]},{"line":"  let new_root, diffs_with_mutants =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    List.fold diffs ~init:(None, [])","counters":[]},{"line":"      ~f:(fun (prev_root, diffs_with_mutants) (Diff.Full.E.E diff) ->","counters":[]},{"line":"        let mutant, new_root = apply_diff t diff ~enable_epoch_ledger_sync in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        update_metrics_with_diff t diff ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let new_root =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          match new_root with","counters":[]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              prev_root","counters":[]},{"line":"          | Some state_hash ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Some { state_hash }","counters":[]},{"line":"        in","counters":[]},{"line":"        (new_root, Diff.Full.With_mutant.E (diff, mutant) :: diffs_with_mutants) )","counters":[]},{"line":"  in","counters":[]},{"line":"  [%log' trace t.logger] \"after applying diffs to full frontier\" ;","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"  if","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    (not","counters":[]},{"line":"       ([%equal: [ `Enabled of _ | `Disabled ]] enable_epoch_ledger_sync","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"          `Disabled ) )","counters":[]},{"line":"    && not has_long_catchup_job","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"  then","counters":[]},{"line":"    Debug_assert.debug_assert (fun () ->","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"        match","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Consensus.Hooks.required_local_state_sync","counters":[]},{"line":"            ~constants:consensus_constants","counters":[]},{"line":"            ~consensus_state:","counters":[]},{"line":"              (Breadcrumb.consensus_state","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"                 (Hashtbl.find_exn t.table t.best_tip).breadcrumb )","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"            ~local_state:t.consensus_local_state","counters":[]},{"line":"        with","counters":[]},{"line":"        | Some jobs ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (* But if there wasn't sync work to do when we started, then there shouldn't be now. *)","counters":[]},{"line":"            if local_state_was_synced_at_start then (","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"              [%log' fatal t.logger]","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                \"after lock transition, the best tip consensus state is out of \\","counters":[]},{"line":"                 sync with the local state -- bug in either \\","counters":[]},{"line":"                 required_local_state_sync or frontier_root_transition.\"","counters":[]},{"line":"                ~metadata:","counters":[]},{"line":"                  [ ( \"sync_jobs\"","counters":[]},{"line":"                    , Consensus.Hooks.local_state_sync_to_yojson jobs )","counters":[{"col_start":63,"col_end":63,"count":0}]},{"line":"                  ; ( \"local_state\"","counters":[]},{"line":"                    , Consensus.Data.Local_state.to_yojson","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"                        t.consensus_local_state )","counters":[]},{"line":"                  ; (\"tf_viz\", `String (visualize_to_string t))","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"                  ] ;","counters":[]},{"line":"              failwith","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                \"local state desynced after applying diffs to full frontier\" )","counters":[]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            () ) ;","counters":[]},{"line":"  `New_root_and_diffs_with_mutants (new_root, diffs_with_mutants)","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"module For_tests = struct","counters":[]},{"line":"  open Core_kernel","counters":[]},{"line":"  open Mina_base","counters":[]},{"line":"  open Signature_lib","counters":[]},{"line":"","counters":[]},{"line":"  let find_protocol_state_exn t hash =","counters":[]},{"line":"    match find_protocol_state t hash with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Some s ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        s","counters":[]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        failwith","counters":[]},{"line":"          (sprintf","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"             !\"Protocol state with hash %s not found\"","counters":[]},{"line":"             (State_body_hash.to_yojson hash |> Yojson.Safe.to_string) )","counters":[{"col_start":38,"col_end":38,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"","counters":[]},{"line":"  let equal t1 t2 =","counters":[]},{"line":"    let sort_breadcrumbs = List.sort ~compare:Breadcrumb.compare in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let equal_breadcrumb breadcrumb1 breadcrumb2 =","counters":[]},{"line":"      let open Breadcrumb in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let open Option.Let_syntax in","counters":[]},{"line":"      let get_successor_nodes frontier breadcrumb =","counters":[]},{"line":"        let%map node = Hashtbl.find frontier.table @@ state_hash breadcrumb in","counters":[{"col_start":49,"col_end":49,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"        Node.successor_hashes node","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      in","counters":[]},{"line":"      equal breadcrumb1 breadcrumb2","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"      && State_hash.equal (parent_hash breadcrumb1) (parent_hash breadcrumb2)","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"      && (let%bind successors1 = get_successor_nodes t1 breadcrumb1 in","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"          let%map successors2 = get_successor_nodes t2 breadcrumb2 in","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"          List.equal State_hash.equal","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (successors1 |> List.sort ~compare:State_hash.compare)","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"            (successors2 |> List.sort ~compare:State_hash.compare) )","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"         |> Option.value_map ~default:false ~f:Fn.id","counters":[]},{"line":"    in","counters":[]},{"line":"    List.equal equal_breadcrumb","counters":[]},{"line":"      (all_breadcrumbs t1 |> sort_breadcrumbs)","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"      (all_breadcrumbs t2 |> sort_breadcrumbs)","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"  (* TODO: Don't force here!! *)","counters":[]},{"line":"","counters":[]},{"line":"  let precomputed_values = Lazy.force Precomputed_values.for_unit_tests","counters":[{"col_start":36,"col_end":36,"count":1}]},{"line":"","counters":[]},{"line":"  let constraint_constants = precomputed_values.constraint_constants","counters":[]},{"line":"","counters":[]},{"line":"  let ledger_depth = constraint_constants.ledger_depth","counters":[]},{"line":"","counters":[]},{"line":"  let proof_level = precomputed_values.proof_level","counters":[]},{"line":"","counters":[]},{"line":"  let logger = Logger.null ()","counters":[{"col_start":25,"col_end":25,"count":1}]},{"line":"","counters":[]},{"line":"  module Context = struct","counters":[]},{"line":"    let logger = logger","counters":[]},{"line":"","counters":[]},{"line":"    let constraint_constants = constraint_constants","counters":[]},{"line":"","counters":[]},{"line":"    let precomputed_values = precomputed_values","counters":[]},{"line":"","counters":[]},{"line":"    let consensus_constants = precomputed_values.consensus_constants","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let verifier () =","counters":[]},{"line":"    Async.Thread_safe.block_on_async_exn (fun () ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        Verifier.create ~logger ~proof_level ~constraint_constants","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ~conf_dir:None","counters":[]},{"line":"          ~pids:(Child_processes.Termination.create_pid_table ()) )","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"","counters":[]},{"line":"  module Genesis_ledger = (val precomputed_values.genesis_ledger)","counters":[]},{"line":"","counters":[]},{"line":"  let accounts_with_secret_keys = Lazy.force Genesis_ledger.accounts","counters":[{"col_start":43,"col_end":43,"count":1}]},{"line":"","counters":[]},{"line":"  let max_length = 5","counters":[]},{"line":"","counters":[]},{"line":"  let gen_breadcrumb ~verifier =","counters":[]},{"line":"    Breadcrumb.For_tests.gen ~logger ~precomputed_values ~verifier","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ?trust_system:None ~accounts_with_secret_keys","counters":[]},{"line":"","counters":[]},{"line":"  let gen_breadcrumb_seq ~verifier =","counters":[]},{"line":"    Breadcrumb.For_tests.gen_seq ~logger ~precomputed_values ~verifier","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ?trust_system:None ~accounts_with_secret_keys","counters":[]},{"line":"","counters":[]},{"line":"  module Transfer =","counters":[]},{"line":"    Mina_ledger.Ledger_transfer.Make (Mina_ledger.Ledger) (Mina_ledger.Ledger)","counters":[]},{"line":"","counters":[]},{"line":"  let create_frontier () =","counters":[]},{"line":"    let open Core in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let epoch_ledger_location =","counters":[]},{"line":"      Filename.temp_dir_name ^/ \"epoch_ledger\"","counters":[]},{"line":"      ^ (Uuid_unix.create () |> Uuid.to_string)","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"    in","counters":[]},{"line":"    let consensus_local_state =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Consensus.Data.Local_state.create","counters":[]},{"line":"        ~context:(module Context)","counters":[]},{"line":"        Public_key.Compressed.Set.empty ~genesis_ledger:Genesis_ledger.t","counters":[]},{"line":"        ~genesis_epoch_data:precomputed_values.genesis_epoch_data","counters":[]},{"line":"        ~epoch_ledger_location","counters":[]},{"line":"        ~genesis_state_hash:","counters":[]},{"line":"          (State_hash.With_state_hashes.state_hash","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"             precomputed_values.protocol_state_with_hashes )","counters":[]},{"line":"    in","counters":[]},{"line":"    let root_ledger =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Or_error.ok_exn","counters":[]},{"line":"        (Transfer.transfer_accounts","counters":[]},{"line":"           ~src:(Lazy.force Genesis_ledger.t)","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"           ~dest:(Mina_ledger.Ledger.create ~depth:ledger_depth ()) )","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"    in","counters":[]},{"line":"    Protocol_version.(set_current zero) ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"    let root_data =","counters":[]},{"line":"      let open Root_data in","counters":[]},{"line":"      { transition =","counters":[]},{"line":"          Mina_block.Validated.lift @@ Mina_block.genesis ~precomputed_values","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"      ; staged_ledger =","counters":[]},{"line":"          Staged_ledger.create_exn ~constraint_constants ~ledger:root_ledger","counters":[]},{"line":"      ; protocol_states = []","counters":[]},{"line":"      }","counters":[]},{"line":"    in","counters":[]},{"line":"    let persistent_root =","counters":[]},{"line":"      Persistent_root.create ~logger","counters":[]},{"line":"        ~directory:(Filename.temp_file \"snarked_ledger\" \"\")","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"        ~ledger_depth","counters":[]},{"line":"    in","counters":[]},{"line":"    Persistent_root.reset_to_genesis_exn persistent_root ~precomputed_values ;","counters":[]},{"line":"    let persistent_root_instance =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Persistent_root.create_instance_exn persistent_root","counters":[]},{"line":"    in","counters":[]},{"line":"    create","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ~context:(module Context)","counters":[]},{"line":"      ~root_data","counters":[]},{"line":"      ~root_ledger:","counters":[]},{"line":"        (Mina_ledger.Ledger.Any_ledger.cast","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"           (module Mina_ledger.Ledger)","counters":[]},{"line":"           root_ledger )","counters":[]},{"line":"      ~consensus_local_state ~max_length","counters":[]},{"line":"      ~time_controller:(Block_time.Controller.basic ~logger)","counters":[]},{"line":"      ~persistent_root_instance","counters":[]},{"line":"","counters":[]},{"line":"  let clean_up_persistent_root ~frontier =","counters":[]},{"line":"    let persistent_root_instance = persistent_root_instance frontier in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Persistent_root.Instance.destroy persistent_root_instance","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}