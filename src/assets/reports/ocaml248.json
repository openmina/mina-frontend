{"filename":"src/lib/participating_state/participating_state.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Async_kernel","counters":[]},{"line":"","counters":[]},{"line":"module T = struct","counters":[]},{"line":"  type 'a t = [ `Active of 'a | `Bootstrapping ]","counters":[]},{"line":"","counters":[]},{"line":"  let return value = `Active value","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"","counters":[]},{"line":"  let bind x ~(f : 'a -> 'b t) =","counters":[]},{"line":"    match x with `Active value -> f value | `Bootstrapping -> `Bootstrapping","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"  let map = `Define_using_bind","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"include T","counters":[]},{"line":"include Monad.Make (T)","counters":[]},{"line":"","counters":[]},{"line":"module Option = struct","counters":[]},{"line":"  module T = struct","counters":[]},{"line":"    type 'a t = 'a option T.t","counters":[]},{"line":"","counters":[]},{"line":"    let return value = `Active (Some value)","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"    let bind value_option_status ~f =","counters":[]},{"line":"      match value_option_status with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | `Active (Some value_option) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          f value_option","counters":[]},{"line":"      | `Active None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          `Active None","counters":[]},{"line":"      | `Bootstrapping ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          `Bootstrapping","counters":[]},{"line":"","counters":[]},{"line":"    let map = `Define_using_bind","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  include Monad.Make (T)","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let active = function `Active x -> Some x | `Bootstrapping -> None","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"let bootstrap_err_msg = \"Node is still bootstrapping\"","counters":[]},{"line":"","counters":[]},{"line":"let active_exn = function","counters":[]},{"line":"  | `Active x ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      x","counters":[]},{"line":"  | `Bootstrapping ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      failwith bootstrap_err_msg","counters":[]},{"line":"","counters":[]},{"line":"let active_error = function","counters":[]},{"line":"  | `Active x ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Ok x","counters":[]},{"line":"  | `Bootstrapping ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Or_error.error_string bootstrap_err_msg","counters":[]},{"line":"","counters":[]},{"line":"let to_deferred_or_error : 'a Deferred.t t -> 'a Deferred.Or_error.t = function","counters":[]},{"line":"  | `Active x ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Deferred.map ~f:Or_error.return x","counters":[]},{"line":"  | `Bootstrapping ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Deferred.Or_error.error_string bootstrap_err_msg","counters":[]},{"line":"","counters":[]},{"line":"let rec sequence (list : 'a T.t List.t) : 'a List.t T.t =","counters":[]},{"line":"  match list with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | [] ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      return []","counters":[]},{"line":"  | [ participating_state ] ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      bind participating_state ~f:(fun value -> return [ value ])","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"  | participating_state :: participating_states ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      bind participating_state ~f:(fun x ->","counters":[]},{"line":"          map (sequence participating_states) ~f:(fun sub_result ->","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"              x :: sub_result ) )","counters":[{"col_start":14,"col_end":14,"count":0}]}]}