{"filename":"src/lib/snarky_group_map/checked_map.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"module Aux (Impl : Snarky_backendless.Snark_intf.Run) = struct","counters":[]},{"line":"  open Impl","counters":[]},{"line":"","counters":[]},{"line":"  let non_residue : Field.Constant.t Lazy.t =","counters":[]},{"line":"    let open Field.Constant in","counters":[]},{"line":"    let rec go i = if not (is_square i) then i else go (i + one) in","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"    lazy (go (of_int 2))","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"","counters":[]},{"line":"  let sqrt_exn x =","counters":[]},{"line":"    let y =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      exists Field.typ ~compute:(fun () ->","counters":[]},{"line":"          Field.Constant.sqrt (As_prover.read_var x) )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"    in","counters":[]},{"line":"    assert_square y x ; y","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"","counters":[]},{"line":"  (* let sqrt_flagged : Field.t -> Field.t * Boolean.var = *)","counters":[]},{"line":"  let sqrt_flagged x =","counters":[]},{"line":"    (*","counters":[]},{"line":"       imeckler: I learned this trick from Dan Boneh","counters":[]},{"line":"","counters":[]},{"line":"       m a known non residue","counters":[]},{"line":"","counters":[]},{"line":"       exists is_square : bool, y.","counters":[]},{"line":"       if is_square then assert y*y = x else assert y*y = m * x","counters":[]},{"line":"","counters":[]},{"line":"       <=>","counters":[]},{"line":"","counters":[]},{"line":"       assert (y*y = if is_square then x else m * x)","counters":[]},{"line":"    *)","counters":[]},{"line":"    let is_square =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      exists Boolean.typ ~compute:(fun () ->","counters":[]},{"line":"          Field.Constant.is_square (As_prover.read_var x) )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"    in","counters":[]},{"line":"    let m = Lazy.force non_residue in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    (sqrt_exn (Field.if_ is_square ~then_:x ~else_:(Field.scale x m)), is_square)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":12,"col_end":12,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let wrap (type f) ((module Impl) : f Snarky_backendless.Snark0.m) ~potential_xs","counters":[]},{"line":"    ~y_squared =","counters":[]},{"line":"  let open Impl in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let module A = Aux (Impl) in","counters":[]},{"line":"  let open A in","counters":[]},{"line":"  stage (fun x ->","counters":[]},{"line":"      let x1, x2, x3 = potential_xs x in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let y1, b1 = sqrt_flagged (y_squared ~x:x1)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"      and y2, b2 = sqrt_flagged (y_squared ~x:x2)","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"      and y3, b3 = sqrt_flagged (y_squared ~x:x3) in","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"      Boolean.Assert.any [ b1; b2; b3 ] ;","counters":[]},{"line":"      let x1_is_first = (b1 :> Field.t)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      and x2_is_first = (Boolean.((not b1) && b2) :> Field.t)","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"      and x3_is_first = (Boolean.((not b1) && (not b2) && b3) :> Field.t) in","counters":[{"col_start":46,"col_end":46,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"      ( Field.((x1_is_first * x1) + (x2_is_first * x2) + (x3_is_first * x3))","counters":[]},{"line":"      , Field.((x1_is_first * y1) + (x2_is_first * y2) + (x3_is_first * y3)) ) )","counters":[]},{"line":"","counters":[]},{"line":"module Make","counters":[]},{"line":"    (M : Snarky_backendless.Snark_intf.Run) (P : sig","counters":[]},{"line":"      val params : M.field Group_map.Params.t","counters":[]},{"line":"    end) =","counters":[]},{"line":"struct","counters":[]},{"line":"  open P","counters":[]},{"line":"  include Group_map.Make (M.Field.Constant) (M.Field) (P)","counters":[]},{"line":"  open M","counters":[]},{"line":"","counters":[]},{"line":"  let to_group =","counters":[]},{"line":"    let { Group_map.Spec.a; b } = Group_map.Params.spec params in","counters":[]},{"line":"    unstage","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":10,"col_end":10,"count":0}]},{"line":"      (wrap","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"         (module M)","counters":[]},{"line":"         ~potential_xs","counters":[]},{"line":"         ~y_squared:Field.(fun ~x -> (x * x * x) + scale x a + constant b) )","counters":[{"col_start":37,"col_end":37,"count":0},{"col_start":55,"col_end":55,"count":0},{"col_start":70,"col_end":70,"count":0}]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}