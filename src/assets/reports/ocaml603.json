{"filename":"src/lib/network_pool/rate_limiter.ml","lines":[{"line":"open Core","counters":[]},{"line":"open Network_peer","counters":[]},{"line":"","counters":[]},{"line":"(*","counters":[]},{"line":"   We maintain, for each \"attribute\" (IP, peer ID), how many operations have we","counters":[]},{"line":"   performed for a sender with that attribute in the last X minutes.","counters":[]},{"line":"*)","counters":[]},{"line":"","counters":[]},{"line":"(* The interval over which we limit the max number of actions performed. *)","counters":[]},{"line":"let interval = Time.Span.of_min 5.","counters":[{"col_start":30,"col_end":30,"count":1}]},{"line":"","counters":[]},{"line":"(* An abelian group with a subset of non_negative elements. This is here in","counters":[]},{"line":"   case we want to generalize to more nuanced kinds of score than numerical","counters":[]},{"line":"   values.","counters":[]},{"line":"*)","counters":[]},{"line":"module type Coned_abelian_group = sig","counters":[]},{"line":"  type t [@@deriving sexp, to_yojson]","counters":[]},{"line":"","counters":[]},{"line":"  val ( + ) : t -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"  val ( - ) : t -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"  val is_non_negative : t -> bool","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type Score_intf = Coned_abelian_group","counters":[]},{"line":"","counters":[]},{"line":"module Score : Score_intf with type t = int = struct","counters":[]},{"line":"  open Int","counters":[]},{"line":"","counters":[]},{"line":"  type t = int [@@deriving to_yojson, sexp]","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":11,"col_end":11,"count":0}]},{"line":"","counters":[]},{"line":"  let ( + ) = ( + )","counters":[]},{"line":"","counters":[]},{"line":"  let ( - ) = ( - )","counters":[]},{"line":"","counters":[]},{"line":"  let is_non_negative = is_non_negative","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Record = struct","counters":[]},{"line":"  (* For a given peer, all of the actions within [interval] that peer has performed,","counters":[]},{"line":"     along with the remaining capacity for actions. *)","counters":[]},{"line":"  type t =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    { mutable remaining_capacity : Score.t; elts : (Score.t * Time.t) Queue.t }","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":47,"col_end":47,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"  [@@deriving sexp]","counters":[]},{"line":"","counters":[]},{"line":"  let clear_old_entries r ~now =","counters":[]},{"line":"    let rec go () =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      match Queue.peek r.elts with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ()","counters":[]},{"line":"      | Some (n, t) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let is_old =","counters":[]},{"line":"            let age = Time.diff now t in","counters":[]},{"line":"            Time.Span.(age > interval)","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          in","counters":[]},{"line":"          if is_old then (","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"            r.remaining_capacity <- Score.(r.remaining_capacity + n) ;","counters":[]},{"line":"            ignore (Queue.dequeue_exn r.elts : int * Time.t) ;","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"            go () )","counters":[]},{"line":"    in","counters":[]},{"line":"    go ()","counters":[]},{"line":"","counters":[]},{"line":"  let add (r : t) ~(now : Time.t) ~(score : Score.t) =","counters":[]},{"line":"    let new_score = Score.(r.remaining_capacity - score) in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    if Score.is_non_negative new_score then (","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"      Queue.enqueue r.elts (score, now) ;","counters":[]},{"line":"      r.remaining_capacity <- new_score ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      clear_old_entries r ~now ;","counters":[]},{"line":"      `Ok )","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    else `No_space","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Lru_table (Q : Hash_queue.S) = struct","counters":[]},{"line":"  let max_size = 2048","counters":[]},{"line":"","counters":[]},{"line":"  type t = { table : Record.t Q.t; initial_capacity : Score.t }","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"  [@@deriving sexp_of]","counters":[]},{"line":"","counters":[]},{"line":"  let add ({ table; initial_capacity } : t) (k : Q.key) ~now ~score =","counters":[]},{"line":"    match Q.lookup_and_move_to_back table k with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        if Int.(Q.length table >= max_size) then","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"          ignore (Q.dequeue_front table : Record.t option) ;","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"        Q.enqueue_back_exn table k","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          { Record.remaining_capacity = initial_capacity","counters":[]},{"line":"          ; elts = Queue.create ()","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"          } ;","counters":[]},{"line":"        `Ok","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    | Some r ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Record.add r ~now ~score","counters":[]},{"line":"","counters":[]},{"line":"  let has_capacity t k ~now ~score =","counters":[]},{"line":"    match Q.lookup_and_move_to_back t.table k with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        true","counters":[]},{"line":"    | Some r ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Record.clear_old_entries r ~now ;","counters":[]},{"line":"        Score.(is_non_negative (r.remaining_capacity - score))","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"  let create ~initial_capacity = { initial_capacity; table = Q.create () }","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"","counters":[]},{"line":"  let next_expires ({ table; _ } : t) (k : Q.key) =","counters":[]},{"line":"    match Q.lookup table k with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Time.now ()","counters":[]},{"line":"    | Some { elts; _ } -> (","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        match Queue.peek elts with","counters":[]},{"line":"        | Some (_, time) ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            time","counters":[]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Time.now () )","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Ip = struct","counters":[]},{"line":"  module Hash_queue = Hash_queue.Make (Unix.Inet_addr)","counters":[]},{"line":"  module Lru = Lru_table (Hash_queue)","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Peer_id = struct","counters":[]},{"line":"  module Hash_queue = Hash_queue.Make (Peer.Id)","counters":[]},{"line":"  module Lru = Lru_table (Hash_queue)","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"type t = { by_ip : Ip.Lru.t; by_peer_id : Peer_id.Lru.t } [@@deriving sexp_of]","counters":[{"col_start":0,"col_end":0,"count":0},{"col_start":11,"col_end":11,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"let create ~capacity:(capacity, `Per t) =","counters":[]},{"line":"  let initial_capacity =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    let max_per_second = Float.of_int capacity /. Time.Span.to_sec t in","counters":[{"col_start":36,"col_end":36,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"    Float.round_up (max_per_second *. Time.Span.to_sec interval) |> Float.to_int","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":53,"col_end":53,"count":0},{"col_start":79,"col_end":79,"count":0}]},{"line":"  in","counters":[]},{"line":"  { by_ip = Ip.Lru.create ~initial_capacity","counters":[]},{"line":"  ; by_peer_id = Peer_id.Lru.create ~initial_capacity","counters":[]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"let add { by_ip; by_peer_id } (sender : Envelope.Sender.t) ~now ~score =","counters":[]},{"line":"  match sender with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | Local ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      `Within_capacity","counters":[]},{"line":"  | Remote peer ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let ip = Peer.ip peer in","counters":[]},{"line":"      let id = peer.peer_id in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      if","counters":[]},{"line":"        Ip.Lru.has_capacity by_ip ip ~now ~score","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"        && Peer_id.Lru.has_capacity by_peer_id id ~now ~score","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"      then (","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"        ignore (Ip.Lru.add by_ip ip ~now ~score : [ `No_space | `Ok ]) ;","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"        ignore (Peer_id.Lru.add by_peer_id id ~now ~score : [ `No_space | `Ok ]) ;","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"        `Within_capacity )","counters":[]},{"line":"      else `Capacity_exceeded","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"","counters":[]},{"line":"let next_expires { by_peer_id; _ } (sender : Envelope.Sender.t) =","counters":[]},{"line":"  match sender with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | Local ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Time.now ()","counters":[]},{"line":"  | Remote { peer_id; _ } ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Peer_id.Lru.next_expires by_peer_id peer_id","counters":[]},{"line":"","counters":[]},{"line":"module Summary = struct","counters":[]},{"line":"  type r = { capacity_used : Score.t } [@@deriving to_yojson]","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"  type t = { by_ip : (string * r) list; by_peer_id : (string * r) list }","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":53,"col_end":53,"count":0},{"col_start":54,"col_end":54,"count":0},{"col_start":59,"col_end":59,"count":0},{"col_start":63,"col_end":63,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"  [@@deriving to_yojson]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let summary ({ by_ip; by_peer_id } : t) =","counters":[]},{"line":"  let open Summary in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  to_yojson","counters":[]},{"line":"    { by_ip =","counters":[]},{"line":"        Ip.Hash_queue.foldi by_ip.table ~init:[] ~f:(fun acc ~key ~data ->","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"            ( Unix.Inet_addr.to_string key","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"            , { capacity_used = by_ip.initial_capacity - data.remaining_capacity","counters":[]},{"line":"              } )","counters":[]},{"line":"            :: acc )","counters":[]},{"line":"    ; by_peer_id =","counters":[]},{"line":"        Peer_id.Hash_queue.foldi by_peer_id.table ~init:[]","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"          ~f:(fun acc ~key ~data ->","counters":[]},{"line":"            ( Peer.Id.to_string key","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"            , { capacity_used = by_ip.initial_capacity - data.remaining_capacity","counters":[]},{"line":"              } )","counters":[]},{"line":"            :: acc )","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":4,"count":1}]}]}