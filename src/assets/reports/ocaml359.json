{"filename":"src/lib/transaction_snark/test/util.ml","lines":[{"line":"open Core","counters":[]},{"line":"open Currency","counters":[]},{"line":"open Mina_base","counters":[]},{"line":"open Signature_lib","counters":[]},{"line":"module Tick = Snark_params.Tick","counters":[]},{"line":"module Impl = Pickles.Impls.Step","counters":[]},{"line":"module Zkapp_command_segment = Transaction_snark.Zkapp_command_segment","counters":[]},{"line":"module Statement = Transaction_snark.Statement","counters":[]},{"line":"","counters":[]},{"line":"let constraint_constants = Genesis_constants.Constraint_constants.compiled","counters":[]},{"line":"","counters":[]},{"line":"let genesis_constants = Genesis_constants.compiled","counters":[]},{"line":"","counters":[]},{"line":"let proof_level = Genesis_constants.Proof_level.compiled","counters":[]},{"line":"","counters":[]},{"line":"let consensus_constants =","counters":[]},{"line":"  Consensus.Constants.create ~constraint_constants","counters":[]},{"line":"    ~protocol_constants:genesis_constants.protocol","counters":[]},{"line":"","counters":[]},{"line":"module Ledger = struct","counters":[]},{"line":"  include Mina_ledger.Ledger","counters":[]},{"line":"","counters":[]},{"line":"  let merkle_root t = Frozen_ledger_hash.of_ledger_hash @@ merkle_root t","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Sparse_ledger = struct","counters":[]},{"line":"  include Mina_ledger.Sparse_ledger","counters":[]},{"line":"","counters":[]},{"line":"  let merkle_root t = Frozen_ledger_hash.of_ledger_hash @@ merkle_root t","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let ledger_depth = constraint_constants.ledger_depth","counters":[]},{"line":"","counters":[]},{"line":"let snark_module =","counters":[]},{"line":"  lazy","counters":[]},{"line":"    ( module Transaction_snark.Make (struct","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let constraint_constants = constraint_constants","counters":[]},{"line":"","counters":[]},{"line":"      let proof_level = proof_level","counters":[]},{"line":"    end) : Transaction_snark.S )","counters":[]},{"line":"","counters":[]},{"line":"let genesis_state_body =","counters":[]},{"line":"  let compile_time_genesis =","counters":[]},{"line":"    let open Staged_ledger_diff in","counters":[]},{"line":"    (*not using Precomputed_values.for_unit_test because of dependency cycle*)","counters":[]},{"line":"    Mina_state.Genesis_protocol_state.t","counters":[]},{"line":"      ~genesis_ledger:Genesis_ledger.(Packed.t for_unit_tests)","counters":[{"col_start":45,"col_end":45,"count":1}]},{"line":"      ~genesis_epoch_data:Consensus.Genesis_epoch_data.for_unit_tests","counters":[]},{"line":"      ~constraint_constants ~consensus_constants ~genesis_body_reference","counters":[]},{"line":"  in","counters":[]},{"line":"  compile_time_genesis.data |> Mina_state.Protocol_state.body","counters":[{"col_start":60,"col_end":60,"count":1}]},{"line":"","counters":[]},{"line":"let genesis_state_view = Mina_state.Protocol_state.Body.view genesis_state_body","counters":[{"col_start":59,"col_end":59,"count":1}]},{"line":"","counters":[]},{"line":"let genesis_state_body_hash =","counters":[]},{"line":"  Mina_state.Protocol_state.Body.hash genesis_state_body","counters":[{"col_start":36,"col_end":36,"count":1}]},{"line":"","counters":[]},{"line":"let init_stack = Pending_coinbase.Stack.empty","counters":[]},{"line":"","counters":[]},{"line":"let pending_coinbase_state_stack ~state_body_hash =","counters":[]},{"line":"  { Transaction_snark.Pending_coinbase_stack_state.source = init_stack","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  ; target = Pending_coinbase.Stack.push_state state_body_hash init_stack","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"let apply_zkapp_command ledger zkapp_command =","counters":[]},{"line":"  let zkapp_command =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    match zkapp_command with","counters":[]},{"line":"    | [] ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        []","counters":[]},{"line":"    | [ ps ] ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [ ( `Pending_coinbase_init_stack init_stack","counters":[]},{"line":"          , `Pending_coinbase_of_statement","counters":[]},{"line":"              (pending_coinbase_state_stack","counters":[]},{"line":"                 ~state_body_hash:genesis_state_body_hash )","counters":[]},{"line":"          , ps )","counters":[]},{"line":"        ]","counters":[]},{"line":"    | ps1 :: ps2 :: rest ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let ps1 =","counters":[]},{"line":"          ( `Pending_coinbase_init_stack init_stack","counters":[]},{"line":"          , `Pending_coinbase_of_statement","counters":[]},{"line":"              (pending_coinbase_state_stack","counters":[]},{"line":"                 ~state_body_hash:genesis_state_body_hash )","counters":[]},{"line":"          , ps1 )","counters":[]},{"line":"        in","counters":[]},{"line":"        let pending_coinbase_state_stack =","counters":[]},{"line":"          pending_coinbase_state_stack ~state_body_hash:genesis_state_body_hash","counters":[]},{"line":"        in","counters":[]},{"line":"        let unchanged_stack_state ps =","counters":[]},{"line":"          ( `Pending_coinbase_init_stack init_stack","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          , `Pending_coinbase_of_statement","counters":[]},{"line":"              { pending_coinbase_state_stack with","counters":[]},{"line":"                source = pending_coinbase_state_stack.target","counters":[]},{"line":"              }","counters":[]},{"line":"          , ps )","counters":[]},{"line":"        in","counters":[]},{"line":"        let ps2 = unchanged_stack_state ps2 in","counters":[]},{"line":"        ps1 :: ps2 :: List.map rest ~f:unchanged_stack_state","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"  in","counters":[]},{"line":"  let witnesses, final_ledger =","counters":[]},{"line":"    Transaction_snark.zkapp_command_witnesses_exn ~constraint_constants","counters":[]},{"line":"      ~state_body:genesis_state_body ~fee_excess:Amount.Signed.zero","counters":[]},{"line":"      (`Ledger ledger) zkapp_command","counters":[]},{"line":"  in","counters":[]},{"line":"  let open Impl in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  List.iter (List.rev witnesses) ~f:(fun (witness, spec, statement) ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"      run_and_check (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"          let s =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            exists Statement.With_sok.typ ~compute:(fun () -> statement)","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"          in","counters":[]},{"line":"          let _opt_snapp_stmt =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Transaction_snark.Base.Zkapp_command_snark.main","counters":[]},{"line":"              ~constraint_constants","counters":[]},{"line":"              (Zkapp_command_segment.Basic.to_single_list spec)","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"              s ~witness","counters":[]},{"line":"          in","counters":[]},{"line":"          fun () -> () )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":20,"col_end":20,"count":0}]},{"line":"      |> Or_error.ok_exn ) ;","counters":[]},{"line":"  final_ledger","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let trivial_zkapp =","counters":[]},{"line":"  lazy","counters":[]},{"line":"    (Transaction_snark.For_tests.create_trivial_snapp ~constraint_constants ())","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"let check_zkapp_command_with_merges_exn ?expected_failure","counters":[]},{"line":"    ?(state_body = genesis_state_body) ledger zkapp_commands =","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"  let module T = (val Lazy.force snark_module) in","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"  (*TODO: merge multiple zkApp transactions*)","counters":[]},{"line":"  let state_view = Mina_state.Protocol_state.Body.view state_body in","counters":[]},{"line":"  let state_body_hash = Mina_state.Protocol_state.Body.hash state_body in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  Async.Deferred.List.iter zkapp_commands ~f:(fun zkapp_command ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      match","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Or_error.try_with (fun () ->","counters":[]},{"line":"            Transaction_snark.zkapp_command_witnesses_exn ~constraint_constants","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              ~state_body ~fee_excess:Amount.Signed.zero (`Ledger ledger)","counters":[]},{"line":"              [ ( `Pending_coinbase_init_stack init_stack","counters":[]},{"line":"                , `Pending_coinbase_of_statement","counters":[]},{"line":"                    (pending_coinbase_state_stack ~state_body_hash)","counters":[]},{"line":"                , zkapp_command )","counters":[]},{"line":"              ] )","counters":[]},{"line":"      with","counters":[]},{"line":"      | Error e -> (","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          match expected_failure with","counters":[]},{"line":"          | Some failure ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              assert (","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                String.is_substring (Error.to_string_hum e)","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"                  ~substring:(Transaction_status.Failure.to_string failure) ) ;","counters":[{"col_start":65,"col_end":65,"count":0}]},{"line":"              Async.Deferred.unit","counters":[]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              failwith","counters":[]},{"line":"                (sprintf \"apply_transaction failed with %s\"","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                   (Error.to_string_hum e) ) )","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"      | Ok (witnesses, _) -> (","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let open Async.Deferred.Let_syntax in","counters":[]},{"line":"          let applied =","counters":[]},{"line":"            Ledger.apply_transaction ~constraint_constants","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"              ~txn_state_view:state_view ledger","counters":[]},{"line":"              (Mina_transaction.Transaction.Command (Zkapp_command zkapp_command)","counters":[]},{"line":"              )","counters":[]},{"line":"            |> Or_error.ok_exn","counters":[]},{"line":"          in","counters":[]},{"line":"          match applied.varying with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | Command (Zkapp_command { command; _ }) -> (","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              match command.status with","counters":[]},{"line":"              | Applied -> (","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  match expected_failure with","counters":[]},{"line":"                  | Some failure ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      failwith","counters":[]},{"line":"                        (sprintf","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                           !\"Application did not fail as expected. Expected \\","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                             failure: \\","counters":[]},{"line":"                             %{sexp:Mina_base.Transaction_status.Failure.t}\"","counters":[]},{"line":"                           failure )","counters":[]},{"line":"                  | None ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      let%map p =","counters":[]},{"line":"                        match List.rev witnesses with","counters":[]},{"line":"                        | [] ->","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            failwith \"no witnesses generated\"","counters":[]},{"line":"                        | (witness, spec, stmt) :: rest ->","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            let open Async.Deferred.Or_error.Let_syntax in","counters":[]},{"line":"                            let%bind p1 =","counters":[]},{"line":"                              Async.Deferred.Or_error.try_with (fun () ->","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"                                  T.of_zkapp_command_segment_exn ~statement:stmt","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"                                    ~witness ~spec )","counters":[]},{"line":"                            in","counters":[]},{"line":"                            Async.Deferred.List.fold ~init:(Ok p1) rest","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                              ~f:(fun acc (witness, spec, stmt) ->","counters":[]},{"line":"                                let%bind prev = Async.Deferred.return acc in","counters":[{"col_start":68,"col_end":68,"count":0}]},{"line":"                                let%bind curr =","counters":[]},{"line":"                                  Async.Deferred.Or_error.try_with (fun () ->","counters":[{"col_start":65,"col_end":65,"count":0}]},{"line":"                                      T.of_zkapp_command_segment_exn","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"                                        ~statement:stmt ~witness ~spec )","counters":[]},{"line":"                                in","counters":[]},{"line":"                                let sok_digest =","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                                  Sok_message.create ~fee:Fee.zero","counters":[]},{"line":"                                    ~prover:","counters":[]},{"line":"                                      (Quickcheck.random_value","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"                                         Public_key.Compressed.gen )","counters":[]},{"line":"                                  |> Sok_message.digest","counters":[]},{"line":"                                in","counters":[]},{"line":"                                T.merge ~sok_digest prev curr )","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                      in","counters":[]},{"line":"                      let p = Or_error.ok_exn p in","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                      let target_ledger_root_snark =","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        (Transaction_snark.statement p).target.ledger","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                      in","counters":[]},{"line":"                      let target_ledger_root = Ledger.merkle_root ledger in","counters":[]},{"line":"                      [%test_eq: Ledger_hash.t] target_ledger_root","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"                        target_ledger_root_snark )","counters":[]},{"line":"              | Failed failure_tbl -> (","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  match expected_failure with","counters":[]},{"line":"                  | None ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      failwith","counters":[]},{"line":"                        (sprintf","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                           !\"Application failed. Failure statuses: %{sexp: \\","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                             Mina_base.Transaction_status.Failure.Collection.t}\"","counters":[]},{"line":"                           failure_tbl )","counters":[]},{"line":"                  | Some failure ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      let failures = List.concat failure_tbl in","counters":[]},{"line":"                      assert (not (List.is_empty failures)) ;","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"                      let failed_as_expected =","counters":[]},{"line":"                        (*Check that there's at least the expected failure*)","counters":[]},{"line":"                        List.fold failures ~init:false ~f:(fun acc f ->","counters":[]},{"line":"                            acc","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"                            || Mina_base.Transaction_status.Failure.(","counters":[]},{"line":"                                 equal failure f) )","counters":[{"col_start":37,"col_end":37,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"                      in","counters":[]},{"line":"                      if not failed_as_expected then","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        failwith","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          (sprintf","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"                             !\"Application failed but not as expected. \\","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                               Expected failure: \\","counters":[]},{"line":"                               %{sexp:Mina_base.Transaction_status.Failure.t} \\","counters":[]},{"line":"                               Failure statuses: %{sexp: \\","counters":[]},{"line":"                               Mina_base.Transaction_status.Failure.Collection.t}\"","counters":[]},{"line":"                             failure failure_tbl )","counters":[]},{"line":"                      else Async.Deferred.unit ) )","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"          | _ ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              failwith \"zkapp_command expected\" ) )","counters":[]},{"line":"","counters":[]},{"line":"let dummy_rule self : _ Pickles.Inductive_rule.t =","counters":[]},{"line":"  let open Tick in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  { identifier = \"dummy\"","counters":[]},{"line":"  ; prevs = [ self; self ]","counters":[]},{"line":"  ; main =","counters":[]},{"line":"      (fun { public_input = _ } ->","counters":[]},{"line":"        let s =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Run.exists Field.typ ~compute:(fun () -> Run.Field.Constant.zero)","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"        in","counters":[]},{"line":"        let public_input =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Run.exists Zkapp_statement.typ ~compute:(fun () -> assert false)","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"        in","counters":[]},{"line":"        let proof =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Run.exists (Typ.Internal.ref ()) ~compute:(fun () -> assert false)","counters":[{"col_start":37,"col_end":37,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"        in","counters":[]},{"line":"        Impl.run_checked (Transaction_snark.dummy_constraints ()) ;","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"        (* Unsatisfiable. *)","counters":[]},{"line":"        Run.Field.(Assert.equal s (s + one)) ;","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"        { previous_proof_statements =","counters":[]},{"line":"            [ { public_input; proof; proof_must_verify = Boolean.true_ }","counters":[]},{"line":"            ; { public_input; proof; proof_must_verify = Boolean.true_ }","counters":[]},{"line":"            ]","counters":[]},{"line":"        ; public_output = ()","counters":[]},{"line":"        ; auxiliary_output = ()","counters":[]},{"line":"        } )","counters":[]},{"line":"  ; uses_lookup = false","counters":[]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"let gen_snapp_ledger =","counters":[]},{"line":"  let open Mina_transaction_logic.For_tests in","counters":[]},{"line":"  let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"  let%bind test_spec = Test_spec.gen in","counters":[]},{"line":"  let pks =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Public_key.Compressed.Set.of_list","counters":[]},{"line":"      (List.map (Array.to_list test_spec.init_ledger) ~f:(fun s ->","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"           Public_key.compress (fst s).public_key ) )","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%map kp =","counters":[]},{"line":"    Quickcheck.Generator.filter Keypair.gen ~f:(fun kp ->","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"        not","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (Public_key.Compressed.Set.mem pks","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"             (Public_key.compress kp.public_key) ) )","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"  in","counters":[]},{"line":"  (test_spec, kp)","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let test_snapp_update ?expected_failure ?state_body ?snapp_permissions ~vk","counters":[]},{"line":"    ~zkapp_prover test_spec ~init_ledger ~snapp_pk =","counters":[]},{"line":"  let open Mina_transaction_logic.For_tests in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  Ledger.with_ledger ~depth:ledger_depth ~f:(fun ledger ->","counters":[]},{"line":"      Async.Thread_safe.block_on_async_exn (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          Init_ledger.init (module Ledger.Ledger_inner) init_ledger ledger ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          (*create a snapp account*)","counters":[]},{"line":"          Transaction_snark.For_tests.create_trivial_zkapp_account","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ?permissions:snapp_permissions ~vk ~ledger snapp_pk ;","counters":[]},{"line":"          let open Async.Deferred.Let_syntax in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let%bind zkapp_command =","counters":[]},{"line":"            Transaction_snark.For_tests.update_states ~zkapp_prover","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"              ~constraint_constants test_spec","counters":[]},{"line":"          in","counters":[]},{"line":"          check_zkapp_command_with_merges_exn ?expected_failure ?state_body","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ledger [ zkapp_command ] ) )","counters":[]},{"line":"","counters":[]},{"line":"let permissions_from_update (update : Account_update.Update.t) ~auth =","counters":[]},{"line":"  let default = Permissions.user_default in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  { default with","counters":[]},{"line":"    edit_state =","counters":[]},{"line":"      ( if","counters":[]},{"line":"        Zkapp_state.V.to_list update.app_state","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"        |> List.exists ~f:Zkapp_basic.Set_or_keep.is_set","counters":[]},{"line":"      then auth","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"      else default.edit_state )","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"  ; set_delegate =","counters":[]},{"line":"      ( if Zkapp_basic.Set_or_keep.is_keep update.delegate then","counters":[]},{"line":"        default.set_delegate","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      else auth )","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"  ; set_verification_key =","counters":[]},{"line":"      ( if Zkapp_basic.Set_or_keep.is_keep update.verification_key then","counters":[]},{"line":"        default.set_verification_key","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      else auth )","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"  ; set_permissions =","counters":[]},{"line":"      ( if Zkapp_basic.Set_or_keep.is_keep update.permissions then","counters":[]},{"line":"        default.set_permissions","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      else auth )","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"  ; set_zkapp_uri =","counters":[]},{"line":"      ( if Zkapp_basic.Set_or_keep.is_keep update.zkapp_uri then","counters":[]},{"line":"        default.set_zkapp_uri","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      else auth )","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"  ; set_token_symbol =","counters":[]},{"line":"      ( if Zkapp_basic.Set_or_keep.is_keep update.token_symbol then","counters":[]},{"line":"        default.set_token_symbol","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      else auth )","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"  ; set_voting_for =","counters":[]},{"line":"      ( if Zkapp_basic.Set_or_keep.is_keep update.voting_for then","counters":[]},{"line":"        default.set_voting_for","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      else auth )","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"module Wallet = struct","counters":[]},{"line":"  type t = { private_key : Private_key.t; account : Account.t }","counters":[]},{"line":"","counters":[]},{"line":"  let random_wallets ?(n = min (Int.pow 2 ledger_depth) (1 lsl 10)) () =","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"    let random_wallet () : t =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let private_key = Private_key.create () in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let public_key =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Public_key.compress (Public_key.of_private_key_exn private_key)","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"      in","counters":[]},{"line":"      let account_id = Account_id.create public_key Token_id.default in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      { private_key","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      ; account =","counters":[]},{"line":"          Account.create account_id","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"            (Balance.of_int ((50 + Random.int 100) * 1_000_000_000))","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"      }","counters":[]},{"line":"    in","counters":[]},{"line":"    Array.init n ~f:(fun _ -> random_wallet ())","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"","counters":[]},{"line":"  let user_command ~fee_payer ~receiver_pk amt fee nonce memo =","counters":[]},{"line":"    let source_pk = Account.public_key fee_payer.account in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let payload : Signed_command.Payload.t =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Signed_command.Payload.create ~fee","counters":[]},{"line":"        ~fee_payer_pk:(Account.public_key fee_payer.account)","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"        ~nonce ~memo ~valid_until:None","counters":[]},{"line":"        ~body:(Payment { source_pk; receiver_pk; amount = Amount.of_int amt })","counters":[{"col_start":70,"col_end":70,"count":0}]},{"line":"    in","counters":[]},{"line":"    let signature = Signed_command.sign_payload fee_payer.private_key payload in","counters":[]},{"line":"    Signed_command.check","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"      Signed_command.Poly.Stable.Latest.","counters":[]},{"line":"        { payload","counters":[]},{"line":"        ; signer = Public_key.of_private_key_exn fee_payer.private_key","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"        ; signature","counters":[]},{"line":"        }","counters":[]},{"line":"    |> Option.value_exn","counters":[]},{"line":"","counters":[]},{"line":"  let stake_delegation ~fee_payer ~delegate_pk fee nonce memo =","counters":[]},{"line":"    let source_pk = Account.public_key fee_payer.account in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let payload : Signed_command.Payload.t =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Signed_command.Payload.create ~fee","counters":[]},{"line":"        ~fee_payer_pk:(Account.public_key fee_payer.account)","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"        ~nonce ~memo ~valid_until:None","counters":[]},{"line":"        ~body:","counters":[]},{"line":"          (Stake_delegation","counters":[]},{"line":"             (Set_delegate { delegator = source_pk; new_delegate = delegate_pk })","counters":[]},{"line":"          )","counters":[]},{"line":"    in","counters":[]},{"line":"    let signature = Signed_command.sign_payload fee_payer.private_key payload in","counters":[]},{"line":"    Signed_command.check","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"      Signed_command.Poly.Stable.Latest.","counters":[]},{"line":"        { payload","counters":[]},{"line":"        ; signer = Public_key.of_private_key_exn fee_payer.private_key","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"        ; signature","counters":[]},{"line":"        }","counters":[]},{"line":"    |> Option.value_exn","counters":[]},{"line":"","counters":[]},{"line":"  let user_command_with_wallet wallets ~sender:i ~receiver:j amt fee nonce memo","counters":[]},{"line":"      =","counters":[]},{"line":"    let fee_payer = wallets.(i) in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let receiver = wallets.(j) in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    user_command ~fee_payer","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ~receiver_pk:(Account.public_key receiver.account)","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"      amt fee nonce memo","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(** Each transaction pushes the previous protocol state (used to validate","counters":[]},{"line":"    the transaction) to the pending coinbase stack of protocol states*)","counters":[]},{"line":"let pending_coinbase_state_update state_body_hash stack =","counters":[]},{"line":"  Pending_coinbase.Stack.(push_state state_body_hash stack)","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"(** Push protocol state and coinbase if it is a coinbase transaction to the","counters":[]},{"line":"      pending coinbase stacks (coinbase stack and state stack)*)","counters":[]},{"line":"let pending_coinbase_stack_target (t : Mina_transaction.Transaction.Valid.t)","counters":[]},{"line":"    state_body_hash stack =","counters":[]},{"line":"  let stack_with_state = pending_coinbase_state_update state_body_hash stack in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  match t with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | Coinbase c ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Pending_coinbase.(Stack.push_coinbase c stack_with_state)","counters":[]},{"line":"  | _ ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      stack_with_state","counters":[]},{"line":"","counters":[]},{"line":"let check_balance pk balance ledger =","counters":[]},{"line":"  let loc = Ledger.location_of_account ledger pk |> Option.value_exn in","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"  let acc = Ledger.get ledger loc |> Option.value_exn in","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"  [%test_eq: Balance.t] acc.balance (Balance.of_int balance)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"","counters":[]},{"line":"(** Test legacy transactions*)","counters":[]},{"line":"let test_transaction_union ?expected_failure ?txn_global_slot ledger txn =","counters":[]},{"line":"  let open Mina_transaction in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let to_preunion (t : Transaction.t) =","counters":[]},{"line":"    match t with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Command (Signed_command x) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        `Transaction (Transaction.Command x)","counters":[]},{"line":"    | Fee_transfer x ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        `Transaction (Fee_transfer x)","counters":[]},{"line":"    | Coinbase x ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        `Transaction (Coinbase x)","counters":[]},{"line":"    | Command (Zkapp_command x) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        `Zkapp_command x","counters":[]},{"line":"  in","counters":[]},{"line":"  let source = Ledger.merkle_root ledger in","counters":[]},{"line":"  let pending_coinbase_stack = Pending_coinbase.Stack.empty in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let txn_unchecked = Transaction.forget txn in","counters":[]},{"line":"  let state_body, state_body_hash =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    match txn_global_slot with","counters":[]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (genesis_state_body, genesis_state_body_hash)","counters":[]},{"line":"    | Some txn_global_slot ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let state_body =","counters":[]},{"line":"          let state =","counters":[]},{"line":"            (* NB: The [previous_state_hash] is a dummy, do not use. *)","counters":[]},{"line":"            Mina_state.Protocol_state.create","counters":[]},{"line":"              ~previous_state_hash:Snark_params.Tick0.Field.zero","counters":[]},{"line":"              ~body:genesis_state_body","counters":[]},{"line":"          in","counters":[]},{"line":"          let consensus_state_at_slot =","counters":[]},{"line":"            Consensus.Data.Consensus_state.Value.For_tests","counters":[]},{"line":"            .with_global_slot_since_genesis","counters":[]},{"line":"              (Mina_state.Protocol_state.consensus_state state)","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"              txn_global_slot","counters":[]},{"line":"          in","counters":[]},{"line":"          Mina_state.Protocol_state.(","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            create_value","counters":[]},{"line":"              ~previous_state_hash:(previous_state_hash state)","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"              ~genesis_state_hash:(genesis_state_hash state)","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"              ~blockchain_state:(blockchain_state state)","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"              ~consensus_state:consensus_state_at_slot","counters":[]},{"line":"              ~constants:","counters":[]},{"line":"                (Protocol_constants_checked.value_of_t","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"                   Genesis_constants.compiled.protocol ))","counters":[]},{"line":"            .body","counters":[]},{"line":"        in","counters":[]},{"line":"        let state_body_hash = Mina_state.Protocol_state.Body.hash state_body in","counters":[]},{"line":"        (state_body, state_body_hash)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"  in","counters":[]},{"line":"  let txn_state_view : Zkapp_precondition.Protocol_state.View.t =","counters":[]},{"line":"    Mina_state.Protocol_state.Body.view state_body","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"  in","counters":[]},{"line":"  let mentioned_keys, pending_coinbase_stack_target =","counters":[]},{"line":"    let pending_coinbase_stack =","counters":[]},{"line":"      Pending_coinbase.Stack.push_state state_body_hash pending_coinbase_stack","counters":[]},{"line":"    in","counters":[]},{"line":"    match txn_unchecked with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Command (Signed_command uc) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ( Signed_command.accounts_referenced (uc :> Signed_command.t)","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"        , pending_coinbase_stack )","counters":[]},{"line":"    | Command (Zkapp_command _) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        failwith \"Zkapp_command commands not supported here\"","counters":[]},{"line":"    | Fee_transfer ft ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (Fee_transfer.receivers ft, pending_coinbase_stack)","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"    | Coinbase cb ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ( Coinbase.accounts_accessed cb","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"        , Pending_coinbase.Stack.push_coinbase cb pending_coinbase_stack )","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"  in","counters":[]},{"line":"  let sok_signer =","counters":[]},{"line":"    match to_preunion txn_unchecked with","counters":[]},{"line":"    | `Transaction t ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (Transaction_union.of_transaction t).signer |> Public_key.compress","counters":[{"col_start":40,"col_end":40,"count":0},{"col_start":73,"col_end":73,"count":0}]},{"line":"    | `Zkapp_command c ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Account_id.public_key (Zkapp_command.fee_payer c)","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"  in","counters":[]},{"line":"  let sparse_ledger =","counters":[]},{"line":"    Sparse_ledger.of_ledger_subset_exn ledger mentioned_keys","counters":[]},{"line":"  in","counters":[]},{"line":"  let expect_snark_failure, applied_transaction =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    match","counters":[]},{"line":"      Ledger.apply_transaction ledger ~constraint_constants ~txn_state_view","counters":[]},{"line":"        txn_unchecked","counters":[]},{"line":"    with","counters":[]},{"line":"    | Ok res ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ( if Option.is_some expected_failure then","counters":[]},{"line":"          match Ledger.Transaction_applied.transaction_status res with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | Applied ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              failwith","counters":[]},{"line":"                (sprintf \"Expected Ledger.apply_transaction to fail with %s\"","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                   (Transaction_status.Failure.describe","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"                      (List.hd_exn (Option.value_exn expected_failure)) ) )","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"          | Failed f ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              assert (","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                List.equal Transaction_status.Failure.equal","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                  (Option.value_exn expected_failure)","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"                  (List.concat f) ) ) ;","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"        (false, Some res)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    | Error e ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        if Option.is_none expected_failure then","counters":[]},{"line":"          failwith","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (sprintf \"Ledger.apply_transaction failed with %s\"","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"               (Error.to_string_hum e) )","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"        else if","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"          String.equal (Error.to_string_hum e)","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"            (Transaction_status.Failure.describe","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"               (List.hd_exn (Option.value_exn expected_failure)) )","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"        then ()","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"        else","counters":[]},{"line":"          failwith","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (sprintf","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"               \"Expected Ledger.apply_transaction to fail with %s but failed \\","counters":[]},{"line":"                with %s\"","counters":[]},{"line":"               (Transaction_status.Failure.describe","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                  (List.hd_exn (Option.value_exn expected_failure)) )","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"               (Error.to_string_hum e) ) ;","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"        (true, None)","counters":[]},{"line":"  in","counters":[]},{"line":"  let target = Ledger.merkle_root ledger in","counters":[]},{"line":"  let sok_message = Sok_message.create ~fee:Fee.zero ~prover:sok_signer in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let supply_increase =","counters":[]},{"line":"    Option.value_map applied_transaction ~default:Amount.Signed.zero","counters":[]},{"line":"      ~f:(fun txn ->","counters":[]},{"line":"        Ledger.Transaction_applied.supply_increase txn |> Or_error.ok_exn )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"  in","counters":[]},{"line":"  match","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Or_error.try_with (fun () ->","counters":[]},{"line":"        Transaction_snark.check_transaction ~constraint_constants ~sok_message","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ~source ~target ~init_stack:pending_coinbase_stack","counters":[]},{"line":"          ~pending_coinbase_stack_state:","counters":[]},{"line":"            { Transaction_snark.Pending_coinbase_stack_state.source =","counters":[]},{"line":"                pending_coinbase_stack","counters":[]},{"line":"            ; target = pending_coinbase_stack_target","counters":[]},{"line":"            }","counters":[]},{"line":"          ~zkapp_account1:None ~zkapp_account2:None ~supply_increase","counters":[]},{"line":"          { transaction = txn; block_data = state_body }","counters":[]},{"line":"          (unstage @@ Sparse_ledger.handler sparse_ledger) )","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"  with","counters":[]},{"line":"  | Error _e ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      assert expect_snark_failure","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"  | Ok _ ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      assert (not expect_snark_failure)","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":38,"col_end":38,"count":2}]}]}