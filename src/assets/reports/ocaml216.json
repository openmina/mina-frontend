{"filename":"src/lib/blockchain_snark/blockchain_snark_state.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Snark_params","counters":[]},{"line":"open Tick","counters":[]},{"line":"open Mina_base","counters":[]},{"line":"open Mina_state","counters":[]},{"line":"open Pickles_types","counters":[]},{"line":"","counters":[]},{"line":"include struct","counters":[]},{"line":"  open Snarky_backendless.Request","counters":[]},{"line":"","counters":[]},{"line":"  type _ t +=","counters":[]},{"line":"    | Prev_state : Protocol_state.Value.t t","counters":[]},{"line":"    | Prev_state_proof : (Nat.N2.n, Nat.N2.n) Pickles.Proof.t t","counters":[]},{"line":"    | Transition : Snark_transition.Value.t t","counters":[]},{"line":"    | Txn_snark : Transaction_snark.Statement.With_sok.t t","counters":[]},{"line":"    | Txn_snark_proof : (Nat.N2.n, Nat.N2.n) Pickles.Proof.t t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Witness = struct","counters":[]},{"line":"  type t =","counters":[]},{"line":"    { prev_state : Protocol_state.Value.t","counters":[]},{"line":"    ; prev_state_proof : (Nat.N2.n, Nat.N2.n) Pickles.Proof.t","counters":[]},{"line":"    ; transition : Snark_transition.Value.t","counters":[]},{"line":"    ; txn_snark : Transaction_snark.Statement.With_sok.t","counters":[]},{"line":"    ; txn_snark_proof : (Nat.N2.n, Nat.N2.n) Pickles.Proof.t","counters":[]},{"line":"    }","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let blockchain_handler on_unhandled","counters":[]},{"line":"    { Witness.prev_state","counters":[]},{"line":"    ; prev_state_proof","counters":[]},{"line":"    ; transition","counters":[]},{"line":"    ; txn_snark","counters":[]},{"line":"    ; txn_snark_proof","counters":[]},{"line":"    } =","counters":[]},{"line":"  let open Snarky_backendless.Request in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  fun (With { request; respond } as r) ->","counters":[]},{"line":"    let k x = respond (Provide x) in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":14,"col_end":14,"count":0}]},{"line":"    match request with","counters":[]},{"line":"    | Prev_state ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        k prev_state","counters":[]},{"line":"    | Prev_state_proof ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        k prev_state_proof","counters":[]},{"line":"    | Transition ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        k transition","counters":[]},{"line":"    | Txn_snark ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        k txn_snark","counters":[]},{"line":"    | Txn_snark_proof ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        k txn_snark_proof","counters":[]},{"line":"    | _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        on_unhandled r","counters":[]},{"line":"","counters":[]},{"line":"let wrap_handler h w =","counters":[]},{"line":"  match h with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | None ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      blockchain_handler","counters":[]},{"line":"        (fun (Snarky_backendless.Request.With { respond; _ }) ->","counters":[]},{"line":"          respond Unhandled )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        w","counters":[]},{"line":"  | Some h ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (* TODO: Clean up the handler composition interface. *)","counters":[]},{"line":"      fun r -> blockchain_handler h w r","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"","counters":[]},{"line":"let with_handler k w ?handler =","counters":[]},{"line":"  let h = wrap_handler handler w in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  k ?handler:(Some h)","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"module Impl = Pickles.Impls.Step","counters":[]},{"line":"","counters":[]},{"line":"let non_pc_registers_equal_var t1 t2 =","counters":[]},{"line":"  Impl.make_checked (fun () ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      let module F = Core_kernel.Field in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let ( ! ) eq x1 x2 = Impl.run_checked (eq x1 x2) in","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"      let f eq acc field = eq (F.get field t1) (F.get field t2) :: acc in","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"      Registers.Fields.fold ~init:[]","counters":[]},{"line":"        ~ledger:(f !Frozen_ledger_hash.equal_var)","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"        ~pending_coinbase_stack:(fun acc f ->","counters":[]},{"line":"          let () = F.get f t1 and () = F.get f t2 in","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"          acc )","counters":[]},{"line":"        ~local_state:(fun acc f ->","counters":[]},{"line":"          Local_state.Checked.equal' (F.get f t1) (F.get f t2) @ acc )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":42,"col_end":42,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"      |> Impl.Boolean.all )","counters":[]},{"line":"","counters":[]},{"line":"(* Blockchain_snark ~old ~nonce ~ledger_snark ~ledger_hash ~timestamp ~new_hash","counters":[]},{"line":"      Input:","counters":[]},{"line":"        old : Blockchain.t","counters":[]},{"line":"        old_snark : proof","counters":[]},{"line":"        nonce : int","counters":[]},{"line":"        work_snark : proof","counters":[]},{"line":"        ledger_hash : Ledger_hash.t","counters":[]},{"line":"        timestamp : Time.t","counters":[]},{"line":"        new_hash : State_hash.t","counters":[]},{"line":"      Witness:","counters":[]},{"line":"        transition : Transition.t","counters":[]},{"line":"      such that","counters":[]},{"line":"        the old_snark verifies against old","counters":[]},{"line":"        new = update_with_asserts(old, nonce, timestamp, ledger_hash)","counters":[]},{"line":"        hash(new) = new_hash","counters":[]},{"line":"        the work_snark verifies against the old.ledger_hash and new_ledger_hash","counters":[]},{"line":"        new.timestamp > old.timestamp","counters":[]},{"line":"        transition consensus data is valid","counters":[]},{"line":"        new consensus state is a function of the old consensus state","counters":[]},{"line":"*)","counters":[]},{"line":"let%snarkydef_ step ~(logger : Logger.t)","counters":[]},{"line":"    ~(proof_level : Genesis_constants.Proof_level.t)","counters":[]},{"line":"    ~(constraint_constants : Genesis_constants.Constraint_constants.t) new_state","counters":[]},{"line":"    : _ Tick.Checked.t =","counters":[]},{"line":"  let new_state_hash =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    State_hash.var_of_hash_packed (Data_as_hash.hash new_state)","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%bind transition =","counters":[]},{"line":"    with_label __LOC__ (fun () ->","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"        exists Snark_transition.typ ~request:(As_prover.return Transition) )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%bind txn_snark =","counters":[]},{"line":"    with_label __LOC__ (fun () ->","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"        exists Transaction_snark.Statement.With_sok.typ","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ~request:(As_prover.return Txn_snark) )","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%bind ( previous_state","counters":[]},{"line":"           , previous_state_hash","counters":[]},{"line":"           , previous_blockchain_proof_input","counters":[]},{"line":"           , previous_state_body_hash ) =","counters":[]},{"line":"    let%bind prev_state_ref =","counters":[]},{"line":"      with_label __LOC__ (fun () ->","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"          exists (Typ.Internal.ref ()) ~request:(As_prover.return Prev_state) )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"    in","counters":[]},{"line":"    let%bind t =","counters":[]},{"line":"      with_label __LOC__ (fun () ->","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"          exists","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (Protocol_state.typ ~constraint_constants)","counters":[]},{"line":"            ~compute:(As_prover.Ref.get prev_state_ref) )","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"    in","counters":[]},{"line":"    let%map previous_state_hash, body = Protocol_state.hash_checked t in","counters":[{"col_start":66,"col_end":66,"count":0}]},{"line":"    let previous_blockchain_proof_input =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Data_as_hash.make_unsafe","counters":[]},{"line":"        (State_hash.var_to_field previous_state_hash)","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"        prev_state_ref","counters":[]},{"line":"    in","counters":[]},{"line":"    (t, previous_state_hash, previous_blockchain_proof_input, body)","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%bind `Success updated_consensus_state, consensus_state =","counters":[]},{"line":"    with_label __LOC__ (fun () ->","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"        Consensus_state_hooks.next_state_checked ~constraint_constants","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ~prev_state:previous_state ~prev_state_hash:previous_state_hash","counters":[]},{"line":"          transition txn_snark.supply_increase )","counters":[]},{"line":"  in","counters":[]},{"line":"  let supercharge_coinbase =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Consensus.Data.Consensus_state.supercharge_coinbase_var consensus_state","counters":[]},{"line":"  in","counters":[]},{"line":"  let prev_pending_coinbase_root =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    previous_state |> Protocol_state.blockchain_state","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"    |> Blockchain_state.staged_ledger_hash","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"    |> Staged_ledger_hash.pending_coinbase_hash_var","counters":[]},{"line":"  in","counters":[]},{"line":"  let%bind genesis_state_hash =","counters":[]},{"line":"    (*get the genesis state hash from previous state unless previous state is the genesis state itslef*)","counters":[]},{"line":"    Protocol_state.genesis_state_hash_checked ~state_hash:previous_state_hash","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"      previous_state","counters":[]},{"line":"  in","counters":[]},{"line":"  let%bind new_state, is_base_case =","counters":[]},{"line":"    let t =","counters":[]},{"line":"      Protocol_state.create_var ~previous_state_hash ~genesis_state_hash","counters":[]},{"line":"        ~blockchain_state:(Snark_transition.blockchain_state transition)","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"        ~consensus_state","counters":[]},{"line":"        ~constants:(Protocol_state.constants previous_state)","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"    in","counters":[]},{"line":"    let%bind is_base_case =","counters":[]},{"line":"      Protocol_state.consensus_state t","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"      |> Consensus.Data.Consensus_state.is_genesis_state_var","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"    in","counters":[]},{"line":"    let%bind previous_state_hash =","counters":[]},{"line":"      match constraint_constants.fork with","counters":[]},{"line":"      | Some { previous_state_hash = fork_prev; _ } ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          State_hash.if_ is_base_case","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"            ~then_:(State_hash.var_of_t fork_prev)","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"            ~else_:t.previous_state_hash","counters":[]},{"line":"      | None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Checked.return t.previous_state_hash","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"    in","counters":[]},{"line":"    let t = { t with previous_state_hash } in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let%map () =","counters":[]},{"line":"      let%bind h, _ = Protocol_state.hash_checked t in","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"      with_label __LOC__ (fun () -> State_hash.assert_equal h new_state_hash)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"    in","counters":[]},{"line":"    (t, is_base_case)","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%bind txn_snark_should_verify, success =","counters":[]},{"line":"    let%bind non_pc_registers_didn't_change =","counters":[]},{"line":"      non_pc_registers_equal_var","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"        (previous_state |> Protocol_state.blockchain_state).registers","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"        { txn_snark.target with pending_coinbase_stack = () }","counters":[]},{"line":"    and supply_increase_is_zero =","counters":[]},{"line":"      Currency.Amount.(","counters":[]},{"line":"        Signed.Checked.equal txn_snark.supply_increase","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"          (Signed.Checked.of_unsigned (var_of_t zero)))","counters":[{"col_start":36,"col_end":36,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"    in","counters":[]},{"line":"    let%bind new_pending_coinbase_hash, deleted_stack, no_coinbases_popped =","counters":[]},{"line":"      let coinbase_receiver =","counters":[]},{"line":"        Consensus.Data.Consensus_state.coinbase_receiver_var consensus_state","counters":[]},{"line":"      in","counters":[]},{"line":"      let%bind root_after_delete, deleted_stack =","counters":[]},{"line":"        Pending_coinbase.Checked.pop_coinbases ~constraint_constants","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"          prev_pending_coinbase_root","counters":[]},{"line":"          ~proof_emitted:(Boolean.not non_pc_registers_didn't_change)","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"      in","counters":[]},{"line":"      (*If snarked ledger hash did not change (no new ledger proof) then pop_coinbases should be a no-op*)","counters":[]},{"line":"      let%bind no_coinbases_popped =","counters":[]},{"line":"        Pending_coinbase.Hash.equal_var root_after_delete","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"          prev_pending_coinbase_root","counters":[]},{"line":"      in","counters":[]},{"line":"      (*new stack or update one*)","counters":[]},{"line":"      let%map new_root =","counters":[]},{"line":"        with_label __LOC__ (fun () ->","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"            Pending_coinbase.Checked.add_coinbase ~constraint_constants","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              root_after_delete","counters":[]},{"line":"              (Snark_transition.pending_coinbase_update transition)","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"              ~coinbase_receiver ~supercharge_coinbase previous_state_body_hash )","counters":[]},{"line":"      in","counters":[]},{"line":"      (new_root, deleted_stack, no_coinbases_popped)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    in","counters":[]},{"line":"    let pending_coinbase_source_stack =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Pending_coinbase.Stack.Checked.create_with deleted_stack","counters":[]},{"line":"    in","counters":[]},{"line":"    let%bind txn_snark_input_correct =","counters":[]},{"line":"      let registers (t : Protocol_state.var) =","counters":[]},{"line":"        (Protocol_state.blockchain_state t).registers","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"      in","counters":[]},{"line":"      let open Checked in","counters":[]},{"line":"      let%bind () =","counters":[]},{"line":"        Fee_excess.(assert_equal_checked (var_of_t zero) txn_snark.fee_excess)","counters":[{"col_start":39,"col_end":39,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"      in","counters":[]},{"line":"      all","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":8,"col_end":8,"count":0}]},{"line":"        [ non_pc_registers_equal_var","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"            { txn_snark.source with pending_coinbase_stack = () }","counters":[]},{"line":"            (registers previous_state)","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"        ; non_pc_registers_equal_var","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"            { txn_snark.target with pending_coinbase_stack = () }","counters":[]},{"line":"            (registers new_state)","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"        ; Pending_coinbase.Stack.equal_var","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"            txn_snark.source.pending_coinbase_stack","counters":[]},{"line":"            pending_coinbase_source_stack","counters":[]},{"line":"        ; Pending_coinbase.Stack.equal_var","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"            txn_snark.target.pending_coinbase_stack deleted_stack","counters":[]},{"line":"        ]","counters":[]},{"line":"      >>= Boolean.all","counters":[]},{"line":"    in","counters":[]},{"line":"    let%bind nothing_changed =","counters":[]},{"line":"      Boolean.all","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"        [ non_pc_registers_didn't_change","counters":[]},{"line":"        ; supply_increase_is_zero","counters":[]},{"line":"        ; no_coinbases_popped","counters":[]},{"line":"        ]","counters":[]},{"line":"    in","counters":[]},{"line":"    let%bind correct_coinbase_status =","counters":[]},{"line":"      let new_root =","counters":[]},{"line":"        transition |> Snark_transition.blockchain_state","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"        |> Blockchain_state.staged_ledger_hash","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"        |> Staged_ledger_hash.pending_coinbase_hash_var","counters":[]},{"line":"      in","counters":[]},{"line":"      Pending_coinbase.Hash.equal_var new_pending_coinbase_hash new_root","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"    in","counters":[]},{"line":"    let%bind () =","counters":[]},{"line":"      with_label __LOC__ (fun () ->","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"          Boolean.Assert.any [ txn_snark_input_correct; nothing_changed ] )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    in","counters":[]},{"line":"    let transaction_snark_should_verifiy = Boolean.not nothing_changed in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let%bind result =","counters":[]},{"line":"      Boolean.all [ updated_consensus_state; correct_coinbase_status ]","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"    in","counters":[]},{"line":"    let%map () =","counters":[]},{"line":"      as_prover","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"        As_prover.(","counters":[]},{"line":"          Let_syntax.(","counters":[]},{"line":"            let%map txn_snark_input_correct =","counters":[]},{"line":"              read Boolean.typ txn_snark_input_correct","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"            and nothing_changed = read Boolean.typ nothing_changed","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"            and no_coinbases_popped = read Boolean.typ no_coinbases_popped","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"            and updated_consensus_state =","counters":[]},{"line":"              read Boolean.typ updated_consensus_state","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"            and correct_coinbase_status =","counters":[]},{"line":"              read Boolean.typ correct_coinbase_status","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"            and result = read Boolean.typ result in","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"            [%log trace]","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"              \"blockchain snark update success: $result = \\","counters":[]},{"line":"               (transaction_snark_input_correct=$transaction_snark_input_correct \\","counters":[]},{"line":"               ∨ nothing_changed \\","counters":[]},{"line":"               (no_coinbases_popped=$no_coinbases_popped)=$nothing_changed) ∧ \\","counters":[]},{"line":"               updated_consensus_state=$updated_consensus_state ∧ \\","counters":[]},{"line":"               correct_coinbase_status=$correct_coinbase_status\"","counters":[]},{"line":"              ~metadata:","counters":[]},{"line":"                [ ( \"transaction_snark_input_correct\"","counters":[]},{"line":"                  , `Bool txn_snark_input_correct )","counters":[]},{"line":"                ; (\"nothing_changed\", `Bool nothing_changed)","counters":[]},{"line":"                ; (\"updated_consensus_state\", `Bool updated_consensus_state)","counters":[]},{"line":"                ; (\"correct_coinbase_status\", `Bool correct_coinbase_status)","counters":[]},{"line":"                ; (\"result\", `Bool result)","counters":[]},{"line":"                ; (\"no_coinbases_popped\", `Bool no_coinbases_popped)","counters":[]},{"line":"                ]))","counters":[]},{"line":"    in","counters":[]},{"line":"    (transaction_snark_should_verifiy, result)","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  in","counters":[]},{"line":"  let txn_snark_should_verify =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    match proof_level with","counters":[]},{"line":"    | Check | None ->","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":14,"col_end":14,"count":0}]},{"line":"        Boolean.false_","counters":[]},{"line":"    | Full ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        txn_snark_should_verify","counters":[]},{"line":"  in","counters":[]},{"line":"  let prev_should_verify =","counters":[]},{"line":"    match proof_level with","counters":[]},{"line":"    | Check | None ->","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":14,"col_end":14,"count":0}]},{"line":"        Boolean.false_","counters":[]},{"line":"    | Full ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Boolean.not is_base_case","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%bind () =","counters":[]},{"line":"    with_label __LOC__ (fun () -> Boolean.Assert.any [ is_base_case; success ])","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%bind previous_blockchain_proof =","counters":[]},{"line":"    exists (Typ.Internal.ref ()) ~request:(As_prover.return Prev_state_proof)","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%map txn_snark_proof =","counters":[]},{"line":"    exists (Typ.Internal.ref ()) ~request:(As_prover.return Txn_snark_proof)","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"  in","counters":[]},{"line":"  ( { Pickles.Inductive_rule.Previous_proof_statement.public_input =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"        previous_blockchain_proof_input","counters":[]},{"line":"    ; proof = previous_blockchain_proof","counters":[]},{"line":"    ; proof_must_verify = prev_should_verify","counters":[]},{"line":"    }","counters":[]},{"line":"  , { Pickles.Inductive_rule.Previous_proof_statement.public_input = txn_snark","counters":[]},{"line":"    ; proof = txn_snark_proof","counters":[]},{"line":"    ; proof_must_verify = txn_snark_should_verify","counters":[]},{"line":"    } )","counters":[]},{"line":"","counters":[]},{"line":"module Statement = struct","counters":[]},{"line":"  type t = Protocol_state.Value.t","counters":[]},{"line":"","counters":[]},{"line":"  let to_field_elements (t : t) : Tick.Field.t array =","counters":[]},{"line":"    [| (Protocol_state.hashes t).state_hash |]","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Statement_var = struct","counters":[]},{"line":"  type t = Protocol_state.Value.t Data_as_hash.t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"type tag = (Statement_var.t, Statement.t, Nat.N2.n, Nat.N1.n) Pickles.Tag.t","counters":[]},{"line":"","counters":[]},{"line":"let typ = Data_as_hash.typ ~hash:(fun t -> (Protocol_state.hashes t).state_hash)","counters":[{"col_start":43,"col_end":43,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"","counters":[]},{"line":"let check w ?handler ~proof_level ~constraint_constants new_state_hash :","counters":[]},{"line":"    unit Or_error.t =","counters":[]},{"line":"  let open Tick in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  check","counters":[]},{"line":"    (Fn.flip handle (wrap_handler handler w) (fun () ->","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"         let%bind curr =","counters":[]},{"line":"           exists typ ~compute:(As_prover.return new_state_hash)","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"         in","counters":[]},{"line":"         step ~proof_level ~constraint_constants ~logger:(Logger.create ()) curr )","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":70,"col_end":70,"count":0}]},{"line":"    )","counters":[]},{"line":"","counters":[]},{"line":"let rule ~proof_level ~constraint_constants transaction_snark self :","counters":[]},{"line":"    _ Pickles.Inductive_rule.t =","counters":[]},{"line":"  { identifier = \"step\"","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  ; prevs = [ self; transaction_snark ]","counters":[]},{"line":"  ; main =","counters":[]},{"line":"      (fun { public_input = x } ->","counters":[]},{"line":"        let b1, b2 =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Run.run_checked","counters":[]},{"line":"            (step ~proof_level ~constraint_constants ~logger:(Logger.create ())","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":74,"col_end":74,"count":0}]},{"line":"               x )","counters":[]},{"line":"        in","counters":[]},{"line":"        { previous_proof_statements = [ b1; b2 ]","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        ; public_output = ()","counters":[]},{"line":"        ; auxiliary_output = ()","counters":[]},{"line":"        } )","counters":[]},{"line":"  ; uses_lookup = false","counters":[]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"module type S = sig","counters":[]},{"line":"  module Proof :","counters":[]},{"line":"    Pickles.Proof_intf","counters":[]},{"line":"      with type t = (Nat.N2.n, Nat.N2.n) Pickles.Proof.t","counters":[]},{"line":"       and type statement = Protocol_state.Value.t","counters":[]},{"line":"","counters":[]},{"line":"  val tag : tag","counters":[]},{"line":"","counters":[]},{"line":"  val cache_handle : Pickles.Cache_handle.t","counters":[]},{"line":"","counters":[]},{"line":"  open Nat","counters":[]},{"line":"","counters":[]},{"line":"  val step :","counters":[]},{"line":"       Witness.t","counters":[]},{"line":"    -> ( Protocol_state.Value.t * (Transaction_snark.Statement.With_sok.t * unit)","counters":[]},{"line":"       , N2.n * (N2.n * unit)","counters":[]},{"line":"       , N1.n * (N5.n * unit)","counters":[]},{"line":"       , Protocol_state.Value.t","counters":[]},{"line":"       , (unit * unit * Proof.t) Async.Deferred.t )","counters":[]},{"line":"       Pickles.Prover.t","counters":[]},{"line":"","counters":[]},{"line":"  val constraint_system_digests : (string * Md5_lib.t) list Lazy.t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let verify ts ~key = Pickles.verify (module Nat.N2) (module Statement) key ts","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"","counters":[]},{"line":"let constraint_system_digests ~proof_level ~constraint_constants () =","counters":[]},{"line":"  let digest = Tick.R1CS_constraint_system.digest in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  [ ( \"blockchain-step\"","counters":[]},{"line":"    , digest","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"        (let main x =","counters":[]},{"line":"           let open Tick in","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"           let%map _ =","counters":[]},{"line":"             step ~proof_level ~constraint_constants ~logger:(Logger.create ())","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":74,"col_end":74,"count":0}]},{"line":"               x","counters":[]},{"line":"           in","counters":[]},{"line":"           ()","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"         in","counters":[]},{"line":"         Tick.constraint_system ~input_typ:typ","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"           ~return_typ:(Snarky_backendless.Typ.unit ())","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"           main ) )","counters":[]},{"line":"  ]","counters":[]},{"line":"","counters":[]},{"line":"module Make (T : sig","counters":[]},{"line":"  val tag : Transaction_snark.tag","counters":[]},{"line":"","counters":[]},{"line":"  val constraint_constants : Genesis_constants.Constraint_constants.t","counters":[]},{"line":"","counters":[]},{"line":"  val proof_level : Genesis_constants.Proof_level.t","counters":[]},{"line":"end) : S = struct","counters":[]},{"line":"  open T","counters":[]},{"line":"","counters":[]},{"line":"  let tag, cache_handle, p, Pickles.Provers.[ step ] =","counters":[]},{"line":"    Pickles.compile () ~cache:Cache_dir.cache ~public_input:(Input typ)","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"      ~auxiliary_typ:Typ.unit","counters":[]},{"line":"      ~branches:(module Nat.N1)","counters":[]},{"line":"      ~max_proofs_verified:(module Nat.N2)","counters":[]},{"line":"      ~name:\"blockchain-snark\"","counters":[]},{"line":"      ~constraint_constants:","counters":[]},{"line":"        (Genesis_constants.Constraint_constants.to_snark_keys_header","counters":[{"col_start":67,"col_end":67,"count":0}]},{"line":"           constraint_constants )","counters":[]},{"line":"      ~choices:(fun ~self ->","counters":[]},{"line":"        [ rule ~proof_level ~constraint_constants T.tag self ] )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":13,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"  let step = with_handler step","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"","counters":[]},{"line":"  let constraint_system_digests =","counters":[]},{"line":"    lazy (constraint_system_digests ~proof_level ~constraint_constants ())","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"  module Proof = (val p)","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}