{"filename":"src/lib/transaction_logic/mina_transaction_logic.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Mina_base","counters":[]},{"line":"open Currency","counters":[]},{"line":"open Signature_lib","counters":[]},{"line":"open Mina_transaction","counters":[]},{"line":"module Zkapp_command_logic = Zkapp_command_logic","counters":[]},{"line":"module Global_slot = Mina_numbers.Global_slot","counters":[]},{"line":"","counters":[]},{"line":"module Transaction_applied = struct","counters":[]},{"line":"  module UC = Signed_command","counters":[]},{"line":"","counters":[]},{"line":"  module Signed_command_applied = struct","counters":[]},{"line":"    module Common = struct","counters":[]},{"line":"      [%%versioned","counters":[]},{"line":"      module Stable = struct","counters":[]},{"line":"        module V2 = struct","counters":[]},{"line":"          type t =","counters":[{"col_start":10,"col_end":10,"count":2},{"col_start":15,"col_end":15,"count":2}]},{"line":"            { user_command : Signed_command.Stable.V2.t With_status.Stable.V2.t","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"            }","counters":[]},{"line":"          [@@deriving sexp]","counters":[{"col_start":26,"col_end":26,"count":5}]},{"line":"","counters":[]},{"line":"          let to_latest = Fn.id","counters":[]},{"line":"        end","counters":[]},{"line":"      end]","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Body = struct","counters":[]},{"line":"      [%%versioned","counters":[]},{"line":"      module Stable = struct","counters":[]},{"line":"        module V2 = struct","counters":[]},{"line":"          type t =","counters":[{"col_start":10,"col_end":10,"count":2},{"col_start":15,"col_end":15,"count":4}]},{"line":"            | Payment of { new_accounts : Account_id.Stable.V2.t list }","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"            | Stake_delegation of","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"                { previous_delegate : Public_key.Compressed.Stable.V1.t option }","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"            | Failed","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          [@@deriving sexp]","counters":[{"col_start":26,"col_end":26,"count":5}]},{"line":"","counters":[]},{"line":"          let to_latest = Fn.id","counters":[]},{"line":"        end","counters":[]},{"line":"      end]","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V2 = struct","counters":[]},{"line":"        type t = { common : Common.Stable.V2.t; body : Body.Stable.V2.t }","counters":[{"col_start":8,"col_end":8,"count":2},{"col_start":13,"col_end":13,"count":2},{"col_start":19,"col_end":19,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":48,"col_end":48,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"        [@@deriving sexp]","counters":[{"col_start":24,"col_end":24,"count":5}]},{"line":"","counters":[]},{"line":"        let to_latest = Fn.id","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    let new_accounts (t : t) =","counters":[]},{"line":"      match t.body with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Payment { new_accounts; _ } ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          new_accounts","counters":[]},{"line":"      | Stake_delegation _ | Failed ->","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"          []","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Zkapp_command_applied = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type t =","counters":[{"col_start":8,"col_end":8,"count":2},{"col_start":13,"col_end":13,"count":2}]},{"line":"          { accounts :","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"              (Account_id.Stable.V2.t * Account.Stable.V2.t option) list","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"          ; command : Zkapp_command.Stable.V1.t With_status.Stable.V2.t","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"          ; new_accounts : Account_id.Stable.V2.t list","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"          }","counters":[]},{"line":"        [@@deriving sexp]","counters":[{"col_start":24,"col_end":24,"count":5}]},{"line":"","counters":[]},{"line":"        let to_latest = Fn.id","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Command_applied = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V2 = struct","counters":[]},{"line":"        type t =","counters":[{"col_start":8,"col_end":8,"count":2},{"col_start":13,"col_end":13,"count":2}]},{"line":"          | Signed_command of Signed_command_applied.Stable.V2.t","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | Zkapp_command of Zkapp_command_applied.Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        [@@deriving sexp]","counters":[{"col_start":24,"col_end":24,"count":5}]},{"line":"","counters":[]},{"line":"        let to_latest = Fn.id","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Fee_transfer_applied = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V2 = struct","counters":[]},{"line":"        type t =","counters":[{"col_start":8,"col_end":8,"count":2},{"col_start":13,"col_end":13,"count":2}]},{"line":"          { fee_transfer : Fee_transfer.Stable.V2.t With_status.Stable.V2.t","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"          ; new_accounts : Account_id.Stable.V2.t list","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"          ; burned_tokens : Currency.Amount.Stable.V1.t","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"          }","counters":[]},{"line":"        [@@deriving sexp]","counters":[{"col_start":24,"col_end":24,"count":5}]},{"line":"","counters":[]},{"line":"        let to_latest = Fn.id","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Coinbase_applied = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V2 = struct","counters":[]},{"line":"        type t =","counters":[{"col_start":8,"col_end":8,"count":2},{"col_start":13,"col_end":13,"count":2}]},{"line":"          { coinbase : Coinbase.Stable.V1.t With_status.Stable.V2.t","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"          ; new_accounts : Account_id.Stable.V2.t list","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"          ; burned_tokens : Currency.Amount.Stable.V1.t","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"          }","counters":[]},{"line":"        [@@deriving sexp]","counters":[{"col_start":24,"col_end":24,"count":5}]},{"line":"","counters":[]},{"line":"        let to_latest = Fn.id","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Varying = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V2 = struct","counters":[]},{"line":"        type t =","counters":[{"col_start":8,"col_end":8,"count":2},{"col_start":13,"col_end":13,"count":2}]},{"line":"          | Command of Command_applied.Stable.V2.t","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | Fee_transfer of Fee_transfer_applied.Stable.V2.t","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | Coinbase of Coinbase_applied.Stable.V2.t","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        [@@deriving sexp]","counters":[{"col_start":24,"col_end":24,"count":5}]},{"line":"","counters":[]},{"line":"        let to_latest = Fn.id","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V2 = struct","counters":[]},{"line":"      type t =","counters":[{"col_start":6,"col_end":6,"count":2},{"col_start":11,"col_end":11,"count":2}]},{"line":"        { previous_hash : Ledger_hash.Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"        ; varying : Varying.Stable.V2.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":16,"col_end":16,"count":0}]},{"line":"        }","counters":[]},{"line":"      [@@deriving sexp]","counters":[{"col_start":22,"col_end":22,"count":5}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  let burned_tokens : t -> Currency.Amount.t =","counters":[]},{"line":"   fun { varying; _ } ->","counters":[]},{"line":"    match varying with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Command _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Currency.Amount.zero","counters":[]},{"line":"    | Fee_transfer f ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        f.burned_tokens","counters":[]},{"line":"    | Coinbase c ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        c.burned_tokens","counters":[]},{"line":"","counters":[]},{"line":"  let new_accounts : t -> Account_id.t list =","counters":[]},{"line":"   fun { varying; _ } ->","counters":[]},{"line":"    match varying with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Command c -> (","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        match c with","counters":[]},{"line":"        | Signed_command sc ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Signed_command_applied.new_accounts sc","counters":[]},{"line":"        | Zkapp_command zc ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            zc.new_accounts )","counters":[]},{"line":"    | Fee_transfer f ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        f.new_accounts","counters":[]},{"line":"    | Coinbase c ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        c.new_accounts","counters":[]},{"line":"","counters":[]},{"line":"  let supply_increase : t -> Currency.Amount.Signed.t Or_error.t =","counters":[]},{"line":"   fun t ->","counters":[]},{"line":"    let open Or_error.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let burned_tokens = Currency.Amount.Signed.of_unsigned (burned_tokens t) in","counters":[{"col_start":72,"col_end":72,"count":0}]},{"line":"    let account_creation_fees =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let account_creation_fee_int =","counters":[]},{"line":"        Genesis_constants.Constraint_constants.compiled.account_creation_fee","counters":[]},{"line":"        |> Currency.Fee.to_int","counters":[]},{"line":"      in","counters":[]},{"line":"      let num_accounts_created = List.length @@ new_accounts t in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"      (* int type is OK, no danger of overflow *)","counters":[]},{"line":"      Currency.Amount.(","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Signed.of_unsigned","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"        @@ of_int (account_creation_fee_int * num_accounts_created))","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"    in","counters":[]},{"line":"    let txn : Transaction.t =","counters":[]},{"line":"      match t.varying with","counters":[]},{"line":"      | Command","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (Signed_command { common = { user_command = { data; _ }; _ }; _ }) ->","counters":[]},{"line":"          Command (Signed_command data)","counters":[]},{"line":"      | Command (Zkapp_command c) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Command (Zkapp_command c.command.data)","counters":[]},{"line":"      | Fee_transfer f ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Fee_transfer f.fee_transfer.data","counters":[]},{"line":"      | Coinbase c ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Coinbase c.coinbase.data","counters":[]},{"line":"    in","counters":[]},{"line":"    let%bind expected_supply_increase =","counters":[]},{"line":"      Transaction.expected_supply_increase txn","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"    in","counters":[]},{"line":"    let rec process_decreases total = function","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      | [] ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Some total","counters":[]},{"line":"      | amt :: amts ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let%bind.Option sum =","counters":[]},{"line":"            Currency.Amount.Signed.(add @@ negate amt) total","counters":[{"col_start":38,"col_end":38,"count":0},{"col_start":48,"col_end":48,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"          in","counters":[]},{"line":"          process_decreases sum amts","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    in","counters":[]},{"line":"    let total =","counters":[]},{"line":"      process_decreases","counters":[]},{"line":"        (Currency.Amount.Signed.of_unsigned expected_supply_increase)","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"        [ burned_tokens; account_creation_fees ]","counters":[]},{"line":"    in","counters":[]},{"line":"    Option.value_map total ~default:(Or_error.error_string \"overflow\")","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"      ~f:(fun v -> Ok v)","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"","counters":[]},{"line":"  let transaction_with_status : t -> Transaction.t With_status.t =","counters":[]},{"line":"   fun { varying; _ } ->","counters":[]},{"line":"    match varying with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Command (Signed_command uc) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        With_status.map uc.common.user_command ~f:(fun cmd ->","counters":[]},{"line":"            Transaction.Command (User_command.Signed_command cmd) )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"    | Command (Zkapp_command s) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        With_status.map s.command ~f:(fun c ->","counters":[]},{"line":"            Transaction.Command (User_command.Zkapp_command c) )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"    | Fee_transfer f ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        With_status.map f.fee_transfer ~f:(fun f -> Transaction.Fee_transfer f)","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"    | Coinbase c ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        With_status.map c.coinbase ~f:(fun c -> Transaction.Coinbase c)","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"","counters":[]},{"line":"  let transaction_status : t -> Transaction_status.t =","counters":[]},{"line":"   fun { varying; _ } ->","counters":[]},{"line":"    match varying with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Command","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (Signed_command { common = { user_command = { status; _ }; _ }; _ }) ->","counters":[]},{"line":"        status","counters":[]},{"line":"    | Command (Zkapp_command c) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        c.command.status","counters":[]},{"line":"    | Fee_transfer f ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        f.fee_transfer.status","counters":[]},{"line":"    | Coinbase c ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        c.coinbase.status","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type S = sig","counters":[]},{"line":"  type ledger","counters":[]},{"line":"","counters":[]},{"line":"  module Transaction_applied : sig","counters":[]},{"line":"    module Signed_command_applied : sig","counters":[]},{"line":"      module Common : sig","counters":[]},{"line":"        type t = Transaction_applied.Signed_command_applied.Common.t =","counters":[]},{"line":"          { user_command : Signed_command.t With_status.t }","counters":[]},{"line":"        [@@deriving sexp]","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      module Body : sig","counters":[]},{"line":"        type t = Transaction_applied.Signed_command_applied.Body.t =","counters":[]},{"line":"          | Payment of { new_accounts : Account_id.t list }","counters":[]},{"line":"          | Stake_delegation of","counters":[]},{"line":"              { previous_delegate : Public_key.Compressed.t option }","counters":[]},{"line":"          | Failed","counters":[]},{"line":"        [@@deriving sexp]","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      type t = Transaction_applied.Signed_command_applied.t =","counters":[]},{"line":"        { common : Common.t; body : Body.t }","counters":[]},{"line":"      [@@deriving sexp]","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Zkapp_command_applied : sig","counters":[]},{"line":"      type t = Transaction_applied.Zkapp_command_applied.t =","counters":[]},{"line":"        { accounts : (Account_id.t * Account.t option) list","counters":[]},{"line":"        ; command : Zkapp_command.t With_status.t","counters":[]},{"line":"        ; new_accounts : Account_id.t list","counters":[]},{"line":"        }","counters":[]},{"line":"      [@@deriving sexp]","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Command_applied : sig","counters":[]},{"line":"      type t = Transaction_applied.Command_applied.t =","counters":[]},{"line":"        | Signed_command of Signed_command_applied.t","counters":[]},{"line":"        | Zkapp_command of Zkapp_command_applied.t","counters":[]},{"line":"      [@@deriving sexp]","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Fee_transfer_applied : sig","counters":[]},{"line":"      type t = Transaction_applied.Fee_transfer_applied.t =","counters":[]},{"line":"        { fee_transfer : Fee_transfer.t With_status.t","counters":[]},{"line":"        ; new_accounts : Account_id.t list","counters":[]},{"line":"        ; burned_tokens : Currency.Amount.t","counters":[]},{"line":"        }","counters":[]},{"line":"      [@@deriving sexp]","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Coinbase_applied : sig","counters":[]},{"line":"      type t = Transaction_applied.Coinbase_applied.t =","counters":[]},{"line":"        { coinbase : Coinbase.t With_status.t","counters":[]},{"line":"        ; new_accounts : Account_id.t list","counters":[]},{"line":"        ; burned_tokens : Currency.Amount.t","counters":[]},{"line":"        }","counters":[]},{"line":"      [@@deriving sexp]","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Varying : sig","counters":[]},{"line":"      type t = Transaction_applied.Varying.t =","counters":[]},{"line":"        | Command of Command_applied.t","counters":[]},{"line":"        | Fee_transfer of Fee_transfer_applied.t","counters":[]},{"line":"        | Coinbase of Coinbase_applied.t","counters":[]},{"line":"      [@@deriving sexp]","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    type t = Transaction_applied.t =","counters":[]},{"line":"      { previous_hash : Ledger_hash.t; varying : Varying.t }","counters":[]},{"line":"    [@@deriving sexp]","counters":[]},{"line":"","counters":[]},{"line":"    val burned_tokens : t -> Currency.Amount.t","counters":[]},{"line":"","counters":[]},{"line":"    val supply_increase : t -> Currency.Amount.Signed.t Or_error.t","counters":[]},{"line":"","counters":[]},{"line":"    val transaction : t -> Transaction.t With_status.t","counters":[]},{"line":"","counters":[]},{"line":"    val transaction_status : t -> Transaction_status.t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Global_state : sig","counters":[]},{"line":"    type t =","counters":[]},{"line":"      { ledger : ledger","counters":[]},{"line":"      ; fee_excess : Amount.Signed.t","counters":[]},{"line":"      ; supply_increase : Amount.Signed.t","counters":[]},{"line":"      ; protocol_state : Zkapp_precondition.Protocol_state.View.t","counters":[]},{"line":"      }","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  val apply_user_command :","counters":[]},{"line":"       constraint_constants:Genesis_constants.Constraint_constants.t","counters":[]},{"line":"    -> txn_global_slot:Global_slot.t","counters":[]},{"line":"    -> ledger","counters":[]},{"line":"    -> Signed_command.With_valid_signature.t","counters":[]},{"line":"    -> Transaction_applied.Signed_command_applied.t Or_error.t","counters":[]},{"line":"","counters":[]},{"line":"  val apply_user_command_unchecked :","counters":[]},{"line":"       constraint_constants:Genesis_constants.Constraint_constants.t","counters":[]},{"line":"    -> txn_global_slot:Global_slot.t","counters":[]},{"line":"    -> ledger","counters":[]},{"line":"    -> Signed_command.t","counters":[]},{"line":"    -> Transaction_applied.Signed_command_applied.t Or_error.t","counters":[]},{"line":"","counters":[]},{"line":"  val update_sequence_state :","counters":[]},{"line":"       Snark_params.Tick.Field.t Pickles_types.Vector.Vector_5.t","counters":[]},{"line":"    -> Zkapp_account.Sequence_events.t","counters":[]},{"line":"    -> txn_global_slot:Global_slot.t","counters":[]},{"line":"    -> last_sequence_slot:Global_slot.t","counters":[]},{"line":"    -> Snark_params.Tick.Field.t Pickles_types.Vector.Vector_5.t * Global_slot.t","counters":[]},{"line":"","counters":[]},{"line":"  val apply_zkapp_command_unchecked :","counters":[]},{"line":"       constraint_constants:Genesis_constants.Constraint_constants.t","counters":[]},{"line":"    -> state_view:Zkapp_precondition.Protocol_state.View.t","counters":[]},{"line":"    -> ledger","counters":[]},{"line":"    -> Zkapp_command.t","counters":[]},{"line":"    -> ( Transaction_applied.Zkapp_command_applied.t","counters":[]},{"line":"       * ( ( Stack_frame.value","counters":[]},{"line":"           , Stack_frame.value list","counters":[]},{"line":"           , Token_id.t","counters":[]},{"line":"           , Amount.Signed.t","counters":[]},{"line":"           , ledger","counters":[]},{"line":"           , bool","counters":[]},{"line":"           , Zkapp_command.Transaction_commitment.t","counters":[]},{"line":"           , Mina_numbers.Index.t","counters":[]},{"line":"           , Transaction_status.Failure.Collection.t )","counters":[]},{"line":"           Zkapp_command_logic.Local_state.t","counters":[]},{"line":"         * Amount.Signed.t ) )","counters":[]},{"line":"       Or_error.t","counters":[]},{"line":"","counters":[]},{"line":"  (** Apply all zkapp_command within a zkapp_command transaction. This behaves as","counters":[]},{"line":"      [apply_zkapp_command_unchecked], except that the [~init] and [~f] arguments","counters":[]},{"line":"      are provided to allow for the accumulation of the intermediate states.","counters":[]},{"line":"","counters":[]},{"line":"      Invariant: [f] is always applied at least once, so it is valid to use an","counters":[]},{"line":"      [_ option] as the initial state and call [Option.value_exn] on the","counters":[]},{"line":"      accumulated result.","counters":[]},{"line":"","counters":[]},{"line":"      This can be used to collect the intermediate states to make them","counters":[]},{"line":"      available for snark work. In particular, since the transaction snark has","counters":[]},{"line":"      a cap on the number of zkapp_command of each kind that may be included, we can","counters":[]},{"line":"      use this to retrieve the (source, target) pairs for each batch of","counters":[]},{"line":"      zkapp_command to include in the snark work spec / transaction snark witness.","counters":[]},{"line":"  *)","counters":[]},{"line":"  val apply_zkapp_command_unchecked_aux :","counters":[]},{"line":"       constraint_constants:Genesis_constants.Constraint_constants.t","counters":[]},{"line":"    -> state_view:Zkapp_precondition.Protocol_state.View.t","counters":[]},{"line":"    -> init:'acc","counters":[]},{"line":"    -> f:","counters":[]},{"line":"         (   'acc","counters":[]},{"line":"          -> Global_state.t","counters":[]},{"line":"             * ( Stack_frame.value","counters":[]},{"line":"               , Stack_frame.value list","counters":[]},{"line":"               , Token_id.t","counters":[]},{"line":"               , Amount.Signed.t","counters":[]},{"line":"               , ledger","counters":[]},{"line":"               , bool","counters":[]},{"line":"               , Zkapp_command.Transaction_commitment.t","counters":[]},{"line":"               , Mina_numbers.Index.t","counters":[]},{"line":"               , Transaction_status.Failure.Collection.t )","counters":[]},{"line":"               Zkapp_command_logic.Local_state.t","counters":[]},{"line":"          -> 'acc )","counters":[]},{"line":"    -> ?fee_excess:Amount.Signed.t","counters":[]},{"line":"    -> ?supply_increase:Amount.Signed.t","counters":[]},{"line":"    -> ledger","counters":[]},{"line":"    -> Zkapp_command.t","counters":[]},{"line":"    -> (Transaction_applied.Zkapp_command_applied.t * 'acc) Or_error.t","counters":[]},{"line":"","counters":[]},{"line":"  val apply_fee_transfer :","counters":[]},{"line":"       constraint_constants:Genesis_constants.Constraint_constants.t","counters":[]},{"line":"    -> txn_global_slot:Global_slot.t","counters":[]},{"line":"    -> ledger","counters":[]},{"line":"    -> Fee_transfer.t","counters":[]},{"line":"    -> Transaction_applied.Fee_transfer_applied.t Or_error.t","counters":[]},{"line":"","counters":[]},{"line":"  val apply_coinbase :","counters":[]},{"line":"       constraint_constants:Genesis_constants.Constraint_constants.t","counters":[]},{"line":"    -> txn_global_slot:Global_slot.t","counters":[]},{"line":"    -> ledger","counters":[]},{"line":"    -> Coinbase.t","counters":[]},{"line":"    -> Transaction_applied.Coinbase_applied.t Or_error.t","counters":[]},{"line":"","counters":[]},{"line":"  val apply_transaction :","counters":[]},{"line":"       constraint_constants:Genesis_constants.Constraint_constants.t","counters":[]},{"line":"    -> txn_state_view:Zkapp_precondition.Protocol_state.View.t","counters":[]},{"line":"    -> ledger","counters":[]},{"line":"    -> Transaction.t","counters":[]},{"line":"    -> Transaction_applied.t Or_error.t","counters":[]},{"line":"","counters":[]},{"line":"  val has_locked_tokens :","counters":[]},{"line":"       global_slot:Global_slot.t","counters":[]},{"line":"    -> account_id:Account_id.t","counters":[]},{"line":"    -> ledger","counters":[]},{"line":"    -> bool Or_error.t","counters":[]},{"line":"","counters":[]},{"line":"  module For_tests : sig","counters":[]},{"line":"    val validate_timing_with_min_balance :","counters":[]},{"line":"         account:Account.t","counters":[]},{"line":"      -> txn_amount:Amount.t","counters":[]},{"line":"      -> txn_global_slot:Global_slot.t","counters":[]},{"line":"      -> (Account.Timing.t * [> `Min_balance of Balance.t ]) Or_error.t","counters":[]},{"line":"","counters":[]},{"line":"    val validate_timing :","counters":[]},{"line":"         account:Account.t","counters":[]},{"line":"      -> txn_amount:Amount.t","counters":[]},{"line":"      -> txn_global_slot:Global_slot.t","counters":[]},{"line":"      -> Account.Timing.t Or_error.t","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(* tags for timing validation errors *)","counters":[]},{"line":"let nsf_tag = \"nsf\"","counters":[]},{"line":"","counters":[]},{"line":"let min_balance_tag = \"minbal\"","counters":[]},{"line":"","counters":[]},{"line":"let timing_error_to_user_command_status err =","counters":[]},{"line":"  match Error.Internal_repr.of_info err with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | Tag_t (tag, _) when String.equal tag nsf_tag ->","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"      Transaction_status.Failure.Source_insufficient_balance","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  | Tag_t (tag, _) when String.equal tag min_balance_tag ->","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"      Transaction_status.Failure.Source_minimum_balance_violation","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  | _ ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      failwith \"Unexpected timed account validation error\"","counters":[]},{"line":"","counters":[]},{"line":"(** [validate_timing_with_min_balance' ~account ~txn_amount ~txn_global_slot]","counters":[]},{"line":"    returns a tuple of 3 values:","counters":[]},{"line":"    * [[`Insufficient_balance of bool | `Invalid_timing of bool]] encodes","counters":[]},{"line":"      possible errors, with the invariant that the return value is always","counters":[]},{"line":"      [`Invalid_timing false] if there was no error.","counters":[]},{"line":"    - [`Insufficient_balance true] results if [txn_amount] is larger than the","counters":[]},{"line":"        balance held in [account].","counters":[]},{"line":"    - [`Invalid_timing true] results if [txn_amount] is larger than the","counters":[]},{"line":"        balance available in [account] at global slot [txn_global_slot].","counters":[]},{"line":"    * [Timing.t], the new timing for [account] calculated at [txn_global_slot].","counters":[]},{"line":"    * [[`Min_balance of Balance.t]] returns the computed available balance at","counters":[]},{"line":"      [txn_global_slot].","counters":[]},{"line":"    - NOTE: We skip this calculation if the error is","counters":[]},{"line":"        [`Insufficient_balance true].  In this scenario, this value MUST NOT be","counters":[]},{"line":"        used, as it contains an incorrect placeholder value.","counters":[]},{"line":"*)","counters":[]},{"line":"let validate_timing_with_min_balance' ~account ~txn_amount ~txn_global_slot =","counters":[]},{"line":"  let open Account.Poly in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let open Account.Timing.Poly in","counters":[]},{"line":"  match account.timing with","counters":[]},{"line":"  | Untimed -> (","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (* no time restrictions *)","counters":[]},{"line":"      match Balance.(account.balance - txn_amount) with","counters":[]},{"line":"      | None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (`Insufficient_balance true, Untimed, `Min_balance Balance.zero)","counters":[]},{"line":"      | _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (`Invalid_timing false, Untimed, `Min_balance Balance.zero) )","counters":[]},{"line":"  | Timed","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      { initial_minimum_balance","counters":[]},{"line":"      ; cliff_time","counters":[]},{"line":"      ; cliff_amount","counters":[]},{"line":"      ; vesting_period","counters":[]},{"line":"      ; vesting_increment","counters":[]},{"line":"      } ->","counters":[]},{"line":"      let invalid_balance, invalid_timing, curr_min_balance =","counters":[]},{"line":"        let account_balance = account.balance in","counters":[]},{"line":"        match Balance.(account_balance - txn_amount) with","counters":[]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (* NB: The [initial_minimum_balance] here is the incorrect value,","counters":[]},{"line":"               but:","counters":[]},{"line":"               * we don't use it anywhere in this error case; and","counters":[]},{"line":"               * we don't want to waste time computing it if it will be unused.","counters":[]},{"line":"            *)","counters":[]},{"line":"            (true, false, initial_minimum_balance)","counters":[]},{"line":"        | Some proposed_new_balance ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let curr_min_balance =","counters":[]},{"line":"              Account.min_balance_at_slot ~global_slot:txn_global_slot","counters":[]},{"line":"                ~cliff_time ~cliff_amount ~vesting_period ~vesting_increment","counters":[]},{"line":"                ~initial_minimum_balance","counters":[]},{"line":"            in","counters":[]},{"line":"            if Balance.(proposed_new_balance < curr_min_balance) then","counters":[]},{"line":"              (false, true, curr_min_balance)","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"            else (false, false, curr_min_balance)","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"      in","counters":[]},{"line":"      (* once the calculated minimum balance becomes zero, the account becomes untimed *)","counters":[]},{"line":"      let possibly_error =","counters":[]},{"line":"        if invalid_balance then `Insufficient_balance invalid_balance","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"        else `Invalid_timing invalid_timing","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"      in","counters":[]},{"line":"      if Balance.(curr_min_balance > zero) then","counters":[]},{"line":"        (possibly_error, account.timing, `Min_balance curr_min_balance)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      else (possibly_error, Untimed, `Min_balance Balance.zero)","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"","counters":[]},{"line":"let validate_timing_with_min_balance ~account ~txn_amount ~txn_global_slot =","counters":[]},{"line":"  let open Or_error.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let nsf_error kind =","counters":[]},{"line":"    Or_error.errorf","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      !\"For %s account, the requested transaction for amount %{sexp: Amount.t} \\","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"        at global slot %{sexp: Global_slot.t}, the balance %{sexp: Balance.t} \\","counters":[]},{"line":"        is insufficient\"","counters":[]},{"line":"      kind txn_amount txn_global_slot account.Account.Poly.balance","counters":[]},{"line":"    |> Or_error.tag ~tag:nsf_tag","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"  in","counters":[]},{"line":"  let min_balance_error min_balance =","counters":[]},{"line":"    Or_error.errorf","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      !\"For timed account, the requested transaction for amount %{sexp: \\","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"        Amount.t} at global slot %{sexp: Global_slot.t}, applying the \\","counters":[]},{"line":"        transaction would put the balance below the calculated minimum balance \\","counters":[]},{"line":"        of %{sexp: Balance.t}\"","counters":[]},{"line":"      txn_amount txn_global_slot min_balance","counters":[]},{"line":"    |> Or_error.tag ~tag:min_balance_tag","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"  in","counters":[]},{"line":"  let possibly_error, timing, (`Min_balance curr_min_balance as min_balance) =","counters":[]},{"line":"    validate_timing_with_min_balance' ~account ~txn_amount ~txn_global_slot","counters":[]},{"line":"  in","counters":[]},{"line":"  match possibly_error with","counters":[]},{"line":"  | `Insufficient_balance true ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      nsf_error \"timed\"","counters":[]},{"line":"  | `Invalid_timing true ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      min_balance_error curr_min_balance","counters":[]},{"line":"  | `Insufficient_balance false ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      failwith \"Broken invariant in validate_timing_with_min_balance'\"","counters":[]},{"line":"  | `Invalid_timing false ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      return (timing, min_balance)","counters":[]},{"line":"","counters":[]},{"line":"let validate_timing ~account ~txn_amount ~txn_global_slot =","counters":[]},{"line":"  let open Result.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%map timing, `Min_balance _ =","counters":[]},{"line":"    validate_timing_with_min_balance ~account ~txn_amount ~txn_global_slot","counters":[]},{"line":"  in","counters":[]},{"line":"  timing","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"module Make (L : Ledger_intf.S) : S with type ledger := L.t = struct","counters":[]},{"line":"  open L","counters":[]},{"line":"","counters":[]},{"line":"  let error s = Or_error.errorf \"Ledger.apply_transaction: %s\" s","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"","counters":[]},{"line":"  let error_opt e = Option.value_map ~default:(error e) ~f:Or_error.return","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"","counters":[]},{"line":"  let get_with_location ledger account_id =","counters":[]},{"line":"    match location_of_account ledger account_id with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Some location -> (","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        match get ledger location with","counters":[]},{"line":"        | Some account ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Ok (`Existing location, account)","counters":[]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            failwith \"Ledger location with no account\" )","counters":[]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Ok (`New, Account.create account_id Balance.zero)","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"","counters":[]},{"line":"  let set_with_location ledger location account =","counters":[]},{"line":"    match location with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | `Existing location ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Ok (set ledger location account)","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"    | `New ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        create_new_account ledger (Account.identifier account) account","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"","counters":[]},{"line":"  let add_amount balance amount =","counters":[]},{"line":"    error_opt \"overflow\" (Balance.add_amount balance amount)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"","counters":[]},{"line":"  let sub_amount balance amount =","counters":[]},{"line":"    error_opt \"insufficient funds\" (Balance.sub_amount balance amount)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"","counters":[]},{"line":"  let sub_account_creation_fee","counters":[]},{"line":"      ~(constraint_constants : Genesis_constants.Constraint_constants.t) action","counters":[]},{"line":"      amount =","counters":[]},{"line":"    let fee = constraint_constants.account_creation_fee in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"    (* Printf.eprintf \"MY_LOG.TRANSACTION_LOGIC.sub_account_creation_fee %d\\n%!\" *)","counters":[]},{"line":"    (*   (Fee.to_int fee) ; *)","counters":[]},{"line":"","counters":[]},{"line":"    (* if Ledger_intf.equal_account_state action `Added then *)","counters":[]},{"line":"    (*   Printf.eprintf \"MY_LOG.TRANSACTION_LOGIC.EQUAL_ADDED %d\\n%!\" *)","counters":[]},{"line":"    (*     (Amount.to_int amount) ; *)","counters":[]},{"line":"","counters":[]},{"line":"    if Ledger_intf.equal_account_state action `Added then","counters":[]},{"line":"      error_opt","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (sprintf","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"           !\"Error subtracting account creation fee %{sexp: Currency.Fee.t}; \\","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"             transaction amount %{sexp: Currency.Amount.t} insufficient\"","counters":[]},{"line":"           fee amount )","counters":[]},{"line":"        Amount.(sub amount (of_fee fee))","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"    else Ok amount","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"  let check b = ksprintf (fun s -> if b then Ok () else Or_error.error_string s)","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"","counters":[]},{"line":"  let validate_nonces txn_nonce account_nonce =","counters":[]},{"line":"    check","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (Account.Nonce.equal account_nonce txn_nonce)","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"      !\"Nonce in account %{sexp: Account.Nonce.t} different from nonce in \\","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"        transaction %{sexp: Account.Nonce.t}\"","counters":[]},{"line":"      account_nonce txn_nonce","counters":[]},{"line":"","counters":[]},{"line":"  let validate_time ~valid_until ~current_global_slot =","counters":[]},{"line":"    check","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Global_slot.(current_global_slot <= valid_until)","counters":[]},{"line":"      !\"Current global slot %{sexp: Global_slot.t} greater than transaction \\","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"        expiry slot %{sexp: Global_slot.t}\"","counters":[]},{"line":"      current_global_slot valid_until","counters":[]},{"line":"","counters":[]},{"line":"  module Transaction_applied = struct","counters":[]},{"line":"    include Transaction_applied","counters":[]},{"line":"","counters":[]},{"line":"    let transaction : t -> Transaction.t With_status.t =","counters":[]},{"line":"     fun { varying; _ } ->","counters":[]},{"line":"      match varying with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Command (Signed_command uc) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          With_status.map uc.common.user_command ~f:(fun cmd ->","counters":[]},{"line":"              Transaction.Command (User_command.Signed_command cmd) )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"      | Command (Zkapp_command s) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          With_status.map s.command ~f:(fun c ->","counters":[]},{"line":"              Transaction.Command (User_command.Zkapp_command c) )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"      | Fee_transfer f ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          With_status.map f.fee_transfer ~f:(fun f ->","counters":[]},{"line":"              Transaction.Fee_transfer f )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"      | Coinbase c ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          With_status.map c.coinbase ~f:(fun c -> Transaction.Coinbase c)","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"","counters":[]},{"line":"    let transaction_status : t -> Transaction_status.t =","counters":[]},{"line":"     fun { varying; _ } ->","counters":[]},{"line":"      match varying with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Command","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (Signed_command { common = { user_command = { status; _ }; _ }; _ })","counters":[]},{"line":"        ->","counters":[]},{"line":"          status","counters":[]},{"line":"      | Command (Zkapp_command c) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          c.command.status","counters":[]},{"line":"      | Fee_transfer f ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          f.fee_transfer.status","counters":[]},{"line":"      | Coinbase c ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          c.coinbase.status","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let get_new_accounts action pk =","counters":[]},{"line":"    if Ledger_intf.equal_account_state action `Added then [ pk ] else []","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":58,"col_end":58,"count":0},{"col_start":70,"col_end":70,"count":0}]},{"line":"","counters":[]},{"line":"  let has_locked_tokens ~global_slot ~account_id ledger =","counters":[]},{"line":"    let open Or_error.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let%map _, account = get_with_location ledger account_id in","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"    Account.has_locked_tokens ~global_slot account","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let failure (e : Transaction_status.Failure.t) = e","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"","counters":[]},{"line":"  let incr_balance (acct : Account.t) amt =","counters":[]},{"line":"    match add_amount acct.balance amt with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Ok balance ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Ok { acct with balance }","counters":[]},{"line":"    | Error _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Result.fail (failure Overflow)","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"","counters":[]},{"line":"  (* Helper function for [apply_user_command_unchecked] *)","counters":[]},{"line":"  let pay_fee' ~command ~nonce ~fee_payer ~fee ~ledger ~current_global_slot =","counters":[]},{"line":"    let open Or_error.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    (* Fee-payer information *)","counters":[]},{"line":"    let%bind location, account = get_with_location ledger fee_payer in","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"    let%bind () =","counters":[]},{"line":"      match location with","counters":[]},{"line":"      | `Existing _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          return ()","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"      | `New ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Or_error.errorf \"The fee-payer account does not exist\"","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"    in","counters":[]},{"line":"    let fee = Amount.of_fee fee in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let%bind balance = sub_amount account.balance fee in","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"    let%bind () = validate_nonces nonce account.nonce in","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"    let%map timing =","counters":[]},{"line":"      validate_timing ~txn_amount:fee ~txn_global_slot:current_global_slot","counters":[]},{"line":"        ~account","counters":[]},{"line":"    in","counters":[]},{"line":"    ( location","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    , { account with","counters":[]},{"line":"        balance","counters":[]},{"line":"      ; nonce = Account.Nonce.succ account.nonce","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"      ; receipt_chain_hash =","counters":[]},{"line":"          Receipt.Chain_hash.cons_signed_command_payload command","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"            account.receipt_chain_hash","counters":[]},{"line":"      ; timing","counters":[]},{"line":"      } )","counters":[]},{"line":"","counters":[]},{"line":"  (* Helper function for [apply_user_command_unchecked] *)","counters":[]},{"line":"  let pay_fee ~user_command ~signer_pk ~ledger ~current_global_slot =","counters":[]},{"line":"    let open Or_error.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    (* Fee-payer information *)","counters":[]},{"line":"    let nonce = Signed_command.nonce user_command in","counters":[]},{"line":"    let fee_payer = Signed_command.fee_payer user_command in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let%bind () =","counters":[]},{"line":"      let fee_token = Signed_command.fee_token user_command in","counters":[]},{"line":"      let%bind () =","counters":[]},{"line":"        (* TODO: Enable multi-sig. *)","counters":[]},{"line":"        if","counters":[]},{"line":"          Public_key.Compressed.equal","counters":[]},{"line":"            (Account_id.public_key fee_payer)","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"            signer_pk","counters":[]},{"line":"        then return ()","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"        else","counters":[]},{"line":"          Or_error.errorf","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"            \"Cannot pay fees from a public key that did not sign the \\","counters":[]},{"line":"             transaction\"","counters":[]},{"line":"      in","counters":[]},{"line":"      let%map () =","counters":[]},{"line":"        (* TODO: Remove this check and update the transaction snark once we have","counters":[]},{"line":"           an exchange rate mechanism. See issue #4447.","counters":[]},{"line":"        *)","counters":[]},{"line":"        if Token_id.equal fee_token Token_id.default then return ()","counters":[{"col_start":58,"col_end":58,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"        else","counters":[]},{"line":"          Or_error.errorf","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"            \"Cannot create transactions with fee_token different from the \\","counters":[]},{"line":"             default\"","counters":[]},{"line":"      in","counters":[]},{"line":"      ()","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    in","counters":[]},{"line":"    let%map loc, account' =","counters":[]},{"line":"      pay_fee' ~command:(Signed_command_payload user_command.payload) ~nonce","counters":[]},{"line":"        ~fee_payer","counters":[]},{"line":"        ~fee:(Signed_command.fee user_command)","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"        ~ledger ~current_global_slot","counters":[]},{"line":"    in","counters":[]},{"line":"    (loc, account')","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  (* someday: It would probably be better if we didn't modify the receipt chain hash","counters":[]},{"line":"     in the case that the sender is equal to the receiver, but it complicates the SNARK, so","counters":[]},{"line":"     we don't for now. *)","counters":[]},{"line":"  let apply_user_command_unchecked","counters":[]},{"line":"      ~(constraint_constants : Genesis_constants.Constraint_constants.t)","counters":[]},{"line":"      ~txn_global_slot ledger","counters":[]},{"line":"      ({ payload; signer; signature = _ } as user_command : Signed_command.t) =","counters":[]},{"line":"    let open Or_error.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let signer_pk = Public_key.compress signer in","counters":[]},{"line":"    let current_global_slot = txn_global_slot in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let%bind () =","counters":[]},{"line":"      validate_time","counters":[]},{"line":"        ~valid_until:(Signed_command.valid_until user_command)","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"        ~current_global_slot","counters":[]},{"line":"    in","counters":[]},{"line":"    (* Fee-payer information *)","counters":[]},{"line":"    let fee_payer = Signed_command.fee_payer user_command in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let%bind fee_payer_location, fee_payer_account =","counters":[]},{"line":"      pay_fee ~user_command ~signer_pk ~ledger ~current_global_slot","counters":[]},{"line":"    in","counters":[]},{"line":"    let%bind () =","counters":[]},{"line":"      if Account.has_permission ~to_:`Send fee_payer_account then Ok ()","counters":[{"col_start":66,"col_end":66,"count":0}]},{"line":"      else","counters":[]},{"line":"        Or_error.error_string","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"          Transaction_status.Failure.(describe Update_not_permitted_balance)","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"    in","counters":[]},{"line":"    (* Charge the fee. This must happen, whether or not the command itself","counters":[]},{"line":"       succeeds, to ensure that the network is compensated for processing this","counters":[]},{"line":"       command.","counters":[]},{"line":"    *)","counters":[]},{"line":"    let%bind () =","counters":[]},{"line":"      set_with_location ledger fee_payer_location fee_payer_account","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"    in","counters":[]},{"line":"    let source = Signed_command.source user_command in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let receiver = Signed_command.receiver user_command in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let exception Reject of Error.t in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let ok_or_reject = function Ok x -> x | Error err -> raise (Reject err) in","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"    let compute_updates () =","counters":[]},{"line":"      let open Result.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      (* Compute the necessary changes to apply the command, failing if any of","counters":[]},{"line":"         the conditions are not met.","counters":[]},{"line":"      *)","counters":[]},{"line":"      match payload.body with","counters":[]},{"line":"      | Stake_delegation _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let receiver_location, _receiver_account =","counters":[]},{"line":"            (* Check that receiver account exists. *)","counters":[]},{"line":"            get_with_location ledger receiver |> ok_or_reject","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"          in","counters":[]},{"line":"          let source_location, source_account =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            get_with_location ledger source |> ok_or_reject","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%bind () =","counters":[]},{"line":"            if Account.has_permission ~to_:`Set_delegate source_account then","counters":[]},{"line":"              Ok ()","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"            else Error Transaction_status.Failure.Update_not_permitted_delegate","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%bind () =","counters":[]},{"line":"            match (source_location, receiver_location) with","counters":[]},{"line":"            | `Existing _, `Existing _ ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                return ()","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"            | `New, _ ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Result.fail Transaction_status.Failure.Source_not_present","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"            | _, `New ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Result.fail Transaction_status.Failure.Receiver_not_present","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"          in","counters":[]},{"line":"          let previous_delegate = source_account.delegate in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          (* Timing is always valid, but we need to record any switch from","counters":[]},{"line":"             timed to untimed here to stay in sync with the snark.","counters":[]},{"line":"          *)","counters":[]},{"line":"          let%map timing =","counters":[]},{"line":"            validate_timing ~txn_amount:Amount.zero","counters":[]},{"line":"              ~txn_global_slot:current_global_slot ~account:source_account","counters":[]},{"line":"            |> Result.map_error ~f:timing_error_to_user_command_status","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"          in","counters":[]},{"line":"          let source_account =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            { source_account with","counters":[]},{"line":"              delegate = Some (Account_id.public_key receiver)","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"            ; timing","counters":[]},{"line":"            }","counters":[]},{"line":"          in","counters":[]},{"line":"          ( [ (source_location, source_account) ]","counters":[]},{"line":"          , Transaction_applied.Signed_command_applied.Body.Stake_delegation","counters":[]},{"line":"              { previous_delegate } )","counters":[]},{"line":"      | Payment { amount; _ } ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"         (* Printf.eprintf \"MY_LOG.getting_location\\n%!\"; *)","counters":[]},{"line":"          let receiver_location, receiver_account =","counters":[]},{"line":"            get_with_location ledger receiver |> ok_or_reject","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"          in","counters":[]},{"line":"         (* Printf.eprintf \"MY_LOG.got location\\n%!\"; *)","counters":[]},{"line":"          let%bind () =","counters":[]},{"line":"            if Account.has_permission ~to_:`Receive receiver_account then Ok ()","counters":[{"col_start":74,"col_end":74,"count":0}]},{"line":"            else Error Transaction_status.Failure.Update_not_permitted_balance","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%bind source_location, source_account =","counters":[]},{"line":"            let ret =","counters":[]},{"line":"              if Account_id.equal source receiver then","counters":[]},{"line":"                (*just check if the timing needs updating*)","counters":[]},{"line":"                let%bind location, account =","counters":[]},{"line":"                  match receiver_location with","counters":[]},{"line":"                  | `Existing _ ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      return (receiver_location, receiver_account)","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                  | `New ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      Result.fail Transaction_status.Failure.Source_not_present","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                in","counters":[]},{"line":"                let%map timing =","counters":[]},{"line":"                  validate_timing ~txn_amount:amount","counters":[]},{"line":"                    ~txn_global_slot:current_global_slot ~account","counters":[]},{"line":"                  |> Result.map_error ~f:timing_error_to_user_command_status","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"                in","counters":[]},{"line":"                (location, { account with timing })","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"              else","counters":[]},{"line":"                let location, account =","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  get_with_location ledger source |> ok_or_reject","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"                in","counters":[]},{"line":"                let%bind () =","counters":[]},{"line":"                  match location with","counters":[]},{"line":"                  | `Existing _ ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      return ()","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                  | `New ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      Result.fail Transaction_status.Failure.Source_not_present","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                in","counters":[]},{"line":"                let%bind timing =","counters":[]},{"line":"                  validate_timing ~txn_amount:amount","counters":[]},{"line":"                    ~txn_global_slot:current_global_slot ~account","counters":[]},{"line":"                  |> Result.map_error ~f:timing_error_to_user_command_status","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"                in","counters":[]},{"line":"                let%map balance =","counters":[]},{"line":"                  Result.map_error (sub_amount account.balance amount)","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"                    ~f:(fun _ ->","counters":[]},{"line":"                      Transaction_status.Failure.Source_insufficient_balance )","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                in","counters":[]},{"line":"                (location, { account with timing; balance })","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"            in","counters":[]},{"line":"            if Account_id.equal fee_payer source then","counters":[]},{"line":"              (* Don't process transactions with insufficient balance from the","counters":[]},{"line":"                 fee-payer.","counters":[]},{"line":"              *)","counters":[]},{"line":"              match ret with","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              | Ok x ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Ok x","counters":[]},{"line":"              | Error failure ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  raise","counters":[]},{"line":"                    (Reject","counters":[]},{"line":"                       (Error.createf \"%s\"","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"                          (Transaction_status.Failure.describe failure) ) )","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"            else ret","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%bind () =","counters":[]},{"line":"            if Account.has_permission ~to_:`Send source_account then Ok ()","counters":[{"col_start":69,"col_end":69,"count":0}]},{"line":"            else Error Transaction_status.Failure.Update_not_permitted_balance","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"          in","counters":[]},{"line":"          (* Charge the account creation fee. *)","counters":[]},{"line":"          let%bind receiver_amount =","counters":[]},{"line":"            (* Printf.eprintf \"Amount_insufficient_to_create_account HERE222\\n%!\" ; *)","counters":[]},{"line":"            match receiver_location with","counters":[]},{"line":"            | `Existing _ ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (* Printf.eprintf *)","counters":[]},{"line":"                (*   \"MY_LOG.apply_user_command_unchecked existing\\n%!\" ; *)","counters":[]},{"line":"                return amount","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"            | `New ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"               (* Subtract the creation fee from the transaction amount. *)","counters":[]},{"line":"","counters":[]},{"line":"                sub_account_creation_fee ~constraint_constants `Added amount","counters":[]},{"line":"                |> Result.map_error ~f:(fun _ ->","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"                       Transaction_status.Failure","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                       .Amount_insufficient_to_create_account )","counters":[]},{"line":"          in","counters":[]},{"line":"          (* Printf.eprintf *)","counters":[]},{"line":"          (*   \"MY_LOG.apply_user_command_unchecked receiver_amount=%d\\n%!\" *)","counters":[]},{"line":"          (*   (Amount.to_int receiver_amount) ; *)","counters":[]},{"line":"          let%map receiver_account =","counters":[]},{"line":"            incr_balance receiver_account receiver_amount","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"          in","counters":[]},{"line":"          let new_accounts =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            match receiver_location with","counters":[]},{"line":"            | `Existing _ ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                []","counters":[]},{"line":"            | `New ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                [ receiver ]","counters":[]},{"line":"          in","counters":[]},{"line":"          (* let receiver_loc = *)","counters":[]},{"line":"          (*   match receiver_location with *)","counters":[]},{"line":"          (*   | `Existing _ -> *)","counters":[]},{"line":"          (*       \"Existing\" *)","counters":[]},{"line":"          (*   | `New -> *)","counters":[]},{"line":"          (*       \"New\" *)","counters":[]},{"line":"          (* in *)","counters":[]},{"line":"          (* let source_loc = *)","counters":[]},{"line":"          (*   match source_location with *)","counters":[]},{"line":"          (*   | `Existing _ -> *)","counters":[]},{"line":"          (*       \"Existing\" *)","counters":[]},{"line":"          (*   | `New -> *)","counters":[]},{"line":"          (*       \"New\" *)","counters":[]},{"line":"          (* in *)","counters":[]},{"line":"          (* Printf.eprintf *)","counters":[]},{"line":"          (*   \"MY_LOG.apply_user_command_unchecked applied receiver=%s source=%s!\\n%!\" *)","counters":[]},{"line":"          (*   receiver_loc source_loc ; *)","counters":[]},{"line":"          ( [ (receiver_location, receiver_account)","counters":[]},{"line":"            ; (source_location, source_account)","counters":[]},{"line":"            ]","counters":[]},{"line":"          , Transaction_applied.Signed_command_applied.Body.Payment","counters":[]},{"line":"              { new_accounts } )","counters":[]},{"line":"    in","counters":[]},{"line":"    match compute_updates () with","counters":[]},{"line":"    | Ok (located_accounts, applied_body) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (* Printf.eprintf \"compute_updates ok\\n%!\" ; *)","counters":[]},{"line":"        (* Update the ledger. *)","counters":[]},{"line":"        let%bind () =","counters":[]},{"line":"          List.fold located_accounts ~init:(Ok ())","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"            ~f:(fun acc (location, account) ->","counters":[]},{"line":"              let%bind () = acc in","counters":[]},{"line":"              set_with_location ledger location account )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"        in","counters":[]},{"line":"        let applied_common : Transaction_applied.Signed_command_applied.Common.t","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            =","counters":[]},{"line":"          { user_command = { data = user_command; status = Applied } }","counters":[]},{"line":"        in","counters":[]},{"line":"        (* Printf.eprintf \"compute_updates ok2\\n%!\" ; *)","counters":[]},{"line":"        return","counters":[]},{"line":"          ( { common = applied_common; body = applied_body }","counters":[]},{"line":"            : Transaction_applied.Signed_command_applied.t )","counters":[]},{"line":"    | Error failure ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (* Printf.eprintf \"compute_updates err=%s\\n%!\" *)","counters":[]},{"line":"        (*   (Transaction_status.Failure.to_string failure) ; *)","counters":[]},{"line":"        (* Do not update the ledger. Except for the fee payer which is already updated *)","counters":[]},{"line":"        let applied_common : Transaction_applied.Signed_command_applied.Common.t","counters":[]},{"line":"            =","counters":[]},{"line":"          { user_command =","counters":[]},{"line":"              { data = user_command","counters":[]},{"line":"              ; status =","counters":[]},{"line":"                  Failed","counters":[]},{"line":"                    (Transaction_status.Failure.Collection.of_single_failure","counters":[{"col_start":75,"col_end":75,"count":0}]},{"line":"                       failure )","counters":[]},{"line":"              }","counters":[]},{"line":"          }","counters":[]},{"line":"        in","counters":[]},{"line":"        return","counters":[]},{"line":"          ( { common = applied_common; body = Failed }","counters":[]},{"line":"            : Transaction_applied.Signed_command_applied.t )","counters":[]},{"line":"    | exception Reject err ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (* Printf.eprintf \"compute_updates exception\\n%!\" ; *)","counters":[]},{"line":"        (* TODO: These transactions should never reach this stage, this error","counters":[]},{"line":"           should be fatal.","counters":[]},{"line":"        *)","counters":[]},{"line":"        Error err","counters":[]},{"line":"","counters":[]},{"line":"  let apply_user_command ~constraint_constants ~txn_global_slot ledger","counters":[]},{"line":"      (user_command : Signed_command.With_valid_signature.t) =","counters":[]},{"line":"    apply_user_command_unchecked ~constraint_constants ~txn_global_slot ledger","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (Signed_command.forget_check user_command)","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"","counters":[]},{"line":"  module Global_state = struct","counters":[]},{"line":"    type t =","counters":[]},{"line":"      { ledger : L.t","counters":[]},{"line":"      ; fee_excess : Amount.Signed.t","counters":[]},{"line":"      ; supply_increase : Amount.Signed.t","counters":[]},{"line":"      ; protocol_state : Zkapp_precondition.Protocol_state.View.t","counters":[]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    let ledger { ledger; _ } = L.create_masked ledger","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"","counters":[]},{"line":"    let set_ledger ~should_update t ledger =","counters":[]},{"line":"      if should_update then L.apply_mask t.ledger ~masked:ledger ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"      t","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let fee_excess { fee_excess; _ } = fee_excess","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"    let set_fee_excess t fee_excess = { t with fee_excess }","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"","counters":[]},{"line":"    let supply_increase { supply_increase; _ } = supply_increase","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"","counters":[]},{"line":"    let set_supply_increase t supply_increase = { t with supply_increase }","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"","counters":[]},{"line":"    let global_slot_since_genesis { protocol_state; _ } =","counters":[]},{"line":"      protocol_state.global_slot_since_genesis","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Inputs = struct","counters":[]},{"line":"    let with_label ~label:_ f = f ()","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"","counters":[]},{"line":"    let value_if b ~then_ ~else_ = if b then then_ else else_","counters":[{"col_start":35,"col_end":35,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"","counters":[]},{"line":"    module Global_state = Global_state","counters":[]},{"line":"","counters":[]},{"line":"    module Field = struct","counters":[]},{"line":"      type t = Snark_params.Tick.Field.t","counters":[]},{"line":"","counters":[]},{"line":"      let if_ = value_if","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Bool = struct","counters":[]},{"line":"      type t = bool","counters":[]},{"line":"","counters":[]},{"line":"      module Assert = struct","counters":[]},{"line":"        let is_true ~pos b =","counters":[]},{"line":"          try assert b","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"          with Assert_failure _ ->","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"            let file, line, col, _ecol = pos in","counters":[]},{"line":"            raise (Assert_failure (file, line, col))","counters":[]},{"line":"","counters":[]},{"line":"        let any ~pos bs = List.exists ~f:Fn.id bs |> is_true ~pos","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      let if_ = value_if","counters":[]},{"line":"","counters":[]},{"line":"      let true_ = true","counters":[]},{"line":"","counters":[]},{"line":"      let false_ = false","counters":[]},{"line":"","counters":[]},{"line":"      let equal = Bool.equal","counters":[]},{"line":"","counters":[]},{"line":"      let not = not","counters":[]},{"line":"","counters":[]},{"line":"      let ( ||| ) = ( || )","counters":[]},{"line":"","counters":[]},{"line":"      let ( &&& ) = ( && )","counters":[]},{"line":"","counters":[]},{"line":"      let display b ~label = sprintf \"%s: %b\" label b","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"      let all = List.for_all ~f:Fn.id","counters":[]},{"line":"","counters":[]},{"line":"      type failure_status = Transaction_status.Failure.t option","counters":[]},{"line":"","counters":[]},{"line":"      type failure_status_tbl = Transaction_status.Failure.Collection.t","counters":[]},{"line":"","counters":[]},{"line":"      let is_empty t = List.join t |> List.is_empty","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"","counters":[]},{"line":"      let assert_with_failure_status_tbl ~pos b failure_status_tbl =","counters":[]},{"line":"        let file, line, col, ecol = pos in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        if (not b) && not (is_empty failure_status_tbl) then","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"          (* Raise a more useful error message if we have a failure","counters":[]},{"line":"             description. *)","counters":[]},{"line":"          let failure_msg =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Yojson.Safe.to_string","counters":[]},{"line":"            @@ Transaction_status.Failure.Collection.Display.to_yojson","counters":[{"col_start":69,"col_end":69,"count":0}]},{"line":"            @@ Transaction_status.Failure.Collection.to_display","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"                 failure_status_tbl","counters":[]},{"line":"          in","counters":[]},{"line":"          Error.raise @@ Error.of_string","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"          @@ sprintf \"File %S, line %d, characters %d-%d: %s\" file line col ecol","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"               failure_msg","counters":[]},{"line":"        else","counters":[]},{"line":"          try assert b","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"          with Assert_failure _ -> raise (Assert_failure (file, line, col))","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Account_id = struct","counters":[]},{"line":"      include Account_id","counters":[]},{"line":"","counters":[]},{"line":"      let if_ = value_if","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Ledger = struct","counters":[]},{"line":"      type t = L.t","counters":[]},{"line":"","counters":[]},{"line":"      let if_ = value_if","counters":[]},{"line":"","counters":[]},{"line":"      let empty = L.empty","counters":[]},{"line":"","counters":[]},{"line":"      type inclusion_proof = [ `Existing of location | `New ]","counters":[]},{"line":"","counters":[]},{"line":"      let get_account p l =","counters":[]},{"line":"        let loc, acct =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Or_error.ok_exn (get_with_location l (Account_update.account_id p))","counters":[{"col_start":43,"col_end":43,"count":0},{"col_start":72,"col_end":72,"count":0}]},{"line":"        in","counters":[]},{"line":"        (acct, loc)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      let set_account l (a, loc) =","counters":[]},{"line":"        Or_error.ok_exn (set_with_location l loc a) ;","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"        l","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      let check_inclusion _ledger (_account, _loc) = ()","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"","counters":[]},{"line":"      let check_account public_key token_id","counters":[]},{"line":"          ((account, loc) : Account.t * inclusion_proof) =","counters":[]},{"line":"        assert (Public_key.Compressed.equal public_key account.public_key) ;","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"        assert (Token_id.equal token_id account.token_id) ;","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"        match loc with `Existing _ -> `Is_new false | `New -> `Is_new true","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Transaction_commitment = struct","counters":[]},{"line":"      type t = Field.t","counters":[]},{"line":"","counters":[]},{"line":"      let empty = Zkapp_command.Transaction_commitment.empty","counters":[]},{"line":"","counters":[]},{"line":"      let commitment ~account_updates =","counters":[]},{"line":"        let account_updates_hash =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Mina_base.Zkapp_command.Call_forest.hash account_updates","counters":[]},{"line":"        in","counters":[]},{"line":"        Zkapp_command.Transaction_commitment.create ~account_updates_hash","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      let full_commitment ~account_update ~memo_hash ~commitment =","counters":[]},{"line":"        (* when called from Zkapp_command_logic.apply, the account_update is the fee payer *)","counters":[]},{"line":"        let fee_payer_hash =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Zkapp_command.Digest.Account_update.create account_update","counters":[]},{"line":"        in","counters":[]},{"line":"        Zkapp_command.Transaction_commitment.create_complete commitment","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ~memo_hash ~fee_payer_hash","counters":[]},{"line":"","counters":[]},{"line":"      let if_ = value_if","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Index = struct","counters":[]},{"line":"      type t = Mina_numbers.Index.t","counters":[]},{"line":"","counters":[]},{"line":"      let zero, succ = Mina_numbers.Index.(zero, succ)","counters":[]},{"line":"","counters":[]},{"line":"      let if_ = value_if","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Public_key = struct","counters":[]},{"line":"      type t = Public_key.Compressed.t","counters":[]},{"line":"","counters":[]},{"line":"      let if_ = value_if","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Controller = struct","counters":[]},{"line":"      type t = Permissions.Auth_required.t","counters":[]},{"line":"","counters":[]},{"line":"      let if_ = value_if","counters":[]},{"line":"","counters":[]},{"line":"      let check ~proof_verifies ~signature_verifies perm =","counters":[]},{"line":"        (* Invariant: We either have a proof, a signature, or neither. *)","counters":[]},{"line":"        assert (not (proof_verifies && signature_verifies)) ;","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"        let tag =","counters":[]},{"line":"          if proof_verifies then Control.Tag.Proof","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"          else if signature_verifies then Control.Tag.Signature","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"          else Control.Tag.None_given","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"        in","counters":[]},{"line":"        Permissions.Auth_required.check perm tag","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Global_slot = struct","counters":[]},{"line":"      include Mina_numbers.Global_slot","counters":[]},{"line":"","counters":[]},{"line":"      let if_ = value_if","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Nonce = struct","counters":[]},{"line":"      type t = Account.Nonce.t","counters":[]},{"line":"","counters":[]},{"line":"      let if_ = value_if","counters":[]},{"line":"","counters":[]},{"line":"      let succ = Account.Nonce.succ","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Receipt_chain_hash = struct","counters":[]},{"line":"      type t = Receipt.Chain_hash.t","counters":[]},{"line":"","counters":[]},{"line":"      module Elt = struct","counters":[]},{"line":"        type t = Receipt.Zkapp_command_elt.t","counters":[]},{"line":"","counters":[]},{"line":"        let of_transaction_commitment tc =","counters":[]},{"line":"          Receipt.Zkapp_command_elt.Zkapp_command_commitment tc","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      let cons_zkapp_command_commitment =","counters":[]},{"line":"        Receipt.Chain_hash.cons_zkapp_command_commitment","counters":[]},{"line":"","counters":[]},{"line":"      let if_ = value_if","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module State_hash = struct","counters":[]},{"line":"      include State_hash","counters":[]},{"line":"","counters":[]},{"line":"      let if_ = value_if","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Timing = struct","counters":[]},{"line":"      type t = Account_update.Update.Timing_info.t option","counters":[]},{"line":"","counters":[]},{"line":"      let if_ = value_if","counters":[]},{"line":"","counters":[]},{"line":"      let vesting_period (t : t) =","counters":[]},{"line":"        match t with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | Some t ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            t.vesting_period","counters":[]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (Account_timing.to_record Untimed).vesting_period","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Balance = struct","counters":[]},{"line":"      include Balance","counters":[]},{"line":"","counters":[]},{"line":"      let if_ = value_if","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Verification_key = struct","counters":[]},{"line":"      type t = (Side_loaded_verification_key.t, Field.t) With_hash.t option","counters":[]},{"line":"","counters":[]},{"line":"      let if_ = value_if","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Sequence_events = struct","counters":[]},{"line":"      type t = Zkapp_account.Sequence_events.t","counters":[]},{"line":"","counters":[]},{"line":"      let is_empty = List.is_empty","counters":[]},{"line":"","counters":[]},{"line":"      let push_events = Account_update.Sequence_events.push_events","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Zkapp_uri = struct","counters":[]},{"line":"      type t = string","counters":[]},{"line":"","counters":[]},{"line":"      let if_ = value_if","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Token_symbol = struct","counters":[]},{"line":"      type t = Account.Token_symbol.t","counters":[]},{"line":"","counters":[]},{"line":"      let if_ = value_if","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Account = struct","counters":[]},{"line":"      include Account","counters":[]},{"line":"","counters":[]},{"line":"      module Permissions = struct","counters":[]},{"line":"        let edit_state : t -> Controller.t = fun a -> a.permissions.edit_state","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"","counters":[]},{"line":"        let send : t -> Controller.t = fun a -> a.permissions.send","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"","counters":[]},{"line":"        let receive : t -> Controller.t = fun a -> a.permissions.receive","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"","counters":[]},{"line":"        let set_delegate : t -> Controller.t =","counters":[]},{"line":"         fun a -> a.permissions.set_delegate","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"","counters":[]},{"line":"        let set_permissions : t -> Controller.t =","counters":[]},{"line":"         fun a -> a.permissions.set_permissions","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"","counters":[]},{"line":"        let set_verification_key : t -> Controller.t =","counters":[]},{"line":"         fun a -> a.permissions.set_verification_key","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"","counters":[]},{"line":"        let set_zkapp_uri : t -> Controller.t =","counters":[]},{"line":"         fun a -> a.permissions.set_zkapp_uri","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"","counters":[]},{"line":"        let edit_sequence_state : t -> Controller.t =","counters":[]},{"line":"         fun a -> a.permissions.edit_sequence_state","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"","counters":[]},{"line":"        let set_token_symbol : t -> Controller.t =","counters":[]},{"line":"         fun a -> a.permissions.set_token_symbol","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"","counters":[]},{"line":"        let increment_nonce : t -> Controller.t =","counters":[]},{"line":"         fun a -> a.permissions.increment_nonce","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"","counters":[]},{"line":"        let set_voting_for : t -> Controller.t =","counters":[]},{"line":"         fun a -> a.permissions.set_voting_for","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"","counters":[]},{"line":"        type t = Permissions.t","counters":[]},{"line":"","counters":[]},{"line":"        let if_ = value_if","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      type timing = Account_update.Update.Timing_info.t option","counters":[]},{"line":"","counters":[]},{"line":"      let timing (a : t) : timing =","counters":[]},{"line":"        Account_update.Update.Timing_info.of_account_timing a.timing","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      let set_timing (a : t) (timing : timing) : t =","counters":[]},{"line":"        { a with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          timing =","counters":[]},{"line":"            Option.value_map ~default:Account_timing.Untimed","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"              ~f:Account_update.Update.Timing_info.to_account_timing timing","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"      let is_timed (a : t) =","counters":[]},{"line":"        match a.timing with Account_timing.Untimed -> false | _ -> true","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"","counters":[]},{"line":"      let set_token_id (a : t) (id : Token_id.t) : t = { a with token_id = id }","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"","counters":[]},{"line":"      let balance (a : t) : Balance.t = a.balance","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"      let set_balance (balance : Balance.t) (a : t) : t = { a with balance }","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"","counters":[]},{"line":"      let check_timing ~txn_global_slot account =","counters":[]},{"line":"        let invalid_timing, timing, _ =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          validate_timing_with_min_balance' ~txn_amount:Amount.zero","counters":[]},{"line":"            ~txn_global_slot ~account","counters":[]},{"line":"        in","counters":[]},{"line":"        ( invalid_timing","counters":[]},{"line":"        , Account_update.Update.Timing_info.of_account_timing timing )","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"","counters":[]},{"line":"      let receipt_chain_hash (a : t) : Receipt.Chain_hash.t =","counters":[]},{"line":"        a.receipt_chain_hash","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      let set_receipt_chain_hash (a : t) hash =","counters":[]},{"line":"        { a with receipt_chain_hash = hash }","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      let make_zkapp (a : t) =","counters":[]},{"line":"        let zkapp =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          match a.zkapp with","counters":[]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Some Zkapp_account.default","counters":[]},{"line":"          | Some _ as zkapp ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              zkapp","counters":[]},{"line":"        in","counters":[]},{"line":"        { a with zkapp }","counters":[]},{"line":"","counters":[]},{"line":"      let unmake_zkapp (a : t) : t =","counters":[]},{"line":"        let zkapp =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          match a.zkapp with","counters":[]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              None","counters":[]},{"line":"          | Some zkapp ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              if Zkapp_account.(equal default zkapp) then None else Some zkapp","counters":[{"col_start":36,"col_end":36,"count":0},{"col_start":58,"col_end":58,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"        in","counters":[]},{"line":"        { a with zkapp }","counters":[]},{"line":"","counters":[]},{"line":"      let get_zkapp (a : t) = Option.value_exn a.zkapp","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"","counters":[]},{"line":"      let set_zkapp (a : t) ~f : t = { a with zkapp = Option.map a.zkapp ~f }","counters":[{"col_start":37,"col_end":37,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"","counters":[]},{"line":"      let proved_state (a : t) = (get_zkapp a).proved_state","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"","counters":[]},{"line":"      let set_proved_state proved_state (a : t) =","counters":[]},{"line":"        set_zkapp a ~f:(fun zkapp -> { zkapp with proved_state })","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"      let app_state (a : t) = (get_zkapp a).app_state","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"      let set_app_state app_state (a : t) =","counters":[]},{"line":"        set_zkapp a ~f:(fun zkapp -> { zkapp with app_state })","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"      let register_verification_key (_ : t) = ()","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"","counters":[]},{"line":"      let verification_key (a : t) = (get_zkapp a).verification_key","counters":[{"col_start":37,"col_end":37,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"","counters":[]},{"line":"      let set_verification_key verification_key (a : t) =","counters":[]},{"line":"        set_zkapp a ~f:(fun zkapp -> { zkapp with verification_key })","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"      let last_sequence_slot (a : t) = (get_zkapp a).last_sequence_slot","counters":[{"col_start":39,"col_end":39,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"","counters":[]},{"line":"      let set_last_sequence_slot last_sequence_slot (a : t) =","counters":[]},{"line":"        set_zkapp a ~f:(fun zkapp -> { zkapp with last_sequence_slot })","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"      let sequence_state (a : t) = (get_zkapp a).sequence_state","counters":[{"col_start":35,"col_end":35,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"      let set_sequence_state sequence_state (a : t) =","counters":[]},{"line":"        set_zkapp a ~f:(fun zkapp -> { zkapp with sequence_state })","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"      let zkapp_uri (a : t) =","counters":[]},{"line":"        Option.value_map a.zkapp ~default:\"\" ~f:(fun zkapp -> zkapp.zkapp_uri)","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"","counters":[]},{"line":"      let set_zkapp_uri zkapp_uri (a : t) : t =","counters":[]},{"line":"        { a with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          zkapp = Option.map a.zkapp ~f:(fun zkapp -> { zkapp with zkapp_uri })","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"      let token_symbol (a : t) = a.token_symbol","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"","counters":[]},{"line":"      let set_token_symbol token_symbol (a : t) = { a with token_symbol }","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"","counters":[]},{"line":"      let public_key (a : t) = a.public_key","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"","counters":[]},{"line":"      let set_public_key public_key (a : t) = { a with public_key }","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"","counters":[]},{"line":"      let delegate (a : t) = Account.delegate_opt a.delegate","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"      let set_delegate delegate (a : t) =","counters":[]},{"line":"        let delegate =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          if Signature_lib.Public_key.Compressed.(equal empty) delegate then","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"            None","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          else Some delegate","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"        in","counters":[]},{"line":"        { a with delegate }","counters":[]},{"line":"","counters":[]},{"line":"      let nonce (a : t) = a.nonce","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"","counters":[]},{"line":"      let set_nonce nonce (a : t) = { a with nonce }","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"","counters":[]},{"line":"      let voting_for (a : t) = a.voting_for","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"","counters":[]},{"line":"      let set_voting_for voting_for (a : t) = { a with voting_for }","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"","counters":[]},{"line":"      let permissions (a : t) = a.permissions","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"","counters":[]},{"line":"      let set_permissions permissions (a : t) = { a with permissions }","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Amount = struct","counters":[]},{"line":"      open Currency.Amount","counters":[]},{"line":"","counters":[]},{"line":"      type unsigned = t","counters":[]},{"line":"","counters":[]},{"line":"      type t = unsigned","counters":[]},{"line":"","counters":[]},{"line":"      let if_ = value_if","counters":[]},{"line":"","counters":[]},{"line":"      module Signed = struct","counters":[]},{"line":"        include Signed","counters":[]},{"line":"","counters":[]},{"line":"        let if_ = value_if","counters":[]},{"line":"","counters":[]},{"line":"        let is_pos (t : t) = Sgn.equal t.sgn Pos","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      let zero = zero","counters":[]},{"line":"","counters":[]},{"line":"      let equal = equal","counters":[]},{"line":"","counters":[]},{"line":"      let add_flagged = add_flagged","counters":[]},{"line":"","counters":[]},{"line":"      let add_signed_flagged (x1 : t) (x2 : Signed.t) : t * [ `Overflow of bool ]","counters":[]},{"line":"          =","counters":[]},{"line":"        let y, `Overflow b = Signed.(add_flagged (of_unsigned x1) x2) in","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":47,"col_end":47,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"        match y.sgn with","counters":[]},{"line":"        | Pos ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (y.magnitude, `Overflow b)","counters":[]},{"line":"        | Neg ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (* We want to capture the accurate value so that this will match","counters":[]},{"line":"               with the values in the snarked logic.","counters":[]},{"line":"            *)","counters":[]},{"line":"            let magnitude =","counters":[]},{"line":"              Amount.to_uint64 y.magnitude","counters":[]},{"line":"              |> Unsigned.UInt64.(mul (sub zero one))","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"              |> Amount.of_uint64","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"            in","counters":[]},{"line":"            (magnitude, `Overflow true)","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"","counters":[]},{"line":"      let of_constant_fee = of_fee","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Token_id = struct","counters":[]},{"line":"      include Token_id","counters":[]},{"line":"","counters":[]},{"line":"      let if_ = value_if","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Protocol_state_precondition = struct","counters":[]},{"line":"      include Zkapp_precondition.Protocol_state","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Account_update = struct","counters":[]},{"line":"      include Account_update","counters":[]},{"line":"","counters":[]},{"line":"      module Account_precondition = struct","counters":[]},{"line":"        include Account_update.Account_precondition","counters":[]},{"line":"","counters":[]},{"line":"        let nonce (t : Account_update.t) = nonce t.body.preconditions.account","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      type 'a or_ignore = 'a Zkapp_basic.Or_ignore.t","counters":[]},{"line":"","counters":[]},{"line":"      type call_forest = Zkapp_call_forest.t","counters":[]},{"line":"","counters":[]},{"line":"      type transaction_commitment = Transaction_commitment.t","counters":[]},{"line":"","counters":[]},{"line":"      let caller (p : t) = p.body.caller","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"","counters":[]},{"line":"      let check_authorization ~commitment:_ ~calls:_ (account_update : t) =","counters":[]},{"line":"        (* The transaction's validity should already have been checked before","counters":[]},{"line":"           this point.","counters":[]},{"line":"        *)","counters":[]},{"line":"        match account_update.authorization with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | Signature _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (`Proof_verifies false, `Signature_verifies true)","counters":[]},{"line":"        | Proof _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (`Proof_verifies true, `Signature_verifies false)","counters":[]},{"line":"        | None_given ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (`Proof_verifies false, `Signature_verifies false)","counters":[]},{"line":"","counters":[]},{"line":"      let is_proved (account_update : t) =","counters":[]},{"line":"        match account_update.body.authorization_kind with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | Proof ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            true","counters":[]},{"line":"        | Signature | None_given ->","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"            false","counters":[]},{"line":"","counters":[]},{"line":"      let is_signed (account_update : t) =","counters":[]},{"line":"        match account_update.body.authorization_kind with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | Signature ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            true","counters":[]},{"line":"        | Proof | None_given ->","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"            false","counters":[]},{"line":"","counters":[]},{"line":"      module Update = struct","counters":[]},{"line":"        open Zkapp_basic","counters":[]},{"line":"","counters":[]},{"line":"        type 'a set_or_keep = 'a Zkapp_basic.Set_or_keep.t","counters":[]},{"line":"","counters":[]},{"line":"        let timing (account_update : t) : Account.timing set_or_keep =","counters":[]},{"line":"          Set_or_keep.map ~f:Option.some account_update.body.update.timing","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"        let app_state (account_update : t) =","counters":[]},{"line":"          account_update.body.update.app_state","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"        let verification_key (account_update : t) =","counters":[]},{"line":"          Zkapp_basic.Set_or_keep.map ~f:Option.some","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            account_update.body.update.verification_key","counters":[]},{"line":"","counters":[]},{"line":"        let sequence_events (account_update : t) =","counters":[]},{"line":"          account_update.body.sequence_events","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"        let zkapp_uri (account_update : t) =","counters":[]},{"line":"          account_update.body.update.zkapp_uri","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"        let token_symbol (account_update : t) =","counters":[]},{"line":"          account_update.body.update.token_symbol","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"        let delegate (account_update : t) = account_update.body.update.delegate","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"        let voting_for (account_update : t) =","counters":[]},{"line":"          account_update.body.update.voting_for","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"        let permissions (account_update : t) =","counters":[]},{"line":"          account_update.body.update.permissions","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"      end","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Set_or_keep = struct","counters":[]},{"line":"      include Zkapp_basic.Set_or_keep","counters":[]},{"line":"","counters":[]},{"line":"      let set_or_keep ~if_:_ t x = set_or_keep t x","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Opt = struct","counters":[]},{"line":"      type 'a t = 'a option","counters":[]},{"line":"","counters":[]},{"line":"      let is_some = Option.is_some","counters":[]},{"line":"","counters":[]},{"line":"      let map = Option.map","counters":[]},{"line":"","counters":[]},{"line":"      let or_default ~if_ x ~default =","counters":[]},{"line":"        if_ (is_some x) ~then_:(Option.value ~default x) ~else_:default","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"","counters":[]},{"line":"      let or_exn x = Option.value_exn x","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Stack (Elt : sig","counters":[]},{"line":"      type t","counters":[]},{"line":"    end) =","counters":[]},{"line":"    struct","counters":[]},{"line":"      type t = Elt.t list","counters":[]},{"line":"","counters":[]},{"line":"      let if_ = value_if","counters":[]},{"line":"","counters":[]},{"line":"      let empty () = []","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"","counters":[]},{"line":"      let is_empty = List.is_empty","counters":[]},{"line":"","counters":[]},{"line":"      let pop_exn : t -> Elt.t * t = function","counters":[]},{"line":"        | [] ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            failwith \"pop_exn\"","counters":[]},{"line":"        | x :: xs ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (x, xs)","counters":[]},{"line":"","counters":[]},{"line":"      let pop : t -> (Elt.t * t) option = function","counters":[]},{"line":"        | x :: xs ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Some (x, xs)","counters":[]},{"line":"        | _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            None","counters":[]},{"line":"","counters":[]},{"line":"      let push x ~onto : t = x :: onto","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Call_forest = Zkapp_call_forest","counters":[]},{"line":"","counters":[]},{"line":"    module Stack_frame = struct","counters":[]},{"line":"      include Stack_frame","counters":[]},{"line":"","counters":[]},{"line":"      type t = value","counters":[]},{"line":"","counters":[]},{"line":"      let if_ = Zkapp_command.value_if","counters":[]},{"line":"","counters":[]},{"line":"      let make = Stack_frame.make","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Call_stack = Stack (Stack_frame)","counters":[]},{"line":"","counters":[]},{"line":"    module Local_state = struct","counters":[]},{"line":"      type t =","counters":[]},{"line":"        ( Stack_frame.t","counters":[]},{"line":"        , Call_stack.t","counters":[]},{"line":"        , Token_id.t","counters":[]},{"line":"        , Amount.Signed.t","counters":[]},{"line":"        , Ledger.t","counters":[]},{"line":"        , Bool.t","counters":[]},{"line":"        , Transaction_commitment.t","counters":[]},{"line":"        , Index.t","counters":[]},{"line":"        , Bool.failure_status_tbl )","counters":[]},{"line":"        Zkapp_command_logic.Local_state.t","counters":[]},{"line":"","counters":[]},{"line":"      let add_check (t : t) failure b =","counters":[]},{"line":"        let failure_status_tbl =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          match t.failure_status_tbl with","counters":[]},{"line":"          | hd :: tl when not b ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (failure :: hd) :: tl","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"          | old_failure_status_tbl ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              old_failure_status_tbl","counters":[]},{"line":"        in","counters":[]},{"line":"        { t with failure_status_tbl; success = t.success && b }","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"","counters":[]},{"line":"      let update_failure_status_tbl (t : t) failure_status b =","counters":[]},{"line":"        match failure_status with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            { t with success = t.success && b }","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"        | Some failure ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            add_check t failure b","counters":[]},{"line":"","counters":[]},{"line":"      let add_new_failure_status_bucket (t : t) =","counters":[]},{"line":"        { t with failure_status_tbl = [] :: t.failure_status_tbl }","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Nonce_precondition = struct","counters":[]},{"line":"      let is_constant =","counters":[]},{"line":"        Zkapp_precondition.Numeric.is_constant","counters":[{"col_start":45,"col_end":45,"count":3}]},{"line":"          Zkapp_precondition.Numeric.Tc.nonce","counters":[]},{"line":"    end","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Env = struct","counters":[]},{"line":"    open Inputs","counters":[]},{"line":"","counters":[]},{"line":"    type t =","counters":[]},{"line":"      < account_update : Account_update.t","counters":[]},{"line":"      ; zkapp_command : Zkapp_command.t","counters":[]},{"line":"      ; account : Account.t","counters":[]},{"line":"      ; ledger : Ledger.t","counters":[]},{"line":"      ; amount : Amount.t","counters":[]},{"line":"      ; signed_amount : Amount.Signed.t","counters":[]},{"line":"      ; bool : Bool.t","counters":[]},{"line":"      ; token_id : Token_id.t","counters":[]},{"line":"      ; global_state : Global_state.t","counters":[]},{"line":"      ; inclusion_proof : [ `Existing of location | `New ]","counters":[]},{"line":"      ; local_state :","counters":[]},{"line":"          ( Stack_frame.t","counters":[]},{"line":"          , Call_stack.t","counters":[]},{"line":"          , Token_id.t","counters":[]},{"line":"          , Amount.Signed.t","counters":[]},{"line":"          , L.t","counters":[]},{"line":"          , bool","counters":[]},{"line":"          , Transaction_commitment.t","counters":[]},{"line":"          , Index.t","counters":[]},{"line":"          , Transaction_status.Failure.Collection.t )","counters":[]},{"line":"          Zkapp_command_logic.Local_state.t","counters":[]},{"line":"      ; protocol_state_precondition : Zkapp_precondition.Protocol_state.t","counters":[]},{"line":"      ; transaction_commitment : Transaction_commitment.t","counters":[]},{"line":"      ; full_transaction_commitment : Transaction_commitment.t","counters":[]},{"line":"      ; field : Snark_params.Tick.Field.t","counters":[]},{"line":"      ; failure : Transaction_status.Failure.t option >","counters":[]},{"line":"","counters":[]},{"line":"    let perform ~constraint_constants:_ (type r)","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"        (eff : (r, t) Zkapp_command_logic.Eff.t) : r =","counters":[]},{"line":"      match eff with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Check_protocol_state_precondition (pred, global_state) -> (","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Zkapp_precondition.Protocol_state.check pred","counters":[]},{"line":"            global_state.protocol_state","counters":[]},{"line":"          |> fun or_err -> match or_err with Ok () -> true | Error _ -> false )","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"      | Check_account_precondition","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (account_update, account, new_account, local_state) -> (","counters":[]},{"line":"          match account_update.body.preconditions.account with","counters":[]},{"line":"          | Accept ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              local_state","counters":[]},{"line":"          | Nonce n ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let nonce_matches = Account.Nonce.equal account.nonce n in","counters":[]},{"line":"              Inputs.Local_state.add_check local_state","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Account_nonce_precondition_unsatisfied nonce_matches","counters":[]},{"line":"          | Full precondition_account ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let local_state = ref local_state in","counters":[]},{"line":"              let check failure b =","counters":[]},{"line":"                local_state :=","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Inputs.Local_state.add_check !local_state failure b","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"              in","counters":[]},{"line":"              Zkapp_precondition.Account.check ~new_account ~check","counters":[]},{"line":"                precondition_account account ;","counters":[]},{"line":"              !local_state )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"      | Init_account { account_update = _; account = a } ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          a","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module M = Zkapp_command_logic.Make (Inputs)","counters":[]},{"line":"","counters":[]},{"line":"  let update_sequence_state sequence_state sequence_events ~txn_global_slot","counters":[]},{"line":"      ~last_sequence_slot =","counters":[]},{"line":"    let sequence_state', last_sequence_slot' =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      M.update_sequence_state sequence_state sequence_events ~txn_global_slot","counters":[]},{"line":"        ~last_sequence_slot","counters":[]},{"line":"    in","counters":[]},{"line":"    (sequence_state', last_sequence_slot')","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let apply_zkapp_command_unchecked_aux (type user_acc)","counters":[]},{"line":"      ~(constraint_constants : Genesis_constants.Constraint_constants.t)","counters":[]},{"line":"      ~(state_view : Zkapp_precondition.Protocol_state.View.t)","counters":[]},{"line":"      ~(init : user_acc) ~(f : user_acc -> _ -> user_acc)","counters":[]},{"line":"      ?(fee_excess = Amount.Signed.zero) ?(supply_increase = Amount.Signed.zero)","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"      (ledger : L.t) (c : Zkapp_command.t) :","counters":[]},{"line":"      (Transaction_applied.Zkapp_command_applied.t * user_acc) Or_error.t =","counters":[]},{"line":"    let open Or_error.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let original_account_states =","counters":[]},{"line":"      List.map (Zkapp_command.accounts_referenced c) ~f:(fun id ->","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"          ( id","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          , Option.Let_syntax.(","counters":[]},{"line":"              let%bind loc = L.location_of_account ledger id in","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"              let%map a = L.get ledger loc in","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"              (loc, a)) ) )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"    in","counters":[]},{"line":"    let perform eff = Env.perform ~constraint_constants eff in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"    let rec step_all user_acc","counters":[]},{"line":"        ( (g_state : Inputs.Global_state.t)","counters":[]},{"line":"        , (l_state : _ Zkapp_command_logic.Local_state.t) ) :","counters":[]},{"line":"        (user_acc * Transaction_status.Failure.Collection.t) Or_error.t =","counters":[]},{"line":"      if List.is_empty l_state.stack_frame.Stack_frame.calls then","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Ok (user_acc, l_state.failure_status_tbl)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      else","counters":[]},{"line":"        let%bind states =","counters":[]},{"line":"          Or_error.try_with (fun () ->","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"              M.step ~constraint_constants { perform } (g_state, l_state) )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"        in","counters":[]},{"line":"        step_all (f user_acc states) states","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"    in","counters":[]},{"line":"    let initial_state :","counters":[]},{"line":"        Inputs.Global_state.t * _ Zkapp_command_logic.Local_state.t =","counters":[]},{"line":"      ( { protocol_state = state_view; ledger; fee_excess; supply_increase }","counters":[]},{"line":"      , { stack_frame =","counters":[]},{"line":"            ({ calls = []","counters":[]},{"line":"             ; caller = Token_id.default","counters":[]},{"line":"             ; caller_caller = Token_id.default","counters":[]},{"line":"             } : Inputs.Stack_frame.t)","counters":[]},{"line":"        ; call_stack = []","counters":[]},{"line":"        ; transaction_commitment = Inputs.Transaction_commitment.empty","counters":[]},{"line":"        ; full_transaction_commitment = Inputs.Transaction_commitment.empty","counters":[]},{"line":"        ; token_id = Token_id.default","counters":[]},{"line":"        ; excess = Currency.Amount.(Signed.of_unsigned zero)","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"        ; supply_increase = Currency.Amount.(Signed.of_unsigned zero)","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"        ; ledger","counters":[]},{"line":"        ; success = true","counters":[]},{"line":"        ; account_update_index = Inputs.Index.zero","counters":[]},{"line":"        ; failure_status_tbl = []","counters":[]},{"line":"        } )","counters":[]},{"line":"    in","counters":[]},{"line":"    let user_acc = f init initial_state in","counters":[]},{"line":"    let%bind (start : Inputs.Global_state.t * _) =","counters":[]},{"line":"      let zkapp_command = Zkapp_command.zkapp_command c in","counters":[]},{"line":"      Or_error.try_with (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"          M.start ~constraint_constants","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            { zkapp_command; memo_hash = Signed_command_memo.hash c.memo }","counters":[{"col_start":64,"col_end":64,"count":0}]},{"line":"            { perform } initial_state )","counters":[]},{"line":"    in","counters":[]},{"line":"    let account_states_after_fee_payer =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      List.map (Zkapp_command.accounts_referenced c) ~f:(fun id ->","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"          ( id","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          , Option.Let_syntax.(","counters":[]},{"line":"              let%bind loc = L.location_of_account ledger id in","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"              let%map a = L.get ledger loc in","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"              (loc, a)) ) )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"    in","counters":[]},{"line":"    let accounts () =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      List.map original_account_states","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ~f:(Tuple2.map_snd ~f:(Option.map ~f:snd))","counters":[]},{"line":"    in","counters":[]},{"line":"    match step_all (f user_acc start) start with","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"    | Error e ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Error e","counters":[]},{"line":"    | Ok (s, reversed_failure_status_tbl) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let failure_status_tbl = List.rev reversed_failure_status_tbl in","counters":[]},{"line":"        let account_ids_originally_not_in_ledger =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          List.filter_map original_account_states","counters":[]},{"line":"            ~f:(fun (acct_id, loc_and_acct) ->","counters":[]},{"line":"              if Option.is_none loc_and_acct then Some acct_id else None )","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":50,"col_end":50,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"        in","counters":[]},{"line":"        let successfully_applied =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Transaction_status.Failure.Collection.is_empty failure_status_tbl","counters":[]},{"line":"        in","counters":[]},{"line":"        (* if the zkapp command fails in at least 1 account update,","counters":[]},{"line":"           then all the account updates would be cancelled except","counters":[]},{"line":"           the fee payer one","counters":[]},{"line":"        *)","counters":[]},{"line":"        let failure_status_tbl =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          if successfully_applied then failure_status_tbl","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"          else","counters":[]},{"line":"            List.mapi failure_status_tbl ~f:(fun idx fs ->","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":20,"col_end":20,"count":0}]},{"line":"                if idx > 0 && List.is_empty fs then","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"                  [ Transaction_status.Failure.Cancelled ]","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                else fs )","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"        in","counters":[]},{"line":"        (* accounts not originally in ledger, now present in ledger *)","counters":[]},{"line":"        let new_accounts =","counters":[]},{"line":"          List.filter account_ids_originally_not_in_ledger ~f:(fun acct_id ->","counters":[]},{"line":"              Option.is_some @@ L.location_of_account ledger acct_id )","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"        in","counters":[]},{"line":"        let valid_result =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Ok","counters":[]},{"line":"            ( { Transaction_applied.Zkapp_command_applied.accounts = accounts ()","counters":[{"col_start":76,"col_end":76,"count":0}]},{"line":"              ; command =","counters":[]},{"line":"                  { With_status.data = c","counters":[]},{"line":"                  ; status =","counters":[]},{"line":"                      ( if successfully_applied then Applied","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"                      else Failed failure_status_tbl )","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                  }","counters":[]},{"line":"              ; new_accounts","counters":[]},{"line":"              }","counters":[]},{"line":"            , s )","counters":[]},{"line":"        in","counters":[]},{"line":"        if successfully_applied then valid_result","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"        else","counters":[]},{"line":"          let other_account_update_accounts_unchanged =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            List.fold_until account_states_after_fee_payer ~init:true","counters":[]},{"line":"              ~f:(fun acc (_, loc_opt) ->","counters":[]},{"line":"                match","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  let open Option.Let_syntax in","counters":[]},{"line":"                  let%bind loc, a = loc_opt in","counters":[]},{"line":"                  let%bind a' = L.get ledger loc in","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"                  Option.some_if (not (Account.equal a a')) ()","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"                with","counters":[]},{"line":"                | None ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    Continue acc","counters":[]},{"line":"                | Some _ ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    Stop false )","counters":[]},{"line":"              ~finish:Fn.id","counters":[]},{"line":"          in","counters":[]},{"line":"          (* Other zkapp_command failed, therefore, updates in those should not get applied *)","counters":[]},{"line":"          if","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            List.is_empty new_accounts","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"            && other_account_update_accounts_unchanged","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"          then valid_result","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"          else","counters":[]},{"line":"            Or_error.error_string","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              \"Zkapp_command application failed but new accounts created or \\","counters":[]},{"line":"               some of the other account_update updates applied\"","counters":[]},{"line":"","counters":[]},{"line":"  let apply_zkapp_command_unchecked ~constraint_constants ~state_view ledger c =","counters":[]},{"line":"    apply_zkapp_command_unchecked_aux ~constraint_constants ~state_view ledger c","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ~init:None ~f:(fun _acc (global_state, local_state) ->","counters":[]},{"line":"        Some (local_state, global_state.fee_excess) )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    |> Result.map ~f:(fun (account_update_applied, state_res) ->","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"           (account_update_applied, Option.value_exn state_res) )","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"","counters":[]},{"line":"  let update_timing_when_no_deduction ~txn_global_slot account =","counters":[]},{"line":"    validate_timing ~txn_amount:Amount.zero ~txn_global_slot ~account","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let has_permission_to_receive ~ledger receiver_account_id :","counters":[]},{"line":"      Account.t","counters":[]},{"line":"      * Ledger_intf.account_state","counters":[]},{"line":"      * [> `Has_permission_to_receive of bool ] =","counters":[]},{"line":"    let init_account = Account.initialize receiver_account_id in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    match location_of_account ledger receiver_account_id with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (* new account, check that default permissions allow receiving *)","counters":[]},{"line":"        ( init_account","counters":[]},{"line":"        , `Added","counters":[]},{"line":"        , `Has_permission_to_receive","counters":[]},{"line":"            (Account.has_permission ~to_:`Receive init_account) )","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"    | Some loc -> (","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        match get ledger loc with","counters":[]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            failwith \"Ledger location with no account\"","counters":[]},{"line":"        | Some receiver_account ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ( receiver_account","counters":[]},{"line":"            , `Existed","counters":[]},{"line":"            , `Has_permission_to_receive","counters":[]},{"line":"                (Account.has_permission ~to_:`Receive receiver_account) ) )","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"","counters":[]},{"line":"  let no_failure = []","counters":[]},{"line":"","counters":[]},{"line":"  let update_failed =","counters":[]},{"line":"    [ Transaction_status.Failure.Update_not_permitted_balance ]","counters":[]},{"line":"","counters":[]},{"line":"  let empty = Transaction_status.Failure.Collection.empty","counters":[]},{"line":"","counters":[]},{"line":"  let single_failure =","counters":[]},{"line":"    Transaction_status.Failure.Collection.of_single_failure","counters":[{"col_start":58,"col_end":58,"count":3}]},{"line":"      Update_not_permitted_balance","counters":[]},{"line":"","counters":[]},{"line":"  let append_entry f (s : Transaction_status.Failure.Collection.t) :","counters":[]},{"line":"      Transaction_status.Failure.Collection.t =","counters":[]},{"line":"    match s with [] -> [ f ] | h :: t -> h :: f :: t","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"","counters":[]},{"line":"  (*Structure of the failure status:","counters":[]},{"line":"     I. Only one fee transfer in the transaction (`One) and it fails:","counters":[]},{"line":"        [[failure]]","counters":[]},{"line":"     II. Two fee transfers in the transaction (`Two)-","counters":[]},{"line":"      Both fee transfers fail:","counters":[]},{"line":"        [[failure-of-first-fee-transfer]; [failure-of-second-fee-transfer]]","counters":[]},{"line":"      First succeeds and second one fails:","counters":[]},{"line":"        [[];[failure-of-second-fee-transfer]]","counters":[]},{"line":"      First fails and second succeeds:","counters":[]},{"line":"        [[failure-of-first-fee-transfer];[]]","counters":[]},{"line":"  *)","counters":[]},{"line":"  let process_fee_transfer t (transfer : Fee_transfer.t) ~modify_balance","counters":[]},{"line":"      ~modify_timing =","counters":[]},{"line":"    let open Or_error.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    (* TODO(#4555): Allow token_id to vary from default. *)","counters":[]},{"line":"    let%bind () =","counters":[]},{"line":"      if","counters":[]},{"line":"        List.for_all","counters":[]},{"line":"          ~f:Token_id.(equal default)","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"          (One_or_two.to_list (Fee_transfer.fee_tokens transfer))","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"      then return ()","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":16,"col_end":16,"count":0}]},{"line":"      else Or_error.errorf \"Cannot pay fees in non-default tokens.\"","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"    in","counters":[]},{"line":"    match Fee_transfer.to_singles transfer with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | `One ft ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let account_id = Fee_transfer.Single.receiver ft in","counters":[]},{"line":"        let a, action, `Has_permission_to_receive can_receive =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          has_permission_to_receive ~ledger:t account_id","counters":[]},{"line":"        in","counters":[]},{"line":"        let%bind timing = modify_timing a in","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"        let%bind balance = modify_balance action account_id a.balance ft.fee in","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"        if can_receive then (","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let%map _action, a, loc = get_or_create t account_id in","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"          let new_accounts = get_new_accounts action account_id in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          set t loc { a with balance; timing } ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          (new_accounts, empty, Currency.Amount.zero) )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        else Ok ([], single_failure, Currency.Amount.of_fee ft.fee)","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"    | `Two (ft1, ft2) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let account_id1 = Fee_transfer.Single.receiver ft1 in","counters":[]},{"line":"        let a1, action1, `Has_permission_to_receive can_receive1 =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          has_permission_to_receive ~ledger:t account_id1","counters":[]},{"line":"        in","counters":[]},{"line":"        let account_id2 = Fee_transfer.Single.receiver ft2 in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        if Account_id.equal account_id1 account_id2 then","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let%bind fee = error_opt \"overflow\" (Fee.add ft1.fee ft2.fee) in","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"          let%bind timing = modify_timing a1 in","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"          let%bind balance =","counters":[]},{"line":"            modify_balance action1 account_id1 a1.balance fee","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"          in","counters":[]},{"line":"          if can_receive1 then (","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let%map _action1, a1, l1 = get_or_create t account_id1 in","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"            let new_accounts1 = get_new_accounts action1 account_id1 in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            set t l1 { a1 with balance; timing } ;","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            (new_accounts1, empty, Currency.Amount.zero) )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          else","counters":[]},{"line":"            (*failure for each fee transfer single*)","counters":[]},{"line":"            Ok","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              ( []","counters":[]},{"line":"              , append_entry update_failed single_failure","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"              , Currency.Amount.of_fee fee )","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"        else","counters":[]},{"line":"          let a2, action2, `Has_permission_to_receive can_receive2 =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            has_permission_to_receive ~ledger:t account_id2","counters":[]},{"line":"          in","counters":[]},{"line":"          let%bind balance1 =","counters":[]},{"line":"            modify_balance action1 account_id1 a1.balance ft1.fee","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"          in","counters":[]},{"line":"          (*Note: Not updating the timing field of a1 to avoid additional check in transactions snark (check_timing for \"receiver\"). This is OK because timing rules will not be violated when balance increases and will be checked whenever an amount is deducted from the account. (#5973)*)","counters":[]},{"line":"          let%bind timing2 = modify_timing a2 in","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"          let%bind balance2 =","counters":[]},{"line":"            modify_balance action2 account_id2 a2.balance ft2.fee","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%bind new_accounts1, failures, burned_tokens1 =","counters":[]},{"line":"            if can_receive1 then (","counters":[]},{"line":"              let%map _action1, a1, l1 = get_or_create t account_id1 in","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"              let new_accounts1 = get_new_accounts action1 account_id1 in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              set t l1 { a1 with balance = balance1 } ;","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              ( new_accounts1","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              , append_entry no_failure empty","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"              , Currency.Amount.zero ) )","counters":[]},{"line":"            else Ok ([], single_failure, Currency.Amount.of_fee ft1.fee)","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%bind new_accounts2, failures', burned_tokens2 =","counters":[]},{"line":"            if can_receive2 then (","counters":[]},{"line":"              let%map _action2, a2, l2 = get_or_create t account_id2 in","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"              let new_accounts2 = get_new_accounts action2 account_id2 in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              set t l2 { a2 with balance = balance2; timing = timing2 } ;","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              ( new_accounts2","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              , append_entry no_failure failures","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"              , Currency.Amount.zero ) )","counters":[]},{"line":"            else","counters":[]},{"line":"              Ok","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ( []","counters":[]},{"line":"                , append_entry update_failed failures","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                , Currency.Amount.of_fee ft2.fee )","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%map burned_tokens =","counters":[]},{"line":"            error_opt \"burned tokens overflow\"","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"              (Currency.Amount.add burned_tokens1 burned_tokens2)","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"          in","counters":[]},{"line":"          (new_accounts1 @ new_accounts2, failures', burned_tokens)","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"  let apply_fee_transfer ~constraint_constants ~txn_global_slot t transfer =","counters":[]},{"line":"    let open Or_error.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let%map new_accounts, failures, burned_tokens =","counters":[]},{"line":"      process_fee_transfer t transfer","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"        ~modify_balance:(fun action _ b f ->","counters":[]},{"line":"          let%bind amount =","counters":[]},{"line":"            let amount = Amount.of_fee f in","counters":[]},{"line":"            sub_account_creation_fee ~constraint_constants action amount","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"          in","counters":[]},{"line":"          add_amount b amount )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        ~modify_timing:(fun acc ->","counters":[]},{"line":"          update_timing_when_no_deduction ~txn_global_slot acc )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    in","counters":[]},{"line":"    let ft_with_status =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      if Transaction_status.Failure.Collection.is_empty failures then","counters":[]},{"line":"        { With_status.data = transfer; status = Applied }","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      else { data = transfer; status = Failed failures }","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"    in","counters":[]},{"line":"    Transaction_applied.Fee_transfer_applied.","counters":[]},{"line":"      { fee_transfer = ft_with_status; new_accounts; burned_tokens }","counters":[]},{"line":"","counters":[]},{"line":"  (*Structure of the failure status:","counters":[]},{"line":"     I. No fee transfer and coinbase transfer fails: [[failure]]","counters":[]},{"line":"     II. With fee transfer-","counters":[]},{"line":"      Both fee transfer and coinbase fails:","counters":[]},{"line":"        [[failure-of-fee-transfer]; [failure-of-coinbase]]","counters":[]},{"line":"      Fee transfer succeeds and coinbase fails:","counters":[]},{"line":"        [[];[failure-of-coinbase]]","counters":[]},{"line":"      Fee transfer fails and coinbase succeeds:","counters":[]},{"line":"        [[failure-of-fee-transfer];[]]","counters":[]},{"line":"  *)","counters":[]},{"line":"  let apply_coinbase ~constraint_constants ~txn_global_slot t","counters":[]},{"line":"      (* TODO: Better system needed for making atomic changes. Could use a monad. *)","counters":[]},{"line":"        ({ receiver; fee_transfer; amount = coinbase_amount } as cb : Coinbase.t)","counters":[]},{"line":"      =","counters":[]},{"line":"    let open Or_error.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let%bind ( receiver_reward","counters":[]},{"line":"             , new_accounts1","counters":[]},{"line":"             , transferee_update","counters":[]},{"line":"             , transferee_timing_prev","counters":[]},{"line":"             , failures1","counters":[]},{"line":"             , burned_tokens1 ) =","counters":[]},{"line":"      match fee_transfer with","counters":[]},{"line":"      | None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          return (coinbase_amount, [], None, None, empty, Currency.Amount.zero)","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"      | Some ({ receiver_pk = transferee; fee } as ft) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          assert (not @@ Public_key.Compressed.equal transferee receiver) ;","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"          let transferee_id = Coinbase.Fee_transfer.receiver ft in","counters":[]},{"line":"          let fee = Amount.of_fee fee in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let%bind receiver_reward =","counters":[]},{"line":"            error_opt \"Coinbase fee transfer too large\"","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"              (Amount.sub coinbase_amount fee)","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"          in","counters":[]},{"line":"          let transferee_account, action, `Has_permission_to_receive can_receive","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              =","counters":[]},{"line":"            has_permission_to_receive ~ledger:t transferee_id","counters":[]},{"line":"          in","counters":[]},{"line":"          let new_accounts = get_new_accounts action transferee_id in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let%bind timing =","counters":[]},{"line":"            update_timing_when_no_deduction ~txn_global_slot transferee_account","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%bind balance =","counters":[]},{"line":"            let%bind amount =","counters":[]},{"line":"              sub_account_creation_fee ~constraint_constants action fee","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"            in","counters":[]},{"line":"            add_amount transferee_account.balance amount","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          in","counters":[]},{"line":"          if can_receive then","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let%map _action, transferee_account, transferee_location =","counters":[]},{"line":"              get_or_create t transferee_id","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"            in","counters":[]},{"line":"            ( receiver_reward","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            , new_accounts","counters":[]},{"line":"            , Some","counters":[]},{"line":"                ( transferee_location","counters":[]},{"line":"                , { transferee_account with balance; timing } )","counters":[]},{"line":"            , Some transferee_account.timing","counters":[]},{"line":"            , append_entry no_failure empty","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"            , Currency.Amount.zero )","counters":[]},{"line":"          else return (receiver_reward, [], None, None, single_failure, fee)","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"    in","counters":[]},{"line":"    let receiver_id = Account_id.create receiver Token_id.default in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let receiver_account, action2, `Has_permission_to_receive can_receive =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      has_permission_to_receive ~ledger:t receiver_id","counters":[]},{"line":"    in","counters":[]},{"line":"    let new_accounts2 = get_new_accounts action2 receiver_id in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    (* Note: Updating coinbase receiver timing only if there is no fee transfer.","counters":[]},{"line":"       This is so as to not add any extra constraints in transaction snark for checking","counters":[]},{"line":"       \"receiver\" timings. This is OK because timing rules will not be violated when","counters":[]},{"line":"       balance increases and will be checked whenever an amount is deducted from the","counters":[]},{"line":"       account (#5973)","counters":[]},{"line":"    *)","counters":[]},{"line":"    let%bind coinbase_receiver_timing =","counters":[]},{"line":"      match transferee_timing_prev with","counters":[]},{"line":"      | None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let%map new_receiver_timing =","counters":[]},{"line":"            update_timing_when_no_deduction ~txn_global_slot receiver_account","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"          in","counters":[]},{"line":"          new_receiver_timing","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"      | Some _timing ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Ok receiver_account.timing","counters":[]},{"line":"    in","counters":[]},{"line":"    let%bind receiver_balance =","counters":[]},{"line":"      let%bind amount =","counters":[]},{"line":"        sub_account_creation_fee ~constraint_constants action2 receiver_reward","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"      in","counters":[]},{"line":"      add_amount receiver_account.balance amount","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    in","counters":[]},{"line":"    let%bind failures, burned_tokens2 =","counters":[]},{"line":"      if can_receive then (","counters":[]},{"line":"        let%map _action2, receiver_account, receiver_location =","counters":[]},{"line":"          get_or_create t receiver_id","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"        in","counters":[]},{"line":"        set t receiver_location","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          { receiver_account with","counters":[]},{"line":"            balance = receiver_balance","counters":[]},{"line":"          ; timing = coinbase_receiver_timing","counters":[]},{"line":"          } ;","counters":[]},{"line":"        (append_entry no_failure failures1, Currency.Amount.zero) )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":20,"col_end":20,"count":0}]},{"line":"      else return (append_entry update_failed failures1, receiver_reward)","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"    in","counters":[]},{"line":"    Option.iter transferee_update ~f:(fun (l, a) -> set t l a) ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"    let%map burned_tokens =","counters":[]},{"line":"      error_opt \"burned tokens overflow\"","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"        (Amount.add burned_tokens1 burned_tokens2)","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"    in","counters":[]},{"line":"    let coinbase_with_status =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      if Transaction_status.Failure.Collection.is_empty failures then","counters":[]},{"line":"        { With_status.data = cb; status = Applied }","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      else { With_status.data = cb; status = Failed failures }","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"    in","counters":[]},{"line":"    Transaction_applied.Coinbase_applied.","counters":[]},{"line":"      { coinbase = coinbase_with_status","counters":[]},{"line":"      ; new_accounts = new_accounts1 @ new_accounts2","counters":[]},{"line":"      ; burned_tokens","counters":[]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"  let apply_transaction ~constraint_constants","counters":[]},{"line":"      ~(txn_state_view : Zkapp_precondition.Protocol_state.View.t) ledger","counters":[]},{"line":"      (t : Transaction.t) =","counters":[]},{"line":"    let previous_hash = merkle_root ledger in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let txn_global_slot = txn_state_view.global_slot_since_genesis in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Or_error.map","counters":[]},{"line":"      ( match t with","counters":[]},{"line":"      | Command (Signed_command txn) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (* Printf.eprintf \"MY_LOG.APPLY_TRANSACTION.SIGNED_COMMAND\\n%!\" ; *)","counters":[]},{"line":"          Or_error.map","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"            (apply_user_command_unchecked ~constraint_constants ~txn_global_slot","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"               ledger txn ) ~f:(fun applied ->","counters":[]},{"line":"              Transaction_applied.Varying.Command (Signed_command applied) )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"      | Command (Zkapp_command txn) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (* Printf.eprintf \"MY_LOG.APPLY_TRANSACTION.ZKAPP_COMMAND\\n%!\" ; *)","counters":[]},{"line":"          Or_error.map","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"            (apply_zkapp_command_unchecked ~state_view:txn_state_view","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"               ~constraint_constants ledger txn ) ~f:(fun (applied, _) ->","counters":[]},{"line":"              Transaction_applied.Varying.Command (Zkapp_command applied) )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"      | Fee_transfer t ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (* Printf.eprintf \"MY_LOG.APPLY_TRANSACTION.FREE_TRANSFER\\n%!\" ; *)","counters":[]},{"line":"          Or_error.map","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"            (apply_fee_transfer ~constraint_constants ~txn_global_slot ledger t)","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"            ~f:(fun applied -> Transaction_applied.Varying.Fee_transfer applied)","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"      | Coinbase t ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (* Printf.eprintf \"MY_LOG.APPLY_TRANSACTION.COINBASE\\n%!\" ; *)","counters":[]},{"line":"          Or_error.map","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"            (apply_coinbase ~constraint_constants ~txn_global_slot ledger t)","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"            ~f:(fun applied -> Transaction_applied.Varying.Coinbase applied) )","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"      ~f:(fun varying -> { Transaction_applied.previous_hash; varying })","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"  module For_tests = struct","counters":[]},{"line":"    let validate_timing_with_min_balance = validate_timing_with_min_balance","counters":[]},{"line":"","counters":[]},{"line":"    let validate_timing = validate_timing","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module For_tests = struct","counters":[]},{"line":"  open Mina_numbers","counters":[]},{"line":"  open Currency","counters":[]},{"line":"","counters":[]},{"line":"  module Account_without_receipt_chain_hash = struct","counters":[]},{"line":"    type t =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ( Public_key.Compressed.t","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      , Token_id.t","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      , Token_permissions.t","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      , Account.Token_symbol.t","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      , Balance.t","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      , Account_nonce.t","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      , unit","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      , Public_key.Compressed.t option","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"      , State_hash.t","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      , Account_timing.t","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      , Permissions.t","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      , Zkapp_account.t option )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"      Account.Poly.t","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    [@@deriving sexp, compare]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let min_init_balance = Int64.of_string \"8000000000\"","counters":[{"col_start":39,"col_end":39,"count":1}]},{"line":"","counters":[]},{"line":"  let max_init_balance = Int64.of_string \"8000000000000\"","counters":[{"col_start":39,"col_end":39,"count":1}]},{"line":"","counters":[]},{"line":"  let num_accounts = 10","counters":[]},{"line":"","counters":[]},{"line":"  let num_transactions = 10","counters":[]},{"line":"","counters":[]},{"line":"  let depth = Int.ceil_log2 (num_accounts + num_transactions)","counters":[{"col_start":26,"col_end":26,"count":1}]},{"line":"","counters":[]},{"line":"  module Init_ledger = struct","counters":[]},{"line":"    type t = (Keypair.t * int64) array [@@deriving sexp]","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":14,"col_end":14,"count":0}]},{"line":"","counters":[]},{"line":"    let init (type l) (module L : Ledger_intf.S with type t = l)","counters":[]},{"line":"        (init_ledger : t) (l : L.t) =","counters":[]},{"line":"      Array.iter init_ledger ~f:(fun (kp, amount) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          let _tag, account, loc =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            L.get_or_create l","counters":[]},{"line":"              (Account_id.create","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                 (Public_key.compress kp.public_key)","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"                 Token_id.default )","counters":[]},{"line":"            |> Or_error.ok_exn","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"          in","counters":[]},{"line":"          L.set l loc","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            { account with","counters":[]},{"line":"              balance =","counters":[]},{"line":"                Currency.Balance.of_uint64 (Unsigned.UInt64.of_int64 amount)","counters":[{"col_start":41,"col_end":41,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"            } )","counters":[]},{"line":"","counters":[]},{"line":"    let gen () : t Quickcheck.Generator.t =","counters":[]},{"line":"      let tbl = Public_key.Compressed.Hash_set.create () in","counters":[{"col_start":6,"col_end":6,"count":1}]},{"line":"      let open Quickcheck.Generator in","counters":[{"col_start":6,"col_end":6,"count":1}]},{"line":"      let open Let_syntax in","counters":[]},{"line":"      let rec go acc n =","counters":[]},{"line":"        if n = 0 then return (Array.of_list acc)","counters":[{"col_start":8,"col_end":8,"count":1},{"col_start":22,"col_end":22,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"        else","counters":[]},{"line":"          let%bind kp =","counters":[]},{"line":"            filter Keypair.gen ~f:(fun kp ->","counters":[{"col_start":17,"col_end":17,"count":1}]},{"line":"                not (Hash_set.mem tbl (Public_key.compress kp.public_key)) )","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"          and amount = Int64.gen_incl min_init_balance max_init_balance in","counters":[{"col_start":36,"col_end":36,"count":1}]},{"line":"          Hash_set.add tbl (Public_key.compress kp.public_key) ;","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"          go ((kp, amount) :: acc) (n - 1)","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"      in","counters":[]},{"line":"      go [] num_accounts","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Transaction_spec = struct","counters":[]},{"line":"    type t =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      { fee : Currency.Fee.t","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":10,"col_end":10,"count":0}]},{"line":"      ; sender : Keypair.t * Account_nonce.t","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"      ; receiver : Public_key.Compressed.t","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"      ; amount : Currency.Amount.t","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":13,"col_end":13,"count":0}]},{"line":"      ; receiver_is_new : bool","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"      }","counters":[]},{"line":"    [@@deriving sexp]","counters":[]},{"line":"","counters":[]},{"line":"    let gen ~(init_ledger : Init_ledger.t) ~nonces =","counters":[]},{"line":"      let pk ((kp : Keypair.t), _) = Public_key.compress kp.public_key in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"      let open Quickcheck.Let_syntax in","counters":[]},{"line":"      let%bind receiver_is_new = Bool.quickcheck_generator in","counters":[]},{"line":"      let gen_index () = Int.gen_incl 0 (Array.length init_ledger - 1) in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"      let%bind receiver_index =","counters":[]},{"line":"        if receiver_is_new then return None else gen_index () >>| Option.return","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":57,"col_end":57,"count":0},{"col_start":62,"col_end":62,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"      in","counters":[]},{"line":"      let%bind receiver =","counters":[]},{"line":"        match receiver_index with","counters":[]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Public_key.Compressed.gen","counters":[]},{"line":"        | Some i ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            return (pk init_ledger.(i))","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"      in","counters":[]},{"line":"      let%bind sender =","counters":[]},{"line":"        let%map i =","counters":[]},{"line":"          match receiver_index with","counters":[]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              gen_index ()","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"          | Some j ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Quickcheck.Generator.filter (gen_index ()) ~f:(( <> ) j)","counters":[{"col_start":40,"col_end":40,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"        in","counters":[]},{"line":"        fst init_ledger.(i)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      in","counters":[]},{"line":"      let gen_amount () =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Currency.Amount.(gen_incl (of_int 1_000_000) (of_int 100_000_000))","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"      in","counters":[]},{"line":"      let gen_fee () =","counters":[]},{"line":"        Currency.Fee.(gen_incl (of_int 1_000_000) (of_int 100_000_000))","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"      in","counters":[]},{"line":"      let nonce : Account_nonce.t = Map.find_exn nonces sender in","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"      let%bind fee = gen_fee () in","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"      let%bind amount = gen_amount () in","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"      let nonces =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Map.set nonces ~key:sender ~data:(Account_nonce.succ nonce)","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"      in","counters":[]},{"line":"      let spec =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { fee; amount; receiver; receiver_is_new; sender = (sender, nonce) }","counters":[]},{"line":"      in","counters":[]},{"line":"      return (spec, nonces)","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Test_spec = struct","counters":[]},{"line":"    type t = { init_ledger : Init_ledger.t; specs : Transaction_spec.t list }","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"    [@@deriving sexp]","counters":[]},{"line":"","counters":[]},{"line":"    let mk_gen ?(num_transactions = num_transactions) () =","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"      let open Quickcheck.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":1}]},{"line":"      let%bind init_ledger = Init_ledger.gen () in","counters":[{"col_start":43,"col_end":43,"count":1}]},{"line":"      let%bind specs =","counters":[]},{"line":"        let rec go acc n nonces =","counters":[]},{"line":"          if n = 0 then return (List.rev acc)","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"          else","counters":[]},{"line":"            let%bind spec, nonces = Transaction_spec.gen ~init_ledger ~nonces in","counters":[]},{"line":"            go (spec :: acc) (n - 1) nonces","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"        in","counters":[]},{"line":"        go [] num_transactions","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"          (Keypair.Map.of_alist_exn","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"             (List.map (Array.to_list init_ledger) ~f:(fun (pk, _) ->","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"                  (pk, Account_nonce.zero) ) ) )","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"      in","counters":[]},{"line":"      return { init_ledger; specs }","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let gen = mk_gen ~num_transactions ()","counters":[{"col_start":19,"col_end":19,"count":1}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let command_send","counters":[]},{"line":"      { Transaction_spec.fee","counters":[]},{"line":"      ; sender = sender, sender_nonce","counters":[]},{"line":"      ; receiver","counters":[]},{"line":"      ; amount","counters":[]},{"line":"      ; receiver_is_new = _","counters":[]},{"line":"      } : Signed_command.t =","counters":[]},{"line":"    let sender_pk = Public_key.compress sender.public_key in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Signed_command.sign sender","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      { common =","counters":[]},{"line":"          { fee","counters":[]},{"line":"          ; fee_payer_pk = sender_pk","counters":[]},{"line":"          ; nonce = sender_nonce","counters":[]},{"line":"          ; valid_until = Global_slot.max_value","counters":[]},{"line":"          ; memo = Signed_command_memo.dummy","counters":[]},{"line":"          }","counters":[]},{"line":"      ; body = Payment { source_pk = sender_pk; receiver_pk = receiver; amount }","counters":[]},{"line":"      }","counters":[]},{"line":"    |> Signed_command.forget_check","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"","counters":[]},{"line":"  let account_update_send ?(use_full_commitment = true)","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"      ?(double_sender_nonce = true)","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"      ~(constraint_constants : Genesis_constants.Constraint_constants.t)","counters":[]},{"line":"      { Transaction_spec.fee","counters":[]},{"line":"      ; sender = sender, sender_nonce","counters":[]},{"line":"      ; receiver","counters":[]},{"line":"      ; amount","counters":[]},{"line":"      ; receiver_is_new","counters":[]},{"line":"      } : Zkapp_command.t =","counters":[]},{"line":"    let sender_pk = Public_key.compress sender.public_key in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let actual_nonce =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (* Here, we double the spec'd nonce, because we bump the nonce a second","counters":[]},{"line":"         time for the 'sender' part of the payment.","counters":[]},{"line":"      *)","counters":[]},{"line":"      (* TODO: We should make bumping the nonce for signed zkapp_command optional,","counters":[]},{"line":"         flagged by a field in the account_update (but always true for the fee payer).","counters":[]},{"line":"","counters":[]},{"line":"         This would also allow us to prevent replays of snapp proofs, by","counters":[]},{"line":"         allowing them to bump their nonce.","counters":[]},{"line":"      *)","counters":[]},{"line":"      if double_sender_nonce then","counters":[]},{"line":"        sender_nonce |> Account.Nonce.to_uint32","counters":[]},{"line":"        |> Unsigned.UInt32.(mul (of_int 2))","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"        |> Account.Nonce.to_uint32","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"      else sender_nonce","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"    in","counters":[]},{"line":"    let zkapp_command : Zkapp_command.Simple.t =","counters":[]},{"line":"      { fee_payer =","counters":[]},{"line":"          { Account_update.Fee_payer.body =","counters":[]},{"line":"              { public_key = sender_pk","counters":[]},{"line":"              ; fee","counters":[]},{"line":"              ; valid_until = None","counters":[]},{"line":"              ; nonce = actual_nonce","counters":[]},{"line":"              }","counters":[]},{"line":"              (* Real signature added in below *)","counters":[]},{"line":"          ; authorization = Signature.dummy","counters":[]},{"line":"          }","counters":[]},{"line":"      ; account_updates =","counters":[]},{"line":"          [ { body =","counters":[]},{"line":"                { public_key = sender_pk","counters":[]},{"line":"                ; update = Account_update.Update.noop","counters":[]},{"line":"                ; token_id = Token_id.default","counters":[]},{"line":"                ; balance_change = Amount.Signed.(negate (of_unsigned amount))","counters":[{"col_start":55,"col_end":55,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"                ; increment_nonce = not use_full_commitment","counters":[]},{"line":"                ; events = []","counters":[]},{"line":"                ; sequence_events = []","counters":[]},{"line":"                ; call_data = Snark_params.Tick.Field.zero","counters":[]},{"line":"                ; call_depth = 0","counters":[]},{"line":"                ; preconditions =","counters":[]},{"line":"                    { Account_update.Preconditions.network =","counters":[]},{"line":"                        Zkapp_precondition.Protocol_state.accept","counters":[]},{"line":"                    ; account = Nonce (Account.Nonce.succ actual_nonce)","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"                    }","counters":[]},{"line":"                ; caller = Call","counters":[]},{"line":"                ; use_full_commitment","counters":[]},{"line":"                ; authorization_kind = Signature","counters":[]},{"line":"                }","counters":[]},{"line":"            ; authorization = None_given","counters":[]},{"line":"            }","counters":[]},{"line":"          ; { body =","counters":[]},{"line":"                { public_key = receiver","counters":[]},{"line":"                ; update = Account_update.Update.noop","counters":[]},{"line":"                ; token_id = Token_id.default","counters":[]},{"line":"                ; balance_change =","counters":[]},{"line":"                    Amount.Signed.of_unsigned","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"                      ( if receiver_is_new then","counters":[]},{"line":"                        Option.value_exn","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"                          (Amount.sub amount","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"                             (Amount.of_fee","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"                                constraint_constants.account_creation_fee ) )","counters":[]},{"line":"                      else amount )","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                ; increment_nonce = false","counters":[]},{"line":"                ; events = []","counters":[]},{"line":"                ; sequence_events = []","counters":[]},{"line":"                ; call_data = Snark_params.Tick.Field.zero","counters":[]},{"line":"                ; call_depth = 0","counters":[]},{"line":"                ; preconditions =","counters":[]},{"line":"                    { Account_update.Preconditions.network =","counters":[]},{"line":"                        Zkapp_precondition.Protocol_state.accept","counters":[]},{"line":"                    ; account = Accept","counters":[]},{"line":"                    }","counters":[]},{"line":"                ; caller = Call","counters":[]},{"line":"                ; use_full_commitment = false","counters":[]},{"line":"                ; authorization_kind = None_given","counters":[]},{"line":"                }","counters":[]},{"line":"            ; authorization = None_given","counters":[]},{"line":"            }","counters":[]},{"line":"          ]","counters":[]},{"line":"      ; memo = Signed_command_memo.empty","counters":[]},{"line":"      }","counters":[]},{"line":"    in","counters":[]},{"line":"    let zkapp_command = Zkapp_command.of_simple zkapp_command in","counters":[]},{"line":"    let commitment = Zkapp_command.commitment zkapp_command in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let full_commitment =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Zkapp_command.Transaction_commitment.create_complete commitment","counters":[]},{"line":"        ~memo_hash:(Signed_command_memo.hash zkapp_command.memo)","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"        ~fee_payer_hash:","counters":[]},{"line":"          (Zkapp_command.Digest.Account_update.create","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"             (Account_update.of_fee_payer zkapp_command.fee_payer) )","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"    in","counters":[]},{"line":"    let account_updates_signature =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let c = if use_full_commitment then full_commitment else commitment in","counters":[{"col_start":42,"col_end":42,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"      Schnorr.Chunked.sign sender.private_key","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"        (Random_oracle.Input.Chunked.field c)","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"    in","counters":[]},{"line":"    let account_updates =","counters":[]},{"line":"      Zkapp_command.Call_forest.map zkapp_command.account_updates","counters":[]},{"line":"        ~f:(fun (account_update : Account_update.t) ->","counters":[]},{"line":"          match account_update.body.preconditions.account with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | Nonce _ ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              { account_update with","counters":[]},{"line":"                authorization = Control.Signature account_updates_signature","counters":[]},{"line":"              }","counters":[]},{"line":"          | _ ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              account_update )","counters":[]},{"line":"    in","counters":[]},{"line":"    let signature =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Schnorr.Chunked.sign sender.private_key","counters":[]},{"line":"        (Random_oracle.Input.Chunked.field full_commitment)","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"    in","counters":[]},{"line":"    { zkapp_command with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      fee_payer = { zkapp_command.fee_payer with authorization = signature }","counters":[]},{"line":"    ; account_updates","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let test_eq (type l) (module L : Ledger_intf.S with type t = l) accounts","counters":[]},{"line":"      (l1 : L.t) (l2 : L.t) =","counters":[]},{"line":"    Or_error.try_with (fun () ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        List.iter accounts ~f:(fun a ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            let mismatch () =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              failwithf","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                !\"One ledger had the account %{sexp:Account_id.t} but the \\","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                  other did not\"","counters":[]},{"line":"                a ()","counters":[]},{"line":"            in","counters":[]},{"line":"            let hide_rc (a : _ Account.Poly.t) =","counters":[]},{"line":"              { a with receipt_chain_hash = () }","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"            in","counters":[]},{"line":"            match L.(location_of_account l1 a, location_of_account l2 a) with","counters":[{"col_start":39,"col_end":39,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"            | None, None ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ()","counters":[]},{"line":"            | Some _, None | None, Some _ ->","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"                mismatch ()","counters":[]},{"line":"            | Some x1, Some x2 -> (","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                match L.(get l1 x1, get l2 x2) with","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"                | None, None ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    ()","counters":[]},{"line":"                | Some _, None | None, Some _ ->","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"                    mismatch ()","counters":[]},{"line":"                | Some a1, Some a2 ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    [%test_eq: Account_without_receipt_chain_hash.t]","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                      (hide_rc a1) (hide_rc a2) ) ) )","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"","counters":[]},{"line":"  let txn_global_slot = Global_slot.zero","counters":[]},{"line":"","counters":[]},{"line":"  let iter_err ts ~f =","counters":[]},{"line":"    List.fold_until ts","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ~finish:(fun () -> Ok ())","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"      ~init:()","counters":[]},{"line":"      ~f:(fun () t ->","counters":[]},{"line":"        match f t with Error e -> Stop (Error e) | Ok _ -> Continue () )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"","counters":[]},{"line":"  let view : Zkapp_precondition.Protocol_state.View.t =","counters":[]},{"line":"    let h = Frozen_ledger_hash.empty_hash in","counters":[]},{"line":"    let len = Length.zero in","counters":[]},{"line":"    let a = Currency.Amount.zero in","counters":[]},{"line":"    let epoch_data =","counters":[]},{"line":"      { Epoch_data.Poly.ledger =","counters":[]},{"line":"          { Epoch_ledger.Poly.hash = h; total_currency = a }","counters":[]},{"line":"      ; seed = h","counters":[]},{"line":"      ; start_checkpoint = h","counters":[]},{"line":"      ; lock_checkpoint = h","counters":[]},{"line":"      ; epoch_length = len","counters":[]},{"line":"      }","counters":[]},{"line":"    in","counters":[]},{"line":"    { snarked_ledger_hash = h","counters":[]},{"line":"    ; timestamp = Block_time.zero","counters":[]},{"line":"    ; blockchain_length = len","counters":[]},{"line":"    ; min_window_density = len","counters":[]},{"line":"    ; last_vrf_output = ()","counters":[]},{"line":"    ; total_currency = a","counters":[]},{"line":"    ; global_slot_since_hard_fork = txn_global_slot","counters":[]},{"line":"    ; global_slot_since_genesis = txn_global_slot","counters":[]},{"line":"    ; staking_epoch_data = epoch_data","counters":[]},{"line":"    ; next_epoch_data = epoch_data","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  (* Quickcheck generator for Zkapp_command.t, derived from Test_spec generator *)","counters":[]},{"line":"  let gen_zkapp_command_from_test_spec =","counters":[]},{"line":"    let open Quickcheck.Let_syntax in","counters":[]},{"line":"    let%bind use_full_commitment = Bool.quickcheck_generator in","counters":[]},{"line":"    match%map Test_spec.mk_gen ~num_transactions:1 () with","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"    | { specs = [ spec ]; _ } ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        account_update_send ~use_full_commitment spec","counters":[]},{"line":"    | { specs; _ } ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        failwithf \"gen_zkapp_command_from_test_spec: expected one spec, got %d\"","counters":[]},{"line":"          (List.length specs) ()","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"end","counters":[]}]}