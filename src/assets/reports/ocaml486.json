{"filename":"src/lib/mina_base/signed_command_intf.ml","lines":[{"line":"(* user_command_intf.ml *)","counters":[]},{"line":"","counters":[]},{"line":"[%%import \"/src/config.mlh\"]","counters":[]},{"line":"","counters":[{"col_start":0,"col_end":0,"count":1}]},{"line":"open Mina_base_import","counters":[]},{"line":"open Core_kernel","counters":[]},{"line":"open Snark_params.Tick","counters":[]},{"line":"open Mina_numbers","counters":[]},{"line":"","counters":[]},{"line":"module type Gen_intf = sig","counters":[]},{"line":"  type t","counters":[]},{"line":"","counters":[]},{"line":"  module Gen : sig","counters":[]},{"line":"    (** Generate a single transaction between","counters":[]},{"line":"     * Generate random keys for sender and receiver","counters":[]},{"line":"     * for fee $\\in [Mina_compile_config.minimum_user_command_fee,","counters":[]},{"line":"     * Mina_compile_config.minimum_user_command_fee+fee_range]$","counters":[]},{"line":"     * and an amount $\\in [1,max_amount]$","counters":[]},{"line":"    *)","counters":[]},{"line":"    val payment :","counters":[]},{"line":"         ?sign_type:[ `Fake | `Real ]","counters":[]},{"line":"      -> key_gen:","counters":[]},{"line":"           (Signature_keypair.t * Signature_keypair.t) Quickcheck.Generator.t","counters":[]},{"line":"      -> ?nonce:Account_nonce.t","counters":[]},{"line":"      -> ?min_amount:int","counters":[]},{"line":"      -> max_amount:int","counters":[]},{"line":"      -> fee_range:int","counters":[]},{"line":"      -> unit","counters":[]},{"line":"      -> t Quickcheck.Generator.t","counters":[]},{"line":"","counters":[]},{"line":"    (** Generate a single transaction between","counters":[]},{"line":"     * $a, b \\in keys$","counters":[]},{"line":"     * for fee $\\in [Mina_compile_config.minimum_user_command_fee,","counters":[]},{"line":"     * Mina_compile_config.minimum_user_command_fee+fee_range]$","counters":[]},{"line":"     * and an amount $\\in [1,max_amount]$","counters":[]},{"line":"    *)","counters":[]},{"line":"    val payment_with_random_participants :","counters":[]},{"line":"         ?sign_type:[ `Fake | `Real ]","counters":[]},{"line":"      -> keys:Signature_keypair.t array","counters":[]},{"line":"      -> ?nonce:Account_nonce.t","counters":[]},{"line":"      -> ?min_amount:int","counters":[]},{"line":"      -> max_amount:int","counters":[]},{"line":"      -> fee_range:int","counters":[]},{"line":"      -> unit","counters":[]},{"line":"      -> t Quickcheck.Generator.t","counters":[]},{"line":"","counters":[]},{"line":"    val stake_delegation :","counters":[]},{"line":"         key_gen:","counters":[]},{"line":"           (Signature_keypair.t * Signature_keypair.t) Quickcheck.Generator.t","counters":[]},{"line":"      -> ?nonce:Account_nonce.t","counters":[]},{"line":"      -> fee_range:int","counters":[]},{"line":"      -> unit","counters":[]},{"line":"      -> t Quickcheck.Generator.t","counters":[]},{"line":"","counters":[]},{"line":"    val stake_delegation_with_random_participants :","counters":[]},{"line":"         keys:Signature_keypair.t array","counters":[]},{"line":"      -> ?nonce:Account_nonce.t","counters":[]},{"line":"      -> fee_range:int","counters":[]},{"line":"      -> unit","counters":[]},{"line":"      -> t Quickcheck.Generator.t","counters":[]},{"line":"","counters":[]},{"line":"    (** Generate a valid sequence of payments based on the initial state of a","counters":[]},{"line":"        ledger. Use this together with Ledger.gen_initial_ledger_state.","counters":[]},{"line":"    *)","counters":[]},{"line":"    val sequence :","counters":[]},{"line":"         ?length:int","counters":[]},{"line":"      -> ?sign_type:[ `Fake | `Real ]","counters":[]},{"line":"      -> ( Signature_lib.Keypair.t","counters":[]},{"line":"         * Currency.Amount.t","counters":[]},{"line":"         * Mina_numbers.Account_nonce.t","counters":[]},{"line":"         * Account_timing.t )","counters":[]},{"line":"         array","counters":[]},{"line":"      -> t list Quickcheck.Generator.t","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type S = sig","counters":[]},{"line":"  type t [@@deriving sexp, yojson, hash]","counters":[]},{"line":"","counters":[]},{"line":"  (* type of signed commands, pre-Berkeley hard fork *)","counters":[]},{"line":"  type t_v1","counters":[]},{"line":"","counters":[]},{"line":"  include Comparable.S with type t := t","counters":[]},{"line":"","counters":[]},{"line":"  include Hashable.S with type t := t","counters":[]},{"line":"","counters":[]},{"line":"  val payload : t -> Signed_command_payload.t","counters":[]},{"line":"","counters":[]},{"line":"  val fee : t -> Currency.Fee.t","counters":[]},{"line":"","counters":[]},{"line":"  val nonce : t -> Account_nonce.t","counters":[]},{"line":"","counters":[]},{"line":"  val signer : t -> Public_key.t","counters":[]},{"line":"","counters":[]},{"line":"  val fee_token : t -> Token_id.t","counters":[]},{"line":"","counters":[]},{"line":"  val fee_payer_pk : t -> Public_key.Compressed.t","counters":[]},{"line":"","counters":[]},{"line":"  val fee_payer : t -> Account_id.t","counters":[]},{"line":"","counters":[]},{"line":"  val fee_excess : t -> Fee_excess.t","counters":[]},{"line":"","counters":[]},{"line":"  val token : t -> Token_id.t","counters":[]},{"line":"","counters":[]},{"line":"  val source_pk : t -> Public_key.Compressed.t","counters":[]},{"line":"","counters":[]},{"line":"  val source : t -> Account_id.t","counters":[]},{"line":"","counters":[]},{"line":"  val receiver_pk : t -> Public_key.Compressed.t","counters":[]},{"line":"","counters":[]},{"line":"  val receiver : t -> Account_id.t","counters":[]},{"line":"","counters":[]},{"line":"  val public_keys : t -> Public_key.Compressed.t list","counters":[]},{"line":"","counters":[]},{"line":"  val amount : t -> Currency.Amount.t option","counters":[]},{"line":"","counters":[]},{"line":"  val memo : t -> Signed_command_memo.t","counters":[]},{"line":"","counters":[]},{"line":"  val valid_until : t -> Global_slot.t","counters":[]},{"line":"","counters":[]},{"line":"  (* for filtering *)","counters":[]},{"line":"  val minimum_fee : Currency.Fee.t","counters":[]},{"line":"","counters":[]},{"line":"  val has_insufficient_fee : t -> bool","counters":[]},{"line":"","counters":[]},{"line":"  val tag : t -> Transaction_union_tag.t","counters":[]},{"line":"","counters":[]},{"line":"  val tag_string : t -> string","counters":[]},{"line":"","counters":[]},{"line":"  val to_input_legacy :","counters":[]},{"line":"    Signed_command_payload.t -> (Field.t, bool) Random_oracle_input.Legacy.t","counters":[]},{"line":"","counters":[]},{"line":"  include Gen_intf with type t := t","counters":[]},{"line":"","counters":[]},{"line":"  module With_valid_signature : sig","counters":[]},{"line":"    module Stable : sig","counters":[]},{"line":"      module Latest : sig","counters":[]},{"line":"        type nonrec t","counters":[]},{"line":"        [@@deriving sexp, equal, bin_io, yojson, version, compare, hash]","counters":[]},{"line":"","counters":[]},{"line":"        include Gen_intf with type t := t","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      module V2 = Latest","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    type t = Stable.Latest.t [@@deriving sexp, yojson, compare, hash]","counters":[]},{"line":"","counters":[]},{"line":"    include Gen_intf with type t := t","counters":[]},{"line":"","counters":[]},{"line":"    include Comparable.S with type t := t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  val sign_payload :","counters":[]},{"line":"       ?signature_kind:Mina_signature_kind.t","counters":[]},{"line":"    -> Signature_lib.Private_key.t","counters":[]},{"line":"    -> Signed_command_payload.t","counters":[]},{"line":"    -> Signature.t","counters":[]},{"line":"","counters":[]},{"line":"  val sign :","counters":[]},{"line":"       ?signature_kind:Mina_signature_kind.t","counters":[]},{"line":"    -> Signature_keypair.t","counters":[]},{"line":"    -> Signed_command_payload.t","counters":[]},{"line":"    -> With_valid_signature.t","counters":[]},{"line":"","counters":[]},{"line":"  val check_signature : ?signature_kind:Mina_signature_kind.t -> t -> bool","counters":[]},{"line":"","counters":[]},{"line":"  val create_with_signature_checked :","counters":[]},{"line":"       ?signature_kind:Mina_signature_kind.t","counters":[]},{"line":"    -> Signature.t","counters":[]},{"line":"    -> Public_key.Compressed.t","counters":[]},{"line":"    -> Signed_command_payload.t","counters":[]},{"line":"    -> With_valid_signature.t option","counters":[]},{"line":"","counters":[]},{"line":"  val check_valid_keys : t -> bool","counters":[]},{"line":"","counters":[]},{"line":"  module Base58_check_v1 : Codable.Base58_check_intf with type t := t_v1","counters":[]},{"line":"","counters":[]},{"line":"  module For_tests : sig","counters":[]},{"line":"    (** the signature kind is an argument, to match `sign`, but ignored *)","counters":[]},{"line":"    val fake_sign :","counters":[]},{"line":"         ?signature_kind:Mina_signature_kind.t","counters":[]},{"line":"      -> Signature_keypair.t","counters":[]},{"line":"      -> Signed_command_payload.t","counters":[]},{"line":"      -> With_valid_signature.t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  (** checks signature and keys *)","counters":[]},{"line":"  val check : t -> With_valid_signature.t option","counters":[]},{"line":"","counters":[]},{"line":"  val check_only_for_signature : t -> With_valid_signature.t option","counters":[]},{"line":"","counters":[]},{"line":"  val to_valid_unsafe :","counters":[]},{"line":"       t","counters":[]},{"line":"    -> [ `If_this_is_used_it_should_have_a_comment_justifying_it of","counters":[]},{"line":"         With_valid_signature.t ]","counters":[]},{"line":"","counters":[]},{"line":"  (** Forget the signature check. *)","counters":[]},{"line":"  val forget_check : With_valid_signature.t -> t","counters":[]},{"line":"","counters":[]},{"line":"  (** account ids accessed, given a transaction status *)","counters":[]},{"line":"  val accounts_accessed : t -> Transaction_status.t -> Account_id.t list","counters":[]},{"line":"","counters":[]},{"line":"  (** all account ids mentioned in a command *)","counters":[]},{"line":"  val accounts_referenced : t -> Account_id.t list","counters":[]},{"line":"","counters":[]},{"line":"  val filter_by_participant : t list -> Public_key.Compressed.t -> t list","counters":[]},{"line":"","counters":[]},{"line":"  val of_base58_check_exn_v1 : string -> t_v1 Or_error.t","counters":[]},{"line":"","counters":[]},{"line":"  include Codable.Base64_intf with type t := t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type Full = sig","counters":[]},{"line":"  module Payload = Signed_command_payload","counters":[]},{"line":"","counters":[]},{"line":"  module Poly : sig","counters":[]},{"line":"    [%%versioned:","counters":[]},{"line":"    module Stable : sig","counters":[]},{"line":"      module V1 : sig","counters":[]},{"line":"        type ('payload, 'pk, 'signature) t =","counters":[]},{"line":"              ( 'payload","counters":[]},{"line":"              , 'pk","counters":[]},{"line":"              , 'signature )","counters":[]},{"line":"              Mina_wire_types.Mina_base.Signed_command.Poly.V1.t =","counters":[]},{"line":"          { payload : 'payload; signer : 'pk; signature : 'signature }","counters":[]},{"line":"        [@@deriving sexp, hash, yojson, equal, compare]","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  [%%versioned:","counters":[]},{"line":"  module Stable : sig","counters":[]},{"line":"    [@@@no_toplevel_latest_type]","counters":[]},{"line":"","counters":[]},{"line":"    module V2 : sig","counters":[]},{"line":"      type t =","counters":[]},{"line":"        ( Payload.Stable.V2.t","counters":[]},{"line":"        , Public_key.Stable.V1.t","counters":[]},{"line":"        , Signature.Stable.V1.t )","counters":[]},{"line":"        Poly.Stable.V1.t","counters":[]},{"line":"      [@@deriving sexp, hash, yojson, version]","counters":[]},{"line":"","counters":[]},{"line":"      include Comparable.S with type t := t","counters":[]},{"line":"","counters":[]},{"line":"      include Hashable.S with type t := t","counters":[]},{"line":"","counters":[]},{"line":"      val accounts_accessed : t -> Transaction_status.t -> Account_id.t list","counters":[]},{"line":"","counters":[]},{"line":"      val accounts_referenced : t -> Account_id.t list","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module V1 : sig","counters":[]},{"line":"      type t =","counters":[]},{"line":"        ( Payload.Stable.V1.t","counters":[]},{"line":"        , Public_key.Stable.V1.t","counters":[]},{"line":"        , Signature.Stable.V1.t )","counters":[]},{"line":"        Poly.Stable.V1.t","counters":[]},{"line":"      [@@deriving compare, sexp, hash, yojson]","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  include S with type t = Stable.V2.t and type t_v1 = Stable.V1.t","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":1}]}]}