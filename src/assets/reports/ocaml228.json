{"filename":"src/lib/pickles/wrap_hack.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Backend","counters":[]},{"line":"open Pickles_types","counters":[]},{"line":"","counters":[]},{"line":"(* The actual \"accumulator\" for the wrap proof contains a vector of elements,","counters":[]},{"line":"   each of which is a vector of bulletproof challenges.","counters":[]},{"line":"","counters":[]},{"line":"   The number of such vectors is equal to the maximum proofs-verified","counters":[]},{"line":"   amongst all the step branches that that proof is wrapping.","counters":[]},{"line":"","counters":[]},{"line":"   To simplify the implementation when the number of proofs-verified","counters":[]},{"line":"   varies across proof systems (being either 0, 1, or 2) we secretly","counters":[]},{"line":"   pad the accumulator so that it always has exactly 2 vectors, padding","counters":[]},{"line":"   with dummy vectors.","counters":[]},{"line":"","counters":[]},{"line":"   We also then pad with the corresponding dummy commitments when proving","counters":[]},{"line":"   wrap statements, as in `pad_accumulator` which is used in wrap.ml.","counters":[]},{"line":"","counters":[]},{"line":"   We add them to the **front**, not the back, of the vector of the actual","counters":[]},{"line":"   \"real\" accumulator values so that we can precompute the sponge states","counters":[]},{"line":"   resulting from absorbing the padding challenges","counters":[]},{"line":"*)","counters":[]},{"line":"","counters":[]},{"line":"module Padded_length = Nat.N2","counters":[]},{"line":"","counters":[]},{"line":"(* Pad up to length 2 by preprending dummy values. *)","counters":[]},{"line":"let pad_vector (type a) ~dummy (v : (a, _) Vector.t) =","counters":[]},{"line":"  let v = Vector.to_array v in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let n = Array.length v in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  assert (n <= 2) ;","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":9,"col_end":9,"count":0}]},{"line":"  let padding = 2 - n in","counters":[]},{"line":"  Vector.init Padded_length.n ~f:(fun i ->","counters":[]},{"line":"      if i < padding then dummy else v.(i - padding) )","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"(* Specialized padding function. *)","counters":[]},{"line":"let pad_challenges (chalss : (_ Vector.t, _) Vector.t) =","counters":[]},{"line":"  pad_vector ~dummy:Dummy.Ipa.Wrap.challenges_computed chalss","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"(* Specialized padding function. *)","counters":[]},{"line":"let pad_accumulator (xs : (Tock.Proof.Challenge_polynomial.t, _) Vector.t) =","counters":[]},{"line":"  pad_vector xs","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":11,"col_end":11,"count":0}]},{"line":"    ~dummy:","counters":[]},{"line":"      { Tock.Proof.Challenge_polynomial.commitment =","counters":[]},{"line":"          Lazy.force Dummy.Ipa.Wrap.sg","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"      ; challenges = Vector.to_array Dummy.Ipa.Wrap.challenges_computed","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"      }","counters":[]},{"line":"  |> Vector.to_list","counters":[]},{"line":"","counters":[]},{"line":"(* Hash the me only, padding first. *)","counters":[]},{"line":"let hash_messages_for_next_wrap_proof (type n) (max_proofs_verified : n Nat.t)","counters":[]},{"line":"    (t :","counters":[]},{"line":"      ( Tick.Curve.Affine.t","counters":[]},{"line":"      , (_, n) Vector.t )","counters":[]},{"line":"      Composition_types.Wrap.Proof_state.Messages_for_next_wrap_proof.t ) =","counters":[]},{"line":"  let t =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    { t with","counters":[]},{"line":"      old_bulletproof_challenges = pad_challenges t.old_bulletproof_challenges","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"    }","counters":[]},{"line":"  in","counters":[]},{"line":"  Tock_field_sponge.digest Tock_field_sponge.params","counters":[]},{"line":"    (Composition_types.Wrap.Proof_state.Messages_for_next_wrap_proof","counters":[]},{"line":"     .to_field_elements t ~g1:(fun ((x, y) : Tick.Curve.Affine.t) -> [ x; y ])","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"    )","counters":[]},{"line":"","counters":[]},{"line":"(* Pad the messages_for_next_wrap_proof of a proof *)","counters":[]},{"line":"let pad_proof (type mlmb) (T p : (mlmb, _) Proof.t) :","counters":[]},{"line":"    Proof.Proofs_verified_max.t =","counters":[]},{"line":"  T","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    { p with","counters":[]},{"line":"      statement =","counters":[]},{"line":"        { p.statement with","counters":[]},{"line":"          proof_state =","counters":[]},{"line":"            { p.statement.proof_state with","counters":[]},{"line":"              messages_for_next_wrap_proof =","counters":[]},{"line":"                { p.statement.proof_state.messages_for_next_wrap_proof with","counters":[]},{"line":"                  old_bulletproof_challenges =","counters":[]},{"line":"                    pad_vector","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                      p.statement.proof_state.messages_for_next_wrap_proof","counters":[]},{"line":"                        .old_bulletproof_challenges","counters":[]},{"line":"                      ~dummy:Dummy.Ipa.Wrap.challenges","counters":[]},{"line":"                }","counters":[]},{"line":"            }","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"module Checked = struct","counters":[]},{"line":"  let pad_challenges (chalss : (_ Vector.t, _) Vector.t) =","counters":[]},{"line":"    pad_vector","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ~dummy:","counters":[]},{"line":"        (Vector.map ~f:Impls.Wrap.Field.constant","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"           Dummy.Ipa.Wrap.challenges_computed )","counters":[]},{"line":"      chalss","counters":[]},{"line":"","counters":[]},{"line":"  let pad_commitments (commitments : _ Vector.t) =","counters":[]},{"line":"    pad_vector","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ~dummy:","counters":[]},{"line":"        (Tuple_lib.Double.map ~f:Impls.Step.Field.constant","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"           (Lazy.force Dummy.Ipa.Wrap.sg) )","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"      commitments","counters":[]},{"line":"","counters":[]},{"line":"  (* We precompute the sponge states that would result from absorbing","counters":[]},{"line":"     0, 1, or 2 dummy challenge vectors. This is used to speed up hashing","counters":[]},{"line":"     inside the circuit. *)","counters":[]},{"line":"  let dummy_messages_for_next_wrap_proof_sponge_states =","counters":[]},{"line":"    lazy","counters":[]},{"line":"      (let module S = Tock_field_sponge.Field in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let full_state s = (S.state s, s.sponge_state) in","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"      let sponge = S.create Tock_field_sponge.params in","counters":[]},{"line":"      let s0 = full_state sponge in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Vector.iter ~f:(S.absorb sponge) Dummy.Ipa.Wrap.challenges_computed ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"      let s1 = full_state sponge in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Vector.iter ~f:(S.absorb sponge) Dummy.Ipa.Wrap.challenges_computed ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"      let s2 = full_state sponge in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      [| s0; s1; s2 |] )","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"  let hash_constant_messages_for_next_wrap_proof =","counters":[]},{"line":"    hash_messages_for_next_wrap_proof","counters":[]},{"line":"","counters":[]},{"line":"  (* TODO: No need to hash the entire bulletproof challenges. Could","counters":[]},{"line":"     just hash the segment of the public input LDE corresponding to them","counters":[]},{"line":"     that we compute when verifying the previous proof. That is a commitment","counters":[]},{"line":"     to them. *)","counters":[]},{"line":"  let hash_messages_for_next_wrap_proof (type n) (max_proofs_verified : n Nat.t)","counters":[]},{"line":"      (t :","counters":[]},{"line":"        ( Wrap_main_inputs.Inner_curve.t","counters":[]},{"line":"        , ((Impls.Wrap.Field.t, Backend.Tock.Rounds.n) Vector.t, n) Vector.t )","counters":[]},{"line":"        Composition_types.Wrap.Proof_state.Messages_for_next_wrap_proof.t ) =","counters":[]},{"line":"    let open Wrap_main_inputs in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let sponge =","counters":[]},{"line":"      (* The sponge states we would reach if we absorbed the padding challenges *)","counters":[]},{"line":"      let s = Sponge.create sponge_params in","counters":[]},{"line":"      let state, sponge_state =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (Lazy.force dummy_messages_for_next_wrap_proof_sponge_states).(2","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                                                                       - Nat","counters":[]},{"line":"                                                                         .to_int","counters":[{"col_start":79,"col_end":79,"count":0}]},{"line":"                                                                           max_proofs_verified)","counters":[]},{"line":"      in","counters":[]},{"line":"      { s with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        state = Array.map state ~f:Impls.Wrap.Field.constant","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"      ; sponge_state","counters":[]},{"line":"      }","counters":[]},{"line":"    in","counters":[]},{"line":"    Array.iter ~f:(Sponge.absorb sponge)","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"      (Composition_types.Wrap.Proof_state.Messages_for_next_wrap_proof","counters":[]},{"line":"       .to_field_elements ~g1:Inner_curve.to_field_elements t ) ;","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"    Sponge.squeeze_field sponge","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  (* Check that the pre-absorbing technique works. I.e., that it's consistent with","counters":[]},{"line":"     the actual definition of hash_messages_for_next_wrap_proof. *)","counters":[]},{"line":"  let%test_unit \"hash_messages_for_next_wrap_proof correct\" =","counters":[]},{"line":"    let open Impls.Wrap in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let test (type n) (n : n Nat.t) =","counters":[]},{"line":"      let messages_for_next_wrap_proof :","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          _ Composition_types.Wrap.Proof_state.Messages_for_next_wrap_proof.t =","counters":[]},{"line":"        let g = Wrap_main_inputs.Inner_curve.Constant.random () in","counters":[]},{"line":"        { Composition_types.Wrap.Proof_state.Messages_for_next_wrap_proof","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          .challenge_polynomial_commitment = g","counters":[]},{"line":"        ; old_bulletproof_challenges =","counters":[]},{"line":"            Vector.init n ~f:(fun _ ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                Vector.init Tock.Rounds.n ~f:(fun _ -> Tock.Field.random ()) )","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"        }","counters":[]},{"line":"      in","counters":[]},{"line":"      Internal_Basic.Test.test_equal ~sexp_of_t:Field.Constant.sexp_of_t","counters":[]},{"line":"        ~equal:Field.Constant.equal","counters":[]},{"line":"        (Composition_types.Wrap.Proof_state.Messages_for_next_wrap_proof.typ","counters":[{"col_start":75,"col_end":75,"count":0}]},{"line":"           Wrap_main_inputs.Inner_curve.typ","counters":[]},{"line":"           (Vector.typ Field.typ Backend.Tock.Rounds.n)","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"           ~length:n )","counters":[]},{"line":"        Field.typ","counters":[]},{"line":"        (fun t -> make_checked (fun () -> hash_messages_for_next_wrap_proof n t))","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"        (fun t ->","counters":[]},{"line":"          hash_constant_messages_for_next_wrap_proof n t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"          |> Digest.Constant.to_bits |> Impls.Wrap.Field.Constant.project )","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"        messages_for_next_wrap_proof","counters":[]},{"line":"    in","counters":[]},{"line":"    test Nat.N0.n ; test Nat.N1.n ; test Nat.N2.n","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}