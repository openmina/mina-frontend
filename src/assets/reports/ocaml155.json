{"filename":"src/lib/crypto/kimchi_backend/common/field.ml","lines":[{"line":"open Intf","counters":[]},{"line":"open Core_kernel","counters":[]},{"line":"module Bignum_bigint = Snarky_backendless.Backend_extended.Bignum_bigint","counters":[]},{"line":"","counters":[]},{"line":"module type Input_intf = sig","counters":[]},{"line":"  type t","counters":[]},{"line":"","counters":[]},{"line":"  module Bigint : Bigint.Intf","counters":[]},{"line":"","counters":[]},{"line":"  val size : unit -> Bigint.t","counters":[]},{"line":"","counters":[]},{"line":"  val size_in_bits : unit -> int","counters":[]},{"line":"","counters":[]},{"line":"  val to_bigint : t -> Bigint.t","counters":[]},{"line":"","counters":[]},{"line":"  val of_bigint : Bigint.t -> t","counters":[]},{"line":"","counters":[]},{"line":"  val of_int : int -> t","counters":[]},{"line":"","counters":[]},{"line":"  val domain_generator : int -> t","counters":[]},{"line":"","counters":[]},{"line":"  val add : t -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"  val sub : t -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"  val mul : t -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"  val div : t -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"  val inv : t -> t option","counters":[]},{"line":"","counters":[]},{"line":"  val negate : t -> t","counters":[]},{"line":"","counters":[]},{"line":"  val square : t -> t","counters":[]},{"line":"","counters":[]},{"line":"  val sqrt : t -> t option","counters":[]},{"line":"","counters":[]},{"line":"  val is_square : t -> bool","counters":[]},{"line":"","counters":[]},{"line":"  val equal : t -> t -> bool","counters":[]},{"line":"","counters":[]},{"line":"  val print : t -> unit","counters":[]},{"line":"","counters":[]},{"line":"  val to_string : t -> string","counters":[]},{"line":"","counters":[]},{"line":"  val of_string : string -> t","counters":[]},{"line":"","counters":[]},{"line":"  val random : unit -> t","counters":[]},{"line":"","counters":[]},{"line":"  val rng : int -> t","counters":[]},{"line":"","counters":[]},{"line":"  val two_adic_root_of_unity : unit -> t","counters":[]},{"line":"","counters":[]},{"line":"  val mut_add : t -> t -> unit","counters":[]},{"line":"","counters":[]},{"line":"  val mut_mul : t -> t -> unit","counters":[]},{"line":"","counters":[]},{"line":"  val mut_square : t -> unit","counters":[]},{"line":"","counters":[]},{"line":"  val mut_sub : t -> t -> unit","counters":[]},{"line":"","counters":[]},{"line":"  val copy : t -> t -> unit","counters":[]},{"line":"","counters":[]},{"line":"  val to_bytes : t -> bytes","counters":[]},{"line":"","counters":[]},{"line":"  val of_bytes : bytes -> t","counters":[]},{"line":"","counters":[]},{"line":"  val domain_generator : int -> t","counters":[]},{"line":"","counters":[]},{"line":"  module Vector : Snarky_intf.Vector.S with type elt = t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type S = sig","counters":[]},{"line":"  type t [@@deriving sexp, compare, yojson, bin_io, hash]","counters":[]},{"line":"","counters":[]},{"line":"  include Input_intf with type t := t","counters":[]},{"line":"","counters":[]},{"line":"  val size : Bigint.t","counters":[]},{"line":"","counters":[]},{"line":"  val domain_generator : log2_size:int -> t","counters":[]},{"line":"","counters":[]},{"line":"  val one : t","counters":[]},{"line":"","counters":[]},{"line":"  val zero : t","counters":[]},{"line":"","counters":[]},{"line":"  val inv : t -> t","counters":[]},{"line":"","counters":[]},{"line":"  val sqrt : t -> t","counters":[]},{"line":"","counters":[]},{"line":"  val size_in_bits : int","counters":[]},{"line":"","counters":[]},{"line":"  val to_bits : t -> bool list","counters":[]},{"line":"","counters":[]},{"line":"  val of_bits : bool list -> t","counters":[]},{"line":"","counters":[]},{"line":"  val ( + ) : t -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"  val ( - ) : t -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"  val ( * ) : t -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"  val ( / ) : t -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"  module Mutable : sig","counters":[]},{"line":"    val add : t -> other:t -> unit","counters":[]},{"line":"","counters":[]},{"line":"    val mul : t -> other:t -> unit","counters":[]},{"line":"","counters":[]},{"line":"    val square : t -> unit","counters":[]},{"line":"","counters":[]},{"line":"    val sub : t -> other:t -> unit","counters":[]},{"line":"","counters":[]},{"line":"    val copy : over:t -> t -> unit","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  val ( += ) : t -> t -> unit","counters":[]},{"line":"","counters":[]},{"line":"  val ( *= ) : t -> t -> unit","counters":[]},{"line":"","counters":[]},{"line":"  val ( -= ) : t -> t -> unit","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type S_with_version = sig","counters":[]},{"line":"  [%%versioned:","counters":[]},{"line":"  module Stable : sig","counters":[]},{"line":"    [@@@no_toplevel_latest_type]","counters":[]},{"line":"","counters":[]},{"line":"    module V1 : sig","counters":[]},{"line":"      [@@@with_all_version_tags]","counters":[]},{"line":"","counters":[]},{"line":"      type t [@@deriving version, sexp, bin_io, compare, yojson, hash, equal]","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  include S with type t = Stable.Latest.t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make (F : Input_intf) :","counters":[]},{"line":"  S_with_version","counters":[]},{"line":"    with type Stable.V1.t = F.t","counters":[]},{"line":"     and module Bigint = F.Bigint","counters":[]},{"line":"     and module Vector = F.Vector = struct","counters":[]},{"line":"  include F","counters":[]},{"line":"","counters":[]},{"line":"  let size = size ()","counters":[{"col_start":16,"col_end":16,"count":2}]},{"line":"","counters":[]},{"line":"  let size_in_bits = size_in_bits ()","counters":[{"col_start":32,"col_end":32,"count":2}]},{"line":"","counters":[]},{"line":"  [%%versioned_binable","counters":[]},{"line":"  module Stable = struct","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"    module V1 = struct","counters":[]},{"line":"      [@@@with_all_version_tags]","counters":[]},{"line":"","counters":[]},{"line":"      type t = (F.t[@version_asserted]) [@@deriving version]","counters":[{"col_start":6,"col_end":6,"count":4},{"col_start":59,"col_end":59,"count":14}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"      include","counters":[]},{"line":"        Binable.Of_binable","counters":[]},{"line":"          (Bigint)","counters":[]},{"line":"          (struct","counters":[]},{"line":"            type nonrec t = t","counters":[]},{"line":"","counters":[]},{"line":"            let to_binable = to_bigint","counters":[]},{"line":"","counters":[]},{"line":"            let of_binable = of_bigint","counters":[]},{"line":"          end)","counters":[]},{"line":"","counters":[]},{"line":"      include","counters":[]},{"line":"        Sexpable.Of_sexpable","counters":[]},{"line":"          (Bigint)","counters":[]},{"line":"          (struct","counters":[]},{"line":"            type nonrec t = t","counters":[]},{"line":"","counters":[]},{"line":"            let to_sexpable = to_bigint","counters":[]},{"line":"","counters":[]},{"line":"            let of_sexpable = of_bigint","counters":[]},{"line":"          end)","counters":[]},{"line":"","counters":[]},{"line":"      let to_bignum_bigint n =","counters":[]},{"line":"        let rec go i two_to_the_i acc =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          if Int.equal i size_in_bits then acc","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"          else","counters":[]},{"line":"            let acc' =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              if Bigint.test_bit n i then Bignum_bigint.(acc + two_to_the_i)","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"              else acc","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"            in","counters":[]},{"line":"            go (i + 1) Bignum_bigint.(two_to_the_i + two_to_the_i) acc'","counters":[]},{"line":"        in","counters":[]},{"line":"        go 0 Bignum_bigint.one Bignum_bigint.zero","counters":[]},{"line":"","counters":[]},{"line":"      let hash_fold_t s x =","counters":[]},{"line":"        Bignum_bigint.hash_fold_t s (to_bignum_bigint (to_bigint x))","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":52,"col_end":52,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"","counters":[]},{"line":"      let hash = Hash.of_fold hash_fold_t","counters":[{"col_start":28,"col_end":28,"count":2}]},{"line":"","counters":[]},{"line":"      let compare t1 t2 = Bigint.compare (to_bigint t1) (to_bigint t2)","counters":[{"col_start":26,"col_end":26,"count":235},{"col_start":50,"col_end":50,"count":235},{"col_start":65,"col_end":65,"count":235}]},{"line":"","counters":[]},{"line":"      let equal = equal","counters":[]},{"line":"","counters":[]},{"line":"      let to_yojson t : Yojson.Safe.t =","counters":[]},{"line":"        `String (Bigint.to_hex_string (to_bigint t))","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"","counters":[]},{"line":"      let of_yojson j =","counters":[]},{"line":"        match j with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | `String h ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Ok (of_bigint (Bigint.of_hex_string h))","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"        | _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Error \"expected hex string\"","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  include (","counters":[]},{"line":"    Stable.Latest : module type of Stable.Latest with type t := Stable.Latest.t )","counters":[]},{"line":"","counters":[]},{"line":"  let domain_generator ~log2_size = domain_generator log2_size","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"","counters":[]},{"line":"  let one = of_int 1","counters":[{"col_start":17,"col_end":17,"count":2}]},{"line":"","counters":[]},{"line":"  let zero = of_int 0","counters":[{"col_start":18,"col_end":18,"count":2}]},{"line":"","counters":[]},{"line":"  (* TODO: Improve snarky interface so these aren't necessary.. *)","counters":[]},{"line":"  let inv x = Option.value (inv x) ~default:zero","counters":[{"col_start":14,"col_end":14,"count":9},{"col_start":30,"col_end":30,"count":9}]},{"line":"","counters":[]},{"line":"  let sqrt x = Option.value (sqrt x) ~default:zero","counters":[{"col_start":15,"col_end":15,"count":5},{"col_start":32,"col_end":32,"count":5}]},{"line":"","counters":[]},{"line":"  let to_bits t =","counters":[]},{"line":"    (* Avoids allocation *)","counters":[]},{"line":"    let n = F.to_bigint t in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    List.init size_in_bits ~f:(Bigint.test_bit n)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"","counters":[]},{"line":"  let of_bits bs =","counters":[]},{"line":"    List.fold (List.rev bs) ~init:zero ~f:(fun acc b ->","counters":[{"col_start":4,"col_end":4,"count":399},{"col_start":22,"col_end":22,"count":399}]},{"line":"        let acc = add acc acc in","counters":[{"col_start":8,"col_end":8,"count":101745}]},{"line":"        if b then add acc one else acc )","counters":[{"col_start":8,"col_end":8,"count":101745},{"col_start":18,"col_end":18,"count":50678},{"col_start":35,"col_end":35,"count":51067}]},{"line":"","counters":[]},{"line":"  let%test_unit \"sexp round trip\" =","counters":[]},{"line":"    let t = random () in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    assert (equal t (t_of_sexp (sexp_of_t t)))","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":11,"col_end":11,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"  let%test_unit \"bin_io round trip\" =","counters":[]},{"line":"    let t = random () in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    [%test_eq: Stable.Latest.t] t","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"      (Binable.of_string","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"         (module Stable.Latest)","counters":[]},{"line":"         (Binable.to_string (module Stable.Latest) t) )","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"","counters":[]},{"line":"  let ( + ) = add","counters":[]},{"line":"","counters":[]},{"line":"  let ( - ) = sub","counters":[]},{"line":"","counters":[]},{"line":"  let ( * ) = mul","counters":[]},{"line":"","counters":[]},{"line":"  let ( / ) = div","counters":[]},{"line":"","counters":[]},{"line":"  module Mutable = struct","counters":[]},{"line":"    let add t ~other = mut_add t other","counters":[{"col_start":23,"col_end":23,"count":930}]},{"line":"","counters":[]},{"line":"    let mul t ~other = mut_mul t other","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"    let square = mut_square","counters":[]},{"line":"","counters":[]},{"line":"    let sub t ~other = mut_sub t other","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"    let copy ~over t = copy over t","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let op f t other = f t ~other","counters":[{"col_start":21,"col_end":21,"count":930}]},{"line":"","counters":[]},{"line":"  let ( += ) = op Mutable.add","counters":[{"col_start":16,"col_end":16,"count":2}]},{"line":"","counters":[]},{"line":"  let ( *= ) = op Mutable.mul","counters":[{"col_start":16,"col_end":16,"count":2}]},{"line":"","counters":[]},{"line":"  let ( -= ) = op Mutable.sub","counters":[{"col_start":16,"col_end":16,"count":2}]},{"line":"","counters":[]},{"line":"  let%test \"of_bits to_bits\" =","counters":[]},{"line":"    let x = random () in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    equal x (of_bits (to_bits x))","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"","counters":[]},{"line":"  let%test_unit \"to_bits of_bits\" =","counters":[]},{"line":"    Quickcheck.test","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (Quickcheck.Generator.list_with_length","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"         Int.(size_in_bits - 1)","counters":[]},{"line":"         Bool.quickcheck_generator )","counters":[]},{"line":"      ~f:(fun bs ->","counters":[]},{"line":"        [%test_eq: bool list] (bs @ [ false ]) (to_bits (of_bits bs)) )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":54,"col_end":54,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}