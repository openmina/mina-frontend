{"filename":"src/lib/transition_frontier/persistent_frontier/persistent_frontier.ml","lines":[{"line":"open Async_kernel","counters":[]},{"line":"open Core","counters":[]},{"line":"open Mina_base","counters":[]},{"line":"open Mina_state","counters":[]},{"line":"open Mina_block","counters":[]},{"line":"open Frontier_base","counters":[]},{"line":"module Database = Database","counters":[]},{"line":"","counters":[]},{"line":"module type CONTEXT = sig","counters":[]},{"line":"  val logger : Logger.t","counters":[]},{"line":"","counters":[]},{"line":"  val precomputed_values : Precomputed_values.t","counters":[]},{"line":"","counters":[]},{"line":"  val constraint_constants : Genesis_constants.Constraint_constants.t","counters":[]},{"line":"","counters":[]},{"line":"  val consensus_constants : Consensus.Constants.t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"exception Invalid_genesis_state_hash of Mina_block.Validated.t","counters":[]},{"line":"","counters":[]},{"line":"let construct_staged_ledger_at_root ~(precomputed_values : Precomputed_values.t)","counters":[]},{"line":"    ~root_ledger ~root_transition ~root ~protocol_states ~logger =","counters":[]},{"line":"  let open Deferred.Or_error.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let open Root_data.Minimal in","counters":[]},{"line":"  let blockchain_state =","counters":[]},{"line":"    root_transition |> Mina_block.Validated.forget |> With_hash.data","counters":[{"col_start":49,"col_end":49,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"    |> Mina_block.header |> Mina_block.Header.protocol_state","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"    |> Protocol_state.blockchain_state","counters":[]},{"line":"  in","counters":[]},{"line":"  let pending_coinbases = pending_coinbase root in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let scan_state = scan_state root in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let protocol_states_map =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    List.fold protocol_states ~init:State_hash.Map.empty","counters":[]},{"line":"      ~f:(fun acc protocol_state ->","counters":[]},{"line":"        Map.add_exn acc ~key:(Protocol_state.hashes protocol_state).state_hash","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"          ~data:protocol_state )","counters":[]},{"line":"  in","counters":[]},{"line":"  let get_state hash =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    match Map.find protocol_states_map hash with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [%log error]","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"          ~metadata:[ (\"state_hash\", State_hash.to_yojson hash) ]","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"          \"Protocol state (for scan state transactions) for $state_hash not \\","counters":[]},{"line":"           found when loading persisted transition frontier\" ;","counters":[]},{"line":"        Or_error.errorf","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          !\"Protocol state (for scan state transactions) for \\","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"            %{sexp:State_hash.t} not found when loading persisted transition \\","counters":[]},{"line":"            frontier\"","counters":[]},{"line":"          hash","counters":[]},{"line":"    | Some protocol_state ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Ok protocol_state","counters":[]},{"line":"  in","counters":[]},{"line":"  let mask = Mina_ledger.Ledger.of_database root_ledger in","counters":[]},{"line":"  let local_state =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Blockchain_state.registers blockchain_state |> Registers.local_state","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"  in","counters":[]},{"line":"  let staged_ledger_hash =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Blockchain_state.staged_ledger_hash blockchain_state","counters":[]},{"line":"  in","counters":[]},{"line":"  let%bind staged_ledger =","counters":[]},{"line":"    Staged_ledger.of_scan_state_pending_coinbases_and_snarked_ledger_unchecked","counters":[]},{"line":"      ~snarked_local_state:local_state ~snarked_ledger:mask ~scan_state","counters":[]},{"line":"      ~constraint_constants:precomputed_values.constraint_constants","counters":[]},{"line":"      ~pending_coinbases","counters":[]},{"line":"      ~expected_merkle_root:(Staged_ledger_hash.ledger_hash staged_ledger_hash)","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"      ~get_state","counters":[]},{"line":"  in","counters":[]},{"line":"  let is_genesis =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Mina_block.Validated.header root_transition","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"    |> Header.protocol_state |> Protocol_state.consensus_state","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"    |> Consensus.Data.Consensus_state.is_genesis_state","counters":[]},{"line":"  in","counters":[]},{"line":"  let constructed_staged_ledger_hash = Staged_ledger.hash staged_ledger in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  if","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    is_genesis","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"    || Staged_ledger_hash.equal staged_ledger_hash","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"         constructed_staged_ledger_hash","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"  then Deferred.return (Ok staged_ledger)","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"  else","counters":[]},{"line":"    Deferred.return","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (Or_error.errorf","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"         !\"Constructed staged ledger %{sexp: Staged_ledger_hash.t} did not \\","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"           match the staged ledger hash in the protocol state %{sexp: \\","counters":[]},{"line":"           Staged_ledger_hash.t}\"","counters":[]},{"line":"         constructed_staged_ledger_hash staged_ledger_hash )","counters":[]},{"line":"","counters":[]},{"line":"module rec Instance_type : sig","counters":[]},{"line":"  type t =","counters":[]},{"line":"    { db : Database.t; mutable sync : Sync.t option; factory : Factory_type.t }","counters":[]},{"line":"end =","counters":[]},{"line":"  Instance_type","counters":[]},{"line":"","counters":[]},{"line":"and Factory_type : sig","counters":[]},{"line":"  type t =","counters":[]},{"line":"    { logger : Logger.t","counters":[]},{"line":"    ; directory : string","counters":[]},{"line":"    ; verifier : Verifier.t","counters":[]},{"line":"    ; time_controller : Block_time.Controller.t","counters":[]},{"line":"    ; mutable instance : Instance_type.t option","counters":[]},{"line":"    }","counters":[]},{"line":"end =","counters":[]},{"line":"  Factory_type","counters":[]},{"line":"","counters":[]},{"line":"open Instance_type","counters":[]},{"line":"open Factory_type","counters":[]},{"line":"","counters":[]},{"line":"module Instance = struct","counters":[]},{"line":"  type t = Instance_type.t","counters":[]},{"line":"","counters":[]},{"line":"  let create factory =","counters":[]},{"line":"    let db =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Database.create ~logger:factory.logger ~directory:factory.directory","counters":[]},{"line":"    in","counters":[]},{"line":"    { db; sync = None; factory }","counters":[]},{"line":"","counters":[]},{"line":"  let assert_no_sync t =","counters":[]},{"line":"    if Option.is_some t.sync then Error `Sync_cannot_be_running else Ok ()","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"","counters":[]},{"line":"  let assert_sync t ~f =","counters":[]},{"line":"    match t.sync with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        return (Error `Sync_must_be_running)","counters":[]},{"line":"    | Some sync ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        f sync","counters":[]},{"line":"","counters":[]},{"line":"  let start_sync ~constraint_constants t ~persistent_root_instance =","counters":[]},{"line":"    let open Result.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let%map () = assert_no_sync t in","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"    t.sync <-","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Some","counters":[]},{"line":"        (Sync.create ~constraint_constants ~logger:t.factory.logger","counters":[]},{"line":"           ~time_controller:t.factory.time_controller ~db:t.db","counters":[]},{"line":"           ~persistent_root_instance )","counters":[]},{"line":"","counters":[]},{"line":"  let stop_sync t =","counters":[]},{"line":"    let open Deferred.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    assert_sync t ~f:(fun sync ->","counters":[]},{"line":"        let%map () = Sync.close sync in","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"        t.sync <- None ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Ok () )","counters":[]},{"line":"","counters":[]},{"line":"  let notify_sync t ~diffs =","counters":[]},{"line":"    assert_sync t ~f:(fun sync ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        Sync.notify sync ~diffs ; Deferred.Result.return () )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"","counters":[]},{"line":"  let destroy t =","counters":[]},{"line":"    let open Deferred.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    [%log' trace t.factory.logger]","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"      \"Destroying transition frontier persistence instance\" ;","counters":[]},{"line":"    let%map () =","counters":[]},{"line":"      if Option.is_some t.sync then","counters":[]},{"line":"        stop_sync t","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"        >>| Fn.compose Result.ok_or_failwith","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":10,"col_end":10,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"              (Result.map_error ~f:(Fn.const \"impossible\"))","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"      else return ()","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":16,"col_end":16,"count":0}]},{"line":"    in","counters":[]},{"line":"    Database.close t.db ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    t.factory.instance <- None","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let factory { factory; _ } = factory","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"","counters":[]},{"line":"  let check_database t = Database.check t.db","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"  let get_root_transition t =","counters":[]},{"line":"    let open Result.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Database.get_root_hash t.db","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"    >>= Database.get_transition t.db","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"    |> Result.map_error ~f:Database.Error.message","counters":[]},{"line":"","counters":[]},{"line":"  let fast_forward t target_root :","counters":[]},{"line":"      (unit, [> `Failure of string | `Bootstrap_required ]) Result.t =","counters":[]},{"line":"    let open Root_identifier.Stable.Latest in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let open Result.Let_syntax in","counters":[]},{"line":"    let%bind () = assert_no_sync t in","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"    let lift_error r msg = Result.map_error r ~f:(Fn.const (`Failure msg)) in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"    let%bind root =","counters":[]},{"line":"      lift_error (Database.get_root t.db) \"failed to get root hash\"","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"    in","counters":[]},{"line":"    let root_hash = Root_data.Minimal.hash root in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    if State_hash.equal root_hash target_root.state_hash then","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (* If the target hash is already the root hash, no fast forward required, but we should check the frontier hash. *)","counters":[]},{"line":"      Ok ()","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    else (","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"      [%log' warn t.factory.logger]","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"        ~metadata:","counters":[]},{"line":"          [ (\"current_root\", State_hash.to_yojson root_hash)","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"          ; (\"target_root\", State_hash.to_yojson target_root.state_hash)","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"          ]","counters":[]},{"line":"        \"Cannot fast forward persistent frontier's root: bootstrap is required \\","counters":[]},{"line":"         ($current_root --> $target_root)\" ;","counters":[]},{"line":"      Error `Bootstrap_required )","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"  let load_full_frontier t ~context:(module Context : CONTEXT) ~root_ledger","counters":[]},{"line":"      ~consensus_local_state ~max_length ~ignore_consensus_local_state","counters":[]},{"line":"      ~persistent_root_instance =","counters":[]},{"line":"    let open Context in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let open Deferred.Result.Let_syntax in","counters":[]},{"line":"    let downgrade_transition transition genesis_state_hash :","counters":[]},{"line":"        ( Mina_block.almost_valid_block","counters":[]},{"line":"        , [ `Invalid_genesis_protocol_state ] )","counters":[]},{"line":"        Result.t =","counters":[]},{"line":"      (* we explicitly re-validate the genesis protocol state here to prevent X-version bugs *)","counters":[]},{"line":"      transition |> Mina_block.Validated.remember","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"      |> Validation.reset_staged_ledger_diff_validation","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"      |> Validation.reset_genesis_protocol_state_validation","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"      |> Validation.validate_genesis_protocol_state ~genesis_state_hash","counters":[]},{"line":"    in","counters":[]},{"line":"    let%bind () = Deferred.return (assert_no_sync t) in","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"    (* read basic information from the database *)","counters":[]},{"line":"    let%bind root, root_transition, best_tip, protocol_states, root_hash =","counters":[]},{"line":"      (let open Result.Let_syntax in","counters":[]},{"line":"      let%bind root = Database.get_root t.db in","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"      let root_hash = Root_data.Minimal.hash root in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%bind root_transition = Database.get_transition t.db root_hash in","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"      let%bind best_tip = Database.get_best_tip t.db in","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"      let%map protocol_states =","counters":[]},{"line":"        Database.get_protocol_states_for_root_scan_state t.db","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"      in","counters":[]},{"line":"      (root, root_transition, best_tip, protocol_states, root_hash))","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      |> Result.map_error ~f:(fun err ->","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"             `Failure (Database.Error.not_found_message err) )","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"      |> Deferred.return","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"    in","counters":[]},{"line":"    let root_genesis_state_hash =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      root_transition |> Mina_block.Validated.forget |> With_hash.data","counters":[{"col_start":51,"col_end":51,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"      |> Mina_block.header |> Mina_block.Header.protocol_state","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"      |> Protocol_state.genesis_state_hash","counters":[]},{"line":"    in","counters":[]},{"line":"    (* construct the root staged ledger in memory *)","counters":[]},{"line":"    let%bind root_staged_ledger =","counters":[]},{"line":"      let open Deferred.Let_syntax in","counters":[]},{"line":"      match%map","counters":[]},{"line":"        construct_staged_ledger_at_root ~precomputed_values ~root_ledger","counters":[]},{"line":"          ~root_transition ~root ~protocol_states ~logger:t.factory.logger","counters":[]},{"line":"      with","counters":[]},{"line":"      | Error err ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Error (`Failure (Error.to_string_hum err))","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"      | Ok staged_ledger ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Ok staged_ledger","counters":[]},{"line":"    in","counters":[]},{"line":"    (* initialize the new in memory frontier and extensions *)","counters":[]},{"line":"    let frontier =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Full_frontier.create","counters":[]},{"line":"        ~context:(module Context)","counters":[]},{"line":"        ~time_controller:t.factory.time_controller","counters":[]},{"line":"        ~root_data:","counters":[]},{"line":"          { transition = root_transition","counters":[]},{"line":"          ; staged_ledger = root_staged_ledger","counters":[]},{"line":"          ; protocol_states =","counters":[]},{"line":"              List.map protocol_states","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                ~f:(With_hash.of_data ~hash_data:Protocol_state.hashes)","counters":[]},{"line":"          }","counters":[]},{"line":"        ~root_ledger:","counters":[]},{"line":"          (Mina_ledger.Ledger.Any_ledger.cast_database_to_mask","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"             (module Mina_ledger.Ledger.Db)","counters":[]},{"line":"             root_ledger )","counters":[]},{"line":"        ~consensus_local_state ~max_length ~persistent_root_instance","counters":[]},{"line":"    in","counters":[]},{"line":"    let%bind extensions =","counters":[]},{"line":"      Deferred.map","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"        (Extensions.create ~logger:t.factory.logger frontier)","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"        ~f:Result.return","counters":[]},{"line":"    in","counters":[]},{"line":"    let apply_diff diff =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let (`New_root_and_diffs_with_mutants (_, diffs_with_mutants)) =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Full_frontier.apply_diffs frontier [ diff ] ~has_long_catchup_job:false","counters":[]},{"line":"          ~enable_epoch_ledger_sync:","counters":[]},{"line":"            ( if ignore_consensus_local_state then `Disabled","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"            else `Enabled root_ledger )","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"      in","counters":[]},{"line":"      Extensions.notify extensions ~frontier ~diffs_with_mutants","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"      |> Deferred.map ~f:Result.return","counters":[]},{"line":"    in","counters":[]},{"line":"    (* crawl through persistent frontier and load transitions into in memory frontier *)","counters":[]},{"line":"    let%bind () =","counters":[]},{"line":"      Deferred.map","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"        (Database.crawl_successors t.db root_hash","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"           ~init:(Full_frontier.root frontier) ~f:(fun parent transition ->","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"             let%bind transition =","counters":[]},{"line":"               match","counters":[]},{"line":"                 downgrade_transition transition root_genesis_state_hash","counters":[]},{"line":"               with","counters":[]},{"line":"               | Ok t ->","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                   Deferred.Result.return t","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"               | Error `Invalid_genesis_protocol_state ->","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                   Error (`Fatal_error (Invalid_genesis_state_hash transition))","counters":[]},{"line":"                   |> Deferred.return","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"             in","counters":[]},{"line":"             (* we're loading transitions from persistent storage,","counters":[]},{"line":"                don't assign a timestamp","counters":[]},{"line":"             *)","counters":[]},{"line":"             let transition_receipt_time = None in","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"             let%bind breadcrumb =","counters":[]},{"line":"               Breadcrumb.build ~skip_staged_ledger_verification:`All","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                 ~logger:t.factory.logger ~precomputed_values","counters":[]},{"line":"                 ~verifier:t.factory.verifier","counters":[]},{"line":"                 ~trust_system:(Trust_system.null ()) ~parent ~transition","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"                 ~sender:None ~transition_receipt_time ()","counters":[]},{"line":"             in","counters":[]},{"line":"             let%map () = apply_diff Diff.(E (New_node (Full breadcrumb))) in","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"             breadcrumb ) )","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"        ~f:","counters":[]},{"line":"          (Result.map_error ~f:(function","counters":[]},{"line":"            | `Crawl_error err ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                let msg =","counters":[]},{"line":"                  match err with","counters":[]},{"line":"                  | `Fatal_error exn ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      \"fatal error -- \" ^ Exn.to_string exn","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"                  | `Invalid_staged_ledger_diff err","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                  | `Invalid_staged_ledger_hash err ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      \"staged ledger diff application failed -- \"","counters":[]},{"line":"                      ^ Error.to_string_hum err","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"                in","counters":[]},{"line":"                `Failure","counters":[]},{"line":"                  ( \"error rebuilding transition frontier from persistence: \"","counters":[]},{"line":"                  ^ msg )","counters":[]},{"line":"            | `Not_found _ as err ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                `Failure (Database.Error.not_found_message err) ) )","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"    in","counters":[]},{"line":"    let%map () = apply_diff Diff.(E (Best_tip_changed best_tip)) in","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"    (frontier, extensions)","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"type t = Factory_type.t","counters":[]},{"line":"","counters":[]},{"line":"let create ~logger ~verifier ~time_controller ~directory =","counters":[]},{"line":"  { logger; verifier; time_controller; directory; instance = None }","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let destroy_database_exn t =","counters":[]},{"line":"  assert (Option.is_none t.instance) ;","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":9,"col_end":9,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"  File_system.remove_dir t.directory","counters":[]},{"line":"","counters":[]},{"line":"let create_instance_exn t =","counters":[]},{"line":"  assert (Option.is_none t.instance) ;","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":9,"col_end":9,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"  let instance = Instance.create t in","counters":[]},{"line":"  t.instance <- Some instance ;","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  instance","counters":[]},{"line":"","counters":[]},{"line":"let with_instance_exn t ~f =","counters":[]},{"line":"  let instance = create_instance_exn t in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let x = f instance in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%map () = Instance.destroy instance in","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"  x","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let reset_database_exn t ~root_data ~genesis_state_hash =","counters":[]},{"line":"  let open Root_data.Limited in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let open Deferred.Let_syntax in","counters":[]},{"line":"  let root_transition = transition root_data in","counters":[]},{"line":"  [%log' info t.logger]","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"    ~metadata:","counters":[]},{"line":"      [ ( \"state_hash\"","counters":[]},{"line":"        , State_hash.to_yojson","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"          @@ Mina_block.Validated.state_hash root_transition )","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"      ]","counters":[]},{"line":"    \"Resetting transition frontier database to new root\" ;","counters":[]},{"line":"  let%bind () = destroy_database_exn t in","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"  with_instance_exn t ~f:(fun instance ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      Database.initialize instance.db ~root_data ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      (* sanity check database after initialization on debug builds *)","counters":[]},{"line":"      Debug_assert.debug_assert (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          ignore","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ( Database.check instance.db ~genesis_state_hash","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"              |> Result.map_error ~f:(function","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                   | `Invalid_version ->","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                       \"invalid version\"","counters":[]},{"line":"                   | `Not_initialized ->","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                       \"not initialized\"","counters":[]},{"line":"                   | `Genesis_state_mismatch _ ->","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                       \"genesis state mismatch\"","counters":[]},{"line":"                   | `Corrupt err ->","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                       Database.Error.message err )","counters":[]},{"line":"              |> Result.ok_or_failwith","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"              : Frozen_ledger_hash.t ) ) )","counters":[{"col_start":41,"col_end":41,"count":2}]}]}