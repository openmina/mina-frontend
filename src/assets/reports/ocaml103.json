{"filename":"src/lib/snarky_taylor/snarky_taylor.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Snarky_integer","counters":[]},{"line":"open Util","counters":[]},{"line":"module Floating_point = Floating_point","counters":[]},{"line":"","counters":[]},{"line":"(*","counters":[]},{"line":"    Given","counters":[]},{"line":"    p / q = 0.b1 b2 b3 ...","counters":[]},{"line":"","counters":[]},{"line":"    2^k p / q = b1 b2 b3 bk . b_{k+1} ...","counters":[]},{"line":"  *)","counters":[]},{"line":"let bignum_as_fixed_point k x =","counters":[]},{"line":"  let p, q = Bignum.(num_as_bigint x, den_as_bigint x) in","counters":[{"col_start":2,"col_end":2,"count":11},{"col_start":33,"col_end":33,"count":11},{"col_start":50,"col_end":50,"count":11}]},{"line":"  B.(shift_left p k / q)","counters":[{"col_start":14,"col_end":14,"count":11}]},{"line":"","counters":[]},{"line":"let least ~such_that =","counters":[]},{"line":"  let rec go i = if such_that i then i else go (i + 1) in","counters":[{"col_start":2,"col_end":2,"count":36},{"col_start":17,"col_end":17,"count":228},{"col_start":37,"col_end":37,"count":36},{"col_start":44,"col_end":44,"count":192}]},{"line":"  go 0","counters":[]},{"line":"","counters":[]},{"line":"let greatest ~such_that =","counters":[]},{"line":"  let rec go best i =","counters":[{"col_start":2,"col_end":2,"count":1}]},{"line":"    match such_that i with","counters":[{"col_start":4,"col_end":4,"count":18}]},{"line":"    | Some acc ->","counters":[{"col_start":6,"col_end":6,"count":17}]},{"line":"        go (Some acc) (i + 1)","counters":[]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":1}]},{"line":"        Option.value_exn best","counters":[]},{"line":"  in","counters":[]},{"line":"  go None 0","counters":[]},{"line":"","counters":[]},{"line":"let factorial n =","counters":[]},{"line":"  let rec go acc i =","counters":[{"col_start":2,"col_end":2,"count":159}]},{"line":"    if B.(equal zero i) then acc else go B.(i * acc) B.(i - one)","counters":[{"col_start":4,"col_end":4,"count":808},{"col_start":14,"col_end":14,"count":808},{"col_start":29,"col_end":29,"count":159},{"col_start":38,"col_end":38,"count":649}]},{"line":"  in","counters":[]},{"line":"  go B.one n","counters":[]},{"line":"","counters":[]},{"line":"(* Computes log using the taylor expansion around 1","counters":[]},{"line":"","counters":[]},{"line":"   (x - 1) - (x - 1)^2 / 2 + (x - 1)^3 / 3 - ...","counters":[]},{"line":"","counters":[]},{"line":"   Only works for 0 < x < 2.","counters":[]},{"line":"*)","counters":[]},{"line":"let log ~terms x =","counters":[]},{"line":"  let open Bignum in","counters":[{"col_start":2,"col_end":2,"count":1}]},{"line":"  let a = x - one in","counters":[]},{"line":"  let open Sequence in","counters":[]},{"line":"  unfold ~init:(a, 1) ~f:(fun (ai, i) ->","counters":[]},{"line":"      let t = ai / of_int i in","counters":[{"col_start":6,"col_end":6,"count":100},{"col_start":24,"col_end":24,"count":100}]},{"line":"      Some ((if Int.(i mod 2 = 0) then neg t else t), (ai * a, Int.(i + 1))) )","counters":[{"col_start":39,"col_end":39,"count":50},{"col_start":41,"col_end":41,"count":50},{"col_start":50,"col_end":50,"count":50}]},{"line":"  |> Fn.flip take terms |> fold ~init:zero ~f:( + )","counters":[{"col_start":11,"col_end":11,"count":1}]},{"line":"","counters":[]},{"line":"(* This computes the number of terms of a taylor series one needs to compute","counters":[]},{"line":"   if the output is to be within 1/2^k of the actual value.","counters":[]},{"line":"   It requires one give an upper bound on the absolute value of the","counters":[]},{"line":"   derivatives of the function *)","counters":[]},{"line":"let terms_needed ~derivative_magnitude_upper_bound ~bits_of_precision:k =","counters":[]},{"line":"  (*","counters":[]},{"line":"      We want the least n such that","counters":[]},{"line":"","counters":[]},{"line":"      (n + 1)! / sup |f^(n+1)(x)|  > 2^k","counters":[]},{"line":"  *)","counters":[]},{"line":"  let lower_bound = Bignum.of_bigint B.(pow (of_int 2) k) in","counters":[{"col_start":2,"col_end":2,"count":18},{"col_start":42,"col_end":42,"count":18},{"col_start":50,"col_end":50,"count":18}]},{"line":"  least ~such_that:(fun n ->","counters":[{"col_start":2,"col_end":2,"count":18}]},{"line":"      let nn = B.of_int n in","counters":[{"col_start":6,"col_end":6,"count":148}]},{"line":"      let d = derivative_magnitude_upper_bound Int.(n + 1) in","counters":[{"col_start":6,"col_end":6,"count":148}]},{"line":"      Bignum.(of_bigint (factorial nn) / d > lower_bound) )","counters":[{"col_start":6,"col_end":6,"count":148},{"col_start":22,"col_end":22,"count":148},{"col_start":33,"col_end":33,"count":148}]},{"line":"","counters":[]},{"line":"let ceil_log2 n = least ~such_that:(fun i -> B.(pow (of_int 2) (of_int i) >= n))","counters":[{"col_start":18,"col_end":18,"count":18},{"col_start":45,"col_end":45,"count":80},{"col_start":50,"col_end":50,"count":80},{"col_start":58,"col_end":58,"count":80},{"col_start":69,"col_end":69,"count":80}]},{"line":"","counters":[]},{"line":"let binary_expansion x =","counters":[]},{"line":"  assert (Bignum.(x < one)) ;","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":9,"col_end":9,"count":0}]},{"line":"  let two = Bignum.of_int 2 in","counters":[]},{"line":"  Sequence.unfold","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    ~init:(x, Bignum.(one / two))","counters":[]},{"line":"    ~f:(fun (rem, pt) ->","counters":[]},{"line":"      let b = Bignum.(rem >= pt) in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let rem = if b then Bignum.(rem - pt) else rem in","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"      Some (b, Bignum.(rem, pt / two)) )","counters":[]},{"line":"","counters":[]},{"line":"module Coeff_integer_part = struct","counters":[]},{"line":"  type t = [ `Zero | `One ] [@@deriving sexp]","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":11,"col_end":11,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"  let of_int_exn : int -> t = function","counters":[]},{"line":"    | 0 ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        `Zero","counters":[]},{"line":"    | 1 ->","counters":[{"col_start":6,"col_end":6,"count":1}]},{"line":"        `One","counters":[]},{"line":"    | _ ->","counters":[]},{"line":"        assert false","counters":[]},{"line":"","counters":[]},{"line":"  let to_int = function `Zero -> 0 | `One -> 1","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Params = struct","counters":[]},{"line":"  type t =","counters":[]},{"line":"    { total_precision : int","counters":[]},{"line":"    ; per_term_precision : int","counters":[]},{"line":"    ; terms_needed : int","counters":[]},{"line":"          (* As a special case, we permite the x^1 coefficient to have absolute value < 2 (rather than < 1) *)","counters":[]},{"line":"    ; linear_term_integer_part : Coeff_integer_part.t","counters":[]},{"line":"    ; coefficients : ([ `Neg | `Pos ] * B.t) array","counters":[]},{"line":"    }","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(* This module constructs a snarky function for computing the function","counters":[]},{"line":"","counters":[]},{"line":"   x -> base^x","counters":[]},{"line":"","counters":[]},{"line":"   where x is in the interval [0, 1)","counters":[]},{"line":"*)","counters":[]},{"line":"module Exp = struct","counters":[]},{"line":"  (* An upper bound on the magnitude nth derivative of base^x in [0, 1) is","counters":[]},{"line":"     |log(base)|^n *)","counters":[]},{"line":"","counters":[]},{"line":"  let derivative_magnitude_upper_bound n ~log_base = Bignum.(log_base ** n)","counters":[{"col_start":53,"col_end":53,"count":148}]},{"line":"","counters":[]},{"line":"  let terms_needed ~log_base ~bits_of_precision =","counters":[]},{"line":"    terms_needed","counters":[{"col_start":4,"col_end":4,"count":18}]},{"line":"      ~derivative_magnitude_upper_bound:","counters":[]},{"line":"        (derivative_magnitude_upper_bound ~log_base)","counters":[]},{"line":"      ~bits_of_precision","counters":[]},{"line":"","counters":[]},{"line":"  type bit_params =","counters":[]},{"line":"    { total_precision : int; terms_needed : int; per_term_precision : int }","counters":[]},{"line":"","counters":[]},{"line":"  (* This figures out how many bits we can hope to calculate given our field","counters":[]},{"line":"     size. This is because computing the terms","counters":[]},{"line":"","counters":[]},{"line":"     x^k","counters":[]},{"line":"","counters":[]},{"line":"     in the taylor series will start to overflow when k is too large. E.g.,","counters":[]},{"line":"     if our field has 298 bits and x has 32 bits, then we cannot easily compute","counters":[]},{"line":"     x^10, since representing it exactly requires 320 bits. *)","counters":[]},{"line":"  let bit_params ~field_size_in_bits ~log_base =","counters":[]},{"line":"    let using_linear_term_whole_part = true in","counters":[{"col_start":4,"col_end":4,"count":1}]},{"line":"    greatest ~such_that:(fun k ->","counters":[]},{"line":"        let kk = B.of_int k in","counters":[{"col_start":8,"col_end":8,"count":18}]},{"line":"        let n = terms_needed ~log_base ~bits_of_precision:kk in","counters":[{"col_start":8,"col_end":8,"count":18}]},{"line":"        let n =","counters":[]},{"line":"          (* To account for our use of the linear term whole part. *)","counters":[]},{"line":"          if using_linear_term_whole_part then n + 1 else n","counters":[{"col_start":47,"col_end":47,"count":18},{"col_start":58,"col_end":58,"count":0}]},{"line":"        in","counters":[]},{"line":"        let per_term_precision = ceil_log2 (B.of_int n) + k in","counters":[{"col_start":41,"col_end":41,"count":18},{"col_start":51,"col_end":51,"count":18}]},{"line":"        if (n * per_term_precision) + per_term_precision < field_size_in_bits","counters":[]},{"line":"        then Some { per_term_precision; terms_needed = n; total_precision = k }","counters":[{"col_start":13,"col_end":13,"count":17}]},{"line":"        else None )","counters":[{"col_start":13,"col_end":13,"count":1}]},{"line":"","counters":[]},{"line":"  let params ~field_size_in_bits ~base =","counters":[]},{"line":"    let abs_log_base =","counters":[{"col_start":4,"col_end":4,"count":1}]},{"line":"      let log_base = log base ~terms:100 in","counters":[]},{"line":"      assert (Bignum.(log_base < zero)) ;","counters":[{"col_start":6,"col_end":6,"count":1},{"col_start":13,"col_end":13,"count":1}]},{"line":"      Bignum.abs log_base","counters":[{"col_start":15,"col_end":15,"count":1}]},{"line":"    in","counters":[]},{"line":"    let { total_precision; terms_needed; per_term_precision } =","counters":[]},{"line":"      bit_params ~field_size_in_bits ~log_base:abs_log_base","counters":[]},{"line":"    in","counters":[]},{"line":"","counters":[]},{"line":"    (* Precompute the coefficeints","counters":[]},{"line":"","counters":[]},{"line":"       log(base)^i / i !","counters":[]},{"line":"","counters":[]},{"line":"       as fixed point numbers.","counters":[]},{"line":"    *)","counters":[]},{"line":"    let coefficients, linear_term_integer_part =","counters":[]},{"line":"      let linear_term_integer_part = ref `Zero in","counters":[]},{"line":"      let coefficients =","counters":[]},{"line":"        Array.init terms_needed ~f:(fun i ->","counters":[]},{"line":"            (* Starts from 1 *)","counters":[]},{"line":"            let i = i + 1 in","counters":[{"col_start":12,"col_end":12,"count":11}]},{"line":"            let c =","counters":[]},{"line":"              Bignum.((abs_log_base ** i) / of_bigint (factorial (B.of_int i)))","counters":[{"col_start":37,"col_end":37,"count":11},{"col_start":52,"col_end":52,"count":11},{"col_start":63,"col_end":63,"count":11},{"col_start":73,"col_end":73,"count":11}]},{"line":"            in","counters":[]},{"line":"            let c_frac =","counters":[]},{"line":"              if i = 1 then (","counters":[{"col_start":28,"col_end":28,"count":1}]},{"line":"                let c_whole = Bignum.round_as_bigint_exn ~dir:`Down c in","counters":[]},{"line":"                let c_frac = Bignum.(c - of_bigint c_whole) in","counters":[{"col_start":16,"col_end":16,"count":1},{"col_start":49,"col_end":49,"count":1}]},{"line":"                linear_term_integer_part :=","counters":[]},{"line":"                  Coeff_integer_part.of_int_exn (Bigint.to_int_exn c_whole) ;","counters":[{"col_start":46,"col_end":46,"count":1},{"col_start":65,"col_end":65,"count":1}]},{"line":"                c_frac )","counters":[]},{"line":"              else (","counters":[{"col_start":19,"col_end":19,"count":10}]},{"line":"                assert (Bignum.(c < one)) ;","counters":[{"col_start":23,"col_end":23,"count":10}]},{"line":"                c )","counters":[]},{"line":"            in","counters":[]},{"line":"            ( (if i mod 2 = 0 then `Neg else `Pos)","counters":[{"col_start":35,"col_end":35,"count":5},{"col_start":45,"col_end":45,"count":6}]},{"line":"            , c_frac |> bignum_as_fixed_point per_term_precision ) )","counters":[{"col_start":44,"col_end":44,"count":11}]},{"line":"      in","counters":[]},{"line":"      (coefficients, !linear_term_integer_part)","counters":[{"col_start":6,"col_end":6,"count":1}]},{"line":"    in","counters":[]},{"line":"    { Params.total_precision","counters":[]},{"line":"    ; terms_needed","counters":[]},{"line":"    ; per_term_precision","counters":[]},{"line":"    ; coefficients","counters":[]},{"line":"    ; linear_term_integer_part","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  module Unchecked = struct","counters":[]},{"line":"    let one_minus_exp (params : Params.t) x =","counters":[]},{"line":"      let denom =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Bignum.(of_bigint B.(shift_left one params.per_term_precision))","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"      in","counters":[]},{"line":"      Array.fold params.coefficients ~init:(Bignum.zero, Bignum.one)","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"        ~f:(fun (acc, x_i) (sgn, c) ->","counters":[]},{"line":"          let x_i = Bignum.(x_i * x) in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let c = Bignum.(of_bigint c / denom) in","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"          let c = match sgn with `Pos -> c | `Neg -> Bignum.neg c in","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"          (Bignum.(acc + (x_i * c)), x_i) )","counters":[]},{"line":"      |> fst","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"      |> fun acc ->","counters":[]},{"line":"      Bignum.(","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        acc","counters":[]},{"line":"        + x","counters":[]},{"line":"          * of_int (Coeff_integer_part.to_int params.linear_term_integer_part))","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  (* Zip together coefficients and powers of x and sum *)","counters":[]},{"line":"  let taylor_sum ~m x_powers coefficients linear_term_integer_part =","counters":[]},{"line":"    let acc =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Array.fold2_exn coefficients x_powers ~init:None","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"        ~f:(fun sum (sgn, ci) xi ->","counters":[]},{"line":"          let term = Floating_point.(mul ~m ci xi) in","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"          match sum with","counters":[]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              assert ([%equal: [ `Pos | `Neg ]] sgn `Pos) ;","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"              Some term","counters":[]},{"line":"          | Some s ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Some (Floating_point.add_signed ~m s (sgn, term)) )","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"      |> Option.value_exn","counters":[]},{"line":"    in","counters":[]},{"line":"    match linear_term_integer_part with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | `Zero ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        acc","counters":[]},{"line":"    | `One ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Floating_point.add ~m acc x_powers.(0)","counters":[]},{"line":"","counters":[]},{"line":"  let one_minus_exp ~m","counters":[]},{"line":"      { Params.total_precision = _","counters":[]},{"line":"      ; terms_needed","counters":[]},{"line":"      ; per_term_precision","counters":[]},{"line":"      ; linear_term_integer_part","counters":[]},{"line":"      ; coefficients","counters":[]},{"line":"      } x =","counters":[]},{"line":"    let powers = Floating_point.powers ~m x terms_needed in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let coefficients =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Array.map coefficients ~f:(fun (sgn, c) ->","counters":[]},{"line":"          ( sgn","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          , Floating_point.constant ~m ~value:c ~precision:per_term_precision ) )","counters":[]},{"line":"    in","counters":[]},{"line":"    taylor_sum ~m powers coefficients linear_term_integer_part","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}