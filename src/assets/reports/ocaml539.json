{"filename":"src/lib/mina_numbers/nat.ml","lines":[{"line":"[%%import \"/src/config.mlh\"]","counters":[]},{"line":"","counters":[{"col_start":0,"col_end":0,"count":1}]},{"line":"open Core_kernel","counters":[]},{"line":"open Fold_lib","counters":[]},{"line":"include Intf","counters":[]},{"line":"module Intf = Intf","counters":[]},{"line":"open Snark_bits","counters":[]},{"line":"","counters":[]},{"line":"[%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"module Make_checked","counters":[]},{"line":"    (N : Unsigned_extended.S)","counters":[]},{"line":"    (Bits : Bits_intf.Convertible_bits with type t := N.t) =","counters":[]},{"line":"struct","counters":[]},{"line":"  open Snark_params.Tick","counters":[]},{"line":"","counters":[]},{"line":"  type var = Field.Var.t","counters":[]},{"line":"","counters":[]},{"line":"  let () = assert (Int.(N.length_in_bits < Field.size_in_bits))","counters":[{"col_start":18,"col_end":18,"count":15}]},{"line":"","counters":[]},{"line":"  let to_input (t : var) =","counters":[]},{"line":"    Random_oracle.Input.Chunked.packed (t, N.length_in_bits)","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let to_input_legacy (t : var) =","counters":[]},{"line":"    let to_bits (t : var) =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      with_label (sprintf \"to_bits: %s\" __LOC__) (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"          Field.Checked.choose_preimage_var t ~length:N.length_in_bits )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    in","counters":[]},{"line":"    Checked.map (to_bits t) ~f:(fun bits ->","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"        Random_oracle.Input.Legacy.bitstring bits )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"  let constant n =","counters":[]},{"line":"    Field.Var.constant","counters":[{"col_start":4,"col_end":4,"count":2}]},{"line":"      (Bigint.to_field (Bigint.of_bignum_bigint (N.to_bigint n)))","counters":[{"col_start":21,"col_end":21,"count":2},{"col_start":46,"col_end":46,"count":2},{"col_start":59,"col_end":59,"count":2}]},{"line":"","counters":[]},{"line":"  let () = assert (Int.(N.length_in_bits mod 16 = 0))","counters":[{"col_start":18,"col_end":18,"count":15}]},{"line":"","counters":[]},{"line":"  let range_check' (t : var) =","counters":[]},{"line":"    let _, _, actual_packed =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Pickles.Scalar_challenge.to_field_checked' ~num_bits:N.length_in_bits m","counters":[]},{"line":"        (Kimchi_backend_common.Scalar_challenge.create t)","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"    in","counters":[]},{"line":"    actual_packed","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let range_check t =","counters":[]},{"line":"    let%bind actual = make_checked (fun () -> range_check' t) in","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"    Field.Checked.Assert.equal actual t","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let range_check_flag t =","counters":[]},{"line":"    let open Pickles.Impls.Step in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let actual = range_check' t in","counters":[]},{"line":"    Field.equal actual t","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let of_field (x : Field.t) : N.t =","counters":[]},{"line":"    let of_bits bs =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (* TODO: Make this efficient *)","counters":[]},{"line":"      List.foldi bs ~init:N.zero ~f:(fun i acc b ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          if b then N.(logor (shift_left one i) acc) else acc )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"    in","counters":[]},{"line":"    of_bits (List.take (Field.unpack x) N.length_in_bits)","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"  let to_field (x : N.t) : Field.t = Field.project (Fold.to_list (Bits.fold x))","counters":[{"col_start":37,"col_end":37,"count":0},{"col_start":63,"col_end":63,"count":0},{"col_start":74,"col_end":74,"count":0}]},{"line":"","counters":[]},{"line":"  let typ : (var, N.t) Typ.t =","counters":[]},{"line":"    let (Typ field_typ) = Field.typ in","counters":[]},{"line":"    Typ.transport","counters":[{"col_start":16,"col_end":16,"count":15}]},{"line":"      (Typ","counters":[]},{"line":"         { field_typ with check = (fun x -> make_checked_ast @@ range_check x) }","counters":[{"col_start":44,"col_end":44,"count":0},{"col_start":74,"col_end":74,"count":0}]},{"line":"      )","counters":[]},{"line":"      ~there:to_field ~back:of_field","counters":[]},{"line":"","counters":[]},{"line":"  let () = assert (N.length_in_bits * 2 < Field.size_in_bits + 1)","counters":[{"col_start":18,"col_end":18,"count":15}]},{"line":"","counters":[]},{"line":"  let div_mod (x : var) (y : var) =","counters":[]},{"line":"    let%bind q, r =","counters":[]},{"line":"      exists (Typ.tuple2 typ typ)","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"        ~compute:","counters":[]},{"line":"          As_prover.(","counters":[]},{"line":"            let%map x = read typ x and y = read typ y in","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"            (N.div x y, N.rem x y))","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"    in","counters":[]},{"line":"","counters":[]},{"line":"    (* q * y + r = x","counters":[]},{"line":"","counters":[]},{"line":"       q * y = x - r","counters":[]},{"line":"    *)","counters":[]},{"line":"    let%map () = assert_r1cs q y (Field.Var.sub x r) in","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"    (q, r)","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  type t = var","counters":[]},{"line":"","counters":[]},{"line":"  let is_succ ~pred ~succ =","counters":[]},{"line":"    let open Snark_params.Tick in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let open Field in","counters":[]},{"line":"    Checked.(equal (pred + Var.constant one) succ)","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"","counters":[]},{"line":"  let gte x y =","counters":[]},{"line":"    let open Pickles.Impls.Step in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let xy = Pickles.Util.seal m Field.(x - y) in","counters":[]},{"line":"    let yx = Pickles.Util.seal m (Field.negate xy) in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"    let x_gte_y = range_check_flag xy in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let y_gte_x = range_check_flag yx in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Boolean.Assert.any [ x_gte_y; y_gte_x ] ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    x_gte_y","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let op op a b = make_checked (fun () -> op a b)","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"","counters":[]},{"line":"  let ( >= ) a b = op gte a b","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"","counters":[]},{"line":"  let ( <= ) a b = b >= a","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"","counters":[]},{"line":"  let ( < ) a b =","counters":[]},{"line":"    make_checked (fun () ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        let open Pickles.Impls.Step in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Boolean.( &&& ) (gte b a) (Boolean.not (Field.equal b a)) )","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"","counters":[]},{"line":"  let ( > ) a b = b < a","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"","counters":[]},{"line":"  module Assert = struct","counters":[]},{"line":"    let equal = Field.Checked.Assert.equal","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let to_field = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"  module Unsafe = struct","counters":[]},{"line":"    let of_field = Fn.id","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let min a b =","counters":[]},{"line":"    let%bind a_lte_b = a <= b in","counters":[]},{"line":"    Field.Checked.if_ a_lte_b ~then_:a ~else_:b","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let if_ = Field.Checked.if_","counters":[]},{"line":"","counters":[]},{"line":"  let succ_if (t : var) (c : Boolean.var) =","counters":[]},{"line":"    Checked.return (Field.Var.add t (c :> Field.Var.t))","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"","counters":[]},{"line":"  let succ (t : var) =","counters":[]},{"line":"    Checked.return (Field.Var.add t (Field.Var.constant Field.one))","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"","counters":[]},{"line":"  let seal x = make_checked (fun () -> Pickles.Util.seal m x)","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"  let add (x : var) (y : var) =","counters":[]},{"line":"    let%bind res = seal (Field.Var.add x y) in","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"    let%map () = range_check res in","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"    res","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let mul (x : var) (y : var) =","counters":[]},{"line":"    let%bind res = Field.Checked.mul x y in","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"    let%map () = range_check res in","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"    res","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let subtract_unpacking_or_zero x y =","counters":[]},{"line":"    let open Pickles.Impls.Step in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let res = Pickles.Util.seal m Field.(x - y) in","counters":[]},{"line":"    let neg_res = Pickles.Util.seal m (Field.negate res) in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"    let x_gte_y = range_check_flag res in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let y_gte_x = range_check_flag neg_res in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Boolean.Assert.any [ x_gte_y; y_gte_x ] ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    (* If y_gte_x is false, then x_gte_y is true, so x >= y and","counters":[]},{"line":"       thus there was no underflow.","counters":[]},{"line":"","counters":[]},{"line":"       If y_gte_x is true, then y >= x, which means there was underflow","counters":[]},{"line":"       iff y != x.","counters":[]},{"line":"","counters":[]},{"line":"       Thus, underflow = (neg_res_good && y != x)","counters":[]},{"line":"    *)","counters":[]},{"line":"    let underflow = Boolean.( &&& ) y_gte_x (Boolean.not (Field.equal x y)) in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":55,"col_end":55,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"    (`Underflow underflow, Field.if_ underflow ~then_:Field.zero ~else_:res)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"  let sub_or_zero a b = make_checked (fun () -> subtract_unpacking_or_zero a b)","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"","counters":[]},{"line":"  (* Unpacking protects against underflow *)","counters":[]},{"line":"  let sub (x : var) (y : var) =","counters":[]},{"line":"    let%bind res = seal (Field.Var.sub x y) in","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"    let%map () = range_check res in","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"    res","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let equal a b = Field.Checked.equal a b","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"","counters":[]},{"line":"  let ( = ) = equal","counters":[]},{"line":"","counters":[]},{"line":"  let zero = Field.Var.constant Field.zero","counters":[{"col_start":30,"col_end":30,"count":15}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"[%%endif]","counters":[]},{"line":"","counters":[]},{"line":"open Snark_params.Tick","counters":[]},{"line":"","counters":[]},{"line":"module Make (N : sig","counters":[]},{"line":"  type t [@@deriving sexp, compare, hash]","counters":[]},{"line":"","counters":[]},{"line":"  include Unsigned_extended.S with type t := t","counters":[]},{"line":"","counters":[]},{"line":"  val random : unit -> t","counters":[]},{"line":"end)","counters":[]},{"line":"(Bits : Bits_intf.Convertible_bits with type t := N.t) =","counters":[]},{"line":"struct","counters":[]},{"line":"  type t = N.t [@@deriving sexp, compare, hash, yojson]","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":11,"col_end":11,"count":0}]},{"line":"","counters":[]},{"line":"  (* can't be automatically derived *)","counters":[]},{"line":"  let dhall_type = Ppx_dhall_type.Dhall_type.Text","counters":[]},{"line":"","counters":[]},{"line":"  let max_value = N.max_int","counters":[]},{"line":"","counters":[]},{"line":"  include Comparable.Make (N)","counters":[]},{"line":"","counters":[]},{"line":"  include (N : module type of N with type t := t)","counters":[]},{"line":"","counters":[]},{"line":"  let sub x y = if x < y then None else Some (N.sub x y)","counters":[{"col_start":16,"col_end":16,"count":2},{"col_start":30,"col_end":30,"count":0},{"col_start":40,"col_end":40,"count":2},{"col_start":50,"col_end":50,"count":2}]},{"line":"","counters":[]},{"line":"  [%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"  module Checked = Make_checked (N) (Bits)","counters":[]},{"line":"","counters":[]},{"line":"  (* warning: this typ does not work correctly with the generic if_ *)","counters":[]},{"line":"  let typ = Checked.typ","counters":[]},{"line":"","counters":[]},{"line":"  [%%endif]","counters":[]},{"line":"","counters":[]},{"line":"  module Bits = Bits","counters":[]},{"line":"","counters":[]},{"line":"  let to_bits = Bits.to_bits","counters":[]},{"line":"","counters":[]},{"line":"  let of_bits = Bits.of_bits","counters":[]},{"line":"","counters":[]},{"line":"  let to_input (t : t) =","counters":[]},{"line":"    Random_oracle.Input.Chunked.packed","counters":[{"col_start":4,"col_end":4,"count":105}]},{"line":"      (Field.project (to_bits t), N.length_in_bits)","counters":[{"col_start":19,"col_end":19,"count":105},{"col_start":28,"col_end":28,"count":105}]},{"line":"","counters":[]},{"line":"  let to_input_legacy t = Random_oracle.Input.Legacy.bitstring (to_bits t)","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":70,"col_end":70,"count":0}]},{"line":"","counters":[]},{"line":"  let fold t = Fold.group3 ~default:false (Bits.fold t)","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"","counters":[]},{"line":"  let gen =","counters":[]},{"line":"    Quickcheck.Generator.map","counters":[{"col_start":27,"col_end":27,"count":11}]},{"line":"      ~f:(fun n -> N.of_string (Bignum_bigint.to_string n))","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"      (Bignum_bigint.gen_incl Bignum_bigint.zero","counters":[{"col_start":28,"col_end":28,"count":11}]},{"line":"         (Bignum_bigint.of_string N.(to_string max_int)) )","counters":[{"col_start":32,"col_end":32,"count":11},{"col_start":45,"col_end":45,"count":11}]},{"line":"","counters":[]},{"line":"  let gen_incl min max =","counters":[]},{"line":"    let open Quickcheck.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let%map n =","counters":[]},{"line":"      Bignum_bigint.gen_incl","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"        (Bignum_bigint.of_string (N.to_string min))","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"        (Bignum_bigint.of_string (N.to_string max))","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"    in","counters":[]},{"line":"    N.of_string (Bignum_bigint.to_string n)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make32 () : UInt32 = struct","counters":[]},{"line":"  open Unsigned_extended","counters":[]},{"line":"","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"    [@@@no_toplevel_latest_type]","counters":[]},{"line":"","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      [@@@with_all_version_tags]","counters":[]},{"line":"","counters":[]},{"line":"      type t = UInt32.Stable.V1.t","counters":[{"col_start":6,"col_end":6,"count":40},{"col_start":11,"col_end":11,"count":20},{"col_start":15,"col_end":15,"count":0}]},{"line":"      [@@deriving sexp, equal, compare, hash, yojson]","counters":[{"col_start":52,"col_end":52,"count":150}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  include","counters":[]},{"line":"    Make","counters":[]},{"line":"      (struct","counters":[]},{"line":"        include UInt32","counters":[]},{"line":"","counters":[]},{"line":"        let random () =","counters":[]},{"line":"          let mask = if Random.bool () then one else zero in","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"          let open UInt32.Infix in","counters":[]},{"line":"          logor (mask lsl 31)","counters":[]},{"line":"            ( Int32.max_value |> Random.int32 |> Int64.of_int32","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"            |> UInt32.of_int64 )","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"      end)","counters":[]},{"line":"      (Bits.UInt32)","counters":[]},{"line":"","counters":[]},{"line":"  let to_uint32 = Unsigned_extended.UInt32.to_uint32","counters":[]},{"line":"","counters":[]},{"line":"  let of_uint32 = Unsigned_extended.UInt32.of_uint32","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make64 () : UInt64 = struct","counters":[]},{"line":"  open Unsigned_extended","counters":[]},{"line":"","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"    [@@@no_toplevel_latest_type]","counters":[]},{"line":"","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      [@@@with_all_version_tags]","counters":[]},{"line":"","counters":[]},{"line":"      type t = UInt64.Stable.V1.t","counters":[{"col_start":6,"col_end":6,"count":4},{"col_start":11,"col_end":11,"count":2},{"col_start":15,"col_end":15,"count":0}]},{"line":"      [@@deriving sexp, equal, compare, hash, yojson]","counters":[{"col_start":52,"col_end":52,"count":15}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  include","counters":[]},{"line":"    Make","counters":[]},{"line":"      (struct","counters":[]},{"line":"        include UInt64","counters":[]},{"line":"","counters":[]},{"line":"        let random () =","counters":[]},{"line":"          let mask = if Random.bool () then one else zero in","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"          let open UInt64.Infix in","counters":[]},{"line":"          logor (mask lsl 63)","counters":[]},{"line":"            (Int64.max_value |> Random.int64 |> UInt64.of_int64)","counters":[{"col_start":48,"col_end":48,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"      end)","counters":[]},{"line":"      (Bits.UInt64)","counters":[]},{"line":"","counters":[]},{"line":"  let to_uint64 = Unsigned_extended.UInt64.to_uint64","counters":[]},{"line":"","counters":[]},{"line":"  let of_uint64 = Unsigned_extended.UInt64.of_uint64","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":1}]}]}