{"filename":"src/lib/network_pool/f_sequence.ml","lines":[{"line":"open Core","counters":[]},{"line":"","counters":[]},{"line":"(** A digit is a container of 1-4 elements. *)","counters":[]},{"line":"module Digit = struct","counters":[]},{"line":"  (* We use GADTs to track whether it's valid to remove/add an element to a","counters":[]},{"line":"     digit, which gets us type safe (un)cons and (un)snoc. *)","counters":[]},{"line":"","counters":[]},{"line":"  [@@@warning \"-37\"]","counters":[]},{"line":"","counters":[]},{"line":"  type addable = Type_addable","counters":[]},{"line":"","counters":[]},{"line":"  type not_addable = Type_not_addable","counters":[]},{"line":"","counters":[]},{"line":"  type removable = Type_removable","counters":[]},{"line":"","counters":[]},{"line":"  type not_removable = Type_not_removable","counters":[]},{"line":"","counters":[]},{"line":"  [@@@warning \"+37\"]","counters":[]},{"line":"","counters":[]},{"line":"  type (_, _, 'e) t =","counters":[]},{"line":"    | One : 'e -> (addable, not_removable, 'e) t","counters":[]},{"line":"    | Two : 'e * 'e -> (addable, removable, 'e) t","counters":[]},{"line":"    | Three : 'e * 'e * 'e -> (addable, removable, 'e) t","counters":[]},{"line":"    | Four : 'e * 'e * 'e * 'e -> (not_addable, removable, 'e) t","counters":[]},{"line":"","counters":[]},{"line":"  (* Can't derive compare on GADTs, instead we provide an explicit instance. *)","counters":[]},{"line":"  let compare (type add_x rem_x add_y rem_y) cmp_e (x : (add_x, rem_x, 'e) t)","counters":[]},{"line":"      (y : (add_y, rem_y, 'e) t) =","counters":[]},{"line":"    let fallthrough ~f = function 0 -> f () | n -> n in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"    match (x, y) with","counters":[]},{"line":"    | One x, One y ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        cmp_e x y","counters":[]},{"line":"    | One _, _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        -1","counters":[]},{"line":"    | _, One _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        1","counters":[]},{"line":"    | Two (x1, x2), Two (y1, y2) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        fallthrough (cmp_e x1 y1) ~f:(fun () -> cmp_e x2 y2)","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"    | Two _, _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        -1","counters":[]},{"line":"    | _, Two _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        1","counters":[]},{"line":"    | Three (x1, x2, x3), Three (y1, y2, y3) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        fallthrough (cmp_e x1 y1) ~f:(fun () ->","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"            fallthrough (cmp_e x2 y2) ~f:(fun () -> cmp_e x3 y3) )","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"    | Three _, _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        -1","counters":[]},{"line":"    | _, Three _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        1","counters":[]},{"line":"    | Four (x1, x2, x3, x4), Four (y1, y2, y3, y4) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        fallthrough (cmp_e x1 y1) ~f:(fun () ->","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"            fallthrough (cmp_e x2 y2) ~f:(fun () ->","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"                fallthrough (cmp_e x3 y3) ~f:(fun () -> cmp_e x4 y4) ) )","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"    | Four _, _ ->","counters":[]},{"line":"        .","counters":[]},{"line":"    | _, Four _ ->","counters":[]},{"line":"        .","counters":[]},{"line":"","counters":[]},{"line":"  (* \"Eliminators\" dispatching on addability/removability. You could achieve","counters":[]},{"line":"      the same effect more directly using or-patterns, but the code that","counters":[]},{"line":"      makes the typechecker understand existentials under or-patterns isn't","counters":[]},{"line":"      in our compiler version. (ocaml/ocaml#2110)","counters":[]},{"line":"  *)","counters":[]},{"line":"  let addable_elim :","counters":[]},{"line":"      type a r.","counters":[]},{"line":"         ((addable, r, 'e) t -> 'o) (** Function handling addable case *)","counters":[]},{"line":"      -> ((not_addable, removable, 'e) t -> 'o)","counters":[]},{"line":"         (** Function handling non-addable case *)","counters":[]},{"line":"      -> (a, r, 'e) t","counters":[]},{"line":"      -> 'o =","counters":[]},{"line":"   fun f g t ->","counters":[]},{"line":"    match t with One _ -> f t | Two _ -> f t | Three _ -> f t | Four _ -> g t","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":47,"col_end":47,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"","counters":[]},{"line":"  let removable_elim :","counters":[]},{"line":"      type a r.","counters":[]},{"line":"         ((a, removable, 'e) t -> 'o) (** Function handling removable case*)","counters":[]},{"line":"      -> ((addable, not_removable, 'e) t -> 'o)","counters":[]},{"line":"         (** Function handling non-removable case *)","counters":[]},{"line":"      -> (a, r, 'e) t","counters":[]},{"line":"      -> 'o =","counters":[]},{"line":"   fun f g t ->","counters":[]},{"line":"    match t with One _ -> g t | Two _ -> f t | Three _ -> f t | Four _ -> f t","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":47,"col_end":47,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"","counters":[]},{"line":"  (** Existential type for when addability is determined at runtime. *)","counters":[]},{"line":"  type ('r, 'e) t_any_a = Mk_any_a : ('a, 'r, 'e) t -> ('r, 'e) t_any_a","counters":[]},{"line":"","counters":[]},{"line":"  (** Same for removability. *)","counters":[]},{"line":"  type ('a, 'e) t_any_r = Mk_any_r : ('a, 'r, 'e) t -> ('a, 'e) t_any_r","counters":[]},{"line":"","counters":[]},{"line":"  (** Both. *)","counters":[]},{"line":"  type 'e t_any_ar = Mk_any_ar : ('a, 'r, 'e) t -> 'e t_any_ar","counters":[]},{"line":"","counters":[]},{"line":"  (** \"Broaden\" a t_any_a into a t_any_ar, i.e. forget that we know the","counters":[]},{"line":"      removability status. *)","counters":[]},{"line":"  let broaden_any_a : ('r, 'e) t_any_a -> 'e t_any_ar =","counters":[]},{"line":"   fun (Mk_any_a t) -> Mk_any_ar t","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"  (** Same deal for t_any_r *)","counters":[]},{"line":"  let broaden_any_r : ('a, 'e) t_any_r -> 'e t_any_ar =","counters":[]},{"line":"   fun (Mk_any_r t) -> Mk_any_ar t","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"  let cons : type r. 'e -> (addable, r, 'e) t -> (removable, 'e) t_any_a =","counters":[]},{"line":"   fun v d ->","counters":[]},{"line":"    match d with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | One a ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Mk_any_a (Two (v, a))","counters":[]},{"line":"    | Two (a, b) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Mk_any_a (Three (v, a, b))","counters":[]},{"line":"    | Three (a, b, c) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Mk_any_a (Four (v, a, b, c))","counters":[]},{"line":"","counters":[]},{"line":"  let snoc : type r. (addable, r, 'e) t -> 'e -> (removable, 'e) t_any_a =","counters":[]},{"line":"   fun d v ->","counters":[]},{"line":"    match d with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | One a ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Mk_any_a (Two (a, v))","counters":[]},{"line":"    | Two (a, b) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Mk_any_a (Three (a, b, v))","counters":[]},{"line":"    | Three (a, b, c) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Mk_any_a (Four (a, b, c, v))","counters":[]},{"line":"","counters":[]},{"line":"  let uncons : type a. (a, removable, 'e) t -> 'e * (addable, 'e) t_any_r =","counters":[]},{"line":"    function","counters":[]},{"line":"    | Two (a, b) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (a, Mk_any_r (One b))","counters":[]},{"line":"    | Three (a, b, c) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (a, Mk_any_r (Two (b, c)))","counters":[]},{"line":"    | Four (a, b, c, d) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (a, Mk_any_r (Three (b, c, d)))","counters":[]},{"line":"","counters":[]},{"line":"  let unsnoc : type a. (a, removable, 'e) t -> (addable, 'e) t_any_r * 'e =","counters":[]},{"line":"    function","counters":[]},{"line":"    | Two (a, b) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (Mk_any_r (One a), b)","counters":[]},{"line":"    | Three (a, b, c) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (Mk_any_r (Two (a, b)), c)","counters":[]},{"line":"    | Four (a, b, c, d) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (Mk_any_r (Three (a, b, c)), d)","counters":[]},{"line":"","counters":[]},{"line":"  let foldr : type a r. ('e -> 'acc -> 'acc) -> 'acc -> (a, r, 'e) t -> 'acc =","counters":[]},{"line":"   fun f z d ->","counters":[]},{"line":"    match d with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | One a ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        f a z","counters":[]},{"line":"    | Two (a, b) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        f a (f b z)","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"    | Three (a, b, c) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        f a (f b (f c z))","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"    | Four (a, b, c, d) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        f a (f b (f c (f d z)))","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"  let foldl : type a r. ('acc -> 'e -> 'acc) -> 'acc -> (a, r, 'e) t -> 'acc =","counters":[]},{"line":"   fun f z d ->","counters":[]},{"line":"    match d with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | One a ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        f z a","counters":[]},{"line":"    | Two (a, b) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        f (f z a) b","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"    | Three (a, b, c) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        f (f (f z a) b) c","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":14,"col_end":14,"count":0}]},{"line":"    | Four (a, b, c, d) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        f (f (f (f z a) b) c) d","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":14,"col_end":14,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"","counters":[]},{"line":"  let to_list : type a r. (a, r, 'e) t -> 'e list =","counters":[]},{"line":"   fun t -> foldr List.cons [] t","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"","counters":[]},{"line":"  let gen_any_ar : int t_any_ar Quickcheck.Generator.t =","counters":[]},{"line":"    let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"    let gen_measure = Int.gen_incl 1 20 in","counters":[]},{"line":"    let%bind a, b, c, d =","counters":[]},{"line":"      Quickcheck.Generator.tuple4 gen_measure gen_measure gen_measure","counters":[{"col_start":32,"col_end":32,"count":1}]},{"line":"        gen_measure","counters":[]},{"line":"    in","counters":[]},{"line":"    Quickcheck.Generator.of_list","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      [ Mk_any_ar (One a)","counters":[]},{"line":"      ; Mk_any_ar (Two (a, b))","counters":[]},{"line":"      ; Mk_any_ar (Three (a, b, c))","counters":[]},{"line":"      ; Mk_any_ar (Four (a, b, c, d))","counters":[]},{"line":"      ]","counters":[]},{"line":"","counters":[]},{"line":"  (** Given a measurement function, compute the total measure of a digit.","counters":[]},{"line":"      See below for an explanation of what measure is.","counters":[]},{"line":"  *)","counters":[]},{"line":"  let measure : ('e -> int) -> (_, _, 'e) t -> int =","counters":[]},{"line":"   fun measure' -> foldl (fun m e -> m + measure' e) 0","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"","counters":[]},{"line":"  (** Split a digit by measure. Again see below. *)","counters":[]},{"line":"  let split :","counters":[]},{"line":"      type a r.","counters":[]},{"line":"         ('e -> int)","counters":[]},{"line":"      -> int","counters":[]},{"line":"      -> int","counters":[]},{"line":"      -> (a, r, 'e) t","counters":[]},{"line":"      -> 'e t_any_ar option * 'e * 'e t_any_ar option =","counters":[]},{"line":"   fun measure' target acc t ->","counters":[]},{"line":"    (* Addable inputs go to addable outputs, but non-addable inputs may go to","counters":[]},{"line":"       either. We use a separate function for addables to represent this and","counters":[]},{"line":"       minimizing the amount of Obj.magicking we need to do. *)","counters":[]},{"line":"    let rec split_addable :","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        type r.","counters":[]},{"line":"           int","counters":[]},{"line":"        -> (addable, r, 'e) t","counters":[]},{"line":"        -> (addable, 'e) t_any_r option * 'e * (addable, 'e) t_any_r option =","counters":[]},{"line":"     fun acc t ->","counters":[]},{"line":"      removable_elim","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (fun t' ->","counters":[]},{"line":"          let head, Mk_any_r tail = uncons t' in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          if acc + measure' head >= target then","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"            (None, head, Some (Mk_any_r tail))","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          else","counters":[]},{"line":"            match split_addable (acc + measure' head) tail with","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"            | Some (Mk_any_r lhs), m, rhs ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                let (Mk_any_a cons_res) = cons head lhs in","counters":[]},{"line":"                (* t' is addable, so the tail of t' is twice-addable. We just","counters":[]},{"line":"                   passed that tail to split_addable, which always returns","counters":[]},{"line":"                   digits with <= the number of elements of the input. So","counters":[]},{"line":"                   cons_res is addable but it's not possible to convince the","counters":[]},{"line":"                   typechecker of that, as far as I can tell.","counters":[]},{"line":"                *)","counters":[]},{"line":"                let cons_res' : (addable, removable, 'e) t =","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Obj.magic cons_res","counters":[]},{"line":"                in","counters":[]},{"line":"                (Some (Mk_any_r cons_res'), m, rhs)","counters":[]},{"line":"            | None, m, rhs ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (Some (Mk_any_r (One head)), m, rhs) )","counters":[]},{"line":"        (fun (One a) ->","counters":[]},{"line":"          if acc + measure' a >= target then (None, a, None)","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"          else failwith \"Digit.split index out of bounds\" )","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"        t","counters":[]},{"line":"    in","counters":[]},{"line":"    addable_elim","counters":[]},{"line":"      (fun t' ->","counters":[]},{"line":"        let lhs, m, rhs = split_addable acc t' in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        (Option.map ~f:broaden_any_r lhs, m, Option.map ~f:broaden_any_r rhs) )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"      (fun t' ->","counters":[]},{"line":"        let head, Mk_any_r tail = uncons t' in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        if acc + measure' head >= target then (None, head, Some (Mk_any_ar tail))","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"        else","counters":[]},{"line":"          let lhs, m, rhs = split_addable (acc + measure' head) tail in","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"          match lhs with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (Some (Mk_any_ar (One head)), m, Option.map ~f:broaden_any_r rhs)","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"          | Some (Mk_any_r lhs') ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              ( Some (broaden_any_a (cons head lhs'))","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"              , m","counters":[]},{"line":"              , Option.map ~f:broaden_any_r rhs ) )","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"      t","counters":[]},{"line":"","counters":[]},{"line":"  let opt_to_list : 'a t_any_ar option -> 'a list = function","counters":[]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        []","counters":[]},{"line":"    | Some (Mk_any_ar dig) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        to_list dig","counters":[]},{"line":"","counters":[]},{"line":"  let%test_unit \"Digit.split preserves contents and order\" =","counters":[]},{"line":"    Quickcheck.test","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"      let%bind (Mk_any_ar dig as dig') = gen_any_ar in","counters":[]},{"line":"      let%bind idx = Int.gen_incl 1 (List.length @@ to_list dig) in","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":47,"col_end":47,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"      return (dig', idx))","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      ~f:(fun (Mk_any_ar dig, target) ->","counters":[]},{"line":"        let lhs_opt, m, rhs_opt = split Fn.id target 0 dig in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let lhs', rhs' = (opt_to_list lhs_opt, opt_to_list rhs_opt) in","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"        [%test_eq: int list] (lhs' @ [ m ] @ rhs') (to_list dig) )","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"","counters":[]},{"line":"  let%test_unit \"Digit.split matches list implementation\" =","counters":[]},{"line":"    Quickcheck.test","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ~sexp_of:(fun (Mk_any_ar dig, idx) ->","counters":[]},{"line":"        Tuple2.sexp_of_t","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (List.sexp_of_t Int.sexp_of_t)","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"          Int.sexp_of_t","counters":[]},{"line":"          (to_list dig, idx) )","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"      (let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"      let%bind (Mk_any_ar dig) = gen_any_ar in","counters":[]},{"line":"      let%bind idx = Int.gen_incl 1 (List.length @@ to_list dig) in","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":47,"col_end":47,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"      return (Mk_any_ar dig, idx))","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      ~f:(fun (Mk_any_ar dig, idx) ->","counters":[]},{"line":"        let as_list = to_list dig in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let lhs_list = List.take as_list (idx - 1) in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let m_list = List.nth_exn as_list (idx - 1) in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let rhs_list = List.drop as_list idx in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        [%test_eq: int list] (lhs_list @ (m_list :: rhs_list)) as_list ;","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"        let lhs_fseq, m_fseq, rhs_fseq = split (Fn.const 1) idx 0 dig in","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"        let lhs_fseq', rhs_fseq' =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (opt_to_list lhs_fseq, opt_to_list rhs_fseq)","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"        in","counters":[]},{"line":"        [%test_eq: int list] (lhs_fseq' @ (m_fseq :: rhs_fseq')) (to_list dig) ;","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":72,"col_end":72,"count":0}]},{"line":"        [%test_eq: int list] lhs_list lhs_fseq' ;","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"        [%test_eq: int] m_list m_fseq ;","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"        [%test_eq: int list] rhs_list rhs_fseq' ;","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"        [%test_eq: int] (List.length lhs_fseq') (idx - 1) ;","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"        [%test_eq: int] (List.length rhs_fseq') (List.length as_list - idx) )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"","counters":[]},{"line":"  (* See comment below about measures for why index 0 is an edge case. *)","counters":[]},{"line":"  let%test_unit \"Digit.split with index 0 is trivial\" =","counters":[]},{"line":"    Quickcheck.test","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (Quickcheck.Generator.tuple2 gen_any_ar (Int.gen_incl 0 200))","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"      ~f:(fun (Mk_any_ar dig, acc) ->","counters":[]},{"line":"        let as_list = to_list dig in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let lhs, m, rhs = split Fn.id acc acc dig in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        assert (Option.is_none lhs) ;","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"        [%test_eq: int] m (List.hd_exn as_list) ;","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"        match rhs with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            [%test_eq: int list] [] (List.tl_exn as_list)","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"        | Some (Mk_any_ar rhs') ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            [%test_eq: int list] (to_list rhs') (List.tl_exn as_list) )","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"","counters":[]},{"line":"  let%test _ =","counters":[]},{"line":"    match split Fn.id 1 0 (One 1) with None, 1, None -> true | _ -> false","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"","counters":[]},{"line":"  let%test _ =","counters":[]},{"line":"    match split Fn.id 5 0 (Three (0, 2, 4)) with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Some (Mk_any_ar (Two (0, 2))), 4, None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        true","counters":[]},{"line":"    | _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        false","counters":[]},{"line":"","counters":[]},{"line":"  let%test _ =","counters":[]},{"line":"    match split Fn.id 10 0 (Four (2, 3, 5, 1)) with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Some (Mk_any_ar (Two (2, 3))), 5, Some (Mk_any_ar (One 1)) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        true","counters":[]},{"line":"    | _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        false","counters":[]},{"line":"","counters":[]},{"line":"  let%test _ =","counters":[]},{"line":"    match split Fn.id 7 0 (Four (2, 4, 3, 2)) with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Some (Mk_any_ar (Two (2, 4))), 3, Some (Mk_any_ar (One 2)) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        true","counters":[]},{"line":"    | _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        false","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(** Nodes containing 2-3 elements, with a cached measurement. *)","counters":[]},{"line":"module Node = struct","counters":[]},{"line":"  (** This implementation doesn't actually use 2-nodes, but they're here for","counters":[]},{"line":"      future use. The paper uses them in the append operation, which isn't","counters":[]},{"line":"      implemented here.","counters":[]},{"line":"  *)","counters":[]},{"line":"  type 'e t = Two of int * 'e * 'e | Three of int * 'e * 'e * 'e","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":14,"col_end":14,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":46,"col_end":46,"count":0},{"col_start":52,"col_end":52,"count":0},{"col_start":53,"col_end":53,"count":0},{"col_start":57,"col_end":57,"count":0},{"col_start":58,"col_end":58,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"  [@@deriving equal, compare]","counters":[]},{"line":"","counters":[]},{"line":"  (** Extract the cached measurement *)","counters":[]},{"line":"  let measure : 'e t -> int =","counters":[]},{"line":"   fun t -> match t with Two (m, _, _) -> m | Three (m, _, _, _) -> m","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"","counters":[]},{"line":"  let to_digit : 'e t -> (Digit.addable, Digit.removable, 'e) Digit.t = function","counters":[]},{"line":"    | Two (_m, a, b) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Digit.Two (a, b)","counters":[]},{"line":"    | Three (_m, a, b, c) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Digit.Three (a, b, c)","counters":[]},{"line":"","counters":[]},{"line":"  (* smart constructors to maintain correct measures *)","counters":[]},{"line":"  let _mk_2 : ('e -> int) -> 'e -> 'e -> 'e t =","counters":[]},{"line":"   fun f a b -> Two (f a + f b, a, b)","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"","counters":[]},{"line":"  let mk_3 : ('e -> int) -> 'e -> 'e -> 'e -> 'e t =","counters":[]},{"line":"   fun f a b c -> Three (f a + f b + f c, a, b, c)","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"  let split_to_digits :","counters":[]},{"line":"         ('e -> int)","counters":[]},{"line":"      -> int","counters":[]},{"line":"      -> int","counters":[]},{"line":"      -> 'e t","counters":[]},{"line":"      -> 'e Digit.t_any_ar option * 'e * 'e Digit.t_any_ar option =","counters":[]},{"line":"   fun measure' target acc t -> to_digit t |> Digit.split measure' target acc","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(** Finally, the actual finger tree type! *)","counters":[]},{"line":"type 'e t =","counters":[]},{"line":"  | Empty : 'e t  (** Empty tree *)","counters":[]},{"line":"  | Single : 'e -> 'e t  (** Single element tree *)","counters":[]},{"line":"  | Deep :","counters":[]},{"line":"      ( int","counters":[]},{"line":"      * ('aL, 'rL, 'e) Digit.t","counters":[]},{"line":"      * 'e Node.t t Lazy.t","counters":[]},{"line":"      * ('aR, 'rR, 'e) Digit.t )","counters":[]},{"line":"      -> 'e t","counters":[]},{"line":"      (** The recursive case. We have a cached measurement, prefix and suffix","counters":[]},{"line":"          fingers, and a subtree. Note the subtree has a different type than its","counters":[]},{"line":"          parent. The top level has 'es, the next level has 'e Node.ts, the next","counters":[]},{"line":"          has 'e Node.t Node.ts and so on. As you go deeper, the breadth","counters":[]},{"line":"          increases exponentially. *)","counters":[]},{"line":"","counters":[]},{"line":"(* Can't derive compare for GADTs.. *)","counters":[]},{"line":"let rec compare : type e. (e -> e -> int) -> e t -> e t -> int =","counters":[]},{"line":" fun cmp_e x y ->","counters":[]},{"line":"  match (x, y) with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | Empty, Empty ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      0","counters":[]},{"line":"  | Empty, _ ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      -1","counters":[]},{"line":"  | _, Empty ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      1","counters":[]},{"line":"  | Single x, Single y ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      cmp_e x y","counters":[]},{"line":"  | Single _, _ ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      -1","counters":[]},{"line":"  | _, Single _ ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      1","counters":[]},{"line":"  | Deep (i, pre_x, mid_x, suff_x), Deep (j, pre_y, mid_y, suff_y) ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let cmp = Int.compare i j in","counters":[]},{"line":"      if cmp <> 0 then cmp","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"      else","counters":[]},{"line":"        let cmp = Digit.compare cmp_e pre_x pre_y in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        if cmp <> 0 then cmp","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"        else","counters":[]},{"line":"          let cmp = Lazy.compare (compare (Node.compare cmp_e)) mid_x mid_y in","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"          if cmp <> 0 then cmp else Digit.compare cmp_e suff_x suff_y","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"  | Deep _, _ ->","counters":[]},{"line":"      .","counters":[]},{"line":"  | _, Deep _ ->","counters":[]},{"line":"      .","counters":[]},{"line":"","counters":[]},{"line":"(* About measurements: in the paper they define finger trees more generally than","counters":[]},{"line":"   this implementation. Given a monoid m, a measurement function for elements","counters":[]},{"line":"   e -> m, and \"monotonic\" predicates on m, if you cache the measure of subtrees","counters":[]},{"line":"   you can index into and split finger trees at the transition point of the","counters":[]},{"line":"   predicates in log time. The output of any of the split functions is a triple","counters":[]},{"line":"   of the longest subsequence starting from the beginning where the predicate is","counters":[]},{"line":"   false, the element that flips it to true, and the subsequence after that up","counters":[]},{"line":"   to the end. In this implementation the monoid is natural numbers under","counters":[]},{"line":"   summation, the measurement is 'Fn.const 1' and the predicates are","counters":[]},{"line":"   (fun x -> x >= idx). So the measure of a tree is how many elements are in it","counters":[]},{"line":"   and the transition point is where there are >= idx elements. Index 0 is a","counters":[]},{"line":"   special case, since forall x : â„•. x >= 0. In that case the first subsequence","counters":[]},{"line":"   is empty, the transition point is the first element, and the second","counters":[]},{"line":"   subsequence is the rest of the input sequence.","counters":[]},{"line":"","counters":[]},{"line":"   You'll see many functions take a parameter measure' to compute measures of","counters":[]},{"line":"   elements with. This is always either Node.measure or 'Fn.const 1' depending","counters":[]},{"line":"   on if we're at the top level or not.","counters":[]},{"line":"","counters":[]},{"line":"   Other measurement functions and monoids get you priority queues, search trees","counters":[]},{"line":"   and interval trees.","counters":[]},{"line":"*)","counters":[]},{"line":"let measure : ('e -> int) -> 'e t -> int =","counters":[]},{"line":" fun measure' t ->","counters":[]},{"line":"  match t with Empty -> 0 | Single a -> measure' a | Deep (m, _, _, _) -> m","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"","counters":[]},{"line":"(** Smart constructor for deep nodes that tracks measure. *)","counters":[]},{"line":"let deep :","counters":[]},{"line":"       ('e -> int)","counters":[]},{"line":"    -> (_, _, 'e) Digit.t","counters":[]},{"line":"    -> 'e Node.t t","counters":[]},{"line":"    -> (_, _, 'e) Digit.t","counters":[]},{"line":"    -> 'e t =","counters":[]},{"line":" fun measure' prefix middle suffix ->","counters":[]},{"line":"  Deep","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    ( Digit.measure measure' prefix","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"      + measure Node.measure middle","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"      + Digit.measure measure' suffix","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"    , prefix","counters":[]},{"line":"    , lazy middle","counters":[]},{"line":"    , suffix )","counters":[]},{"line":"","counters":[]},{"line":"let empty : 'e t = Empty","counters":[]},{"line":"","counters":[]},{"line":"(** Add a new element to the left end of the tree. *)","counters":[]},{"line":"let rec cons' : 'e. ('e -> int) -> 'e -> 'e t -> 'e t =","counters":[]},{"line":" fun measure' v t ->","counters":[]},{"line":"  match t with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | Empty ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Single v","counters":[]},{"line":"  | Single v' ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      deep measure' (Digit.One v) Empty (Digit.One v')","counters":[]},{"line":"  | Deep (_, prefix, middle, suffix) ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (* If there is space in the left finger, the finger is the only thing that","counters":[]},{"line":"         needs to change. If not we need to make a recursive call. A recursive","counters":[]},{"line":"         call frees up two finger slots and is needed every third cons","counters":[]},{"line":"         operation, so the amortized cost is constant for a two layer tree.","counters":[]},{"line":"         Because each level triples the number of elements in the fingers, we","counters":[]},{"line":"         free up 2 * 3^level slots per recursive call and need to do so every","counters":[]},{"line":"         2 * 3^level conses. So cons is amortized O(1) for arbitrary depth","counters":[]},{"line":"         trees.","counters":[]},{"line":"      *)","counters":[]},{"line":"      Digit.addable_elim","counters":[]},{"line":"        (fun prefix' ->","counters":[]},{"line":"          let (Mk_any_a prefix'') = Digit.cons v prefix' in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          deep measure' prefix'' (Lazy.force middle) suffix )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"        (fun (Four (a, b, c, d)) ->","counters":[]},{"line":"          deep measure'","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (Digit.Two (v, a))","counters":[]},{"line":"            (cons' Node.measure (Node.mk_3 measure' b c d) @@ Lazy.force middle)","counters":[{"col_start":41,"col_end":41,"count":0},{"col_start":57,"col_end":57,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"            suffix )","counters":[]},{"line":"        prefix","counters":[]},{"line":"","counters":[]},{"line":"let cons : 'e -> 'e t -> 'e t = fun x xs -> cons' (Fn.const 1) x xs","counters":[{"col_start":44,"col_end":44,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"","counters":[]},{"line":"(** Add a new element to the right end of the tree. This is a mirror of cons' *)","counters":[]},{"line":"let rec snoc' : 'e. ('e -> int) -> 'e t -> 'e -> 'e t =","counters":[]},{"line":" fun measure' t v ->","counters":[]},{"line":"  match t with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | Empty ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Single v","counters":[]},{"line":"  | Single v' ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      deep measure' (Digit.One v') Empty (Digit.One v)","counters":[]},{"line":"  | Deep (_, prefix, middle, suffix) ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Digit.addable_elim","counters":[]},{"line":"        (fun digit ->","counters":[]},{"line":"          let (Mk_any_a digit') = Digit.snoc digit v in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          deep measure' prefix (Lazy.force middle) digit' )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"        (fun (Four (a, b, c, d)) ->","counters":[]},{"line":"          deep measure' prefix","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (snoc' Node.measure (Lazy.force middle) @@ Node.mk_3 measure' a b c)","counters":[{"col_start":42,"col_end":42,"count":0},{"col_start":50,"col_end":50,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"            (Digit.Two (d, v)) )","counters":[]},{"line":"        suffix","counters":[]},{"line":"","counters":[]},{"line":"let snoc : 'e t -> 'e -> 'e t = fun xs x -> snoc' (Fn.const 1) xs x","counters":[{"col_start":44,"col_end":44,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"","counters":[]},{"line":"(** Create a finger tree from a digit *)","counters":[]},{"line":"let tree_of_digit : ('e -> int) -> ('a, 'r, 'e) Digit.t -> 'e t =","counters":[]},{"line":" fun measure' dig -> Digit.foldr (cons' measure') Empty dig","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"","counters":[]},{"line":"(** If the input is non-empty, get the first element and the rest of the","counters":[]},{"line":"    sequence. If it is empty, return None. *)","counters":[]},{"line":"let rec uncons' : 'e. ('e -> int) -> 'e t -> ('e * 'e t) option =","counters":[]},{"line":" fun measure' t ->","counters":[]},{"line":"  match t with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | Empty ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      None","counters":[]},{"line":"  | Single e ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Some (e, empty)","counters":[]},{"line":"  | Deep (_m, prefix, middle, suffix) ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Digit.removable_elim","counters":[]},{"line":"        (fun prefix' ->","counters":[]},{"line":"          let head, Mk_any_r prefix_rest = Digit.uncons prefix' in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          Some (head, deep measure' prefix_rest (force middle) suffix) )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"        (fun (One e) ->","counters":[]},{"line":"          match uncons' Node.measure (force middle) with","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Some (e, tree_of_digit measure' suffix)","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"          | Some (node, rest) ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Some (e, deep measure' (Node.to_digit node) rest suffix) )","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"        prefix","counters":[]},{"line":"","counters":[]},{"line":"(** Uncons for the top level trees. *)","counters":[]},{"line":"let uncons : 'e t -> ('e * 'e t) option = fun t -> uncons' (Fn.const 1) t","counters":[{"col_start":51,"col_end":51,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"","counters":[]},{"line":"(** Mirror of uncons' for the last element. *)","counters":[]},{"line":"let rec unsnoc' : 'e. ('e -> int) -> 'e t -> ('e t * 'e) option =","counters":[]},{"line":" fun measure' t ->","counters":[]},{"line":"  match t with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | Empty ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      None","counters":[]},{"line":"  | Single e ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Some (empty, e)","counters":[]},{"line":"  | Deep (_m, prefix, middle, suffix) ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Digit.removable_elim","counters":[]},{"line":"        (fun suffix' ->","counters":[]},{"line":"          let Mk_any_r liat, deah = Digit.unsnoc suffix' in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          Some (deep measure' prefix (force middle) liat, deah) )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"        (fun (One e) ->","counters":[]},{"line":"          match unsnoc' Node.measure (force middle) with","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Some (tree_of_digit measure' prefix, e)","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"          | Some (rest, node) ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Some (deep measure' prefix rest (Node.to_digit node), e) )","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"        suffix","counters":[]},{"line":"","counters":[]},{"line":"(** Mirror of uncons. *)","counters":[]},{"line":"let unsnoc : 'e t -> ('e t * 'e) option = fun t -> unsnoc' (Fn.const 1) t","counters":[{"col_start":51,"col_end":51,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"","counters":[]},{"line":"let head_exn : 'e t -> 'e = fun t -> Option.value_exn (uncons t) |> Tuple2.get1","counters":[{"col_start":37,"col_end":37,"count":0},{"col_start":52,"col_end":52,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"","counters":[]},{"line":"let last_exn : 'e t -> 'e = fun t -> unsnoc t |> Option.value_exn |> Tuple2.get2","counters":[{"col_start":37,"col_end":37,"count":0},{"col_start":42,"col_end":42,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"","counters":[]},{"line":"let rec foldl : ('a -> 'e -> 'a) -> 'a -> 'e t -> 'a =","counters":[]},{"line":" fun f acc t ->","counters":[]},{"line":"  match uncons t with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | None ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      acc","counters":[]},{"line":"  | Some (head, tail) ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      foldl f (f acc head) tail","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"","counters":[]},{"line":"let rec foldr : ('e -> 'a -> 'a) -> 'a -> 'e t -> 'a =","counters":[]},{"line":" fun f acc t ->","counters":[]},{"line":"  match uncons t with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | None ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      acc","counters":[]},{"line":"  | Some (head, tail) ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      f head (foldr f acc tail)","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"","counters":[]},{"line":"module C = Container.Make (struct","counters":[]},{"line":"  type nonrec 'a t = 'a t","counters":[]},{"line":"","counters":[]},{"line":"  let fold : 'a t -> init:'accum -> f:('accum -> 'a -> 'accum) -> 'accum =","counters":[]},{"line":"   fun t ~init ~f -> foldl f init t","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"","counters":[]},{"line":"  let iter = `Define_using_fold","counters":[]},{"line":"","counters":[]},{"line":"  let length = `Custom (fun t -> measure (Fn.const 1) t)","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"end)","counters":[]},{"line":"","counters":[]},{"line":"let is_empty = C.is_empty","counters":[]},{"line":"","counters":[]},{"line":"let length = C.length","counters":[]},{"line":"","counters":[]},{"line":"let iter = C.iter","counters":[]},{"line":"","counters":[]},{"line":"let find = C.find","counters":[]},{"line":"","counters":[]},{"line":"let findi t ~f =","counters":[]},{"line":"  match","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    C.fold t ~init:(`Not_found 0) ~f:(fun acc x ->","counters":[]},{"line":"        match acc with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | `Not_found i ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            if f x then `Found i else `Not_found (i + 1)","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"        | `Found i ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            `Found i )","counters":[]},{"line":"  with","counters":[]},{"line":"  | `Not_found _ ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      None","counters":[]},{"line":"  | `Found i ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Some i","counters":[]},{"line":"","counters":[]},{"line":"let to_seq : 'e t -> 'e Sequence.t = fun t -> Sequence.unfold ~init:t ~f:uncons","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"","counters":[]},{"line":"let sexp_of_t : ('e -> Sexp.t) -> 'e t -> Sexp.t =","counters":[]},{"line":" fun sexp_inner -> Fn.compose (Sequence.sexp_of_t sexp_inner) to_seq","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"","counters":[]},{"line":"let rec equal : ('e -> 'e -> bool) -> 'e t -> 'e t -> bool =","counters":[]},{"line":" fun eq_inner xs ys ->","counters":[]},{"line":"  match (uncons xs, uncons ys) with","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":14,"col_end":14,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"  | Some (x, xs_tail), Some (y, ys_tail) ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      eq_inner x y && equal eq_inner xs_tail ys_tail","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"  | _ ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      false","counters":[]},{"line":"","counters":[]},{"line":"let to_list : 'e t -> 'e list = fun fseq -> Sequence.to_list (to_seq fseq)","counters":[{"col_start":44,"col_end":44,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"","counters":[]},{"line":"let of_list : 'e list -> 'e t = List.fold_left ~init:empty ~f:snoc","counters":[]},{"line":"","counters":[]},{"line":"(* Split a tree into the elements before a given index, the element at that","counters":[]},{"line":"   index and the elements after it. The index must exist in the tree. *)","counters":[]},{"line":"let rec split : 'e. ('e -> int) -> 'e t -> int -> int -> 'e t * 'e * 'e t =","counters":[]},{"line":" fun measure' t target acc ->","counters":[]},{"line":"  match t with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | Empty ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      failwith \"FSequence.split index out of bounds (1)\"","counters":[]},{"line":"  | Single x ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      if acc + measure' x >= target then (Empty, x, Empty)","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"      else failwith \"FSequence.split index out of bounds (2)\"","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"  | Deep (_m, prefix, middle, suffix) ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let acc_p = acc + Digit.measure measure' prefix in","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"      if acc_p >= target then","counters":[]},{"line":"        (* split point is in left finger *)","counters":[]},{"line":"        let dl, m, dr = Digit.split measure' target acc prefix in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        ( (* left part of digit split *)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ( match dl with","counters":[]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Empty","counters":[]},{"line":"          | Some (Mk_any_ar dig) ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              tree_of_digit measure' dig )","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"        , (* middle of digit split *) m","counters":[]},{"line":"        , (* right part of digit split + subtree + suffix *)","counters":[]},{"line":"          match dr with","counters":[]},{"line":"          | None -> (","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              match uncons' Node.measure @@ force middle with","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"              | None ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  tree_of_digit measure' suffix","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"              | Some (head, tail) ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  deep measure' (Node.to_digit head) tail suffix )","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"          | Some (Mk_any_ar dig) ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              deep measure' dig (force middle) suffix )","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"      else","counters":[]},{"line":"        let acc_m = acc_p + measure Node.measure (force middle) in","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"        if acc_m >= target then","counters":[]},{"line":"          (* split point is in subtree *)","counters":[]},{"line":"          let lhs, m, rhs = split Node.measure (force middle) target acc_p in","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"          (* The subtree is made of nodes, so the midpoint we got from the","counters":[]},{"line":"             recursive call is a node, so split that. *)","counters":[]},{"line":"          let m_lhs, m_m, m_rhs =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Node.split_to_digits measure' target","counters":[]},{"line":"              (measure Node.measure lhs + acc_p)","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"              m","counters":[]},{"line":"          in","counters":[]},{"line":"          ( (* prefix + lhs of the split of the subtree + lhs of the split of","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"               them midpoint of the subtree *)","counters":[]},{"line":"            ( match m_lhs with","counters":[]},{"line":"            | None -> (","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                match unsnoc' Node.measure lhs with","counters":[]},{"line":"                | None ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    tree_of_digit measure' prefix","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                | Some (liat, deah) ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    deep measure' prefix liat (Node.to_digit deah) )","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"            | Some (Mk_any_ar dig) ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                deep measure' prefix lhs dig )","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"          , (* midpoint of the split of the subtree *)","counters":[]},{"line":"            m_m","counters":[]},{"line":"          , (* rhs of the split of the midpoint of the subtree + rhs of the","counters":[]},{"line":"               split of the subtree + suffix *)","counters":[]},{"line":"            match m_rhs with","counters":[]},{"line":"            | None -> (","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                match uncons' Node.measure rhs with","counters":[]},{"line":"                | None ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    tree_of_digit measure' suffix","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                | Some (head, tail) ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    deep measure' (Node.to_digit head) tail suffix )","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"            | Some (Mk_any_ar dig) ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                deep measure' dig rhs suffix )","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"        else","counters":[]},{"line":"          let acc_s = acc_m + Digit.measure measure' suffix in","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"          if acc_s >= target then","counters":[]},{"line":"            (* split point is in right finger *)","counters":[]},{"line":"            let dl, m, dr = Digit.split measure' target acc_m suffix in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            ( (* prefix + subtree + left part of digit split *)","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              ( match dl with","counters":[]},{"line":"              | None -> (","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  match unsnoc' Node.measure (force middle) with","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                  | None ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      tree_of_digit measure' prefix","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"                  | Some (liat, deah) ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      deep measure' prefix liat (Node.to_digit deah) )","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"              | Some (Mk_any_ar dig) ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  deep measure' prefix (force middle) dig )","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"            , (* midpoint of digit split *)","counters":[]},{"line":"              m","counters":[]},{"line":"            , (* right part of digit split *)","counters":[]},{"line":"              match dr with","counters":[]},{"line":"              | None ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Empty","counters":[]},{"line":"              | Some (Mk_any_ar dig) ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  tree_of_digit measure' dig )","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"          else failwith \"FSequence.split index out of bounds (3)\"","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"","counters":[]},{"line":"(* Split a tree into the elements before some index and the elements >= that","counters":[]},{"line":"   index. split_at works when the index is out of range and returns a pair while","counters":[]},{"line":"   split throws an exception if the index is out of range and returns a triple.","counters":[]},{"line":"   The contract is that split_at xs i = take i xs, drop i xs.","counters":[]},{"line":"*)","counters":[]},{"line":"let split_at : 'e t -> int -> 'e t * 'e t =","counters":[]},{"line":" fun t idx ->","counters":[]},{"line":"  match t with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | Empty ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (empty, empty)","counters":[]},{"line":"  | _ ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      if idx = 0 then (empty, t)","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"      else if measure (Fn.const 1) t >= idx then","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"        match split (Fn.const 1) t idx 0 with lhs, m, rhs -> (snoc lhs m, rhs)","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":46,"col_end":46,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"      else (t, empty)","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"","counters":[]},{"line":"let singleton : 'e -> 'e t = fun v -> Single v","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"","counters":[]},{"line":"(* Assert that the cached measures match the actual ones. *)","counters":[]},{"line":"let rec assert_measure : type e. (e -> int) -> e t -> unit =","counters":[]},{"line":" fun measure' -> function","counters":[]},{"line":"  | Empty ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ()","counters":[]},{"line":"  | Single _ ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ()","counters":[]},{"line":"  | Deep (cached_measure, prefix, middle, suffix) ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let measure_node_with_assert node =","counters":[]},{"line":"        let expected = Node.measure node in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let contents = node |> Node.to_digit |> Digit.to_list in","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"        [%test_eq: int] expected (List.sum (module Int) ~f:measure' contents) ;","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"        expected","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      in","counters":[]},{"line":"      let middle' = Lazy.force middle in","counters":[]},{"line":"      assert_measure measure_node_with_assert middle' ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      [%test_eq: int] cached_measure","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"        ( Digit.measure measure' prefix","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"        + measure Node.measure middle'","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"        + Digit.measure measure' suffix )","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"(* Quickcheck.Generator.list generates pretty small lists, which are not big","counters":[]},{"line":"   enough to exercise multiple levels of the tree. So we use this instead. *)","counters":[]},{"line":"let big_list : 'a Quickcheck.Generator.t -> 'a list Quickcheck.Generator.t =","counters":[]},{"line":" fun gen ->","counters":[]},{"line":"  let open Quickcheck.Generator.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%bind len = Int.gen_incl 0 1000 in","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"  Quickcheck.Generator.list_with_length len gen","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let%test_unit \"list isomorphism - cons\" =","counters":[]},{"line":"  Quickcheck.test (big_list Int.quickcheck_generator) ~f:(fun xs ->","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"      let xs_fseq = List.fold_right xs ~f:cons ~init:empty in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      assert_measure (Fn.const 1) xs_fseq ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"      [%test_eq: int list] xs (to_list xs_fseq) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"      [%test_eq: int] (List.length xs) (length xs_fseq) )","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"","counters":[]},{"line":"let%test_unit \"list isomorphism - snoc\" =","counters":[]},{"line":"  Quickcheck.test (big_list Int.quickcheck_generator) ~f:(fun xs ->","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"      let xs_fseq = List.fold_left xs ~init:empty ~f:snoc in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      assert_measure (Fn.const 1) xs_fseq ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"      [%test_eq: int list] xs (to_list xs_fseq) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"      [%test_eq: int] (List.length xs) (length xs_fseq) )","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"","counters":[]},{"line":"let%test_unit \"alternating cons/snoc\" =","counters":[]},{"line":"  Quickcheck.test","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Quickcheck.Generator.(","counters":[]},{"line":"      big_list @@ variant2 (Int.gen_incl 0 500) (Int.gen_incl 0 500))","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"    ~f:(fun cmds ->","counters":[]},{"line":"      let rec go list fseq cmds_acc =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        match cmds_acc with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | [] ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            assert_measure (Fn.const 1) fseq ;","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"            [%test_eq: int list] list (to_list fseq) ;","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"            [%test_eq: int] (List.length list) (length fseq)","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"        | `A x :: rest ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            go (x :: list) (cons x fseq) rest","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"        | `B x :: rest ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            go (list @ [ x ]) (snoc fseq x) rest","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"      in","counters":[]},{"line":"      go [] empty cmds )","counters":[]},{"line":"","counters":[]},{"line":"let%test_unit \"split properties\" =","counters":[]},{"line":"  let gen =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"    let%bind xs = big_list (Int.gen_incl 0 500) in","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"    let%bind idx = Int.gen_incl 0 (List.length xs) in","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"    return (xs, idx)","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  in","counters":[]},{"line":"  let shrinker =","counters":[]},{"line":"    Quickcheck.Shrinker.create (fun (xs, idx) ->","counters":[]},{"line":"        Sequence.append","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ( if List.length xs - 1 > idx then","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"            Sequence.singleton (List.tl_exn xs, idx)","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"          else Sequence.empty )","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"          ( Sequence.range ~start:`inclusive ~stop:`inclusive 1 5","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"          |> Sequence.filter_map ~f:(fun offset ->","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                 let res = idx - offset in","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                 if res >= 0 then Some (xs, res) else None ) ) )","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"  in","counters":[]},{"line":"  Quickcheck.test gen ~shrink_attempts:`Exhaustive","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    ~sexp_of:[%sexp_of: int list * int] ~shrinker ~f:(fun (xs, idx) ->","counters":[]},{"line":"      let len = List.length xs in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let split_l_list = List.take xs idx in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let split_r_list = List.drop xs idx in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let xs_fseq = of_list xs in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let split_l_fseq, split_r_fseq = split_at xs_fseq idx in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let split_l_fseq', split_r_fseq' =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (to_list split_l_fseq, to_list split_r_fseq)","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"      in","counters":[]},{"line":"      assert_measure (Fn.const 1) split_l_fseq ;","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"      assert_measure (Fn.const 1) split_r_fseq ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"      [%test_eq: int] (List.length split_l_list + List.length split_r_list) len ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"      [%test_eq: int list] split_l_list split_l_fseq' ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"      [%test_eq: int list] split_r_list split_r_fseq' ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"      [%test_eq: int] (List.length split_l_fseq') (length split_l_fseq) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"      [%test_eq: int] (List.length split_r_fseq') (length split_r_fseq) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"      [%test_eq: int] (length split_l_fseq + length split_r_fseq) len )","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"","counters":[]},{"line":"(* Exercise all the functions that generate sequences, in random combinations. *)","counters":[]},{"line":"let%test_module \"random sequence generation, with splits\" =","counters":[]},{"line":"  ( module struct","counters":[]},{"line":"    type action =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      [ `Cons of int","counters":[]},{"line":"      | `Snoc of int","counters":[]},{"line":"      | `Split_take_left of int","counters":[]},{"line":"      | `Split_take_right of int ]","counters":[]},{"line":"    [@@deriving sexp_of]","counters":[]},{"line":"","counters":[]},{"line":"    let%test_unit _ =","counters":[]},{"line":"      let rec gen_actions xs len n =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let open Quickcheck.Generator in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"        if n = 0 then return @@ List.rev xs","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"        else","counters":[]},{"line":"          match%bind","counters":[]},{"line":"            variant3 (Int.gen_incl 0 500) (Int.gen_incl 0 500)","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"              (Int.gen_uniform_incl 0 len)","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"          with","counters":[]},{"line":"          | `A v ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              gen_actions (`Cons v :: xs) (len + 1) (n - 1)","counters":[]},{"line":"          | `B v ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              gen_actions (`Snoc v :: xs) (len + 1) (n - 1)","counters":[]},{"line":"          | `C idx -> (","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              match%bind bool with","counters":[]},{"line":"              | true ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  gen_actions (`Split_take_left idx :: xs) idx (n - 1)","counters":[]},{"line":"              | false ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  gen_actions (`Split_take_right idx :: xs) (len - idx) (n - 1)","counters":[]},{"line":"              )","counters":[]},{"line":"      in","counters":[]},{"line":"      let gen =","counters":[]},{"line":"        let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"        let%bind len = Int.gen_incl 0 50 in","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"        gen_actions [] 0 len","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      in","counters":[]},{"line":"      let shrinker =","counters":[]},{"line":"        Quickcheck.Shrinker.create (function","counters":[]},{"line":"          | [] ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Sequence.empty","counters":[]},{"line":"          | _ :: _ as acts ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Sequence.of_list","counters":[]},{"line":"                [ List.take acts (List.length acts / 2)","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"                ; List.take acts (List.length acts - 1)","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"                ; List.map acts ~f:(function `Snoc x -> `Cons x | x -> x)","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"                ; List.map acts ~f:(function `Cons x -> `Snoc x | x -> x)","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"                ] )","counters":[]},{"line":"      in","counters":[]},{"line":"      Quickcheck.test gen ~trials:100_000 ~shrinker","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ~sexp_of:(List.sexp_of_t sexp_of_action) ~f:(fun acts ->","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"          let rec go fseq =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let assert_m fseq' =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              assert_measure (Fn.const 1) fseq' ;","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"              fseq'","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"            in","counters":[]},{"line":"            function","counters":[]},{"line":"            | [] ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ()","counters":[]},{"line":"            | `Cons x :: acts_rest ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                go (assert_m @@ cons x fseq) acts_rest","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"            | `Snoc x :: acts_rest ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                go (assert_m @@ snoc fseq x) acts_rest","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"            | `Split_take_left idx :: acts_rest ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                go (assert_m @@ Tuple2.get1 @@ split_at fseq idx) acts_rest","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":42,"col_end":42,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"            | `Split_take_right idx :: acts_rest ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                go (assert_m @@ Tuple2.get2 @@ split_at fseq idx) acts_rest","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":42,"col_end":42,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"          in","counters":[]},{"line":"          go empty acts )","counters":[]},{"line":"  end )","counters":[{"col_start":6,"col_end":6,"count":1}]}]}