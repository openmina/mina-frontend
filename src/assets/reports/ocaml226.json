{"filename":"src/lib/network_pool/batcher.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Async_kernel","counters":[]},{"line":"open Network_peer","counters":[]},{"line":"","counters":[]},{"line":"(* Only show stdout for failed inline tests. *)","counters":[]},{"line":"open Inline_test_quiet_logs","counters":[]},{"line":"","counters":[]},{"line":"module Id = Unique_id.Int ()","counters":[]},{"line":"","counters":[]},{"line":"type ('init, 'result) elt =","counters":[{"col_start":0,"col_end":0,"count":0}]},{"line":"  { id : Id.t","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":5,"col_end":5,"count":0}]},{"line":"  ; data : 'init","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":7,"col_end":7,"count":0}]},{"line":"  ; weight : int","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":9,"col_end":9,"count":0}]},{"line":"  ; res : (('result, Verifier.invalid) Result.t Or_error.t Ivar.t[@sexp.opaque])","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":6,"col_end":6,"count":0}]},{"line":"  }","counters":[]},{"line":"[@@deriving sexp]","counters":[]},{"line":"","counters":[]},{"line":"type ('proof, 'result) state =","counters":[{"col_start":0,"col_end":0,"count":0}]},{"line":"  | Waiting","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | Verifying of { out_for_verification : ('proof, 'result) elt list }","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"[@@deriving sexp]","counters":[]},{"line":"","counters":[]},{"line":"module Q = Doubly_linked","counters":[]},{"line":"","counters":[]},{"line":"type ('init, 'partially_validated, 'result) t =","counters":[{"col_start":0,"col_end":0,"count":0}]},{"line":"  { mutable state : ('init, 'result) state","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":16,"col_end":16,"count":0}]},{"line":"  ; how_to_add : [ `Insert | `Enqueue_back ]","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"  ; queue : ('init, 'result) elt Q.t","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":8,"col_end":8,"count":0}]},{"line":"  ; compare_init : ('init -> 'init -> int) option","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"  ; logger : (Logger.t[@sexp.opaque])","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":9,"col_end":9,"count":0}]},{"line":"  ; weight : 'init -> int","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":9,"col_end":9,"count":0}]},{"line":"  ; max_weight_per_call : int option","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"  ; verifier :","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":11,"col_end":11,"count":0}]},{"line":"         (* The batched verifier may make partial progress on its input so that we can","counters":[]},{"line":"            save time when it is re-verified in a smaller batch in the case that a batch","counters":[]},{"line":"            fails to verify. *)","counters":[]},{"line":"         [ `Init of 'init | `Partially_validated of 'partially_validated ] list","counters":[]},{"line":"      -> [ `Valid of 'result","counters":[]},{"line":"         | Verifier.invalid","counters":[]},{"line":"         | `Potentially_invalid of 'partially_validated ]","counters":[]},{"line":"         list","counters":[]},{"line":"         Deferred.Or_error.t","counters":[]},{"line":"        [@sexp.opaque]","counters":[]},{"line":"  }","counters":[]},{"line":"[@@deriving sexp]","counters":[]},{"line":"","counters":[]},{"line":"let create ?(how_to_add = `Enqueue_back) ?logger ?compare_init","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"    ?(weight = fun _ -> 1) ?max_weight_per_call verifier =","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"  { state = Waiting","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  ; queue = Q.create ()","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"  ; how_to_add","counters":[]},{"line":"  ; compare_init","counters":[]},{"line":"  ; verifier","counters":[]},{"line":"  ; weight","counters":[]},{"line":"  ; max_weight_per_call","counters":[]},{"line":"  ; logger = Option.value logger ~default:(Logger.create ())","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"let call_verifier t (ps : 'proof list) = t.verifier ps","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"","counters":[]},{"line":"(*Worst case (if all the proofs are invalid): log n * (2^(log n) + 1)","counters":[]},{"line":"  In the average case this should show better performance.","counters":[]},{"line":"  We could implement the trusted/untrusted batches from the snark pool batching RFC #4882","counters":[]},{"line":"  to further mitigate possible DoS/DDoS here*)","counters":[]},{"line":"let rec determine_outcome :","counters":[]},{"line":"    type p r partial.","counters":[]},{"line":"       (p, r) elt list","counters":[]},{"line":"    -> [ `Valid of r | `Potentially_invalid of partial | Verifier.invalid ] list","counters":[]},{"line":"    -> (p, partial, r) t","counters":[]},{"line":"    -> unit Deferred.Or_error.t =","counters":[]},{"line":" fun ps res v ->","counters":[]},{"line":"  O1trace.thread \"determining_batcher_outcome\" (fun () ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      (* First separate out all the known results. That information will definitely be included","counters":[]},{"line":"         in the outcome. *)","counters":[]},{"line":"      let potentially_invalid =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        List.filter_map (List.zip_exn ps res) ~f:(fun (elt, r) ->","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"            match r with","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            | `Valid r ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                if Ivar.is_full elt.res then","counters":[]},{"line":"                  [%log' error (Logger.create ())] \"Ivar.fill bug is here 666!\" ;","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"                Ivar.fill elt.res (Ok (Ok r)) ;","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                None","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"            | `Invalid_keys keys ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                if Ivar.is_full elt.res then","counters":[]},{"line":"                  [%log' error (Logger.create ())] \"Ivar.fill bug is here 777!\" ;","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"                Ivar.fill elt.res (Ok (Error (`Invalid_keys keys))) ;","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                None","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"            | `Invalid_signature keys ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                if Ivar.is_full elt.res then","counters":[]},{"line":"                  [%log' error (Logger.create ())] \"Ivar.fill bug is here 888!\" ;","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"                Ivar.fill elt.res (Ok (Error (`Invalid_signature keys))) ;","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                None","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"            | `Invalid_proof ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                if Ivar.is_full elt.res then","counters":[]},{"line":"                  [%log' error (Logger.create ())] \"Ivar.fill bug is here 999!\" ;","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"                Ivar.fill elt.res (Ok (Error `Invalid_proof)) ;","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                None","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"            | `Missing_verification_key keys ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                if Ivar.is_full elt.res then","counters":[]},{"line":"                  [%log' error (Logger.create ())] \"Ivar.fill bug is here AAA!\" ;","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"                Ivar.fill elt.res (Ok (Error (`Missing_verification_key keys))) ;","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                None","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"            | `Potentially_invalid new_hint ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Some (elt, new_hint) )","counters":[]},{"line":"      in","counters":[]},{"line":"      let open Deferred.Or_error.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      match potentially_invalid with","counters":[]},{"line":"      | [] ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (* All results are known *)","counters":[]},{"line":"          return ()","counters":[]},{"line":"      | [ ({ res; _ }, _) ] ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          if Ivar.is_full res then","counters":[]},{"line":"            [%log' error (Logger.create ())] \"Ivar.fill bug is here BBB!\" ;","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"          Ivar.fill res (Ok (Error `Invalid_proof)) ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          (* If there is a potentially invalid proof in this batch of size 1, then","counters":[]},{"line":"             that proof is itself invalid. *)","counters":[]},{"line":"          return ()","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"      | _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let outcome xs =","counters":[]},{"line":"            let%bind res_xs =","counters":[]},{"line":"              call_verifier v","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                (List.map xs ~f:(fun (_e, new_hint) ->","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                     `Partially_validated new_hint ) )","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"            in","counters":[]},{"line":"            determine_outcome (List.map xs ~f:fst) res_xs v","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"          in","counters":[]},{"line":"          let length = List.length potentially_invalid in","counters":[]},{"line":"          let left, right = List.split_n potentially_invalid (length / 2) in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let%bind () = outcome left in","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"          outcome right )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"let compare_elt ~compare t1 t2 =","counters":[]},{"line":"  match compare t1.data t2.data with 0 -> Id.compare t1.id t2.id | x -> x","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"","counters":[]},{"line":"let order_proofs t =","counters":[]},{"line":"  match t.compare_init with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | None ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Fn.id","counters":[]},{"line":"  | Some compare ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      List.sort ~compare:(compare_elt ~compare)","counters":[]},{"line":"","counters":[]},{"line":"(* When new proofs come in put them in the queue.","counters":[]},{"line":"      If state = Waiting, verify those proofs immediately.","counters":[]},{"line":"      Whenever the verifier returns, if the queue is nonempty, flush it into the verifier.","counters":[]},{"line":"*)","counters":[]},{"line":"","counters":[]},{"line":"let rec start_verifier : type proof partial r. (proof, partial, r) t -> unit =","counters":[]},{"line":" fun t ->","counters":[]},{"line":"  O1trace.sync_thread \"running_batcher_verifier_loop\" (fun () ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      if Q.is_empty t.queue then","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (* we looped in the else after verifier finished but no pending work. *)","counters":[]},{"line":"        t.state <- Waiting","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      else (","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"        [%log' debug t.logger] \"Verifying proofs in batch of size $num_proofs\"","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"          ~metadata:[ (\"num_proofs\", `Int (Q.length t.queue)) ] ;","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"        let out_for_verification =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let proofs =","counters":[]},{"line":"            match t.max_weight_per_call with","counters":[]},{"line":"            | None ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                let proofs = Q.to_list t.queue in","counters":[]},{"line":"                Q.clear t.queue ; proofs","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"            | Some max_weight ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                let rec take capacity acc =","counters":[]},{"line":"                  match Q.first t.queue with","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  | None ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      acc","counters":[]},{"line":"                  | Some ({ weight; _ } as proof) ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      if weight <= capacity then (","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"                        ignore (Q.remove_first t.queue : (proof, r) elt option) ;","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"                        take (capacity - weight) (proof :: acc) )","counters":[]},{"line":"                      else acc","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                in","counters":[]},{"line":"                List.rev (take max_weight [])","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"          in","counters":[]},{"line":"          order_proofs t proofs","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"        in","counters":[]},{"line":"        [%log' debug t.logger] \"Calling verifier with $num_proofs on $ids\"","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"          ~metadata:","counters":[]},{"line":"            [ (\"num_proofs\", `Int (List.length out_for_verification))","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"            ; ( \"ids\"","counters":[]},{"line":"              , `List","counters":[]},{"line":"                  (List.map","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                     ~f:(fun { id; _ } -> `Int (Id.to_int_exn id))","counters":[{"col_start":42,"col_end":42,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"                     out_for_verification ) )","counters":[]},{"line":"            ] ;","counters":[]},{"line":"        let res =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          match%bind","counters":[]},{"line":"            call_verifier t","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"              (List.map out_for_verification ~f:(fun { data = p; _ } -> `Init p))","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":72,"col_end":72,"count":0}]},{"line":"          with","counters":[]},{"line":"          | Error e ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Deferred.return (Error e)","counters":[]},{"line":"          | Ok res ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              determine_outcome out_for_verification res t","counters":[]},{"line":"        in","counters":[]},{"line":"        t.state <- Verifying { out_for_verification } ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        upon res (fun r ->","counters":[]},{"line":"            ( match r with","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            | Ok () ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ()","counters":[]},{"line":"            | Error e ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                List.iter out_for_verification ~f:(fun x ->","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                    Ivar.fill_if_empty x.res (Error e) ) ) ;","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"            start_verifier t ) ) )","counters":[]},{"line":"","counters":[]},{"line":"let verify (type p r partial) (t : (p, partial, r) t) (proof : p) :","counters":[]},{"line":"    (r, Verifier.invalid) Result.t Deferred.Or_error.t =","counters":[]},{"line":"  let elt =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    { id = Id.create ()","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"    ; data = proof","counters":[]},{"line":"    ; weight = t.weight proof","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"    ; res = Ivar.create ()","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"    }","counters":[]},{"line":"  in","counters":[]},{"line":"  ignore","counters":[]},{"line":"    ( match (t.how_to_add, t.compare_init) with","counters":[]},{"line":"      | `Enqueue_back, _ | `Insert, None ->","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"          Q.insert_last t.queue elt","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"      | `Insert, Some compare -> (","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (* Find the first element that [proof] is less than *)","counters":[]},{"line":"          let compare = compare_elt ~compare in","counters":[]},{"line":"          match Q.find_elt t.queue ~f:(fun e -> compare elt e < 0) with","counters":[{"col_start":48,"col_end":48,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (* [proof] is greater than all elts in the queue, and so goes in the back. *)","counters":[]},{"line":"              Q.insert_last t.queue elt","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"          | Some succ ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Q.insert_before t.queue succ elt )","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"      : (p, r) elt Q.Elt.t ) ;","counters":[]},{"line":"  (match t.state with Verifying _ -> () | Waiting -> start_verifier t) ;","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":42,"col_end":42,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"  Ivar.read elt.res","counters":[]},{"line":"","counters":[]},{"line":"type ('a, 'b, 'c) batcher = ('a, 'b, 'c) t [@@deriving sexp]","counters":[{"col_start":0,"col_end":0,"count":0}]},{"line":"","counters":[]},{"line":"let compare_envelope (e1 : _ Envelope.Incoming.t) (e2 : _ Envelope.Incoming.t) =","counters":[]},{"line":"  Envelope.Sender.compare e1.sender e2.sender","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"module Transaction_pool = struct","counters":[]},{"line":"  open Mina_base","counters":[]},{"line":"","counters":[]},{"line":"  type diff = User_command.Verifiable.t list Envelope.Incoming.t","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  [@@deriving sexp]","counters":[]},{"line":"","counters":[]},{"line":"  (* A partially verified transaction is either valid, or valid assuming that some list of","counters":[]},{"line":"     (verification key, statement, proof) triples will verify. That is, the transaction has","counters":[]},{"line":"     already been validated in all ways, except the proofs were in a batch that failed to","counters":[]},{"line":"     verify.","counters":[]},{"line":"  *)","counters":[]},{"line":"  type partial_item =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    [ `Valid of User_command.Valid.t","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":16,"col_end":16,"count":0}]},{"line":"    | `Valid_assuming of","counters":[]},{"line":"      User_command.Verifiable.t","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      * ( Pickles.Side_loaded.Verification_key.t","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        * Zkapp_statement.t","counters":[]},{"line":"        * Pickles.Side_loaded.Proof.t )","counters":[]},{"line":"        list ]","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"  [@@deriving sexp]","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"","counters":[]},{"line":"  type partial = partial_item list [@@deriving sexp]","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"  type t = (diff, partial, User_command.Valid.t list) batcher [@@deriving sexp]","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"  type input = [ `Init of diff | `Partially_validated of partial ]","counters":[]},{"line":"","counters":[]},{"line":"  let init_result (ds : input list) =","counters":[]},{"line":"    (* We store a result for every diff in the input. *)","counters":[]},{"line":"    Array.of_list_map ds ~f:(function","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      | `Init d ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (* Initially, the status of all the transactions in a never-before-seen","counters":[]},{"line":"             diff are unknown. *)","counters":[]},{"line":"          `In_progress (Array.of_list_map d.data ~f:(fun _ -> `Unknown))","counters":[{"col_start":40,"col_end":40,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"      | `Partially_validated d ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (* We've seen this diff before, so we have some information about its","counters":[]},{"line":"             transactions. *)","counters":[]},{"line":"          `In_progress","counters":[]},{"line":"            (Array.of_list_map d ~f:(function","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"              | `Valid c ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  `Valid c","counters":[]},{"line":"              | `Valid_assuming x ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  `Valid_assuming x ) ) )","counters":[]},{"line":"","counters":[]},{"line":"  let list_of_array_map a ~f = List.init (Array.length a) ~f:(fun i -> f a.(i))","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":53,"col_end":53,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"","counters":[]},{"line":"  let all_valid a =","counters":[]},{"line":"    Option.all","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (Array.to_list","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"         (Array.map a ~f:(function `Valid c -> Some c | _ -> None)) )","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"","counters":[]},{"line":"  let create verifier : t =","counters":[]},{"line":"    let logger = Logger.create () in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    create ~compare_init:compare_envelope ~logger (fun (ds : input list) ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        O1trace.thread \"dispatching_transaction_pool_batcher_verification\"","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (fun () ->","counters":[]},{"line":"            [%log info]","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"              \"Dispatching $num_proofs transaction pool proofs to verifier\"","counters":[]},{"line":"              ~metadata:[ (\"num_proofs\", `Int (List.length ds)) ] ;","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"            let open Deferred.Or_error.Let_syntax in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let result = init_result ds in","counters":[]},{"line":"            (* Extract all the transactions that have not yet been fully validated and hold on to their","counters":[]},{"line":"               position (diff index, position in diff). *)","counters":[]},{"line":"            let unknowns =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              List.concat_mapi ds ~f:(fun i x ->","counters":[]},{"line":"                  match x with","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  | `Init diff ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      List.mapi diff.data ~f:(fun j c -> ((i, j), c))","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"                  | `Partially_validated partial ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      List.filter_mapi partial ~f:(fun j c ->","counters":[]},{"line":"                          match c with","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                          | `Valid _ ->","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                              None","counters":[]},{"line":"                          | `Valid_assuming (v, _) ->","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                              (* TODO: This rechecks the signatures on snapp transactions... oh well for now *)","counters":[]},{"line":"                              Some ((i, j), v) ) )","counters":[]},{"line":"            in","counters":[]},{"line":"            let%map res =","counters":[]},{"line":"              (* Verify the unknowns *)","counters":[]},{"line":"              Verifier.verify_commands verifier (List.map unknowns ~f:snd)","counters":[{"col_start":37,"col_end":37,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"            in","counters":[]},{"line":"            (* We now iterate over the results of the unknown transactions and appropriately modify","counters":[]},{"line":"               the verification result of the diff that it belongs to. *)","counters":[]},{"line":"            List.iter2_exn unknowns res ~f:(fun ((i, j), v) r ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"                match r with","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                | `Invalid_keys keys ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    (* A diff is invalid is any of the transactions it contains are invalid.","counters":[]},{"line":"                       Invalidate the whole diff that this transaction comes from. *)","counters":[]},{"line":"                    result.(i) <- `Invalid_keys keys","counters":[]},{"line":"                | `Invalid_signature keys ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    (* Invalidate the whole diff *)","counters":[]},{"line":"                    result.(i) <- `Invalid_signature keys","counters":[]},{"line":"                | `Missing_verification_key keys ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    (* Invalidate the whole diff *)","counters":[]},{"line":"                    result.(i) <- `Missing_verification_key keys","counters":[]},{"line":"                | `Invalid_proof ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    (* Invalidate the whole diff *)","counters":[]},{"line":"                    result.(i) <- `Invalid_proof","counters":[]},{"line":"                | `Valid_assuming xs -> (","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    match result.(i) with","counters":[]},{"line":"                    | `Invalid_keys _","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                    | `Invalid_signature _","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                    | `Invalid_proof","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                    | `Missing_verification_key _ ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        (* If this diff has already been declared invalid, knowing that one of its","counters":[]},{"line":"                           transactions is partially valid is not useful. *)","counters":[]},{"line":"                        ()","counters":[]},{"line":"                    | `In_progress a ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        (* The diff may still be valid. *)","counters":[]},{"line":"                        a.(j) <- `Valid_assuming (v, xs) )","counters":[]},{"line":"                | `Valid c -> (","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    (* Similar to the above. *)","counters":[]},{"line":"                    match result.(i) with","counters":[]},{"line":"                    | `Invalid_keys _","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                    | `Invalid_signature _","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                    | `Invalid_proof","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                    | `Missing_verification_key _ ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        ()","counters":[]},{"line":"                    | `In_progress a ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        a.(j) <- `Valid c ) ) ;","counters":[]},{"line":"            list_of_array_map result ~f:(function","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              | `Invalid_keys keys ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  `Invalid_keys keys","counters":[]},{"line":"              | `Invalid_signature keys ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  `Invalid_signature keys","counters":[]},{"line":"              | `Invalid_proof ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  `Invalid_proof","counters":[]},{"line":"              | `Missing_verification_key keys ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  `Missing_verification_key keys","counters":[]},{"line":"              | `In_progress a -> (","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  (* If the diff is all valid, we're done. If not, we return a partial","counters":[]},{"line":"                       result. *)","counters":[]},{"line":"                  match all_valid a with","counters":[]},{"line":"                  | Some res ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      `Valid res","counters":[]},{"line":"                  | None ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      `Potentially_invalid","counters":[]},{"line":"                        (list_of_array_map a ~f:(function","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"                          | `Unknown ->","counters":[]},{"line":"                              assert false","counters":[]},{"line":"                          | `Valid c ->","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                              `Valid c","counters":[]},{"line":"                          | `Valid_assuming (v, xs) ->","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                              `Valid_assuming (v, xs) ) ) ) ) ) )","counters":[]},{"line":"","counters":[]},{"line":"  let verify (t : t) = verify t","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Snark_pool = struct","counters":[]},{"line":"  type proof_envelope =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    (Ledger_proof.t One_or_two.t * Mina_base.Sok_message.t) Envelope.Incoming.t","counters":[{"col_start":5,"col_end":5,"count":0}]},{"line":"  [@@deriving sexp]","counters":[]},{"line":"","counters":[]},{"line":"  (* We don't use partial verification here. *)","counters":[]},{"line":"  type partial = proof_envelope [@@deriving sexp]","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"  type t = (proof_envelope, partial, unit) batcher [@@deriving sexp]","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"  let verify (t : t) (p : proof_envelope) : bool Deferred.Or_error.t =","counters":[]},{"line":"    let open Deferred.Or_error.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    match%map verify t p with Ok () -> true | Error _ -> false","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"","counters":[]},{"line":"  let create verifier : t =","counters":[]},{"line":"    let logger = Logger.create () in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    create","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    (* TODO: Make this a proper config detail once we have data on what a","counters":[]},{"line":"           good default would be.","counters":[]},{"line":"    *)","counters":[]},{"line":"      ~max_weight_per_call:","counters":[]},{"line":"        (Option.value_map ~default:1000 ~f:Int.of_string","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"           (Sys.getenv_opt \"MAX_VERIFIER_BATCH_SIZE\") )","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"      ~compare_init:compare_envelope ~logger","counters":[]},{"line":"      (fun ps0 ->","counters":[]},{"line":"        [%log info] \"Dispatching $num_proofs snark pool proofs to verifier\"","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"          ~metadata:[ (\"num_proofs\", `Int (List.length ps0)) ] ;","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"        let ps =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          List.concat_map ps0 ~f:(function","counters":[]},{"line":"              | `Partially_validated env | `Init env ->","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"              let ps, message = env.data in","counters":[]},{"line":"              One_or_two.map ps ~f:(fun p -> (p, message)) |> One_or_two.to_list )","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"        in","counters":[]},{"line":"        let open Deferred.Or_error.Let_syntax in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let%map result = Verifier.verify_transaction_snarks verifier ps in","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"        match result with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | true ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            List.map ps0 ~f:(fun _ -> `Valid ())","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"        | false ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            List.map ps0 ~f:(function `Partially_validated env | `Init env ->","counters":[{"col_start":38,"col_end":38,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"                `Potentially_invalid env ) )","counters":[]},{"line":"","counters":[]},{"line":"  module Work_key = struct","counters":[]},{"line":"    module T = struct","counters":[]},{"line":"      type t =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (Transaction_snark.Statement.t One_or_two.t * Mina_base.Sok_message.t)","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"        Envelope.Incoming.t","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      [@@deriving sexp, compare]","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    let of_proof_envelope t =","counters":[]},{"line":"      Envelope.Incoming.map t ~f:(fun (ps, message) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          (One_or_two.map ~f:Ledger_proof.statement ps, message) )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"","counters":[]},{"line":"    include T","counters":[]},{"line":"    include Comparable.Make (T)","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let verify' (t : t) ps =","counters":[]},{"line":"    let open Deferred.Or_error.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let%map invalid =","counters":[]},{"line":"      Deferred.Or_error.List.filter_map ps ~f:(fun p ->","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"          match%map verify t p with true -> None | false -> Some p )","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"    in","counters":[]},{"line":"    `Invalid","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (Work_key.Set.of_list (List.map invalid ~f:Work_key.of_proof_envelope))","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"","counters":[]},{"line":"  let%test_module \"With valid and invalid proofs\" =","counters":[]},{"line":"    ( module struct","counters":[]},{"line":"      open Mina_base","counters":[]},{"line":"","counters":[]},{"line":"      let precomputed_values = Lazy.force Precomputed_values.for_unit_tests","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"      let proof_level = precomputed_values.proof_level","counters":[]},{"line":"","counters":[]},{"line":"      let constraint_constants = precomputed_values.constraint_constants","counters":[]},{"line":"","counters":[]},{"line":"      let logger = Logger.null ()","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"      let verifier =","counters":[]},{"line":"        Async.Thread_safe.block_on_async_exn (fun () ->","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"            Verifier.create ~logger ~proof_level ~constraint_constants","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              ~conf_dir:None","counters":[]},{"line":"              ~pids:(Child_processes.Termination.create_pid_table ()) )","counters":[{"col_start":64,"col_end":64,"count":0}]},{"line":"","counters":[]},{"line":"      let gen_proofs =","counters":[]},{"line":"        let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"        let data_gen =","counters":[]},{"line":"          let%bind statements =","counters":[]},{"line":"            One_or_two.gen Transaction_snark.Statement.gen","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%map { fee; prover } = Fee_with_prover.gen in","counters":[]},{"line":"          let message = Mina_base.Sok_message.create ~fee ~prover in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          ( One_or_two.map statements ~f:Ledger_proof.For_tests.mk_dummy_proof","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"          , message )","counters":[]},{"line":"        in","counters":[]},{"line":"        Envelope.Incoming.gen data_gen","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"","counters":[]},{"line":"      let gen_invalid_proofs =","counters":[]},{"line":"        let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"        let data_gen =","counters":[]},{"line":"          let%bind statements =","counters":[]},{"line":"            One_or_two.gen Transaction_snark.Statement.gen","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%bind { fee; prover } = Fee_with_prover.gen in","counters":[]},{"line":"          let%map invalid_prover =","counters":[]},{"line":"            Quickcheck.Generator.filter Signature_lib.Public_key.Compressed.gen","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"              ~f:(Signature_lib.Public_key.Compressed.( <> ) prover)","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"          in","counters":[]},{"line":"          let sok_digest =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Mina_base.Sok_message.(digest (create ~fee ~prover:invalid_prover))","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"          in","counters":[]},{"line":"          let message = Mina_base.Sok_message.create ~fee ~prover in","counters":[]},{"line":"          ( One_or_two.map statements ~f:(fun statement ->","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                Ledger_proof.create ~statement ~sok_digest","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  ~proof:Proof.transaction_dummy )","counters":[]},{"line":"          , message )","counters":[]},{"line":"        in","counters":[]},{"line":"        Envelope.Incoming.gen data_gen","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"","counters":[]},{"line":"      let run_test proof_lists =","counters":[]},{"line":"        let batcher = create verifier in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Deferred.List.iter proof_lists ~f:(fun (invalid_proofs, proof_list) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            let%map r = verify' batcher proof_list in","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"            let (`Invalid ps) = Or_error.ok_exn r in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            assert (Work_key.Set.equal ps invalid_proofs) )","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"      let gen ~(valid_count : [ `Any | `Count of int ])","counters":[]},{"line":"          ~(invalid_count : [ `Any | `Count of int ]) =","counters":[]},{"line":"        let open Quickcheck.Generator.Let_syntax in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let gen_with_count count gen =","counters":[]},{"line":"          match count with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | `Any ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Quickcheck.Generator.list_non_empty gen","counters":[]},{"line":"          | `Count c ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Quickcheck.Generator.list_with_length c gen","counters":[]},{"line":"        in","counters":[]},{"line":"        let invalid_gen = gen_with_count invalid_count gen_invalid_proofs in","counters":[]},{"line":"        let valid_gen = gen_with_count valid_count gen_proofs in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let%map lst =","counters":[]},{"line":"          Quickcheck.Generator.(list (both valid_gen invalid_gen))","counters":[{"col_start":35,"col_end":35,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"        in","counters":[]},{"line":"        List.map lst ~f:(fun (valid, invalid) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            ( Work_key.(Set.of_list (List.map ~f:of_proof_envelope invalid))","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"            , List.permute valid @ invalid ) )","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"      let%test_unit \"all valid proofs\" =","counters":[]},{"line":"        Quickcheck.test ~trials:10","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (gen ~valid_count:`Any ~invalid_count:(`Count 0))","counters":[]},{"line":"          ~f:(fun proof_lists ->","counters":[]},{"line":"            Async.Thread_safe.block_on_async_exn (fun () ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"                run_test proof_lists ) )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"","counters":[]},{"line":"      let%test_unit \"some invalid proofs\" =","counters":[]},{"line":"        Quickcheck.test ~trials:10","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (gen ~valid_count:`Any ~invalid_count:`Any)","counters":[]},{"line":"          ~f:(fun proof_lists ->","counters":[]},{"line":"            Async.Thread_safe.block_on_async_exn (fun () ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"                run_test proof_lists ) )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"","counters":[]},{"line":"      let%test_unit \"all invalid proofs\" =","counters":[]},{"line":"        Quickcheck.test ~trials:10","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (gen ~valid_count:(`Count 0) ~invalid_count:`Any)","counters":[]},{"line":"          ~f:(fun proof_lists ->","counters":[]},{"line":"            Async.Thread_safe.block_on_async_exn (fun () ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"                run_test proof_lists ) )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"    end )","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":1}]}]}