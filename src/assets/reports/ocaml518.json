{"filename":"src/lib/snarky_curves/snarky_curves.ml","lines":[{"line":"module Bignum_bigint = Bigint","counters":[]},{"line":"open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"module type Params_intf = sig","counters":[]},{"line":"  type field","counters":[]},{"line":"","counters":[]},{"line":"  val a : field","counters":[]},{"line":"","counters":[]},{"line":"  val b : field","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type Scalar_intf = sig","counters":[]},{"line":"  type (_, _) typ","counters":[]},{"line":"","counters":[]},{"line":"  type (_, _) checked","counters":[]},{"line":"","counters":[]},{"line":"  type boolean_var","counters":[]},{"line":"","counters":[]},{"line":"  type var","counters":[]},{"line":"","counters":[]},{"line":"  type t [@@deriving equal, sexp]","counters":[]},{"line":"","counters":[]},{"line":"  val typ : (var, t) typ","counters":[]},{"line":"","counters":[]},{"line":"  val length_in_bits : int","counters":[]},{"line":"","counters":[]},{"line":"  val test_bit : t -> int -> bool","counters":[]},{"line":"","counters":[]},{"line":"  module Checked : sig","counters":[]},{"line":"    val equal : var -> var -> (boolean_var, _) checked","counters":[]},{"line":"","counters":[]},{"line":"    module Assert : sig","counters":[]},{"line":"      val equal : var -> var -> (unit, _) checked","counters":[]},{"line":"    end","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type Shifted_intf = sig","counters":[]},{"line":"  type _ checked","counters":[]},{"line":"","counters":[]},{"line":"  type boolean_var","counters":[]},{"line":"","counters":[]},{"line":"  type curve_var","counters":[]},{"line":"","counters":[]},{"line":"  type t","counters":[]},{"line":"","counters":[]},{"line":"  val zero : t","counters":[]},{"line":"","counters":[]},{"line":"  val add : t -> curve_var -> t checked","counters":[]},{"line":"","counters":[]},{"line":"  (* This is only safe if the result is guaranteed to not be zero. *)","counters":[]},{"line":"","counters":[]},{"line":"  val unshift_nonzero : t -> curve_var checked","counters":[]},{"line":"","counters":[]},{"line":"  val if_ : boolean_var -> then_:t -> else_:t -> t checked","counters":[]},{"line":"","counters":[]},{"line":"  module Assert : sig","counters":[]},{"line":"    val equal : t -> t -> unit checked","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type Weierstrass_checked_intf = sig","counters":[]},{"line":"  module Impl : Snarky_backendless.Snark_intf.S","counters":[]},{"line":"","counters":[]},{"line":"  open Impl","counters":[]},{"line":"","counters":[]},{"line":"  type unchecked","counters":[]},{"line":"","counters":[]},{"line":"  type t","counters":[]},{"line":"","counters":[]},{"line":"  val typ : (t, unchecked) Typ.t","counters":[]},{"line":"","counters":[]},{"line":"  module Shifted : sig","counters":[]},{"line":"    module type S =","counters":[]},{"line":"      Shifted_intf","counters":[]},{"line":"        with type 'a checked := 'a Checked.t","counters":[]},{"line":"         and type curve_var := t","counters":[]},{"line":"         and type boolean_var := Boolean.var","counters":[]},{"line":"","counters":[]},{"line":"    type 'a m = (module S with type t = 'a)","counters":[]},{"line":"","counters":[]},{"line":"    val create : unit -> (module S) Checked.t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  val negate : t -> t","counters":[]},{"line":"","counters":[]},{"line":"  val constant : unchecked -> t","counters":[]},{"line":"","counters":[]},{"line":"  val add_unsafe :","counters":[]},{"line":"    t -> t -> [ `I_thought_about_this_very_carefully of t ] Checked.t","counters":[]},{"line":"","counters":[]},{"line":"  val if_ : Boolean.var -> then_:t -> else_:t -> t Checked.t","counters":[]},{"line":"","counters":[]},{"line":"  val double : t -> t Checked.t","counters":[]},{"line":"","counters":[]},{"line":"  val if_value : Boolean.var -> then_:unchecked -> else_:unchecked -> t","counters":[]},{"line":"","counters":[]},{"line":"  val scale :","counters":[]},{"line":"       's Shifted.m","counters":[]},{"line":"    -> t","counters":[]},{"line":"    -> Boolean.var Bitstring_lib.Bitstring.Lsb_first.t","counters":[]},{"line":"    -> init:'s","counters":[]},{"line":"    -> 's Checked.t","counters":[]},{"line":"","counters":[]},{"line":"  val scale_known :","counters":[]},{"line":"       's Shifted.m","counters":[]},{"line":"    -> unchecked","counters":[]},{"line":"    -> Boolean.var Bitstring_lib.Bitstring.Lsb_first.t","counters":[]},{"line":"    -> init:'s","counters":[]},{"line":"    -> 's Checked.t","counters":[]},{"line":"","counters":[]},{"line":"  val sum : 's Shifted.m -> t list -> init:'s -> 's Checked.t","counters":[]},{"line":"","counters":[]},{"line":"  module Assert : sig","counters":[]},{"line":"    val on_curve : t -> unit Checked.t","counters":[]},{"line":"","counters":[]},{"line":"    val equal : t -> t -> unit Checked.t","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make_weierstrass_checked","counters":[]},{"line":"    (F : Snarky_field_extensions.Intf.S) (Scalar : sig","counters":[]},{"line":"      type t","counters":[]},{"line":"","counters":[]},{"line":"      val of_int : int -> t","counters":[]},{"line":"    end) (Curve : sig","counters":[]},{"line":"      type t","counters":[]},{"line":"","counters":[]},{"line":"      val random : unit -> t","counters":[]},{"line":"","counters":[]},{"line":"      val to_affine_exn : t -> F.Unchecked.t * F.Unchecked.t","counters":[]},{"line":"","counters":[]},{"line":"      val of_affine : F.Unchecked.t * F.Unchecked.t -> t","counters":[]},{"line":"","counters":[]},{"line":"      val double : t -> t","counters":[]},{"line":"","counters":[]},{"line":"      val ( + ) : t -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"      val negate : t -> t","counters":[]},{"line":"","counters":[]},{"line":"      val scale : t -> Scalar.t -> t","counters":[]},{"line":"    end)","counters":[]},{"line":"    (Params : Params_intf with type field := F.Unchecked.t) (Override : sig","counters":[]},{"line":"      val add : (F.t * F.t -> F.t * F.t -> (F.t * F.t) F.Impl.Checked.t) option","counters":[]},{"line":"    end) :","counters":[]},{"line":"  Weierstrass_checked_intf","counters":[]},{"line":"    with module Impl := F.Impl","counters":[]},{"line":"     and type unchecked := Curve.t","counters":[]},{"line":"     and type t = F.t * F.t = struct","counters":[]},{"line":"  open F.Impl","counters":[]},{"line":"","counters":[]},{"line":"  type t = F.t * F.t","counters":[]},{"line":"","counters":[]},{"line":"  let assert_on_curve (x, y) =","counters":[]},{"line":"    let open F in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let%bind x2 = square x in","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"    let%bind x3 = x2 * x in","counters":[]},{"line":"    let%bind ax = constant Params.a * x in","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"    assert_square y (x3 + ax + constant Params.b)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"","counters":[]},{"line":"  let typ : (t, Curve.t) Typ.t =","counters":[]},{"line":"    let (Typ unchecked) =","counters":[]},{"line":"      Typ.transport","counters":[]},{"line":"        Typ.(tuple2 F.typ F.typ)","counters":[{"col_start":18,"col_end":18,"count":2}]},{"line":"        ~there:Curve.to_affine_exn ~back:Curve.of_affine","counters":[]},{"line":"    in","counters":[]},{"line":"    Typ","counters":[{"col_start":4,"col_end":4,"count":2}]},{"line":"      { unchecked with check = (fun x -> make_checked_ast (assert_on_curve x)) }","counters":[{"col_start":41,"col_end":41,"count":0},{"col_start":73,"col_end":73,"count":0}]},{"line":"","counters":[]},{"line":"  let negate ((x, y) : t) : t = (x, F.negate y)","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"","counters":[]},{"line":"  let constant (t : Curve.t) : t =","counters":[]},{"line":"    let x, y = Curve.to_affine_exn t in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    F.(constant x, constant y)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":14,"col_end":14,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"","counters":[]},{"line":"  let assert_equal (x1, y1) (x2, y2) =","counters":[]},{"line":"    let%map () = F.assert_equal x1 x2 and () = F.assert_equal y1 y2 in","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"    ()","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  module Assert = struct","counters":[]},{"line":"    let on_curve = assert_on_curve","counters":[]},{"line":"","counters":[]},{"line":"    let equal = assert_equal","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  open Let_syntax","counters":[]},{"line":"","counters":[]},{"line":"  let%snarkydef_ add' ~div (ax, ay) (bx, by) =","counters":[]},{"line":"    let open F in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let%bind lambda = div (by - ay) (bx - ax) in","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"    let%bind cx =","counters":[]},{"line":"      exists typ","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"        ~compute:","counters":[]},{"line":"          (let open As_prover in","counters":[]},{"line":"          let open Let_syntax in","counters":[]},{"line":"          let%map ax = read typ ax","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"          and bx = read typ bx","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"          and lambda = read typ lambda in","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"          Unchecked.(square lambda - (ax + bx)))","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"    in","counters":[]},{"line":"    let%bind () =","counters":[]},{"line":"      (* lambda^2 = cx + ax + bx","counters":[]},{"line":"            cx = lambda^2 - (ax + bc)","counters":[]},{"line":"      *)","counters":[]},{"line":"      assert_square lambda F.(cx + ax + bx)","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"    in","counters":[]},{"line":"    let%bind cy =","counters":[]},{"line":"      exists typ","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"        ~compute:","counters":[]},{"line":"          (let open As_prover in","counters":[]},{"line":"          let open Let_syntax in","counters":[]},{"line":"          let%map ax = read typ ax","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"          and ay = read typ ay","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"          and cx = read typ cx","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"          and lambda = read typ lambda in","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"          Unchecked.((lambda * (ax - cx)) - ay))","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    in","counters":[]},{"line":"    let%map () = assert_r1cs lambda (ax - cx) (cy + ay) in","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"    (cx, cy)","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let add' ~div p1 p2 =","counters":[]},{"line":"    match Override.add with Some add -> add p1 p2 | None -> add' ~div p1 p2","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"","counters":[]},{"line":"  (* This function MUST NOT be called UNLESS you are certain the two points","counters":[]},{"line":"     on which it is called are not equal. If it is called on equal points,","counters":[]},{"line":"     the prover can return almost any curve point they want to from this function. *)","counters":[]},{"line":"  let add_unsafe p q =","counters":[]},{"line":"    let%map r = add' ~div:F.div_unsafe p q in","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"    `I_thought_about_this_very_carefully r","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let add_exn p q = add' ~div:(fun x y -> F.inv_exn y >>= F.(( * ) x)) p q","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":42,"col_end":42,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"","counters":[]},{"line":"  (* TODO-someday: Make it so this doesn't have to compute both branches *)","counters":[]},{"line":"  let if_ b ~then_:(tx, ty) ~else_:(ex, ey) =","counters":[]},{"line":"    let%map x = F.if_ b ~then_:tx ~else_:ex","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"    and y = F.if_ b ~then_:ty ~else_:ey in","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"    (x, y)","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  module Shifted = struct","counters":[]},{"line":"    module type S =","counters":[]},{"line":"      Shifted_intf","counters":[]},{"line":"        with type 'a checked := 'a Checked.t","counters":[]},{"line":"         and type curve_var := t","counters":[]},{"line":"         and type boolean_var := Boolean.var","counters":[]},{"line":"","counters":[]},{"line":"    type 'a m = (module S with type t = 'a)","counters":[]},{"line":"","counters":[]},{"line":"    module Make (M : sig","counters":[]},{"line":"      val shift : t","counters":[]},{"line":"    end) : S = struct","counters":[]},{"line":"      open M","counters":[]},{"line":"","counters":[]},{"line":"      type nonrec t = t","counters":[]},{"line":"","counters":[]},{"line":"      let zero = shift","counters":[]},{"line":"","counters":[]},{"line":"      let if_ = if_","counters":[]},{"line":"","counters":[]},{"line":"      let unshift_nonzero shifted = add_exn (negate shift) shifted","counters":[{"col_start":36,"col_end":36,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"","counters":[]},{"line":"      let add shifted x = add_exn shifted x","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"","counters":[]},{"line":"      module Assert = struct","counters":[]},{"line":"        let equal = assert_equal","counters":[]},{"line":"      end","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    let create () : (module S) Checked.t =","counters":[]},{"line":"      let%map shift =","counters":[]},{"line":"        exists typ ~compute:As_prover.(map (return ()) ~f:Curve.random)","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"      in","counters":[]},{"line":"      let module M = Make (struct","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let shift = shift","counters":[]},{"line":"      end) in","counters":[]},{"line":"      (module M : S)","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let%snarkydef_ double (ax, ay) =","counters":[]},{"line":"    let open F in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let%bind x_squared = square ax in","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"    let%bind lambda =","counters":[]},{"line":"      exists typ","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"        ~compute:","counters":[]},{"line":"          As_prover.(","counters":[]},{"line":"            map2 (read typ x_squared) (read typ ay) ~f:(fun x_squared ay ->","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"                let open F.Unchecked in","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                (x_squared + x_squared + x_squared + Params.a) * inv (ay + ay) ))","counters":[{"col_start":67,"col_end":67,"count":0}]},{"line":"    in","counters":[]},{"line":"    let%bind bx =","counters":[]},{"line":"      exists typ","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"        ~compute:","counters":[]},{"line":"          As_prover.(","counters":[]},{"line":"            map2 (read typ lambda) (read typ ax) ~f:(fun lambda ax ->","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"                let open F.Unchecked in","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                square lambda - (ax + ax) ))","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"    in","counters":[]},{"line":"    let%bind by =","counters":[]},{"line":"      exists typ","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"        ~compute:","counters":[]},{"line":"          (let open As_prover in","counters":[]},{"line":"          let open Let_syntax in","counters":[]},{"line":"          let%map lambda = read typ lambda","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"          and ax = read typ ax","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"          and ay = read typ ay","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"          and bx = read typ bx in","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"          F.Unchecked.((lambda * (ax - bx)) - ay))","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    in","counters":[]},{"line":"    let two = Field.of_int 2 in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let%map () =","counters":[]},{"line":"      assert_r1cs (F.scale lambda two) ay","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"        (F.scale x_squared (Field.of_int 3) + F.constant Params.a)","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"    and () = assert_square lambda (bx + F.scale ax two)","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"    and () = assert_r1cs lambda (ax - bx) (by + ay) in","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"    (bx, by)","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let if_value (cond : Boolean.var) ~then_ ~else_ =","counters":[]},{"line":"    let x1, y1 = Curve.to_affine_exn then_ in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let x2, y2 = Curve.to_affine_exn else_ in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let cond = (cond :> Field.Var.t) in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let choose a1 a2 =","counters":[]},{"line":"      let open Field.Checked in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      F.map2_ a1 a2 ~f:(fun a1 a2 ->","counters":[]},{"line":"          (a1 * cond) + (a2 * (Field.Var.constant Field.one - cond)) )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"    in","counters":[]},{"line":"    (choose x1 x2, choose y1 y2)","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"","counters":[]},{"line":"  let%snarkydef_ scale (type shifted)","counters":[]},{"line":"      (module Shifted : Shifted.S with type t = shifted) t","counters":[]},{"line":"      (c : Boolean.var Bitstring_lib.Bitstring.Lsb_first.t) ~(init : shifted) :","counters":[]},{"line":"      shifted Checked.t =","counters":[]},{"line":"    let c = Bitstring_lib.Bitstring.Lsb_first.to_list c in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let open Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let rec go i bs0 acc pt =","counters":[]},{"line":"      match bs0 with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | [] ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          return acc","counters":[]},{"line":"      | b :: bs ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let%bind acc' =","counters":[]},{"line":"            with_label (sprintf \"acc_%d\" i) (fun () ->","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"                let%bind add_pt = Shifted.add acc pt in","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"                let don't_add_pt = acc in","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                Shifted.if_ b ~then_:add_pt ~else_:don't_add_pt )","counters":[]},{"line":"          and pt' = double pt in","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"          go (i + 1) bs acc' pt'","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    in","counters":[]},{"line":"    go 0 c init t","counters":[]},{"line":"","counters":[]},{"line":"  (* This 'looks up' a field element from a lookup table of size 2^2 = 4 with","counters":[]},{"line":"     a 2 bit index.  See https://github.com/zcash/zcash/issues/2234#issuecomment-383736266 for","counters":[]},{"line":"     a discussion of this trick.","counters":[]},{"line":"  *)","counters":[]},{"line":"  let lookup_point (b0, b1) (t1, t2, t3, t4) =","counters":[]},{"line":"    let%map b0_and_b1 = Boolean.( && ) b0 b1 in","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"    let lookup_one (a1, a2, a3, a4) =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let open F.Unchecked in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let ( * ) x b = F.map_ x ~f:(fun x -> Field.Var.scale b x) in","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"      let ( +^ ) = F.( + ) in","counters":[]},{"line":"      F.constant a1","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"      +^ ((a2 - a1) * (b0 :> Field.Var.t))","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"      +^ ((a3 - a1) * (b1 :> Field.Var.t))","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"      +^ ((a4 + a1 - a2 - a3) * (b0_and_b1 :> Field.Var.t))","counters":[]},{"line":"    in","counters":[]},{"line":"    let x1, y1 = Curve.to_affine_exn t1","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"    and x2, y2 = Curve.to_affine_exn t2","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"    and x3, y3 = Curve.to_affine_exn t3","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"    and x4, y4 = Curve.to_affine_exn t4 in","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"    (lookup_one (x1, x2, x3, x4), lookup_one (y1, y2, y3, y4))","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"","counters":[]},{"line":"  (* Similar to the above, but doing lookup in a size 1 table *)","counters":[]},{"line":"  let lookup_single_bit (b : Boolean.var) (t1, t2) =","counters":[]},{"line":"    let lookup_one (a1, a2) =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let open F in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      constant a1","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"      + map_ Unchecked.(a2 - a1) ~f:(Field.Var.scale (b :> Field.Var.t))","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"    in","counters":[]},{"line":"    let x1, y1 = Curve.to_affine_exn t1 and x2, y2 = Curve.to_affine_exn t2 in","counters":[{"col_start":35,"col_end":35,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"    (lookup_one (x1, x2), lookup_one (y1, y2))","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"  let scale_known (type shifted)","counters":[]},{"line":"      (module Shifted : Shifted.S with type t = shifted) (t : Curve.t)","counters":[]},{"line":"      (b : Boolean.var Bitstring_lib.Bitstring.Lsb_first.t) ~init =","counters":[]},{"line":"    let b = Bitstring_lib.Bitstring.Lsb_first.to_list b in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let sigma = t in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let n = List.length b in","counters":[]},{"line":"    let sigma_count = (n + 1) / 2 in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"    (* = ceil (n / 2.0) *)","counters":[]},{"line":"    (* We implement a complicated optimzation so that in total","counters":[]},{"line":"       this costs roughly (1 + 3) * (n / 2) constraints, rather than","counters":[]},{"line":"       the naive 4*n + 3*n. If scalars were represented with some","counters":[]},{"line":"       kind of signed digit representation we could probably get it","counters":[]},{"line":"       down to 2 * (n / 3) + 3 * (n / 3).","counters":[]},{"line":"    *)","counters":[]},{"line":"    (* Assume n is even *)","counters":[]},{"line":"    (* Define","counters":[]},{"line":"       to_term_unshifted i (b0, b1) =","counters":[]},{"line":"       match b0, b1 with","counters":[]},{"line":"       | false, false -> oo","counters":[]},{"line":"       | true, false -> 2^i * t","counters":[]},{"line":"       | false, true -> 2^{i+1} * t","counters":[]},{"line":"       | true, true -> 2^i * t + 2^{i + 1} t","counters":[]},{"line":"","counters":[]},{"line":"       to_term i (b0, b1) =","counters":[]},{"line":"       sigma + to_term_unshifted i (b0, b1) =","counters":[]},{"line":"       match b0, b1 with","counters":[]},{"line":"       | false, false -> sigma","counters":[]},{"line":"       | true, false -> sigma + 2^i * t","counters":[]},{"line":"       | false, true -> sigma + 2^{i+1} * t","counters":[]},{"line":"       | true, true -> sigma + 2^i * t + 2^{i + 1} t","counters":[]},{"line":"    *)","counters":[]},{"line":"    let to_term ~two_to_the_i ~two_to_the_i_plus_1 bits =","counters":[]},{"line":"      lookup_point bits","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ( sigma","counters":[]},{"line":"        , Curve.(sigma + two_to_the_i)","counters":[]},{"line":"        , Curve.(sigma + two_to_the_i_plus_1)","counters":[]},{"line":"        , Curve.(sigma + two_to_the_i + two_to_the_i_plus_1) )","counters":[]},{"line":"    in","counters":[]},{"line":"","counters":[]},{"line":"    (*","counters":[]},{"line":"       Say b = b0, b1, .., b_{n-1}.","counters":[]},{"line":"       We compute","counters":[]},{"line":"","counters":[]},{"line":"       (to_term 0 (b0, b1)","counters":[]},{"line":"       + to_term 2 (b2, b3)","counters":[]},{"line":"       + to_term 4 (b4, b5)","counters":[]},{"line":"       + ...","counters":[]},{"line":"       + to_term (n-2) (b_{n-2}, b_{n-1}))","counters":[]},{"line":"       - (n/2) * sigma","counters":[]},{"line":"       =","counters":[]},{"line":"       (n/2)*sigma + (b0*2^0 + b1*21 + ... + b_{n-1}*2^{n-1}) t - (n/2) * sigma","counters":[]},{"line":"       =","counters":[]},{"line":"       (n/2)*sigma + b * t - (n/2)*sigma","counters":[]},{"line":"       = b * t","counters":[]},{"line":"    *)","counters":[]},{"line":"    let open Let_syntax in","counters":[]},{"line":"    (* TODO #1152","counters":[]},{"line":"        Can get away with using an unsafe add if we modify this a bit. *)","counters":[]},{"line":"    let rec go acc two_to_the_i bits =","counters":[]},{"line":"      match bits with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | [] ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          return acc","counters":[]},{"line":"      | [ b_i ] ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let term =","counters":[]},{"line":"            lookup_single_bit b_i (sigma, Curve.(sigma + two_to_the_i))","counters":[]},{"line":"          in","counters":[]},{"line":"          Shifted.add acc term","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"      | b_i :: b_i_plus_1 :: rest ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let two_to_the_i_plus_1 = Curve.double two_to_the_i in","counters":[]},{"line":"          let%bind term =","counters":[]},{"line":"            to_term ~two_to_the_i ~two_to_the_i_plus_1 (b_i, b_i_plus_1)","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%bind acc = Shifted.add acc term in","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"          go acc (Curve.double two_to_the_i_plus_1) rest","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"    in","counters":[]},{"line":"    let%bind result_with_shift = go init t b in","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"    let unshift =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Curve.scale (Curve.negate sigma) (Scalar.of_int sigma_count)","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"    in","counters":[]},{"line":"    Shifted.add result_with_shift (constant unshift)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"","counters":[]},{"line":"  let to_constant (x, y) =","counters":[]},{"line":"    let open Option.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let%map x = F.to_constant x and y = F.to_constant y in","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"    Curve.of_affine (x, y)","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let scale m t c ~init =","counters":[]},{"line":"    match to_constant t with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Some t ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        scale_known m t c ~init","counters":[]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        scale m t c ~init","counters":[]},{"line":"","counters":[]},{"line":"  let sum (type shifted) (module Shifted : Shifted.S with type t = shifted) xs","counters":[]},{"line":"      ~init =","counters":[]},{"line":"    let open Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let rec go acc = function","counters":[]},{"line":"      | [] ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          return acc","counters":[]},{"line":"      | t :: ts ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let%bind acc' = Shifted.add acc t in","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"          go acc' ts","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    in","counters":[]},{"line":"    go init xs","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}