{"filename":"src/lib/pickles/plonk_curve_ops.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"open Kimchi_backend_common.Plonk_constraint_system.Plonk_constraint","counters":[]},{"line":"","counters":[]},{"line":"let seal i = Tuple_lib.Double.map ~f:(Util.seal i)","counters":[{"col_start":13,"col_end":13,"count":3},{"col_start":46,"col_end":46,"count":3}]},{"line":"","counters":[]},{"line":"let add_fast (type f)","counters":[]},{"line":"    (module Impl : Snarky_backendless.Snark_intf.Run with type field = f)","counters":[]},{"line":"    ?(check_finite = true) ((x1, y1) as p1) ((x2, y2) as p2) :","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"    Impl.Field.t * Impl.Field.t =","counters":[]},{"line":"  let p1 = seal (module Impl) p1 in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let p2 = seal (module Impl) p2 in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let open Impl in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let open Field.Constant in","counters":[]},{"line":"  let bool b = if b then one else zero in","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"  let eq a b = As_prover.(equal (read_var a) (read_var b)) in","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"  let same_x_bool = lazy (eq x1 x2) in","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"  let ( ! ) = Lazy.force in","counters":[]},{"line":"  let ( !! ) = As_prover.read_var in","counters":[]},{"line":"  let mk f = exists Field.typ ~compute:f in","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"  let same_x = mk (fun () -> bool !same_x_bool) in","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"  let inf =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    if check_finite then Field.zero","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"    else mk (fun () -> bool (!same_x_bool && not (eq y1 y2)))","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":10,"col_end":10,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"  in","counters":[]},{"line":"  let inf_z =","counters":[]},{"line":"    mk (fun () ->","counters":[]},{"line":"        if eq y1 y2 then zero","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"        else if !same_x_bool then inv (!!y2 - !!y1)","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"        else zero )","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"  in","counters":[]},{"line":"  let x21_inv =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    mk (fun () -> if !same_x_bool then zero else inv (!!x2 - !!x1))","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":49,"col_end":49,"count":0},{"col_start":55,"col_end":55,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"  in","counters":[]},{"line":"  let s =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    mk (fun () ->","counters":[]},{"line":"        if !same_x_bool then","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let x1_squared = square !!x1 in","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"          let y1 = !!y1 in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          (x1_squared + x1_squared + x1_squared) / (y1 + y1)","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        else (!!y2 - !!y1) / (!!x2 - !!x1) )","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"  in","counters":[]},{"line":"  let x3 = mk (fun () -> square !!s - (!!x1 + !!x2)) in","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"  let y3 = mk (fun () -> (!!s * (!!x1 - !!x3)) - !!y1) in","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"  let p3 = (x3, y3) in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  with_label \"add_fast\" (fun () ->","counters":[]},{"line":"      assert_","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { annotation = Some __LOC__","counters":[]},{"line":"        ; basic =","counters":[]},{"line":"            Kimchi_backend_common.Plonk_constraint_system.Plonk_constraint.T","counters":[]},{"line":"              (EC_add_complete","counters":[]},{"line":"                 { p1; p2; p3; inf; same_x; slope = s; inf_z; x21_inv } )","counters":[]},{"line":"        } ;","counters":[]},{"line":"      p3 )","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"module Make","counters":[]},{"line":"    (Impl : Snarky_backendless.Snark_intf.Run)","counters":[]},{"line":"    (G : Intf.Group(Impl).S with type t = Impl.Field.t * Impl.Field.t) =","counters":[]},{"line":"struct","counters":[]},{"line":"  open Impl","counters":[]},{"line":"","counters":[]},{"line":"  let seal = seal (module Impl)","counters":[{"col_start":16,"col_end":16,"count":3}]},{"line":"","counters":[]},{"line":"  let add_fast = add_fast (module Impl)","counters":[{"col_start":24,"col_end":24,"count":3}]},{"line":"","counters":[]},{"line":"  let bits_per_chunk = 5","counters":[]},{"line":"","counters":[]},{"line":"  (* Number of chunks needed to cover the given number of bits. *)","counters":[]},{"line":"  let chunks_needed ~num_bits =","counters":[]},{"line":"    (num_bits + (bits_per_chunk - 1)) / bits_per_chunk","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let scale_fast_msb_bits base","counters":[]},{"line":"      (Pickles_types.Shifted_value.Type1.Shifted_value","counters":[]},{"line":"        (bits_msb : Boolean.var array) ) : Field.t * Field.t =","counters":[]},{"line":"    let ((x_base, y_base) as base) = seal base in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let ( !! ) = As_prover.read_var in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let mk f = exists Field.typ ~compute:f in","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"    (* MSB bits *)","counters":[]},{"line":"    let num_bits = Array.length bits_msb in","counters":[]},{"line":"    let chunks = num_bits / bits_per_chunk in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    [%test_eq: int] (num_bits mod bits_per_chunk) 0 ;","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"    let acc = ref (add_fast base base) in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"    let n_acc = ref Field.zero in","counters":[]},{"line":"    let rounds_rev = ref [] in","counters":[]},{"line":"    for chunk = 0 to chunks - 1 do","counters":[]},{"line":"      let open Field.Constant in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let double x = x + x in","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"      let bs =","counters":[]},{"line":"        Array.init bits_per_chunk ~f:(fun i ->","counters":[]},{"line":"            (bits_msb.(Int.((chunk * bits_per_chunk) + i)) :> Field.t) )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"      in","counters":[]},{"line":"      let n_acc_prev = !n_acc in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      n_acc :=","counters":[]},{"line":"        mk (fun () ->","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"            Array.fold bs ~init:!!n_acc_prev ~f:(fun acc b -> double acc + !!b) ) ;","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":62,"col_end":62,"count":0},{"col_start":67,"col_end":67,"count":0},{"col_start":76,"col_end":76,"count":0}]},{"line":"      let accs, slopes =","counters":[]},{"line":"        Array.fold_map bs ~init:!acc ~f:(fun (x_acc, y_acc) b ->","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"            let s1 =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              mk (fun () ->","counters":[]},{"line":"                  (!!y_acc - (!!y_base * (double !!b - one)))","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":47,"col_end":47,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"                  / (!!x_acc - !!x_base) )","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"            in","counters":[]},{"line":"            let s1_squared = mk (fun () -> square !!s1) in","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":43,"col_end":43,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"            let s2 =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              mk (fun () ->","counters":[]},{"line":"                  (double !!y_acc / (double !!x_acc + !!x_base - !!s1_squared))","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":42,"col_end":42,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":55,"col_end":55,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"                  - !!s1 )","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"            in","counters":[]},{"line":"            let x_res = mk (fun () -> !!x_base + square !!s2 - !!s1_squared) in","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":54,"col_end":54,"count":0},{"col_start":57,"col_end":57,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"            let y_res = mk (fun () -> ((!!x_acc - !!x_res) * !!s2) - !!y_acc) in","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":51,"col_end":51,"count":0},{"col_start":62,"col_end":62,"count":0},{"col_start":70,"col_end":70,"count":0}]},{"line":"            let acc' = (x_res, y_res) in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            (acc', (acc', s1)) )","counters":[]},{"line":"        |> snd |> Array.unzip","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"      in","counters":[]},{"line":"      let accs = Array.append [| !acc |] accs in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      acc := Array.last accs ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"      rounds_rev :=","counters":[]},{"line":"        { Kimchi_backend_common.Scale_round.accs","counters":[]},{"line":"        ; bits = bs","counters":[]},{"line":"        ; ss = slopes","counters":[]},{"line":"        ; n_prev = n_acc_prev","counters":[]},{"line":"        ; n_next = !n_acc","counters":[]},{"line":"        ; base","counters":[]},{"line":"        }","counters":[]},{"line":"        :: !rounds_rev","counters":[]},{"line":"    done ;","counters":[]},{"line":"    assert_","counters":[]},{"line":"      { annotation = Some __LOC__","counters":[]},{"line":"      ; basic =","counters":[]},{"line":"          Kimchi_backend_common.Plonk_constraint_system.Plonk_constraint.T","counters":[]},{"line":"            (EC_scale { state = Array.of_list_rev !rounds_rev })","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"      } ;","counters":[]},{"line":"    (* TODO: Return n_acc ? *)","counters":[]},{"line":"    !acc","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  (*","counters":[]},{"line":"     Computes","counters":[]},{"line":"","counters":[]},{"line":"     fun (g, t) -> (2 * t + 1 + 2^len(t)) g *)","counters":[]},{"line":"  let scale_fast_unpack base","counters":[]},{"line":"      (Pickles_types.Shifted_value.Type1.Shifted_value (scalar : Field.t))","counters":[]},{"line":"      ~num_bits : (Field.t * Field.t) * Boolean.var array =","counters":[]},{"line":"    let ((x_base, y_base) as base) = seal base in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let ( !! ) = As_prover.read_var in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let mk f = exists Field.typ ~compute:f in","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"    (* MSB bits *)","counters":[]},{"line":"    (*","counters":[]},{"line":"    let num_bits = Field.size_in_bits in *)","counters":[]},{"line":"    let chunks = num_bits / bits_per_chunk in","counters":[]},{"line":"    [%test_eq: int] (num_bits mod bits_per_chunk) 0 ;","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"    let bits_msb =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      exists (Typ.array ~length:num_bits Field.typ) ~compute:(fun () ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"          let open Field.Constant in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          unpack !!scalar |> Fn.flip List.take num_bits","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"          |> Array.of_list_rev_map ~f:(fun b -> if b then one else zero) )","counters":[{"col_start":48,"col_end":48,"count":0},{"col_start":58,"col_end":58,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"    in","counters":[]},{"line":"    let acc = ref (add_fast base base) in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"    let n_acc = ref Field.zero in","counters":[]},{"line":"    let rounds_rev = ref [] in","counters":[]},{"line":"    for chunk = 0 to chunks - 1 do","counters":[]},{"line":"      let open Field.Constant in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let double x = x + x in","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"      let bs =","counters":[]},{"line":"        Array.init bits_per_chunk ~f:(fun i ->","counters":[]},{"line":"            bits_msb.(Int.((chunk * bits_per_chunk) + i)) )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"      in","counters":[]},{"line":"      let n_acc_prev = !n_acc in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      n_acc :=","counters":[]},{"line":"        mk (fun () ->","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"            Array.fold bs ~init:!!n_acc_prev ~f:(fun acc b -> double acc + !!b) ) ;","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":62,"col_end":62,"count":0},{"col_start":67,"col_end":67,"count":0},{"col_start":76,"col_end":76,"count":0}]},{"line":"      let accs, slopes =","counters":[]},{"line":"        Array.fold_map bs ~init:!acc ~f:(fun (x_acc, y_acc) b ->","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"            let s1 =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              mk (fun () ->","counters":[]},{"line":"                  (!!y_acc - (!!y_base * (double !!b - one)))","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":47,"col_end":47,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"                  / (!!x_acc - !!x_base) )","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"            in","counters":[]},{"line":"            let s1_squared = mk (fun () -> square !!s1) in","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":43,"col_end":43,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"            let s2 =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              mk (fun () ->","counters":[]},{"line":"                  (double !!y_acc / (double !!x_acc + !!x_base - !!s1_squared))","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":42,"col_end":42,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":55,"col_end":55,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"                  - !!s1 )","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"            in","counters":[]},{"line":"            let x_res = mk (fun () -> !!x_base + square !!s2 - !!s1_squared) in","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":54,"col_end":54,"count":0},{"col_start":57,"col_end":57,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"            let y_res = mk (fun () -> ((!!x_acc - !!x_res) * !!s2) - !!y_acc) in","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":51,"col_end":51,"count":0},{"col_start":62,"col_end":62,"count":0},{"col_start":70,"col_end":70,"count":0}]},{"line":"            let acc' = (x_res, y_res) in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            (acc', (acc', s1)) )","counters":[]},{"line":"        |> snd |> Array.unzip","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"      in","counters":[]},{"line":"      let accs = Array.append [| !acc |] accs in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      acc := Array.last accs ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"      rounds_rev :=","counters":[]},{"line":"        { Kimchi_backend_common.Scale_round.accs","counters":[]},{"line":"        ; bits = bs","counters":[]},{"line":"        ; ss = slopes","counters":[]},{"line":"        ; n_prev = n_acc_prev","counters":[]},{"line":"        ; n_next = !n_acc","counters":[]},{"line":"        ; base","counters":[]},{"line":"        }","counters":[]},{"line":"        :: !rounds_rev","counters":[]},{"line":"    done ;","counters":[]},{"line":"    assert_","counters":[]},{"line":"      { annotation = Some __LOC__","counters":[]},{"line":"      ; basic =","counters":[]},{"line":"          Kimchi_backend_common.Plonk_constraint_system.Plonk_constraint.T","counters":[]},{"line":"            (EC_scale { state = Array.of_list_rev !rounds_rev })","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"      } ;","counters":[]},{"line":"    Field.Assert.equal !n_acc scalar ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let bits_lsb =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let bs = Array.map bits_msb ~f:Boolean.Unsafe.of_cvar in","counters":[]},{"line":"      Array.rev_inplace bs ; bs","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"    in","counters":[]},{"line":"    (!acc, bits_lsb)","counters":[]},{"line":"","counters":[]},{"line":"  let scale_fast_unpack base scalar ~num_bits :","counters":[]},{"line":"      (Field.t * Field.t) * Boolean.var array =","counters":[]},{"line":"    with_label \"scale_fast_unpack\" (fun () ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        scale_fast_unpack base scalar ~num_bits )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"  let scale_fast base s ~num_bits =","counters":[]},{"line":"    let r, _bits = scale_fast_unpack base s ~num_bits in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    r","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  module type Scalar_field_intf = sig","counters":[]},{"line":"    module Constant : sig","counters":[]},{"line":"      include Plonk_checks.Field_intf","counters":[]},{"line":"","counters":[]},{"line":"      val to_bigint : t -> Impl.Bigint.t","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    type t = Field.t","counters":[]},{"line":"","counters":[]},{"line":"    val typ : (t, Constant.t) Typ.t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  (* Computes","counters":[]},{"line":"","counters":[]},{"line":"     (g, s) -> (s + 2^{len(s) - 1})","counters":[]},{"line":"","counters":[]},{"line":"     as","counters":[]},{"line":"","counters":[]},{"line":"     let h = scale_fast g (s >> 1) in","counters":[]},{"line":"     if s is odd then h else h - g","counters":[]},{"line":"     ==","counters":[]},{"line":"     let h = [ 2 * (s >> 1) + 1 + 2^{len(s) - 1} ] * g in","counters":[]},{"line":"     if s is odd then h else h - g","counters":[]},{"line":"","counters":[]},{"line":"     since if s is odd, then s = 2 * (s >> 1) + 1, and otherwise,","counters":[]},{"line":"     s = 2 * (s >> 1) + 1 - 1.","counters":[]},{"line":"  *)","counters":[]},{"line":"  let scale_fast2 (g : G.t)","counters":[]},{"line":"      (Pickles_types.Shifted_value.Type2.Shifted_value","counters":[]},{"line":"        ((s_div_2 : Field.t), (s_odd : Boolean.var)) ) ~(num_bits : int) : G.t =","counters":[]},{"line":"    let s_div_2_bits = num_bits - 1 in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    (* The number of chunks need for scaling by s_div_2. *)","counters":[]},{"line":"    let chunks_needed = chunks_needed ~num_bits:s_div_2_bits in","counters":[]},{"line":"    let actual_bits_used = chunks_needed * bits_per_chunk in","counters":[]},{"line":"    let h, bits_lsb =","counters":[]},{"line":"      scale_fast_unpack g (Shifted_value s_div_2) ~num_bits:actual_bits_used","counters":[]},{"line":"    in","counters":[]},{"line":"    (* Constrain the top bits of s_div_2 to be 0. *)","counters":[]},{"line":"    with_label __LOC__ (fun () ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        for i = s_div_2_bits to Array.length bits_lsb - 1 do","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"          Field.Assert.equal Field.zero (bits_lsb.(i) :> Field.t)","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"        done ) ;","counters":[]},{"line":"    with_label __LOC__ (fun () ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        G.if_ s_odd ~then_:h ~else_:(add_fast h (G.negate g)) )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"","counters":[]},{"line":"  let scale_fast2' (type scalar_field)","counters":[]},{"line":"      (module Scalar_field : Scalar_field_intf","counters":[]},{"line":"        with type Constant.t = scalar_field ) g (s : Scalar_field.t) ~num_bits =","counters":[]},{"line":"    let ((s_div_2, s_odd) as s_parts) =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      with_label __LOC__ (fun () ->","counters":[]},{"line":"          exists","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Typ.(Scalar_field.typ * Boolean.typ)","counters":[]},{"line":"            ~compute:","counters":[]},{"line":"              As_prover.(","counters":[]},{"line":"                fun () ->","counters":[]},{"line":"                  let s = read Scalar_field.typ s in","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  let open Scalar_field.Constant in","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  let s_odd = Bigint.test_bit (to_bigint s) 0 in","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"                  ((if s_odd then s - one else s) / of_int 2, s_odd)) )","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":47,"col_end":47,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"    in","counters":[]},{"line":"","counters":[]},{"line":"    (* In this case, it's safe to use this field to compute","counters":[]},{"line":"","counters":[]},{"line":"       2 s_div_2 + b","counters":[]},{"line":"","counters":[]},{"line":"       in the other field. *)","counters":[]},{"line":"    with_label __LOC__ (fun () ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        Field.Assert.equal Field.((of_int 2 * s_div_2) + (s_odd :> Field.t)) s ) ;","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"    scale_fast2 g (Shifted_value s_parts) ~num_bits","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let scale_fast a b = with_label __LOC__ (fun () -> scale_fast a b)","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"","counters":[]},{"line":"  let%test_module \"curve_ops\" =","counters":[]},{"line":"    ( module struct","counters":[]},{"line":"      module T = Internal_Basic","counters":[]},{"line":"","counters":[]},{"line":"      let random_point =","counters":[]},{"line":"        let rec pt x =","counters":[]},{"line":"          let y2 = G.Params.(T.Field.(b + (x * (a + (x * x))))) in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          if T.Field.is_square y2 then (x, T.Field.sqrt y2)","counters":[{"col_start":39,"col_end":39,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"          else pt T.Field.(x + one)","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"        in","counters":[]},{"line":"        G.Constant.of_affine (pt (T.Field.of_int 0))","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"","counters":[]},{"line":"      let n = Field.size_in_bits","counters":[]},{"line":"","counters":[]},{"line":"      let%test_unit \"scale fast 2\" =","counters":[]},{"line":"        Quickcheck.test ~trials:5 Field.Constant.gen ~f:(fun s ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            let input =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let s_odd = T.Bigint.test_bit (T.Bigint.of_field s) 0 in","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"              Field.Constant.((if s_odd then s - one else s) / of_int 2, s_odd)","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":58,"col_end":58,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"            in","counters":[]},{"line":"            T.Test.test_equal ~equal:G.Constant.equal","counters":[]},{"line":"              ~sexp_of_t:G.Constant.sexp_of_t","counters":[]},{"line":"              (Typ.tuple2 G.typ (Typ.tuple2 Field.typ Boolean.typ))","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"              G.typ","counters":[]},{"line":"              (fun (g, s) ->","counters":[]},{"line":"                make_checked (fun () ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                    scale_fast2 ~num_bits:n g (Shifted_value s) ) )","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"              (fun (g, _) ->","counters":[]},{"line":"                let x =","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  let chunks_needed = chunks_needed ~num_bits:(n - 1) in","counters":[]},{"line":"                  let actual_bits_used = chunks_needed * bits_per_chunk in","counters":[]},{"line":"                  Pickles_types.Pcs_batch.pow ~one:G.Constant.Scalar.one","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"                    ~mul:G.Constant.Scalar.( * )","counters":[]},{"line":"                    G.Constant.Scalar.(of_int 2)","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"                    actual_bits_used","counters":[]},{"line":"                  |> G.Constant.Scalar.( + )","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"                       (G.Constant.Scalar.project (Field.Constant.unpack s))","counters":[{"col_start":48,"col_end":48,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"                in","counters":[]},{"line":"                G.Constant.scale g x )","counters":[]},{"line":"              (random_point, input) )","counters":[]},{"line":"","counters":[]},{"line":"      let%test_unit \"scale fast\" =","counters":[]},{"line":"        let open Pickles_types in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let shift =","counters":[]},{"line":"          Shifted_value.Type1.Shift.create (module G.Constant.Scalar)","counters":[]},{"line":"        in","counters":[]},{"line":"        Quickcheck.test ~trials:10","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Quickcheck.Generator.(","counters":[]},{"line":"            map (list_with_length n Bool.quickcheck_generator) ~f:(fun bs ->","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"                Field.Constant.project bs |> Field.Constant.unpack ))","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"          ~f:(fun xs ->","counters":[]},{"line":"            try","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              T.Test.test_equal ~equal:G.Constant.equal","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                ~sexp_of_t:G.Constant.sexp_of_t","counters":[]},{"line":"                (Typ.tuple2 G.typ (Typ.list ~length:n Boolean.typ))","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"                G.typ","counters":[]},{"line":"                (fun (g, s) ->","counters":[]},{"line":"                  make_checked (fun () ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                      scale_fast ~num_bits:n g (Shifted_value (Field.project s)) )","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":75,"col_end":75,"count":0}]},{"line":"                  )","counters":[]},{"line":"                (fun (g, s) ->","counters":[]},{"line":"                  let open G.Constant.Scalar in","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  let s = project s in","counters":[]},{"line":"                  let x =","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    Shifted_value.Type1.to_field","counters":[]},{"line":"                      (module G.Constant.Scalar)","counters":[]},{"line":"                      ~shift (Shifted_value s)","counters":[]},{"line":"                  in","counters":[]},{"line":"                  G.Constant.scale g x )","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                (random_point, xs)","counters":[]},{"line":"            with e ->","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"              eprintf !\"Input %{sexp: bool list}\\n%!\" xs ;","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"              raise e )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"    end )","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}