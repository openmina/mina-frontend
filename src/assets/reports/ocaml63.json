{"filename":"src/lib/interruptible/interruptible.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Async_kernel","counters":[]},{"line":"","counters":[]},{"line":"module T = struct","counters":[]},{"line":"  type ('a, 's) t =","counters":[]},{"line":"    { interruption_signal : 's Ivar.t; d : ('a, 's) Deferred.Result.t }","counters":[]},{"line":"","counters":[]},{"line":"  let map_signal t ~f =","counters":[]},{"line":"    let interruption_signal =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      match Ivar.peek t.interruption_signal with","counters":[]},{"line":"      | Some signal ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Ivar.create_full (f signal)","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"      | None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let interruption_signal = Ivar.create () in","counters":[]},{"line":"          Deferred.upon (Ivar.read t.interruption_signal) (fun signal ->","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"              Ivar.fill_if_empty interruption_signal (f signal) ) ;","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"          interruption_signal","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    in","counters":[]},{"line":"    { interruption_signal; d = Deferred.Result.map_error ~f t.d }","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"","counters":[]},{"line":"  let map t ~f =","counters":[]},{"line":"    match Ivar.peek t.interruption_signal with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (* Note: we do not shortcut if [t.d] has resolved, otherwise the","counters":[]},{"line":"           interruption signal cannot interrupt this function.","counters":[]},{"line":"        *)","counters":[]},{"line":"        let d =","counters":[]},{"line":"          let%map res =","counters":[]},{"line":"            Deferred.choose","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"              [ Deferred.choice (Ivar.read t.interruption_signal) Result.fail","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"              ; Deferred.choice t.d Fn.id","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"              ]","counters":[]},{"line":"          in","counters":[]},{"line":"          (* If the interruption signal fires between [t.d] resolving and the","counters":[]},{"line":"             scheduler running this code to call [f], we prefer the signal and","counters":[]},{"line":"             avoid running [f].","counters":[]},{"line":"          *)","counters":[]},{"line":"          match Ivar.peek t.interruption_signal with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Result.map ~f res","counters":[]},{"line":"          | Some e ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Error e","counters":[]},{"line":"        in","counters":[]},{"line":"        { interruption_signal = t.interruption_signal; d }","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    | Some e ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (* The interruption signal has already triggered, resolve to the","counters":[]},{"line":"           signal's value.","counters":[]},{"line":"        *)","counters":[]},{"line":"        { interruption_signal = t.interruption_signal","counters":[]},{"line":"        ; d = Deferred.Result.fail e","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"  let bind t ~f =","counters":[]},{"line":"    let t : (('a, 's) t, 's) t = map ~f t in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"    (* Propagate the signal into the [Interruptible.t] returned by [bind]. *)","counters":[]},{"line":"    Deferred.upon (Ivar.read t.interruption_signal) (fun signal ->","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"        Deferred.upon t.d (function","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          | Ok t' ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Ivar.fill_if_empty t'.interruption_signal signal","counters":[]},{"line":"          | Error _ ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              () ) ) ;","counters":[]},{"line":"    let interruption_signal =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      match Ivar.peek t.interruption_signal with","counters":[]},{"line":"      | Some interruption_signal ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Ivar.create_full interruption_signal","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"      | None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let interruption_signal = Ivar.create () in","counters":[]},{"line":"          Deferred.upon t.d (function","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            | Ok t' ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Deferred.upon","counters":[]},{"line":"                  (Ivar.read t'.interruption_signal)","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                  (Ivar.fill_if_empty interruption_signal)","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"            | Error signal ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (* [t] was interrupted by [signal], [f] was not run. *)","counters":[]},{"line":"                Ivar.fill_if_empty interruption_signal signal ) ;","counters":[]},{"line":"          interruption_signal","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    in","counters":[]},{"line":"    Deferred.upon (Ivar.read interruption_signal) (fun signal ->","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"        match Deferred.peek t.d with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | Some (Ok t') ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (* The computation [t] which we bound over has resolved, don't","counters":[]},{"line":"               interrupt it in case some other values also depend on it.","counters":[]},{"line":"               Still interrupt [t'] because it's a consequence of this [bind].","counters":[]},{"line":"            *)","counters":[]},{"line":"            Ivar.fill_if_empty t'.interruption_signal signal","counters":[]},{"line":"        | Some (Error _) ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (* Already interrupted, do nothing. *)","counters":[]},{"line":"            ()","counters":[]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (* The computation we bound hasn't resolved, interrupt it. *)","counters":[]},{"line":"            Ivar.fill_if_empty t.interruption_signal signal ) ;","counters":[]},{"line":"    { interruption_signal; d = Deferred.Result.bind t.d ~f:(fun t' -> t'.d) }","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":50,"col_end":50,"count":0},{"col_start":70,"col_end":70,"count":0}]},{"line":"","counters":[]},{"line":"  let return a =","counters":[]},{"line":"    { interruption_signal = Ivar.create (); d = Deferred.Result.return a }","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"","counters":[]},{"line":"  let don't_wait_for { d; _ } =","counters":[]},{"line":"    don't_wait_for @@ Deferred.map d ~f:(function Ok () -> () | Error _ -> ())","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":50,"col_end":50,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"","counters":[]},{"line":"  let finally t ~f =","counters":[]},{"line":"    { interruption_signal = t.interruption_signal","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    ; d = Deferred.map t.d ~f:(fun r -> f () ; r)","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let uninterruptible d =","counters":[]},{"line":"    { interruption_signal = Ivar.create ()","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"    ; d = Deferred.map d ~f:(fun x -> Ok x)","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let lift d interrupt =","counters":[]},{"line":"    let interruption_signal = Ivar.create () in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Deferred.upon interrupt (Ivar.fill_if_empty interruption_signal) ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"    { interruption_signal; d = Deferred.map d ~f:(fun x -> Ok x) }","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":42,"col_end":42,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"","counters":[]},{"line":"  let force t =","counters":[]},{"line":"    (* We use [map] here to prefer interrupt signals even where the underlying","counters":[]},{"line":"       value has been resolved.","counters":[]},{"line":"    *)","counters":[]},{"line":"    (map ~f:Fn.id t).d","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":7,"col_end":7,"count":0}]},{"line":"","counters":[]},{"line":"  let map = `Define_using_bind","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module M = Monad.Make2 (T)","counters":[]},{"line":"include T","counters":[]},{"line":"include M","counters":[]},{"line":"","counters":[]},{"line":"module Result = struct","counters":[]},{"line":"  type nonrec ('a, 'b, 's) t = (('a, 'b) Result.t, 's) t","counters":[]},{"line":"","counters":[]},{"line":"  include Monad.Make3 (struct","counters":[]},{"line":"    type nonrec ('a, 'b, 's) t = ('a, 'b, 's) t","counters":[]},{"line":"","counters":[]},{"line":"    let bind x ~f =","counters":[]},{"line":"      x >>= function Ok y -> f y | Error err -> return (Error err)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"    let map = `Define_using_bind","counters":[]},{"line":"","counters":[]},{"line":"    let return x = return (Result.return x)","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"  end)","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Or_error = struct","counters":[]},{"line":"  type nonrec ('a, 's) t = ('a Or_error.t, 's) t","counters":[]},{"line":"","counters":[]},{"line":"  include (","counters":[]},{"line":"    Result :","counters":[]},{"line":"      module type of Result with type ('a, 'b, 's) t := ('a, 'b, 's) Result.t )","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Deferred_let_syntax = struct","counters":[]},{"line":"  module Let_syntax = struct","counters":[]},{"line":"    let return = return","counters":[]},{"line":"","counters":[]},{"line":"    let bind x ~f = bind (uninterruptible x) ~f","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"    let map x ~f = map (uninterruptible x) ~f","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"","counters":[]},{"line":"    let both x y =","counters":[]},{"line":"      Let_syntax.Let_syntax.both (uninterruptible x) (uninterruptible y)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":48,"col_end":48,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"","counters":[]},{"line":"    module Open_on_rhs = Deferred.Let_syntax","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let%test_unit \"monad gets interrupted\" =","counters":[]},{"line":"  Run_in_thread.block_on_async_exn (fun () ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      let r = ref 0 in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let wait i = after (Time_ns.Span.of_ms i) in","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"      let ivar = Ivar.create () in","counters":[]},{"line":"      don't_wait_for","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (let open Let_syntax in","counters":[]},{"line":"        let%bind () = lift Deferred.unit (Ivar.read ivar) in","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"        let%bind () = uninterruptible (wait 100.) in","counters":[{"col_start":36,"col_end":36,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"        incr r ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let%map () = uninterruptible (wait 100.) in","counters":[{"col_start":35,"col_end":35,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"        incr r) ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      let open Deferred.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%bind () = wait 130. in","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"      Ivar.fill ivar () ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%map () = wait 100. in","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"      assert (!r = 1) )","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"let%test_unit \"monad gets interrupted within nested binds\" =","counters":[]},{"line":"  Run_in_thread.block_on_async_exn (fun () ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      let r = ref 0 in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let wait i = after (Time_ns.Span.of_ms i) in","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"      let ivar = Ivar.create () in","counters":[]},{"line":"      let rec go () =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let open Let_syntax in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let%bind () = uninterruptible (wait 100.) in","counters":[{"col_start":36,"col_end":36,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"        incr r ; go ()","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"      in","counters":[]},{"line":"      don't_wait_for","counters":[]},{"line":"        (let open Let_syntax in","counters":[]},{"line":"        let%bind () = lift Deferred.unit (Ivar.read ivar) in","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"        go ()) ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      let open Deferred.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%bind () = wait 130. in","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"      Ivar.fill ivar () ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%map () = wait 100. in","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"      assert (!r = 1) )","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"let%test_unit \"interruptions still run finally blocks\" =","counters":[]},{"line":"  Run_in_thread.block_on_async_exn (fun () ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      let r = ref 0 in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let wait i = after (Time_ns.Span.of_ms i) in","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"      let ivar = Ivar.create () in","counters":[]},{"line":"      let rec go () =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let open Let_syntax in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let%bind () = uninterruptible (wait 100.) in","counters":[{"col_start":36,"col_end":36,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"        incr r ; go ()","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"      in","counters":[]},{"line":"      don't_wait_for","counters":[]},{"line":"        (let open Let_syntax in","counters":[]},{"line":"        let%bind () = lift Deferred.unit (Ivar.read ivar) in","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"        finally (go ()) ~f:(fun () -> incr r)) ;","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"      let open Deferred.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%bind () = wait 130. in","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"      Ivar.fill ivar () ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%map () = wait 100. in","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"      assert (!r = 2) )","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"let%test_unit \"interruptions branches do not cancel each other\" =","counters":[]},{"line":"  Run_in_thread.block_on_async_exn (fun () ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      let r = ref 0 in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let s = ref 0 in","counters":[]},{"line":"      let wait i = after (Time_ns.Span.of_ms i) in","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"      let ivar_r = Ivar.create () in","counters":[]},{"line":"      let ivar_s = Ivar.create () in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let rec go r =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let open Let_syntax in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let%bind () = uninterruptible (wait 100.) in","counters":[{"col_start":36,"col_end":36,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"        incr r ; go r","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"      in","counters":[]},{"line":"      (* Both computations hang off [start]. *)","counters":[]},{"line":"      let start = uninterruptible Deferred.unit in","counters":[]},{"line":"      don't_wait_for","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (let open Let_syntax in","counters":[]},{"line":"        let%bind () = start in","counters":[]},{"line":"        let%bind () = lift Deferred.unit (Ivar.read ivar_r) in","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"        go r) ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      don't_wait_for","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (let open Let_syntax in","counters":[]},{"line":"        let%bind () = start in","counters":[]},{"line":"        let%bind () = lift Deferred.unit (Ivar.read ivar_s) in","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"        go s) ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      let open Deferred.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%bind () = wait 130. in","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"      Ivar.fill ivar_r () ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%bind () = wait 100. in","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"      Ivar.fill ivar_s () ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%map () = wait 100. in","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"      assert (!r = 1) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":13,"col_end":13,"count":0}]},{"line":"      assert (!s = 2) )","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":22,"col_end":22,"count":2}]}]}