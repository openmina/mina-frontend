{"filename":"src/lib/base58_check/base58_check.ml","lines":[{"line":"(* base58_check.ml : implement Base58Check algorithm","counters":[]},{"line":"   see: https://www.oreilly.com/library/view/mastering-bitcoin-2nd/9781491954379/ch04.html#base58","counters":[]},{"line":"   also: https://datatracker.ietf.org/doc/html/draft-msporny-base58-03","counters":[]},{"line":"","counters":[]},{"line":"   the algorithm is modified for long strings, to apply encoding on chunks of the input","counters":[]},{"line":"*)","counters":[]},{"line":"","counters":[{"col_start":0,"col_end":0,"count":1}]},{"line":"open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"exception Invalid_base58_checksum of string","counters":[]},{"line":"","counters":[]},{"line":"exception Invalid_base58_version_byte of (char * string)","counters":[]},{"line":"","counters":[]},{"line":"exception Invalid_base58_check_length of string","counters":[]},{"line":"","counters":[]},{"line":"exception Invalid_base58_character of string","counters":[]},{"line":"","counters":[]},{"line":"(* same as Bitcoin alphabet *)","counters":[]},{"line":"let mina_alphabet =","counters":[]},{"line":"  B58.make_alphabet \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"","counters":[{"col_start":18,"col_end":18,"count":1}]},{"line":"","counters":[]},{"line":"let version_len = 1","counters":[]},{"line":"","counters":[]},{"line":"let checksum_len = 4","counters":[]},{"line":"","counters":[]},{"line":"module Make (M : sig","counters":[]},{"line":"  val description : string","counters":[]},{"line":"","counters":[]},{"line":"  val version_byte : char","counters":[]},{"line":"end) =","counters":[]},{"line":"struct","counters":[]},{"line":"  let version_byte = M.version_byte","counters":[]},{"line":"","counters":[]},{"line":"  let version_string = String.make 1 version_byte","counters":[{"col_start":33,"col_end":33,"count":23}]},{"line":"","counters":[]},{"line":"  let max_length = 8192","counters":[]},{"line":"","counters":[]},{"line":"  let compute_checksum payload =","counters":[]},{"line":"    (* double-hash using SHA256 *)","counters":[]},{"line":"    let open Digestif.SHA256 in","counters":[{"col_start":4,"col_end":4,"count":2}]},{"line":"    let ctx0 = init () in","counters":[]},{"line":"    let ctx1 = feed_string ctx0 version_string in","counters":[{"col_start":4,"col_end":4,"count":2}]},{"line":"    let ctx2 = feed_string ctx1 payload in","counters":[{"col_start":4,"col_end":4,"count":2}]},{"line":"    let first_hash = get ctx2 |> to_raw_string in","counters":[{"col_start":4,"col_end":4,"count":2},{"col_start":33,"col_end":33,"count":2}]},{"line":"    let ctx3 = feed_string ctx0 first_hash in","counters":[{"col_start":4,"col_end":4,"count":2}]},{"line":"    let second_hash = get ctx3 |> to_raw_string in","counters":[{"col_start":4,"col_end":4,"count":2},{"col_start":34,"col_end":34,"count":2}]},{"line":"    second_hash |> String.sub ~pos:0 ~len:checksum_len","counters":[{"col_start":4,"col_end":4,"count":2}]},{"line":"","counters":[]},{"line":"  (* we don't name this with _exn, we don't expect to raise an exception","counters":[]},{"line":"     if we do, we're encoding types that shouldn't be encoded","counters":[]},{"line":"  *)","counters":[]},{"line":"  let encode payload =","counters":[]},{"line":"    let len = String.length payload in","counters":[{"col_start":4,"col_end":4,"count":2}]},{"line":"    if len > max_length then","counters":[{"col_start":4,"col_end":4,"count":2}]},{"line":"      failwithf","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":14,"col_end":14,"count":0}]},{"line":"        \"String is too long (%d bytes) to Base58Check-encode, max length is %d\"","counters":[]},{"line":"        len max_length () ;","counters":[]},{"line":"    let checksum = compute_checksum payload in","counters":[{"col_start":4,"col_end":4,"count":2}]},{"line":"    let bytes = version_string ^ payload ^ checksum |> Bytes.of_string in","counters":[{"col_start":4,"col_end":4,"count":2}]},{"line":"    B58.encode mina_alphabet bytes |> Bytes.to_string","counters":[{"col_start":4,"col_end":4,"count":2},{"col_start":38,"col_end":38,"count":2}]},{"line":"","counters":[]},{"line":"  let decode_exn s =","counters":[]},{"line":"    let bytes = Bytes.of_string s in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let decoded =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      try B58.decode mina_alphabet bytes |> Bytes.to_string","counters":[{"col_start":44,"col_end":44,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"      with B58.Invalid_base58_character ->","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"        raise (Invalid_base58_character M.description)","counters":[]},{"line":"    in","counters":[]},{"line":"    let len = String.length decoded in","counters":[]},{"line":"    (* input must be at least as long as the version byte and checksum *)","counters":[]},{"line":"    if len < version_len + checksum_len then","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      raise (Invalid_base58_check_length M.description) ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    let checksum =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      String.sub decoded","counters":[]},{"line":"        ~pos:(String.length decoded - checksum_len)","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"        ~len:checksum_len","counters":[]},{"line":"    in","counters":[]},{"line":"    let payload =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      String.sub decoded ~pos:1 ~len:(len - version_len - checksum_len)","counters":[]},{"line":"    in","counters":[]},{"line":"    if not (String.equal checksum (compute_checksum payload)) then","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"      raise (Invalid_base58_checksum M.description) ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    if not (Char.equal decoded.[0] version_byte) then","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"      raise (Invalid_base58_version_byte (decoded.[0], M.description)) ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    payload","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let decode s =","counters":[]},{"line":"    let error_str e desc =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      sprintf \"Error decoding %s\\nInvalid base58 %s in %s\" s e desc","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    in","counters":[]},{"line":"    try Ok (decode_exn s) with","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"    | Invalid_base58_character str ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Or_error.error_string (error_str \"character\" str)","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"    | Invalid_base58_check_length str ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Or_error.error_string (error_str \"check length\" str)","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"    | Invalid_base58_checksum str ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Or_error.error_string (error_str \"checksum\" str)","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"    | Invalid_base58_version_byte (ch, str) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Or_error.error_string","counters":[]},{"line":"          (error_str","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"             (sprintf \"version byte \\\\x%02X, expected \\\\x%02X\" (Char.to_int ch)","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":74,"col_end":74,"count":0}]},{"line":"                (Char.to_int version_byte) )","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"             str )","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Version_bytes = Version_bytes","counters":[]},{"line":"","counters":[]},{"line":"let%test_module \"base58check tests\" =","counters":[]},{"line":"  ( module struct","counters":[]},{"line":"    module Base58_check = Make (struct","counters":[]},{"line":"      let description = \"Base58check tests\"","counters":[]},{"line":"","counters":[]},{"line":"      let version_byte = '\\x53'","counters":[]},{"line":"    end)","counters":[]},{"line":"","counters":[]},{"line":"    open Base58_check","counters":[]},{"line":"","counters":[]},{"line":"    let test_roundtrip payload =","counters":[]},{"line":"      let encoded = encode payload in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let payload' = decode_exn encoded in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      String.equal payload payload'","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let%test \"empty_string\" = test_roundtrip \"\"","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"","counters":[]},{"line":"    let%test \"nonempty_string\" =","counters":[]},{"line":"      test_roundtrip \"Somewhere, over the rainbow, way up high\"","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let%test \"longer_string\" =","counters":[]},{"line":"      test_roundtrip","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        \"Someday, I wish upon a star, wake up where the clouds are far behind \\","counters":[]},{"line":"         me, where trouble melts like lemon drops, High above the chimney top, \\","counters":[]},{"line":"         that's where you'll find me\"","counters":[]},{"line":"","counters":[]},{"line":"    let%test \"invalid checksum\" =","counters":[]},{"line":"      try","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let encoded = encode \"Bluer than velvet were her eyes\" in","counters":[]},{"line":"        let bytes = Bytes.of_string encoded in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let len = Bytes.length bytes in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let last_ch = Bytes.get bytes (len - 1) in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        (* change last byte to invalidate checksum *)","counters":[]},{"line":"        let new_last_ch =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          if Char.equal last_ch '\\xFF' then '\\x00'","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"          else Char.of_int_exn (Char.to_int last_ch + 1)","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"        in","counters":[]},{"line":"        Bytes.set bytes (len - 1) new_last_ch ;","counters":[]},{"line":"        let encoded_bad_checksum = Bytes.to_string bytes in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let _payload = decode_exn encoded_bad_checksum in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        false","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      with Invalid_base58_checksum _ -> true","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"","counters":[]},{"line":"    let%test \"invalid length\" =","counters":[]},{"line":"      try","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let _payload = decode_exn \"abcd\" in","counters":[]},{"line":"        false","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      with Invalid_base58_check_length _ -> true","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"  end )","counters":[{"col_start":6,"col_end":6,"count":1}]}]}