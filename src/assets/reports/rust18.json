{"filename":"src/staged_ledger/pre_diff_info.rs","lines":[{"line":"use std::collections::HashMap;","counters":[]},{"line":"","counters":[]},{"line":"use mina_signer::CompressedPubKey;","counters":[]},{"line":"","counters":[]},{"line":"use crate::{","counters":[]},{"line":"    scan_state::{","counters":[]},{"line":"        currency::{Amount, Fee, Magnitude},","counters":[]},{"line":"        scan_state::{group_list, transaction_snark::work, ConstraintConstants},","counters":[]},{"line":"        transaction_logic::{","counters":[]},{"line":"            valid, Coinbase, CoinbaseFeeTransfer, FeeTransfer, GenericCommand, GenericTransaction,","counters":[]},{"line":"            SingleFeeTransfer, Transaction, TransactionStatus, UserCommand, WithStatus,","counters":[]},{"line":"        },","counters":[]},{"line":"    },","counters":[]},{"line":"    verifier::VerifierError,","counters":[]},{"line":"    TokenId,","counters":[]},{"line":"};","counters":[]},{"line":"","counters":[]},{"line":"use super::diff::{self, with_valid_signatures_and_proofs, PreDiffOne, PreDiffTwo};","counters":[]},{"line":"","counters":[]},{"line":"#[derive(Debug)]","counters":[{"col_start":9,"col_end":10,"count":0},{"col_start":13,"col_end":14,"count":0}]},{"line":"pub enum PreDiffError {","counters":[]},{"line":"    VerificationFailed(VerifierError),","counters":[]},{"line":"    CoinbaseError(String),","counters":[]},{"line":"    InsufficientFee((Fee, Fee)),","counters":[]},{"line":"    InternalCommandStatusMismatch,","counters":[]},{"line":"    Unexpected(String),","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl From<VerifierError> for PreDiffError {","counters":[]},{"line":"    fn from(value: VerifierError) -> Self {","counters":[{"col_start":4,"col_end":43,"count":0}]},{"line":"        Self::VerificationFailed(value)","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl From<String> for PreDiffError {","counters":[]},{"line":"    fn from(value: String) -> Self {","counters":[{"col_start":4,"col_end":36,"count":0}]},{"line":"        Self::Unexpected(value)","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"// type t =","counters":[]},{"line":"//   | Verification_failed of Verifier.Failure.t","counters":[]},{"line":"//   | Coinbase_error of string","counters":[]},{"line":"//   | Insufficient_fee of Currency.Fee.t * Currency.Fee.t","counters":[]},{"line":"//   | Internal_command_status_mismatch","counters":[]},{"line":"//   | Unexpected of Error.t","counters":[]},{"line":"// [@@deriving sexp]","counters":[]},{"line":"","counters":[]},{"line":"struct PreDiffInfo<T> {","counters":[]},{"line":"    transactions: Vec<WithStatus<T>>,","counters":[]},{"line":"    work: Vec<work::Work>,","counters":[]},{"line":"    commands_count: usize,","counters":[]},{"line":"    coinbases: Vec<Amount>,","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl<T> PreDiffInfo<T> {","counters":[]},{"line":"    fn empty() -> Self {","counters":[{"col_start":4,"col_end":24,"count":0}]},{"line":"        Self {","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"            transactions: Vec::new(),","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"            work: Vec::new(),","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"            commands_count: 0,","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"            coinbases: Vec::new(),","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"enum CoinbaseParts {","counters":[]},{"line":"    Zero,","counters":[]},{"line":"    One(Option<CoinbaseFeeTransfer>),","counters":[]},{"line":"    Two(Option<(CoinbaseFeeTransfer, Option<CoinbaseFeeTransfer>)>),","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"/// A Coinbase is a single transaction that accommodates the coinbase amount","counters":[]},{"line":"/// and a fee transfer for the work required to add the coinbase. It also","counters":[]},{"line":"/// contains the state body hash corresponding to a particular protocol state.","counters":[]},{"line":"/// Unlike a transaction, a coinbase (including the fee transfer) just requires one slot","counters":[]},{"line":"/// in the jobs queue.","counters":[]},{"line":"/// The minimum number of slots required to add a single transaction is three (at","counters":[]},{"line":"/// worst case number of provers: when each pair of proofs is from a different","counters":[]},{"line":"/// prover). One slot for the transaction and two slots for fee transfers.","counters":[]},{"line":"/// When the diff is split into two prediffs (why? refer to #687) and if after","counters":[]},{"line":"/// adding transactions, the first prediff has two slots remaining which cannot","counters":[]},{"line":"/// not accommodate transactions, then those slots are filled by splitting the","counters":[]},{"line":"/// coinbase into two parts.","counters":[]},{"line":"/// If it has one slot, then we simply add one coinbase. It is also possible that","counters":[]},{"line":"/// the first prediff may have no slots left after adding transactions (for","counters":[]},{"line":"/// example, when there are three slots and maximum number of provers), in which case,","counters":[]},{"line":"/// we simply add one coinbase as part of the second prediff.","counters":[]},{"line":"///","counters":[]},{"line":"/// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/staged_ledger/pre_diff_info.ml#L95","counters":[]},{"line":"fn create_coinbase(","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"    constraint_constants: &ConstraintConstants,","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"    coinbase_parts: CoinbaseParts,","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"    receiver: &CompressedPubKey,","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"    coinbase_amount: Amount,","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":") -> Result<Vec<Coinbase>, PreDiffError> {","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"    let coinbase_or_error = |cb: Result<Coinbase, String>| -> Result<Coinbase, PreDiffError> {","counters":[{"col_start":0,"col_end":25,"count":0},{"col_start":93,"col_end":94,"count":0}]},{"line":"        cb.map_err(PreDiffError::CoinbaseError)","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"    };","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    let underflow_err = |a1: Amount, a2: Amount| {","counters":[{"col_start":8,"col_end":21,"count":0},{"col_start":49,"col_end":50,"count":0}]},{"line":"        a1.checked_sub(&a2).ok_or_else(|| {","counters":[{"col_start":0,"col_end":39,"count":0},{"col_start":42,"col_end":43,"count":0}]},{"line":"            PreDiffError::CoinbaseError(format!(","counters":[{"col_start":0,"col_end":48,"count":0}]},{"line":"                \"underflow when splitting coinbase: Minuend: {:?} Subtrahend: {:?}\",","counters":[{"col_start":0,"col_end":84,"count":0}]},{"line":"                a1, a2","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"            ))","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"        })","counters":[{"col_start":0,"col_end":9,"count":0},{"col_start":9,"col_end":10,"count":0}]},{"line":"    };","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    let two_parts = |amt: Amount,","counters":[{"col_start":8,"col_end":20,"count":0}]},{"line":"                     ft1: Option<CoinbaseFeeTransfer>,","counters":[]},{"line":"                     ft2: Option<CoinbaseFeeTransfer>|","counters":[]},{"line":"     -> Result<Vec<Coinbase>, PreDiffError> {","counters":[{"col_start":44,"col_end":45,"count":0}]},{"line":"        let rem_coinbase = underflow_err(coinbase_amount, amt)?;","counters":[{"col_start":12,"col_end":24,"count":0},{"col_start":27,"col_end":62,"count":0},{"col_start":62,"col_end":63,"count":0}]},{"line":"","counters":[]},{"line":"        let ft2_amount = ft2","counters":[{"col_start":12,"col_end":28,"count":0}]},{"line":"            .as_ref()","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"            .map(|ft| Amount::of_fee(&ft.fee))","counters":[{"col_start":0,"col_end":17,"count":0},{"col_start":22,"col_end":45,"count":0},{"col_start":45,"col_end":46,"count":0}]},{"line":"            .unwrap_or_else(Amount::zero);","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"        underflow_err(rem_coinbase, ft2_amount)?;","counters":[{"col_start":0,"col_end":47,"count":0},{"col_start":47,"col_end":48,"count":0}]},{"line":"","counters":[]},{"line":"        let cb1 = coinbase_or_error(Coinbase::create(amt, receiver.clone(), ft1))?;","counters":[{"col_start":12,"col_end":15,"count":0},{"col_start":18,"col_end":81,"count":0},{"col_start":81,"col_end":82,"count":0}]},{"line":"        let cb2 = coinbase_or_error(Coinbase::create(rem_coinbase, receiver.clone(), ft2))?;","counters":[{"col_start":12,"col_end":15,"count":0},{"col_start":18,"col_end":90,"count":0},{"col_start":90,"col_end":91,"count":0}]},{"line":"","counters":[]},{"line":"        Ok(vec![cb1, cb2])","counters":[{"col_start":8,"col_end":26,"count":0}]},{"line":"    };","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    let coinbases = match coinbase_parts {","counters":[{"col_start":8,"col_end":17,"count":0},{"col_start":26,"col_end":40,"count":0}]},{"line":"        CoinbaseParts::Zero => vec![],","counters":[{"col_start":31,"col_end":37,"count":0}]},{"line":"        CoinbaseParts::One(x) => vec![coinbase_or_error(Coinbase::create(","counters":[{"col_start":27,"col_end":73,"count":0}]},{"line":"            coinbase_amount,","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"            receiver.clone(),","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"            x,","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"        ))?],","counters":[{"col_start":0,"col_end":10,"count":0},{"col_start":10,"col_end":11,"count":0}]},{"line":"        CoinbaseParts::Two(None) => two_parts(","counters":[{"col_start":36,"col_end":46,"count":0}]},{"line":"            Amount::of_fee(&constraint_constants.account_creation_fee),","counters":[{"col_start":0,"col_end":71,"count":0}]},{"line":"            None,","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"            None,","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"        )?,","counters":[{"col_start":0,"col_end":9,"count":0},{"col_start":9,"col_end":10,"count":0}]},{"line":"        CoinbaseParts::Two(Some((ft1, ft2))) => {","counters":[{"col_start":33,"col_end":41,"count":0}]},{"line":"            let fee = constraint_constants","counters":[{"col_start":16,"col_end":19,"count":0},{"col_start":22,"col_end":42,"count":0}]},{"line":"                .account_creation_fee","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"                .checked_add(&ft1.fee)","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"                .ok_or_else(|| {","counters":[{"col_start":0,"col_end":28,"count":0},{"col_start":31,"col_end":32,"count":0}]},{"line":"                    PreDiffError::CoinbaseError(format!(","counters":[{"col_start":0,"col_end":56,"count":0}]},{"line":"                        \"Overflow when trying to add account_creation_fee \\","counters":[{"col_start":0,"col_end":75,"count":0}]},{"line":"                     {:?} to a fee transfer {:?}\",","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"                        constraint_constants.account_creation_fee, ft1.fee,","counters":[{"col_start":0,"col_end":75,"count":0}]},{"line":"                    ))","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"                })?;","counters":[{"col_start":0,"col_end":17,"count":0},{"col_start":17,"col_end":18,"count":0},{"col_start":18,"col_end":19,"count":0}]},{"line":"","counters":[]},{"line":"            two_parts(Amount::of_fee(&fee), Some(ft1), ft2)?","counters":[{"col_start":12,"col_end":59,"count":0},{"col_start":59,"col_end":60,"count":0}]},{"line":"        }","counters":[]},{"line":"    };","counters":[]},{"line":"","counters":[]},{"line":"    Ok(coinbases)","counters":[{"col_start":4,"col_end":17,"count":0}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"/// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/staged_ledger/pre_diff_info.ml#L166","counters":[]},{"line":"/// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/staged_ledger/staged_ledger.ml#446","counters":[]},{"line":"pub fn sum_fees<'a, I, T: 'a, F>(fees: I, fun: F) -> Result<Fee, String>","counters":[{"col_start":0,"col_end":72,"count":0}]},{"line":"where","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"    I: IntoIterator<Item = &'a T>,","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"    F: Fn(&'a T) -> Fee,","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"{","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"    fees.into_iter()","counters":[{"col_start":0,"col_end":20,"count":0}]},{"line":"        .try_fold(Fee::zero(), |accum, elem| accum.checked_add(&fun(elem)))","counters":[{"col_start":0,"col_end":31,"count":0},{"col_start":45,"col_end":74,"count":0},{"col_start":74,"col_end":75,"count":0}]},{"line":"        .ok_or_else(|| \"Fee overflow\".to_string())","counters":[{"col_start":0,"col_end":20,"count":0},{"col_start":23,"col_end":49,"count":0},{"col_start":49,"col_end":50,"count":0}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"/// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/staged_ledger/pre_diff_info.ml#L179","counters":[]},{"line":"fn fee_remainder<'a, Cmd>(","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"    commands: &[WithStatus<Cmd>],","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"    completed_works: impl IntoIterator<Item = &'a work::Unchecked>,","counters":[{"col_start":0,"col_end":67,"count":0}]},{"line":"    coinbase_fee: Fee,","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":") -> Result<Fee, PreDiffError>","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"where","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"    Cmd: GenericCommand,","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"{","counters":[{"col_start":0,"col_end":0,"count":0},{"col_start":0,"col_end":0,"count":0}]},{"line":"    let budget = sum_fees(commands, |v| v.data.fee())?;","counters":[{"col_start":8,"col_end":14,"count":0},{"col_start":17,"col_end":36,"count":0},{"col_start":40,"col_end":52,"count":0},{"col_start":52,"col_end":53,"count":0},{"col_start":53,"col_end":54,"count":0}]},{"line":"    let work_fee = sum_fees(completed_works, |w| w.fee)?;","counters":[{"col_start":8,"col_end":16,"count":0},{"col_start":19,"col_end":45,"count":0},{"col_start":49,"col_end":54,"count":0},{"col_start":54,"col_end":55,"count":0},{"col_start":55,"col_end":56,"count":0}]},{"line":"","counters":[]},{"line":"    let total_work_fee = work_fee","counters":[{"col_start":8,"col_end":33,"count":0}]},{"line":"        .checked_sub(&coinbase_fee)","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"        .unwrap_or_else(Fee::zero);","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"    budget","counters":[{"col_start":0,"col_end":10,"count":0}]},{"line":"        .checked_sub(&total_work_fee)","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"        .ok_or(PreDiffError::InsufficientFee((budget, total_work_fee)))","counters":[{"col_start":0,"col_end":71,"count":0}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"#[derive(Clone, Debug, Eq, derive_more::From)]","counters":[{"col_start":9,"col_end":14,"count":0},{"col_start":16,"col_end":21,"count":0},{"col_start":27,"col_end":44,"count":0}]},{"line":"pub struct HashableCompressedPubKey(pub CompressedPubKey);","counters":[]},{"line":"","counters":[]},{"line":"impl PartialEq for HashableCompressedPubKey {","counters":[]},{"line":"    fn eq(&self, other: &Self) -> bool {","counters":[{"col_start":4,"col_end":40,"count":0}]},{"line":"        self.0 == other.0","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl std::hash::Hash for HashableCompressedPubKey {","counters":[]},{"line":"    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {","counters":[{"col_start":4,"col_end":57,"count":0}]},{"line":"        self.0.x.hash(state);","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"        self.0.is_odd.hash(state);","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl PartialOrd for HashableCompressedPubKey {","counters":[]},{"line":"    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {","counters":[]},{"line":"        match self.0.x.partial_cmp(&other.0.x) {","counters":[{"col_start":23,"col_end":46,"count":0}]},{"line":"            Some(core::cmp::Ordering::Equal) => {}","counters":[{"col_start":48,"col_end":50,"count":0}]},{"line":"            ord => return ord,","counters":[{"col_start":12,"col_end":29,"count":0}]},{"line":"        };","counters":[]},{"line":"        self.0.is_odd.partial_cmp(&other.0.is_odd)","counters":[{"col_start":8,"col_end":50,"count":0}]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"pub fn fee_transfers_map<I, T>(singles: I) -> Option<HashMap<HashableCompressedPubKey, Fee>>","counters":[{"col_start":0,"col_end":92,"count":0}]},{"line":"where","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"    I: IntoIterator<Item = (T, Fee)>,","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"    T: Into<HashableCompressedPubKey>,","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"{","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"    use std::collections::hash_map::Entry::{Occupied, Vacant};","counters":[{"col_start":0,"col_end":62,"count":0}]},{"line":"","counters":[]},{"line":"    let singles = singles.into_iter();","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"","counters":[]},{"line":"    let mut map = HashMap::with_capacity(singles.size_hint().0);","counters":[{"col_start":0,"col_end":63,"count":0}]},{"line":"","counters":[]},{"line":"    for (pk, fee) in singles {","counters":[{"col_start":9,"col_end":16,"count":0},{"col_start":21,"col_end":28,"count":0}]},{"line":"        let pk: HashableCompressedPubKey = pk.into();","counters":[{"col_start":12,"col_end":53,"count":0}]},{"line":"","counters":[]},{"line":"        match map.entry(pk) {","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"            Occupied(mut entry) => {","counters":[{"col_start":21,"col_end":36,"count":0}]},{"line":"                entry.insert(fee.checked_add(entry.get())?);","counters":[{"col_start":0,"col_end":57,"count":0},{"col_start":57,"col_end":58,"count":0}]},{"line":"            }","counters":[]},{"line":"            Vacant(e) => {","counters":[{"col_start":19,"col_end":26,"count":0}]},{"line":"                e.insert(fee);","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    Some(map)","counters":[{"col_start":4,"col_end":13,"count":0}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"/// TODO: This method is a mess, need to add tests","counters":[]},{"line":"///","counters":[]},{"line":"/// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/staged_ledger/pre_diff_info.ml#L199","counters":[]},{"line":"fn create_fee_transfers<'a>(","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"    completed_works: impl Iterator<Item = &'a work::Unchecked>,","counters":[{"col_start":0,"col_end":63,"count":0}]},{"line":"    delta: Fee,","counters":[{"col_start":0,"col_end":15,"count":0}]},{"line":"    public_key: &CompressedPubKey,","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"    coinbase_fts: impl Iterator<Item = &'a CoinbaseFeeTransfer>,","counters":[{"col_start":0,"col_end":64,"count":0}]},{"line":") -> Result<Vec<FeeTransfer>, PreDiffError> {","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"    use std::collections::hash_map::Entry::Occupied;","counters":[{"col_start":0,"col_end":52,"count":0}]},{"line":"","counters":[]},{"line":"    let singles = std::iter::once((public_key.clone(), delta))","counters":[{"col_start":0,"col_end":62,"count":0}]},{"line":"        .chain(completed_works.map(|work::Unchecked { fee, prover, .. }| (prover.clone(), *fee)))","counters":[{"col_start":0,"col_end":35,"count":0},{"col_start":73,"col_end":95,"count":0},{"col_start":95,"col_end":97,"count":0}]},{"line":"        .filter(|(_, fee)| !fee.is_zero());","counters":[{"col_start":0,"col_end":16,"count":0},{"col_start":27,"col_end":41,"count":0},{"col_start":41,"col_end":42,"count":0}]},{"line":"","counters":[]},{"line":"    let mut singles_map = fee_transfers_map(singles)","counters":[{"col_start":8,"col_end":23,"count":0},{"col_start":26,"col_end":52,"count":0}]},{"line":"        .ok_or_else(|| PreDiffError::Unexpected(\"fee overflow\".to_string()))?;","counters":[{"col_start":0,"col_end":20,"count":0},{"col_start":23,"col_end":75,"count":0},{"col_start":75,"col_end":76,"count":0},{"col_start":76,"col_end":77,"count":4}]},{"line":"","counters":[]},{"line":"    for CoinbaseFeeTransfer {","counters":[]},{"line":"        receiver_pk,","counters":[{"col_start":8,"col_end":20,"count":0}]},{"line":"        fee: cb_fee,","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"    } in coinbase_fts","counters":[{"col_start":9,"col_end":21,"count":0}]},{"line":"    {","counters":[]},{"line":"        if let Occupied(mut entry) =","counters":[{"col_start":24,"col_end":33,"count":0}]},{"line":"            singles_map.entry(HashableCompressedPubKey(receiver_pk.clone()))","counters":[{"col_start":12,"col_end":76,"count":0}]},{"line":"        {","counters":[]},{"line":"            let new_fee = entry","counters":[{"col_start":16,"col_end":23,"count":0},{"col_start":26,"col_end":31,"count":0}]},{"line":"                .get()","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"                .checked_sub(cb_fee)","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"                .ok_or_else(|| PreDiffError::Unexpected(\"fee underflow\".to_string()))?;","counters":[{"col_start":0,"col_end":28,"count":0},{"col_start":31,"col_end":84,"count":0},{"col_start":84,"col_end":85,"count":0},{"col_start":85,"col_end":86,"count":1}]},{"line":"","counters":[]},{"line":"            if !new_fee.is_zero() {","counters":[{"col_start":15,"col_end":33,"count":0},{"col_start":34,"col_end":35,"count":0}]},{"line":"                entry.insert(new_fee);","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"            } else {","counters":[{"col_start":0,"col_end":13,"count":0},{"col_start":19,"col_end":20,"count":0}]},{"line":"                entry.remove();","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        }","counters":[{"col_start":9,"col_end":10,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    let mut list: Vec<_> = singles_map.into_iter().collect();","counters":[{"col_start":8,"col_end":61,"count":1}]},{"line":"    // TODO: panic + check how OCaml sort those keys","counters":[{"col_start":0,"col_end":52,"count":1}]},{"line":"    list.sort_by(|(pk1, _), (pk2, _)| pk1.partial_cmp(pk2).unwrap());","counters":[{"col_start":0,"col_end":17,"count":1},{"col_start":38,"col_end":67,"count":0},{"col_start":67,"col_end":69,"count":1}]},{"line":"","counters":[]},{"line":"    let sft: Vec<_> = list","counters":[{"col_start":0,"col_end":26,"count":1}]},{"line":"        .into_iter()","counters":[{"col_start":0,"col_end":20,"count":1}]},{"line":"        .map(|(receiver_pk, fee)| SingleFeeTransfer::create(receiver_pk.0, fee, TokenId::default()))","counters":[{"col_start":0,"col_end":13,"count":1},{"col_start":34,"col_end":99,"count":0},{"col_start":99,"col_end":100,"count":1}]},{"line":"        .collect();","counters":[{"col_start":0,"col_end":19,"count":1}]},{"line":"","counters":[]},{"line":"    let res: Result<Vec<_>, _> = group_list(&sft, |v| v.clone())","counters":[{"col_start":0,"col_end":50,"count":1},{"col_start":54,"col_end":63,"count":0},{"col_start":63,"col_end":64,"count":1}]},{"line":"        .map(FeeTransfer::of_singles)","counters":[{"col_start":0,"col_end":37,"count":1}]},{"line":"        .collect();","counters":[{"col_start":0,"col_end":19,"count":1}]},{"line":"","counters":[]},{"line":"    Ok(res?)","counters":[{"col_start":0,"col_end":10,"count":1},{"col_start":10,"col_end":11,"count":0}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":5}]},{"line":"","counters":[]},{"line":"fn check_coinbase<A, B>(","counters":[]},{"line":"    (fst, snd): &(PreDiffTwo<A, B>, Option<PreDiffOne<A, B>>),","counters":[]},{"line":") -> Result<(), PreDiffError> {","counters":[]},{"line":"    use diff::AtMostOne as O;","counters":[]},{"line":"    use diff::AtMostTwo::*;","counters":[]},{"line":"","counters":[]},{"line":"    match (","counters":[]},{"line":"        &fst.coinbase,","counters":[{"col_start":8,"col_end":22,"count":0}]},{"line":"        snd.as_ref()","counters":[{"col_start":0,"col_end":20,"count":0}]},{"line":"            .map(|s| &s.coinbase)","counters":[{"col_start":0,"col_end":17,"count":0},{"col_start":21,"col_end":32,"count":0},{"col_start":32,"col_end":33,"count":0}]},{"line":"            .unwrap_or(&diff::AtMostOne::Zero),","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"    ) {","counters":[]},{"line":"        // (Zero, Zero) | (Zero, One _) | One _, Zero | Two _, Zero ->","counters":[]},{"line":"        (Zero, O::Zero) | (Zero, O::One(_)) | (One(_), O::Zero) | (Two(_), O::Zero) => Ok(()),","counters":[{"col_start":87,"col_end":93,"count":0}]},{"line":"        (x, y) => Err(PreDiffError::CoinbaseError(format!(","counters":[{"col_start":9,"col_end":58,"count":0}]},{"line":"            \"Invalid coinbase value in staged ledger prediffs {:?} and {:?}\",","counters":[{"col_start":0,"col_end":77,"count":0}]},{"line":"            x, y,","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"        ))),","counters":[{"col_start":0,"col_end":11,"count":0}]},{"line":"    }","counters":[]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"fn generate_statuses<F, Cmd, Tx>(","counters":[]},{"line":"    constraint_constants: &ConstraintConstants,","counters":[]},{"line":"    coinbase_parts: CoinbaseParts,","counters":[]},{"line":"    receiver: &CompressedPubKey,","counters":[]},{"line":"    coinbase_amount: Amount,","counters":[]},{"line":"    commands: &[WithStatus<Cmd>],","counters":[]},{"line":"    completed_works: &[work::Unchecked],","counters":[]},{"line":"    generate_status: &mut F,","counters":[]},{"line":") -> Result<(Vec<WithStatus<Cmd>>, Vec<TransactionStatus>), PreDiffError>","counters":[]},{"line":"where","counters":[]},{"line":"    Cmd: GenericCommand + Clone,","counters":[]},{"line":"    F: FnMut(Transaction) -> Result<TransactionStatus, String>,","counters":[]},{"line":"    Tx: GenericTransaction + From<Coinbase> + From<FeeTransfer>,","counters":[]},{"line":"{","counters":[]},{"line":"    let TransactionData {","counters":[]},{"line":"        commands,","counters":[]},{"line":"        coinbases,","counters":[]},{"line":"        fee_transfers,","counters":[]},{"line":"    } = get_transaction_data::<Cmd, Tx>(","counters":[]},{"line":"        constraint_constants,","counters":[]},{"line":"        coinbase_parts,","counters":[]},{"line":"        receiver,","counters":[]},{"line":"        coinbase_amount,","counters":[]},{"line":"        commands.to_vec(),","counters":[]},{"line":"        completed_works,","counters":[]},{"line":"    )?;","counters":[]},{"line":"","counters":[]},{"line":"    let transactions = commands","counters":[]},{"line":"        .into_iter()","counters":[]},{"line":"        .map(|cmd| {","counters":[]},{"line":"            let status = generate_status(Transaction::Command(cmd.data.forget()))?;","counters":[]},{"line":"","counters":[]},{"line":"            Ok(WithStatus {","counters":[]},{"line":"                data: cmd.data,","counters":[]},{"line":"                status,","counters":[]},{"line":"            })","counters":[]},{"line":"        })","counters":[]},{"line":"        .collect::<Result<Vec<_>, PreDiffError>>()?;","counters":[]},{"line":"","counters":[]},{"line":"    // Order of application is user-commands, coinbase, fee transfers. See [get_individual_info]","counters":[]},{"line":"","counters":[]},{"line":"    let internal_commands = coinbases","counters":[]},{"line":"        .into_iter()","counters":[]},{"line":"        .map(Transaction::Coinbase)","counters":[]},{"line":"        .chain(fee_transfers.into_iter().map(Transaction::FeeTransfer));","counters":[]},{"line":"","counters":[]},{"line":"    let internal_command_statuses = internal_commands","counters":[]},{"line":"        .map(|cmd| Ok(generate_status(cmd)?))","counters":[]},{"line":"        .collect::<Result<Vec<_>, PreDiffError>>()?;","counters":[]},{"line":"","counters":[]},{"line":"    Ok((transactions, internal_command_statuses))","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"pub fn compute_statuses<Cmd, Tx, F>(","counters":[]},{"line":"    constraint_constants: &ConstraintConstants,","counters":[]},{"line":"    diff: (","counters":[]},{"line":"        PreDiffTwo<work::Work, WithStatus<Cmd>>,","counters":[]},{"line":"        Option<PreDiffOne<work::Work, WithStatus<Cmd>>>,","counters":[]},{"line":"    ),","counters":[]},{"line":"    coinbase_receiver: CompressedPubKey,","counters":[]},{"line":"    coinbase_amount: Amount,","counters":[]},{"line":"    generate_status: &mut F,","counters":[]},{"line":") -> Result<","counters":[]},{"line":"    (","counters":[]},{"line":"        PreDiffTwo<work::Work, WithStatus<Cmd>>,","counters":[]},{"line":"        Option<PreDiffOne<work::Work, WithStatus<Cmd>>>,","counters":[]},{"line":"    ),","counters":[]},{"line":"    PreDiffError,","counters":[]},{"line":">","counters":[]},{"line":"where","counters":[]},{"line":"    Cmd: GenericCommand + Clone,","counters":[]},{"line":"    Tx: GenericTransaction + From<Coinbase> + From<FeeTransfer>,","counters":[]},{"line":"    F: FnMut(Transaction) -> Result<TransactionStatus, String>,","counters":[]},{"line":"{","counters":[]},{"line":"    let get_statuses_pre_diff_with_at_most_two =","counters":[]},{"line":"        |t1: PreDiffTwo<work::Work, WithStatus<Cmd>>, generate_status: &mut F| {","counters":[]},{"line":"            let coinbase_parts = match &t1.coinbase {","counters":[]},{"line":"                diff::AtMostTwo::Zero => CoinbaseParts::Zero,","counters":[]},{"line":"                diff::AtMostTwo::One(x) => CoinbaseParts::One(x.clone()),","counters":[]},{"line":"                diff::AtMostTwo::Two(x) => CoinbaseParts::Two(x.clone()),","counters":[]},{"line":"            };","counters":[]},{"line":"","counters":[]},{"line":"            let (commands, internal_command_statuses) = generate_statuses::<_, _, Tx>(","counters":[]},{"line":"                constraint_constants,","counters":[]},{"line":"                coinbase_parts,","counters":[]},{"line":"                &coinbase_receiver,","counters":[]},{"line":"                coinbase_amount,","counters":[]},{"line":"                &t1.commands,","counters":[]},{"line":"                &t1.completed_works,","counters":[]},{"line":"                generate_status,","counters":[]},{"line":"            )?;","counters":[]},{"line":"","counters":[]},{"line":"            Ok::<_, PreDiffError>(PreDiffTwo {","counters":[]},{"line":"                completed_works: t1.completed_works,","counters":[]},{"line":"                commands,","counters":[]},{"line":"                coinbase: t1.coinbase,","counters":[]},{"line":"                internal_command_statuses,","counters":[]},{"line":"            })","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"    let get_statuses_pre_diff_with_at_most_one =","counters":[]},{"line":"        |t2: PreDiffOne<work::Work, WithStatus<Cmd>>, generate_status: &mut F| {","counters":[]},{"line":"            let coinbase_added = match &t2.coinbase {","counters":[]},{"line":"                diff::AtMostOne::Zero => CoinbaseParts::Zero,","counters":[]},{"line":"                diff::AtMostOne::One(x) => CoinbaseParts::One(x.clone()),","counters":[]},{"line":"            };","counters":[]},{"line":"","counters":[]},{"line":"            let (commands, internal_command_statuses) = generate_statuses::<_, _, Tx>(","counters":[]},{"line":"                constraint_constants,","counters":[]},{"line":"                coinbase_added,","counters":[]},{"line":"                &coinbase_receiver,","counters":[]},{"line":"                coinbase_amount,","counters":[]},{"line":"                &t2.commands,","counters":[]},{"line":"                &t2.completed_works,","counters":[]},{"line":"                generate_status,","counters":[]},{"line":"            )?;","counters":[]},{"line":"","counters":[]},{"line":"            Ok::<_, PreDiffError>(PreDiffOne {","counters":[]},{"line":"                completed_works: t2.completed_works,","counters":[]},{"line":"                commands,","counters":[]},{"line":"                coinbase: t2.coinbase,","counters":[]},{"line":"                internal_command_statuses,","counters":[]},{"line":"            })","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"    let p1 = get_statuses_pre_diff_with_at_most_two(diff.0, generate_status)?;","counters":[]},{"line":"    let p2 = match diff.1 {","counters":[]},{"line":"        Some(d2) => Some(get_statuses_pre_diff_with_at_most_one(d2, generate_status)?),","counters":[]},{"line":"        None => None,","counters":[]},{"line":"    };","counters":[]},{"line":"","counters":[]},{"line":"    Ok((p1, p2))","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"/// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/staged_ledger/pre_diff_info.ml#L237","counters":[]},{"line":"struct TransactionData<T> {","counters":[]},{"line":"    commands: Vec<WithStatus<T>>,","counters":[]},{"line":"    coinbases: Vec<Coinbase>,","counters":[]},{"line":"    fee_transfers: Vec<FeeTransfer>,","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"fn get_transaction_data<Cmd, Tx>(","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"    constraint_constants: &ConstraintConstants,","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"    coinbase_parts: CoinbaseParts,","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"    receiver: &CompressedPubKey,","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"    coinbase_amount: Amount,","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"    commands: Vec<WithStatus<Cmd>>,","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"    completed_works: &[work::Unchecked],","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":") -> Result<TransactionData<Cmd>, PreDiffError>","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"where","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"    Cmd: GenericCommand,","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"    Tx: GenericTransaction + From<Coinbase> + From<FeeTransfer>,","counters":[{"col_start":0,"col_end":64,"count":0}]},{"line":"{","counters":[{"col_start":0,"col_end":0,"count":0},{"col_start":0,"col_end":0,"count":0}]},{"line":"    let coinbases = create_coinbase(","counters":[{"col_start":8,"col_end":17,"count":0},{"col_start":20,"col_end":36,"count":0}]},{"line":"        constraint_constants,","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"        coinbase_parts,","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"        receiver,","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"        coinbase_amount,","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"    )?;","counters":[{"col_start":0,"col_end":5,"count":0},{"col_start":5,"col_end":6,"count":20}]},{"line":"","counters":[]},{"line":"    let coinbase_fts_iterator = coinbases.iter().flat_map(|cb| cb.fee_transfer.iter());","counters":[{"col_start":8,"col_end":58,"count":0},{"col_start":63,"col_end":85,"count":0},{"col_start":85,"col_end":87,"count":0}]},{"line":"","counters":[]},{"line":"    let coinbase_work_fees: Fee =","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"        sum_fees(coinbase_fts_iterator.clone(), |ft| ft.fee).expect(\"OCaml throw here\");","counters":[{"col_start":0,"col_end":48,"count":0},{"col_start":53,"col_end":59,"count":0},{"col_start":59,"col_end":88,"count":0}]},{"line":"","counters":[]},{"line":"    let txn_works_others_iterator = completed_works.iter().filter(|w| &w.prover != receiver);","counters":[{"col_start":0,"col_end":66,"count":0},{"col_start":70,"col_end":91,"count":0},{"col_start":91,"col_end":92,"count":0}]},{"line":"","counters":[]},{"line":"    let delta: Fee = fee_remainder(","counters":[{"col_start":8,"col_end":18,"count":0},{"col_start":21,"col_end":35,"count":0}]},{"line":"        commands.as_slice(),","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"        txn_works_others_iterator.clone(),","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"        coinbase_work_fees,","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"    )?;","counters":[{"col_start":0,"col_end":5,"count":0},{"col_start":5,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let fee_transfers: Vec<FeeTransfer> = create_fee_transfers(","counters":[{"col_start":8,"col_end":39,"count":0},{"col_start":42,"col_end":63,"count":0}]},{"line":"        txn_works_others_iterator,","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"        delta,","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"        receiver,","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"        coinbase_fts_iterator,","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"    )?;","counters":[{"col_start":0,"col_end":5,"count":0},{"col_start":5,"col_end":6,"count":20}]},{"line":"","counters":[]},{"line":"    Ok(TransactionData {","counters":[{"col_start":4,"col_end":24,"count":0}]},{"line":"        commands,","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"        coinbases,","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"        fee_transfers,","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"    })","counters":[{"col_start":0,"col_end":6,"count":0}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":40}]},{"line":"","counters":[]},{"line":"fn get_individual_info<Cmd, Tx>(","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"    constraint_constants: &ConstraintConstants,","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"    coinbase_parts: CoinbaseParts,","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"    receiver: &CompressedPubKey,","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"    coinbase_amount: Amount,","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"    commands: Vec<WithStatus<Cmd>>,","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"    completed_works: Vec<work::Unchecked>,","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"    internal_command_statuses: Vec<TransactionStatus>,","counters":[{"col_start":0,"col_end":54,"count":0}]},{"line":") -> Result<PreDiffInfo<Tx>, PreDiffError>","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"where","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"    Cmd: GenericCommand,","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"    Tx: GenericTransaction + From<Coinbase> + From<FeeTransfer> + From<Cmd>,","counters":[{"col_start":0,"col_end":76,"count":0}]},{"line":"{","counters":[{"col_start":0,"col_end":0,"count":0},{"col_start":0,"col_end":0,"count":0}]},{"line":"    let TransactionData {","counters":[]},{"line":"        commands,","counters":[{"col_start":8,"col_end":17,"count":0}]},{"line":"        coinbases: coinbase_parts,","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"        fee_transfers,","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"    } = get_transaction_data::<Cmd, Tx>(","counters":[{"col_start":8,"col_end":40,"count":0}]},{"line":"        constraint_constants,","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"        coinbase_parts,","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"        receiver,","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"        coinbase_amount,","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"        commands,","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"        &completed_works,","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"    )?;","counters":[{"col_start":0,"col_end":5,"count":0},{"col_start":5,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let commands_count = commands.len();","counters":[{"col_start":8,"col_end":40,"count":0}]},{"line":"    let coinbases_amount: Vec<Amount> = coinbase_parts.iter().map(|cb| cb.amount).collect();","counters":[{"col_start":0,"col_end":66,"count":0},{"col_start":71,"col_end":80,"count":0},{"col_start":80,"col_end":92,"count":0}]},{"line":"","counters":[]},{"line":"    let internal_commands = coinbase_parts","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"        .into_iter()","counters":[{"col_start":0,"col_end":20,"count":0}]},{"line":"        .map(Tx::from)","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"        .chain(fee_transfers.into_iter().map(Into::into));","counters":[{"col_start":0,"col_end":58,"count":0}]},{"line":"","counters":[]},{"line":"    let internal_commands_with_statuses = internal_command_statuses","counters":[{"col_start":0,"col_end":67,"count":0}]},{"line":"        .into_iter()","counters":[{"col_start":0,"col_end":20,"count":0}]},{"line":"        .zip(internal_commands)","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"        .map(|(status, cmd)| {","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"            if cmd.is_coinbase() || cmd.is_fee_transfer() {","counters":[{"col_start":15,"col_end":32,"count":0},{"col_start":36,"col_end":57,"count":0}]},{"line":"                Ok(WithStatus { data: cmd, status })","counters":[{"col_start":16,"col_end":52,"count":0}]},{"line":"            } else {","counters":[]},{"line":"                Err(PreDiffError::InternalCommandStatusMismatch)","counters":[{"col_start":16,"col_end":64,"count":0}]},{"line":"            }","counters":[]},{"line":"        });","counters":[{"col_start":8,"col_end":9,"count":0},{"col_start":9,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"    let transactions: Vec<WithStatus<Tx>> = commands","counters":[{"col_start":8,"col_end":41,"count":0},{"col_start":44,"col_end":52,"count":0}]},{"line":"        .into_iter()","counters":[{"col_start":0,"col_end":20,"count":0}]},{"line":"        .map(|cmd| Ok(cmd.into_map(Into::into)))","counters":[{"col_start":0,"col_end":13,"count":0},{"col_start":19,"col_end":47,"count":0},{"col_start":47,"col_end":48,"count":0}]},{"line":"        .chain(internal_commands_with_statuses)","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"        .collect::<Result<_, _>>()?;","counters":[{"col_start":0,"col_end":34,"count":0},{"col_start":34,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"    Ok(PreDiffInfo {","counters":[{"col_start":4,"col_end":20,"count":0}]},{"line":"        transactions,","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"        work: completed_works,","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"        commands_count,","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"        coinbases: coinbases_amount,","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"    })","counters":[{"col_start":0,"col_end":6,"count":0}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"fn get_impl<Cmd, Tx>(","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"    constraint_constants: &ConstraintConstants,","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"    diff: (","counters":[{"col_start":0,"col_end":11,"count":0}]},{"line":"        PreDiffTwo<work::Work, WithStatus<Cmd>>,","counters":[{"col_start":0,"col_end":48,"count":0}]},{"line":"        Option<PreDiffOne<work::Work, WithStatus<Cmd>>>,","counters":[{"col_start":0,"col_end":56,"count":0}]},{"line":"    ),","counters":[{"col_start":0,"col_end":6,"count":0}]},{"line":"    coinbase_receiver: CompressedPubKey,","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"    coinbase_amount: Option<Amount>,","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":") -> Result<(Vec<WithStatus<Tx>>, Vec<work::Work>, usize, Vec<Amount>), PreDiffError>","counters":[{"col_start":0,"col_end":85,"count":0}]},{"line":"where","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"    Cmd: GenericCommand,","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"    Tx: GenericTransaction + From<Coinbase> + From<FeeTransfer> + From<Cmd>,","counters":[{"col_start":0,"col_end":76,"count":0}]},{"line":"{","counters":[{"col_start":0,"col_end":0,"count":0},{"col_start":0,"col_end":0,"count":0}]},{"line":"    let coinbase_amount = match coinbase_amount {","counters":[{"col_start":8,"col_end":23,"count":0},{"col_start":32,"col_end":47,"count":0}]},{"line":"        Some(amount) => amount,","counters":[{"col_start":13,"col_end":30,"count":0}]},{"line":"        None => {","counters":[]},{"line":"            return Err(PreDiffError::CoinbaseError(format!(","counters":[{"col_start":19,"col_end":59,"count":0}]},{"line":"                \"Overflow when calculating coinbase amount: Supercharged \\","counters":[{"col_start":0,"col_end":74,"count":0}]},{"line":"                 coinbase factor ({:?}) x coinbase amount ({:?})\",","counters":[{"col_start":0,"col_end":66,"count":0}]},{"line":"                constraint_constants.supercharged_coinbase_factor,","counters":[{"col_start":0,"col_end":66,"count":0}]},{"line":"                constraint_constants.coinbase_amount,","counters":[{"col_start":0,"col_end":53,"count":0}]},{"line":"            )))","counters":[{"col_start":0,"col_end":15,"count":0}]},{"line":"        }","counters":[]},{"line":"    };","counters":[]},{"line":"","counters":[]},{"line":"    let apply_pre_diff_with_at_most_two = |t1: PreDiffTwo<_, _>| {","counters":[{"col_start":8,"col_end":42,"count":0},{"col_start":65,"col_end":66,"count":0}]},{"line":"        let coinbase_parts = match t1.coinbase {","counters":[{"col_start":12,"col_end":26,"count":0},{"col_start":35,"col_end":46,"count":0}]},{"line":"            diff::AtMostTwo::Zero => CoinbaseParts::Zero,","counters":[{"col_start":37,"col_end":56,"count":0}]},{"line":"            diff::AtMostTwo::One(x) => CoinbaseParts::One(x),","counters":[{"col_start":33,"col_end":60,"count":0}]},{"line":"            diff::AtMostTwo::Two(x) => CoinbaseParts::Two(x),","counters":[{"col_start":33,"col_end":60,"count":0}]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        get_individual_info::<Cmd, Tx>(","counters":[{"col_start":8,"col_end":39,"count":0}]},{"line":"            constraint_constants,","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"            coinbase_parts,","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"            &coinbase_receiver,","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"            coinbase_amount,","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"            t1.commands,","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"            t1.completed_works,","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"            t1.internal_command_statuses,","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"        )","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    };","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    let apply_pre_diff_with_at_most_one = |t2: PreDiffOne<_, _>| {","counters":[{"col_start":8,"col_end":42,"count":0},{"col_start":65,"col_end":66,"count":20}]},{"line":"        let coinbase_added = match t2.coinbase {","counters":[{"col_start":12,"col_end":26,"count":20},{"col_start":35,"col_end":46,"count":20}]},{"line":"            diff::AtMostOne::Zero => CoinbaseParts::Zero,","counters":[{"col_start":37,"col_end":56,"count":20}]},{"line":"            diff::AtMostOne::One(x) => CoinbaseParts::One(x),","counters":[{"col_start":33,"col_end":60,"count":0}]},{"line":"        };","counters":[]},{"line":"        get_individual_info::<Cmd, Tx>(","counters":[{"col_start":8,"col_end":39,"count":20}]},{"line":"            constraint_constants,","counters":[{"col_start":0,"col_end":33,"count":20}]},{"line":"            coinbase_added,","counters":[{"col_start":0,"col_end":27,"count":20}]},{"line":"            &coinbase_receiver,","counters":[{"col_start":0,"col_end":31,"count":20}]},{"line":"            coinbase_amount,","counters":[{"col_start":0,"col_end":28,"count":20}]},{"line":"            t2.commands,","counters":[{"col_start":0,"col_end":24,"count":20}]},{"line":"            t2.completed_works,","counters":[{"col_start":0,"col_end":31,"count":20}]},{"line":"            t2.internal_command_statuses,","counters":[{"col_start":0,"col_end":41,"count":20}]},{"line":"        )","counters":[{"col_start":0,"col_end":9,"count":20}]},{"line":"    };","counters":[{"col_start":0,"col_end":5,"count":20}]},{"line":"","counters":[]},{"line":"    check_coinbase(&diff)?;","counters":[{"col_start":4,"col_end":25,"count":0},{"col_start":25,"col_end":26,"count":0}]},{"line":"","counters":[]},{"line":"    let p1 = apply_pre_diff_with_at_most_two(diff.0)?;","counters":[{"col_start":8,"col_end":10,"count":0},{"col_start":13,"col_end":52,"count":0},{"col_start":52,"col_end":53,"count":0}]},{"line":"","counters":[]},{"line":"    let p2 = if let Some(d) = diff.1 {","counters":[{"col_start":8,"col_end":10,"count":17},{"col_start":25,"col_end":26,"count":0},{"col_start":30,"col_end":36,"count":0}]},{"line":"        apply_pre_diff_with_at_most_one(d)?","counters":[{"col_start":8,"col_end":42,"count":0},{"col_start":42,"col_end":43,"count":17}]},{"line":"    } else {","counters":[]},{"line":"        PreDiffInfo::empty()","counters":[{"col_start":8,"col_end":28,"count":10}]},{"line":"    };","counters":[]},{"line":"","counters":[]},{"line":"    Ok((","counters":[{"col_start":4,"col_end":8,"count":17}]},{"line":"        p1.transactions.into_iter().chain(p2.transactions).collect(),","counters":[{"col_start":0,"col_end":69,"count":17}]},{"line":"        p1.work.into_iter().chain(p2.work).collect(),","counters":[{"col_start":0,"col_end":53,"count":17}]},{"line":"        p1.commands_count + p2.commands_count,","counters":[{"col_start":0,"col_end":46,"count":17}]},{"line":"        p1.coinbases.into_iter().chain(p2.coinbases).collect(),","counters":[{"col_start":0,"col_end":63,"count":17}]},{"line":"    ))","counters":[{"col_start":0,"col_end":6,"count":17}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":34}]},{"line":"","counters":[]},{"line":"impl diff::Diff {","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/staged_ledger/pre_diff_info.ml#L457","counters":[]},{"line":"    pub fn get<F>(","counters":[]},{"line":"        self,","counters":[]},{"line":"        check: F,","counters":[]},{"line":"        constraint_constants: &ConstraintConstants,","counters":[]},{"line":"        coinbase_receiver: CompressedPubKey,","counters":[]},{"line":"        supercharge_coinbase: bool,","counters":[]},{"line":"    ) -> Result<","counters":[]},{"line":"        (","counters":[]},{"line":"            Vec<WithStatus<valid::Transaction>>,","counters":[]},{"line":"            Vec<work::Work>,","counters":[]},{"line":"            usize,","counters":[]},{"line":"            Vec<Amount>,","counters":[]},{"line":"        ),","counters":[]},{"line":"        PreDiffError,","counters":[]},{"line":"    >","counters":[]},{"line":"    where","counters":[]},{"line":"        F: Fn(Vec<&UserCommand>) -> Result<Vec<valid::UserCommand>, VerifierError>,","counters":[]},{"line":"    {","counters":[]},{"line":"        let diff = self.validate_commands(check)?;","counters":[]},{"line":"","counters":[]},{"line":"        let coinbase_amount =","counters":[]},{"line":"            diff::coinbase(&diff.diff, constraint_constants, supercharge_coinbase);","counters":[]},{"line":"","counters":[]},{"line":"        get_impl::<valid::UserCommand, valid::Transaction>(","counters":[]},{"line":"            constraint_constants,","counters":[]},{"line":"            diff.diff,","counters":[]},{"line":"            coinbase_receiver,","counters":[]},{"line":"            coinbase_amount,","counters":[]},{"line":"        )","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/staged_ledger/pre_diff_info.ml#L481","counters":[]},{"line":"    pub fn get_transactions(","counters":[{"col_start":4,"col_end":28,"count":0}]},{"line":"        self,","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        constraint_constants: &ConstraintConstants,","counters":[{"col_start":0,"col_end":51,"count":0}]},{"line":"        coinbase_receiver: CompressedPubKey,","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"        supercharge_coinbase: bool,","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"    ) -> Result<Vec<WithStatus<Transaction>>, PreDiffError> {","counters":[{"col_start":0,"col_end":61,"count":0}]},{"line":"        let coinbase_amount =","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"            diff::coinbase(&self.diff, constraint_constants, supercharge_coinbase);","counters":[{"col_start":0,"col_end":82,"count":0}]},{"line":"","counters":[]},{"line":"        let (transactions, _, _, _) = get_impl::<UserCommand, Transaction>(","counters":[{"col_start":13,"col_end":25,"count":0},{"col_start":38,"col_end":75,"count":0}]},{"line":"            constraint_constants,","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"            self.diff,","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"            coinbase_receiver,","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"            coinbase_amount,","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"        )?;","counters":[{"col_start":0,"col_end":9,"count":0},{"col_start":9,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"        Ok(transactions)","counters":[{"col_start":8,"col_end":24,"count":0}]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl with_valid_signatures_and_proofs::Diff {","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/staged_ledger/pre_diff_info.ml#L472","counters":[]},{"line":"    pub fn get_unchecked(","counters":[{"col_start":4,"col_end":25,"count":0}]},{"line":"        self,","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        constraint_constants: &ConstraintConstants,","counters":[{"col_start":0,"col_end":51,"count":0}]},{"line":"        coinbase_receiver: CompressedPubKey,","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"        supercharge_coinbase: bool,","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"    ) -> Result<","counters":[{"col_start":0,"col_end":16,"count":0}]},{"line":"        (","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"            Vec<WithStatus<valid::Transaction>>,","counters":[{"col_start":0,"col_end":48,"count":0}]},{"line":"            Vec<work::Work>,","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"            usize,","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"            Vec<Amount>,","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"        ),","counters":[{"col_start":0,"col_end":10,"count":0}]},{"line":"        PreDiffError,","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"    > {","counters":[{"col_start":0,"col_end":7,"count":0}]},{"line":"        let diff = self.forget_proof_checks();","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"","counters":[]},{"line":"        let coinbase_amount =","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"            diff::coinbase(&diff.diff, constraint_constants, supercharge_coinbase);","counters":[{"col_start":0,"col_end":83,"count":0}]},{"line":"","counters":[]},{"line":"        get_impl::<valid::UserCommand, valid::Transaction>(","counters":[{"col_start":0,"col_end":59,"count":0}]},{"line":"            constraint_constants,","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"            diff.diff,","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"            coinbase_receiver,","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"            coinbase_amount,","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"        )","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]}]}