{"filename":"src/scan_state/scan_state.rs","lines":[{"line":"use std::collections::HashSet;","counters":[]},{"line":"","counters":[]},{"line":"use binprot_derive::BinProtWrite;","counters":[]},{"line":"use mina_hasher::Fp;","counters":[]},{"line":"use mina_p2p_messages::{","counters":[]},{"line":"    bigint, number,","counters":[]},{"line":"    v2::{","counters":[]},{"line":"        CurrencyAmountStableV1, CurrencyFeeStableV1, MinaStateProtocolStateValueStableV2, StateHash,","counters":[]},{"line":"    },","counters":[]},{"line":"};","counters":[]},{"line":"use mina_signer::CompressedPubKey;","counters":[]},{"line":"","counters":[]},{"line":"use crate::{","counters":[]},{"line":"    scan_state::{","counters":[]},{"line":"        fee_excess::FeeExcess,","counters":[]},{"line":"        parallel_scan::{base, merge, JobStatus},","counters":[]},{"line":"        pending_coinbase,","counters":[]},{"line":"        scan_state::transaction_snark::{","counters":[]},{"line":"            LedgerProofWithSokMessage, SokMessage, Statement, TransactionWithWitness,","counters":[]},{"line":"        },","counters":[]},{"line":"    },","counters":[]},{"line":"    staged_ledger::{hash::AuxHash, sparse_ledger::SparseLedger},","counters":[]},{"line":"    verifier::Verifier,","counters":[]},{"line":"    Account, AccountId,","counters":[]},{"line":"};","counters":[]},{"line":"","counters":[]},{"line":"use self::transaction_snark::{InitStack, LedgerProof, OneOrTwo, Registers};","counters":[]},{"line":"","counters":[]},{"line":"use super::{","counters":[]},{"line":"    currency::{Amount, Fee, Length, Slot},","counters":[]},{"line":"    parallel_scan::ParallelScan,","counters":[]},{"line":"    snark_work,","counters":[]},{"line":"    transaction_logic::{","counters":[]},{"line":"        apply_transaction, local_state::LocalState, protocol_state::protocol_state_view,","counters":[]},{"line":"        transaction_applied::TransactionApplied, transaction_witness::TransactionWitness,","counters":[]},{"line":"        Transaction, WithStatus,","counters":[]},{"line":"    },","counters":[]},{"line":"};","counters":[]},{"line":"// use super::parallel_scan::AvailableJob;","counters":[]},{"line":"","counters":[]},{"line":"pub use super::parallel_scan::SpacePartition;","counters":[]},{"line":"","counters":[]},{"line":"// type LedgerProof = LedgerProofProdStableV2;","counters":[]},{"line":"// type LedgerProofWithSokMessage = TransactionSnarkScanStateLedgerProofWithSokMessageStableV2;","counters":[]},{"line":"// type TransactionWithWitness = TransactionSnarkScanStateTransactionWithWitnessStableV2;","counters":[]},{"line":"","counters":[]},{"line":"pub type AvailableJob = super::parallel_scan::AvailableJob<","counters":[]},{"line":"    transaction_snark::TransactionWithWitness,","counters":[]},{"line":"    transaction_snark::LedgerProofWithSokMessage,","counters":[]},{"line":">;","counters":[]},{"line":"","counters":[]},{"line":"#[derive(Clone)]","counters":[]},{"line":"pub struct ScanState {","counters":[]},{"line":"    pub state: ParallelScan<","counters":[]},{"line":"        transaction_snark::TransactionWithWitness,","counters":[]},{"line":"        transaction_snark::LedgerProofWithSokMessage,","counters":[]},{"line":"    >,","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"pub mod transaction_snark {","counters":[]},{"line":"    use std::rc::Rc;","counters":[]},{"line":"","counters":[]},{"line":"    use mina_hasher::Fp;","counters":[]},{"line":"    use mina_p2p_messages::v2::TransactionSnarkProofStableV2;","counters":[]},{"line":"    use mina_signer::CompressedPubKey;","counters":[]},{"line":"","counters":[]},{"line":"    use crate::{","counters":[]},{"line":"        scan_state::{","counters":[]},{"line":"            currency::{Amount, Signed},","counters":[]},{"line":"            fee_excess::FeeExcess,","counters":[]},{"line":"            pending_coinbase,","counters":[]},{"line":"            transaction_logic::{local_state::LocalState, transaction_applied::TransactionApplied},","counters":[]},{"line":"        },","counters":[]},{"line":"        staged_ledger::{hash::OCamlString, sparse_ledger::SparseLedger},","counters":[]},{"line":"        Account, AccountId,","counters":[]},{"line":"    };","counters":[]},{"line":"","counters":[]},{"line":"    use super::Fee;","counters":[]},{"line":"","counters":[]},{"line":"    pub type LedgerHash = Fp;","counters":[]},{"line":"","counters":[]},{"line":"    #[derive(Debug, Clone, PartialEq, Eq)]","counters":[{"col_start":13,"col_end":18,"count":0},{"col_start":20,"col_end":25,"count":0},{"col_start":27,"col_end":28,"count":191258},{"col_start":35,"col_end":36,"count":588}]},{"line":"    pub struct Registers {","counters":[]},{"line":"        pub ledger: LedgerHash,","counters":[]},{"line":"        pub pending_coinbase_stack: pending_coinbase::Stack,","counters":[]},{"line":"        pub local_state: LocalState,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl Registers {","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/transaction_snark/transaction_snark.ml#L350","counters":[]},{"line":"        pub fn check_equal(&self, other: &Self) -> bool {","counters":[{"col_start":8,"col_end":57,"count":0}]},{"line":"            self.ledger == other.ledger","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"                && self.local_state == other.local_state","counters":[{"col_start":19,"col_end":56,"count":0}]},{"line":"                && pending_coinbase::Stack::connected(","counters":[{"col_start":19,"col_end":54,"count":0}]},{"line":"                    &self.pending_coinbase_stack,","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"                    &other.pending_coinbase_stack,","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"                    None,","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"                )","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/mina_state/registers.ml#L47","counters":[]},{"line":"        pub fn connected(r1: &Self, r2: &Self) -> bool {","counters":[{"col_start":8,"col_end":56,"count":0}]},{"line":"            r1.ledger == r2.ledger","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"                && r1.local_state == r2.local_state","counters":[{"col_start":19,"col_end":51,"count":0}]},{"line":"                && pending_coinbase::Stack::connected(","counters":[{"col_start":19,"col_end":54,"count":0}]},{"line":"                    &r1.pending_coinbase_stack,","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"                    &r2.pending_coinbase_stack,","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"                    None,","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"                )","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    #[derive(Clone, PartialEq, Eq, derive_more::Deref)]","counters":[{"col_start":13,"col_end":18,"count":0},{"col_start":35,"col_end":53,"count":0}]},{"line":"    pub struct SokDigest(pub Vec<u8>);","counters":[]},{"line":"","counters":[]},{"line":"    impl OCamlString for SokDigest {","counters":[]},{"line":"        fn to_ocaml_str(&self) -> String {","counters":[{"col_start":8,"col_end":42,"count":0}]},{"line":"            crate::staged_ledger::hash::to_ocaml_str(&self.0)","counters":[{"col_start":0,"col_end":61,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        fn from_ocaml_str(s: &str) -> Self {","counters":[{"col_start":8,"col_end":44,"count":0}]},{"line":"            let bytes: [u8; 32] = crate::staged_ledger::hash::from_ocaml_str(s);","counters":[{"col_start":0,"col_end":80,"count":0}]},{"line":"            Self(bytes.to_vec())","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl std::fmt::Debug for SokDigest {","counters":[]},{"line":"        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {","counters":[{"col_start":8,"col_end":76,"count":0}]},{"line":"            f.write_fmt(format_args!(\"SokDigest({})\", self.to_ocaml_str()))","counters":[{"col_start":0,"col_end":75,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl Default for SokDigest {","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/3a78f0e0c1343d14e2729c8b00205baa2ec70c93/src/lib/mina_base/sok_message.ml#L76","counters":[]},{"line":"        fn default() -> Self {","counters":[{"col_start":8,"col_end":30,"count":0}]},{"line":"            Self(vec![0; 32])","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    #[derive(Debug, Clone, PartialEq, Eq)]","counters":[{"col_start":13,"col_end":18,"count":0},{"col_start":20,"col_end":25,"count":0},{"col_start":27,"col_end":28,"count":0},{"col_start":35,"col_end":36,"count":1}]},{"line":"    pub struct Statement<D> {","counters":[]},{"line":"        pub source: Registers,","counters":[]},{"line":"        pub target: Registers,","counters":[]},{"line":"        pub supply_increase: Signed<Amount>,","counters":[]},{"line":"        pub fee_excess: FeeExcess,","counters":[]},{"line":"        pub sok_digest: D,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl Statement<()> {","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/2ee6e004ba8c6a0541056076aab22ea162f7eb3a/src/lib/transaction_snark/transaction_snark.ml#L348","counters":[]},{"line":"        pub fn merge(&self, s2: &Statement<()>) -> Result<Self, String> {","counters":[{"col_start":8,"col_end":72,"count":0}]},{"line":"            let fee_excess = FeeExcess::combine(&self.fee_excess, &s2.fee_excess)?;","counters":[{"col_start":16,"col_end":26,"count":0},{"col_start":29,"col_end":81,"count":0},{"col_start":81,"col_end":82,"count":0}]},{"line":"            let supply_increase = self","counters":[{"col_start":16,"col_end":31,"count":0},{"col_start":34,"col_end":38,"count":0}]},{"line":"                .supply_increase","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"                .add(&s2.supply_increase)","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"                .ok_or_else(|| \"Error adding supply_increase\".to_string())?;","counters":[{"col_start":0,"col_end":28,"count":0},{"col_start":31,"col_end":73,"count":0},{"col_start":73,"col_end":74,"count":0},{"col_start":74,"col_end":75,"count":0}]},{"line":"","counters":[]},{"line":"            assert!(self.target.check_equal(&s2.source));","counters":[{"col_start":12,"col_end":56,"count":0}]},{"line":"","counters":[]},{"line":"            Ok(Self {","counters":[{"col_start":12,"col_end":21,"count":0}]},{"line":"                source: self.source.clone(),","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"                target: s2.target.clone(),","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"                supply_increase,","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"                fee_excess,","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"                sok_digest: (),","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"            })","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    pub mod work {","counters":[]},{"line":"        use super::*;","counters":[]},{"line":"","counters":[]},{"line":"        pub type Statement = OneOrTwo<super::Statement<()>>;","counters":[]},{"line":"","counters":[]},{"line":"        #[derive(Debug, Clone)]","counters":[{"col_start":17,"col_end":22,"count":1},{"col_start":24,"col_end":29,"count":0}]},{"line":"        pub struct Work {","counters":[]},{"line":"            pub fee: Fee,","counters":[]},{"line":"            pub proofs: OneOrTwo<LedgerProof>,","counters":[]},{"line":"            pub prover: CompressedPubKey,","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        pub type Unchecked = Work;","counters":[]},{"line":"","counters":[]},{"line":"        pub type Checked = Work;","counters":[]},{"line":"","counters":[]},{"line":"        impl Work {","counters":[]},{"line":"            pub fn statement(&self) -> Statement {","counters":[{"col_start":12,"col_end":50,"count":0}]},{"line":"                self.proofs.map(|p| {","counters":[{"col_start":0,"col_end":32,"count":0},{"col_start":36,"col_end":37,"count":0}]},{"line":"                    let statement = p.statement();","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"                    super::Statement::<()> {","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"                        source: statement.source,","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"                        target: statement.target,","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"                        supply_increase: statement.supply_increase,","counters":[{"col_start":0,"col_end":67,"count":0}]},{"line":"                        fee_excess: statement.fee_excess,","counters":[{"col_start":0,"col_end":57,"count":0}]},{"line":"                        sok_digest: (),","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"                    }","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"                })","counters":[{"col_start":0,"col_end":17,"count":0},{"col_start":17,"col_end":18,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        impl Checked {","counters":[]},{"line":"            /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/transaction_snark_work/transaction_snark_work.ml#L121","counters":[]},{"line":"            pub fn forget(self) -> Unchecked {","counters":[{"col_start":12,"col_end":46,"count":0}]},{"line":"                self","counters":[{"col_start":0,"col_end":20,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    // TransactionSnarkPendingCoinbaseStackStateInitStackStableV1","counters":[]},{"line":"    #[derive(Debug, Clone)]","counters":[{"col_start":13,"col_end":14,"count":0},{"col_start":17,"col_end":18,"count":0},{"col_start":20,"col_end":21,"count":0},{"col_start":24,"col_end":25,"count":0}]},{"line":"    pub enum InitStack {","counters":[]},{"line":"        Base(pending_coinbase::Stack),","counters":[]},{"line":"        Merge,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    #[derive(Debug, Clone)]","counters":[{"col_start":13,"col_end":18,"count":0},{"col_start":20,"col_end":25,"count":0}]},{"line":"    pub struct TransactionWithWitness {","counters":[]},{"line":"        pub transaction_with_info: TransactionApplied,","counters":[]},{"line":"        pub state_hash: (Fp, Fp), // (StateHash, StateBodyHash)","counters":[]},{"line":"        // pub state_hash: (StateHash, MinaBaseStateBodyHashStableV1),","counters":[]},{"line":"        pub statement: Statement<()>,","counters":[]},{"line":"        pub init_stack: InitStack,","counters":[]},{"line":"        pub ledger_witness: SparseLedger<AccountId, Account>,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    #[derive(Debug, Clone, PartialEq)]","counters":[{"col_start":13,"col_end":18,"count":0},{"col_start":20,"col_end":25,"count":0}]},{"line":"    pub struct TransactionSnark<D> {","counters":[]},{"line":"        pub statement: Statement<D>,","counters":[]},{"line":"        pub proof: Rc<TransactionSnarkProofStableV2>,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    #[derive(Debug, Clone, PartialEq)]","counters":[{"col_start":13,"col_end":18,"count":0},{"col_start":20,"col_end":25,"count":0}]},{"line":"    pub struct LedgerProof(pub TransactionSnark<SokDigest>);","counters":[]},{"line":"","counters":[]},{"line":"    impl LedgerProof {","counters":[]},{"line":"        pub fn create(","counters":[{"col_start":8,"col_end":22,"count":0}]},{"line":"            statement: Statement<()>,","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"            sok_digest: SokDigest,","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"            proof: Rc<TransactionSnarkProofStableV2>,","counters":[{"col_start":0,"col_end":53,"count":0}]},{"line":"        ) -> Self {","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"            let statement = Statement::<SokDigest> {","counters":[{"col_start":0,"col_end":52,"count":0}]},{"line":"                source: statement.source,","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"                target: statement.target,","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"                supply_increase: statement.supply_increase,","counters":[{"col_start":0,"col_end":59,"count":0}]},{"line":"                fee_excess: statement.fee_excess,","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"                sok_digest,","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"            };","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"","counters":[]},{"line":"            Self(TransactionSnark { statement, proof })","counters":[{"col_start":0,"col_end":55,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn statement(&self) -> Statement<()> {","counters":[{"col_start":8,"col_end":50,"count":0}]},{"line":"            let statement = &self.0.statement;","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"","counters":[]},{"line":"            Statement::<()> {","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"                source: statement.source.clone(),","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"                target: statement.target.clone(),","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"                supply_increase: statement.supply_increase,","counters":[{"col_start":0,"col_end":59,"count":0}]},{"line":"                fee_excess: statement.fee_excess.clone(),","counters":[{"col_start":0,"col_end":57,"count":0}]},{"line":"                sok_digest: (),","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn statement_ref(&self) -> &Statement<SokDigest> {","counters":[{"col_start":8,"col_end":62,"count":0}]},{"line":"            &self.0.statement","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    #[derive(Debug, Clone, PartialEq)]","counters":[{"col_start":13,"col_end":18,"count":0},{"col_start":20,"col_end":25,"count":0}]},{"line":"    pub struct SokMessage {","counters":[]},{"line":"        pub fee: Fee,","counters":[]},{"line":"        pub prover: CompressedPubKey,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl SokMessage {","counters":[]},{"line":"        pub fn create(fee: Fee, prover: CompressedPubKey) -> Self {","counters":[{"col_start":8,"col_end":67,"count":0}]},{"line":"            Self { fee, prover }","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    #[derive(Debug, Clone, PartialEq)]","counters":[{"col_start":13,"col_end":18,"count":0},{"col_start":20,"col_end":25,"count":0}]},{"line":"    pub struct LedgerProofWithSokMessage {","counters":[]},{"line":"        pub proof: LedgerProof,","counters":[]},{"line":"        pub sok_message: SokMessage,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    #[derive(Debug, Clone, PartialEq, Eq)]","counters":[{"col_start":13,"col_end":14,"count":0},{"col_start":17,"col_end":18,"count":0},{"col_start":20,"col_end":21,"count":0},{"col_start":24,"col_end":25,"count":0},{"col_start":27,"col_end":28,"count":0},{"col_start":35,"col_end":36,"count":0}]},{"line":"    pub enum OneOrTwo<T> {","counters":[]},{"line":"        One(T),","counters":[]},{"line":"        Two((T, T)),","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl<T> OneOrTwo<T> {","counters":[]},{"line":"        pub fn len(&self) -> usize {","counters":[{"col_start":8,"col_end":36,"count":0}]},{"line":"            match self {","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"                OneOrTwo::One(_) => 1,","counters":[{"col_start":36,"col_end":37,"count":0}]},{"line":"                OneOrTwo::Two(_) => 2,","counters":[{"col_start":36,"col_end":37,"count":0}]},{"line":"            }","counters":[]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn iter(&self) -> OneOrTwoIter<T> {","counters":[{"col_start":8,"col_end":46,"count":0}]},{"line":"            let array = match self {","counters":[{"col_start":16,"col_end":21,"count":0},{"col_start":30,"col_end":34,"count":0}]},{"line":"                OneOrTwo::One(a) => [Some(a), None],","counters":[{"col_start":30,"col_end":51,"count":0}]},{"line":"                OneOrTwo::Two((a, b)) => [Some(a), Some(b)],","counters":[{"col_start":31,"col_end":59,"count":0}]},{"line":"            };","counters":[]},{"line":"","counters":[]},{"line":"            OneOrTwoIter {","counters":[{"col_start":12,"col_end":26,"count":0}]},{"line":"                inner: array,","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"                index: 0,","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn into_iter(self) -> OneOrTwoIntoIter<T> {","counters":[{"col_start":8,"col_end":54,"count":0}]},{"line":"            let array = match self {","counters":[{"col_start":16,"col_end":21,"count":0},{"col_start":30,"col_end":34,"count":0}]},{"line":"                OneOrTwo::One(a) => [Some(a), None],","counters":[{"col_start":30,"col_end":51,"count":0}]},{"line":"                OneOrTwo::Two((a, b)) => [Some(a), Some(b)],","counters":[{"col_start":31,"col_end":59,"count":0}]},{"line":"            };","counters":[]},{"line":"","counters":[]},{"line":"            OneOrTwoIntoIter {","counters":[{"col_start":12,"col_end":30,"count":0}]},{"line":"                inner: array,","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"                index: 0,","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn map<F, R>(&self, fun: F) -> OneOrTwo<R>","counters":[{"col_start":8,"col_end":54,"count":0}]},{"line":"        where","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"            F: Fn(&T) -> R,","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"        {","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"            match self {","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"                OneOrTwo::One(one) => OneOrTwo::One(fun(one)),","counters":[{"col_start":30,"col_end":61,"count":0}]},{"line":"                OneOrTwo::Two((a, b)) => OneOrTwo::Two((fun(a), fun(b))),","counters":[{"col_start":31,"col_end":72,"count":0}]},{"line":"            }","counters":[]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn into_map<F, R>(self, fun: F) -> OneOrTwo<R>","counters":[{"col_start":8,"col_end":58,"count":0}]},{"line":"        where","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"            F: Fn(T) -> R,","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"        {","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"            match self {","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"                OneOrTwo::One(one) => OneOrTwo::One(fun(one)),","counters":[{"col_start":30,"col_end":61,"count":0}]},{"line":"                OneOrTwo::Two((a, b)) => OneOrTwo::Two((fun(a), fun(b))),","counters":[{"col_start":31,"col_end":72,"count":0}]},{"line":"            }","counters":[]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        pub fn into_map_err<F, R, E>(self, fun: F) -> Result<OneOrTwo<R>, E>","counters":[]},{"line":"        where","counters":[]},{"line":"            F: Fn(T) -> Result<R, E>,","counters":[]},{"line":"        {","counters":[]},{"line":"            match self {","counters":[]},{"line":"                OneOrTwo::One(one) => Ok(OneOrTwo::One(fun(one)?)),","counters":[]},{"line":"                OneOrTwo::Two((a, b)) => Ok(OneOrTwo::Two((fun(a)?, fun(b)?))),","counters":[]},{"line":"            }","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/one_or_two/one_or_two.ml#L54","counters":[]},{"line":"        pub fn zip<B>(a: OneOrTwo<T>, b: OneOrTwo<B>) -> OneOrTwo<(T, B)> {","counters":[]},{"line":"            use OneOrTwo::*;","counters":[]},{"line":"","counters":[]},{"line":"            match (a, b) {","counters":[]},{"line":"                (One(a), One(b)) => One((a, b)),","counters":[]},{"line":"                (Two((a1, a2)), Two((b1, b2))) => Two(((a1, b1), (a2, b2))),","counters":[]},{"line":"                (One(_), Two(_)) => panic!(\"One_or_two.zip mismatched\"),","counters":[]},{"line":"                (Two(_), One(_)) => panic!(\"One_or_two.zip mismatched\"),","counters":[]},{"line":"            }","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        pub fn fold<A, F>(&self, init: A, fun: F) -> A","counters":[]},{"line":"        where","counters":[]},{"line":"            F: Fn(A, &T) -> A,","counters":[]},{"line":"        {","counters":[]},{"line":"            match self {","counters":[]},{"line":"                OneOrTwo::One(a) => fun(init, a),","counters":[]},{"line":"                OneOrTwo::Two((a, b)) => fun(fun(init, a), b),","counters":[]},{"line":"            }","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    pub struct OneOrTwoIter<'a, T> {","counters":[]},{"line":"        inner: [Option<&'a T>; 2],","counters":[]},{"line":"        index: usize,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl<'a, T> Iterator for OneOrTwoIter<'a, T> {","counters":[]},{"line":"        type Item = &'a T;","counters":[]},{"line":"","counters":[]},{"line":"        fn next(&mut self) -> Option<Self::Item> {","counters":[{"col_start":8,"col_end":49,"count":0}]},{"line":"            let value = self.inner.get(self.index)?.as_ref()?;","counters":[{"col_start":16,"col_end":21,"count":0},{"col_start":24,"col_end":50,"count":0},{"col_start":50,"col_end":51,"count":0},{"col_start":52,"col_end":60,"count":0},{"col_start":60,"col_end":61,"count":0}]},{"line":"            self.index += 1;","counters":[{"col_start":12,"col_end":28,"count":0}]},{"line":"","counters":[]},{"line":"            Some(value)","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    pub struct OneOrTwoIntoIter<T> {","counters":[]},{"line":"        inner: [Option<T>; 2],","counters":[]},{"line":"        index: usize,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    impl<T> Iterator for OneOrTwoIntoIter<T> {","counters":[]},{"line":"        type Item = T;","counters":[]},{"line":"","counters":[]},{"line":"        fn next(&mut self) -> Option<Self::Item> {","counters":[{"col_start":8,"col_end":49,"count":0}]},{"line":"            let value = self.inner.get_mut(self.index)?.take()?;","counters":[{"col_start":16,"col_end":21,"count":0},{"col_start":24,"col_end":54,"count":0},{"col_start":54,"col_end":55,"count":0},{"col_start":56,"col_end":62,"count":0},{"col_start":62,"col_end":63,"count":0}]},{"line":"            self.index += 1;","counters":[{"col_start":12,"col_end":28,"count":0}]},{"line":"","counters":[]},{"line":"            Some(value)","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"        }","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"    }","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl ScanState {","counters":[]},{"line":"    pub fn hash(&self) -> AuxHash {","counters":[{"col_start":4,"col_end":35,"count":0}]},{"line":"        use binprot::BinProtWrite;","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"","counters":[]},{"line":"        let digest = self.state.hash(","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"            |buffer, proof| {","counters":[{"col_start":0,"col_end":12,"count":0},{"col_start":28,"col_end":29,"count":0}]},{"line":"                #[cfg(test)]","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"                {","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"                    let a: mina_p2p_messages::v2::TransactionSnarkScanStateLedgerProofWithSokMessageStableV2 = proof.into();","counters":[{"col_start":0,"col_end":124,"count":0}]},{"line":"                    let b: LedgerProofWithSokMessage = (&a).into();","counters":[{"col_start":0,"col_end":67,"count":0}]},{"line":"                    assert_eq!(&b, proof);","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"                }","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"","counters":[]},{"line":"                proof.binprot_write(buffer).unwrap();","counters":[{"col_start":0,"col_end":53,"count":0}]},{"line":"            },","counters":[{"col_start":0,"col_end":13,"count":0},{"col_start":13,"col_end":14,"count":0}]},{"line":"            |buffer, transaction| {","counters":[{"col_start":0,"col_end":12,"count":0},{"col_start":34,"col_end":35,"count":0}]},{"line":"                transaction.binprot_write(buffer).unwrap();","counters":[{"col_start":0,"col_end":59,"count":0}]},{"line":"            },","counters":[{"col_start":0,"col_end":13,"count":0},{"col_start":13,"col_end":14,"count":0}]},{"line":"        );","counters":[{"col_start":0,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"        AuxHash(digest.into())","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"#[derive(Clone, Debug)]","counters":[{"col_start":9,"col_end":14,"count":0},{"col_start":16,"col_end":21,"count":0}]},{"line":"pub struct ForkConstants {","counters":[]},{"line":"    previous_state_hash: Fp,    // Pickles.Backend.Tick.Field.Stable.Latest.t,","counters":[]},{"line":"    previous_length: Length,    // Mina_numbers.Length.Stable.Latest.t,","counters":[]},{"line":"    previous_global_slot: Slot, // Mina_numbers.Global_slot.Stable.Latest.t,","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"#[derive(Clone, Debug)]","counters":[{"col_start":9,"col_end":14,"count":0},{"col_start":16,"col_end":21,"count":0}]},{"line":"pub struct ConstraintConstants {","counters":[]},{"line":"    pub sub_windows_per_window: u64,","counters":[]},{"line":"    pub ledger_depth: u64,","counters":[]},{"line":"    pub work_delay: u64,","counters":[]},{"line":"    pub block_window_duration_ms: u64,","counters":[]},{"line":"    pub transaction_capacity_log_2: u64,","counters":[]},{"line":"    pub pending_coinbase_depth: u64,","counters":[]},{"line":"    pub coinbase_amount: Amount, // Currency.Amount.Stable.Latest.t,","counters":[]},{"line":"    pub supercharged_coinbase_factor: u64,","counters":[]},{"line":"    pub account_creation_fee: Fee,   // Currency.Fee.Stable.Latest.t,","counters":[]},{"line":"    pub fork: Option<ForkConstants>, // Fork_constants.t option,","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"#[derive(Clone, Debug, BinProtWrite)]","counters":[{"col_start":16,"col_end":21,"count":0},{"col_start":23,"col_end":24,"count":0},{"col_start":34,"col_end":35,"count":0}]},{"line":"pub struct ForkConstantsUnversioned {","counters":[]},{"line":"    previous_state_hash: bigint::BigInt,","counters":[]},{"line":"    previous_length: number::Int32,","counters":[]},{"line":"    previous_global_slot: number::Int32,","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl From<&ForkConstants> for ForkConstantsUnversioned {","counters":[]},{"line":"    fn from(fork_constants: &ForkConstants) -> Self {","counters":[{"col_start":4,"col_end":53,"count":0}]},{"line":"        Self {","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"            previous_state_hash: fork_constants.previous_state_hash.into(),","counters":[{"col_start":0,"col_end":75,"count":0}]},{"line":"            previous_length: (fork_constants.previous_length.as_u32() as i32).into(),","counters":[{"col_start":0,"col_end":85,"count":0}]},{"line":"            previous_global_slot: (fork_constants.previous_global_slot.as_u32() as i32).into(),","counters":[{"col_start":0,"col_end":95,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"#[derive(Clone, Debug, BinProtWrite)]","counters":[{"col_start":16,"col_end":21,"count":0},{"col_start":23,"col_end":24,"count":0},{"col_start":34,"col_end":35,"count":0}]},{"line":"pub struct ConstraintConstantsUnversioned {","counters":[]},{"line":"    pub sub_windows_per_window: number::Int64,","counters":[]},{"line":"    pub ledger_depth: number::Int64,","counters":[]},{"line":"    pub work_delay: number::Int64,","counters":[]},{"line":"    pub block_window_duration_ms: number::Int64,","counters":[]},{"line":"    pub transaction_capacity_log_2: number::Int64,","counters":[]},{"line":"    pub pending_coinbase_depth: number::Int64,","counters":[]},{"line":"    pub coinbase_amount: CurrencyAmountStableV1,","counters":[]},{"line":"    pub supercharged_coinbase_factor: number::Int64,","counters":[]},{"line":"    pub account_creation_fee: CurrencyFeeStableV1,","counters":[]},{"line":"    pub fork: Option<ForkConstantsUnversioned>,","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl From<&ConstraintConstants> for ConstraintConstantsUnversioned {","counters":[]},{"line":"    fn from(constraints: &ConstraintConstants) -> Self {","counters":[{"col_start":4,"col_end":56,"count":0}]},{"line":"        Self {","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"            sub_windows_per_window: (constraints.sub_windows_per_window as i64).into(),","counters":[{"col_start":0,"col_end":87,"count":0}]},{"line":"            ledger_depth: (constraints.ledger_depth as i64).into(),","counters":[{"col_start":0,"col_end":67,"count":0}]},{"line":"            work_delay: (constraints.work_delay as i64).into(),","counters":[{"col_start":0,"col_end":63,"count":0}]},{"line":"            block_window_duration_ms: (constraints.block_window_duration_ms as i64).into(),","counters":[{"col_start":0,"col_end":91,"count":0}]},{"line":"            transaction_capacity_log_2: (constraints.transaction_capacity_log_2 as i64).into(),","counters":[{"col_start":0,"col_end":95,"count":0}]},{"line":"            pending_coinbase_depth: (constraints.pending_coinbase_depth as i64).into(),","counters":[{"col_start":0,"col_end":87,"count":0}]},{"line":"            coinbase_amount: constraints.coinbase_amount.into(),","counters":[{"col_start":0,"col_end":64,"count":0}]},{"line":"            supercharged_coinbase_factor: (constraints.supercharged_coinbase_factor as i64).into(),","counters":[{"col_start":0,"col_end":99,"count":0}]},{"line":"            account_creation_fee: (&constraints.account_creation_fee).into(),","counters":[{"col_start":0,"col_end":77,"count":0}]},{"line":"            fork: match &constraints.fork {","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"                Some(fork) => Some(fork.into()),","counters":[{"col_start":21,"col_end":47,"count":0}]},{"line":"                None => None,","counters":[{"col_start":24,"col_end":28,"count":0}]},{"line":"            },","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl binprot::BinProtWrite for ConstraintConstants {","counters":[]},{"line":"    fn binprot_write<W: std::io::Write>(&self, w: &mut W) -> std::io::Result<()> {","counters":[{"col_start":4,"col_end":82,"count":0}]},{"line":"        let constraints: ConstraintConstantsUnversioned = self.into();","counters":[{"col_start":0,"col_end":70,"count":0}]},{"line":"        constraints.binprot_write(w)","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"/// https://github.com/MinaProtocol/mina/blob/e5183ca1dde1c085b4c5d37d1d9987e24c294c32/src/lib/transaction_snark_scan_state/transaction_snark_scan_state.ml#L175","counters":[]},{"line":"fn create_expected_statement<F>(","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"    constraint_constants: &ConstraintConstants,","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"    get_state: F,","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"    TransactionWithWitness {","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"        transaction_with_info,","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"        state_hash,","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"        statement,","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"        init_stack,","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"        ledger_witness,","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"    }: &TransactionWithWitness,","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":") -> Result<Statement<()>, String>","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"where","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"    F: Fn(&Fp) -> &MinaStateProtocolStateValueStableV2,","counters":[{"col_start":0,"col_end":55,"count":0}]},{"line":"{","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"    let mut ledger_witness = ledger_witness.clone();","counters":[{"col_start":0,"col_end":52,"count":0}]},{"line":"    let source_merkle_root = ledger_witness.merkle_root();","counters":[{"col_start":0,"col_end":58,"count":0}]},{"line":"","counters":[]},{"line":"    let WithStatus {","counters":[{"col_start":0,"col_end":20,"count":0}]},{"line":"        data: transaction, ..","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"    } = transaction_with_info.transaction();","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"    let protocol_state = get_state(&state_hash.0);","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"    let state_view = protocol_state_view(protocol_state);","counters":[{"col_start":0,"col_end":57,"count":0}]},{"line":"","counters":[]},{"line":"    let empty_local_state = LocalState::empty();","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"","counters":[]},{"line":"    let coinbase = match &transaction {","counters":[{"col_start":8,"col_end":16,"count":0},{"col_start":25,"col_end":37,"count":0}]},{"line":"        Transaction::Coinbase(coinbase) => Some(coinbase.clone()),","counters":[{"col_start":30,"col_end":65,"count":0}]},{"line":"        _ => None,","counters":[{"col_start":13,"col_end":17,"count":0}]},{"line":"    };","counters":[]},{"line":"    // Keep the error, in OCaml it is throwned later","counters":[]},{"line":"    let fee_excess_with_err = transaction.fee_excess();","counters":[{"col_start":8,"col_end":54,"count":0}]},{"line":"","counters":[]},{"line":"    let applied_transaction = apply_transaction(","counters":[{"col_start":8,"col_end":27,"count":0},{"col_start":30,"col_end":48,"count":0}]},{"line":"        constraint_constants,","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"        &state_view,","counters":[{"col_start":0,"col_end":20,"count":0}]},{"line":"        &mut ledger_witness,","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"        &transaction,","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"    )?;","counters":[{"col_start":0,"col_end":5,"count":0},{"col_start":5,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let target_merkle_root = ledger_witness.merkle_root();","counters":[{"col_start":8,"col_end":57,"count":0}]},{"line":"","counters":[]},{"line":"    let pending_coinbase_before = match init_stack {","counters":[{"col_start":8,"col_end":31,"count":0},{"col_start":40,"col_end":50,"count":0}]},{"line":"        transaction_snark::InitStack::Base(source) => source,","counters":[{"col_start":43,"col_end":60,"count":0}]},{"line":"        transaction_snark::InitStack::Merge => {","counters":[]},{"line":"            return Err(","counters":[{"col_start":19,"col_end":23,"count":0}]},{"line":"                \"Invalid init stack in Pending coinbase stack state . Expected Base found Merge\"","counters":[{"col_start":0,"col_end":96,"count":0}]},{"line":"                    .to_string(),","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"            );","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        }","counters":[]},{"line":"    };","counters":[]},{"line":"","counters":[]},{"line":"    let pending_coinbase_after = {","counters":[{"col_start":8,"col_end":30,"count":0}]},{"line":"        let state_body_hash = state_hash.1;","counters":[{"col_start":12,"col_end":43,"count":0}]},{"line":"","counters":[]},{"line":"        let pending_coinbase_with_state = pending_coinbase_before.push_state(state_body_hash);","counters":[{"col_start":0,"col_end":94,"count":0}]},{"line":"","counters":[]},{"line":"        match coinbase {","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"            Some(cb) => pending_coinbase_with_state.push_coinbase(cb),","counters":[{"col_start":17,"col_end":69,"count":0}]},{"line":"            None => pending_coinbase_with_state,","counters":[{"col_start":20,"col_end":47,"count":0}]},{"line":"        }","counters":[]},{"line":"    };","counters":[]},{"line":"","counters":[]},{"line":"    let fee_excess = fee_excess_with_err?;","counters":[{"col_start":8,"col_end":18,"count":0},{"col_start":21,"col_end":40,"count":0},{"col_start":40,"col_end":41,"count":0}]},{"line":"    let supply_increase = applied_transaction.supply_increase(constraint_constants)?;","counters":[{"col_start":8,"col_end":23,"count":0},{"col_start":26,"col_end":83,"count":0},{"col_start":83,"col_end":84,"count":0}]},{"line":"","counters":[]},{"line":"    Ok(Statement {","counters":[{"col_start":4,"col_end":18,"count":0}]},{"line":"        source: Registers {","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"            ledger: source_merkle_root,","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"            pending_coinbase_stack: statement.source.pending_coinbase_stack.clone(),","counters":[{"col_start":0,"col_end":84,"count":0}]},{"line":"            local_state: empty_local_state.clone(),","counters":[{"col_start":0,"col_end":51,"count":0}]},{"line":"        },","counters":[{"col_start":0,"col_end":10,"count":0}]},{"line":"        target: Registers {","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"            ledger: target_merkle_root,","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"            pending_coinbase_stack: pending_coinbase_after,","counters":[{"col_start":0,"col_end":59,"count":0}]},{"line":"            local_state: empty_local_state,","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"        },","counters":[{"col_start":0,"col_end":10,"count":0}]},{"line":"        supply_increase,","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"        fee_excess,","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"        sok_digest: (),","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"    })","counters":[{"col_start":0,"col_end":6,"count":0}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"fn completed_work_to_scanable_work(","counters":[]},{"line":"    job: AvailableJob,","counters":[]},{"line":"    (fee, current_proof, prover): (Fee, LedgerProof, CompressedPubKey),","counters":[]},{"line":") -> Result<LedgerProofWithSokMessage, String> {","counters":[]},{"line":"    use super::parallel_scan::AvailableJob::{Base, Merge};","counters":[]},{"line":"","counters":[]},{"line":"    let sok_digest = current_proof.0.statement.sok_digest;","counters":[{"col_start":8,"col_end":58,"count":0}]},{"line":"","counters":[]},{"line":"    let proof = &current_proof.0.proof;","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"    match job {","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        Base(TransactionWithWitness { statement, .. }) => {","counters":[{"col_start":38,"col_end":59,"count":0}]},{"line":"            let ledger_proof = LedgerProof::create(statement, sok_digest, proof.clone());","counters":[{"col_start":0,"col_end":89,"count":0}]},{"line":"            let sok_message = SokMessage::create(fee, prover);","counters":[{"col_start":0,"col_end":62,"count":0}]},{"line":"","counters":[]},{"line":"            Ok(LedgerProofWithSokMessage {","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"                proof: ledger_proof,","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"                sok_message,","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"            })","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"        }","counters":[]},{"line":"        Merge {","counters":[]},{"line":"            left: proof1,","counters":[{"col_start":18,"col_end":25,"count":0}]},{"line":"            right: proof2,","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"        } => {","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"            let s1 = proof1.proof.statement();","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"            let s2 = proof2.proof.statement();","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"","counters":[]},{"line":"            let fee_excess = FeeExcess::combine(&s1.fee_excess, &s2.fee_excess)?;","counters":[{"col_start":16,"col_end":26,"count":0},{"col_start":29,"col_end":79,"count":0},{"col_start":79,"col_end":80,"count":0}]},{"line":"","counters":[]},{"line":"            let supply_increase = s1","counters":[{"col_start":16,"col_end":36,"count":0}]},{"line":"                .supply_increase","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"                .add(&s2.supply_increase)","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"                .expect(\"Error adding supply_increases\");","counters":[{"col_start":0,"col_end":57,"count":0}]},{"line":"","counters":[]},{"line":"            if s1.target.pending_coinbase_stack != s2.source.pending_coinbase_stack {","counters":[{"col_start":0,"col_end":83,"count":0}]},{"line":"                panic!(\"Invalid pending coinbase stack state\");","counters":[{"col_start":16,"col_end":62,"count":0}]},{"line":"            }","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"            let statement = Statement {","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"                source: s1.source,","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"                target: s2.target,","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"                supply_increase,","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"                fee_excess,","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"                sok_digest: (),","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"            };","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"","counters":[]},{"line":"            let ledger_proof = LedgerProof::create(statement, sok_digest, proof.clone());","counters":[{"col_start":0,"col_end":89,"count":0}]},{"line":"            let sok_message = SokMessage::create(fee, prover);","counters":[{"col_start":0,"col_end":62,"count":0}]},{"line":"","counters":[]},{"line":"            Ok(LedgerProofWithSokMessage {","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"                proof: ledger_proof,","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"                sok_message,","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"            })","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"fn total_proofs(works: &[transaction_snark::work::Work]) -> usize {","counters":[{"col_start":0,"col_end":67,"count":0}]},{"line":"    works.iter().map(|work| work.proofs.len()).sum()","counters":[{"col_start":0,"col_end":21,"count":0},{"col_start":28,"col_end":45,"count":0},{"col_start":45,"col_end":52,"count":0}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"pub enum StatementCheck {","counters":[]},{"line":"    Partial,","counters":[]},{"line":"    Full(Box<dyn Fn(&Fp) -> &MinaStateProtocolStateValueStableV2>), // TODO: The fn returns a protocol state","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl ScanState {","counters":[]},{"line":"    pub fn scan_statement(","counters":[{"col_start":4,"col_end":26,"count":0}]},{"line":"        &self,","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"        constraint_constants: &ConstraintConstants,","counters":[{"col_start":0,"col_end":51,"count":0}]},{"line":"        statement_check: StatementCheck,","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"        verifier: &Verifier,","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"    ) -> Result<Statement<()>, String> {","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"        struct Acc(Option<(Statement<()>, Vec<LedgerProofWithSokMessage>)>);","counters":[{"col_start":0,"col_end":76,"count":0}]},{"line":"","counters":[]},{"line":"        let merge_acc = |mut proofs: Vec<LedgerProofWithSokMessage>,","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"                         acc: Acc,","counters":[]},{"line":"                         s2: &Statement<()>|","counters":[]},{"line":"         -> Result<Acc, String> {","counters":[{"col_start":32,"col_end":33,"count":0}]},{"line":"            match acc.0 {","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"                None => Ok(Acc(Some((s2.clone(), proofs)))),","counters":[{"col_start":24,"col_end":59,"count":0}]},{"line":"                Some((s1, mut ps)) => {","counters":[{"col_start":22,"col_end":32,"count":0}]},{"line":"                    let merged_statement = s1.merge(s2)?;","counters":[{"col_start":24,"col_end":40,"count":0},{"col_start":43,"col_end":55,"count":0},{"col_start":55,"col_end":56,"count":0}]},{"line":"                    proofs.append(&mut ps);","counters":[{"col_start":20,"col_end":43,"count":0}]},{"line":"                    Ok(Acc(Some((merged_statement, proofs))))","counters":[{"col_start":0,"col_end":61,"count":0}]},{"line":"                }","counters":[]},{"line":"            }","counters":[]},{"line":"        };","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        let merge_pc = |acc: Option<Statement<()>>,","counters":[{"col_start":12,"col_end":20,"count":0}]},{"line":"                        s2: &Statement<()>|","counters":[]},{"line":"         -> Result<Option<Statement<()>>, String> {","counters":[{"col_start":50,"col_end":51,"count":0}]},{"line":"            match acc {","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"                None => Ok(Some(s2.clone())),","counters":[{"col_start":24,"col_end":44,"count":0}]},{"line":"                Some(s1) => {","counters":[{"col_start":21,"col_end":29,"count":0}]},{"line":"                    if !pending_coinbase::Stack::connected(","counters":[{"col_start":0,"col_end":59,"count":0}]},{"line":"                        &s1.target.pending_coinbase_stack,","counters":[{"col_start":0,"col_end":58,"count":0}]},{"line":"                        &s2.source.pending_coinbase_stack,","counters":[{"col_start":0,"col_end":58,"count":0}]},{"line":"                        Some(&s1.source.pending_coinbase_stack),","counters":[{"col_start":0,"col_end":64,"count":0}]},{"line":"                    ) {","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"                        return Err(format!(","counters":[{"col_start":31,"col_end":43,"count":0}]},{"line":"                            \"Base merge proof: invalid pending coinbase \\","counters":[{"col_start":0,"col_end":73,"count":0}]},{"line":"                             transition s1: {:?} s2: {:?}\",","counters":[{"col_start":0,"col_end":59,"count":0}]},{"line":"                            s1, s2","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"                        ));","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"                    }","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                    Ok(Some(s2.clone()))","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"                }","counters":[]},{"line":"            }","counters":[]},{"line":"        };","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        let fold_step_a = |(acc_statement, acc_pc): (Acc, Option<Statement<()>>),","counters":[{"col_start":12,"col_end":26,"count":0}]},{"line":"                           job: &merge::Job<LedgerProofWithSokMessage>|","counters":[]},{"line":"         -> Result<(Acc, Option<Statement<()>>), String> {","counters":[]},{"line":"            use merge::{","counters":[]},{"line":"                Job::{Empty, Full, Part},","counters":[]},{"line":"                Record,","counters":[]},{"line":"            };","counters":[]},{"line":"            use JobStatus::Done;","counters":[]},{"line":"","counters":[]},{"line":"            match job {","counters":[{"col_start":18,"col_end":21,"count":0}]},{"line":"                Part(ref ledger @ LedgerProofWithSokMessage { ref proof, .. }) => {","counters":[{"col_start":21,"col_end":83,"count":0}]},{"line":"                    let statement = proof.statement();","counters":[{"col_start":0,"col_end":53,"count":0}]},{"line":"                    let acc_stmt = merge_acc(vec![ledger.clone()], acc_statement, &statement)?;","counters":[{"col_start":24,"col_end":32,"count":0},{"col_start":35,"col_end":93,"count":0},{"col_start":93,"col_end":94,"count":0}]},{"line":"                    Ok((acc_stmt, acc_pc))","counters":[{"col_start":20,"col_end":42,"count":0}]},{"line":"                }","counters":[]},{"line":"                Empty | Full(Record { state: Done, .. }) => Ok((acc_statement, acc_pc)),","counters":[{"col_start":60,"col_end":87,"count":0}]},{"line":"                Full(Record { left, right, .. }) => {","counters":[{"col_start":30,"col_end":53,"count":0}]},{"line":"                    let LedgerProofWithSokMessage { proof: proof1, .. } = &left;","counters":[{"col_start":0,"col_end":80,"count":0}]},{"line":"                    let LedgerProofWithSokMessage { proof: proof2, .. } = &right;","counters":[{"col_start":0,"col_end":81,"count":0}]},{"line":"","counters":[]},{"line":"                    let stmt1 = proof1.statement();","counters":[{"col_start":0,"col_end":51,"count":0}]},{"line":"                    let stmt2 = proof2.statement();","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"                    let merged_statement = stmt1.merge(&stmt2)?;","counters":[{"col_start":24,"col_end":40,"count":0},{"col_start":43,"col_end":62,"count":0},{"col_start":62,"col_end":63,"count":0}]},{"line":"","counters":[]},{"line":"                    let acc_stmt = merge_acc(","counters":[{"col_start":24,"col_end":32,"count":0},{"col_start":35,"col_end":45,"count":0}]},{"line":"                        vec![left.clone(), right.clone()],","counters":[{"col_start":0,"col_end":58,"count":0}]},{"line":"                        acc_statement,","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"                        &merged_statement,","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"                    )?;","counters":[{"col_start":0,"col_end":21,"count":0},{"col_start":21,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"                    Ok((acc_stmt, acc_pc))","counters":[{"col_start":20,"col_end":42,"count":0}]},{"line":"                }","counters":[]},{"line":"            }","counters":[]},{"line":"        };","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        let fold_step_d = |(acc_statement, acc_pc): (Acc, Option<Statement<()>>),","counters":[{"col_start":12,"col_end":26,"count":0}]},{"line":"                           job: &base::Job<TransactionWithWitness>|","counters":[]},{"line":"         -> Result<(Acc, Option<Statement<()>>), String> {","counters":[]},{"line":"            use base::{","counters":[]},{"line":"                Job::{Empty, Full},","counters":[]},{"line":"                Record,","counters":[]},{"line":"            };","counters":[]},{"line":"            use JobStatus::Done;","counters":[]},{"line":"","counters":[]},{"line":"            match job {","counters":[{"col_start":18,"col_end":21,"count":0}]},{"line":"                Empty => Ok((acc_statement, acc_pc)),","counters":[{"col_start":25,"col_end":52,"count":0}]},{"line":"                Full(Record {","counters":[]},{"line":"                    state: Done,","counters":[]},{"line":"                    job: transaction,","counters":[{"col_start":25,"col_end":36,"count":0}]},{"line":"                    ..","counters":[]},{"line":"                }) => {","counters":[]},{"line":"                    let acc_pc = merge_pc(acc_pc, &transaction.statement)?;","counters":[{"col_start":24,"col_end":30,"count":0},{"col_start":33,"col_end":73,"count":0},{"col_start":73,"col_end":74,"count":0}]},{"line":"                    Ok((acc_statement, acc_pc))","counters":[{"col_start":20,"col_end":47,"count":0}]},{"line":"                }","counters":[]},{"line":"                Full(Record {","counters":[]},{"line":"                    job: transaction, ..","counters":[{"col_start":25,"col_end":36,"count":0}]},{"line":"                }) => {","counters":[]},{"line":"                    use StatementCheck::{Full, Partial};","counters":[]},{"line":"","counters":[]},{"line":"                    let expected_statement = match &statement_check {","counters":[{"col_start":24,"col_end":42,"count":0},{"col_start":51,"col_end":67,"count":0}]},{"line":"                        Full(get_state) => create_expected_statement(","counters":[{"col_start":29,"col_end":69,"count":0}]},{"line":"                            constraint_constants,","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"                            &**get_state,","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"                            transaction,","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"                        )?,","counters":[{"col_start":0,"col_end":25,"count":0},{"col_start":25,"col_end":26,"count":0}]},{"line":"                        Partial => transaction.statement.clone(),","counters":[{"col_start":35,"col_end":64,"count":0}]},{"line":"                    };","counters":[]},{"line":"","counters":[]},{"line":"                    if transaction.statement == expected_statement {","counters":[{"col_start":23,"col_end":66,"count":0}]},{"line":"                        let acc_stmt =","counters":[{"col_start":28,"col_end":36,"count":0}]},{"line":"                            merge_acc(Vec::new(), acc_statement, &transaction.statement)?;","counters":[{"col_start":28,"col_end":88,"count":0},{"col_start":88,"col_end":89,"count":0}]},{"line":"                        let acc_pc = merge_pc(acc_pc, &transaction.statement)?;","counters":[{"col_start":28,"col_end":34,"count":0},{"col_start":37,"col_end":77,"count":0},{"col_start":77,"col_end":78,"count":0}]},{"line":"","counters":[]},{"line":"                        Ok((acc_stmt, acc_pc))","counters":[{"col_start":24,"col_end":46,"count":0}]},{"line":"                    } else {","counters":[]},{"line":"                        Err(format!(","counters":[{"col_start":24,"col_end":36,"count":0}]},{"line":"                            \"Bad base statement expected: {:#?} got: {:#?}\",","counters":[{"col_start":0,"col_end":76,"count":0}]},{"line":"                            transaction.statement, expected_statement","counters":[{"col_start":0,"col_end":69,"count":0}]},{"line":"                        ))","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"                    }","counters":[]},{"line":"                }","counters":[]},{"line":"            }","counters":[]},{"line":"        };","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        let res = self.state.fold_chronological_until_err(","counters":[{"col_start":12,"col_end":15,"count":0},{"col_start":18,"col_end":58,"count":0}]},{"line":"            (Acc(None), None),","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"            |acc, merge::Merge { weight: _, job }| fold_step_a(acc, job),","counters":[{"col_start":0,"col_end":12,"count":0},{"col_start":51,"col_end":72,"count":0},{"col_start":72,"col_end":73,"count":0}]},{"line":"            |acc, base::Base { weight: _, job }| fold_step_d(acc, job),","counters":[{"col_start":0,"col_end":12,"count":0},{"col_start":49,"col_end":70,"count":0},{"col_start":70,"col_end":71,"count":0}]},{"line":"            |v| v,","counters":[{"col_start":0,"col_end":12,"count":0},{"col_start":16,"col_end":17,"count":0},{"col_start":17,"col_end":18,"count":0}]},{"line":"        )?;","counters":[{"col_start":0,"col_end":9,"count":0},{"col_start":9,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"        match res {","counters":[{"col_start":14,"col_end":17,"count":0}]},{"line":"            (Acc(None), _) => Err(\"Empty\".to_string()),","counters":[{"col_start":30,"col_end":54,"count":0}]},{"line":"            (Acc(Some((res, proofs))), _) => match verifier.verify(proofs.as_slice()) {","counters":[{"col_start":23,"col_end":85,"count":0}]},{"line":"                Ok(true) => Ok(res),","counters":[{"col_start":28,"col_end":35,"count":0}]},{"line":"                Ok(false) => Err(\"Bad proofs\".to_string()),","counters":[{"col_start":29,"col_end":58,"count":0}]},{"line":"                Err(e) => Err(e),","counters":[{"col_start":20,"col_end":32,"count":0}]},{"line":"            },","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn check_invariants(","counters":[{"col_start":4,"col_end":28,"count":1}]},{"line":"        &self,","counters":[{"col_start":0,"col_end":14,"count":1}]},{"line":"        constraint_constants: &ConstraintConstants,","counters":[{"col_start":0,"col_end":51,"count":1}]},{"line":"        statement_check: StatementCheck,","counters":[{"col_start":0,"col_end":40,"count":1}]},{"line":"        verifier: &Verifier,","counters":[{"col_start":0,"col_end":28,"count":1}]},{"line":"        _error_prefix: &'static str,","counters":[{"col_start":0,"col_end":36,"count":1}]},{"line":"        _registers_begin: Option<&Registers>,","counters":[{"col_start":0,"col_end":45,"count":1}]},{"line":"        _registers_end: Registers,","counters":[{"col_start":0,"col_end":34,"count":1}]},{"line":"    ) -> Result<(), String> {","counters":[{"col_start":0,"col_end":29,"count":1}]},{"line":"        // TODO: OCaml does much more than this (pretty printing error)","counters":[{"col_start":0,"col_end":71,"count":1}]},{"line":"        match self.scan_statement(constraint_constants, statement_check, verifier) {","counters":[{"col_start":0,"col_end":82,"count":1}]},{"line":"            Ok(_) => Ok(()),","counters":[{"col_start":21,"col_end":27,"count":1}]},{"line":"            Err(s) => Err(s),","counters":[{"col_start":16,"col_end":28,"count":0}]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":1}]},{"line":"","counters":[]},{"line":"    fn statement_of_job(job: &AvailableJob) -> Option<Statement<()>> {","counters":[{"col_start":4,"col_end":70,"count":0}]},{"line":"        use super::parallel_scan::AvailableJob::{Base, Merge};","counters":[{"col_start":0,"col_end":62,"count":0}]},{"line":"","counters":[]},{"line":"        match job {","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"            Base(TransactionWithWitness { statement, .. }) => Some(statement.clone()),","counters":[{"col_start":42,"col_end":85,"count":0}]},{"line":"            Merge { left, right } => {","counters":[{"col_start":20,"col_end":38,"count":0}]},{"line":"                let LedgerProofWithSokMessage { proof: p1, .. } = left;","counters":[{"col_start":0,"col_end":71,"count":0}]},{"line":"                let LedgerProofWithSokMessage { proof: p2, .. } = right;","counters":[{"col_start":0,"col_end":72,"count":0}]},{"line":"","counters":[]},{"line":"                p1.statement().merge(&p2.statement()).ok()","counters":[{"col_start":0,"col_end":58,"count":0}]},{"line":"            }","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn create(work_delay: u64, transaction_capacity_log_2: u64) -> Self {","counters":[{"col_start":4,"col_end":73,"count":0}]},{"line":"        let k = 2u64.pow(transaction_capacity_log_2 as u32);","counters":[{"col_start":0,"col_end":60,"count":0}]},{"line":"","counters":[]},{"line":"        Self {","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"            state: ParallelScan::empty(k, work_delay),","counters":[{"col_start":0,"col_end":54,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn empty(constraint_constants: &ConstraintConstants) -> Self {","counters":[{"col_start":4,"col_end":70,"count":0}]},{"line":"        let work_delay = constraint_constants.work_delay;","counters":[{"col_start":0,"col_end":57,"count":0}]},{"line":"        let transaction_capacity_log_2 = constraint_constants.transaction_capacity_log_2;","counters":[{"col_start":0,"col_end":89,"count":0}]},{"line":"","counters":[]},{"line":"        Self::create(work_delay, transaction_capacity_log_2)","counters":[{"col_start":0,"col_end":60,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn extract_txns(","counters":[{"col_start":4,"col_end":20,"count":0}]},{"line":"        txns_with_witnesses: &[TransactionWithWitness],","counters":[{"col_start":0,"col_end":55,"count":0}]},{"line":"    ) -> Vec<(WithStatus<Transaction>, Fp)> {","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"        txns_with_witnesses","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"            .iter()","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"            .map(|txns_with_witnesses: &TransactionWithWitness| {","counters":[{"col_start":0,"col_end":17,"count":0},{"col_start":64,"col_end":65,"count":0}]},{"line":"                let txn = txns_with_witnesses.transaction_with_info.transaction();","counters":[{"col_start":0,"col_end":82,"count":0}]},{"line":"                let state_hash = txns_with_witnesses.state_hash.0;","counters":[{"col_start":0,"col_end":66,"count":0}]},{"line":"                (txn, state_hash)","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"            })","counters":[{"col_start":0,"col_end":13,"count":0},{"col_start":13,"col_end":14,"count":0}]},{"line":"            .collect()","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn latest_ledger_proof(","counters":[{"col_start":4,"col_end":31,"count":0}]},{"line":"        &self,","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"    ) -> Option<(","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"        &LedgerProofWithSokMessage,","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"        Vec<(WithStatus<Transaction>, Fp)>,","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"    )> {","counters":[{"col_start":0,"col_end":7,"count":0}]},{"line":"        let (proof, txns_with_witnesses) = self.state.last_emitted_value()?;","counters":[{"col_start":13,"col_end":39,"count":0},{"col_start":43,"col_end":74,"count":0},{"col_start":74,"col_end":75,"count":0}]},{"line":"        Some((proof, Self::extract_txns(txns_with_witnesses.as_slice())))","counters":[{"col_start":8,"col_end":73,"count":0}]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn free_space(&self) -> u64 {","counters":[{"col_start":4,"col_end":37,"count":0}]},{"line":"        self.state.free_space()","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn all_jobs(&self) -> Vec<Vec<AvailableJob>> {","counters":[{"col_start":4,"col_end":50,"count":0}]},{"line":"        self.state.all_jobs()","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn next_on_new_tree(&self) -> bool {","counters":[{"col_start":4,"col_end":44,"count":0}]},{"line":"        self.state.next_on_new_tree()","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn base_jobs_on_latest_tree(&self) -> impl Iterator<Item = TransactionWithWitness> {","counters":[{"col_start":4,"col_end":92,"count":0}]},{"line":"        self.state.base_jobs_on_latest_tree()","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn base_jobs_on_earlier_tree(","counters":[{"col_start":4,"col_end":37,"count":0}]},{"line":"        &self,","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"        index: usize,","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"    ) -> impl Iterator<Item = TransactionWithWitness> {","counters":[{"col_start":0,"col_end":55,"count":0}]},{"line":"        self.state.base_jobs_on_earlier_tree(index)","counters":[{"col_start":0,"col_end":51,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn staged_transactions(&self) -> Vec<WithStatus<Transaction>> {","counters":[]},{"line":"        self.state","counters":[]},{"line":"            .pending_data()","counters":[]},{"line":"            .into_iter()","counters":[]},{"line":"            .map(|transaction_with_witness| {","counters":[]},{"line":"                transaction_with_witness.transaction_with_info.transaction()","counters":[]},{"line":"            })","counters":[]},{"line":"            .collect()","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    pub fn staged_transactions_with_protocol_states<F>(","counters":[]},{"line":"        &self,","counters":[]},{"line":"        get_state: F,","counters":[]},{"line":"    ) -> Vec<(WithStatus<Transaction>, MinaStateProtocolStateValueStableV2)>","counters":[]},{"line":"    where","counters":[]},{"line":"        F: Fn(&Fp) -> &MinaStateProtocolStateValueStableV2,","counters":[]},{"line":"    {","counters":[]},{"line":"        self.state","counters":[]},{"line":"            .pending_data()","counters":[]},{"line":"            .into_iter()","counters":[]},{"line":"            .map(|transaction_with_witness| {","counters":[]},{"line":"                let txn = transaction_with_witness.transaction_with_info.transaction();","counters":[]},{"line":"                let protocol_state = get_state(&transaction_with_witness.state_hash.0);","counters":[]},{"line":"                (txn, protocol_state.clone())","counters":[]},{"line":"            })","counters":[]},{"line":"            .collect()","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    pub fn partition_if_overflowing(&self) -> SpacePartition {","counters":[{"col_start":4,"col_end":62,"count":0}]},{"line":"        let bundle_count = |work_count: u64| (work_count + 1) / 2;","counters":[{"col_start":0,"col_end":24,"count":0},{"col_start":45,"col_end":65,"count":0}]},{"line":"","counters":[]},{"line":"        // slots: current tree space","counters":[]},{"line":"        // job_count: work count on current tree","counters":[]},{"line":"        let SpacePartition {","counters":[]},{"line":"            first: (slots, job_count),","counters":[{"col_start":20,"col_end":38,"count":0}]},{"line":"            second,","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"        } = self.state.partition_if_overflowing();","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"","counters":[]},{"line":"        SpacePartition {","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"            first: (slots, bundle_count(job_count)),","counters":[{"col_start":0,"col_end":52,"count":0}]},{"line":"            second: second.map(|(slots, job_count)| (slots, bundle_count(job_count))),","counters":[{"col_start":0,"col_end":31,"count":0},{"col_start":52,"col_end":84,"count":0},{"col_start":84,"col_end":86,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn extract_from_job(job: AvailableJob) -> Extracted {","counters":[{"col_start":4,"col_end":57,"count":0}]},{"line":"        use super::parallel_scan::AvailableJob::{Base, Merge};","counters":[{"col_start":0,"col_end":62,"count":0}]},{"line":"","counters":[]},{"line":"        match job {","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"            Base(d) => Extracted::First {","counters":[{"col_start":17,"col_end":41,"count":0}]},{"line":"                transaction_with_info: d.transaction_with_info,","counters":[{"col_start":0,"col_end":63,"count":0}]},{"line":"                statement: Box::new(d.statement),","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"                state_hash: d.state_hash,","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"                ledger_witness: d.ledger_witness,","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"                init_stack: d.init_stack,","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"            },","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"            Merge {","counters":[]},{"line":"                left: LedgerProofWithSokMessage { proof: p1, .. },","counters":[{"col_start":57,"col_end":66,"count":0}]},{"line":"                right: LedgerProofWithSokMessage { proof: p2, .. },","counters":[{"col_start":0,"col_end":67,"count":0}]},{"line":"            } => Extracted::Second(Box::new((p1, p2))),","counters":[{"col_start":0,"col_end":54,"count":0}]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn all_work_statements_exn(&self) -> Vec<transaction_snark::work::Statement> {","counters":[{"col_start":4,"col_end":86,"count":0}]},{"line":"        let work_seqs = self.all_jobs();","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"        let s = |job: &AvailableJob| Self::statement_of_job(job).unwrap();","counters":[{"col_start":0,"col_end":13,"count":0},{"col_start":37,"col_end":73,"count":0}]},{"line":"","counters":[]},{"line":"        work_seqs","counters":[{"col_start":8,"col_end":17,"count":0}]},{"line":"            .iter()","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"            .flat_map(|work_seq| group_list(work_seq, s))","counters":[{"col_start":0,"col_end":22,"count":0},{"col_start":33,"col_end":56,"count":0},{"col_start":56,"col_end":57,"count":0}]},{"line":"            .collect()","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn required_work_pairs(&self, slots: u64) -> Vec<OneOrTwo<AvailableJob>> {","counters":[]},{"line":"        let work_list = self.state.jobs_for_slots(slots);","counters":[]},{"line":"        work_list","counters":[]},{"line":"            .iter()","counters":[]},{"line":"            .flat_map(|works| group_list(works, |job| job.clone()))","counters":[]},{"line":"            .collect()","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    pub fn k_work_pairs_for_new_diff(&self, k: u64) -> Vec<OneOrTwo<AvailableJob>> {","counters":[{"col_start":4,"col_end":84,"count":0}]},{"line":"        let work_list = self.state.jobs_for_next_update();","counters":[{"col_start":0,"col_end":58,"count":0}]},{"line":"        work_list","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"            .iter()","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"            .flat_map(|works| group_list(works, |job| job.clone()))","counters":[{"col_start":0,"col_end":22,"count":0},{"col_start":30,"col_end":48,"count":0},{"col_start":54,"col_end":65,"count":0},{"col_start":65,"col_end":66,"count":0},{"col_start":66,"col_end":67,"count":0}]},{"line":"            .take(k as usize)","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"            .collect()","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    // Always the same pairing of jobs","counters":[]},{"line":"    pub fn work_statements_for_new_diff(&self) -> Vec<transaction_snark::work::Statement> {","counters":[{"col_start":4,"col_end":91,"count":0}]},{"line":"        let work_list = self.state.jobs_for_next_update();","counters":[{"col_start":0,"col_end":58,"count":0}]},{"line":"","counters":[]},{"line":"        let s = |job: &AvailableJob| Self::statement_of_job(job).unwrap();","counters":[{"col_start":0,"col_end":13,"count":0},{"col_start":37,"col_end":73,"count":0}]},{"line":"","counters":[]},{"line":"        work_list","counters":[{"col_start":8,"col_end":17,"count":0}]},{"line":"            .iter()","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"            .flat_map(|works| group_list(works, s))","counters":[{"col_start":0,"col_end":22,"count":0},{"col_start":30,"col_end":50,"count":0},{"col_start":50,"col_end":51,"count":0}]},{"line":"            .collect()","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn all_work_pairs<F>(","counters":[]},{"line":"        &self,","counters":[]},{"line":"        get_state: F,","counters":[]},{"line":"    ) -> Result<Vec<OneOrTwo<snark_work::spec::Work>>, String>","counters":[]},{"line":"    where","counters":[]},{"line":"        F: Fn(&Fp) -> &MinaStateProtocolStateValueStableV2,","counters":[]},{"line":"    {","counters":[]},{"line":"        let all_jobs = self.all_jobs();","counters":[]},{"line":"","counters":[]},{"line":"        let single_spec = |job: AvailableJob| match Self::extract_from_job(job) {","counters":[]},{"line":"            Extracted::First {","counters":[]},{"line":"                transaction_with_info,","counters":[]},{"line":"                statement,","counters":[]},{"line":"                state_hash,","counters":[]},{"line":"                ledger_witness,","counters":[]},{"line":"                init_stack,","counters":[]},{"line":"            } => {","counters":[]},{"line":"                let witness = {","counters":[]},{"line":"                    let WithStatus {","counters":[]},{"line":"                        data: transaction,","counters":[]},{"line":"                        status,","counters":[]},{"line":"                    } = transaction_with_info.transaction();","counters":[]},{"line":"","counters":[]},{"line":"                    let protocol_state_body = {","counters":[]},{"line":"                        let state = get_state(&state_hash.0);","counters":[]},{"line":"                        state.body.clone()","counters":[]},{"line":"                    };","counters":[]},{"line":"","counters":[]},{"line":"                    let init_stack = match init_stack {","counters":[]},{"line":"                        InitStack::Base(x) => x,","counters":[]},{"line":"                        InitStack::Merge => return Err(\"init_stack was Merge\".to_string()),","counters":[]},{"line":"                    };","counters":[]},{"line":"","counters":[]},{"line":"                    TransactionWitness {","counters":[]},{"line":"                        transaction,","counters":[]},{"line":"                        ledger: ledger_witness,","counters":[]},{"line":"                        protocol_state_body,","counters":[]},{"line":"                        init_stack,","counters":[]},{"line":"                        status,","counters":[]},{"line":"                    }","counters":[]},{"line":"                };","counters":[]},{"line":"","counters":[]},{"line":"                Ok(snark_work::spec::Work::Transition((statement, witness)))","counters":[]},{"line":"            }","counters":[]},{"line":"            Extracted::Second(s) => {","counters":[]},{"line":"                let merged = s.0.statement().merge(&s.1.statement())?;","counters":[]},{"line":"                Ok(snark_work::spec::Work::Merge((merged, s)))","counters":[]},{"line":"            }","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        all_jobs","counters":[]},{"line":"            .iter()","counters":[]},{"line":"            .flat_map(|jobs| {","counters":[]},{"line":"                group_list(jobs.as_slice(), |j| j.clone())","counters":[]},{"line":"                    .map(|group| group.into_map_err(single_spec))","counters":[]},{"line":"            })","counters":[]},{"line":"            .collect()","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    pub fn fill_work_and_enqueue_transactions(","counters":[{"col_start":4,"col_end":46,"count":0}]},{"line":"        &mut self,","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"        transactions: Vec<TransactionWithWitness>,","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"        work: Vec<transaction_snark::work::Unchecked>,","counters":[{"col_start":0,"col_end":54,"count":0}]},{"line":"    ) -> Result<Option<(LedgerProof, Vec<(WithStatus<Transaction>, Fp)>)>, String> {","counters":[{"col_start":0,"col_end":84,"count":0}]},{"line":"        // println!(\"fill_work_and_enqueue_transactions tx={:?} work={:?}\", transactions.len(), work.len());","counters":[{"col_start":0,"col_end":108,"count":0}]},{"line":"","counters":[]},{"line":"        {","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"            use crate::scan_state::transaction_logic::transaction_applied::Varying::*;","counters":[{"col_start":0,"col_end":86,"count":0}]},{"line":"","counters":[]},{"line":"            println!(\"{} transactions added to scan state:\", transactions.len());","counters":[{"col_start":0,"col_end":81,"count":0}]},{"line":"            println!(","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"                \"- num_fee_transfer={:?}\",","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"                transactions","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"                    .iter()","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"                    .filter(|tx| matches!(tx.transaction_with_info.varying, FeeTransfer(_)))","counters":[{"col_start":0,"col_end":28,"count":0},{"col_start":33,"col_end":41,"count":0},{"col_start":42,"col_end":74,"count":0},{"col_start":90,"col_end":91,"count":0},{"col_start":91,"col_end":92,"count":0}]},{"line":"                    .count()","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"            );","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"","counters":[]},{"line":"            println!(","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"                \"- num_coinbase={:?}\",","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"                transactions","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"                    .iter()","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"                    .filter(|tx| matches!(tx.transaction_with_info.varying, Coinbase(_)))","counters":[{"col_start":0,"col_end":28,"count":0},{"col_start":33,"col_end":41,"count":0},{"col_start":42,"col_end":74,"count":0},{"col_start":87,"col_end":88,"count":0},{"col_start":88,"col_end":89,"count":0}]},{"line":"                    .count()","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"            );","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"","counters":[]},{"line":"            println!(","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"                \"- num_user_command={:?}\",","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"                transactions","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"                    .iter()","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"                    .filter(|tx| matches!(tx.transaction_with_info.varying, Command(_)))","counters":[{"col_start":0,"col_end":28,"count":0},{"col_start":33,"col_end":41,"count":0},{"col_start":42,"col_end":74,"count":0},{"col_start":86,"col_end":87,"count":0},{"col_start":87,"col_end":88,"count":0}]},{"line":"                    .count()","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"            );","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        let fill_in_transaction_snark_work =","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"            |works: Vec<transaction_snark::work::Work>| -> Result<Vec<LedgerProofWithSokMessage>, String>","counters":[]},{"line":"        {","counters":[{"col_start":8,"col_end":9,"count":0}]},{"line":"            let next_jobs = self","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"                .state","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"                .jobs_for_next_update()","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"                .into_iter()","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"                .flatten()","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"                .take(total_proofs(&works));","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"            let works = works.into_iter().flat_map(|transaction_snark::work::Work { fee, proofs, prover }| {","counters":[{"col_start":0,"col_end":51,"count":0},{"col_start":107,"col_end":108,"count":0}]},{"line":"                proofs.into_map(|proof| (fee, proof, prover.clone())).into_iter()","counters":[{"col_start":0,"col_end":32,"count":0},{"col_start":40,"col_end":68,"count":0},{"col_start":68,"col_end":81,"count":0}]},{"line":"            });","counters":[{"col_start":0,"col_end":13,"count":0},{"col_start":13,"col_end":15,"count":0}]},{"line":"","counters":[]},{"line":"            next_jobs.zip(works).map(|(job, work)| completed_work_to_scanable_work(job, work)).collect()","counters":[{"col_start":0,"col_end":37,"count":0},{"col_start":51,"col_end":93,"count":0},{"col_start":93,"col_end":104,"count":0}]},{"line":"        };","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        let old_proof = self.state.last_emitted_value().cloned();","counters":[{"col_start":12,"col_end":64,"count":0}]},{"line":"        let work_list = fill_in_transaction_snark_work(work)?;","counters":[{"col_start":12,"col_end":21,"count":0},{"col_start":24,"col_end":60,"count":0},{"col_start":60,"col_end":61,"count":0}]},{"line":"","counters":[]},{"line":"        let proof_opt = self","counters":[{"col_start":12,"col_end":28,"count":0}]},{"line":"            .state","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"            .update(transactions, work_list, |base| {","counters":[{"col_start":0,"col_end":45,"count":0},{"col_start":52,"col_end":53,"count":0}]},{"line":"                // TODO: This is for logs only, make it cleaner","counters":[{"col_start":0,"col_end":63,"count":0}]},{"line":"                match base.transaction_with_info.varying {","counters":[{"col_start":0,"col_end":56,"count":0}]},{"line":"                    super::transaction_logic::transaction_applied::Varying::Command(_) => 0,","counters":[{"col_start":90,"col_end":91,"count":0}]},{"line":"                    super::transaction_logic::transaction_applied::Varying::FeeTransfer(_) => 1,","counters":[{"col_start":94,"col_end":95,"count":0}]},{"line":"                    super::transaction_logic::transaction_applied::Varying::Coinbase(_) => 2,","counters":[{"col_start":91,"col_end":92,"count":0}]},{"line":"                }","counters":[]},{"line":"            })","counters":[{"col_start":12,"col_end":13,"count":0},{"col_start":13,"col_end":14,"count":0}]},{"line":"            .unwrap();","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"        match proof_opt {","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"            None => Ok(None),","counters":[{"col_start":20,"col_end":28,"count":0}]},{"line":"            Some((LedgerProofWithSokMessage { proof, .. }, txns_with_witnesses)) => {","counters":[{"col_start":46,"col_end":85,"count":0}]},{"line":"                let curr_source = &proof.statement().source;","counters":[{"col_start":0,"col_end":60,"count":0}]},{"line":"","counters":[]},{"line":"                // TODO(OCaml): get genesis ledger hash if the old_proof is none","counters":[{"col_start":0,"col_end":80,"count":0}]},{"line":"","counters":[]},{"line":"                let prev_target = old_proof","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"                    .as_ref()","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"                    .map(|p| &p.0.proof.statement_ref().target)","counters":[{"col_start":0,"col_end":25,"count":0},{"col_start":29,"col_end":62,"count":0},{"col_start":62,"col_end":63,"count":0}]},{"line":"                    .unwrap_or(curr_source);","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"                // prev_target is connected to curr_source- Order of the arguments is","counters":[{"col_start":0,"col_end":85,"count":0}]},{"line":"                // important here","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"","counters":[]},{"line":"                if Registers::connected(prev_target, curr_source) {","counters":[{"col_start":0,"col_end":65,"count":0}]},{"line":"                    Ok(Some((proof, Self::extract_txns(&txns_with_witnesses))))","counters":[{"col_start":20,"col_end":79,"count":0}]},{"line":"                } else {","counters":[]},{"line":"                    Err(\"Unexpected ledger proof emitted\".to_string())","counters":[{"col_start":20,"col_end":70,"count":0}]},{"line":"                }","counters":[]},{"line":"            }","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn required_state_hashes(&self) -> HashSet<Fp> {","counters":[]},{"line":"        self.state","counters":[]},{"line":"            .pending_data()","counters":[]},{"line":"            .iter()","counters":[]},{"line":"            .map(|t| t.state_hash.0)","counters":[]},{"line":"            .collect()","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn check_required_protocol_states(&self, _protocol_states: ()) {","counters":[]},{"line":"        todo!() // Not sure what is the type of `protocol_states` here","counters":[]},{"line":"    }","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"pub fn group_list<'a, F, T, R>(slice: &'a [T], fun: F) -> impl Iterator<Item = OneOrTwo<R>> + '_","counters":[{"col_start":0,"col_end":96,"count":267}]},{"line":"where","counters":[{"col_start":0,"col_end":5,"count":267}]},{"line":"    F: Fn(&'a T) -> R + 'a,","counters":[{"col_start":0,"col_end":27,"count":267}]},{"line":"{","counters":[{"col_start":0,"col_end":1,"count":267}]},{"line":"    slice.chunks(2).map(move |subslice| match subslice {","counters":[{"col_start":0,"col_end":24,"count":267},{"col_start":40,"col_end":54,"count":0}]},{"line":"        [a, b] => OneOrTwo::Two((fun(a), fun(b))),","counters":[{"col_start":9,"col_end":49,"count":0}]},{"line":"        [a] => OneOrTwo::One(fun(a)),","counters":[{"col_start":9,"col_end":36,"count":16}]},{"line":"        _ => panic!(),","counters":[{"col_start":13,"col_end":21,"count":0}]},{"line":"    })","counters":[{"col_start":4,"col_end":5,"count":16},{"col_start":5,"col_end":6,"count":267}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":267}]},{"line":"","counters":[]},{"line":"pub enum Extracted {","counters":[]},{"line":"    First {","counters":[]},{"line":"        transaction_with_info: TransactionApplied,","counters":[]},{"line":"        statement: Box<Statement<()>>,","counters":[]},{"line":"        state_hash: (Fp, Fp),","counters":[]},{"line":"        ledger_witness: SparseLedger<AccountId, Account>,","counters":[]},{"line":"        init_stack: InitStack,","counters":[]},{"line":"    },","counters":[]},{"line":"    Second(Box<(LedgerProof, LedgerProof)>),","counters":[]},{"line":"}","counters":[]}]}