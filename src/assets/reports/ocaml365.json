{"filename":"src/lib/secrets/secret_file.ml","lines":[{"line":"open Core","counters":[]},{"line":"open Async","counters":[]},{"line":"","counters":[]},{"line":"type password = Bytes.t Async.Deferred.t Lazy.t","counters":[]},{"line":"","counters":[]},{"line":"let handle_open ~mkdir ~(f : string -> 'a Deferred.t) path =","counters":[]},{"line":"  let corrupted_privkey = Privkey_error.corrupted_privkey in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let open Unix.Error in","counters":[]},{"line":"  let open Deferred.Result.Let_syntax in","counters":[]},{"line":"  let dn = Filename.dirname path in","counters":[]},{"line":"  let%bind parent_exists =","counters":[]},{"line":"    let open Deferred.Let_syntax in","counters":[]},{"line":"    match%bind","counters":[]},{"line":"      Monitor.try_with ~here:[%here] ~extract_exn:true (fun () ->","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"          let%bind stat = Unix.stat dn in","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"          Deferred.return","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          @@","counters":[]},{"line":"          if Unix.File_kind.equal stat.kind `Directory then Ok true","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"          else","counters":[]},{"line":"            corrupted_privkey","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"              (Error.createf","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                 \"%s exists and it is not a directory, can't store files there\"","counters":[]},{"line":"                 dn ) )","counters":[]},{"line":"    with","counters":[]},{"line":"    | Ok x ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        return x","counters":[]},{"line":"    | Error (Unix.Unix_error (ENOENT, _, _)) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Deferred.Result.return false","counters":[]},{"line":"    | Error (Unix.Unix_error (e, _, _)) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Deferred.return @@ corrupted_privkey","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"        @@ Error.createf","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"             !\"could not stat %s: %s, not making keys\\n\"","counters":[]},{"line":"             dn (message e)","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"    | Error e ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Deferred.return @@ corrupted_privkey (Error.of_exn e)","counters":[{"col_start":43,"col_end":43,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%bind () =","counters":[]},{"line":"    let open Deferred.Let_syntax in","counters":[]},{"line":"    match%bind","counters":[]},{"line":"      Monitor.try_with ~here:[%here] ~extract_exn:true (fun () ->","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"          if (not parent_exists) && mkdir then","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"            let%bind () = Unix.mkdir ~p:() dn in","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"            let%bind () = Unix.chmod dn ~perm:0o700 in","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"            Deferred.Result.return ()","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          else if not parent_exists then","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"            Deferred.return (Error (`Parent_directory_does_not_exist dn))","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          else Deferred.Result.return () )","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"    with","counters":[]},{"line":"    | Ok x ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Deferred.return x","counters":[]},{"line":"    | Error (Unix.Unix_error ((EACCES as e), _, _)) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Deferred.return @@ corrupted_privkey","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"        @@ Error.createf \"could not mkdir -p %s: %s\\n\" dn (message e)","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"    | Error e ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        raise e","counters":[]},{"line":"  in","counters":[]},{"line":"  let open Deferred.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  match%bind","counters":[]},{"line":"    Deferred.Or_error.try_with ~here:[%here] ~extract_exn:true (fun () ->","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"        f path )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"  with","counters":[]},{"line":"  | Ok x ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Deferred.Result.return x","counters":[]},{"line":"  | Error e -> (","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      match Error.to_exn e with","counters":[]},{"line":"      | Unix.Unix_error (error_code, _, _) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Deferred.return (Error (`Cannot_open_file (path, error_code)))","counters":[]},{"line":"      | e ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Deferred.return @@ corrupted_privkey (Error.of_exn e) )","counters":[{"col_start":45,"col_end":45,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"","counters":[]},{"line":"let lift (t : 'a Deferred.t) : ('a, 'b) Deferred.Result.t = t >>| fun x -> Ok x","counters":[{"col_start":60,"col_end":60,"count":0},{"col_start":75,"col_end":75,"count":0}]},{"line":"","counters":[]},{"line":"let write ~path ~mkdir ~(password : Bytes.t Deferred.t Lazy.t) ~plaintext =","counters":[]},{"line":"  let open Deferred.Result.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%bind privkey_f =","counters":[]},{"line":"    handle_open ~mkdir ~f:(fun path -> Writer.open_file path) path","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%bind password = lift @@ Lazy.force password in","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"  let sb = Secret_box.encrypt ~plaintext ~password in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let sb =","counters":[]},{"line":"    Secret_box.to_yojson sb |> Yojson.Safe.to_string |> Bytes.of_string","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"  in","counters":[]},{"line":"  Writer.write_bytes privkey_f sb ;","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%bind () = lift (Unix.chmod path ~perm:0o600) in","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"  lift (Writer.close privkey_f)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"","counters":[]},{"line":"let read ~path ~(password : Bytes.t Deferred.t Lazy.t) =","counters":[]},{"line":"  let to_corrupt_privkey =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Deferred.Result.map_error ~f:(fun e -> `Corrupted_privkey e)","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"  in","counters":[]},{"line":"  let handle_open ~mkdir ~f p = handle_open ~mkdir ~f p in","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"  let open Deferred.Result.Let_syntax in","counters":[]},{"line":"  let read_all r =","counters":[]},{"line":"    lift (Pipe.to_list (Reader.lines r))","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":7,"col_end":7,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"    >>| fun ss -> String.concat ~sep:\"\\n\" ss","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%bind privkey_file = handle_open ~mkdir:false ~f:Reader.open_file path in","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"  let%bind st = handle_open ~mkdir:false ~f:Unix.stat path in","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"  let file_error =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    if st.perm land 0o077 <> 0 then","counters":[]},{"line":"      Some","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (sprintf","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"           \"insecure permissions on `%s`. They should be 0600, they are %o\\n\\","counters":[]},{"line":"            Hint: chmod 600 %s\\n\"","counters":[]},{"line":"           path (st.perm land 0o777) path )","counters":[]},{"line":"    else None","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"  in","counters":[]},{"line":"  let dn = Filename.dirname path in","counters":[]},{"line":"  let%bind st = handle_open ~mkdir:false ~f:Unix.stat dn in","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"  let dir_error =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    if st.perm land 0o777 <> 0o700 then","counters":[]},{"line":"      Some","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (sprintf","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"           \"insecure permissions on `%s`. They should be 0700, they are %o\\n\\","counters":[]},{"line":"            Hint: chmod 700 %s\\n\"","counters":[]},{"line":"           dn (st.perm land 0o777) dn )","counters":[]},{"line":"    else None","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%bind () =","counters":[]},{"line":"    match (file_error, dir_error) with","counters":[]},{"line":"    | Some e1, Some e2 ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Deferred.Or_error.error_string (e1 ^ e2) |> to_corrupt_privkey","counters":[{"col_start":37,"col_end":37,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"    | Some e1, None | None, Some e1 ->","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"        Deferred.Or_error.error_string e1 |> to_corrupt_privkey","counters":[{"col_start":37,"col_end":37,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"    | None, None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Deferred.Result.return ()","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%bind file_contents = read_all privkey_file |> to_corrupt_privkey in","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"  let%bind sb =","counters":[]},{"line":"    match Secret_box.of_yojson (Yojson.Safe.from_string file_contents) with","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"    | Ok sb ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        return sb","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"    | Error e ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Deferred.return","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"          (Privkey_error.corrupted_privkey","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"             (Error.createf \"couldn't parse %s: %s\" path e) )","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%bind password = lift (Lazy.force password) in","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"  Deferred.return (Secret_box.decrypt ~password sb)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":50,"col_end":50,"count":2}]}]}