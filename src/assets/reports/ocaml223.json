{"filename":"src/lib/cache_lib/intf.ml","lines":[{"line":"open Async_kernel","counters":[]},{"line":"open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"type 'a final_state = [ `Failed | `Success of 'a ] Ivar.t","counters":[]},{"line":"","counters":[]},{"line":"(** [Constant.S] is a helper signature for passing constant values","counters":[]},{"line":" *  to functors.","counters":[]},{"line":" *)","counters":[]},{"line":"module Constant = struct","counters":[]},{"line":"  module type S = sig","counters":[]},{"line":"    type t","counters":[]},{"line":"","counters":[]},{"line":"    val t : t","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(** A [Registry] module will receive events whenever items","counters":[]},{"line":" *  are removed from the cache, whether by invalidation","counters":[]},{"line":" *  or garbage collection *)","counters":[]},{"line":"module Registry = struct","counters":[]},{"line":"  module type S = sig","counters":[]},{"line":"    type element","counters":[]},{"line":"","counters":[]},{"line":"    val element_added : element -> unit","counters":[]},{"line":"","counters":[]},{"line":"    val element_removed :","counters":[]},{"line":"      [ `Consumed | `Unconsumed | `Failure ] -> element -> unit","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(** A [('t, 'cache_t) Cached.t] is a representation of a value","counters":[]},{"line":" *  stored in a cache, where ['t] is the type of the immediate","counters":[]},{"line":" *  value currently being stored, and ['cache_t] is the type","counters":[]},{"line":" *  of the value stored in the underlying cache. A [Cached.t] has","counters":[]},{"line":" *  semantics such that it can only be consumed once, and","counters":[]},{"line":" *  will track and handle the case where it is garbage collected","counters":[]},{"line":" *  before consumption. [Cached.t] values can be consumed either","counters":[]},{"line":" *  by transforming the value into another [Cached.t] with a","counters":[]},{"line":" *  different ['t] parameter, or by invalidating the [Cached.t],","counters":[]},{"line":" *  which removes it from the underlying cache.","counters":[]},{"line":" *)","counters":[]},{"line":"module Cached = struct","counters":[]},{"line":"  module type S = sig","counters":[]},{"line":"    type ('t, 'cache_t) t","counters":[]},{"line":"","counters":[]},{"line":"    (** [pure v] returns a pure cached object with","counters":[]},{"line":"     *  the value of [v]. Pure cached objects are used","counters":[]},{"line":"     *  for unifying values with the [Cached.t] type for","counters":[]},{"line":"     *  convenience. Pure cached objects are not stored","counters":[]},{"line":"     *  in a cache and cannot be consumed.","counters":[]},{"line":"     *)","counters":[]},{"line":"    val pure : 't -> ('t, _) t","counters":[]},{"line":"","counters":[]},{"line":"    val is_pure : (_, _) t -> bool","counters":[]},{"line":"","counters":[]},{"line":"    val original : (_, 'b) t -> 'b","counters":[]},{"line":"","counters":[]},{"line":"    (** [peek c] inspects the value of [c] without consuming","counters":[]},{"line":"     *  [c].","counters":[]},{"line":"     *)","counters":[]},{"line":"    val peek : ('t, _) t -> 't","counters":[]},{"line":"","counters":[]},{"line":"    val final_state : ('t1, 't2) t -> 't2 final_state","counters":[]},{"line":"","counters":[]},{"line":"    (** [invalidate c] removes the underlying cached value","counters":[]},{"line":"     *  of [c] from its cache. [invalidate] will return an","counters":[]},{"line":"     *  [Error] if the underlying cached value was not","counters":[]},{"line":"     *  present in the cache.","counters":[]},{"line":"     *)","counters":[]},{"line":"    val invalidate_with_failure : ('t, _) t -> 't","counters":[]},{"line":"","counters":[]},{"line":"    val invalidate_with_success : ('t, _) t -> 't","counters":[]},{"line":"","counters":[]},{"line":"    val was_consumed : (_, _) t -> bool","counters":[]},{"line":"","counters":[]},{"line":"    (** [transform c ~f ~logger] maps the value of [c] over","counters":[]},{"line":"     *  [f], consuming [c]. *)","counters":[]},{"line":"    val transform : ('t0, 'cache_t) t -> f:('t0 -> 't1) -> ('t1, 'cache_t) t","counters":[]},{"line":"","counters":[]},{"line":"    (** [sequence_deferred c] lifts a deferred value from","counters":[]},{"line":"     *  [c], returning a non deferred cached object in a","counters":[]},{"line":"     *  deferred context. [c] is consumed.","counters":[]},{"line":"     *)","counters":[]},{"line":"    val sequence_deferred :","counters":[]},{"line":"      ('t Deferred.t, 'cache_t) t -> ('t, 'cache_t) t Deferred.t","counters":[]},{"line":"","counters":[]},{"line":"    (** [sequence_result] lifts a result value from","counters":[]},{"line":"     *  [c], returning a result containing the raw","counters":[]},{"line":"     *  cached value if the value of [c] was [Ok].","counters":[]},{"line":"     *  Otherwise, an [Error] is returned and [c]","counters":[]},{"line":"     *  is invalidated from the cache","counters":[]},{"line":"     *)","counters":[]},{"line":"    val sequence_result :","counters":[]},{"line":"      (('t, 'e) Result.t, 'cache_t) t -> (('t, 'cache_t) t, 'e) Result.t","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(**","counters":[]},{"line":" *  A ['a Cache.t] is a [Hashtbl.t] baked cache abstraction which","counters":[]},{"line":" *  registers [('a, 'a) Cached.t] values.","counters":[]},{"line":" *)","counters":[]},{"line":"module Cache = struct","counters":[]},{"line":"  module type S = sig","counters":[]},{"line":"    type ('t, 'cache_t) cached","counters":[]},{"line":"","counters":[]},{"line":"    type 'elt t","counters":[]},{"line":"","counters":[]},{"line":"    val name : _ t -> string","counters":[]},{"line":"","counters":[]},{"line":"    val create :","counters":[]},{"line":"         name:string","counters":[]},{"line":"      -> logger:Logger.t","counters":[]},{"line":"      -> on_add:('elt -> unit)","counters":[]},{"line":"      -> on_remove:([ `Consumed | `Unconsumed | `Failure ] -> 'elt -> unit)","counters":[]},{"line":"      -> element_to_string:('elt -> string)","counters":[]},{"line":"      -> (module Hashtbl.Key_plain with type t = 'elt)","counters":[]},{"line":"      -> 'elt t","counters":[]},{"line":"","counters":[]},{"line":"    (** [register cache elt] add [elt] to [cache]. If [elt]","counters":[]},{"line":"     *  already existed in [cache], an [Error] is returned.","counters":[]},{"line":"     *  Otherwise, [Ok] is returned with a [Cached]","counters":[]},{"line":"     *  representation of [elt].","counters":[]},{"line":"     *)","counters":[]},{"line":"    val register_exn : 'elt t -> 'elt -> ('elt, 'elt) cached","counters":[]},{"line":"","counters":[]},{"line":"    val mem : 'elt t -> 'elt -> bool","counters":[]},{"line":"","counters":[]},{"line":"    val final_state : 'elt t -> 'elt -> 'elt final_state Option.t","counters":[]},{"line":"","counters":[]},{"line":"    val element_to_string : 'elt t -> 'elt -> string","counters":[]},{"line":"","counters":[]},{"line":"    val to_list : 'elt t -> 'elt list","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(** A [Transmuter] module transmutes some source value into","counters":[]},{"line":" *  some target value","counters":[]},{"line":" *)","counters":[]},{"line":"module Transmuter = struct","counters":[]},{"line":"  module type S = sig","counters":[]},{"line":"    module Source : sig","counters":[]},{"line":"      type t","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Target : sig","counters":[]},{"line":"      include Hash_set.Elt_plain","counters":[]},{"line":"","counters":[]},{"line":"      val to_string : t -> string","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    val transmute : Source.t -> Target.t","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(** A [Transmuter_cache] module is a wrapper for a [Cache]","counters":[]},{"line":" *  module, except that a [Transmuter] module provides a","counters":[]},{"line":" *  layer of indirection to the values stored in the","counters":[]},{"line":" *  [Cache.t], transmuting values through the interface","counters":[]},{"line":" *  to provide a more abstract interface.","counters":[]},{"line":" *)","counters":[]},{"line":"module Transmuter_cache = struct","counters":[]},{"line":"  module type S = sig","counters":[]},{"line":"    module Cached : Cached.S","counters":[]},{"line":"","counters":[]},{"line":"    module Cache :","counters":[]},{"line":"      Cache.S with type ('t, 'cache_t) cached := ('t, 'cache_t) Cached.t","counters":[]},{"line":"","counters":[]},{"line":"    type target","counters":[]},{"line":"","counters":[]},{"line":"    type source","counters":[]},{"line":"","counters":[]},{"line":"    type t = target Cache.t","counters":[]},{"line":"","counters":[]},{"line":"    val create : logger:Logger.t -> t","counters":[]},{"line":"","counters":[]},{"line":"    val register_exn : t -> source -> (source, target) Cached.t","counters":[]},{"line":"","counters":[]},{"line":"    val final_state : t -> source -> target final_state Option.t","counters":[]},{"line":"","counters":[]},{"line":"    val mem : t -> source -> bool","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module type F = sig","counters":[]},{"line":"    module Cached : Cached.S","counters":[]},{"line":"","counters":[]},{"line":"    module Cache :","counters":[]},{"line":"      Cache.S with type ('t, 'cache_t) cached := ('t, 'cache_t) Cached.t","counters":[]},{"line":"","counters":[]},{"line":"    module Make","counters":[]},{"line":"        (Transmuter : Transmuter.S)","counters":[]},{"line":"        (Registry : Registry.S with type element := Transmuter.Target.t)","counters":[]},{"line":"        (Name : Constant.S with type t := string) :","counters":[]},{"line":"      S","counters":[]},{"line":"        with module Cached := Cached","counters":[]},{"line":"         and module Cache := Cache","counters":[]},{"line":"         and type source = Transmuter.Source.t","counters":[]},{"line":"         and type target = Transmuter.Target.t","counters":[]},{"line":"    [@@warning \"-67\"]","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(** [Main.S] is the signature of the [Cache_lib] library. *)","counters":[]},{"line":"module Main = struct","counters":[]},{"line":"  module type S = sig","counters":[]},{"line":"    module Cached : Cached.S","counters":[]},{"line":"","counters":[]},{"line":"    module Cache :","counters":[]},{"line":"      Cache.S with type ('t, 'cache_t) cached := ('t, 'cache_t) Cached.t","counters":[]},{"line":"","counters":[]},{"line":"    module Transmuter_cache :","counters":[]},{"line":"      Transmuter_cache.F with module Cached := Cached and module Cache := Cache","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":1}]}]}