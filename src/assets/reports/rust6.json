{"filename":"src/base.rs","lines":[{"line":"use std::{","counters":[]},{"line":"    collections::HashSet,","counters":[]},{"line":"    ops::{ControlFlow, Deref},","counters":[]},{"line":"    path::PathBuf,","counters":[]},{"line":"    sync::atomic::AtomicU64,","counters":[]},{"line":"};","counters":[]},{"line":"","counters":[]},{"line":"use mina_hasher::Fp;","counters":[]},{"line":"use mina_signer::CompressedPubKey;","counters":[]},{"line":"","counters":[]},{"line":"use crate::{","counters":[]},{"line":"    account::{Account, AccountId, TokenId},","counters":[]},{"line":"    address::Address,","counters":[]},{"line":"    database::DatabaseError,","counters":[]},{"line":"    scan_state::transaction_logic::AccountState,","counters":[]},{"line":"    staged_ledger::sparse_ledger::LedgerIntf,","counters":[]},{"line":"    Mask,","counters":[]},{"line":"};","counters":[]},{"line":"","counters":[]},{"line":"pub type Uuid = String;","counters":[]},{"line":"","counters":[]},{"line":"static UUID_GENERATOR: AtomicU64 = AtomicU64::new(0);","counters":[]},{"line":"","counters":[]},{"line":"pub fn next_uuid() -> Uuid {","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"    // use uuid::Uuid;","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"    uuid::Uuid::new_v4().to_string()","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"","counters":[]},{"line":"    // \"a\".to_string()","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"    // UUID_GENERATOR.fetch_add(1, Ordering::AcqRel)","counters":[{"col_start":0,"col_end":52,"count":0}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"#[derive(PartialEq, Eq)]","counters":[]},{"line":"pub enum MerklePath {","counters":[]},{"line":"    Left(Fp),","counters":[]},{"line":"    Right(Fp),","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl MerklePath {","counters":[]},{"line":"    pub fn hash(&self) -> &Fp {","counters":[{"col_start":4,"col_end":31,"count":0}]},{"line":"        match self {","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"            MerklePath::Left(h) => h,","counters":[{"col_start":29,"col_end":36,"count":0}]},{"line":"            MerklePath::Right(h) => h,","counters":[{"col_start":30,"col_end":37,"count":0}]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl std::fmt::Debug for MerklePath {","counters":[]},{"line":"    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {","counters":[{"col_start":4,"col_end":72,"count":0}]},{"line":"        match self {","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"            Self::Left(arg0) => f.debug_tuple(\"Left\").field(&arg0.to_string()).finish(),","counters":[{"col_start":23,"col_end":87,"count":0}]},{"line":"            Self::Right(arg0) => f.debug_tuple(\"Right\").field(&arg0.to_string()).finish(),","counters":[{"col_start":24,"col_end":89,"count":0}]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"pub trait BaseLedger {","counters":[]},{"line":"    /// list of accounts in the ledger","counters":[]},{"line":"    fn to_list(&self) -> Vec<Account>;","counters":[]},{"line":"","counters":[]},{"line":"    /// iterate over all indexes and accounts","counters":[]},{"line":"    fn iter<F>(&self, fun: F)","counters":[]},{"line":"    where","counters":[]},{"line":"        F: FnMut(&Account);","counters":[]},{"line":"","counters":[]},{"line":"    /// fold over accounts in the ledger, passing the Merkle address","counters":[]},{"line":"    fn fold<B, F>(&self, init: B, fun: F) -> B","counters":[]},{"line":"    where","counters":[]},{"line":"        F: FnMut(B, &Account) -> B;","counters":[]},{"line":"","counters":[]},{"line":"    /// the set of [account_id]s are ledger elements to skip during the fold,","counters":[]},{"line":"    /// because they're in a mask","counters":[]},{"line":"    fn fold_with_ignored_accounts<B, F>(&self, ignoreds: HashSet<AccountId>, init: B, fun: F) -> B","counters":[]},{"line":"    where","counters":[]},{"line":"        F: FnMut(B, &Account) -> B;","counters":[]},{"line":"","counters":[]},{"line":"    /// fold until `fun` returns `ControlFlow::Stop`","counters":[]},{"line":"    fn fold_until<B, F>(&self, init: B, fun: F) -> B","counters":[]},{"line":"    where","counters":[]},{"line":"        F: FnMut(B, &Account) -> ControlFlow<B, B>;","counters":[]},{"line":"","counters":[]},{"line":"    /// set of account ids associated with accounts","counters":[]},{"line":"    fn accounts(&self) -> HashSet<AccountId>;","counters":[]},{"line":"","counters":[]},{"line":"    /// Get the account id that owns a token.","counters":[]},{"line":"    fn token_owner(&self, token_id: TokenId) -> Option<AccountId>;","counters":[]},{"line":"","counters":[]},{"line":"    /// Get the set of all accounts which own a token.","counters":[]},{"line":"    fn token_owners(&self) -> HashSet<AccountId>;","counters":[]},{"line":"","counters":[]},{"line":"    /// Get all of the tokens for which a public key has accounts.","counters":[]},{"line":"    fn tokens(&self, public_key: CompressedPubKey) -> HashSet<TokenId>;","counters":[]},{"line":"","counters":[]},{"line":"    fn location_of_account(&self, account_id: &AccountId) -> Option<Address>;","counters":[]},{"line":"","counters":[]},{"line":"    fn location_of_account_batch(","counters":[]},{"line":"        &self,","counters":[]},{"line":"        account_ids: &[AccountId],","counters":[]},{"line":"    ) -> Vec<(AccountId, Option<Address>)>;","counters":[]},{"line":"","counters":[]},{"line":"    /// This may return an error if the ledger is full.","counters":[]},{"line":"    fn get_or_create_account(","counters":[]},{"line":"        &mut self,","counters":[]},{"line":"        account_id: AccountId,","counters":[]},{"line":"        account: Account,","counters":[]},{"line":"    ) -> Result<GetOrCreated, DatabaseError>;","counters":[]},{"line":"","counters":[]},{"line":"    /// the ledger should not be used after calling [close]","counters":[]},{"line":"    fn close(&self);","counters":[]},{"line":"","counters":[]},{"line":"    /// for account locations in the ledger, the last (rightmost) filled location","counters":[]},{"line":"    fn last_filled(&self) -> Option<Address>;","counters":[]},{"line":"","counters":[]},{"line":"    fn get_uuid(&self) -> Uuid;","counters":[]},{"line":"","counters":[]},{"line":"    /// return Some [directory] for ledgers that use a file system, else None","counters":[]},{"line":"    fn get_directory(&self) -> Option<PathBuf>;","counters":[]},{"line":"","counters":[]},{"line":"    fn get(&self, addr: Address) -> Option<Account>;","counters":[]},{"line":"","counters":[]},{"line":"    fn get_batch(&self, addr: &[Address]) -> Vec<(Address, Option<Account>)>;","counters":[]},{"line":"","counters":[]},{"line":"    fn set(&mut self, addr: Address, account: Account);","counters":[]},{"line":"","counters":[]},{"line":"    fn set_batch(&mut self, list: &[(Address, Account)]);","counters":[]},{"line":"","counters":[]},{"line":"    fn get_at_index(&self, index: AccountIndex) -> Option<Account>;","counters":[]},{"line":"","counters":[]},{"line":"    fn set_at_index(&mut self, index: AccountIndex, account: Account) -> Result<(), ()>;","counters":[]},{"line":"","counters":[]},{"line":"    fn index_of_account(&self, account_id: AccountId) -> Option<AccountIndex>;","counters":[]},{"line":"","counters":[]},{"line":"    /// meant to be a fast operation: the root hash is stored, rather","counters":[]},{"line":"    /// than calculated dynamically","counters":[]},{"line":"    fn merkle_root(&mut self) -> Fp;","counters":[]},{"line":"","counters":[]},{"line":"    fn merkle_path(&mut self, addr: Address) -> Vec<MerklePath>;","counters":[]},{"line":"","counters":[]},{"line":"    fn merkle_path_at_index(&mut self, index: AccountIndex) -> Vec<MerklePath>;","counters":[]},{"line":"","counters":[]},{"line":"    fn remove_accounts(&mut self, ids: &[AccountId]);","counters":[]},{"line":"","counters":[]},{"line":"    /// Triggers when the ledger has been detached and should no longer be","counters":[]},{"line":"    /// accessed.","counters":[]},{"line":"    fn detached_signal(&mut self);","counters":[]},{"line":"","counters":[]},{"line":"    // Following methods from Syncable_intf","counters":[]},{"line":"","counters":[]},{"line":"    fn depth(&self) -> u8;","counters":[]},{"line":"","counters":[]},{"line":"    fn num_accounts(&self) -> usize;","counters":[]},{"line":"","counters":[]},{"line":"    fn merkle_path_at_addr(&mut self, addr: Address) -> Vec<MerklePath>;","counters":[]},{"line":"","counters":[]},{"line":"    fn get_inner_hash_at_addr(&mut self, addr: Address) -> Result<Fp, ()>;","counters":[]},{"line":"","counters":[]},{"line":"    fn set_inner_hash_at_addr(&mut self, addr: Address, hash: Fp) -> Result<(), ()>;","counters":[]},{"line":"","counters":[]},{"line":"    fn set_all_accounts_rooted_at(&mut self, addr: Address, accounts: &[Account])","counters":[]},{"line":"        -> Result<(), ()>;","counters":[]},{"line":"","counters":[]},{"line":"    fn set_batch_accounts(&mut self, list: &[(Address, Account)]) {","counters":[{"col_start":4,"col_end":67,"count":0}]},{"line":"        Self::set_batch(self, list)","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    /// Get all of the accounts that are in a subtree of the underlying Merkle","counters":[]},{"line":"    /// tree rooted at `address`. The accounts are ordered by their addresses.","counters":[]},{"line":"    fn get_all_accounts_rooted_at(&self, addr: Address) -> Option<Vec<(Address, Account)>>;","counters":[]},{"line":"","counters":[]},{"line":"    fn make_space_for(&mut self, space: usize);","counters":[]},{"line":"","counters":[]},{"line":"    // Following are internal methods, they might be better in a private trait","counters":[]},{"line":"    fn get_account_hash(&mut self, account_index: AccountIndex) -> Option<Fp>;","counters":[]},{"line":"    /// Used on mask only, has no effect with other implementation","counters":[]},{"line":"    /// Required for `LedgerIntf` on masks","counters":[]},{"line":"    fn commit(&mut self);","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]","counters":[{"col_start":9,"col_end":14,"count":0},{"col_start":16,"col_end":21,"count":0},{"col_start":23,"col_end":32,"count":0},{"col_start":38,"col_end":48,"count":0},{"col_start":50,"col_end":53,"count":0},{"col_start":55,"col_end":59,"count":0}]},{"line":"pub struct AccountIndex(pub u64);","counters":[]},{"line":"","counters":[]},{"line":"impl AccountIndex {","counters":[]},{"line":"    pub fn as_u64(&self) -> u64 {","counters":[{"col_start":4,"col_end":33,"count":0}]},{"line":"        self.0","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl PartialEq<u64> for AccountIndex {","counters":[]},{"line":"    fn eq(&self, other: &u64) -> bool {","counters":[{"col_start":4,"col_end":39,"count":0}]},{"line":"        self.0 == *other","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl PartialEq<usize> for AccountIndex {","counters":[]},{"line":"    fn eq(&self, other: &usize) -> bool {","counters":[{"col_start":4,"col_end":41,"count":0}]},{"line":"        let other: u64 = (*other).try_into().unwrap();","counters":[{"col_start":0,"col_end":54,"count":0}]},{"line":"        self.0 == other","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl From<usize> for AccountIndex {","counters":[]},{"line":"    fn from(n: usize) -> Self {","counters":[{"col_start":4,"col_end":31,"count":0}]},{"line":"        Self(n.try_into().unwrap())","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"#[derive(Clone, Debug)]","counters":[{"col_start":16,"col_end":17,"count":0},{"col_start":20,"col_end":21,"count":0}]},{"line":"pub enum GetOrCreated {","counters":[]},{"line":"    Added(Address),","counters":[]},{"line":"    Existed(Address),","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl GetOrCreated {","counters":[]},{"line":"    pub fn addr(self) -> Address {","counters":[{"col_start":4,"col_end":34,"count":289}]},{"line":"        match self {","counters":[{"col_start":0,"col_end":18,"count":289}]},{"line":"            GetOrCreated::Added(addr) => addr,","counters":[{"col_start":32,"col_end":45,"count":289}]},{"line":"            GetOrCreated::Existed(addr) => addr,","counters":[{"col_start":34,"col_end":47,"count":0}]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":289}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Deref for GetOrCreated {","counters":[]},{"line":"    type Target = Address;","counters":[]},{"line":"","counters":[]},{"line":"    fn deref(&self) -> &Self::Target {","counters":[{"col_start":4,"col_end":38,"count":0}]},{"line":"        match self {","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"            GetOrCreated::Added(addr) => addr,","counters":[{"col_start":32,"col_end":45,"count":0}]},{"line":"            GetOrCreated::Existed(addr) => addr,","counters":[{"col_start":34,"col_end":47,"count":0}]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl LedgerIntf for Mask {","counters":[]},{"line":"    type Location = Address;","counters":[]},{"line":"","counters":[]},{"line":"    fn get(&self, addr: &Address) -> Option<Account> {","counters":[{"col_start":4,"col_end":54,"count":0}]},{"line":"        BaseLedger::get(self, addr.clone())","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn location_of_account(&self, account_id: &AccountId) -> Option<Address> {","counters":[{"col_start":4,"col_end":78,"count":0}]},{"line":"        BaseLedger::location_of_account(self, account_id)","counters":[{"col_start":0,"col_end":57,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn set(&mut self, addr: &Address, account: Account) {","counters":[{"col_start":4,"col_end":57,"count":0}]},{"line":"        BaseLedger::set(self, addr.clone(), account)","counters":[{"col_start":0,"col_end":52,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/mina_ledger/ledger.ml#L311","counters":[]},{"line":"    fn get_or_create(","counters":[{"col_start":4,"col_end":21,"count":0}]},{"line":"        &mut self,","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"        account_id: &AccountId,","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"    ) -> Result<(AccountState, Account, Address), String> {","counters":[{"col_start":0,"col_end":58,"count":0}]},{"line":"        let location = BaseLedger::get_or_create_account(","counters":[{"col_start":12,"col_end":20,"count":0},{"col_start":23,"col_end":57,"count":0}]},{"line":"            self,","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"            account_id.clone(),","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"            Account::initialize(account_id),","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"        )","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"        .map_err(|e| format!(\"{:?}\", e))?;","counters":[{"col_start":0,"col_end":17,"count":0},{"col_start":21,"col_end":39,"count":0},{"col_start":39,"col_end":40,"count":0},{"col_start":40,"col_end":41,"count":0}]},{"line":"","counters":[]},{"line":"        let action = match location {","counters":[{"col_start":12,"col_end":18,"count":0},{"col_start":27,"col_end":35,"count":0}]},{"line":"            GetOrCreated::Added(_) => AccountState::Added,","counters":[{"col_start":38,"col_end":57,"count":0}]},{"line":"            GetOrCreated::Existed(_) => AccountState::Existed,","counters":[{"col_start":40,"col_end":61,"count":0}]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        let addr = location.addr();","counters":[{"col_start":12,"col_end":34,"count":0}]},{"line":"        let account = BaseLedger::get(self, addr.clone()).ok_or_else(|| {","counters":[{"col_start":12,"col_end":19,"count":0},{"col_start":22,"col_end":69,"count":0},{"col_start":72,"col_end":73,"count":0}]},{"line":"            \"get_or_create: Account was not found in the ledger after creation\".to_string()","counters":[{"col_start":0,"col_end":91,"count":0}]},{"line":"        })?;","counters":[{"col_start":0,"col_end":9,"count":0},{"col_start":9,"col_end":10,"count":0},{"col_start":10,"col_end":11,"count":0}]},{"line":"","counters":[]},{"line":"        Ok((action, account, addr))","counters":[{"col_start":8,"col_end":35,"count":0}]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/mina_ledger/ledger.ml#L304","counters":[]},{"line":"    fn create_new_account(&mut self, account_id: AccountId, account: Account) -> Result<(), ()> {","counters":[{"col_start":4,"col_end":97,"count":0}]},{"line":"        match BaseLedger::get_or_create_account(self, account_id, account).unwrap() {","counters":[{"col_start":0,"col_end":83,"count":0}]},{"line":"            GetOrCreated::Added(_) => {}","counters":[{"col_start":38,"col_end":40,"count":0}]},{"line":"            GetOrCreated::Existed(_) => panic!(),","counters":[{"col_start":40,"col_end":48,"count":0}]},{"line":"        }","counters":[]},{"line":"        Ok(())","counters":[{"col_start":8,"col_end":14,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn remove_accounts_exn(&mut self, account_ids: &[AccountId]) {","counters":[{"col_start":4,"col_end":66,"count":0}]},{"line":"        BaseLedger::remove_accounts(self, account_ids)","counters":[{"col_start":0,"col_end":54,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn merkle_root(&mut self) -> Fp {","counters":[{"col_start":4,"col_end":37,"count":0}]},{"line":"        BaseLedger::merkle_root(self)","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn empty(depth: usize) -> Self {","counters":[{"col_start":4,"col_end":36,"count":0}]},{"line":"        let root = Mask::new_unattached(depth);","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"        root.make_child()","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn create_masked(&self) -> Self {","counters":[{"col_start":4,"col_end":37,"count":0}]},{"line":"        let mask = Mask::new_unattached(self.depth() as usize);","counters":[{"col_start":0,"col_end":63,"count":0}]},{"line":"        mask.set_parent(self.clone(), None)","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn apply_mask(&mut self, mask: Self) {","counters":[{"col_start":4,"col_end":42,"count":0}]},{"line":"        // ignore `self` here:","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"        // https://github.com/MinaProtocol/mina/blob/f6756507ff7380a691516ce02a3cf7d9d32915ae/src/lib/mina_ledger/ledger.ml#L236-L246","counters":[{"col_start":0,"col_end":133,"count":0}]},{"line":"        mask.commit()","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn account_locations(&self) -> Vec<Self::Location> {","counters":[{"col_start":4,"col_end":56,"count":0}]},{"line":"        let mut addrs: Vec<Address> = self","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"            .accounts()","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"            .into_iter()","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"            .map(|account_id| BaseLedger::location_of_account(self, &account_id).unwrap())","counters":[{"col_start":0,"col_end":17,"count":0},{"col_start":30,"col_end":89,"count":0},{"col_start":89,"col_end":90,"count":0}]},{"line":"            .collect();","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"        addrs.sort_by_key(Address::to_index);","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"","counters":[]},{"line":"        addrs","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]}]}