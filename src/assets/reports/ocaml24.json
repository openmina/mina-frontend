{"filename":"src/lib/rose_tree/rose_tree.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"type 'a t = T of 'a * 'a t list","counters":[]},{"line":"","counters":[]},{"line":"type 'a display = { value : 'a; children : 'a display list } [@@deriving yojson]","counters":[{"col_start":0,"col_end":0,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":43,"col_end":43,"count":0},{"col_start":57,"col_end":57,"count":0},{"col_start":79,"col_end":79,"count":0}]},{"line":"","counters":[]},{"line":"let rec to_display (T (value, children)) =","counters":[]},{"line":"  { value; children = List.map ~f:to_display children }","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"let rec of_display { value; children } =","counters":[]},{"line":"  T (value, List.map ~f:of_display children)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"","counters":[]},{"line":"let to_yojson conv t = display_to_yojson conv (to_display t)","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"","counters":[]},{"line":"let of_yojson conv json = Result.map ~f:of_display (display_of_yojson conv json)","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"","counters":[]},{"line":"let root (T (value, _)) = value","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"","counters":[]},{"line":"let children (T (_, children)) = children","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"","counters":[]},{"line":"let rec print ?(whitespace = 0) ~element_to_string (T (root, branches)) =","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"  Printf.printf \"%s- %s\\n\" (String.make whitespace ' ') (element_to_string root) ;","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":73,"col_end":73,"count":0}]},{"line":"  List.iter branches ~f:(print ~whitespace:(whitespace + 2) ~element_to_string)","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let rec of_list_exn ?(subtrees = []) = function","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"  | [] ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      raise","counters":[]},{"line":"        (Invalid_argument","counters":[]},{"line":"           \"Rose_tree.of_list_exn: cannot construct rose tree from empty list\"","counters":[]},{"line":"        )","counters":[]},{"line":"  | [ h ] ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      T (h, subtrees)","counters":[]},{"line":"  | h :: t ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      T (h, [ of_list_exn t ~subtrees ])","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"","counters":[]},{"line":"let of_non_empty_list ?(subtrees = []) =","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"  Fn.compose","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    (Non_empty_list.fold","counters":[]},{"line":"       ~init:(fun x -> T (x, subtrees))","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"       ~f:(fun acc x -> T (x, [ acc ])) )","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"    Non_empty_list.rev","counters":[]},{"line":"","counters":[]},{"line":"let rec equal ~f (T (value1, children1)) (T (value2, children2)) =","counters":[]},{"line":"  f value1 value2 && List.equal (equal ~f) children1 children2","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"","counters":[]},{"line":"let subset ~f xs ys = List.for_all xs ~f:(fun x -> List.mem ys x ~equal:f)","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"","counters":[]},{"line":"let bag_equiv ~f xs ys = subset ~f xs ys && subset ~f ys xs","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"let rec equiv ~f (T (x1, ts1)) (T (x2, ts2)) =","counters":[]},{"line":"  f x1 x2 && bag_equiv ~f:(equiv ~f) ts1 ts2","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":13,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"module type Monad_intf = sig","counters":[]},{"line":"  include Monad.S","counters":[]},{"line":"","counters":[]},{"line":"  module List : sig","counters":[]},{"line":"    val iter : 'a list -> f:('a -> unit t) -> unit t","counters":[]},{"line":"","counters":[]},{"line":"    val map : 'a list -> f:('a -> 'b t) -> 'b list t","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type Ops_intf = sig","counters":[]},{"line":"  module Monad : Monad_intf","counters":[]},{"line":"","counters":[]},{"line":"  val iter : 'a t -> f:('a -> unit Monad.t) -> unit Monad.t","counters":[]},{"line":"","counters":[]},{"line":"  val map : 'a t -> f:('a -> 'b Monad.t) -> 'b t Monad.t","counters":[]},{"line":"","counters":[]},{"line":"  val fold_map : 'a t -> init:'b -> f:('b -> 'a -> 'b Monad.t) -> 'b t Monad.t","counters":[]},{"line":"","counters":[]},{"line":"  val fold_map_over_subtrees :","counters":[]},{"line":"    'a t -> init:'b -> f:('b -> 'a t -> 'b Monad.t) -> 'b t Monad.t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make_ops (Monad : Monad_intf) : Ops_intf with module Monad := Monad =","counters":[]},{"line":"struct","counters":[]},{"line":"  open Monad.Let_syntax","counters":[]},{"line":"","counters":[]},{"line":"  let rec iter (T (base, successors)) ~f =","counters":[]},{"line":"    let%bind () = f base in","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"    Monad.List.iter successors ~f:(iter ~f)","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let rec map (T (base, successors)) ~f =","counters":[]},{"line":"    let%bind base' = f base in","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"    let%map successors' = Monad.List.map successors ~f:(map ~f) in","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"    T (base', successors')","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let rec fold_map (T (base, successors)) ~init ~f =","counters":[]},{"line":"    let%bind base' = f init base in","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"    let%map successors' =","counters":[]},{"line":"      Monad.List.map successors ~f:(fold_map ~init:base' ~f)","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"    in","counters":[]},{"line":"    T (base', successors')","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let rec fold_map_over_subtrees (T (_, successors) as subtree) ~init ~f =","counters":[]},{"line":"    let%bind base' = f init subtree in","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"    let%map successors' =","counters":[]},{"line":"      Monad.List.map successors ~f:(fold_map_over_subtrees ~init:base' ~f)","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"    in","counters":[]},{"line":"    T (base', successors')","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"include Make_ops (struct","counters":[]},{"line":"  include Monad.Ident","counters":[]},{"line":"  module List = List","counters":[]},{"line":"end)","counters":[]},{"line":"","counters":[]},{"line":"let rec flatten (T (x, ts)) = x :: List.concat_map ts ~f:flatten","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"","counters":[]},{"line":"module Deferred = struct","counters":[]},{"line":"  open Async_kernel","counters":[]},{"line":"","counters":[]},{"line":"  include Make_ops (struct","counters":[]},{"line":"    include (Deferred : Monad.S with type +'a t = 'a Deferred.t)","counters":[]},{"line":"","counters":[]},{"line":"    module List = struct","counters":[]},{"line":"      open Deferred.List","counters":[]},{"line":"","counters":[]},{"line":"      let iter ls ~f = iter ~how:`Sequential ls ~f","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"      let map ls ~f = map ~how:`Sequential ls ~f","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"    end","counters":[]},{"line":"  end)","counters":[]},{"line":"","counters":[]},{"line":"  let rec all (T (x', ts')) =","counters":[]},{"line":"    let open Deferred.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let%bind x = x' in","counters":[]},{"line":"    let%bind ts = Deferred.all @@ List.map ~f:all ts' in","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"    return @@ T (x, ts)","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  module Or_error = Make_ops (struct","counters":[]},{"line":"    include (","counters":[]},{"line":"      Deferred.Or_error : Monad.S with type +'a t = 'a Deferred.Or_error.t )","counters":[]},{"line":"","counters":[]},{"line":"    module List = struct","counters":[]},{"line":"      open Deferred.Or_error.List","counters":[]},{"line":"","counters":[]},{"line":"      let iter ls ~f = iter ~how:`Sequential ls ~f","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"      let map ls ~f = map ~how:`Sequential ls ~f","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"    end","counters":[]},{"line":"  end)","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Or_error = Make_ops (struct","counters":[]},{"line":"  include Or_error","counters":[]},{"line":"","counters":[]},{"line":"  module List = struct","counters":[]},{"line":"    open Or_error.Let_syntax","counters":[]},{"line":"","counters":[]},{"line":"    let iter ls ~f =","counters":[]},{"line":"      List.fold_left ls ~init:(return ()) ~f:(fun or_error x ->","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"          let%bind () = or_error in","counters":[]},{"line":"          f x )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"    let map ls ~f =","counters":[]},{"line":"      let%map ls' =","counters":[]},{"line":"        List.fold_left ls ~init:(return []) ~f:(fun or_error x ->","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"            let%bind t = or_error in","counters":[]},{"line":"            let%map x' = f x in","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"            x' :: t )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"      in","counters":[]},{"line":"      List.rev ls'","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  end","counters":[]},{"line":"end)","counters":[{"col_start":3,"col_end":3,"count":2}]}]}