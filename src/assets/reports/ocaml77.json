{"filename":"src/lib/pickles/step.ml","lines":[{"line":"module SC = Scalar_challenge","counters":[]},{"line":"open Core_kernel","counters":[]},{"line":"open Async_kernel","counters":[]},{"line":"module P = Proof","counters":[]},{"line":"open Pickles_types","counters":[]},{"line":"open Poly_types","counters":[]},{"line":"open Hlist","counters":[]},{"line":"open Backend","counters":[]},{"line":"open Tuple_lib","counters":[]},{"line":"open Import","counters":[]},{"line":"open Types","counters":[]},{"line":"open Common","counters":[]},{"line":"","counters":[]},{"line":"(* This contains the \"step\" prover *)","counters":[]},{"line":"","counters":[]},{"line":"module Make","counters":[]},{"line":"    (A : T0) (A_value : sig","counters":[]},{"line":"      type t","counters":[]},{"line":"    end)","counters":[]},{"line":"    (Max_proofs_verified : Nat.Add.Intf_transparent) =","counters":[]},{"line":"struct","counters":[]},{"line":"  let double_zip = Double.map2 ~f:Core_kernel.Tuple2.create","counters":[]},{"line":"","counters":[]},{"line":"  module E = struct","counters":[]},{"line":"    type t = Tock.Field.t array Double.t Plonk_types.Evals.t * Tock.Field.t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Plonk_checks = struct","counters":[]},{"line":"    include Plonk_checks","counters":[]},{"line":"    module Type1 = Plonk_checks.Make (Shifted_value.Type1) (Scalars.Tick)","counters":[]},{"line":"    module Type2 = Plonk_checks.Make (Shifted_value.Type2) (Scalars.Tock)","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  (* The prover corresponding to the given inductive rule. *)","counters":[]},{"line":"  let f","counters":[]},{"line":"      (type (* The maximum number of proofs verified by one of the proof systems verified by this rule :)","counters":[]},{"line":"","counters":[]},{"line":"               In other words: each of the proofs verified by this rule comes from some pickles proof system.","counters":[]},{"line":"","counters":[]},{"line":"               The ith one of those proof systems has a maximum number of proofs N_i that is verified by","counters":[]},{"line":"               a rule in proof system i. max_local_max_proof_verifieds is the max of the N_i.","counters":[]},{"line":"            *)","counters":[]},{"line":"      max_local_max_proof_verifieds self_branches prev_vars prev_values","counters":[]},{"line":"      local_widths local_heights prevs_length var value ret_var ret_value","counters":[]},{"line":"      auxiliary_var auxiliary_value ) ?handler","counters":[]},{"line":"      (T branch_data :","counters":[]},{"line":"        ( A.t","counters":[]},{"line":"        , A_value.t","counters":[]},{"line":"        , ret_var","counters":[]},{"line":"        , ret_value","counters":[]},{"line":"        , auxiliary_var","counters":[]},{"line":"        , auxiliary_value","counters":[]},{"line":"        , Max_proofs_verified.n","counters":[]},{"line":"        , self_branches","counters":[]},{"line":"        , prev_vars","counters":[]},{"line":"        , prev_values","counters":[]},{"line":"        , local_widths","counters":[]},{"line":"        , local_heights )","counters":[]},{"line":"        Step_branch_data.t ) (next_state : A_value.t)","counters":[]},{"line":"      ~maxes:","counters":[]},{"line":"        (module Maxes : Pickles_types.Hlist.Maxes.S","counters":[]},{"line":"          with type length = Max_proofs_verified.n","counters":[]},{"line":"           and type ns = max_local_max_proof_verifieds )","counters":[]},{"line":"      ~(prevs_length : (prev_vars, prevs_length) Length.t) ~self ~step_domains","counters":[]},{"line":"      ~uses_lookup ~self_dlog_plonk_index","counters":[]},{"line":"      ~(public_input :","counters":[]},{"line":"         ( var","counters":[]},{"line":"         , value","counters":[]},{"line":"         , A.t","counters":[]},{"line":"         , A_value.t","counters":[]},{"line":"         , ret_var","counters":[]},{"line":"         , ret_value )","counters":[]},{"line":"         Inductive_rule.public_input )","counters":[]},{"line":"      ~(auxiliary_typ : (auxiliary_var, auxiliary_value) Impls.Step.Typ.t) pk","counters":[]},{"line":"      self_dlog_vk :","counters":[]},{"line":"      ( ( value","counters":[]},{"line":"        , (_, Max_proofs_verified.n) Vector.t","counters":[]},{"line":"        , (_, prevs_length) Vector.t","counters":[]},{"line":"        , (_, prevs_length) Vector.t","counters":[]},{"line":"        , _","counters":[]},{"line":"        , (_, Max_proofs_verified.n) Vector.t )","counters":[]},{"line":"        P.Base.Step.t","counters":[]},{"line":"      * ret_value","counters":[]},{"line":"      * auxiliary_value","counters":[]},{"line":"      * (int, prevs_length) Vector.t )","counters":[]},{"line":"      Promise.t =","counters":[]},{"line":"    let _, prev_vars_length = branch_data.proofs_verified in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let T = Length.contr prev_vars_length prevs_length in","counters":[]},{"line":"    let (module Req) = branch_data.requests in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let T =","counters":[]},{"line":"      Hlist.Length.contr (snd branch_data.proofs_verified) prev_vars_length","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"    in","counters":[]},{"line":"    let prev_values_length =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let module L12 = H4.Length_1_to_2 (Tag) in","counters":[]},{"line":"      L12.f branch_data.rule.prevs prev_vars_length","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    in","counters":[]},{"line":"    let lte = branch_data.lte in","counters":[]},{"line":"    let module X_hat = struct","counters":[]},{"line":"      type t = Tock.Field.t Double.t","counters":[]},{"line":"    end in","counters":[]},{"line":"    let module Statement_with_hashes = struct","counters":[]},{"line":"      type t =","counters":[]},{"line":"        ( Challenge.Constant.t","counters":[]},{"line":"        , Challenge.Constant.t Scalar_challenge.t","counters":[]},{"line":"        , Tick.Field.t Shifted_value.Type1.t","counters":[]},{"line":"        , ( Challenge.Constant.t Scalar_challenge.t","counters":[]},{"line":"          , Tick.Field.t Shifted_value.Type1.t )","counters":[]},{"line":"          Types.Step.Proof_state.Deferred_values.Plonk.In_circuit.Lookup.t","counters":[]},{"line":"          option","counters":[]},{"line":"        , Digest.Constant.t","counters":[]},{"line":"        , Digest.Constant.t","counters":[]},{"line":"        , Digest.Constant.t","counters":[]},{"line":"        , Challenge.Constant.t Scalar_challenge.t Bulletproof_challenge.t","counters":[]},{"line":"          Step_bp_vec.t","counters":[]},{"line":"        , Branch_data.t )","counters":[]},{"line":"        Wrap.Statement.In_circuit.t","counters":[]},{"line":"    end in","counters":[]},{"line":"    let challenge_polynomial =","counters":[]},{"line":"      Tock.Field.(Wrap_verifier.challenge_polynomial ~add ~mul ~one)","counters":[]},{"line":"    in","counters":[]},{"line":"    let expand_proof :","counters":[]},{"line":"        type var value local_max_proofs_verified m.","counters":[]},{"line":"           Impls.Wrap.Verification_key.t","counters":[]},{"line":"        -> 'a","counters":[]},{"line":"        -> value","counters":[]},{"line":"        -> (local_max_proofs_verified, local_max_proofs_verified) P.t","counters":[]},{"line":"        -> (var, value, local_max_proofs_verified, m) Tag.t","counters":[]},{"line":"        -> must_verify:bool","counters":[]},{"line":"        -> [ `Sg of Tock.Curve.Affine.t ]","counters":[]},{"line":"           * Unfinalized.Constant.t","counters":[]},{"line":"           * Statement_with_hashes.t","counters":[]},{"line":"           * X_hat.t","counters":[]},{"line":"           * ( value","counters":[]},{"line":"             , local_max_proofs_verified","counters":[]},{"line":"             , m )","counters":[]},{"line":"             Per_proof_witness.Constant.No_app_state.t","counters":[]},{"line":"           * [ `Actual_wrap_domain of int ] =","counters":[]},{"line":"     fun dlog_vk dlog_index app_state (T t) tag ~must_verify ->","counters":[]},{"line":"      let t =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { t with","counters":[]},{"line":"          statement =","counters":[]},{"line":"            { t.statement with","counters":[]},{"line":"              messages_for_next_step_proof =","counters":[]},{"line":"                { t.statement.messages_for_next_step_proof with app_state }","counters":[]},{"line":"            }","counters":[]},{"line":"        }","counters":[]},{"line":"      in","counters":[]},{"line":"      let plonk0 = t.statement.proof_state.deferred_values.plonk in","counters":[]},{"line":"      let plonk =","counters":[]},{"line":"        let domain =","counters":[]},{"line":"          Branch_data.domain t.statement.proof_state.deferred_values.branch_data","counters":[]},{"line":"        in","counters":[]},{"line":"        let to_field =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          SC.to_field_constant","counters":[]},{"line":"            (module Tick.Field)","counters":[]},{"line":"            ~endo:Endo.Wrap_inner_curve.scalar","counters":[]},{"line":"        in","counters":[]},{"line":"        let alpha = to_field plonk0.alpha in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let zeta = to_field plonk0.zeta in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let zetaw =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Tick.Field.(","counters":[]},{"line":"            zeta * domain_generator ~log2_size:(Domain.log2_size domain))","counters":[{"col_start":63,"col_end":63,"count":0}]},{"line":"        in","counters":[]},{"line":"        let combined_evals =","counters":[]},{"line":"          Plonk_checks.evals_of_split_evals","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"            (module Tick.Field)","counters":[]},{"line":"            t.prev_evals.evals.evals ~rounds:(Nat.to_int Tick.Rounds.n) ~zeta","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"            ~zetaw","counters":[]},{"line":"          |> Plonk_types.Evals.to_in_circuit","counters":[]},{"line":"        in","counters":[]},{"line":"        let plonk_minimal =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          { Composition_types.Wrap.Proof_state.Deferred_values.Plonk.Minimal","counters":[]},{"line":"            .zeta","counters":[]},{"line":"          ; alpha","counters":[]},{"line":"          ; beta = Challenge.Constant.to_tick_field plonk0.beta","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"          ; gamma = Challenge.Constant.to_tick_field plonk0.gamma","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"          ; joint_combiner = Option.map ~f:to_field plonk0.joint_combiner","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"          }","counters":[]},{"line":"        in","counters":[]},{"line":"        let env =","counters":[]},{"line":"          Plonk_checks.scalars_env","counters":[]},{"line":"            (module Tick.Field)","counters":[]},{"line":"            ~srs_length_log2:Common.Max_degree.step_log2","counters":[]},{"line":"            ~endo:Endo.Step_inner_curve.base ~mds:Tick_field_sponge.params.mds","counters":[]},{"line":"            ~field_of_hex:(fun s ->","counters":[]},{"line":"              Kimchi_pasta.Pasta.Bigint256.of_hex_string s","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"              |> Kimchi_pasta.Pasta.Fp.of_bigint )","counters":[]},{"line":"            ~domain:","counters":[]},{"line":"              (Plonk_checks.domain","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"                 (module Tick.Field)","counters":[]},{"line":"                 domain ~shifts:Common.tick_shifts","counters":[]},{"line":"                 ~domain_generator:Backend.Tick.Field.domain_generator )","counters":[]},{"line":"            plonk_minimal combined_evals","counters":[]},{"line":"        in","counters":[]},{"line":"        time \"plonk_checks\" (fun () ->","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":11,"col_end":11,"count":0}]},{"line":"            Plonk_checks.Type1.derive_plonk","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (module Tick.Field)","counters":[]},{"line":"              ~env ~shift:Shifts.tick1 plonk_minimal combined_evals )","counters":[]},{"line":"      in","counters":[]},{"line":"      let data = Types_map.lookup_basic tag in","counters":[]},{"line":"      let (module Local_max_proofs_verified) = data.max_proofs_verified in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let T = Local_max_proofs_verified.eq in","counters":[]},{"line":"      let statement = t.statement in","counters":[]},{"line":"      let prev_challenges =","counters":[]},{"line":"        (* TODO: This is redone in the call to Reduced_messages_for_next_proof_over_same_field.Wrap.prepare *)","counters":[]},{"line":"        Vector.map ~f:Ipa.Wrap.compute_challenges","counters":[]},{"line":"          statement.proof_state.messages_for_next_wrap_proof","counters":[]},{"line":"            .old_bulletproof_challenges","counters":[]},{"line":"      in","counters":[]},{"line":"      let prev_statement_with_hashes :","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          ( _","counters":[]},{"line":"          , _","counters":[]},{"line":"          , _ Shifted_value.Type1.t","counters":[]},{"line":"          , _","counters":[]},{"line":"          , _","counters":[]},{"line":"          , _","counters":[]},{"line":"          , _","counters":[]},{"line":"          , _","counters":[]},{"line":"          , _ )","counters":[]},{"line":"          Wrap.Statement.In_circuit.t =","counters":[]},{"line":"        { messages_for_next_step_proof =","counters":[]},{"line":"            (let to_field_elements =","counters":[]},{"line":"               let (Typ typ) = data.public_input in","counters":[]},{"line":"               fun x -> fst (typ.value_to_fields x)","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"             in","counters":[]},{"line":"             (* TODO: Only do this hashing when necessary *)","counters":[]},{"line":"             Common.hash_messages_for_next_step_proof","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"               (Reduced_messages_for_next_proof_over_same_field.Step.prepare","counters":[{"col_start":75,"col_end":75,"count":0}]},{"line":"                  ~dlog_plonk_index:dlog_index","counters":[]},{"line":"                  statement.messages_for_next_step_proof )","counters":[]},{"line":"               ~app_state:to_field_elements )","counters":[]},{"line":"        ; proof_state =","counters":[]},{"line":"            { statement.proof_state with","counters":[]},{"line":"              deferred_values =","counters":[]},{"line":"                { statement.proof_state.deferred_values with","counters":[]},{"line":"                  plonk =","counters":[]},{"line":"                    { plonk with","counters":[]},{"line":"                      zeta = plonk0.zeta","counters":[]},{"line":"                    ; alpha = plonk0.alpha","counters":[]},{"line":"                    ; beta = plonk0.beta","counters":[]},{"line":"                    ; gamma = plonk0.gamma","counters":[]},{"line":"                    ; lookup =","counters":[]},{"line":"                        Option.map (Opt.to_option plonk.lookup) ~f:(fun l ->","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"                            { l with","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                              joint_combiner =","counters":[]},{"line":"                                Option.value_exn plonk0.joint_combiner","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"                            } )","counters":[]},{"line":"                    }","counters":[]},{"line":"                }","counters":[]},{"line":"            ; messages_for_next_wrap_proof =","counters":[]},{"line":"                Wrap_hack.hash_messages_for_next_wrap_proof","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"                  Local_max_proofs_verified.n","counters":[]},{"line":"                  { old_bulletproof_challenges = prev_challenges","counters":[]},{"line":"                  ; challenge_polynomial_commitment =","counters":[]},{"line":"                      statement.proof_state.messages_for_next_wrap_proof","counters":[]},{"line":"                        .challenge_polynomial_commitment","counters":[]},{"line":"                  }","counters":[]},{"line":"            }","counters":[]},{"line":"        }","counters":[]},{"line":"      in","counters":[]},{"line":"      let module O = Tock.Oracles in","counters":[]},{"line":"      let o =","counters":[]},{"line":"        let public_input =","counters":[]},{"line":"          tock_public_input_of_statement prev_statement_with_hashes","counters":[]},{"line":"        in","counters":[]},{"line":"        O.create dlog_vk","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"          ( Vector.map2","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"              (Vector.extend_exn","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                 statement.messages_for_next_step_proof","counters":[]},{"line":"                   .challenge_polynomial_commitments Local_max_proofs_verified.n","counters":[]},{"line":"                 (Lazy.force Dummy.Ipa.Wrap.sg) )","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"              (* This should indeed have length Max_proofs_verified... No! It should have type Max_proofs_verified_a. That is, the max_proofs_verified specific to a proof of this type...*)","counters":[]},{"line":"              prev_challenges","counters":[]},{"line":"              ~f:(fun commitment chals ->","counters":[]},{"line":"                { Tock.Proof.Challenge_polynomial.commitment","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                ; challenges = Vector.to_array chals","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"                } )","counters":[]},{"line":"          |> Wrap_hack.pad_accumulator )","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"          public_input t.proof","counters":[]},{"line":"      in","counters":[]},{"line":"      let ((x_hat_1, x_hat_2) as x_hat) = O.(p_eval_1 o, p_eval_2 o) in","counters":[{"col_start":52,"col_end":52,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"      let scalar_chal f =","counters":[]},{"line":"        Scalar_challenge.map ~f:Challenge.Constant.of_tock_field (f o)","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"      in","counters":[]},{"line":"      let plonk0 =","counters":[]},{"line":"        { Types.Wrap.Proof_state.Deferred_values.Plonk.Minimal.alpha =","counters":[]},{"line":"            scalar_chal O.alpha","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"        ; beta = O.beta o","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"        ; gamma = O.gamma o","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"        ; zeta = scalar_chal O.zeta","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"        ; joint_combiner =","counters":[]},{"line":"            Option.map","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"              ~f:(Scalar_challenge.map ~f:Challenge.Constant.of_tock_field)","counters":[]},{"line":"              (O.joint_combiner_chal o)","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"        }","counters":[]},{"line":"      in","counters":[]},{"line":"      let xi = scalar_chal O.v in","counters":[]},{"line":"      let r = scalar_chal O.u in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let sponge_digest_before_evaluations = O.digest_before_evaluations o in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let to_field =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        SC.to_field_constant","counters":[]},{"line":"          (module Tock.Field)","counters":[]},{"line":"          ~endo:Endo.Step_inner_curve.scalar","counters":[]},{"line":"      in","counters":[]},{"line":"      let module As_field = struct","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let r = to_field r","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"        let xi = to_field xi","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"","counters":[]},{"line":"        let zeta = to_field plonk0.zeta","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"","counters":[]},{"line":"        let alpha = to_field plonk0.alpha","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"","counters":[]},{"line":"        let joint_combiner = O.joint_combiner o","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"      end in","counters":[]},{"line":"      let w =","counters":[]},{"line":"        Tock.Field.domain_generator ~log2_size:dlog_vk.domain.log_size_of_group","counters":[]},{"line":"      in","counters":[]},{"line":"      let zetaw = Tock.Field.mul As_field.zeta w in","counters":[]},{"line":"      let new_bulletproof_challenges, b =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let prechals =","counters":[]},{"line":"          Array.map (O.opening_prechallenges o) ~f:(fun x ->","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"              Scalar_challenge.map ~f:Challenge.Constant.of_tock_field x )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"        in","counters":[]},{"line":"        let chals =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Array.map prechals ~f:(fun x -> Ipa.Wrap.compute_challenge x)","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"        in","counters":[]},{"line":"        let challenge_polynomial = unstage (challenge_polynomial chals) in","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"        let open As_field in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let b =","counters":[]},{"line":"          let open Tock.Field in","counters":[]},{"line":"          challenge_polynomial zeta + (r * challenge_polynomial zetaw)","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"        in","counters":[]},{"line":"        let prechals =","counters":[]},{"line":"          Vector.of_list_and_length_exn","counters":[]},{"line":"            ( Array.map prechals ~f:(fun x ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                  { Bulletproof_challenge.prechallenge = x } )","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"            |> Array.to_list )","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"            Tock.Rounds.n","counters":[]},{"line":"        in","counters":[]},{"line":"        (prechals, b)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      in","counters":[]},{"line":"      let challenge_polynomial_commitment =","counters":[]},{"line":"        if not must_verify then Ipa.Wrap.compute_sg new_bulletproof_challenges","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"        else t.proof.openings.proof.challenge_polynomial_commitment","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"      in","counters":[]},{"line":"      let witness : _ Per_proof_witness.Constant.No_app_state.t =","counters":[]},{"line":"        { app_state = ()","counters":[]},{"line":"        ; proof_state =","counters":[]},{"line":"            { prev_statement_with_hashes.proof_state with","counters":[]},{"line":"              messages_for_next_wrap_proof = ()","counters":[]},{"line":"            }","counters":[]},{"line":"        ; prev_proof_evals = t.prev_evals","counters":[]},{"line":"        ; prev_challenge_polynomial_commitments =","counters":[]},{"line":"            Vector.extend_exn","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"              t.statement.messages_for_next_step_proof","counters":[]},{"line":"                .challenge_polynomial_commitments Local_max_proofs_verified.n","counters":[]},{"line":"              (Lazy.force Dummy.Ipa.Wrap.sg)","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"            (* TODO: This computation is also redone elsewhere. *)","counters":[]},{"line":"        ; prev_challenges =","counters":[]},{"line":"            Vector.extend_exn","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"              (Vector.map","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                 t.statement.messages_for_next_step_proof","counters":[]},{"line":"                   .old_bulletproof_challenges ~f:Ipa.Step.compute_challenges )","counters":[]},{"line":"              Local_max_proofs_verified.n Dummy.Ipa.Step.challenges_computed","counters":[]},{"line":"        ; wrap_proof =","counters":[]},{"line":"            { opening =","counters":[]},{"line":"                { t.proof.openings.proof with challenge_polynomial_commitment }","counters":[]},{"line":"            ; messages = t.proof.messages","counters":[]},{"line":"            }","counters":[]},{"line":"        }","counters":[]},{"line":"      in","counters":[]},{"line":"      let tock_domain =","counters":[]},{"line":"        Plonk_checks.domain","counters":[]},{"line":"          (module Tock.Field)","counters":[]},{"line":"          (Pow_2_roots_of_unity dlog_vk.domain.log_size_of_group)","counters":[]},{"line":"          ~shifts:Common.tock_shifts","counters":[]},{"line":"          ~domain_generator:Backend.Tock.Field.domain_generator","counters":[]},{"line":"      in","counters":[]},{"line":"      let tock_combined_evals =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Plonk_checks.evals_of_split_evals","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"          (module Tock.Field)","counters":[]},{"line":"          t.proof.openings.evals ~rounds:(Nat.to_int Tock.Rounds.n)","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"          ~zeta:As_field.zeta ~zetaw","counters":[]},{"line":"        |> Plonk_types.Evals.to_in_circuit","counters":[]},{"line":"      in","counters":[]},{"line":"      let tock_plonk_minimal =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { plonk0 with","counters":[]},{"line":"          zeta = As_field.zeta","counters":[]},{"line":"        ; alpha = As_field.alpha","counters":[]},{"line":"        ; joint_combiner = As_field.joint_combiner","counters":[]},{"line":"        }","counters":[]},{"line":"      in","counters":[]},{"line":"      let tock_env =","counters":[]},{"line":"        Plonk_checks.scalars_env","counters":[]},{"line":"          (module Tock.Field)","counters":[]},{"line":"          ~domain:tock_domain ~srs_length_log2:Common.Max_degree.wrap_log2","counters":[]},{"line":"          ~field_of_hex:(fun s ->","counters":[]},{"line":"            Kimchi_pasta.Pasta.Bigint256.of_hex_string s","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"            |> Kimchi_pasta.Pasta.Fq.of_bigint )","counters":[]},{"line":"          ~endo:Endo.Wrap_inner_curve.base ~mds:Tock_field_sponge.params.mds","counters":[]},{"line":"          tock_plonk_minimal tock_combined_evals","counters":[]},{"line":"      in","counters":[]},{"line":"      let combined_inner_product =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let e = t.proof.openings.evals in","counters":[]},{"line":"        let b_polys =","counters":[]},{"line":"          Vector.map","counters":[]},{"line":"            ~f:(fun chals ->","counters":[]},{"line":"              unstage (challenge_polynomial (Vector.to_array chals)) )","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":42,"col_end":42,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"            (Wrap_hack.pad_challenges prev_challenges)","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"        in","counters":[]},{"line":"        let a = Plonk_types.Evals.to_list e in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let open As_field in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let combine ~which_eval ~ft_eval pt =","counters":[]},{"line":"          let f (x, y) = match which_eval with `Fst -> x | `Snd -> y in","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":47,"col_end":47,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"          let v : Tock.Field.t array list =","counters":[]},{"line":"            let a = List.map ~f a in","counters":[]},{"line":"            List.append","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"              (Vector.to_list (Vector.map b_polys ~f:(fun f -> [| f pt |])))","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":63,"col_end":63,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"              ([| f x_hat |] :: [| ft_eval |] :: a)","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"          in","counters":[]},{"line":"          let open Tock.Field in","counters":[]},{"line":"          Pcs_batch.combine_split_evaluations ~xi ~init:Fn.id","counters":[]},{"line":"            ~mul_and_add:(fun ~acc ~xi fx -> fx + (xi * acc))","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"            v","counters":[]},{"line":"        in","counters":[]},{"line":"        let ft_eval0 =","counters":[]},{"line":"          Plonk_checks.Type2.ft_eval0","counters":[]},{"line":"            (module Tock.Field)","counters":[]},{"line":"            ~domain:tock_domain ~env:tock_env tock_plonk_minimal","counters":[]},{"line":"            tock_combined_evals x_hat_1 ~lookup_constant_term_part:None","counters":[]},{"line":"        in","counters":[]},{"line":"        let open Tock.Field in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        combine ~which_eval:`Fst ~ft_eval:ft_eval0 As_field.zeta","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"        + (r * combine ~which_eval:`Snd ~ft_eval:t.proof.openings.ft_eval1 zetaw)","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"      in","counters":[]},{"line":"      let chal = Challenge.Constant.of_tock_field in","counters":[]},{"line":"      let plonk =","counters":[]},{"line":"        Plonk_checks.Type2.derive_plonk","counters":[]},{"line":"          (module Tock.Field)","counters":[]},{"line":"          ~env:tock_env ~shift:Shifts.tock2 tock_plonk_minimal","counters":[]},{"line":"          tock_combined_evals","counters":[]},{"line":"      in","counters":[]},{"line":"      let shifted_value =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Shifted_value.Type2.of_field (module Tock.Field) ~shift:Shifts.tock2","counters":[]},{"line":"      in","counters":[]},{"line":"      ( `Sg challenge_polynomial_commitment","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      , { Types.Step.Proof_state.Per_proof.deferred_values =","counters":[]},{"line":"            { plonk =","counters":[]},{"line":"                { plonk with","counters":[]},{"line":"                  zeta = plonk0.zeta","counters":[]},{"line":"                ; alpha = plonk0.alpha","counters":[]},{"line":"                ; beta = chal plonk0.beta","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                ; gamma = chal plonk0.gamma","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                ; lookup =","counters":[]},{"line":"                    Option.map (Opt.to_option plonk.lookup) ~f:(fun l ->","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"                        { l with","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          joint_combiner =","counters":[]},{"line":"                            Option.value_exn plonk0.joint_combiner","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"                        } )","counters":[]},{"line":"                }","counters":[]},{"line":"            ; combined_inner_product = shifted_value combined_inner_product","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"            ; xi","counters":[]},{"line":"            ; bulletproof_challenges = new_bulletproof_challenges","counters":[]},{"line":"            ; b = shifted_value b","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"            }","counters":[]},{"line":"        ; should_finalize = must_verify","counters":[]},{"line":"        ; sponge_digest_before_evaluations =","counters":[]},{"line":"            Digest.Constant.of_tock_field sponge_digest_before_evaluations","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"        }","counters":[]},{"line":"      , prev_statement_with_hashes","counters":[]},{"line":"      , x_hat","counters":[]},{"line":"      , witness","counters":[]},{"line":"      , `Actual_wrap_domain dlog_vk.domain.log_size_of_group )","counters":[]},{"line":"    in","counters":[]},{"line":"    let challenge_polynomial_commitments = ref None in","counters":[]},{"line":"    let unfinalized_proofs = ref None in","counters":[]},{"line":"    let statements_with_hashes = ref None in","counters":[]},{"line":"    let x_hats = ref None in","counters":[]},{"line":"    let witnesses = ref None in","counters":[]},{"line":"    let prev_proofs = ref None in","counters":[]},{"line":"    let return_value = ref None in","counters":[]},{"line":"    let auxiliary_value = ref None in","counters":[]},{"line":"    let actual_wrap_domains = ref None in","counters":[]},{"line":"    let compute_prev_proof_parts prev_proof_requests =","counters":[]},{"line":"      let ( challenge_polynomial_commitments'","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          , unfinalized_proofs'","counters":[]},{"line":"          , statements_with_hashes'","counters":[]},{"line":"          , x_hats'","counters":[]},{"line":"          , witnesses'","counters":[]},{"line":"          , prev_proofs'","counters":[]},{"line":"          , actual_wrap_domains' ) =","counters":[]},{"line":"        let rec go :","counters":[]},{"line":"            type vars values ns ms k.","counters":[]},{"line":"               (vars, values, ns, ms) H4.T(Tag).t","counters":[]},{"line":"            -> ( values","counters":[]},{"line":"               , ns )","counters":[]},{"line":"               H2.T(Inductive_rule.Previous_proof_statement.Constant).t","counters":[]},{"line":"            -> (vars, k) Length.t","counters":[]},{"line":"            -> (Tock.Curve.Affine.t, k) Vector.t","counters":[]},{"line":"               * (Unfinalized.Constant.t, k) Vector.t","counters":[]},{"line":"               * (Statement_with_hashes.t, k) Vector.t","counters":[]},{"line":"               * (X_hat.t, k) Vector.t","counters":[]},{"line":"               * ( values","counters":[]},{"line":"                 , ns","counters":[]},{"line":"                 , ms )","counters":[]},{"line":"                 H3.T(Per_proof_witness.Constant.No_app_state).t","counters":[]},{"line":"               * (ns, ns) H2.T(Proof).t","counters":[]},{"line":"               * (int, k) Vector.t =","counters":[]},{"line":"         fun ts prev_proof_stmts l ->","counters":[]},{"line":"          match (ts, prev_proof_stmts, l) with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | [], [], Z ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              ([], [], [], [], [], [], [])","counters":[]},{"line":"          | ( t :: ts","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            , { public_input = app_state","counters":[]},{"line":"              ; proof = p","counters":[]},{"line":"              ; proof_must_verify = must_verify","counters":[]},{"line":"              }","counters":[]},{"line":"              :: prev_proof_stmts","counters":[]},{"line":"            , S l ) ->","counters":[]},{"line":"              let dlog_vk, dlog_index =","counters":[]},{"line":"                if Type_equal.Id.same self.Tag.id t.id then","counters":[]},{"line":"                  (self_dlog_vk, self_dlog_plonk_index)","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                else","counters":[]},{"line":"                  let d = Types_map.lookup_basic t in","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  (d.wrap_vk, d.wrap_key)","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"              in","counters":[]},{"line":"              let `Sg sg, u, s, x, w, `Actual_wrap_domain domain =","counters":[]},{"line":"                expand_proof dlog_vk dlog_index app_state p t ~must_verify","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"              and sgs, us, ss, xs, ws, ps, domains = go ts prev_proof_stmts l in","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"              ( sg :: sgs","counters":[]},{"line":"              , u :: us","counters":[]},{"line":"              , s :: ss","counters":[]},{"line":"              , x :: xs","counters":[]},{"line":"              , w :: ws","counters":[]},{"line":"              , p :: ps","counters":[]},{"line":"              , domain :: domains )","counters":[]},{"line":"          | _, _ :: _, _ ->","counters":[]},{"line":"              .","counters":[]},{"line":"          | _, [], _ ->","counters":[]},{"line":"              .","counters":[]},{"line":"        in","counters":[]},{"line":"        go branch_data.rule.prevs prev_proof_requests prev_vars_length","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"      in","counters":[]},{"line":"      challenge_polynomial_commitments := Some challenge_polynomial_commitments' ;","counters":[]},{"line":"      unfinalized_proofs := Some unfinalized_proofs' ;","counters":[]},{"line":"      statements_with_hashes := Some statements_with_hashes' ;","counters":[]},{"line":"      x_hats := Some x_hats' ;","counters":[]},{"line":"      witnesses := Some witnesses' ;","counters":[]},{"line":"      prev_proofs := Some prev_proofs' ;","counters":[]},{"line":"      actual_wrap_domains := Some actual_wrap_domains'","counters":[]},{"line":"    in","counters":[]},{"line":"    let unfinalized_proofs_extended =","counters":[]},{"line":"      lazy","counters":[]},{"line":"        (Vector.extend","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"           (Option.value_exn !unfinalized_proofs)","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"           lte Max_proofs_verified.n","counters":[]},{"line":"           (Lazy.force Unfinalized.Constant.dummy) )","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"    in","counters":[]},{"line":"    let module Extract = struct","counters":[]},{"line":"      module type S = sig","counters":[]},{"line":"        type res","counters":[]},{"line":"","counters":[]},{"line":"        val f : _ P.t -> res","counters":[]},{"line":"      end","counters":[]},{"line":"    end in","counters":[]},{"line":"    let extract_from_proofs (type res)","counters":[]},{"line":"        (module Extract : Extract.S with type res = res) =","counters":[]},{"line":"      let rec go :","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          type vars values ns ms len.","counters":[]},{"line":"             (ns, ns) H2.T(P).t","counters":[]},{"line":"          -> (values, vars, ns, ms) H4.T(Tag).t","counters":[]},{"line":"          -> (vars, len) Length.t","counters":[]},{"line":"          -> (res, len) Vector.t =","counters":[]},{"line":"       fun prevs tags len ->","counters":[]},{"line":"        match (prevs, tags, len) with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | [], [], Z ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            []","counters":[]},{"line":"        | t :: prevs, _ :: tags, S len ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Extract.f t :: go prevs tags len","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"      in","counters":[]},{"line":"      go","counters":[]},{"line":"        (Option.value_exn !prev_proofs)","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"        branch_data.rule.prevs prev_values_length","counters":[]},{"line":"    in","counters":[]},{"line":"    let messages_for_next_step_proof :","counters":[]},{"line":"        _ Reduced_messages_for_next_proof_over_same_field.Step.t Lazy.t =","counters":[]},{"line":"      lazy","counters":[]},{"line":"        (let old_bulletproof_challenges =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"           extract_from_proofs","counters":[]},{"line":"             ( module struct","counters":[]},{"line":"               type res =","counters":[]},{"line":"                 Challenge.Constant.t Scalar_challenge.t Bulletproof_challenge.t","counters":[]},{"line":"                 Step_bp_vec.t","counters":[]},{"line":"","counters":[]},{"line":"               let f (T t : _ P.t) =","counters":[]},{"line":"                 t.statement.proof_state.deferred_values.bulletproof_challenges","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"             end )","counters":[]},{"line":"         in","counters":[]},{"line":"         let (return_value : ret_value) = Option.value_exn !return_value in","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"         let (app_state : value) =","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"           match public_input with","counters":[]},{"line":"           | Input _ ->","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"               next_state","counters":[]},{"line":"           | Output _ ->","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"               return_value","counters":[]},{"line":"           | Input_and_output _ ->","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"               (next_state, return_value)","counters":[]},{"line":"         in","counters":[]},{"line":"         (* Have the sg be available in the opening proof and verify it. *)","counters":[]},{"line":"         { app_state","counters":[]},{"line":"         ; challenge_polynomial_commitments =","counters":[]},{"line":"             Option.value_exn !challenge_polynomial_commitments","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"         ; old_bulletproof_challenges","counters":[]},{"line":"         } )","counters":[]},{"line":"    in","counters":[]},{"line":"    let messages_for_next_step_proof_prepared =","counters":[]},{"line":"      lazy","counters":[]},{"line":"        (Reduced_messages_for_next_proof_over_same_field.Step.prepare","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"           ~dlog_plonk_index:self_dlog_plonk_index","counters":[]},{"line":"           (Lazy.force messages_for_next_step_proof) )","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"    in","counters":[]},{"line":"    let messages_for_next_wrap_proof_padded =","counters":[]},{"line":"      let rec pad :","counters":[]},{"line":"          type n k maxes pvals lws lhs.","counters":[]},{"line":"             (Digest.Constant.t, k) Vector.t","counters":[]},{"line":"          -> maxes H1.T(Nat).t","counters":[]},{"line":"          -> (maxes, n) Hlist.Length.t","counters":[]},{"line":"          -> (Digest.Constant.t, n) Vector.t =","counters":[]},{"line":"       fun xs maxes l ->","counters":[]},{"line":"        match (xs, maxes, l) with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | [], [], Z ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            []","counters":[]},{"line":"        | x :: xs, [], Z ->","counters":[]},{"line":"            assert false","counters":[]},{"line":"        | x :: xs, _ :: ms, S n ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            x :: pad xs ms n","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"        | [], m :: ms, S n ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let t : _ Types.Wrap.Proof_state.Messages_for_next_wrap_proof.t =","counters":[]},{"line":"              { challenge_polynomial_commitment = Lazy.force Dummy.Ipa.Step.sg","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"              ; old_bulletproof_challenges =","counters":[]},{"line":"                  Vector.init Max_proofs_verified.n ~f:(fun _ ->","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                      Dummy.Ipa.Wrap.challenges_computed )","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"              }","counters":[]},{"line":"            in","counters":[]},{"line":"            Wrap_hack.hash_messages_for_next_wrap_proof Max_proofs_verified.n t","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"            :: pad [] ms n","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"      in","counters":[]},{"line":"      lazy","counters":[]},{"line":"        (pad","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"           (Vector.map (Option.value_exn !statements_with_hashes) ~f:(fun s ->","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"                s.proof_state.messages_for_next_wrap_proof ) )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"           Maxes.maxes Maxes.length )","counters":[]},{"line":"    in","counters":[]},{"line":"    let handler (Snarky_backendless.Request.With { request; respond } as r) =","counters":[]},{"line":"      let k x = respond (Provide x) in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":16,"col_end":16,"count":0}]},{"line":"      match request with","counters":[]},{"line":"      | Req.Compute_prev_proof_parts prev_proof_requests ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          compute_prev_proof_parts prev_proof_requests ;","counters":[]},{"line":"          k ()","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"      | Req.Proof_with_datas ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          k (Option.value_exn !witnesses)","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"      | Req.Wrap_index ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          k self_dlog_plonk_index","counters":[]},{"line":"      | Req.App_state ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          k next_state","counters":[]},{"line":"      | Req.Return_value res ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          return_value := Some res ;","counters":[]},{"line":"          k ()","counters":[]},{"line":"      | Req.Auxiliary_value res ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          auxiliary_value := Some res ;","counters":[]},{"line":"          k ()","counters":[]},{"line":"      | Req.Unfinalized_proofs ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          k (Lazy.force unfinalized_proofs_extended)","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"      | Req.Messages_for_next_wrap_proof ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          k (Lazy.force messages_for_next_wrap_proof_padded)","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"      | _ -> (","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          match handler with","counters":[]},{"line":"          | Some f ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              f r","counters":[]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Snarky_backendless.Request.unhandled )","counters":[]},{"line":"    in","counters":[]},{"line":"    let prev_challenge_polynomial_commitments =","counters":[]},{"line":"      lazy","counters":[]},{"line":"        (let to_fold_in =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"           extract_from_proofs","counters":[]},{"line":"             ( module struct","counters":[]},{"line":"               type res = Tick.Curve.Affine.t","counters":[]},{"line":"","counters":[]},{"line":"               let f (T t : _ P.t) =","counters":[]},{"line":"                 t.statement.proof_state.messages_for_next_wrap_proof","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                   .challenge_polynomial_commitment","counters":[]},{"line":"             end )","counters":[]},{"line":"         in","counters":[]},{"line":"         (* emphatically NOT padded with dummies *)","counters":[]},{"line":"         Vector.(","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"           map2 to_fold_in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"             (Lazy.force messages_for_next_step_proof_prepared)","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"               .old_bulletproof_challenges ~f:(fun commitment chals ->","counters":[]},{"line":"               { Tick.Proof.Challenge_polynomial.commitment","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"               ; challenges = Vector.to_array chals","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"               } )","counters":[]},{"line":"           |> to_list) )","counters":[]},{"line":"    in","counters":[]},{"line":"    let%map.Promise (next_proof : Tick.Proof.t), next_statement_hashed =","counters":[]},{"line":"      let (T (input, _conv, conv_inv)) =","counters":[]},{"line":"        Impls.Step.input ~proofs_verified:Max_proofs_verified.n","counters":[]},{"line":"          ~wrap_rounds:Tock.Rounds.n ~uses_lookup","counters":[]},{"line":"      in","counters":[]},{"line":"      let { Domains.h } =","counters":[]},{"line":"        List.nth_exn (Vector.to_list step_domains) branch_data.index","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"      in","counters":[]},{"line":"      ksprintf Common.time \"step-prover %d (%d)\" branch_data.index","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":13,"col_end":13,"count":0}]},{"line":"        (Domain.size h)","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"        (fun () ->","counters":[]},{"line":"          Impls.Step.generate_witness_conv","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ~f:(fun { Impls.Step.Proof_inputs.auxiliary_inputs; public_inputs }","counters":[]},{"line":"                    next_statement_hashed ->","counters":[]},{"line":"              let%map.Promise proof =","counters":[]},{"line":"                Backend.Tick.Proof.create_async ~primary:public_inputs","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"                  ~auxiliary:auxiliary_inputs","counters":[]},{"line":"                  ~message:(Lazy.force prev_challenge_polynomial_commitments)","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                  pk","counters":[]},{"line":"              in","counters":[]},{"line":"              (proof, next_statement_hashed) )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"            ~input_typ:Impls.Step.Typ.unit ~return_typ:input","counters":[]},{"line":"            (fun () () ->","counters":[]},{"line":"              Impls.Step.handle","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (fun () -> conv_inv (branch_data.main ~step_domains ()))","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"                handler ) )","counters":[]},{"line":"        ()","counters":[]},{"line":"    in","counters":[]},{"line":"    let prev_evals =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      extract_from_proofs","counters":[]},{"line":"        ( module struct","counters":[]},{"line":"          type res = E.t","counters":[]},{"line":"","counters":[]},{"line":"          let f (T t : _ P.t) =","counters":[]},{"line":"            (t.proof.openings.evals, t.proof.openings.ft_eval1)","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"        end )","counters":[]},{"line":"    in","counters":[]},{"line":"    let messages_for_next_wrap_proof =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let rec go :","counters":[]},{"line":"          type a a.","counters":[]},{"line":"             (a, a) H2.T(P).t","counters":[]},{"line":"          -> a H1.T(P.Base.Messages_for_next_proof_over_same_field.Wrap).t =","counters":[]},{"line":"        function","counters":[]},{"line":"        | [] ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            []","counters":[]},{"line":"        | T t :: tl ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            t.statement.proof_state.messages_for_next_wrap_proof :: go tl","counters":[{"col_start":69,"col_end":69,"count":0}]},{"line":"      in","counters":[]},{"line":"      go (Option.value_exn !prev_proofs)","counters":[{"col_start":7,"col_end":7,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"    in","counters":[]},{"line":"    let next_statement : _ Types.Step.Statement.t =","counters":[]},{"line":"      { proof_state =","counters":[]},{"line":"          { unfinalized_proofs = Lazy.force unfinalized_proofs_extended","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"          ; messages_for_next_step_proof =","counters":[]},{"line":"              Lazy.force messages_for_next_step_proof","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"          }","counters":[]},{"line":"      ; messages_for_next_wrap_proof","counters":[]},{"line":"      }","counters":[]},{"line":"    in","counters":[]},{"line":"    ( { P.Base.Step.proof = next_proof","counters":[]},{"line":"      ; statement = next_statement","counters":[]},{"line":"      ; index = branch_data.index","counters":[]},{"line":"      ; prev_evals =","counters":[]},{"line":"          Vector.extend","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"            (Vector.map2 prev_evals (Option.value_exn !x_hats)","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"               ~f:(fun (es, ft_eval1) x_hat ->","counters":[]},{"line":"                 Plonk_types.All_evals.","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                   { ft_eval1","counters":[]},{"line":"                   ; evals =","counters":[]},{"line":"                       { With_public_input.evals = es; public_input = x_hat }","counters":[]},{"line":"                   } ) )","counters":[]},{"line":"            lte Max_proofs_verified.n Dummy.evals","counters":[]},{"line":"      }","counters":[]},{"line":"    , Option.value_exn !return_value","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"    , Option.value_exn !auxiliary_value","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"    , Option.value_exn !actual_wrap_domains )","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}