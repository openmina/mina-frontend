{"filename":"src/lib/mina_base/fee_excess.ml","lines":[{"line":"(** Fee excesses associated with transactions or transitions.","counters":[]},{"line":"","counters":[]},{"line":"    These are represented as a 'left' and 'right' excess, which describe the","counters":[]},{"line":"    unresolved fee excesses in the fee tokens of the first (or leftmost) and","counters":[]},{"line":"    last (or rightmost) transactions in the transition.","counters":[]},{"line":"","counters":[]},{"line":"    Assumptions:","counters":[]},{"line":"    * Transactions are grouped by their fee token.","counters":[]},{"line":"    * The 'fee transfer' transaction to dispense those fees is part of this","counters":[]},{"line":"      group.","counters":[]},{"line":"    * The fee excess for each token is 0 across the group.","counters":[]},{"line":"    * No transactions with fees paid in another token are executed while the","counters":[]},{"line":"      previous fee token's excess is non-zero.","counters":[]},{"line":"","counters":[]},{"line":"    By maintaining these assumptions, we can ensure that the un-settled fee","counters":[]},{"line":"    excesses can be represented by excesses in (at most) 2 tokens.","counters":[]},{"line":"    Consider, for example, any consecutive subsequence of the transactions","counters":[]},{"line":"","counters":[]},{"line":"    ..[txn@2][ft@2][txn@3][txn@3][ft@3][txn@4][ft@4][txn@5][txn@5][ft@5][txn@6][ft@6]..","counters":[]},{"line":"","counters":[]},{"line":"    where [txn@i] and [ft@i] are transactions and fee transfers respectively","counters":[]},{"line":"    paid in token i.","counters":[]},{"line":"    The only groups which may have non-zero fee excesses are those which","counters":[]},{"line":"    contain the start and end of the subsequence.","counters":[]},{"line":"","counters":[]},{"line":"    The code below also defines a canonical representation where fewer than 2","counters":[]},{"line":"    tokens have non-zero excesses. See [rebalance] below for details and the","counters":[]},{"line":"    implementation.","counters":[]},{"line":"*)","counters":[]},{"line":"","counters":[]},{"line":"[%%import \"/src/config.mlh\"]","counters":[]},{"line":"","counters":[{"col_start":0,"col_end":0,"count":1}]},{"line":"open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"[%%ifndef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"open Mina_base_import","counters":[]},{"line":"","counters":[]},{"line":"[%%endif]","counters":[]},{"line":"","counters":[]},{"line":"open Currency","counters":[]},{"line":"","counters":[]},{"line":"[%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"open Snark_params","counters":[]},{"line":"open Tick","counters":[]},{"line":"","counters":[]},{"line":"[%%endif]","counters":[]},{"line":"","counters":[]},{"line":"module Poly = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type ('token, 'fee) t =","counters":[{"col_start":6,"col_end":6,"count":1},{"col_start":26,"col_end":26,"count":5}]},{"line":"            ('token, 'fee) Mina_wire_types.Mina_base.Fee_excess.Poly.V1.t =","counters":[]},{"line":"        { fee_token_l : 'token","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"        ; fee_excess_l : 'fee","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"        ; fee_token_r : 'token","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"        ; fee_excess_r : 'fee","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"        }","counters":[]},{"line":"      [@@deriving compare, equal, hash, sexp, hlist]","counters":[{"col_start":51,"col_end":51,"count":3}]},{"line":"","counters":[]},{"line":"      let to_yojson token_to_yojson fee_to_yojson","counters":[]},{"line":"          { fee_token_l; fee_excess_l; fee_token_r; fee_excess_r } =","counters":[]},{"line":"        `List","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          [ `Assoc","counters":[]},{"line":"              [ (\"token\", token_to_yojson fee_token_l)","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"              ; (\"amount\", fee_to_yojson fee_excess_l)","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"              ]","counters":[]},{"line":"          ; `Assoc","counters":[]},{"line":"              [ (\"token\", token_to_yojson fee_token_r)","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"              ; (\"amount\", fee_to_yojson fee_excess_r)","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"              ]","counters":[]},{"line":"          ]","counters":[]},{"line":"","counters":[]},{"line":"      let of_yojson token_of_yojson fee_of_yojson = function","counters":[]},{"line":"        | `List [ `Assoc [ left0; left1 ]; `Assoc [ right0; right1 ] ] -> (","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (* allow for reversed field order: \"be liberal in what you accept\" *)","counters":[]},{"line":"            let token_and_excess pair0 pair1 =","counters":[]},{"line":"              match (pair0, pair1) with","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              | (\"token\", token), (\"amount\", excess) ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Some (token, excess)","counters":[]},{"line":"              | (\"amount\", excess), (\"token\", token) ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Some (token, excess)","counters":[]},{"line":"              | _ ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  None","counters":[]},{"line":"            in","counters":[]},{"line":"            let left = token_and_excess left0 left1 in","counters":[]},{"line":"            let right = token_and_excess right0 right1 in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            match (left, right) with","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            | Some (fee_token_l, fee_excess_l), Some (fee_token_r, fee_excess_r)","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              ->","counters":[]},{"line":"                let open Result.Let_syntax in","counters":[]},{"line":"                let%map fee_token_l = token_of_yojson fee_token_l","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"                and fee_excess_l = fee_of_yojson fee_excess_l","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"                and fee_token_r = token_of_yojson fee_token_r","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"                and fee_excess_r = fee_of_yojson fee_excess_r in","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"                { fee_token_l; fee_excess_l; fee_token_r; fee_excess_r }","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"            | _ ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Error \"Fee_excess.Poly.Stable.V1.t, unexpected JSON field\" )","counters":[]},{"line":"        | _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Error \"Fee_excess.Poly.Stable.V1.t\"","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  [%%define_locally Stable.Latest.(to_yojson, of_yojson)]","counters":[]},{"line":"","counters":[]},{"line":"  [%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"  let typ (token_typ : ('token_var, 'token) Typ.t)","counters":[]},{"line":"      (fee_typ : ('fee_var, 'fee) Typ.t) :","counters":[]},{"line":"      (('token_var, 'fee_var) t, ('token, 'fee) t) Typ.t =","counters":[]},{"line":"    Typ.of_hlistable","counters":[{"col_start":4,"col_end":4,"count":1}]},{"line":"      [ token_typ; fee_typ; token_typ; fee_typ ]","counters":[]},{"line":"      ~var_to_hlist:to_hlist ~var_of_hlist:of_hlist ~value_to_hlist:to_hlist","counters":[]},{"line":"      ~value_of_hlist:of_hlist","counters":[]},{"line":"","counters":[]},{"line":"  [%%endif]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"[%%versioned","counters":[]},{"line":"module Stable = struct","counters":[]},{"line":"  module V1 = struct","counters":[]},{"line":"    type t =","counters":[{"col_start":4,"col_end":4,"count":2},{"col_start":9,"col_end":9,"count":1}]},{"line":"      ( Token_id.Stable.V2.t","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":8,"col_end":8,"count":0}]},{"line":"      , (Fee.Stable.V1.t, Sgn.Stable.V1.t) Signed_poly.Stable.V1.t )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":9,"col_end":9,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"      Poly.Stable.V1.t","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    [@@deriving compare, equal, hash, sexp, yojson]","counters":[{"col_start":50,"col_end":50,"count":5}]},{"line":"","counters":[]},{"line":"    let to_latest = Fn.id","counters":[]},{"line":"  end","counters":[]},{"line":"end]","counters":[]},{"line":"","counters":[]},{"line":"type ('token, 'fee) poly = ('token, 'fee) Poly.t =","counters":[{"col_start":0,"col_end":0,"count":0}]},{"line":"  { fee_token_l : 'token","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":14,"col_end":14,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"  ; fee_excess_l : 'fee","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"  ; fee_token_r : 'token","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":14,"col_end":14,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"  ; fee_excess_r : 'fee","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"  }","counters":[]},{"line":"[@@deriving compare, equal, hash, sexp]","counters":[]},{"line":"","counters":[]},{"line":"let poly_to_yojson = Poly.to_yojson","counters":[]},{"line":"","counters":[]},{"line":"let poly_of_yojson = Poly.of_yojson","counters":[]},{"line":"","counters":[]},{"line":"[%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"type var = (Token_id.Checked.t, Fee.Signed.var) poly","counters":[]},{"line":"","counters":[]},{"line":"let typ : (var, t) Typ.t = Poly.typ Token_id.typ Fee.Signed.typ","counters":[{"col_start":34,"col_end":34,"count":1}]},{"line":"","counters":[]},{"line":"let var_of_t ({ fee_token_l; fee_excess_l; fee_token_r; fee_excess_r } : t) :","counters":[]},{"line":"    var =","counters":[]},{"line":"  { fee_token_l = Token_id.Checked.constant fee_token_l","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"  ; fee_excess_l = Fee.Signed.Checked.constant fee_excess_l","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"  ; fee_token_r = Token_id.Checked.constant fee_token_r","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"  ; fee_excess_r = Fee.Signed.Checked.constant fee_excess_r","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"[%%endif]","counters":[]},{"line":"","counters":[]},{"line":"let to_input { fee_token_l; fee_excess_l; fee_token_r; fee_excess_r } =","counters":[]},{"line":"  let open Random_oracle.Input.Chunked in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  List.reduce_exn ~f:append","counters":[]},{"line":"    [ Token_id.to_input fee_token_l","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"    ; Fee.Signed.to_input fee_excess_l","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"    ; Token_id.to_input fee_token_r","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"    ; Fee.Signed.to_input fee_excess_r","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"    ]","counters":[]},{"line":"","counters":[]},{"line":"[%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"let to_input_checked { fee_token_l; fee_excess_l; fee_token_r; fee_excess_r } =","counters":[]},{"line":"  let fee_token_l = Token_id.Checked.to_input fee_token_l","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"  and fee_token_r = Token_id.Checked.to_input fee_token_r in","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"  let%map fee_excess_l = Fee.Signed.Checked.to_input fee_excess_l","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"  and fee_excess_r = Fee.Signed.Checked.to_input fee_excess_r in","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"  List.reduce_exn ~f:Random_oracle.Input.Chunked.append","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    [ fee_token_l; fee_excess_l; fee_token_r; fee_excess_r ]","counters":[]},{"line":"","counters":[]},{"line":"let assert_equal_checked (t1 : var) (t2 : var) =","counters":[]},{"line":"  Checked.all_unit","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    [ [%with_label_ \"fee_token_l\"] (fun () ->","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"          make_checked (fun () ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              Token_id.Checked.Assert.equal t1.fee_token_l t2.fee_token_l ) )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"    ; [%with_label_ \"fee_excess_l\"] (fun () ->","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"          Fee.Signed.Checked.assert_equal t1.fee_excess_l t2.fee_excess_l )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    ; [%with_label_ \"fee_token_r\"] (fun () ->","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"          make_checked (fun () ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              Token_id.Checked.Assert.equal t1.fee_token_r t2.fee_token_r ) )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"    ; [%with_label_ \"fee_excess_r\"] (fun () ->","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"          Fee.Signed.Checked.assert_equal t1.fee_excess_r t2.fee_excess_r )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    ]","counters":[]},{"line":"","counters":[]},{"line":"[%%endif]","counters":[]},{"line":"","counters":[]},{"line":"(** Eliminate a fee excess, either by combining it with one to the left/right,","counters":[]},{"line":"    or by checking that it is zero.","counters":[]},{"line":"*)","counters":[]},{"line":"let eliminate_fee_excess (fee_token_l, fee_excess_l) (fee_token_m, fee_excess_m)","counters":[]},{"line":"    (fee_token_r, fee_excess_r) =","counters":[]},{"line":"  let add_err x y =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    match Fee.Signed.add x y with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Some z ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Or_error.return z","counters":[]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Or_error.errorf \"Error adding fees: overflow.\"","counters":[]},{"line":"  in","counters":[]},{"line":"  let open Or_error.Let_syntax in","counters":[]},{"line":"  if","counters":[]},{"line":"    Token_id.equal fee_token_l fee_token_m","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"    || Fee.(equal zero) fee_excess_l.Signed_poly.magnitude","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"  then","counters":[]},{"line":"    let%map fee_excess_l = add_err fee_excess_l fee_excess_m in","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"    ((fee_token_m, fee_excess_l), (fee_token_r, fee_excess_r))","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  else if","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"    Token_id.equal fee_token_r fee_token_m","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"    || Fee.(equal zero fee_excess_r.Signed_poly.magnitude)","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"  then","counters":[]},{"line":"    let%map fee_excess_r = add_err fee_excess_r fee_excess_m in","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"    ((fee_token_l, fee_excess_l), (fee_token_m, fee_excess_r))","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  else if Fee.(equal zero) fee_excess_m.Signed_poly.magnitude then","counters":[{"col_start":7,"col_end":7,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"    return ((fee_token_l, fee_excess_l), (fee_token_r, fee_excess_r))","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  else","counters":[]},{"line":"    Or_error.errorf","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      !\"Error eliminating fee excess: Excess for token %{sexp: Token_id.t} \\","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"        %{sexp: Fee.Signed.t} was nonzero\"","counters":[]},{"line":"      fee_token_m fee_excess_m","counters":[]},{"line":"","counters":[]},{"line":"[%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"(* We use field elements instead of a currency type here, under the following","counters":[]},{"line":"   assumptions:","counters":[]},{"line":"   * the additions and subtractions performed upon members of the currency","counters":[]},{"line":"     type do not overflow the field size","counters":[]},{"line":"     - The currency type is currently 64-bit, which is much smaller than the","counters":[]},{"line":"       field size.","counters":[]},{"line":"   * it is acceptable for the currency type to overflow/underflow, as long as","counters":[]},{"line":"     a subsequent subtraction/addition brings it back into the range for the","counters":[]},{"line":"     currency type.","counters":[]},{"line":"     - These situations will be rejected by the unchecked code that checks","counters":[]},{"line":"       each addition/subtraction, but this superset of that behaviour seems","counters":[]},{"line":"       well-defined, and is still 'correct' in the sense that currency is","counters":[]},{"line":"       preserved.","counters":[]},{"line":"","counters":[]},{"line":"   This optimisation saves serveral hundred constraints in the proof by not","counters":[]},{"line":"   unpacking the result of each arithmetic operation.","counters":[]},{"line":"*)","counters":[]},{"line":"let%snarkydef_ eliminate_fee_excess_checked (fee_token_l, fee_excess_l)","counters":[]},{"line":"    (fee_token_m, fee_excess_m) (fee_token_r, fee_excess_r) =","counters":[]},{"line":"  let open Tick in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let open Checked.Let_syntax in","counters":[]},{"line":"  let combine (fee_token, fee_excess) fee_excess_m =","counters":[]},{"line":"    let%bind fee_token_equal =","counters":[]},{"line":"      make_checked (fun () -> Token_id.Checked.equal fee_token fee_token_m)","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"    in","counters":[]},{"line":"    let%bind fee_excess_zero =","counters":[]},{"line":"      Field.(Checked.equal (Var.constant zero)) fee_excess","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"    in","counters":[]},{"line":"    let%bind may_move = Boolean.(fee_token_equal ||| fee_excess_zero) in","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"    let%bind fee_token =","counters":[]},{"line":"      make_checked (fun () ->","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"          Token_id.Checked.if_ fee_excess_zero ~then_:fee_token_m","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ~else_:fee_token )","counters":[]},{"line":"    in","counters":[]},{"line":"    let%map fee_excess_to_move =","counters":[]},{"line":"      Field.Checked.if_ may_move ~then_:fee_excess_m","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"        ~else_:Field.(Var.constant zero)","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"    in","counters":[]},{"line":"    ( (fee_token, Field.Var.add fee_excess fee_excess_to_move)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"    , Field.Var.sub fee_excess_m fee_excess_to_move )","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"  in","counters":[]},{"line":"  (* NOTE: Below, we may update the tokens on both sides, even though we only","counters":[]},{"line":"     promote the excess to one of them. This differs from the unchecked","counters":[]},{"line":"     version, but","counters":[]},{"line":"     * the token may only be changed if it is associated with 0 fee excess","counters":[]},{"line":"     * any intermediate 0 fee excesses can always be either combined or erased","counters":[]},{"line":"       in later eliminations","counters":[]},{"line":"     * a fee excess of 0 on the left or right will have its token erased to the","counters":[]},{"line":"       default","counters":[]},{"line":"  *)","counters":[]},{"line":"  let%bind (fee_token_l, fee_excess_l), fee_excess_m =","counters":[]},{"line":"    combine (fee_token_l, fee_excess_l) fee_excess_m","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%bind (fee_token_r, fee_excess_r), fee_excess_m =","counters":[]},{"line":"    combine (fee_token_r, fee_excess_r) fee_excess_m","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%map () =","counters":[]},{"line":"    [%with_label_ \"Fee excess is eliminated\"]","counters":[{"col_start":43,"col_end":43,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"      Field.(fun () -> Checked.Assert.equal (Var.constant zero) fee_excess_m)","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"  in","counters":[]},{"line":"  ((fee_token_l, fee_excess_l), (fee_token_r, fee_excess_r))","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"[%%endif]","counters":[]},{"line":"","counters":[]},{"line":"(* 'Rebalance' to a canonical form, where","counters":[]},{"line":"   - if there is only 1 nonzero excess, it is to the left","counters":[]},{"line":"   - any zero fee excess has the default token","counters":[]},{"line":"   - if the fee tokens are the same, the excesses are combined","counters":[]},{"line":"*)","counters":[]},{"line":"let rebalance ({ fee_token_l; fee_excess_l; fee_token_r; fee_excess_r } : t) =","counters":[]},{"line":"  let open Or_error.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  (* Use the same token for both if [fee_excess_l] is zero. *)","counters":[]},{"line":"  let fee_token_l =","counters":[]},{"line":"    if Fee.(equal zero) fee_excess_l.magnitude then fee_token_r else fee_token_l","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":52,"col_end":52,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"  in","counters":[]},{"line":"  (* Rebalancing. *)","counters":[]},{"line":"  let%map fee_excess_l, fee_excess_r =","counters":[]},{"line":"    if Token_id.equal fee_token_l fee_token_r then","counters":[]},{"line":"      match Fee.Signed.add fee_excess_l fee_excess_r with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Some fee_excess_l ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          return (fee_excess_l, Fee.Signed.zero)","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"      | None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Or_error.errorf !\"Error adding fees: overflow\"","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"    else return (fee_excess_l, fee_excess_r)","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":14,"col_end":14,"count":0}]},{"line":"  in","counters":[]},{"line":"  (* Use the default token if the excess is zero.","counters":[]},{"line":"     This allows [verify_complete_merge] to verify a proof without knowledge of","counters":[]},{"line":"     the particular fee tokens used.","counters":[]},{"line":"  *)","counters":[]},{"line":"  let fee_token_l =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    if Fee.(equal zero) fee_excess_l.magnitude then Token_id.default","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"    else fee_token_l","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"  in","counters":[]},{"line":"  let fee_token_r =","counters":[]},{"line":"    if Fee.(equal zero) fee_excess_r.magnitude then Token_id.default","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"    else fee_token_r","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"  in","counters":[]},{"line":"  { fee_token_l; fee_excess_l; fee_token_r; fee_excess_r }","counters":[]},{"line":"","counters":[]},{"line":"[%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"let rebalance_checked { fee_token_l; fee_excess_l; fee_token_r; fee_excess_r } =","counters":[]},{"line":"  let open Checked.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  (* Use the same token for both if [fee_excess_l] is zero. *)","counters":[]},{"line":"  let%bind fee_token_l =","counters":[]},{"line":"    let%bind excess_is_zero =","counters":[]},{"line":"      Field.(Checked.equal (Var.constant zero) fee_excess_l)","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"    in","counters":[]},{"line":"    make_checked (fun () ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        Token_id.Checked.if_ excess_is_zero ~then_:fee_token_r","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ~else_:fee_token_l )","counters":[]},{"line":"  in","counters":[]},{"line":"  (* Rebalancing. *)","counters":[]},{"line":"  let%bind fee_excess_l, fee_excess_r =","counters":[]},{"line":"    let%bind tokens_equal =","counters":[]},{"line":"      make_checked (fun () -> Token_id.Checked.equal fee_token_l fee_token_r)","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"    in","counters":[]},{"line":"    let%map amount_to_move =","counters":[]},{"line":"      Field.Checked.if_ tokens_equal ~then_:fee_excess_r","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"        ~else_:Field.(Var.constant zero)","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"    in","counters":[]},{"line":"    ( Field.Var.add fee_excess_l amount_to_move","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"    , Field.Var.sub fee_excess_r amount_to_move )","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"  in","counters":[]},{"line":"  (* Use the default token if the excess is zero. *)","counters":[]},{"line":"  let%bind fee_token_l =","counters":[]},{"line":"    let%bind excess_is_zero =","counters":[]},{"line":"      Field.(Checked.equal (Var.constant zero) fee_excess_l)","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"    in","counters":[]},{"line":"    make_checked (fun () ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        Token_id.Checked.if_ excess_is_zero","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ~then_:Token_id.(Checked.constant default)","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"          ~else_:fee_token_l )","counters":[]},{"line":"  in","counters":[]},{"line":"  let%map fee_token_r =","counters":[]},{"line":"    let%bind excess_is_zero =","counters":[]},{"line":"      Field.(Checked.equal (Var.constant zero) fee_excess_r)","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"    in","counters":[]},{"line":"    make_checked (fun () ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        Token_id.Checked.if_ excess_is_zero","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ~then_:Token_id.(Checked.constant default)","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"          ~else_:fee_token_r )","counters":[]},{"line":"  in","counters":[]},{"line":"  { fee_token_l; fee_excess_l; fee_token_r; fee_excess_r }","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"[%%endif]","counters":[]},{"line":"","counters":[]},{"line":"(** Combine the fee excesses from two transitions. *)","counters":[]},{"line":"let combine","counters":[]},{"line":"    { fee_token_l = fee_token1_l","counters":[]},{"line":"    ; fee_excess_l = fee_excess1_l","counters":[]},{"line":"    ; fee_token_r = fee_token1_r","counters":[]},{"line":"    ; fee_excess_r = fee_excess1_r","counters":[]},{"line":"    }","counters":[]},{"line":"    { fee_token_l = fee_token2_l","counters":[]},{"line":"    ; fee_excess_l = fee_excess2_l","counters":[]},{"line":"    ; fee_token_r = fee_token2_r","counters":[]},{"line":"    ; fee_excess_r = fee_excess2_r","counters":[]},{"line":"    } =","counters":[]},{"line":"  let open Or_error.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  (* Eliminate fee_excess1_r. *)","counters":[]},{"line":"  let%bind (fee_token1_l, fee_excess1_l), (fee_token2_l, fee_excess2_l) =","counters":[]},{"line":"    (* [1l; 1r; 2l; 2r] -> [1l; 2l; 2r] *)","counters":[]},{"line":"    eliminate_fee_excess","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"      (fee_token1_l, fee_excess1_l)","counters":[]},{"line":"      (fee_token1_r, fee_excess1_r)","counters":[]},{"line":"      (fee_token2_l, fee_excess2_l)","counters":[]},{"line":"  in","counters":[]},{"line":"  (* Eliminate fee_excess2_l. *)","counters":[]},{"line":"  let%bind (fee_token1_l, fee_excess1_l), (fee_token2_r, fee_excess2_r) =","counters":[]},{"line":"    (* [1l; 2l; 2r] -> [1l; 2r] *)","counters":[]},{"line":"    eliminate_fee_excess","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"      (fee_token1_l, fee_excess1_l)","counters":[]},{"line":"      (fee_token2_l, fee_excess2_l)","counters":[]},{"line":"      (fee_token2_r, fee_excess2_r)","counters":[]},{"line":"  in","counters":[]},{"line":"  rebalance","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    { fee_token_l = fee_token1_l","counters":[]},{"line":"    ; fee_excess_l = fee_excess1_l","counters":[]},{"line":"    ; fee_token_r = fee_token2_r","counters":[]},{"line":"    ; fee_excess_r = fee_excess2_r","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"[%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"let%snarkydef_ combine_checked","counters":[]},{"line":"    { fee_token_l = fee_token1_l","counters":[]},{"line":"    ; fee_excess_l = fee_excess1_l","counters":[]},{"line":"    ; fee_token_r = fee_token1_r","counters":[]},{"line":"    ; fee_excess_r = fee_excess1_r","counters":[]},{"line":"    }","counters":[]},{"line":"    { fee_token_l = fee_token2_l","counters":[]},{"line":"    ; fee_excess_l = fee_excess2_l","counters":[]},{"line":"    ; fee_token_r = fee_token2_r","counters":[]},{"line":"    ; fee_excess_r = fee_excess2_r","counters":[]},{"line":"    } =","counters":[]},{"line":"  let open Checked.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  (* Represent amounts as field elements. *)","counters":[]},{"line":"  let%bind fee_excess1_l = Fee.Signed.Checked.to_field_var fee_excess1_l in","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"  let%bind fee_excess1_r = Fee.Signed.Checked.to_field_var fee_excess1_r in","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"  let%bind fee_excess2_l = Fee.Signed.Checked.to_field_var fee_excess2_l in","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"  let%bind fee_excess2_r = Fee.Signed.Checked.to_field_var fee_excess2_r in","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"  (* Eliminations. *)","counters":[]},{"line":"  let%bind (fee_token1_l, fee_excess1_l), (fee_token2_l, fee_excess2_l) =","counters":[]},{"line":"    (* [1l; 1r; 2l; 2r] -> [1l; 2l; 2r] *)","counters":[]},{"line":"    [%with_label_ \"Eliminate fee_excess1_r\"] (fun () ->","counters":[{"col_start":42,"col_end":42,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"        eliminate_fee_excess_checked","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (fee_token1_l, fee_excess1_l)","counters":[]},{"line":"          (fee_token1_r, fee_excess1_r)","counters":[]},{"line":"          (fee_token2_l, fee_excess2_l) )","counters":[]},{"line":"  in","counters":[]},{"line":"  let%bind (fee_token1_l, fee_excess1_l), (fee_token2_r, fee_excess2_r) =","counters":[]},{"line":"    (* [1l; 2l; 2r] -> [1l; 2r] *)","counters":[]},{"line":"    [%with_label_ \"Eliminate fee_excess2_l\"] (fun () ->","counters":[{"col_start":42,"col_end":42,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"        eliminate_fee_excess_checked","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (fee_token1_l, fee_excess1_l)","counters":[]},{"line":"          (fee_token2_l, fee_excess2_l)","counters":[]},{"line":"          (fee_token2_r, fee_excess2_r) )","counters":[]},{"line":"  in","counters":[]},{"line":"  let%bind { fee_token_l; fee_excess_l; fee_token_r; fee_excess_r } =","counters":[]},{"line":"    rebalance_checked","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"      { fee_token_l = fee_token1_l","counters":[]},{"line":"      ; fee_excess_l = fee_excess1_l","counters":[]},{"line":"      ; fee_token_r = fee_token2_r","counters":[]},{"line":"      ; fee_excess_r = fee_excess2_r","counters":[]},{"line":"      }","counters":[]},{"line":"  in","counters":[]},{"line":"  let convert_to_currency excess =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    let%bind currency_excess =","counters":[]},{"line":"      exists Fee.Signed.typ","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"        ~compute:","counters":[]},{"line":"          As_prover.(","counters":[]},{"line":"            let%map excess = read Field.typ excess in","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"            let is_neg =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Bigint.test_bit (Bigint.of_field excess) (Field.size_in_bits - 1)","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"            in","counters":[]},{"line":"            let sgn = if is_neg then Sgn.Neg else Sgn.Pos in","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"            let excess =","counters":[]},{"line":"              if is_neg then Field.(mul (negate one) excess) else excess","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":46,"col_end":46,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"            in","counters":[]},{"line":"            let magnitude =","counters":[]},{"line":"              (* TODO: Add a native coercion [Bigint -> UInt64] in Snarky's FFI","counters":[]},{"line":"                 bindings, use it here.","counters":[]},{"line":"              *)","counters":[]},{"line":"              let n = Bigint.of_field excess in","counters":[]},{"line":"              let total = ref Unsigned_extended.UInt64.zero in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              for i = 0 to Unsigned_extended.UInt64.length_in_bits - 1 do","counters":[]},{"line":"                if Bigint.test_bit n i then","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  total :=","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    Unsigned_extended.UInt64.(add !total (shift_left one i))","counters":[{"col_start":48,"col_end":48,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"              done ;","counters":[]},{"line":"              Fee.of_uint64 !total","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"            in","counters":[]},{"line":"            Fee.Signed.create ~magnitude ~sgn)","counters":[]},{"line":"    in","counters":[]},{"line":"    let%bind excess_from_currency =","counters":[]},{"line":"      Fee.Signed.Checked.to_field_var currency_excess","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"    in","counters":[]},{"line":"    let%map () =","counters":[]},{"line":"      [%with_label_ \"Fee excess does not overflow\"] (fun () ->","counters":[{"col_start":49,"col_end":49,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"          Field.Checked.Assert.equal excess excess_from_currency )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    in","counters":[]},{"line":"    currency_excess","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  in","counters":[]},{"line":"  (* Convert to currency. *)","counters":[]},{"line":"  let%bind fee_excess_l =","counters":[]},{"line":"    [%with_label_ \"Check for overflow in fee_excess_l\"] (fun () ->","counters":[{"col_start":53,"col_end":53,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"        convert_to_currency fee_excess_l )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%map fee_excess_r =","counters":[]},{"line":"    [%with_label_ \"Check for overflow in fee_excess_r\"] (fun () ->","counters":[{"col_start":53,"col_end":53,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"        convert_to_currency fee_excess_r )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"  in","counters":[]},{"line":"  { fee_token_l; fee_excess_l; fee_token_r; fee_excess_r }","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"[%%endif]","counters":[]},{"line":"","counters":[]},{"line":"let empty =","counters":[]},{"line":"  { fee_token_l = Token_id.default","counters":[]},{"line":"  ; fee_excess_l = Fee.Signed.zero","counters":[]},{"line":"  ; fee_token_r = Token_id.default","counters":[]},{"line":"  ; fee_excess_r = Fee.Signed.zero","counters":[]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"let is_empty { fee_token_l; fee_excess_l; fee_token_r; fee_excess_r } =","counters":[]},{"line":"  Fee.Signed.(equal zero) fee_excess_l","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"  && Fee.Signed.(equal zero) fee_excess_r","counters":[{"col_start":5,"col_end":5,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"  && Token_id.(equal default) fee_token_l","counters":[{"col_start":5,"col_end":5,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"  && Token_id.(equal default) fee_token_r","counters":[{"col_start":5,"col_end":5,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"","counters":[]},{"line":"let zero = empty","counters":[]},{"line":"","counters":[]},{"line":"let is_zero = is_empty","counters":[]},{"line":"","counters":[]},{"line":"let of_single (fee_token_l, fee_excess_l) =","counters":[]},{"line":"  (* This is safe, we know that we will not hit overflow above. *)","counters":[]},{"line":"  Or_error.ok_exn","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  @@ rebalance","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"       { fee_token_l","counters":[]},{"line":"       ; fee_excess_l","counters":[]},{"line":"       ; fee_token_r = Token_id.default","counters":[]},{"line":"       ; fee_excess_r = Fee.Signed.zero","counters":[]},{"line":"       }","counters":[]},{"line":"","counters":[]},{"line":"let of_one_or_two excesses =","counters":[]},{"line":"  let unreduced =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    match excesses with","counters":[]},{"line":"    | `One (fee_token_l, fee_excess_l) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { fee_token_l","counters":[]},{"line":"        ; fee_excess_l","counters":[]},{"line":"        ; fee_token_r = Token_id.default","counters":[]},{"line":"        ; fee_excess_r = Fee.Signed.zero","counters":[]},{"line":"        }","counters":[]},{"line":"    | `Two ((fee_token_l, fee_excess_l), (fee_token_r, fee_excess_r)) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { fee_token_l; fee_excess_l; fee_token_r; fee_excess_r }","counters":[]},{"line":"  in","counters":[]},{"line":"  rebalance unreduced","counters":[]},{"line":"","counters":[]},{"line":"let to_one_or_two ({ fee_token_l; fee_excess_l; fee_token_r; fee_excess_r } : t)","counters":[]},{"line":"    =","counters":[]},{"line":"  if Fee.(equal zero) fee_excess_r.magnitude then","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":14,"col_end":14,"count":0}]},{"line":"    `One (fee_token_l, fee_excess_l)","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  else `Two ((fee_token_l, fee_excess_l), (fee_token_r, fee_excess_r))","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"","counters":[]},{"line":"[%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"let gen =","counters":[]},{"line":"  let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"  let%map excesses =","counters":[]},{"line":"    One_or_two.gen (Quickcheck.Generator.tuple2 Token_id.gen Fee.Signed.gen)","counters":[{"col_start":17,"col_end":17,"count":1},{"col_start":46,"col_end":46,"count":1}]},{"line":"  in","counters":[]},{"line":"  match of_one_or_two excesses with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | Ok ret ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ret","counters":[]},{"line":"  | Error _ -> (","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (* There is an overflow, just choose the first excess. *)","counters":[]},{"line":"      match excesses with","counters":[]},{"line":"      | `One (fee_token_l, fee_excess_l) | `Two ((fee_token_l, fee_excess_l), _)","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"        ->","counters":[]},{"line":"          { fee_token_l","counters":[]},{"line":"          ; fee_excess_l","counters":[]},{"line":"          ; fee_token_r = Token_id.default","counters":[]},{"line":"          ; fee_excess_r = Fee.Signed.zero","counters":[]},{"line":"          } )","counters":[]},{"line":"","counters":[]},{"line":"let%test_unit \"Checked and unchecked behaviour is consistent\" =","counters":[]},{"line":"  Quickcheck.test (Quickcheck.Generator.tuple2 gen gen) ~f:(fun (fe1, fe2) ->","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"      let fe = combine fe1 fe2 in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let fe_checked =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Or_error.try_with (fun () ->","counters":[]},{"line":"            Test_util.checked_to_unchecked","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Typ.(typ * typ)","counters":[]},{"line":"              typ","counters":[]},{"line":"              (fun (fe1, fe2) -> combine_checked fe1 fe2)","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"              (fe1, fe2) )","counters":[]},{"line":"      in","counters":[]},{"line":"      match (fe, fe_checked) with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Ok fe, Ok fe_checked ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          [%test_eq: t] fe fe_checked","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"      | Error _, Error _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ()","counters":[]},{"line":"      | _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          [%test_eq: t Or_error.t] fe fe_checked )","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"let%test_unit \"Combine succeeds when the middle excess is zero\" =","counters":[]},{"line":"  Quickcheck.test","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Quickcheck.Generator.(","counters":[]},{"line":"      filter (tuple3 gen Token_id.gen Fee.Signed.gen)","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"        ~f:(fun (fe1, tid, _excess) ->","counters":[]},{"line":"          (* The tokens before and after should be distinct. Especially in this","counters":[]},{"line":"             scenario, we may get an overflow error otherwise.","counters":[]},{"line":"          *)","counters":[]},{"line":"          not (Token_id.equal fe1.fee_token_l tid) ))","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"    ~f:(fun (fe1, tid, excess) ->","counters":[]},{"line":"      let fe2 =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        if Fee.Signed.(equal zero) fe1.fee_excess_r then of_single (tid, excess)","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":57,"col_end":57,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"        else","counters":[]},{"line":"          match","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            of_one_or_two","counters":[]},{"line":"              (`Two","counters":[]},{"line":"                ( (fe1.fee_token_r, Fee.Signed.negate fe1.fee_excess_r)","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"                , (tid, excess) ) )","counters":[]},{"line":"          with","counters":[]},{"line":"          | Ok fe2 ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              fe2","counters":[]},{"line":"          | Error _ ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (* The token is the same, and rebalancing causes an overflow. *)","counters":[]},{"line":"              of_single (fe1.fee_token_r, Fee.Signed.negate fe1.fee_excess_r)","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"      in","counters":[]},{"line":"      ignore @@ Or_error.ok_exn (combine fe1 fe2) )","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":50,"col_end":50,"count":1}]},{"line":"","counters":[]},{"line":"[%%endif]","counters":[]}]}