{"filename":"src/lib/non_empty_list/non_empty_list.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"(* A non-empty list is a tuple of the head and the rest (as a list) *)","counters":[]},{"line":"[%%versioned","counters":[]},{"line":"module Stable = struct","counters":[]},{"line":"  module V1 = struct","counters":[]},{"line":"    type 'a t = 'a * 'a list [@@deriving sexp, compare, equal, hash, to_yojson]","counters":[{"col_start":4,"col_end":4,"count":2},{"col_start":9,"col_end":9,"count":0},{"col_start":12,"col_end":12,"count":3},{"col_start":16,"col_end":16,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":78,"col_end":78,"count":5}]},{"line":"  end","counters":[]},{"line":"end]","counters":[]},{"line":"","counters":[]},{"line":"let init x xs = (x, xs)","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"","counters":[]},{"line":"let singleton x = (x, [])","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"","counters":[]},{"line":"let uncons = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"let cons x' (x, xs) = (x', x :: xs)","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"let head (x, _) = x","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"","counters":[]},{"line":"let tail (_, xs) = xs","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"","counters":[]},{"line":"let last (x, xs) = if List.is_empty xs then x else List.last_exn xs","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"","counters":[]},{"line":"let of_list_opt = function [] -> None | x :: xs -> Some (x, xs)","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"let tail_opt t = of_list_opt (tail t)","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"","counters":[]},{"line":"let map (x, xs) ~f = (f x, List.map ~f xs)","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"","counters":[]},{"line":"let rev (x, xs) = List.fold xs ~init:(singleton x) ~f:(Fn.flip cons)","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":46,"col_end":46,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"","counters":[]},{"line":"(* As the Base.Container docs state, we'll add each function from C explicitly","counters":[]},{"line":" * rather than including C *)","counters":[]},{"line":"module C = Container.Make (struct","counters":[]},{"line":"  type nonrec 'a t = 'a t","counters":[]},{"line":"","counters":[]},{"line":"  let fold (x, xs) ~init ~f = List.fold xs ~init:(f init x) ~f","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"","counters":[]},{"line":"  let iter = `Custom (fun (x, xs) ~f -> f x ; List.iter xs ~f)","counters":[{"col_start":40,"col_end":40,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"","counters":[]},{"line":"  let length = `Define_using_fold","counters":[]},{"line":"end)","counters":[]},{"line":"","counters":[]},{"line":"[%%define_locally C.(find, find_map, iter, length)]","counters":[]},{"line":"","counters":[]},{"line":"let fold (x, xs) ~init ~f = List.fold xs ~init:(init x) ~f","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"","counters":[]},{"line":"let to_list (x, xs) = x :: xs","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"let append (x, xs) ys = (x, xs @ to_list ys)","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"let take (x, xs) = function","counters":[]},{"line":"  | 0 ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      None","counters":[]},{"line":"  | 1 ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Some (x, [])","counters":[]},{"line":"  | n ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Some (x, List.take xs (n - 1))","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"let min_elt ~compare (x, xs) =","counters":[]},{"line":"  Option.value_map ~default:x (List.min_elt ~compare xs) ~f:(fun mininum ->","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"      if compare x mininum < 0 then x else mininum )","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"","counters":[]},{"line":"let max_elt ~compare (x, xs) =","counters":[]},{"line":"  Option.value_map ~default:x (List.max_elt ~compare xs) ~f:(fun maximum ->","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"      if compare x maximum > 0 then x else maximum )","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"","counters":[]},{"line":"let rec iter_deferred (x, xs) ~f =","counters":[]},{"line":"  let open Async_kernel in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%bind () = f x in","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"  match xs with [] -> return () | h :: t -> iter_deferred (h, t) ~f","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":66,"col_end":66,"count":2}]}]}