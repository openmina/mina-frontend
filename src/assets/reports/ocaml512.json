{"filename":"src/lib/sparse_ledger_lib/sparse_ledger.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"module Tree = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    [@@@no_toplevel_latest_type]","counters":[]},{"line":"","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type ('hash, 'account) t =","counters":[{"col_start":6,"col_end":6,"count":1},{"col_start":29,"col_end":29,"count":5}]},{"line":"        | Account of 'account","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"        | Hash of 'hash","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"        | Node of 'hash * ('hash, 'account) t * ('hash, 'account) t","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":48,"col_end":48,"count":0},{"col_start":49,"col_end":49,"count":0},{"col_start":56,"col_end":56,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"      [@@deriving equal, sexp, yojson]","counters":[{"col_start":37,"col_end":37,"count":3}]},{"line":"","counters":[]},{"line":"      let rec to_latest acct_to_latest = function","counters":[]},{"line":"        | Account acct ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Account (acct_to_latest acct)","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"        | Hash hash ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Hash hash","counters":[]},{"line":"        | Node (hash, l, r) ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Node (hash, to_latest acct_to_latest l, to_latest acct_to_latest r)","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  type ('hash, 'account) t = ('hash, 'account) Stable.Latest.t =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    | Account of 'account","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"    | Hash of 'hash","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"    | Node of 'hash * ('hash, 'account) t * ('hash, 'account) t","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":52,"col_end":52,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"  [@@deriving equal, sexp, yojson]","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module T = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    [@@@no_toplevel_latest_type]","counters":[]},{"line":"","counters":[]},{"line":"    module V2 = struct","counters":[]},{"line":"      type ('hash, 'key, 'account) t =","counters":[{"col_start":6,"col_end":6,"count":2},{"col_start":35,"col_end":35,"count":6}]},{"line":"        { indexes : ('key * int) list","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"        ; depth : int","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":14,"col_end":14,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":20,"col_end":20,"count":0}]},{"line":"        ; tree : ('hash, 'account) Tree.Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"        }","counters":[]},{"line":"      [@@deriving sexp, yojson]","counters":[{"col_start":30,"col_end":30,"count":5}]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  type ('hash, 'key, 'account) t = ('hash, 'key, 'account) Stable.Latest.t =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    { indexes : ('key * int) list","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":12,"col_end":12,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"    ; depth : int","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":10,"col_end":10,"count":0},{"col_start":14,"col_end":14,"count":0},{"col_start":16,"col_end":16,"count":0}]},{"line":"    ; tree : ('hash, 'account) Tree.t","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":9,"col_end":9,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"    }","counters":[]},{"line":"  [@@deriving sexp, yojson]","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type S = sig","counters":[]},{"line":"  type hash","counters":[]},{"line":"","counters":[]},{"line":"  type account_id","counters":[]},{"line":"","counters":[]},{"line":"  type account","counters":[]},{"line":"","counters":[]},{"line":"  type t = (hash, account_id, account) T.t [@@deriving sexp, yojson]","counters":[]},{"line":"","counters":[]},{"line":"  val of_hash : depth:int -> hash -> t","counters":[]},{"line":"","counters":[]},{"line":"  val get_exn : t -> int -> account","counters":[]},{"line":"","counters":[]},{"line":"  val path_exn : t -> int -> [ `Left of hash | `Right of hash ] list","counters":[]},{"line":"","counters":[]},{"line":"  val set_exn : t -> int -> account -> t","counters":[]},{"line":"","counters":[]},{"line":"  val find_index_exn : t -> account_id -> int","counters":[]},{"line":"","counters":[]},{"line":"  val add_path :","counters":[]},{"line":"    t -> [ `Left of hash | `Right of hash ] list -> account_id -> account -> t","counters":[]},{"line":"","counters":[]},{"line":"  val iteri : t -> f:(int -> account -> unit) -> unit","counters":[]},{"line":"","counters":[]},{"line":"  val merkle_root : t -> hash","counters":[]},{"line":"","counters":[]},{"line":"  val depth : t -> int","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let tree { T.tree; _ } = tree","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"let of_hash ~depth h = { T.indexes = []; depth; tree = Hash h }","counters":[{"col_start":23,"col_end":23,"count":4}]},{"line":"","counters":[]},{"line":"module Make (Hash : sig","counters":[]},{"line":"  type t [@@deriving equal, sexp, yojson, compare]","counters":[]},{"line":"","counters":[]},{"line":"  val merge : height:int -> t -> t -> t","counters":[]},{"line":"end) (Account_id : sig","counters":[]},{"line":"  type t [@@deriving equal, sexp, yojson]","counters":[]},{"line":"end) (Account : sig","counters":[]},{"line":"  type t [@@deriving equal, sexp, yojson]","counters":[]},{"line":"","counters":[]},{"line":"  val data_hash : t -> Hash.t","counters":[]},{"line":"end) : sig","counters":[]},{"line":"  include","counters":[]},{"line":"    S","counters":[]},{"line":"      with type hash := Hash.t","counters":[]},{"line":"       and type account_id := Account_id.t","counters":[]},{"line":"       and type account := Account.t","counters":[]},{"line":"","counters":[]},{"line":"  val hash : (Hash.t, Account.t) Tree.t -> Hash.t","counters":[]},{"line":"end = struct","counters":[]},{"line":"  type t = (Hash.t, Account_id.t, Account.t) T.t [@@deriving sexp, yojson]","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":11,"col_end":11,"count":0},{"col_start":12,"col_end":12,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":73,"col_end":73,"count":0}]},{"line":"","counters":[]},{"line":"  let of_hash ~depth (hash : Hash.t) = of_hash ~depth hash","counters":[{"col_start":39,"col_end":39,"count":4}]},{"line":"","counters":[]},{"line":"  let hash : (Hash.t, Account.t) Tree.t -> Hash.t = function","counters":[]},{"line":"    | Account a ->","counters":[{"col_start":6,"col_end":6,"count":96}]},{"line":"        Account.data_hash a","counters":[]},{"line":"    | Hash h ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        h","counters":[]},{"line":"    | Node (h, _, _) ->","counters":[{"col_start":6,"col_end":6,"count":228}]},{"line":"        h","counters":[]},{"line":"","counters":[]},{"line":"  type index = int [@@deriving sexp, yojson]","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"","counters":[]},{"line":"  let depth { T.depth; _ } = depth","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"  let merkle_root { T.tree; _ } = hash tree","counters":[{"col_start":34,"col_end":34,"count":4}]},{"line":"","counters":[]},{"line":"  (* , add_path sl *)","counters":[]},{"line":"  (*     (Ledger.merkle_path ledger loc) *)","counters":[]},{"line":"  (*     key *)","counters":[]},{"line":"  (*     ( Ledger.get ledger loc *)","counters":[]},{"line":"  (*     |> Option.value_exn ?here:None ?error:None ?message:None ) ) *)","counters":[]},{"line":"","counters":[]},{"line":"  let add_path depth0 tree0 path0 account =","counters":[]},{"line":"    let rec build_tree height p =","counters":[{"col_start":4,"col_end":4,"count":64}]},{"line":"      match p with","counters":[{"col_start":6,"col_end":6,"count":124}]},{"line":"      | `Left h_r :: path ->","counters":[{"col_start":8,"col_end":8,"count":60}]},{"line":"          let l = build_tree (height - 1) path in","counters":[]},{"line":"          Tree.Node (Hash.merge ~height (hash l) h_r, l, Hash h_r)","counters":[{"col_start":10,"col_end":10,"count":60},{"col_start":30,"col_end":30,"count":60},{"col_start":44,"col_end":44,"count":60}]},{"line":"      | `Right h_l :: path ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let r = build_tree (height - 1) path in","counters":[]},{"line":"          Node (Hash.merge ~height h_l (hash r), Hash h_l, r)","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"      | [] ->","counters":[{"col_start":8,"col_end":8,"count":64}]},{"line":"          assert (height = -1) ;","counters":[{"col_start":17,"col_end":17,"count":64}]},{"line":"          Account account","counters":[]},{"line":"    in","counters":[]},{"line":"    let rec union height tree path =","counters":[]},{"line":"      (* Printf.eprintf \"union height=%d\\n%!\" height ; *)","counters":[]},{"line":"      match (tree, path) with","counters":[{"col_start":6,"col_end":6,"count":260}]},{"line":"      | Tree.Hash h, path ->","counters":[{"col_start":8,"col_end":8,"count":64}]},{"line":"          let t = build_tree height path in","counters":[]},{"line":"          [%test_result: Hash.t]","counters":[{"col_start":10,"col_end":10,"count":64},{"col_start":25,"col_end":25,"count":64}]},{"line":"            ~message:","counters":[]},{"line":"              \"Hashes in union are not equal, something is wrong with your \\","counters":[]},{"line":"               ledger\"","counters":[]},{"line":"            ~expect:h (hash t) ;","counters":[{"col_start":26,"col_end":26,"count":64}]},{"line":"          t","counters":[{"col_start":10,"col_end":10,"count":64}]},{"line":"      | Node (h, l, r), `Left h_r :: path ->","counters":[{"col_start":8,"col_end":8,"count":68}]},{"line":"          assert (Hash.equal h_r (hash r)) ;","counters":[{"col_start":17,"col_end":17,"count":68},{"col_start":27,"col_end":27,"count":68},{"col_start":37,"col_end":37,"count":68}]},{"line":"          let l = union (height - 1) l path in","counters":[]},{"line":"          Node (h, l, r)","counters":[{"col_start":10,"col_end":10,"count":68}]},{"line":"      | Node (h, l, r), `Right h_l :: path ->","counters":[{"col_start":8,"col_end":8,"count":128}]},{"line":"          assert (Hash.equal h_l (hash l)) ;","counters":[{"col_start":17,"col_end":17,"count":128},{"col_start":27,"col_end":27,"count":128},{"col_start":37,"col_end":37,"count":128}]},{"line":"          let r = union (height - 1) r path in","counters":[]},{"line":"          Node (h, l, r)","counters":[{"col_start":10,"col_end":10,"count":128}]},{"line":"      | Node _, [] ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          failwith \"Path too short\"","counters":[]},{"line":"      | Account _, _ :: _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          failwith \"Path too long\"","counters":[]},{"line":"      | Account a, [] ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          assert (Account.equal a account) ;","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"          tree","counters":[]},{"line":"    in","counters":[]},{"line":"    (* let v = *)","counters":[]},{"line":"    (*   List.map path0 ~f:(fun p -> *)","counters":[]},{"line":"    (*       match p with `Right _ -> \"right\" | `Left _ -> \"left\" ) *)","counters":[]},{"line":"    (* in *)","counters":[]},{"line":"    (* Printf.eprintf \"PATH LEN=%s\\n%!\" (String.concat ~sep:\",\" v) ; *)","counters":[]},{"line":"    (* let v = *)","counters":[]},{"line":"    (*   List.map path0 ~f:(fun p -> match p with `Right h -> h | `Left h -> h) *)","counters":[]},{"line":"    (* in *)","counters":[]},{"line":"    (* let v = List.map v ~f:(fun h -> Snark_params.Tick.Field.to_string h) in *)","counters":[]},{"line":"    (* Printf.eprintf \"PATH LEN=%s\\n%!\" (String.concat ~sep:\",\" v) ; *)","counters":[]},{"line":"    union (depth0 - 1) tree0 (List.rev path0)","counters":[{"col_start":37,"col_end":37,"count":64}]},{"line":"","counters":[]},{"line":"  let add_path (t : t) path account_id account =","counters":[]},{"line":"    (* Printf.eprintf \"add_path called\\n%!\" ; *)","counters":[]},{"line":"    let index =","counters":[{"col_start":4,"col_end":4,"count":64}]},{"line":"      List.foldi path ~init:0 ~f:(fun i acc x ->","counters":[]},{"line":"          match x with `Right _ -> acc + (1 lsl i) | `Left _ -> acc )","counters":[{"col_start":10,"col_end":10,"count":256},{"col_start":23,"col_end":23,"count":128},{"col_start":53,"col_end":53,"count":128}]},{"line":"    in","counters":[]},{"line":"    { t with","counters":[{"col_start":4,"col_end":4,"count":64}]},{"line":"      tree = add_path t.depth t.tree path account","counters":[{"col_start":20,"col_end":20,"count":64}]},{"line":"    ; indexes = (account_id, index) :: t.indexes","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let iteri (t : t) ~f =","counters":[]},{"line":"    let rec go acc i tree ~f =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      match tree with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Tree.Account a ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          f acc a","counters":[]},{"line":"      | Hash _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ()","counters":[]},{"line":"      | Node (_, l, r) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          go acc (i - 1) l ~f ;","counters":[]},{"line":"          go (acc + (1 lsl i)) (i - 1) r ~f","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    in","counters":[]},{"line":"    go 0 (t.depth - 1) t.tree ~f","counters":[]},{"line":"","counters":[]},{"line":"  let ith_bit idx i = (idx lsr i) land 1 = 1","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"  let find_index_exn (t : t) aid =","counters":[]},{"line":"    match List.Assoc.find t.indexes ~equal:Account_id.equal aid with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Some x ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        x","counters":[]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        failwithf","counters":[]},{"line":"          !\"Sparse_ledger.find_index_exn: %{sexp:Account_id.t} not in %{sexp: \\","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"            Account_id.t list}\"","counters":[]},{"line":"          aid","counters":[]},{"line":"          (List.map t.indexes ~f:fst)","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"          ()","counters":[]},{"line":"","counters":[]},{"line":"  let get_exn ({ T.tree; depth; _ } as t) idx =","counters":[]},{"line":"    let rec go i tree =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      match (i < 0, tree) with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | true, Tree.Account acct ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          acct","counters":[]},{"line":"      | false, Node (_, l, r) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let go_right = ith_bit idx i in","counters":[]},{"line":"          if go_right then go (i - 1) r else go (i - 1) l","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"      | _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let expected_kind = if i < 0 then \"n account\" else \" node\" in","counters":[{"col_start":44,"col_end":44,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"          let kind =","counters":[]},{"line":"            match tree with","counters":[]},{"line":"            | Account _ ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                \"n account\"","counters":[]},{"line":"            | Hash _ ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                \" hash\"","counters":[]},{"line":"            | Node _ ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                \" node\"","counters":[]},{"line":"          in","counters":[]},{"line":"          failwithf","counters":[]},{"line":"            !\"Sparse_ledger.get: Bad index %i. Expected a%s, but got a%s at \\","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"              depth %i. Tree = %{sexp:t}\"","counters":[]},{"line":"            idx expected_kind kind (depth - i) t ()","counters":[]},{"line":"    in","counters":[]},{"line":"    go (depth - 1) tree","counters":[]},{"line":"","counters":[]},{"line":"  let set_exn (t : t) idx acct =","counters":[]},{"line":"    let rec go i tree =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      match (i < 0, tree) with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | true, Tree.Account _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Tree.Account acct","counters":[]},{"line":"      | false, Node (_, l, r) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let l, r =","counters":[]},{"line":"            let go_right = ith_bit idx i in","counters":[]},{"line":"            if go_right then (l, go (i - 1) r) else (go (i - 1) l, r)","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":52,"col_end":52,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"          in","counters":[]},{"line":"          Node (Hash.merge ~height:i (hash l) (hash r), l, r)","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"      | _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let expected_kind = if i < 0 then \"n account\" else \" node\" in","counters":[{"col_start":44,"col_end":44,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"          let kind =","counters":[]},{"line":"            match tree with","counters":[]},{"line":"            | Account _ ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                \"n account\"","counters":[]},{"line":"            | Hash _ ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                \" hash\"","counters":[]},{"line":"            | Node _ ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                \" node\"","counters":[]},{"line":"          in","counters":[]},{"line":"          failwithf","counters":[]},{"line":"            \"Sparse_ledger.set: Bad index %i. Expected a%s, but got a%s at \\","counters":[]},{"line":"             depth %i.\"","counters":[]},{"line":"            idx expected_kind kind (t.depth - i) ()","counters":[]},{"line":"    in","counters":[]},{"line":"    { t with tree = go (t.depth - 1) t.tree }","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"","counters":[]},{"line":"  let path_exn { T.tree; depth; _ } idx =","counters":[]},{"line":"    let rec go acc i tree =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      if i < 0 then acc","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":20,"col_end":20,"count":0}]},{"line":"      else","counters":[]},{"line":"        match tree with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | Tree.Account _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            failwithf \"Sparse_ledger.path: Bad depth at index %i.\" idx ()","counters":[]},{"line":"        | Hash _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            failwithf \"Sparse_ledger.path: Dead end at index %i.\" idx ()","counters":[]},{"line":"        | Node (_, l, r) ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let go_right = ith_bit idx i in","counters":[]},{"line":"            if go_right then go (`Right (hash l) :: acc) (i - 1) r","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"            else go (`Left (hash r) :: acc) (i - 1) l","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"    in","counters":[]},{"line":"    go [] (depth - 1) tree","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"type ('hash, 'key, 'account) t = ('hash, 'key, 'account) T.t [@@deriving yojson]","counters":[{"col_start":0,"col_end":0,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":79,"col_end":79,"count":0}]},{"line":"","counters":[]},{"line":"let%test_module \"sparse-ledger-test\" =","counters":[]},{"line":"  ( module struct","counters":[]},{"line":"    module Hash = struct","counters":[]},{"line":"      type t = Core_kernel.Md5.t [@@deriving sexp, compare]","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"      let equal h1 h2 = Int.equal (compare h1 h2) 0","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"","counters":[]},{"line":"      let to_yojson md5 = `String (Core_kernel.Md5.to_hex md5)","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"","counters":[]},{"line":"      let of_yojson = function","counters":[]},{"line":"        | `String x ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Or_error.try_with (fun () -> Core_kernel.Md5.of_hex_exn x)","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"            |> Result.map_error ~f:Error.to_string_hum","counters":[]},{"line":"        | _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Error \"Expected a hex-encoded MD5 hash\"","counters":[]},{"line":"","counters":[]},{"line":"      let merge ~height x y =","counters":[]},{"line":"        let open Md5 in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        digest_string","counters":[]},{"line":"          (sprintf \"sparse-ledger_%03d\" height ^ to_binary x ^ to_binary y)","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":57,"col_end":57,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"","counters":[]},{"line":"      let gen =","counters":[]},{"line":"        Quickcheck.Generator.map String.quickcheck_generator","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"          ~f:Md5.digest_string","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Account = struct","counters":[]},{"line":"      module T = struct","counters":[]},{"line":"        type t = { name : string; favorite_number : int }","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":48,"col_end":48,"count":0},{"col_start":52,"col_end":52,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"        [@@deriving bin_io, equal, sexp, yojson]","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      include T","counters":[]},{"line":"","counters":[]},{"line":"      let key { name; _ } = name","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"","counters":[]},{"line":"      let data_hash t = Md5.digest_string (Binable.to_string (module T) t)","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"","counters":[]},{"line":"      let gen =","counters":[]},{"line":"        let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"        let%map name = String.quickcheck_generator","counters":[]},{"line":"        and favorite_number = Int.quickcheck_generator in","counters":[]},{"line":"        { name; favorite_number }","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Account_id = struct","counters":[]},{"line":"      type t = string [@@deriving sexp, equal, yojson]","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    include Make (Hash) (Account_id) (Account)","counters":[]},{"line":"","counters":[]},{"line":"    let gen =","counters":[]},{"line":"      let open Quickcheck.Generator in","counters":[]},{"line":"      let open Let_syntax in","counters":[]},{"line":"      let indexes max_depth t =","counters":[]},{"line":"        let rec go addr d = function","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          | Tree.Account a ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              [ (Account.key a, addr) ]","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"          | Hash _ ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              []","counters":[]},{"line":"          | Node (_, l, r) ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              go addr (d - 1) l @ go (addr lor (1 lsl d)) (d - 1) r","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"        in","counters":[]},{"line":"        go 0 (max_depth - 1) t","counters":[]},{"line":"      in","counters":[]},{"line":"      let rec prune_hash_branches = function","counters":[]},{"line":"        | Tree.Hash h ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Tree.Hash h","counters":[]},{"line":"        | Account a ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Account a","counters":[]},{"line":"        | Node (h, l, r) -> (","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            match (prune_hash_branches l, prune_hash_branches r) with","counters":[{"col_start":37,"col_end":37,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"            | Hash _, Hash _ ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Hash h","counters":[]},{"line":"            | l, r ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Node (h, l, r) )","counters":[]},{"line":"      in","counters":[]},{"line":"      let rec gen depth =","counters":[]},{"line":"        if depth = 0 then Account.gen >>| fun a -> Tree.Account a","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"        else","counters":[]},{"line":"          let t =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let sub = gen (depth - 1) in","counters":[]},{"line":"            let%map l = sub and r = sub in","counters":[]},{"line":"            Tree.Node (Hash.merge ~height:(depth - 1) (hash l) (hash r), l, r)","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":58,"col_end":58,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"          in","counters":[]},{"line":"          weighted_union","counters":[]},{"line":"            [ (1. /. 3., Hash.gen >>| fun h -> Tree.Hash h); (2. /. 3., t) ]","counters":[{"col_start":36,"col_end":36,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"      in","counters":[]},{"line":"      let%bind depth = Int.gen_incl 0 16 in","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"      let%map tree = gen depth >>| prune_hash_branches in","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"      { T.tree; depth; indexes = indexes depth tree }","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"iteri consistent indices with t.indexes\" =","counters":[]},{"line":"      Quickcheck.test gen ~f:(fun t ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          let indexes = Int.Set.of_list (t.indexes |> List.map ~f:snd) in","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"          iteri t ~f:(fun i _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              [%test_result: bool]","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"                ~message:","counters":[]},{"line":"                  \"Iteri index should be contained in the indexes auxillary \\","counters":[]},{"line":"                   structure\"","counters":[]},{"line":"                ~expect:true (Int.Set.mem indexes i) ) )","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"path_test\" =","counters":[]},{"line":"      Quickcheck.test gen ~f:(fun t ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          let root = { t with indexes = []; tree = Hash (merkle_root t) } in","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"          let t' =","counters":[]},{"line":"            List.fold t.indexes ~init:root ~f:(fun acc (_, index) ->","counters":[]},{"line":"                let account = get_exn t index in","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                add_path acc (path_exn t index) (Account.key account) account )","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"          in","counters":[]},{"line":"          assert (Tree.equal Hash.equal Account.equal t'.tree t.tree) )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"  end )","counters":[{"col_start":6,"col_end":6,"count":2}]}]}