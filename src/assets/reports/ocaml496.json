{"filename":"src/lib/merkle_mask/maskable_merkle_tree_intf.ml","lines":[{"line":"(* maskable_merkle_tree_intf.ml *)","counters":[]},{"line":"","counters":[]},{"line":"(** the type of a Merkle tree that can have associated mask children *)","counters":[{"col_start":71,"col_end":71,"count":1}]},{"line":"module type S = sig","counters":[]},{"line":"  include Base_merkle_tree_intf.S","counters":[]},{"line":"","counters":[]},{"line":"  type unattached_mask","counters":[]},{"line":"","counters":[]},{"line":"  type attached_mask","counters":[]},{"line":"","counters":[]},{"line":"  (* registering a mask makes it an active child of the parent Merkle tree","counters":[]},{"line":"     - reads to the mask that fail are delegated to the parent","counters":[]},{"line":"     - writes to the parent notify the child mask","counters":[]},{"line":"  *)","counters":[]},{"line":"","counters":[]},{"line":"  (* val register_mask : t -> t -> t *)","counters":[]},{"line":"","counters":[]},{"line":"  val register_mask : t -> unattached_mask -> attached_mask","counters":[]},{"line":"","counters":[]},{"line":"  (** raises an exception if mask is not registered *)","counters":[]},{"line":"  val unregister_mask_exn :","counters":[]},{"line":"       ?grandchildren:","counters":[]},{"line":"         [ `Check | `Recursive | `I_promise_I_am_reparenting_this_mask ]","counters":[]},{"line":"    -> loc:string","counters":[]},{"line":"    -> attached_mask","counters":[]},{"line":"    -> unattached_mask","counters":[]},{"line":"","counters":[]},{"line":"  (**","counters":[]},{"line":"   *              o","counters":[]},{"line":"   *             /","counters":[]},{"line":"   *            /","counters":[]},{"line":"   *   o --- o -","counters":[]},{"line":"   *   ^     ^  \\","counters":[]},{"line":"   *  parent |   \\","counters":[]},{"line":"   *        mask  o","counters":[]},{"line":"   *            children","counters":[]},{"line":"   *","counters":[]},{"line":"   * Removes the attached mask from its parent and attaches the children to the","counters":[]},{"line":"   * parent instead. Raises an exception if the merkle roots of the mask and the","counters":[]},{"line":"   * parent are not the same.","counters":[]},{"line":"  *)","counters":[]},{"line":"  val remove_and_reparent_exn : t -> attached_mask -> unit","counters":[]},{"line":"","counters":[]},{"line":"  (* module Debug : sig *)","counters":[]},{"line":"  (*   val visualize : filename:string -> unit *)","counters":[]},{"line":"  (* end *)","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}