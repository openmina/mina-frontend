{"filename":"src/lib/verifier/verifier.ml","lines":[{"line":"module Failure = Verification_failure","counters":[]},{"line":"module Prod = Prod","counters":[]},{"line":"module Dummy = Dummy","counters":[]},{"line":"","counters":[]},{"line":"let m =","counters":[]},{"line":"  if Base__Import.am_testing then","counters":[]},{"line":"    (* Spawning a process using [Rpc_parallel] calls the current binary with a","counters":[]},{"line":"       particular set of arguments. Unfortunately, unit tests use the inline","counters":[]},{"line":"       test binary -- which doesn't support these arguments -- and so we're not","counters":[]},{"line":"       able to use these [Rpc_parallel] calls. Here we detect this and call out","counters":[]},{"line":"       to the dummy verifier instead.","counters":[]},{"line":"       The implementation of dummy is equivalent to the one with","counters":[]},{"line":"       [proof_level <> Full], so this should make no difference. Inline tests","counters":[]},{"line":"       shouldn't be run with [proof_level = Full].","counters":[]},{"line":"    *)","counters":[]},{"line":"    (module Dummy : Verifier_intf.S with type ledger_proof = Ledger_proof.t)","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  else (module Prod)","counters":[{"col_start":7,"col_end":7,"count":1}]},{"line":"","counters":[]},{"line":"include (val m)","counters":[]}]}