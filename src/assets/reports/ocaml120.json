{"filename":"src/lib/user_command_input/user_command_input.ml","lines":[{"line":"open Mina_base","counters":[]},{"line":"open Signature_lib","counters":[]},{"line":"open Mina_numbers","counters":[]},{"line":"open Core_kernel","counters":[]},{"line":"open Async_kernel","counters":[]},{"line":"","counters":[]},{"line":"module Payload = struct","counters":[]},{"line":"  module Common = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V2 = struct","counters":[]},{"line":"        type t =","counters":[{"col_start":8,"col_end":8,"count":2},{"col_start":13,"col_end":13,"count":1}]},{"line":"          ( Currency.Fee.Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":12,"col_end":12,"count":0}]},{"line":"          , Public_key.Compressed.Stable.V1.t","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          , Account_nonce.Stable.V1.t option","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          , Global_slot.Stable.V1.t","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          , Signed_command_memo.Stable.V1.t )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          Signed_command_payload.Common.Poly.Stable.V2.t","counters":[]},{"line":"        [@@deriving sexp, to_yojson]","counters":[{"col_start":35,"col_end":35,"count":5}]},{"line":"","counters":[]},{"line":"        let to_latest = Fn.id","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    let create ~fee ~fee_payer_pk ?nonce ~valid_until ~memo : t =","counters":[]},{"line":"      { fee; fee_payer_pk; nonce; valid_until; memo }","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let to_user_command_common (t : t) ~minimum_nonce ~inferred_nonce :","counters":[]},{"line":"        (Signed_command_payload.Common.t, string) Result.t =","counters":[]},{"line":"      let open Result.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%map nonce =","counters":[]},{"line":"        match t.nonce with","counters":[]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (*User did not provide a nonce, use inferred*)","counters":[]},{"line":"            Ok inferred_nonce","counters":[]},{"line":"        | Some nonce ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (* NB: A lower, explicitly given nonce can be used to cancel","counters":[]},{"line":"               transactions or to re-issue them with a higher fee.","counters":[]},{"line":"            *)","counters":[]},{"line":"            if Account_nonce.(minimum_nonce <= nonce && nonce <= inferred_nonce)","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"            then Ok nonce","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"            else","counters":[]},{"line":"              (* IMPORTANT! Do not change the content of this error without","counters":[]},{"line":"               * updating Rosetta's construction API to handle the changes *)","counters":[]},{"line":"              Error","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (sprintf","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                   !\"Input nonce %s either different from inferred nonce %s or \\","counters":[]},{"line":"                     below minimum_nonce %s\"","counters":[]},{"line":"                   (Account_nonce.to_string nonce)","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"                   (Account_nonce.to_string inferred_nonce)","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"                   (Account_nonce.to_string minimum_nonce) )","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"      in","counters":[]},{"line":"      { Signed_command_payload.Common.Poly.fee = t.fee","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      ; fee_payer_pk = t.fee_payer_pk","counters":[]},{"line":"      ; nonce","counters":[]},{"line":"      ; valid_until = t.valid_until","counters":[]},{"line":"      ; memo = t.memo","counters":[]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    let fee_payer ({ fee_payer_pk; _ } : t) =","counters":[]},{"line":"      Account_id.create fee_payer_pk Mina_base.Token_id.default","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V2 = struct","counters":[]},{"line":"      type t =","counters":[{"col_start":6,"col_end":6,"count":2},{"col_start":11,"col_end":11,"count":1}]},{"line":"        ( Common.Stable.V2.t","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":10,"col_end":10,"count":0}]},{"line":"        , Signed_command_payload.Body.Stable.V2.t )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        Signed_command_payload.Poly.Stable.V1.t","counters":[]},{"line":"      [@@deriving sexp, to_yojson]","counters":[{"col_start":33,"col_end":33,"count":5}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  let create ~fee ~fee_payer_pk ?nonce ~valid_until ~memo ~body : t =","counters":[]},{"line":"    { common = Common.create ~fee ~fee_payer_pk ?nonce ~valid_until ~memo","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    ; body","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let to_user_command_payload (t : t) ~minimum_nonce ~inferred_nonce :","counters":[]},{"line":"      (Signed_command_payload.t, string) Result.t =","counters":[]},{"line":"    let open Result.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let%map common =","counters":[]},{"line":"      Common.to_user_command_common t.common ~minimum_nonce ~inferred_nonce","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"    in","counters":[]},{"line":"    { Signed_command_payload.Poly.common; body = t.body }","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let fee_payer ({ common; _ } : t) = Common.fee_payer common","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Sign_choice = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type t =","counters":[{"col_start":6,"col_end":6,"count":2},{"col_start":11,"col_end":11,"count":2}]},{"line":"        | Signature of Signature.Stable.V1.t","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"        | Hd_index of Unsigned_extended.UInt32.Stable.V1.t","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"        | Keypair of Keypair.Stable.V1.t","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"      [@@deriving sexp, to_yojson]","counters":[{"col_start":33,"col_end":33,"count":5}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"[%%versioned","counters":[]},{"line":"module Stable = struct","counters":[]},{"line":"  module V2 = struct","counters":[]},{"line":"    type t =","counters":[{"col_start":4,"col_end":4,"count":2},{"col_start":9,"col_end":9,"count":1}]},{"line":"      ( Payload.Stable.V2.t","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":8,"col_end":8,"count":0}]},{"line":"      , Public_key.Compressed.Stable.V1.t","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      , Sign_choice.Stable.V1.t )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      Signed_command.Poly.Stable.V1.t","counters":[]},{"line":"    [@@deriving sexp, to_yojson]","counters":[{"col_start":31,"col_end":31,"count":5}]},{"line":"","counters":[]},{"line":"    let to_latest = Fn.id","counters":[]},{"line":"  end","counters":[]},{"line":"end]","counters":[]},{"line":"","counters":[]},{"line":"[%%define_locally Stable.Latest.(to_yojson)]","counters":[]},{"line":"","counters":[]},{"line":"let fee_payer ({ payload; _ } : t) = Payload.fee_payer payload","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"let create ?nonce ~fee ~fee_payer_pk ~valid_until ~memo ~body ~signer","counters":[]},{"line":"    ~sign_choice () : t =","counters":[]},{"line":"  let valid_until = Option.value valid_until ~default:Global_slot.max_value in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let payload =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Payload.create ~fee ~fee_payer_pk ?nonce ~valid_until ~memo ~body","counters":[]},{"line":"  in","counters":[]},{"line":"  { payload; signer; signature = sign_choice }","counters":[]},{"line":"","counters":[]},{"line":"let sign ~signer ~(user_command_payload : Signed_command_payload.t) = function","counters":[]},{"line":"  | Sign_choice.Signature signature ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Option.value_map","counters":[]},{"line":"        ~default:(Deferred.return (Error \"Invalid_signature\"))","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"        (Signed_command.create_with_signature_checked signature signer","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"           user_command_payload )","counters":[]},{"line":"        ~f:Deferred.Result.return","counters":[]},{"line":"  | Keypair signer_kp ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Deferred.Result.return","counters":[]},{"line":"        (Signed_command.sign signer_kp user_command_payload)","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"  | Hd_index hd_index ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Secrets.Hardware_wallets.sign ~hd_index","counters":[]},{"line":"        ~public_key:(Public_key.decompress_exn signer)","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"        ~user_command_payload","counters":[]},{"line":"","counters":[]},{"line":"let inferred_nonce ~get_current_nonce ~(fee_payer : Account_id.t) ~nonce_map =","counters":[]},{"line":"  let open Result.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let update_map = Map.set nonce_map ~key:fee_payer in","counters":[]},{"line":"  match Map.find nonce_map fee_payer with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | Some (min_nonce, nonce) ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (* Multiple user commands from the same fee-payer. *)","counters":[]},{"line":"      (* TODO: this logic does not currently support zkapp_command transactions, as zkapp_command transactions can increment the fee payer nonce more than once (#11001) *)","counters":[]},{"line":"      let next_nonce = Account_nonce.succ nonce in","counters":[]},{"line":"      let updated_map = update_map ~data:(min_nonce, next_nonce) in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Ok (min_nonce, next_nonce, updated_map)","counters":[]},{"line":"  | None ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let%map `Min min_nonce, txn_pool_or_account_nonce =","counters":[]},{"line":"        get_current_nonce fee_payer","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"      in","counters":[]},{"line":"      let updated_map =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        update_map ~data:(min_nonce, txn_pool_or_account_nonce)","counters":[]},{"line":"      in","counters":[]},{"line":"      (min_nonce, txn_pool_or_account_nonce, updated_map)","counters":[]},{"line":"","counters":[]},{"line":"(* If the receiver account doesn't exist yet (as far as we can tell) *and* the","counters":[]},{"line":" * user command isn't sufficient to cover the account creation fee, log a","counters":[]},{"line":" * warning. *)","counters":[]},{"line":"let warn_if_unable_to_pay_account_creation_fee ~get_account","counters":[]},{"line":"    ~(constraint_constants : Genesis_constants.Constraint_constants.t) ~logger","counters":[]},{"line":"    user_command_payload =","counters":[]},{"line":"  let receiver_pk = Signed_command_payload.receiver_pk user_command_payload in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let token = Signed_command_payload.token user_command_payload in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let receiver = Account_id.create receiver_pk token in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let receiver_account = get_account receiver in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let amount = Signed_command_payload.amount user_command_payload in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  match (receiver_account, amount) with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | `Bootstrapping, _ | `Active (Some _), _ | _, None ->","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"      ()","counters":[]},{"line":"  | `Active None, Some amount ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let open Currency.Amount in","counters":[]},{"line":"      let account_creation_fee =","counters":[]},{"line":"        of_fee constraint_constants.account_creation_fee","counters":[]},{"line":"      in","counters":[]},{"line":"      if amount < account_creation_fee then","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [%log warn]","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"          \"A transaction was submitted that is likely to fail because the \\","counters":[]},{"line":"           receiver account doesn't appear to have been created already and \\","counters":[]},{"line":"           the transaction amount of %s is smaller than the account creation \\","counters":[]},{"line":"           fee of %s.\"","counters":[]},{"line":"          (to_formatted_string amount)","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"          (to_formatted_string account_creation_fee) ;","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"      ()","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"let to_user_command ?(nonce_map = Account_id.Map.empty) ~get_current_nonce","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"    ~get_account ~constraint_constants ~logger (client_input : t) =","counters":[]},{"line":"  Deferred.map","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    ~f:","counters":[]},{"line":"      (Result.map_error ~f:(fun str ->","counters":[]},{"line":"           Error.createf \"Error creating user command: %s Error: %s\"","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"             (Yojson.Safe.to_string (to_yojson client_input))","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"             str ) )","counters":[]},{"line":"  @@","counters":[]},{"line":"  let open Deferred.Result.Let_syntax in","counters":[]},{"line":"  let fee_payer = fee_payer client_input in","counters":[]},{"line":"  let%bind minimum_nonce, inferred_nonce, updated_nonce_map =","counters":[]},{"line":"    inferred_nonce ~get_current_nonce ~fee_payer ~nonce_map |> Deferred.return","counters":[{"col_start":77,"col_end":77,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%bind user_command_payload =","counters":[]},{"line":"    Payload.to_user_command_payload client_input.payload ~minimum_nonce","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"      ~inferred_nonce","counters":[]},{"line":"    |> Deferred.return","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"  in","counters":[]},{"line":"  let () =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    warn_if_unable_to_pay_account_creation_fee ~get_account","counters":[]},{"line":"      ~constraint_constants ~logger user_command_payload","counters":[]},{"line":"  in","counters":[]},{"line":"  let%map signed_user_command =","counters":[]},{"line":"    sign ~signer:client_input.signer ~user_command_payload","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"      client_input.signature","counters":[]},{"line":"  in","counters":[]},{"line":"  (Signed_command.forget_check signed_user_command, updated_nonce_map)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"let to_user_commands ?(nonce_map = Account_id.Map.empty) ~get_current_nonce","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"    ~get_account ~constraint_constants ~logger uc_inputs :","counters":[]},{"line":"    Signed_command.t list Deferred.Or_error.t =","counters":[]},{"line":"  (* When batching multiple user commands, keep track of the nonces and send","counters":[]},{"line":"      all the user commands if they are valid or none if there is an error in","counters":[]},{"line":"      one of them.","counters":[]},{"line":"  *)","counters":[]},{"line":"  let open Deferred.Or_error.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%map user_commands, _ =","counters":[]},{"line":"    Deferred.Or_error.List.fold ~init:([], nonce_map) uc_inputs","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"      ~f:(fun (valid_user_commands, nonce_map) uc_input ->","counters":[]},{"line":"        let%map res, updated_nonce_map =","counters":[]},{"line":"          to_user_command ~nonce_map ~get_current_nonce ~get_account","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"            ~constraint_constants ~logger uc_input","counters":[]},{"line":"        in","counters":[]},{"line":"        (res :: valid_user_commands, updated_nonce_map) )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"  in","counters":[]},{"line":"  List.rev user_commands","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":23,"col_end":23,"count":2}]}]}