{"filename":"src/lib/merkle_ledger/database.ml","lines":[{"line":"open Core","counters":[]},{"line":"","counters":[]},{"line":"module type Inputs_intf = sig","counters":[]},{"line":"  include Base_inputs_intf.S","counters":[]},{"line":"","counters":[]},{"line":"  module Location : Location_intf.S","counters":[]},{"line":"","counters":[]},{"line":"  module Location_binable : Hashable.S_binable with type t := Location.t","counters":[]},{"line":"","counters":[]},{"line":"  module Kvdb : Intf.Key_value_database with type config := string","counters":[]},{"line":"","counters":[]},{"line":"  module Storage_locations : Intf.Storage_locations","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Rust = Mina_tree.Rust","counters":[]},{"line":"","counters":[]},{"line":"module Make (Inputs : Inputs_intf) :","counters":[]},{"line":"  Database_intf.S","counters":[]},{"line":"    with module Location = Inputs.Location","counters":[]},{"line":"     and module Addr = Inputs.Location.Addr","counters":[]},{"line":"     and type key := Inputs.Key.t","counters":[]},{"line":"     and type token_id := Inputs.Token_id.t","counters":[]},{"line":"     and type token_id_set := Inputs.Token_id.Set.t","counters":[]},{"line":"     and type account := Inputs.Account.t","counters":[]},{"line":"     and type root_hash := Inputs.Hash.t","counters":[]},{"line":"     and type hash := Inputs.Hash.t","counters":[]},{"line":"     and type account_id := Inputs.Account_id.t","counters":[]},{"line":"     and type account_id_set := Inputs.Account_id.Set.t = struct","counters":[]},{"line":"  (* The max depth of a merkle tree can never be greater than 253. *)","counters":[]},{"line":"  open Inputs","counters":[]},{"line":"","counters":[]},{"line":"  (* module Db_error = struct *)","counters":[]},{"line":"  (*   type t = Account_location_not_found | Out_of_leaves | Malformed_database *)","counters":[]},{"line":"  (*   [@@deriving sexp] *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   exception Db_exception of t *)","counters":[]},{"line":"  (* end *)","counters":[]},{"line":"","counters":[]},{"line":"  module Path = Merkle_path.Make (Hash)","counters":[]},{"line":"  module Addr = Location.Addr","counters":[]},{"line":"  module Location = Location","counters":[]},{"line":"  module Key = Key","counters":[]},{"line":"","counters":[]},{"line":"  type location = Location.t [@@deriving sexp]","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"  type index = int","counters":[]},{"line":"","counters":[]},{"line":"  type path = Path.t","counters":[]},{"line":"","counters":[]},{"line":"  module Detached_parent_signal = struct","counters":[]},{"line":"    type t = unit Async.Ivar.t","counters":[]},{"line":"","counters":[]},{"line":"    let sexp_of_t (_ : t) = Sexp.List []","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"","counters":[]},{"line":"    let t_of_sexp (_ : Sexp.t) : t = Async.Ivar.create ()","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"    let _use_unused t =","counters":[]},{"line":"      let _a = sexp_of_t t in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let _b = t_of_sexp (Sexp.List []) in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      ()","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  type t = Mina_tree.database","counters":[]},{"line":"","counters":[]},{"line":"  let sexp_of_t (_ : t) = Sexp.List []","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"","counters":[]},{"line":"  let t_of_sexp (_ : Sexp.t) : t = failwith \"t_of_sexp: not implemented\"","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"  let _use_unused t =","counters":[]},{"line":"    let _a = sexp_of_t t in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let _b = t_of_sexp (Sexp.List []) in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    ()","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let hash_from_rust hash =","counters":[]},{"line":"    hash |> Bigstring.of_bytes |> Hash.bin_read_t ~pos_ref:(ref 0)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"  let path_from_rust path =","counters":[]},{"line":"    match path with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | `Left hash ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        `Left (hash_from_rust hash)","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"    | `Right hash ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        `Right (hash_from_rust hash)","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"  let location_to_rust location =","counters":[]},{"line":"    (* let s = *)","counters":[]},{"line":"    (*   match location with *)","counters":[]},{"line":"    (*   | Location.Generic bigs -> *)","counters":[]},{"line":"    (*       \"Generic \" ^ Bigstring.to_string bigs *)","counters":[]},{"line":"    (*   | Location.Account addr -> *)","counters":[]},{"line":"    (*       \"Account \" ^ Addr.to_string addr *)","counters":[]},{"line":"    (*   | Location.Hash addr -> *)","counters":[]},{"line":"    (*       \"Hash \" ^ Addr.to_string addr *)","counters":[]},{"line":"    (* in *)","counters":[]},{"line":"    (* Printf.eprintf \"%s\\n%!\" s ; *)","counters":[]},{"line":"    Location.to_path_exn location |> Addr.to_string","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"  let account_location_from_rust addr = Location.Account (Addr.of_string addr)","counters":[{"col_start":40,"col_end":40,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"","counters":[]},{"line":"  let account_from_rust account =","counters":[]},{"line":"    Account.bin_read_t (Bigstring.of_bytes account) ~pos_ref:(ref 0)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"","counters":[]},{"line":"  let account_to_rust account =","counters":[]},{"line":"    let buf = Bigstring.create (Account.bin_size_t account) in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"    ignore (Account.bin_write_t buf ~pos:0 account : int) ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"    Bigstring.to_bytes buf","counters":[]},{"line":"","counters":[]},{"line":"  let account_id_from_rust account_id =","counters":[]},{"line":"    Account_id.Stable.Latest.bin_read_t","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (Bigstring.of_bytes account_id)","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"      ~pos_ref:(ref 0)","counters":[]},{"line":"","counters":[]},{"line":"  let account_id_to_rust account_id =","counters":[]},{"line":"    let buf =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Bigstring.create (Account_id.Stable.Latest.bin_size_t account_id)","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"    in","counters":[]},{"line":"    ignore (Account_id.Stable.Latest.bin_write_t buf ~pos:0 account_id : int) ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"    Bigstring.to_bytes buf","counters":[]},{"line":"","counters":[]},{"line":"  let token_id_from_rust token_id =","counters":[]},{"line":"    Token_id.Stable.Latest.bin_read_t","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (Bigstring.of_bytes token_id)","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"      ~pos_ref:(ref 0)","counters":[]},{"line":"","counters":[]},{"line":"  let token_id_to_rust token_id =","counters":[]},{"line":"    let buf = Bigstring.create (Token_id.Stable.Latest.bin_size_t token_id) in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"    ignore (Token_id.Stable.Latest.bin_write_t buf ~pos:0 token_id : int) ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"    Bigstring.to_bytes buf","counters":[]},{"line":"","counters":[]},{"line":"  let pubkey_to_rust pubkey =","counters":[]},{"line":"    let buf = Bigstring.create (Key.Stable.Latest.bin_size_t pubkey) in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"    ignore (Key.Stable.Latest.bin_write_t buf ~pos:0 pubkey : int) ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"    Bigstring.to_bytes buf","counters":[]},{"line":"","counters":[]},{"line":"  (* type t = *)","counters":[]},{"line":"  (*   { uuid : Uuid.Stable.V1.t *)","counters":[]},{"line":"  (*   ; kvdb : Kvdb.t [@sexp.opaque] *)","counters":[]},{"line":"  (*   ; depth : int *)","counters":[]},{"line":"  (*   ; directory : string *)","counters":[]},{"line":"  (*   ; detached_parent_signal : Detached_parent_signal.t *)","counters":[]},{"line":"  (*   } *)","counters":[]},{"line":"  (* [@@deriving sexp] *)","counters":[]},{"line":"","counters":[]},{"line":"  (* let get_uuid t = t.uuid *)","counters":[]},{"line":"  let get_uuid t = Rust.database_get_uuid t |> Uuid.of_string","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"  let get_directory t = Rust.database_get_directory t","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"","counters":[]},{"line":"  (* let get_directory _t = None *)","counters":[]},{"line":"  (* TODO *)","counters":[]},{"line":"  (* let get_directory t = Some t.directory *)","counters":[]},{"line":"","counters":[]},{"line":"  let depth t = Rust.database_depth t","counters":[{"col_start":16,"col_end":16,"count":2}]},{"line":"","counters":[]},{"line":"  let create ?directory_name ~depth () =","counters":[]},{"line":"    (*Printf.eprintf \"MY_LOG.MERKLE_LEDGER.DATABASE.CREATE\\n%!\" ;*)","counters":[]},{"line":"    let rust_db = Rust.database_create depth directory_name in","counters":[{"col_start":4,"col_end":4,"count":2}]},{"line":"    rust_db","counters":[{"col_start":4,"col_end":4,"count":2}]},{"line":"  (* assert (depth < 0xfe) ; *)","counters":[]},{"line":"  (* let uuid = Uuid_unix.create () in *)","counters":[]},{"line":"  (* let directory = *)","counters":[]},{"line":"  (*   match directory_name with *)","counters":[]},{"line":"  (*   | None -> *)","counters":[]},{"line":"  (*       (\\* Create in the autogen path, where we know we have write *)","counters":[]},{"line":"  (*          permissions. *)","counters":[]},{"line":"  (*       *\\) *)","counters":[]},{"line":"  (*       Cache_dir.autogen_path ^/ Uuid.to_string uuid *)","counters":[]},{"line":"  (*   | Some name -> *)","counters":[]},{"line":"  (*       name *)","counters":[]},{"line":"  (* in *)","counters":[]},{"line":"  (* Unix.mkdir_p directory ; *)","counters":[]},{"line":"  (* let kvdb = Kvdb.create directory in *)","counters":[]},{"line":"  (* { uuid *)","counters":[]},{"line":"  (* ; kvdb *)","counters":[]},{"line":"  (* ; depth *)","counters":[]},{"line":"  (* ; directory *)","counters":[]},{"line":"  (* ; detached_parent_signal = Async.Ivar.create () *)","counters":[]},{"line":"  (* } *)","counters":[]},{"line":"","counters":[]},{"line":"  let create_checkpoint t ~directory_name () =","counters":[]},{"line":"    (*Printf.eprintf \"MY_LOG.MERKLE_LEDGER.DATABASE.CREATE_CHECKPOINT\\n%!\" ;*)","counters":[]},{"line":"    let _ = directory_name in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Rust.database_create_checkpoint t directory_name","counters":[]},{"line":"  (* let uuid = Uuid_unix.create () in *)","counters":[]},{"line":"  (* let kvdb = Kvdb.create_checkpoint t.kvdb directory_name in *)","counters":[]},{"line":"  (* { uuid *)","counters":[]},{"line":"  (* ; kvdb *)","counters":[]},{"line":"  (* ; depth = t.depth *)","counters":[]},{"line":"  (* ; directory = directory_name *)","counters":[]},{"line":"  (* ; detached_parent_signal = Async.Ivar.create () *)","counters":[]},{"line":"  (* } *)","counters":[]},{"line":"","counters":[]},{"line":"  let make_checkpoint t ~directory_name =","counters":[]},{"line":"    (*Printf.eprintf \"MY_LOG.MERKLE_LEDGER.DATABASE.MAKE_CHECKPOINT\\n%!\" ;*)","counters":[]},{"line":"    let _ = directory_name in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Rust.database_make_checkpoint t directory_name","counters":[]},{"line":"  (* Kvdb.make_checkpoint t.kvdb directory_name *)","counters":[]},{"line":"","counters":[]},{"line":"  let close t = Rust.database_close t","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"","counters":[]},{"line":"  (* let close { kvdb; uuid = _; depth = _; directory = _; detached_parent_signal } *)","counters":[]},{"line":"  (*     = *)","counters":[]},{"line":"  (*   Kvdb.close kvdb ; *)","counters":[]},{"line":"  (*   Async.Ivar.fill_if_empty detached_parent_signal () *)","counters":[]},{"line":"","counters":[]},{"line":"  let detached_signal _t = failwith \"detached_signal: not implemented\"","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"  (* Rust.database_close t *)","counters":[]},{"line":"","counters":[]},{"line":"  (* TODO *)","counters":[]},{"line":"  (* Async.Ivar.read detached_parent_signal *)","counters":[]},{"line":"","counters":[]},{"line":"  let with_ledger ~depth ~f =","counters":[]},{"line":"    let t = create ~depth () in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    try","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let result = f t in","counters":[]},{"line":"      close t ; result","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":16,"col_end":16,"count":0}]},{"line":"    with exn -> close t ; raise exn","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"","counters":[]},{"line":"  (* let empty_hash = *)","counters":[]},{"line":"  (*   Empty_hashes.extensible_cache (module Hash) ~init_hash:Hash.empty_account *)","counters":[]},{"line":"","counters":[]},{"line":"  (* let get_raw { kvdb; depth; _ } location = *)","counters":[]},{"line":"  (*   Kvdb.get kvdb ~key:(Location.serialize ~ledger_depth:depth location) *)","counters":[]},{"line":"","counters":[]},{"line":"  (* let get_raw_batch { kvdb; depth; _ } locations = *)","counters":[]},{"line":"  (*   let keys = List.map locations ~f:(Location.serialize ~ledger_depth:depth) in *)","counters":[]},{"line":"  (*   Kvdb.get_batch kvdb ~keys *)","counters":[]},{"line":"","counters":[]},{"line":"  (* let get_bin mdb location bin_read = *)","counters":[]},{"line":"  (*   get_raw mdb location |> Option.map ~f:(fun v -> bin_read v ~pos_ref:(ref 0)) *)","counters":[]},{"line":"","counters":[]},{"line":"  (* let get_bin_batch mdb locations bin_read = *)","counters":[]},{"line":"  (*   get_raw_batch mdb locations *)","counters":[]},{"line":"  (*   |> List.map ~f:(Option.map ~f:(fun v -> bin_read v ~pos_ref:(ref 0))) *)","counters":[]},{"line":"","counters":[]},{"line":"  (* let delete_raw { kvdb; depth; _ } location = *)","counters":[]},{"line":"  (*   Kvdb.remove kvdb ~key:(Location.serialize ~ledger_depth:depth location) *)","counters":[]},{"line":"","counters":[]},{"line":"  let get mdb location =","counters":[]},{"line":"    (*Printf.eprintf \"MY_LOG.MERKLE_LEDGER.DATABASE.GET\\n%!\" ;*)","counters":[]},{"line":"    let addr = location_to_rust location in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    (* let addr = Location.to_path_exn location |> Addr.to_string in *)","counters":[]},{"line":"    Rust.database_get mdb addr |> Option.map ~f:account_from_rust","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":20,"col_end":20,"count":0}]},{"line":"","counters":[]},{"line":"  (* assert (Location.is_account location) ; *)","counters":[]},{"line":"  (* get_bin mdb location Account.bin_read_t *)","counters":[]},{"line":"","counters":[]},{"line":"  let get_batch mdb locations =","counters":[]},{"line":"    (*Printf.eprintf \"MY_LOG.MERKLE_LEDGER.DATABASE.GET_BATCH %d\\n%!\"","counters":[]},{"line":"      (List.length locations) ;*)","counters":[]},{"line":"    let addrs = List.map locations ~f:location_to_rust in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Rust.database_get_batch mdb addrs","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"    |> List.map ~f:(fun (addr, account) ->","counters":[]},{"line":"           ( account_location_from_rust addr","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"           , Option.map account ~f:account_from_rust ) )","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"  (* assert (List.for_all locations ~f:Location.is_account) ; *)","counters":[]},{"line":"  (* List.zip_exn locations (get_bin_batch mdb locations Account.bin_read_t) *)","counters":[]},{"line":"","counters":[]},{"line":"  (* let get_hash mdb location = *)","counters":[]},{"line":"  (*   assert (Location.is_hash location) ; *)","counters":[]},{"line":"  (*   match get_bin mdb location Hash.bin_read_t with *)","counters":[]},{"line":"  (*   | Some hash -> *)","counters":[]},{"line":"  (*       hash *)","counters":[]},{"line":"  (*   | None -> *)","counters":[]},{"line":"  (*       empty_hash (Location.height ~ledger_depth:mdb.depth location) *)","counters":[]},{"line":"","counters":[]},{"line":"  (* let account_list_bin { kvdb; _ } account_bin_read : Account.t list = *)","counters":[]},{"line":"  (*   let all_keys_values = Kvdb.to_alist kvdb in *)","counters":[]},{"line":"  (*   (\\* see comment at top of location.ml about encoding of locations *\\) *)","counters":[]},{"line":"  (*   let account_location_prefix = *)","counters":[]},{"line":"  (*     Location.Prefix.account |> Unsigned.UInt8.to_int *)","counters":[]},{"line":"  (*   in *)","counters":[]},{"line":"  (*   (\\* just want list of locations and accounts, ignoring other locations *\\) *)","counters":[]},{"line":"  (*   let locations_accounts_bin = *)","counters":[]},{"line":"  (*     List.filter all_keys_values ~f:(fun (loc, _v) -> *)","counters":[]},{"line":"  (*         let ch = Bigstring.get_uint8 loc ~pos:0 in *)","counters":[]},{"line":"  (*         Int.equal ch account_location_prefix ) *)","counters":[]},{"line":"  (*   in *)","counters":[]},{"line":"  (*   List.map locations_accounts_bin ~f:(fun (_location_bin, account_bin) -> *)","counters":[]},{"line":"  (*       account_bin_read account_bin ~pos_ref:(ref 0) ) *)","counters":[]},{"line":"","counters":[]},{"line":"  let to_list mdb = Rust.database_get_list mdb |> List.map ~f:account_from_rust","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"","counters":[]},{"line":"  (* account_list_bin mdb Account.bin_read_t *)","counters":[]},{"line":"","counters":[]},{"line":"  let accounts mdb =","counters":[]},{"line":"    Rust.database_get_list mdb","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"    |> List.map ~f:account_id_from_rust","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"    |> Account_id.Set.of_list","counters":[]},{"line":"","counters":[]},{"line":"  (* to_list mdb |> List.map ~f:Account.identifier |> Account_id.Set.of_list *)","counters":[]},{"line":"","counters":[]},{"line":"  (* let set_raw { kvdb; depth; _ } location bin = *)","counters":[]},{"line":"  (*   Kvdb.set kvdb *)","counters":[]},{"line":"  (*     ~key:(Location.serialize ~ledger_depth:depth location) *)","counters":[]},{"line":"  (*     ~data:bin *)","counters":[]},{"line":"","counters":[]},{"line":"  (* let set_raw_batch { kvdb; depth; _ } locations_bins = *)","counters":[]},{"line":"  (*   let serialize_location (loc, bin) = *)","counters":[]},{"line":"  (*     (Location.serialize ~ledger_depth:depth loc, bin) *)","counters":[]},{"line":"  (*   in *)","counters":[]},{"line":"  (*   let serialized = List.map locations_bins ~f:serialize_location in *)","counters":[]},{"line":"  (*   Kvdb.set_batch kvdb ~key_data_pairs:serialized *)","counters":[]},{"line":"","counters":[]},{"line":"  (* let set_bin mdb location bin_size bin_write v = *)","counters":[]},{"line":"  (*   let buf = Bigstring.create (bin_size v) in *)","counters":[]},{"line":"  (*   ignore (bin_write buf ~pos:0 v : int) ; *)","counters":[]},{"line":"  (*   set_raw mdb location buf *)","counters":[]},{"line":"","counters":[]},{"line":"  (* let set_bin_batch mdb bin_size bin_write locations_vs = *)","counters":[]},{"line":"  (*   let create_buf (loc, v) = *)","counters":[]},{"line":"  (*     let buf = Bigstring.create (bin_size v) in *)","counters":[]},{"line":"  (*     ignore (bin_write buf ~pos:0 v : int) ; *)","counters":[]},{"line":"  (*     (loc, buf) *)","counters":[]},{"line":"  (*   in *)","counters":[]},{"line":"  (*   let locs_bufs = List.map locations_vs ~f:create_buf in *)","counters":[]},{"line":"  (*   set_raw_batch ~remove_keys:[] mdb locs_bufs *)","counters":[]},{"line":"","counters":[]},{"line":"  let get_inner_hash_at_addr_exn mdb address =","counters":[]},{"line":"    (* assert (Addr.depth address <= mdb.depth) ; *)","counters":[]},{"line":"    let hash =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Rust.database_get_inner_hash_at_addr mdb (Addr.to_string address)","counters":[{"col_start":41,"col_end":41,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"      |> hash_from_rust","counters":[]},{"line":"    in","counters":[]},{"line":"    (* Printf.eprintf \"GET_INNER_HASH=%s\\n%!\" *)","counters":[]},{"line":"    (*   (Snark_params.Tick.Field.to_string hash) ; *)","counters":[]},{"line":"    hash","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  (* |> Bigstring.of_bytes *)","counters":[]},{"line":"  (* |> Hash.bin_read_t ~pos_ref:(ref 0) *)","counters":[]},{"line":"","counters":[]},{"line":"  (* get_hash mdb (Location.Hash address) *)","counters":[]},{"line":"","counters":[]},{"line":"  let set_inner_hash_at_addr_exn mdb address hash =","counters":[]},{"line":"    let buf = Bigstring.create (Hash.bin_size_t hash) in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"    ignore (Hash.bin_write_t buf ~pos:0 hash : int) ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"    Rust.database_set_inner_hash_at_addr mdb (Addr.to_string address)","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"      (Bigstring.to_bytes buf)","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"","counters":[]},{"line":"  (* assert (Addr.depth address <= mdb.depth) ; *)","counters":[]},{"line":"  (* set_bin mdb (Location.Hash address) Hash.bin_size_t Hash.bin_write_t hash *)","counters":[]},{"line":"","counters":[]},{"line":"  let make_space_for _t _tot = ()","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"","counters":[]},{"line":"  (* let get_generic mdb location = *)","counters":[]},{"line":"  (*   assert (Location.is_generic location) ; *)","counters":[]},{"line":"  (*   get_raw mdb location *)","counters":[]},{"line":"","counters":[]},{"line":"  (* let get_generic_batch mdb locations = *)","counters":[]},{"line":"  (*   assert (List.for_all locations ~f:Location.is_generic) ; *)","counters":[]},{"line":"  (*   get_raw_batch mdb locations *)","counters":[]},{"line":"","counters":[]},{"line":"  (* module Account_location = struct *)","counters":[]},{"line":"  (*   (\\** encodes a key, token_id pair as a location used as a database key, so *)","counters":[]},{"line":"  (*       we can find the account location associated with that key. *)","counters":[]},{"line":"  (*   *\\) *)","counters":[]},{"line":"  (*   let build_location account_id = *)","counters":[]},{"line":"  (*     Location.build_generic *)","counters":[]},{"line":"  (*       (Bigstring.of_string *)","counters":[]},{"line":"  (*          ( \"$\" *)","counters":[]},{"line":"  (*          ^ Format.sprintf *)","counters":[]},{"line":"  (*              !\"%{sexp: Key.t}!%{sexp: Token_id.t}\" *)","counters":[]},{"line":"  (*              (Account_id.public_key account_id) *)","counters":[]},{"line":"  (*              (Account_id.token_id account_id) ) ) *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   let serialize_kv ~ledger_depth (aid, location) = *)","counters":[]},{"line":"  (*     ( Location.serialize ~ledger_depth @@ build_location aid *)","counters":[]},{"line":"  (*     , Location.serialize ~ledger_depth location ) *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   let get mdb key = *)","counters":[]},{"line":"  (*     match get_generic mdb (build_location key) with *)","counters":[]},{"line":"  (*     | None -> *)","counters":[]},{"line":"  (*         Error Db_error.Account_location_not_found *)","counters":[]},{"line":"  (*     | Some location_bin -> *)","counters":[]},{"line":"  (*         Location.parse ~ledger_depth:mdb.depth location_bin *)","counters":[]},{"line":"  (*         |> Result.map_error ~f:(fun () -> Db_error.Malformed_database) *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   let get_batch mdb keys = *)","counters":[]},{"line":"  (*     let parse_location bin = *)","counters":[]},{"line":"  (*       match Location.parse ~ledger_depth:mdb.depth bin with *)","counters":[]},{"line":"  (*       | Ok loc -> *)","counters":[]},{"line":"  (*           Some loc *)","counters":[]},{"line":"  (*       | Error () -> *)","counters":[]},{"line":"  (*           None *)","counters":[]},{"line":"  (*     in *)","counters":[]},{"line":"  (*     List.map keys ~f:build_location *)","counters":[]},{"line":"  (*     |> get_generic_batch mdb *)","counters":[]},{"line":"  (*     |> List.map ~f:(Option.bind ~f:parse_location) *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   let delete mdb key = delete_raw mdb (build_location key) *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   let set mdb key location = *)","counters":[]},{"line":"  (*     set_raw mdb (build_location key) *)","counters":[]},{"line":"  (*       (Location.serialize ~ledger_depth:mdb.depth location) *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   let set_batch_create ~ledger_depth keys_to_locations = *)","counters":[]},{"line":"  (*     List.map ~f:(serialize_kv ~ledger_depth) keys_to_locations *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   let _set_batch mdb keys_to_locations = *)","counters":[]},{"line":"  (*     Kvdb.set_batch mdb.kvdb *)","counters":[]},{"line":"  (*       ~key_data_pairs: *)","counters":[]},{"line":"  (*         (set_batch_create ~ledger_depth:mdb.depth keys_to_locations) *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   let last_location_key () = *)","counters":[]},{"line":"  (*     Location.build_generic (Bigstring.of_string \"last_account_location\") *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   let serialize_last_account_kv ~ledger_depth (location, last_account_location) *)","counters":[]},{"line":"  (*       = *)","counters":[]},{"line":"  (*     ( Location.serialize ~ledger_depth location *)","counters":[]},{"line":"  (*     , Location.serialize ~ledger_depth last_account_location ) *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   let increment_last_account_location mdb = *)","counters":[]},{"line":"  (*     let location = last_location_key () in *)","counters":[]},{"line":"  (*     let ledger_depth = mdb.depth in *)","counters":[]},{"line":"  (*     match get_generic mdb location with *)","counters":[]},{"line":"  (*     | None -> *)","counters":[]},{"line":"  (*         let first_location = *)","counters":[]},{"line":"  (*           Location.Account *)","counters":[]},{"line":"  (*             ( Addr.of_directions *)","counters":[]},{"line":"  (*             @@ List.init mdb.depth ~f:(fun _ -> Direction.Left) ) *)","counters":[]},{"line":"  (*         in *)","counters":[]},{"line":"  (*         set_raw mdb location (Location.serialize ~ledger_depth first_location) ; *)","counters":[]},{"line":"  (*         Result.return first_location *)","counters":[]},{"line":"  (*     | Some prev_location -> ( *)","counters":[]},{"line":"  (*         match Location.parse ~ledger_depth:mdb.depth prev_location with *)","counters":[]},{"line":"  (*         | Error () -> *)","counters":[]},{"line":"  (*             Error Db_error.Malformed_database *)","counters":[]},{"line":"  (*         | Ok prev_account_location -> *)","counters":[]},{"line":"  (*             Location.next prev_account_location *)","counters":[]},{"line":"  (*             |> Result.of_option ~error:Db_error.Out_of_leaves *)","counters":[]},{"line":"  (*             |> Result.map ~f:(fun next_account_location -> *)","counters":[]},{"line":"  (*                    set_raw mdb location *)","counters":[]},{"line":"  (*                      (Location.serialize ~ledger_depth next_account_location) ; *)","counters":[]},{"line":"  (*                    next_account_location ) ) *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   let allocate mdb key = *)","counters":[]},{"line":"  (*     let location_result = increment_last_account_location mdb in *)","counters":[]},{"line":"  (*     Result.map location_result ~f:(fun location -> *)","counters":[]},{"line":"  (*         set mdb key location ; location ) *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   let last_location_address mdb = *)","counters":[]},{"line":"  (*     match *)","counters":[]},{"line":"  (*       last_location_key () |> get_raw mdb |> Result.of_option ~error:() *)","counters":[]},{"line":"  (*       |> Result.bind ~f:(Location.parse ~ledger_depth:mdb.depth) *)","counters":[]},{"line":"  (*     with *)","counters":[]},{"line":"  (*     | Error () -> *)","counters":[]},{"line":"  (*         None *)","counters":[]},{"line":"  (*     | Ok parsed_location -> *)","counters":[]},{"line":"  (*         Some (Location.to_path_exn parsed_location) *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   let last_location mdb = *)","counters":[]},{"line":"  (*     match *)","counters":[]},{"line":"  (*       last_location_key () |> get_raw mdb |> Result.of_option ~error:() *)","counters":[]},{"line":"  (*       |> Result.bind ~f:(Location.parse ~ledger_depth:mdb.depth) *)","counters":[]},{"line":"  (*     with *)","counters":[]},{"line":"  (*     | Error () -> *)","counters":[]},{"line":"  (*         None *)","counters":[]},{"line":"  (*     | Ok parsed_location -> *)","counters":[]},{"line":"  (*         Some parsed_location *)","counters":[]},{"line":"  (* end *)","counters":[]},{"line":"","counters":[]},{"line":"  let get_at_index_exn mdb index =","counters":[]},{"line":"    Rust.database_get_at_index mdb index |> account_from_rust","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"  (* let addr = Addr.of_int_exn ~ledger_depth:mdb.depth index in *)","counters":[]},{"line":"  (* get mdb (Location.Account addr) |> Option.value_exn *)","counters":[]},{"line":"","counters":[]},{"line":"  (* let all_accounts (t : t) = *)","counters":[]},{"line":"  (*   match Account_location.last_location_address t with *)","counters":[]},{"line":"  (*   | None -> *)","counters":[]},{"line":"  (*       Sequence.empty *)","counters":[]},{"line":"  (*   | Some last_addr -> *)","counters":[]},{"line":"  (*       Sequence.range ~stop:`inclusive 0 (Addr.to_int last_addr) *)","counters":[]},{"line":"  (*       |> Sequence.map ~f:(fun i -> get_at_index_exn t i) *)","counters":[]},{"line":"","counters":[]},{"line":"  let iteri (t : t) ~(f : int -> Account.t -> unit) =","counters":[]},{"line":"    Rust.database_iter t (fun index bytes -> f index (account_from_rust bytes))","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":70,"col_end":70,"count":0}]},{"line":"  (* Sequence.iteri (all_accounts t) ~f *)","counters":[]},{"line":"","counters":[]},{"line":"  (** The tokens associated with each public key.","counters":[]},{"line":"","counters":[]},{"line":"      These are represented as a [Token_id.Set.t], which is represented by an","counters":[]},{"line":"      ordered list.","counters":[]},{"line":"  *)","counters":[]},{"line":"  (* module Tokens = struct *)","counters":[]},{"line":"  (*   module Owner = struct *)","counters":[]},{"line":"  (*     (\\* Map token IDs to the owning account *\\) *)","counters":[]},{"line":"","counters":[]},{"line":"  (*     let build_location token_id = *)","counters":[]},{"line":"  (*       Location.build_generic *)","counters":[]},{"line":"  (*         (Bigstring.of_string *)","counters":[]},{"line":"  (*            (Format.sprintf !\"$tid!%{sexp: Token_id.t}\" token_id) ) *)","counters":[]},{"line":"","counters":[]},{"line":"  (*     let serialize_kv ~ledger_depth ((tid : Token_id.t), (aid : Account_id.t)) *)","counters":[]},{"line":"  (*         = *)","counters":[]},{"line":"  (*       let aid_buf = *)","counters":[]},{"line":"  (*         Bin_prot.Common.create_buf (Account_id.Stable.Latest.bin_size_t aid) *)","counters":[]},{"line":"  (*       in *)","counters":[]},{"line":"  (*       ignore (Account_id.Stable.Latest.bin_write_t aid_buf ~pos:0 aid : int) ; *)","counters":[]},{"line":"  (*       (Location.serialize ~ledger_depth (build_location tid), aid_buf) *)","counters":[]},{"line":"","counters":[]},{"line":"  (*     let get (mdb : t) (token_id : Token_id.t) : Account_id.t option = *)","counters":[]},{"line":"  (*       get_bin mdb (build_location token_id) *)","counters":[]},{"line":"  (*         Account_id.Stable.Latest.bin_read_t *)","counters":[]},{"line":"","counters":[]},{"line":"  (*     let set (mdb : t) (token_id : Token_id.t) (account_id : Account_id.t) : *)","counters":[]},{"line":"  (*         unit = *)","counters":[]},{"line":"  (*       set_bin mdb (build_location token_id) *)","counters":[]},{"line":"  (*         Account_id.Stable.Latest.bin_size_t *)","counters":[]},{"line":"  (*         Account_id.Stable.Latest.bin_write_t account_id *)","counters":[]},{"line":"","counters":[]},{"line":"  (*     let remove (mdb : t) (token_id : Token_id.t) : unit = *)","counters":[]},{"line":"  (*       delete_raw mdb (build_location token_id) *)","counters":[]},{"line":"","counters":[]},{"line":"  (*     let all_owners (t : t) : (Token_id.t * Account_id.t) Sequence.t = *)","counters":[]},{"line":"  (*       let deduped_tokens = *)","counters":[]},{"line":"  (*         (\\* First get the sequence of unique tokens *\\) *)","counters":[]},{"line":"  (*         Sequence.folding_map (all_accounts t) ~init:Token_id.Set.empty *)","counters":[]},{"line":"  (*           ~f:(fun (seen : Token_id.Set.t) (a : Account.t) -> *)","counters":[]},{"line":"  (*             let token = Account.token a in *)","counters":[]},{"line":"  (*             let already_seen = Token_id.Set.mem seen token in *)","counters":[]},{"line":"  (*             (Set.add seen token, (already_seen, token)) ) *)","counters":[]},{"line":"  (*         |> Sequence.filter_map ~f:(fun (already_seen, token) -> *)","counters":[]},{"line":"  (*                if already_seen then None else Some token ) *)","counters":[]},{"line":"  (*       in *)","counters":[]},{"line":"  (*       Sequence.filter_map deduped_tokens ~f:(fun token -> *)","counters":[]},{"line":"  (*           Option.map (get t token) ~f:(fun owner -> (token, owner)) ) *)","counters":[]},{"line":"","counters":[]},{"line":"  (*     let foldi (type a) (t : t) ~(init : a) *)","counters":[]},{"line":"  (*         ~(f : key:Token_id.t -> data:Account_id.t -> a -> a) : a = *)","counters":[]},{"line":"  (*       Sequence.fold (all_owners t) ~init ~f:(fun acc (key, data) -> *)","counters":[]},{"line":"  (*           f ~key ~data acc ) *)","counters":[]},{"line":"","counters":[]},{"line":"  (*     let _iteri t ~f = foldi t ~init:() ~f:(fun ~key ~data () -> f ~key ~data) *)","counters":[]},{"line":"  (*   end *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   let build_location pk = *)","counters":[]},{"line":"  (*     Location.build_generic *)","counters":[]},{"line":"  (*       (Bigstring.of_string (Format.sprintf !\"$tids!%{sexp: Key.t}\" pk)) *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   let serialize_kv ~ledger_depth (pk, tids) = *)","counters":[]},{"line":"  (*     let tokens_buf = *)","counters":[]},{"line":"  (*       Bin_prot.Common.create_buf (Token_id.Set.bin_size_t tids) *)","counters":[]},{"line":"  (*     in *)","counters":[]},{"line":"  (*     ignore (Token_id.Set.bin_write_t tokens_buf ~pos:0 tids : int) ; *)","counters":[]},{"line":"  (*     (Location.serialize ~ledger_depth (build_location pk), tokens_buf) *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   let get_opt mdb pk = get_bin mdb (build_location pk) Token_id.Set.bin_read_t *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   let get mdb pk = Option.value ~default:Token_id.Set.empty (get_opt mdb pk) *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   let set mdb pk tids = *)","counters":[]},{"line":"  (*     set_bin mdb (build_location pk) Token_id.Set.bin_size_t *)","counters":[]},{"line":"  (*       Token_id.Set.bin_write_t tids *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   let delete mdb pk = delete_raw mdb (build_location pk) *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   let change_opt mdb pk ~f = *)","counters":[]},{"line":"  (*     let old = get_opt mdb pk in *)","counters":[]},{"line":"  (*     match (old, f old) with *)","counters":[]},{"line":"  (*     | _, Some tids -> *)","counters":[]},{"line":"  (*         set mdb pk tids *)","counters":[]},{"line":"  (*     | Some _, None -> *)","counters":[]},{"line":"  (*         delete mdb pk *)","counters":[]},{"line":"  (*     | None, None -> *)","counters":[]},{"line":"  (*         () *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   let to_opt s = if Set.is_empty s then None else Some s *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   let _update_opt mdb pk ~f = change_opt mdb pk ~f:(fun x -> to_opt (f x)) *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   let update mdb pk ~f = *)","counters":[]},{"line":"  (*     change_opt mdb pk ~f:(fun x -> *)","counters":[]},{"line":"  (*         to_opt @@ f (Option.value ~default:Token_id.Set.empty x) ) *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   let add mdb pk tid = update mdb pk ~f:(fun tids -> Set.add tids tid) *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   let _add_several mdb pk new_tids = *)","counters":[]},{"line":"  (*     update mdb pk ~f:(fun tids -> *)","counters":[]},{"line":"  (*         Set.union tids (Token_id.Set.of_list new_tids) ) *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   let add_account (mdb : t) (aid : Account_id.t) : unit = *)","counters":[]},{"line":"  (*     let token = Account_id.token_id aid in *)","counters":[]},{"line":"  (*     let key = Account_id.public_key aid in *)","counters":[]},{"line":"  (*     add mdb key token ; *)","counters":[]},{"line":"  (*     (\\* TODO: The owner DB will store a lot of these unnecessarily since *)","counters":[]},{"line":"  (*        most accounts are not going to be managers. *\\) *)","counters":[]},{"line":"  (*     Owner.set mdb (Account_id.derive_token_id ~owner:aid) aid *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   let remove mdb pk tid = update mdb pk ~f:(fun tids -> Set.remove tids tid) *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   let _remove_several mdb pk rem_tids = *)","counters":[]},{"line":"  (*     update mdb pk ~f:(fun tids -> *)","counters":[]},{"line":"  (*         Set.diff tids (Token_id.Set.of_list rem_tids) ) *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   let remove_account (mdb : t) (aid : Account_id.t) : unit = *)","counters":[]},{"line":"  (*     let token = Account_id.token_id aid in *)","counters":[]},{"line":"  (*     let key = Account_id.public_key aid in *)","counters":[]},{"line":"  (*     remove mdb key token ; *)","counters":[]},{"line":"  (*     Owner.remove mdb (Account_id.derive_token_id ~owner:aid) *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   (\\** Generate a batch of database changes to add the given tokens. *\\) *)","counters":[]},{"line":"  (*   let add_batch_create mdb pks_to_tokens = *)","counters":[]},{"line":"  (*     let pks_to_all_tokens = *)","counters":[]},{"line":"  (*       Map.filter_mapi pks_to_tokens ~f:(fun ~key:pk ~data:tokens_to_add -> *)","counters":[]},{"line":"  (*           to_opt (Set.union (get mdb pk) tokens_to_add) ) *)","counters":[]},{"line":"  (*     in *)","counters":[]},{"line":"  (*     Map.to_alist pks_to_all_tokens *)","counters":[]},{"line":"  (*     |> List.map ~f:(serialize_kv ~ledger_depth:mdb.depth) *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   let _add_batch mdb pks_to_tokens = *)","counters":[]},{"line":"  (*     Kvdb.set_batch mdb.kvdb *)","counters":[]},{"line":"  (*       ~key_data_pairs:(add_batch_create mdb pks_to_tokens) *)","counters":[]},{"line":"  (* end *)","counters":[]},{"line":"","counters":[]},{"line":"  let location_of_account t account_id =","counters":[]},{"line":"    Rust.database_location_of_account t (account_id_to_rust account_id)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"    |> Option.map ~f:(fun addr -> Location.Account (Addr.of_string addr))","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"","counters":[]},{"line":"  (* match Account_location.get t key with *)","counters":[]},{"line":"  (* | Error _ -> *)","counters":[]},{"line":"  (*     None *)","counters":[]},{"line":"  (* | Ok location -> *)","counters":[]},{"line":"  (*     Some location *)","counters":[]},{"line":"","counters":[]},{"line":"  let location_of_account_batch t account_ids =","counters":[]},{"line":"    Printf.eprintf \"location_of_account_batch len=%d\\n%!\"","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (List.length account_ids) ;","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"    let account_ids =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      List.map account_ids ~f:(fun account_id -> account_id_to_rust account_id)","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"    in","counters":[]},{"line":"    let list =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Rust.database_location_of_account_batch t account_ids","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"      |> List.map ~f:(fun (account_id, addr) ->","counters":[]},{"line":"             ( account_id_from_rust account_id","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"             , Option.map addr ~f:(fun addr ->","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                   Location.Account (Addr.of_string addr) ) ) )","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"    in","counters":[]},{"line":"    (* Printf.eprintf \"LOCATIONS=%s\\n%!\" *)","counters":[]},{"line":"    (*   (String.concat ~sep:\",\" *)","counters":[]},{"line":"    (*      (List.map ~f:(fun (a, b) -> Addr.to_string b) list) ) ; *)","counters":[]},{"line":"    list","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  (* List.zip_exn keys (Account_location.get_batch t keys) *)","counters":[]},{"line":"","counters":[]},{"line":"  let last_filled t =","counters":[]},{"line":"    Rust.database_last_filled t","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"    |> Option.map ~f:(fun last -> Location.Account (Addr.of_string last))","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"  (* Account_location.last_location t *)","counters":[]},{"line":"","counters":[]},{"line":"  let token_owners (t : t) : Account_id.Set.t =","counters":[]},{"line":"    let list = Rust.database_token_owners t in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let list =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      List.map list ~f:(fun v ->","counters":[]},{"line":"          Account_id.Stable.Latest.bin_read_t (Bigstring.of_bytes v)","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"            ~pos_ref:(ref 0) )","counters":[]},{"line":"    in","counters":[]},{"line":"    Account_id.Set.of_list list","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  (* Tokens.Owner.all_owners t *)","counters":[]},{"line":"  (* |> Sequence.fold ~init:Account_id.Set.empty ~f:(fun acc (_, owner) -> *)","counters":[]},{"line":"  (*        Set.add acc owner ) *)","counters":[]},{"line":"","counters":[]},{"line":"  let token_owner t token_id =","counters":[]},{"line":"    Rust.database_token_owner t (token_id_to_rust token_id)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"    |> Option.map ~f:(fun owner -> account_id_from_rust owner)","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"  (* let token_owner = Tokens.Owner.get *)","counters":[]},{"line":"","counters":[]},{"line":"  let tokens t key =","counters":[]},{"line":"    Rust.database_tokens t (pubkey_to_rust key)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"    |> List.map ~f:token_id_from_rust","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"    |> Token_id.Set.of_list","counters":[]},{"line":"","counters":[]},{"line":"  (* let tokens = Tokens.get *)","counters":[]},{"line":"","counters":[]},{"line":"  (* include Util.Make (struct *)","counters":[]},{"line":"  (*   module Key = Key *)","counters":[]},{"line":"  (*   module Token_id = Token_id *)","counters":[]},{"line":"  (*   module Account_id = Account_id *)","counters":[]},{"line":"  (*   module Balance = Balance *)","counters":[]},{"line":"  (*   module Location = Location *)","counters":[]},{"line":"  (*   module Location_binable = Location_binable *)","counters":[]},{"line":"  (*   module Account = Account *)","counters":[]},{"line":"  (*   module Hash = Hash *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   module Base = struct *)","counters":[]},{"line":"  (*     type nonrec t = t *)","counters":[]},{"line":"","counters":[]},{"line":"  (*     let get = get *)","counters":[]},{"line":"","counters":[]},{"line":"  (*     let last_filled = last_filled *)","counters":[]},{"line":"  (*   end *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   let get_hash = get_hash *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   let ledger_depth = depth *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   let location_of_account_addr addr = Location.Account addr *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   let location_of_hash_addr addr = Location.Hash addr *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   let set_raw_hash_batch mdb addresses_and_hashes = *)","counters":[]},{"line":"  (*     set_bin_batch mdb Hash.bin_size_t Hash.bin_write_t addresses_and_hashes *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   let set_location_batch ~last_location mdb key_to_location_list = *)","counters":[]},{"line":"  (*     let last_location_key_value = *)","counters":[]},{"line":"  (*       (Account_location.last_location_key (), last_location) *)","counters":[]},{"line":"  (*     in *)","counters":[]},{"line":"  (*     let key_to_location_list = Non_empty_list.to_list key_to_location_list in *)","counters":[]},{"line":"  (*     let account_tokens = *)","counters":[]},{"line":"  (*       List.fold ~init:Key.Map.empty key_to_location_list *)","counters":[]},{"line":"  (*         ~f:(fun map (aid, _) -> *)","counters":[]},{"line":"  (*           Map.update map (Account_id.public_key aid) ~f:(function *)","counters":[]},{"line":"  (*             | Some set -> *)","counters":[]},{"line":"  (*                 Set.add set (Account_id.token_id aid) *)","counters":[]},{"line":"  (*             | None -> *)","counters":[]},{"line":"  (*                 Token_id.Set.singleton (Account_id.token_id aid) ) ) *)","counters":[]},{"line":"  (*     in *)","counters":[]},{"line":"  (*     let batched_changes = *)","counters":[]},{"line":"  (*       Account_location.serialize_last_account_kv ~ledger_depth:mdb.depth *)","counters":[]},{"line":"  (*         last_location_key_value *)","counters":[]},{"line":"  (*       :: ( Tokens.add_batch_create mdb account_tokens *)","counters":[]},{"line":"  (*          @ Account_location.set_batch_create ~ledger_depth:mdb.depth *)","counters":[]},{"line":"  (*              key_to_location_list ) *)","counters":[]},{"line":"  (*     in *)","counters":[]},{"line":"  (*     Kvdb.set_batch mdb.kvdb ~remove_keys:[] ~key_data_pairs:batched_changes *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   let set_raw_account_batch mdb *)","counters":[]},{"line":"  (*       (addresses_and_accounts : (location * Account.t) list) = *)","counters":[]},{"line":"  (*     set_bin_batch mdb Account.bin_size_t Account.bin_write_t *)","counters":[]},{"line":"  (*       addresses_and_accounts ; *)","counters":[]},{"line":"  (*     let token_owner_changes = *)","counters":[]},{"line":"  (*       List.filter_map addresses_and_accounts ~f:(fun (_, account) -> *)","counters":[]},{"line":"  (*           if Account.token_owner account then *)","counters":[]},{"line":"  (*             let aid = Account.identifier account in *)","counters":[]},{"line":"  (*             Some *)","counters":[]},{"line":"  (*               (Tokens.Owner.serialize_kv ~ledger_depth:mdb.depth *)","counters":[]},{"line":"  (*                  (Account_id.token_id aid, aid) ) *)","counters":[]},{"line":"  (*           else None ) *)","counters":[]},{"line":"  (*     in *)","counters":[]},{"line":"  (*     Kvdb.set_batch mdb.kvdb ~remove_keys:[] *)","counters":[]},{"line":"  (*       ~key_data_pairs:token_owner_changes *)","counters":[]},{"line":"  (* end) *)","counters":[]},{"line":"","counters":[]},{"line":"  (* let set_hash _mdb _location _new_hash = failwith \"set_hash: not implemented\" *)","counters":[]},{"line":"","counters":[]},{"line":"  (* TODO *)","counters":[]},{"line":"  (* set_hash_batch mdb [ (location, new_hash) ] *)","counters":[]},{"line":"","counters":[]},{"line":"  module For_tests = struct","counters":[]},{"line":"    let gen_account_location ~ledger_depth =","counters":[]},{"line":"      let open Quickcheck.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let build_account (path : Direction.t list) =","counters":[]},{"line":"        assert (List.length path = ledger_depth) ;","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"        Location.Account (Addr.of_directions path)","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"      in","counters":[]},{"line":"      let%map dirs =","counters":[]},{"line":"        Quickcheck.Generator.list_with_length ledger_depth Direction.gen","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"      in","counters":[]},{"line":"      build_account dirs","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let set mdb location account =","counters":[]},{"line":"    (*Printf.eprintf \"MY_LOG.MERKLE_LEDGER.DATABASE.SET\\n%!\" ;*)","counters":[]},{"line":"    let location = location_to_rust location in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Rust.database_set mdb location (account_to_rust account)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"","counters":[]},{"line":"  (* set_bin mdb location Account.bin_size_t Account.bin_write_t account ; *)","counters":[]},{"line":"  (* set_hash mdb *)","counters":[]},{"line":"  (*   (Location.Hash (Location.to_path_exn location)) *)","counters":[]},{"line":"  (*   (Hash.hash_account account) *)","counters":[]},{"line":"","counters":[]},{"line":"  let index_of_account_exn mdb account_id =","counters":[]},{"line":"    Rust.database_index_of_account mdb (account_id_to_rust account_id)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"  (* let location = location_of_account mdb account_id |> Option.value_exn in *)","counters":[]},{"line":"  (* let addr = Location.to_path_exn location in *)","counters":[]},{"line":"  (* Addr.to_int addr *)","counters":[]},{"line":"","counters":[]},{"line":"  let set_at_index_exn mdb index account =","counters":[]},{"line":"    Rust.database_set_at_index mdb index (account_to_rust account)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"  (* let addr = Addr.of_int_exn ~ledger_depth:mdb.depth index in *)","counters":[]},{"line":"  (* set mdb (Location.Account addr) account *)","counters":[]},{"line":"","counters":[]},{"line":"  let get_or_create_account mdb account_id account =","counters":[]},{"line":"    (*Printf.eprintf \"MY_LOG.MERKLE_LEDGER.DATABASE.GET_OR_CREATE_ACCOUNT\\n%!\" ;*)","counters":[]},{"line":"    let account_id = account_id_to_rust account_id in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let account = account_to_rust account in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    match Rust.database_get_or_create_account mdb account_id account with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Ok (location, addr) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Ok (location, Location.Account (Addr.of_string addr))","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"    | Error _err ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Error (Error.of_string \"get_or_create_account\")","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"  (* match Account_location.get mdb account_id with *)","counters":[]},{"line":"  (* | Error Account_location_not_found -> ( *)","counters":[]},{"line":"  (*     match Account_location.allocate mdb account_id with *)","counters":[]},{"line":"  (*     | Ok location -> *)","counters":[]},{"line":"  (*         set mdb location account ; *)","counters":[]},{"line":"  (*         Tokens.add_account mdb account_id ; *)","counters":[]},{"line":"  (*         Ok (`Added, location) *)","counters":[]},{"line":"  (*     | Error err -> *)","counters":[]},{"line":"  (*         Error (Error.create \"get_or_create_account\" err Db_error.sexp_of_t) *)","counters":[]},{"line":"  (*     ) *)","counters":[]},{"line":"  (* | Error err -> *)","counters":[]},{"line":"  (*     Error (Error.create \"get_or_create_account\" err Db_error.sexp_of_t) *)","counters":[]},{"line":"  (* | Ok location -> *)","counters":[]},{"line":"  (*     Ok (`Existed, location) *)","counters":[]},{"line":"","counters":[]},{"line":"  let num_accounts t = Rust.database_num_accounts t","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"  (* match Account_location.last_location_address t with *)","counters":[]},{"line":"  (* | None -> *)","counters":[]},{"line":"  (*     0 *)","counters":[]},{"line":"  (* | Some addr -> *)","counters":[]},{"line":"  (*     Addr.to_int addr + 1 *)","counters":[]},{"line":"","counters":[]},{"line":"  (* TODO : if key-value store supports iteration mechanism, like RocksDB,","counters":[]},{"line":"     maybe use that here, instead of loading all accounts into memory See Issue","counters":[]},{"line":"     #1191 *)","counters":[]},{"line":"","counters":[]},{"line":"  let foldi_with_ignored_accounts t ignored_accounts ~init ~f =","counters":[]},{"line":"    let accum = ref init in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let ignored_accounts =","counters":[]},{"line":"      Account_id.Set.to_list ignored_accounts |> List.map ~f:account_id_to_rust","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"    in","counters":[]},{"line":"    Rust.database_foldi_with_ignored_accounts t ignored_accounts","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (fun addr account ->","counters":[]},{"line":"        accum := f (Addr.of_string addr) !accum (account_from_rust account) ) ;","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"    !accum","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  (* Rust.database_fold_with_ignored_accounts t ignored_accounts init f *)","counters":[]},{"line":"","counters":[]},{"line":"  (* let f' index accum account = *)","counters":[]},{"line":"  (*   f (Addr.of_int_exn ~ledger_depth:(depth t) index) accum account *)","counters":[]},{"line":"  (* in *)","counters":[]},{"line":"  (* match Account_location.last_location_address t with *)","counters":[]},{"line":"  (* | None -> *)","counters":[]},{"line":"  (*     init *)","counters":[]},{"line":"  (* | Some last_addr -> *)","counters":[]},{"line":"  (*     let ignored_indices = *)","counters":[]},{"line":"  (*       Int.Set.map ignored_accounts ~f:(fun account_id -> *)","counters":[]},{"line":"  (*           try index_of_account_exn t account_id with _ -> -1 *)","counters":[]},{"line":"  (*           (\\* dummy index for accounts not in database *\\) ) *)","counters":[]},{"line":"  (*     in *)","counters":[]},{"line":"  (*     let last = Addr.to_int last_addr in *)","counters":[]},{"line":"  (*     Sequence.range ~stop:`inclusive 0 last *)","counters":[]},{"line":"  (*     (\\* filter out indices corresponding to ignored accounts *\\) *)","counters":[]},{"line":"  (*     |> Sequence.filter ~f:(fun loc -> not (Int.Set.mem ignored_indices loc)) *)","counters":[]},{"line":"  (*     |> Sequence.map ~f:(get_at_index_exn t) *)","counters":[]},{"line":"  (*     |> Sequence.foldi ~init ~f:f' *)","counters":[]},{"line":"","counters":[]},{"line":"  let foldi t ~init ~f =","counters":[]},{"line":"    let accum = ref init in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Rust.database_foldi t (fun addr account ->","counters":[]},{"line":"        accum := f (Addr.of_string addr) !accum (account_from_rust account) ) ;","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"    !accum","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  (* Rust.database_fold t init f *)","counters":[]},{"line":"  (* foldi_with_ignored_accounts t Account_id.Set.empty ~init ~f *)","counters":[]},{"line":"","counters":[]},{"line":"  (* module C : Container.S0 with type t := t and type elt := Account.t = *)","counters":[]},{"line":"  (* Container.Make0 (struct *)","counters":[]},{"line":"  (*   module Elt = Account *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   type nonrec t = t *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   let fold t ~init ~f = *)","counters":[]},{"line":"  (*     let f' _index accum account = f accum account in *)","counters":[]},{"line":"  (*     foldi t ~init ~f:f' *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   let iter = `Define_using_fold *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   (\\* Use num_accounts instead? *\\) *)","counters":[]},{"line":"  (*   let length = `Define_using_fold *)","counters":[]},{"line":"  (* end) *)","counters":[]},{"line":"","counters":[]},{"line":"  let fold_until t ~init ~f =","counters":[]},{"line":"    let _t = t in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let _init = init in","counters":[]},{"line":"    let _f = f in","counters":[]},{"line":"    failwith \"fold_until: not implemented\"","counters":[]},{"line":"  (* Rust.database_fold_until t init f *)","counters":[]},{"line":"  (* let fold_until = C.fold_until *)","counters":[]},{"line":"","counters":[]},{"line":"  let merkle_root mdb = Rust.database_merkle_root mdb |> hash_from_rust","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"  (* let merkle_root mdb = get_hash mdb Location.root_hash *)","counters":[]},{"line":"","counters":[]},{"line":"  let remove_accounts_exn t account_ids =","counters":[]},{"line":"    let account_ids = List.map account_ids ~f:account_id_to_rust in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Rust.database_remove_accounts t account_ids","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  (* let locations = *)","counters":[]},{"line":"  (*   (\\* if we don't have a location for all keys, raise an exception *\\) *)","counters":[]},{"line":"  (*   let rec loop keys accum = *)","counters":[]},{"line":"  (*     match keys with *)","counters":[]},{"line":"  (*     | [] -> *)","counters":[]},{"line":"  (*         accum (\\* no need to reverse *\\) *)","counters":[]},{"line":"  (*     | key :: rest -> ( *)","counters":[]},{"line":"  (*         match Account_location.get t key with *)","counters":[]},{"line":"  (*         | Ok loc -> *)","counters":[]},{"line":"  (*             loop rest (loc :: accum) *)","counters":[]},{"line":"  (*         | Error err -> *)","counters":[]},{"line":"  (*             raise (Db_error.Db_exception err) ) *)","counters":[]},{"line":"  (*   in *)","counters":[]},{"line":"  (*   loop keys [] *)","counters":[]},{"line":"  (* in *)","counters":[]},{"line":"  (* (\\* N.B.: we're not using stack database here to make available newly-freed *)","counters":[]},{"line":"  (*    locations *\\) *)","counters":[]},{"line":"  (* List.iter keys ~f:(Account_location.delete t) ; *)","counters":[]},{"line":"  (* List.iter keys ~f:(Tokens.remove_account t) ; *)","counters":[]},{"line":"  (* List.iter locations ~f:(fun loc -> delete_raw t loc) ; *)","counters":[]},{"line":"  (* (\\* recalculate hashes for each removed account *\\) *)","counters":[]},{"line":"  (* List.iter locations ~f:(fun loc -> *)","counters":[]},{"line":"  (*     let hash_loc = Location.Hash (Location.to_path_exn loc) in *)","counters":[]},{"line":"  (*     set_hash t hash_loc Hash.empty_account ) *)","counters":[]},{"line":"","counters":[]},{"line":"  let merkle_path mdb location =","counters":[]},{"line":"    (*let empty = Account.empty in","counters":[]},{"line":"    let hash_empty = Hash.hash_account empty in","counters":[]},{"line":"    Printf.eprintf \"MY_LOG.MERKLE_LEDGER.DATABASE.MERKLE_PATH %s\\n%!\"","counters":[]},{"line":"       (Hash.to_base58_check hash_empty) ;","counters":[]},{"line":"      (Snark_params.Tick.Field.to_string hash_empty) ; *)","counters":[]},{"line":"    Rust.database_merkle_path mdb (location_to_rust location)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"    |> List.map ~f:path_from_rust","counters":[]},{"line":"","counters":[]},{"line":"  (* let location = *)","counters":[]},{"line":"  (*   if Location.is_account location then *)","counters":[]},{"line":"  (*     Location.Hash (Location.to_path_exn location) *)","counters":[]},{"line":"  (*   else location *)","counters":[]},{"line":"  (* in *)","counters":[]},{"line":"  (* assert (Location.is_hash location) ; *)","counters":[]},{"line":"  (* let rec loop k = *)","counters":[]},{"line":"  (*   if Location.height ~ledger_depth:mdb.depth k >= mdb.depth then [] *)","counters":[]},{"line":"  (*   else *)","counters":[]},{"line":"  (*     let sibling = Location.sibling k in *)","counters":[]},{"line":"  (*     let sibling_dir = Location.last_direction (Location.to_path_exn k) in *)","counters":[]},{"line":"  (*     let hash = get_hash mdb sibling in *)","counters":[]},{"line":"  (*     Direction.map sibling_dir ~left:(`Left hash) ~right:(`Right hash) *)","counters":[]},{"line":"  (*     :: loop (Location.parent k) *)","counters":[]},{"line":"  (* in *)","counters":[]},{"line":"  (* loop location *)","counters":[]},{"line":"","counters":[]},{"line":"  let merkle_path_at_addr_exn mdb addr =","counters":[]},{"line":"    Rust.database_merkle_path_at_addr mdb (Addr.to_string addr)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"    |> List.map ~f:path_from_rust","counters":[]},{"line":"","counters":[]},{"line":"  (* failwith \"merkle_path_at_addr_exn: not implemented\" *)","counters":[]},{"line":"  (* TODO *)","counters":[]},{"line":"  (* let ledger_depth = depth t in *)","counters":[]},{"line":"  (* let _ = *)","counters":[]},{"line":"  (*   Rust.database_merkle_path_at_addr t *)","counters":[]},{"line":"  (*     (Bigstring.to_bytes *)","counters":[]},{"line":"  (*        (Location.serialize ~ledger_depth (Location.Hash addr)) ) *)","counters":[]},{"line":"  (* in *)","counters":[]},{"line":"","counters":[]},{"line":"  (* let merkle_path_at_addr_exn t addr = merkle_path t (Location.Hash addr) *)","counters":[]},{"line":"","counters":[]},{"line":"  let merkle_path_at_index_exn mdb index =","counters":[]},{"line":"    Rust.database_merkle_path_at_index mdb index |> List.map ~f:path_from_rust","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"  (* failwith \"merkle_path_at_index: not implemented\" *)","counters":[]},{"line":"  (* Rust.database_merkle_path_at_index t index *)","counters":[]},{"line":"","counters":[]},{"line":"  (* let addr = Addr.of_int_exn ~ledger_depth:t.depth index in *)","counters":[]},{"line":"  (* merkle_path_at_addr_exn t addr *)","counters":[]},{"line":"","counters":[]},{"line":"  let set_all_accounts_rooted_at_exn t addr accounts =","counters":[]},{"line":"    let accounts = List.map accounts ~f:account_to_rust in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Rust.database_set_all_accounts_rooted_at t (Addr.to_string addr) accounts","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"","counters":[]},{"line":"  let set_batch_accounts t list =","counters":[]},{"line":"    (* Printf.eprintf \"SET_BATCH_ACCOUNT '%s'\\n%!\" *)","counters":[]},{"line":"    (*   (Addr.to_string (Addr.of_string \"0101011111\")) ; *)","counters":[]},{"line":"    let accounts =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      List.map list ~f:(fun (addr, account) ->","counters":[]},{"line":"          (* Printf.eprintf \"ADDR HERE %s\\n%!\" (Addr.to_string addr) ; *)","counters":[]},{"line":"          (Addr.to_string addr, account_to_rust account) )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"    in","counters":[]},{"line":"    Rust.database_set_batch_accounts t accounts","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let set_batch t list =","counters":[]},{"line":"    Printf.eprintf \"SET_BATCH\\n%!\" ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let accounts =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      List.map list ~f:(fun (location, account) ->","counters":[]},{"line":"          (location_to_rust location, account_to_rust account) )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"    in","counters":[]},{"line":"    Rust.database_set_batch_accounts t accounts","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let get_all_accounts_rooted_at_exn t addr =","counters":[]},{"line":"    let accounts =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Rust.database_get_all_accounts_rooted_at t (Addr.to_string addr)","counters":[{"col_start":63,"col_end":63,"count":0}]},{"line":"    in","counters":[]},{"line":"    List.map accounts ~f:(fun (addr, account) ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        (Addr.of_string addr, account_from_rust account) )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}