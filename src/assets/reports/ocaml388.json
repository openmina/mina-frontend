{"filename":"src/lib/mina_base/data_as_hash.ml","lines":[{"line":"open Snark_params","counters":[]},{"line":"open Tick","counters":[]},{"line":"","counters":[]},{"line":"type 'a t = Field.Var.t * 'a As_prover.Ref.t","counters":[]},{"line":"","counters":[]},{"line":"let hash (x, _) = x","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"","counters":[]},{"line":"let ref (_, x) = x","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"","counters":[]},{"line":"let typ ~hash =","counters":[]},{"line":"  Typ.transport","counters":[{"col_start":2,"col_end":2,"count":5}]},{"line":"    Typ.(Field.typ * Internal.ref ())","counters":[{"col_start":32,"col_end":32,"count":5}]},{"line":"    ~there:(fun s -> (hash s, s))","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"    ~back:(fun (_, s) -> s)","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"let optional_typ ~hash ~non_preimage ~dummy_value =","counters":[]},{"line":"  Typ.transport","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Typ.(Field.typ * Internal.ref ())","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"    ~there:(function","counters":[]},{"line":"      | None -> (non_preimage, dummy_value) | Some s -> (hash s, s) )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":46,"col_end":46,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"    ~back:(fun (_, s) -> Some s)","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"let to_input (x, _) = Random_oracle_input.Chunked.field x","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"let if_ b ~then_ ~else_ =","counters":[]},{"line":"  let open Run in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let hash = Field.if_ b ~then_:(fst then_) ~else_:(fst else_) in","counters":[{"col_start":35,"col_end":35,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"  let ref =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    As_prover.Ref.create","counters":[]},{"line":"      As_prover.(","counters":[]},{"line":"        fun () ->","counters":[]},{"line":"          let ref = if read Boolean.typ b then snd then_ else snd else_ in","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":47,"col_end":47,"count":0},{"col_start":49,"col_end":49,"count":0},{"col_start":62,"col_end":62,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"          As_prover.Ref.get ref)","counters":[]},{"line":"  in","counters":[]},{"line":"  (hash, ref)","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let make_unsafe hash ref : 'a t = (hash, ref)","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"","counters":[]},{"line":"module As_record = struct","counters":[]},{"line":"  (* it's OK that hash is a Field.t (not a var), bc this is just annotation for the deriver *)","counters":[]},{"line":"  type 'a t = { data : 'a; hash : Field.t } [@@deriving annot, fields]","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":10,"col_end":10,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let deriver inner obj =","counters":[]},{"line":"  let open Fields_derivers_zkapps in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let ( !. ) = ( !. ) ~t_fields_annots:As_record.t_fields_annots in","counters":[]},{"line":"  As_record.Fields.make_creator obj ~data:!.inner ~hash:!.field","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":43,"col_end":43,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"  |> finish \"Events\" ~t_toplevel_annots:As_record.t_toplevel_annots","counters":[{"col_start":66,"col_end":66,"count":1}]}]}