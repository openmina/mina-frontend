{"filename":"src/lib/snarky_log/snarky_log.ml","lines":[{"line":"open Snarky_backendless","counters":[]},{"line":"open Webkit_trace_event","counters":[]},{"line":"open Webkit_trace_event.Output.JSON","counters":[]},{"line":"open Yojson","counters":[]},{"line":"","counters":[]},{"line":"let to_string ?buf ?len ?std events =","counters":[]},{"line":"  to_string ?buf ?len ?std @@ json_of_events events","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"","counters":[]},{"line":"let to_channel ?buf ?len ?std out_channel events =","counters":[]},{"line":"  to_channel ?buf ?len ?std out_channel @@ json_of_events events","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"","counters":[]},{"line":"let to_file ?buf ?len ?std filename events =","counters":[]},{"line":"  let oc = open_out filename in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  to_channel ?buf ?len ?std oc events ;","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  close_out oc","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"module Constraints (Snarky_backendless : Snark_intf.Basic) = struct","counters":[]},{"line":"  (** Create flamechart events for Snarky_backendless constraints.","counters":[]},{"line":"","counters":[]},{"line":"    This creates a chart of labels, associating each label with a 'timestamp'","counters":[]},{"line":"    equal to the number of constraints at its start and end. *)","counters":[]},{"line":"  open Snarky_backendless","counters":[]},{"line":"","counters":[]},{"line":"  (** Generate a flamechart for the labels of a checked computation. *)","counters":[]},{"line":"  let log ?weight (t : unit -> _ Checked.t) : events =","counters":[]},{"line":"    let rev_events = ref [] in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let _total =","counters":[]},{"line":"      constraint_count ?weight t ~log:(fun ?(start = false) label count ->","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"          rev_events :=","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            create_event label","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"              ~phase:(if start then Measure_start else Measure_end)","counters":[{"col_start":36,"col_end":36,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"              ~timestamp:count","counters":[]},{"line":"            :: !rev_events )","counters":[]},{"line":"    in","counters":[]},{"line":"    List.rev !rev_events","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  (** Same as [log], but for functions which take [Var.t] arguments.","counters":[]},{"line":"    Use [apply_args] to apply the corresponding OCaml-typed arguments.","counters":[]},{"line":"    For example: {[","counters":[]},{"line":"open Snarky_backendless","counters":[]},{"line":"module Snark = Snark.Make (Backends.Bn128.Default)","counters":[]},{"line":"open Snark","counters":[]},{"line":"module Constraints = Snarky_log.Constraints (Snark)","counters":[]},{"line":"","counters":[]},{"line":"let () = Snarky_log.to_file \"output.json\" @@","counters":[]},{"line":"  Constraints.log_func ~input:Data_spec.[Field.typ; Field.typ] Field.Checked.mul","counters":[]},{"line":"    ~apply_args:(fun mul -> mul Field.one Field.one)","counters":[]},{"line":"    }] *)","counters":[]},{"line":"  let log_func ~input_typ ~return_typ ~(apply_args : 'k_value -> _ Checked.t)","counters":[]},{"line":"      (f : 'k_var) : events =","counters":[]},{"line":"    let f' = conv (fun c -> c) input_typ return_typ f in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"    log (fun () -> apply_args f')","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"end","counters":[]}]}