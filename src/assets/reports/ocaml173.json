{"filename":"src/lib/pickles/types_map.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Pickles_types","counters":[]},{"line":"open Import","counters":[]},{"line":"open Backend","counters":[]},{"line":"","counters":[]},{"line":"(* We maintain a global hash table which stores for each inductive proof system some","counters":[]},{"line":"   data.","counters":[]},{"line":"*)","counters":[]},{"line":"type inner_curve_var =","counters":[]},{"line":"  Tick.Field.t Snarky_backendless.Cvar.t","counters":[]},{"line":"  * Tick.Field.t Snarky_backendless.Cvar.t","counters":[]},{"line":"","counters":[]},{"line":"module Basic = struct","counters":[]},{"line":"  type ('var, 'value, 'n1, 'n2) t =","counters":[]},{"line":"    { max_proofs_verified : (module Nat.Add.Intf with type n = 'n1)","counters":[]},{"line":"    ; public_input : ('var, 'value) Impls.Step.Typ.t","counters":[]},{"line":"    ; branches : 'n2 Nat.t","counters":[]},{"line":"    ; wrap_domains : Domains.t","counters":[]},{"line":"    ; wrap_key : Tick.Inner_curve.Affine.t Plonk_verification_key_evals.t","counters":[]},{"line":"    ; wrap_vk : Impls.Wrap.Verification_key.t","counters":[]},{"line":"    ; step_uses_lookup : Plonk_types.Opt.Flag.t","counters":[]},{"line":"    }","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Side_loaded = struct","counters":[]},{"line":"  module Ephemeral = struct","counters":[]},{"line":"    type t =","counters":[]},{"line":"      { index :","counters":[]},{"line":"          [ `In_circuit of Side_loaded_verification_key.Checked.t","counters":[]},{"line":"          | `In_prover of Side_loaded_verification_key.t","counters":[]},{"line":"          | `In_both of","counters":[]},{"line":"            Side_loaded_verification_key.t","counters":[]},{"line":"            * Side_loaded_verification_key.Checked.t ]","counters":[]},{"line":"      }","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Permanent = struct","counters":[]},{"line":"    type ('var, 'value, 'n1, 'n2) t =","counters":[]},{"line":"      { max_proofs_verified : (module Nat.Add.Intf with type n = 'n1)","counters":[]},{"line":"      ; public_input : ('var, 'value) Impls.Step.Typ.t","counters":[]},{"line":"      ; step_uses_lookup : Plonk_types.Opt.Flag.t","counters":[]},{"line":"      ; branches : 'n2 Nat.t","counters":[]},{"line":"      }","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  type ('var, 'value, 'n1, 'n2) t =","counters":[]},{"line":"    { ephemeral : Ephemeral.t option","counters":[]},{"line":"    ; permanent : ('var, 'value, 'n1, 'n2) Permanent.t","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  type packed =","counters":[]},{"line":"    | T :","counters":[]},{"line":"        ('var, 'value, 'n1, 'n2) Tag.tag * ('var, 'value, 'n1, 'n2) t","counters":[]},{"line":"        -> packed","counters":[]},{"line":"","counters":[]},{"line":"  let to_basic","counters":[]},{"line":"      { permanent =","counters":[]},{"line":"          { max_proofs_verified; public_input; branches; step_uses_lookup }","counters":[]},{"line":"      ; ephemeral","counters":[]},{"line":"      } =","counters":[]},{"line":"    let wrap_key, wrap_vk =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      match ephemeral with","counters":[]},{"line":"      | Some { index = `In_prover i | `In_both (i, _) } ->","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"          (i.wrap_index, i.wrap_vk)","counters":[]},{"line":"      | _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          failwithf \"Side_loaded.to_basic: Expected `In_prover (%s)\" __LOC__ ()","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"    in","counters":[]},{"line":"    let proofs_verified = Nat.to_int (Nat.Add.n max_proofs_verified) in","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"    let wrap_vk = Option.value_exn ~here:[%here] wrap_vk in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    { Basic.max_proofs_verified","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    ; wrap_vk","counters":[]},{"line":"    ; public_input","counters":[]},{"line":"    ; branches","counters":[]},{"line":"    ; wrap_domains = Common.wrap_domains ~proofs_verified","counters":[]},{"line":"    ; wrap_key","counters":[]},{"line":"    ; step_uses_lookup","counters":[]},{"line":"    }","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Compiled = struct","counters":[]},{"line":"  type f = Impls.Wrap.field","counters":[]},{"line":"","counters":[]},{"line":"  type ('a_var, 'a_value, 'max_proofs_verified, 'branches) basic =","counters":[]},{"line":"    { public_input : ('a_var, 'a_value) Impls.Step.Typ.t","counters":[]},{"line":"    ; proofs_verifieds : (int, 'branches) Vector.t","counters":[]},{"line":"          (* For each branch in this rule, how many predecessor proofs does it have? *)","counters":[]},{"line":"    ; wrap_domains : Domains.t","counters":[]},{"line":"    ; step_domains : (Domains.t, 'branches) Vector.t","counters":[]},{"line":"    ; step_uses_lookup : Plonk_types.Opt.Flag.t","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  (* This is the data associated to an inductive proof system with statement type","counters":[]},{"line":"     ['a_var], which has ['branches] many \"variants\" each of which depends on at most","counters":[]},{"line":"     ['max_proofs_verified] many previous statements. *)","counters":[]},{"line":"  type ('a_var, 'a_value, 'max_proofs_verified, 'branches) t =","counters":[]},{"line":"    { branches : 'branches Nat.t","counters":[]},{"line":"    ; max_proofs_verified :","counters":[]},{"line":"        (module Nat.Add.Intf with type n = 'max_proofs_verified)","counters":[]},{"line":"    ; proofs_verifieds : (int, 'branches) Vector.t","counters":[]},{"line":"          (* For each branch in this rule, how many predecessor proofs does it have? *)","counters":[]},{"line":"    ; public_input : ('a_var, 'a_value) Impls.Step.Typ.t","counters":[]},{"line":"    ; wrap_key : Tick.Inner_curve.Affine.t Plonk_verification_key_evals.t Lazy.t","counters":[]},{"line":"    ; wrap_vk : Impls.Wrap.Verification_key.t Lazy.t","counters":[]},{"line":"    ; wrap_domains : Domains.t","counters":[]},{"line":"    ; step_domains : (Domains.t, 'branches) Vector.t","counters":[]},{"line":"    ; step_uses_lookup : Plonk_types.Opt.Flag.t","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  type packed =","counters":[]},{"line":"    | T :","counters":[]},{"line":"        ('var, 'value, 'n1, 'n2) Tag.tag * ('var, 'value, 'n1, 'n2) t","counters":[]},{"line":"        -> packed","counters":[]},{"line":"","counters":[]},{"line":"  let to_basic","counters":[]},{"line":"      { branches","counters":[]},{"line":"      ; max_proofs_verified","counters":[]},{"line":"      ; proofs_verifieds","counters":[]},{"line":"      ; public_input","counters":[]},{"line":"      ; wrap_vk","counters":[]},{"line":"      ; wrap_domains","counters":[]},{"line":"      ; step_domains","counters":[]},{"line":"      ; wrap_key","counters":[]},{"line":"      ; step_uses_lookup","counters":[]},{"line":"      } =","counters":[]},{"line":"    { Basic.max_proofs_verified","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    ; wrap_domains","counters":[]},{"line":"    ; public_input","counters":[]},{"line":"    ; branches = Vector.length step_domains","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"    ; wrap_key = Lazy.force wrap_key","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"    ; wrap_vk = Lazy.force wrap_vk","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"    ; step_uses_lookup","counters":[]},{"line":"    }","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module For_step = struct","counters":[]},{"line":"  type ('a_var, 'a_value, 'max_proofs_verified, 'branches) t =","counters":[]},{"line":"    { branches : 'branches Nat.t","counters":[]},{"line":"    ; max_proofs_verified :","counters":[]},{"line":"        (module Nat.Add.Intf with type n = 'max_proofs_verified)","counters":[]},{"line":"    ; proofs_verifieds :","counters":[]},{"line":"        [ `Known of (Impls.Step.Field.t, 'branches) Vector.t | `Side_loaded ]","counters":[]},{"line":"    ; public_input : ('a_var, 'a_value) Impls.Step.Typ.t","counters":[]},{"line":"    ; wrap_key : inner_curve_var Plonk_verification_key_evals.t","counters":[]},{"line":"    ; wrap_domain :","counters":[]},{"line":"        [ `Known of Domain.t","counters":[]},{"line":"        | `Side_loaded of","counters":[]},{"line":"          Impls.Step.field Pickles_base.Proofs_verified.One_hot.Checked.t ]","counters":[]},{"line":"    ; step_domains : [ `Known of (Domains.t, 'branches) Vector.t | `Side_loaded ]","counters":[]},{"line":"    ; step_uses_lookup : Plonk_types.Opt.Flag.t","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let of_side_loaded (type a b c d e f)","counters":[]},{"line":"      ({ ephemeral","counters":[]},{"line":"       ; permanent =","counters":[]},{"line":"           { branches; max_proofs_verified; public_input; step_uses_lookup }","counters":[]},{"line":"       } :","counters":[]},{"line":"        (a, b, c, d) Side_loaded.t ) : (a, b, c, d) t =","counters":[]},{"line":"    let index =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      match ephemeral with","counters":[]},{"line":"      | Some { index = `In_circuit i | `In_both (_, i) } ->","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"          i","counters":[]},{"line":"      | _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          failwithf \"For_step.side_loaded: Expected `In_circuit (%s)\" __LOC__ ()","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"    in","counters":[]},{"line":"    let T = Nat.eq_exn branches Side_loaded_verification_key.Max_branches.n in","counters":[]},{"line":"    { branches","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    ; max_proofs_verified","counters":[]},{"line":"    ; public_input","counters":[]},{"line":"    ; proofs_verifieds = `Side_loaded","counters":[]},{"line":"    ; wrap_key = index.wrap_index","counters":[]},{"line":"    ; wrap_domain = `Side_loaded index.max_proofs_verified","counters":[]},{"line":"    ; step_domains = `Side_loaded","counters":[]},{"line":"    ; step_uses_lookup","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let of_compiled","counters":[]},{"line":"      ({ branches","counters":[]},{"line":"       ; max_proofs_verified","counters":[]},{"line":"       ; proofs_verifieds","counters":[]},{"line":"       ; public_input","counters":[]},{"line":"       ; wrap_key","counters":[]},{"line":"       ; wrap_domains","counters":[]},{"line":"       ; step_domains","counters":[]},{"line":"       ; step_uses_lookup","counters":[]},{"line":"       } :","counters":[]},{"line":"        _ Compiled.t ) =","counters":[]},{"line":"    { branches","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    ; max_proofs_verified","counters":[]},{"line":"    ; proofs_verifieds =","counters":[]},{"line":"        `Known (Vector.map proofs_verifieds ~f:Impls.Step.Field.of_int)","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"    ; public_input","counters":[]},{"line":"    ; wrap_key =","counters":[]},{"line":"        Plonk_verification_key_evals.map (Lazy.force wrap_key)","counters":[{"col_start":39,"col_end":39,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"          ~f:Step_main_inputs.Inner_curve.constant","counters":[]},{"line":"    ; wrap_domain = `Known wrap_domains.h","counters":[]},{"line":"    ; step_domains = `Known step_domains","counters":[]},{"line":"    ; step_uses_lookup","counters":[]},{"line":"    }","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"type t =","counters":[]},{"line":"  { compiled : Compiled.packed Type_equal.Id.Uid.Table.t","counters":[]},{"line":"  ; side_loaded : Side_loaded.packed Type_equal.Id.Uid.Table.t","counters":[]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"let univ : t =","counters":[]},{"line":"  { compiled = Type_equal.Id.Uid.Table.create ()","counters":[{"col_start":44,"col_end":44,"count":1}]},{"line":"  ; side_loaded = Type_equal.Id.Uid.Table.create ()","counters":[{"col_start":47,"col_end":47,"count":1}]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"let find t k =","counters":[]},{"line":"  match Hashtbl.find t k with None -> failwith \"key not found\" | Some x -> x","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"","counters":[]},{"line":"let lookup_compiled :","counters":[]},{"line":"    type var value n m.","counters":[]},{"line":"    (var, value, n, m) Tag.tag -> (var, value, n, m) Compiled.t =","counters":[]},{"line":" fun t ->","counters":[]},{"line":"  let (T (other_id, d)) = find univ.compiled (Type_equal.Id.uid t) in","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"  let T = Type_equal.Id.same_witness_exn t other_id in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  d","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let lookup_side_loaded :","counters":[]},{"line":"    type var value n m.","counters":[]},{"line":"    (var, value, n, m) Tag.tag -> (var, value, n, m) Side_loaded.t =","counters":[]},{"line":" fun t ->","counters":[]},{"line":"  let (T (other_id, d)) = find univ.side_loaded (Type_equal.Id.uid t) in","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"  let T = Type_equal.Id.same_witness_exn t other_id in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  d","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let lookup_basic :","counters":[]},{"line":"    type var value n m. (var, value, n, m) Tag.t -> (var, value, n, m) Basic.t =","counters":[]},{"line":" fun t ->","counters":[]},{"line":"  match t.kind with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | Compiled ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Compiled.to_basic (lookup_compiled t.id)","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"  | Side_loaded ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Side_loaded.to_basic (lookup_side_loaded t.id)","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"","counters":[]},{"line":"let max_proofs_verified :","counters":[]},{"line":"    type n1. (_, _, n1, _) Tag.t -> (module Nat.Add.Intf with type n = n1) =","counters":[]},{"line":" fun tag ->","counters":[]},{"line":"  match tag.kind with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | Compiled ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (lookup_compiled tag.id).max_proofs_verified","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"  | Side_loaded ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (lookup_side_loaded tag.id).permanent.max_proofs_verified","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"","counters":[]},{"line":"let public_input :","counters":[]},{"line":"    type var value. (var, value, _, _) Tag.t -> (var, value) Impls.Step.Typ.t =","counters":[]},{"line":" fun tag ->","counters":[]},{"line":"  match tag.kind with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | Compiled ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (lookup_compiled tag.id).public_input","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"  | Side_loaded ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (lookup_side_loaded tag.id).permanent.public_input","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"","counters":[]},{"line":"let uses_lookup :","counters":[]},{"line":"    type var value. (var, value, _, _) Tag.t -> Plonk_types.Opt.Flag.t =","counters":[]},{"line":" fun tag ->","counters":[]},{"line":"  match tag.kind with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | Compiled ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (lookup_compiled tag.id).step_uses_lookup","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"  | Side_loaded ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (lookup_side_loaded tag.id).permanent.step_uses_lookup","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"","counters":[]},{"line":"let value_to_field_elements :","counters":[]},{"line":"    type a. (_, a, _, _) Tag.t -> a -> Tick.Field.t array =","counters":[]},{"line":" fun t ->","counters":[]},{"line":"  let (Typ typ) = public_input t in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  fun x -> fst (typ.value_to_fields x)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":11,"col_end":11,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"","counters":[]},{"line":"let lookup_map (type var value c d) (t : (var, value, c, d) Tag.t) ~self","counters":[]},{"line":"    ~default","counters":[]},{"line":"    ~(f :","counters":[]},{"line":"          [ `Compiled of (var, value, c, d) Compiled.t","counters":[]},{"line":"          | `Side_loaded of (var, value, c, d) Side_loaded.t ]","counters":[]},{"line":"       -> _ ) =","counters":[]},{"line":"  match Type_equal.Id.same_witness t.id self with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | Some _ ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      default","counters":[]},{"line":"  | None -> (","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      match t.kind with","counters":[]},{"line":"      | Compiled ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let (T (other_id, d)) = find univ.compiled (Type_equal.Id.uid t.id) in","counters":[{"col_start":70,"col_end":70,"count":0}]},{"line":"          let T = Type_equal.Id.same_witness_exn t.id other_id in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          f (`Compiled d)","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"      | Side_loaded ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let (T (other_id, d)) =","counters":[]},{"line":"            find univ.side_loaded (Type_equal.Id.uid t.id)","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"          in","counters":[]},{"line":"          let T = Type_equal.Id.same_witness_exn t.id other_id in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          f (`Side_loaded d) )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"let add_side_loaded ~name permanent =","counters":[]},{"line":"  let id = Type_equal.Id.create ~name sexp_of_opaque in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  Hashtbl.add_exn univ.side_loaded ~key:(Type_equal.Id.uid id)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"    ~data:(T (id, { ephemeral = None; permanent })) ;","counters":[]},{"line":"  { Tag.kind = Side_loaded; id }","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let set_ephemeral { Tag.kind; id } (eph : Side_loaded.Ephemeral.t) =","counters":[]},{"line":"  (match kind with Side_loaded -> () | _ -> failwith \"Expected Side_loaded\") ;","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"  Hashtbl.update univ.side_loaded (Type_equal.Id.uid id) ~f:(function","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"    | None ->","counters":[]},{"line":"        assert false","counters":[]},{"line":"    | Some (T (id, d)) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let ephemeral =","counters":[]},{"line":"          match (d.ephemeral, eph.index) with","counters":[]},{"line":"          | None, _ | Some _, `In_prover _ ->","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"              (* Giving prover only always resets. *)","counters":[]},{"line":"              Some eph","counters":[]},{"line":"          | Some { index = `In_prover prover }, `In_circuit circuit","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          | Some { index = `In_both (prover, _) }, `In_circuit circuit ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (* In-circuit extends prover if one was given. *)","counters":[]},{"line":"              Some { index = `In_both (prover, circuit) }","counters":[]},{"line":"          | _ ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (* Otherwise, just use the given value. *)","counters":[]},{"line":"              Some eph","counters":[]},{"line":"        in","counters":[]},{"line":"        T (id, { d with ephemeral }) )","counters":[]},{"line":"","counters":[]},{"line":"let add_exn (type var value c d) (tag : (var, value, c, d) Tag.t)","counters":[]},{"line":"    (data : (var, value, c, d) Compiled.t) =","counters":[]},{"line":"  Hashtbl.add_exn univ.compiled ~key:(Type_equal.Id.uid tag.id)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"    ~data:(Compiled.T (tag.id, data))","counters":[{"col_start":36,"col_end":36,"count":2}]}]}