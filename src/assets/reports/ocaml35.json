{"filename":"src/lib/pickles/step_verifier.ml","lines":[{"line":"(* q > p *)","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"open Core_kernel","counters":[]},{"line":"module SC = Scalar_challenge","counters":[]},{"line":"open Import","counters":[]},{"line":"open Util","counters":[]},{"line":"open Types.Step","counters":[]},{"line":"open Pickles_types","counters":[]},{"line":"open Common","counters":[]},{"line":"open Import","counters":[]},{"line":"module S = Sponge","counters":[]},{"line":"","counters":[]},{"line":"let lookup_verification_enabled = false","counters":[]},{"line":"","counters":[]},{"line":"module Make","counters":[]},{"line":"    (Inputs : Intf.Step_main_inputs.S","counters":[]},{"line":"                with type Impl.field = Backend.Tick.Field.t","counters":[]},{"line":"                 and type Impl.Bigint.t = Backend.Tick.Bigint.t","counters":[]},{"line":"                 and type Inner_curve.Constant.Scalar.t = Backend.Tock.Field.t) =","counters":[]},{"line":"struct","counters":[]},{"line":"  open Inputs","counters":[]},{"line":"  open Impl","counters":[]},{"line":"  module PC = Inner_curve","counters":[]},{"line":"  module Challenge = Challenge.Make (Impl)","counters":[]},{"line":"  module Digest = Digest.Make (Impl)","counters":[]},{"line":"  module Number = Snarky_backendless.Number.Run.Make (Impl)","counters":[]},{"line":"","counters":[]},{"line":"  (* Other_field.size > Field.size *)","counters":[]},{"line":"  module Other_field = struct","counters":[]},{"line":"    let size_in_bits = Field.size_in_bits","counters":[]},{"line":"","counters":[]},{"line":"    module Constant = Other_field","counters":[]},{"line":"","counters":[]},{"line":"    type t = Impls.Step.Other_field.t","counters":[]},{"line":"","counters":[]},{"line":"    let typ = Impls.Step.Other_field.typ","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let print_g lab (x, y) =","counters":[]},{"line":"    if debug then","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      as_prover","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        As_prover.(","counters":[]},{"line":"          fun () ->","counters":[]},{"line":"            printf","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              !\"%s: %{sexp:Backend.Tick.Field.t}, %{sexp:Backend.Tick.Field.t}\\n\\","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                %!\"","counters":[]},{"line":"              lab (read_var x) (read_var y))","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"  let print_chal lab chal =","counters":[]},{"line":"    if debug then","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      as_prover","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        As_prover.(","counters":[]},{"line":"          fun () ->","counters":[]},{"line":"            printf","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              !\"%s: %{sexp:Challenge.Constant.t}\\n%!\"","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"              lab (read Challenge.typ chal))","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"  let print_fp lab x =","counters":[]},{"line":"    if debug then","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      as_prover","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        As_prover.(","counters":[]},{"line":"          fun () ->","counters":[]},{"line":"            printf !\"%s: %{sexp:Backend.Tick.Field.t}\\n%!\" lab (read_var x))","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"","counters":[]},{"line":"  let print_bool lab x =","counters":[]},{"line":"    if debug then","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      as_prover (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          printf \"%s: %b\\n%!\" lab (As_prover.read Boolean.typ x) )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"","counters":[]},{"line":"  let equal_g g1 g2 =","counters":[]},{"line":"    List.map2_exn ~f:Field.equal","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":16,"col_end":16,"count":0}]},{"line":"      (Inner_curve.to_field_elements g1)","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"      (Inner_curve.to_field_elements g2)","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"    |> Boolean.all","counters":[]},{"line":"","counters":[]},{"line":"  let absorb sponge ty t =","counters":[]},{"line":"    absorb","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ~absorb_field:(fun x -> Sponge.absorb sponge (`Field x))","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"      ~g1_to_field_elements:Inner_curve.to_field_elements","counters":[]},{"line":"      ~absorb_scalar:(fun (x, (b : Boolean.var)) ->","counters":[]},{"line":"        Sponge.absorb sponge (`Field x) ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Sponge.absorb sponge (`Bits [ b ]) )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      ~mask_g1_opt:(fun ((b : Boolean.var), (x, y)) ->","counters":[]},{"line":"        Field.((b :> t) * x, (b :> t) * y) )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      ty t","counters":[]},{"line":"","counters":[]},{"line":"  let scalar_to_field s =","counters":[]},{"line":"    SC.to_field_checked (module Impl) s ~endo:Endo.Wrap_inner_curve.scalar","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let assert_n_bits ~n a =","counters":[]},{"line":"    (* Scalar_challenge.to_field_checked has the side effect of","counters":[]},{"line":"        checking that the input fits in n bits. *)","counters":[]},{"line":"    ignore","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ( SC.to_field_checked","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"          (module Impl)","counters":[]},{"line":"          (SC.SC.create a) ~endo:Endo.Wrap_inner_curve.scalar ~num_bits:n","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"        : Field.t )","counters":[]},{"line":"","counters":[]},{"line":"  let lowest_128_bits ~constrain_low_bits x =","counters":[]},{"line":"    let assert_128_bits = assert_n_bits ~n:128 in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Util.lowest_128_bits ~constrain_low_bits ~assert_128_bits (module Impl) x","counters":[]},{"line":"","counters":[]},{"line":"  module Scalar_challenge =","counters":[]},{"line":"    SC.Make (Impl) (Inner_curve) (Challenge) (Endo.Step_inner_curve)","counters":[]},{"line":"  module Ops = Step_main_inputs.Ops","counters":[]},{"line":"","counters":[]},{"line":"  module Inner_curve = struct","counters":[]},{"line":"    include Inner_curve","counters":[]},{"line":"","counters":[]},{"line":"    let ( + ) = Ops.add_fast","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Public_input_scalar = struct","counters":[]},{"line":"    type t = Field.t","counters":[]},{"line":"","counters":[]},{"line":"    let typ = Field.typ","counters":[]},{"line":"","counters":[]},{"line":"    module Constant = struct","counters":[]},{"line":"      include Field.Constant","counters":[]},{"line":"","counters":[]},{"line":"      let to_bigint = Impl.Bigint.of_field","counters":[]},{"line":"    end","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let multiscale_known","counters":[]},{"line":"      (ts :","counters":[]},{"line":"        ( [ `Field of Field.t | `Packed_bits of Field.t * int ]","counters":[]},{"line":"        * Inner_curve.Constant.t )","counters":[]},{"line":"        array ) =","counters":[]},{"line":"    let module F = Public_input_scalar in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let rec pow2pow x i =","counters":[]},{"line":"      if i = 0 then x else pow2pow Inner_curve.Constant.(x + x) (i - 1)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"    in","counters":[]},{"line":"    with_label __LOC__ (fun () ->","counters":[]},{"line":"        let constant_part, non_constant_part =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          List.partition_map (Array.to_list ts) ~f:(fun (t, g) ->","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"              match t with","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              | `Field (Constant c) | `Packed_bits (Constant c, _) ->","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"                  First","counters":[]},{"line":"                    ( if Field.Constant.(equal zero) c then None","counters":[{"col_start":45,"col_end":45,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"                    else if Field.Constant.(equal one) c then Some g","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":48,"col_end":48,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"                    else","counters":[]},{"line":"                      Some","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        (Inner_curve.Constant.scale g","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                           (Inner_curve.Constant.Scalar.project","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"                              (Field.Constant.unpack c) ) ) )","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"              | `Field x ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Second (`Field x, g)","counters":[]},{"line":"              | `Packed_bits (x, n) ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Second (`Packed_bits (x, n), g) )","counters":[]},{"line":"        in","counters":[]},{"line":"        let add_opt xo y =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Option.value_map xo ~default:y ~f:(fun x ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              Inner_curve.Constant.( + ) x y )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"        in","counters":[]},{"line":"        let constant_part =","counters":[]},{"line":"          List.filter_map constant_part ~f:Fn.id","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"          |> List.fold ~init:None ~f:(fun acc x -> Some (add_opt acc x))","counters":[{"col_start":51,"col_end":51,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"        in","counters":[]},{"line":"        let correction, acc =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          List.mapi non_constant_part ~f:(fun i (s, x) ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"              let rr, n =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                match s with","counters":[]},{"line":"                | `Packed_bits (s, n) ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    ( Ops.scale_fast2'","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                        (module F)","counters":[]},{"line":"                        (Inner_curve.constant x) s ~num_bits:n","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"                    , n )","counters":[]},{"line":"                | `Field s ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    ( Ops.scale_fast2'","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                        (module F)","counters":[]},{"line":"                        (Inner_curve.constant x) s ~num_bits:Field.size_in_bits","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"                    , Field.size_in_bits )","counters":[]},{"line":"              in","counters":[]},{"line":"              let n =","counters":[]},{"line":"                Ops.bits_per_chunk * Ops.chunks_needed ~num_bits:(n - 1)","counters":[]},{"line":"              in","counters":[]},{"line":"              let cc = pow2pow x n in","counters":[]},{"line":"              (cc, rr) )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"          |> List.reduce_exn ~f:(fun (a1, b1) (a2, b2) ->","counters":[]},{"line":"                 (Inner_curve.Constant.( + ) a1 a2, Inner_curve.( + ) b1 b2) )","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":43,"col_end":43,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"        in","counters":[]},{"line":"        Inner_curve.(","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          acc + constant (Constant.negate correction |> add_opt constant_part)) )","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"","counters":[]},{"line":"  let squeeze_challenge sponge : Field.t =","counters":[]},{"line":"    lowest_128_bits (Sponge.squeeze sponge) ~constrain_low_bits:true","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"","counters":[]},{"line":"  let squeeze_scalar sponge : Field.t SC.SC.t =","counters":[]},{"line":"    (* No need to boolean constrain scalar challenges. *)","counters":[]},{"line":"    SC.SC.create","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (lowest_128_bits ~constrain_low_bits:false (Sponge.squeeze sponge))","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"","counters":[]},{"line":"  let bullet_reduce sponge gammas =","counters":[]},{"line":"    with_label __LOC__ (fun () ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        let absorb t = absorb sponge t in","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"        let prechallenges =","counters":[]},{"line":"          Array.mapi gammas ~f:(fun i gammas_i ->","counters":[]},{"line":"              absorb (PC :: PC) gammas_i ;","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              squeeze_scalar sponge )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"        in","counters":[]},{"line":"        let term_and_challenge (l, r) pre =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let left_term = Scalar_challenge.endo_inv l pre in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let right_term = Scalar_challenge.endo r pre in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          ( Inner_curve.(left_term + right_term)","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          , { Bulletproof_challenge.prechallenge = pre } )","counters":[]},{"line":"        in","counters":[]},{"line":"        let terms, challenges =","counters":[]},{"line":"          Array.map2_exn gammas prechallenges ~f:term_and_challenge","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"          |> Array.unzip","counters":[]},{"line":"        in","counters":[]},{"line":"        (Array.reduce_exn terms ~f:Inner_curve.( + ), challenges) )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"","counters":[]},{"line":"  let group_map =","counters":[]},{"line":"    let f =","counters":[]},{"line":"      lazy","counters":[]},{"line":"        (let module M =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"           Group_map.Bw19.Make (Field.Constant) (Field)","counters":[]},{"line":"             (struct","counters":[]},{"line":"               let params =","counters":[]},{"line":"                 Group_map.Bw19.Params.create","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"                   (module Field.Constant)","counters":[]},{"line":"                   { b = Inner_curve.Params.b }","counters":[]},{"line":"             end)","counters":[]},{"line":"         in","counters":[]},{"line":"        let open M in","counters":[]},{"line":"        Snarky_group_map.Checked.wrap","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"          (module Impl)","counters":[]},{"line":"          ~potential_xs","counters":[]},{"line":"          ~y_squared:(fun ~x ->","counters":[]},{"line":"            Field.(","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (x * x * x)","counters":[]},{"line":"              + (constant Inner_curve.Params.a * x)","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"              + constant Inner_curve.Params.b) )","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"        |> unstage )","counters":[]},{"line":"    in","counters":[]},{"line":"    fun x -> Lazy.force f x","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"  let scale_fast p s =","counters":[]},{"line":"    with_label __LOC__ (fun () ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        Ops.scale_fast p s ~num_bits:Field.size_in_bits )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"  let scale_fast2 p (s : Other_field.t Shifted_value.Type2.t) =","counters":[]},{"line":"    with_label __LOC__ (fun () ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        Ops.scale_fast2 p s ~num_bits:Field.size_in_bits )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"  let check_bulletproof ~pcs_batch ~(sponge : Sponge.t) ~xi","counters":[]},{"line":"      ~(* Corresponds to y in figure 7 of WTS *)","counters":[]},{"line":"       (* sum_i r^i sum_j xi^j f_j(beta_i) *)","counters":[]},{"line":"      (advice : _ Bulletproof.Advice.t)","counters":[]},{"line":"      ~polynomials:(without_degree_bound, with_degree_bound)","counters":[]},{"line":"      ~opening:","counters":[]},{"line":"        ({ lr; delta; z_1; z_2; challenge_polynomial_commitment } :","counters":[]},{"line":"          (Inner_curve.t, Other_field.t Shifted_value.Type2.t) Bulletproof.t ) =","counters":[]},{"line":"    with_label \"check_bulletproof\" (fun () ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        absorb sponge Scalar","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ( match advice.combined_inner_product with","counters":[]},{"line":"          | Shifted_value.Type2.Shifted_value x ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              x ) ;","counters":[]},{"line":"        (* a_hat should be equal to","counters":[]},{"line":"           sum_i < t, r^i pows(beta_i) >","counters":[]},{"line":"           = sum_i r^i < t, pows(beta_i) > *)","counters":[]},{"line":"        let u =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let t = Sponge.squeeze_field sponge in","counters":[]},{"line":"          group_map t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"        in","counters":[]},{"line":"        let open Inner_curve in","counters":[]},{"line":"        let combined_polynomial (* Corresponds to xi in figure 7 of WTS *) =","counters":[]},{"line":"          with_label \"combined_polynomial\" (fun () ->","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"              Pcs_batch.combine_split_commitments pcs_batch","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ~scale_and_add:(fun ~(acc :","counters":[]},{"line":"                                       [ `Maybe_finite of","counters":[]},{"line":"                                         Boolean.var * Inner_curve.t","counters":[]},{"line":"                                       | `Finite of Inner_curve.t ] ) ~xi p ->","counters":[]},{"line":"                  match acc with","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  | `Maybe_finite (acc_is_finite, (acc : Inner_curve.t)) -> (","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      match p with","counters":[]},{"line":"                      | `Maybe_finite (p_is_finite, p) ->","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          let is_finite =","counters":[]},{"line":"                            Boolean.(p_is_finite ||| acc_is_finite)","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                          in","counters":[]},{"line":"                          let xi_acc = Scalar_challenge.endo acc xi in","counters":[]},{"line":"                          `Maybe_finite","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            ( is_finite","counters":[]},{"line":"                            , if_ acc_is_finite ~then_:(p + xi_acc) ~else_:p )","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                      | `Finite p ->","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          let xi_acc = Scalar_challenge.endo acc xi in","counters":[]},{"line":"                          `Finite","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            (if_ acc_is_finite ~then_:(p + xi_acc) ~else_:p) )","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                  | `Finite acc ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      let xi_acc = Scalar_challenge.endo acc xi in","counters":[]},{"line":"                      `Finite","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        ( match p with","counters":[]},{"line":"                        | `Finite p ->","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            p + xi_acc","counters":[]},{"line":"                        | `Maybe_finite (p_is_finite, p) ->","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            if_ p_is_finite ~then_:(p + xi_acc) ~else_:xi_acc )","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                  )","counters":[]},{"line":"                ~xi","counters":[]},{"line":"                ~init:(function","counters":[]},{"line":"                  | `Finite x -> `Finite x | `Maybe_finite x -> `Maybe_finite x","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"                  )","counters":[]},{"line":"                (Vector.map without_degree_bound","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                   ~f:(Array.map ~f:(fun x -> `Finite x)) )","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"                (Vector.map with_degree_bound","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                   ~f:","counters":[]},{"line":"                     (let open Plonk_types.Poly_comm.With_degree_bound in","counters":[]},{"line":"                     fun { shifted; unshifted } ->","counters":[]},{"line":"                       let f x = `Maybe_finite x in","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"                       { unshifted = Array.map ~f unshifted","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"                       ; shifted = f shifted","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                       }) ) )","counters":[]},{"line":"          |> function `Finite x -> x | `Maybe_finite _ -> assert false","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"        in","counters":[]},{"line":"        let lr_prod, challenges = bullet_reduce sponge lr in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let p_prime =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let uc = scale_fast2 u advice.combined_inner_product in","counters":[]},{"line":"          combined_polynomial + uc","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        in","counters":[]},{"line":"        let q = p_prime + lr_prod in","counters":[]},{"line":"        absorb sponge PC delta ;","counters":[]},{"line":"        let c = squeeze_scalar sponge in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        print_fp \"c\" c.inner ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        (* c Q + delta = z1 (G + b U) + z2 H *)","counters":[]},{"line":"        let lhs =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let cq = Scalar_challenge.endo q c in","counters":[]},{"line":"          cq + delta","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        in","counters":[]},{"line":"        let rhs =","counters":[]},{"line":"          with_label __LOC__ (fun () ->","counters":[]},{"line":"              let b_u = scale_fast2 u advice.b in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              let z_1_g_plus_b_u =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                scale_fast2 (challenge_polynomial_commitment + b_u) z_1","counters":[]},{"line":"              in","counters":[]},{"line":"              let z2_h =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                scale_fast2 (Inner_curve.constant (Lazy.force Generators.h)) z_2","counters":[{"col_start":48,"col_end":48,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"              in","counters":[]},{"line":"              z_1_g_plus_b_u + z2_h )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"        in","counters":[]},{"line":"        (`Success (equal_g lhs rhs), challenges) )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"  let assert_eq_deferred_values","counters":[]},{"line":"      (m1 :","counters":[]},{"line":"        ( 'a","counters":[]},{"line":"        , Inputs.Impl.Field.t Import.Scalar_challenge.t )","counters":[]},{"line":"        Types.Step.Proof_state.Deferred_values.Plonk.Minimal.t )","counters":[]},{"line":"      (m2 :","counters":[]},{"line":"        ( Inputs.Impl.Field.t","counters":[]},{"line":"        , Inputs.Impl.Field.t Import.Scalar_challenge.t )","counters":[]},{"line":"        Types.Step.Proof_state.Deferred_values.Plonk.Minimal.t ) =","counters":[]},{"line":"    let open Types.Wrap.Proof_state.Deferred_values.Plonk.Minimal in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let chal c1 c2 = Field.Assert.equal c1 c2 in","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"    let scalar_chal ({ SC.SC.inner = t1 } : _ Import.Scalar_challenge.t)","counters":[]},{"line":"        ({ SC.SC.inner = t2 } : _ Import.Scalar_challenge.t) =","counters":[]},{"line":"      Field.Assert.equal t1 t2","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    in","counters":[]},{"line":"    with_label __LOC__ (fun () -> chal m1.beta m2.beta) ;","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"    with_label __LOC__ (fun () -> chal m1.gamma m2.gamma) ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"    with_label __LOC__ (fun () -> scalar_chal m1.alpha m2.alpha) ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"    with_label __LOC__ (fun () -> scalar_chal m1.zeta m2.zeta)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"","counters":[]},{"line":"  let lagrange_commitment ~domain i =","counters":[]},{"line":"    let d =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Kimchi_pasta.Pasta.Precomputed.Lagrange_precomputations","counters":[]},{"line":"      .index_of_domain_log2 (Domain.log2_size domain)","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"    in","counters":[]},{"line":"    match Precomputed.Lagrange_precomputations.pallas.(d).(i) with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | [| g |] ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Inner_curve.Constant.of_affine g","counters":[]},{"line":"    | _ ->","counters":[]},{"line":"        assert false","counters":[]},{"line":"","counters":[]},{"line":"  module O = One_hot_vector.Make (Impl)","counters":[]},{"line":"  open Tuple_lib","counters":[]},{"line":"","counters":[]},{"line":"  let public_input_commitment_dynamic (type n) (which : n O.t)","counters":[]},{"line":"      (domains : (Domains.t, n) Vector.t)","counters":[]},{"line":"      ~(public_input :","counters":[]},{"line":"         [ `Field of Field.t | `Packed_bits of Field.t * int ] array ) =","counters":[]},{"line":"    (*","counters":[]},{"line":"    let domains : (Domains.t, Nat.N3.n) Vector.t =","counters":[]},{"line":"      Vector.map ~f:(fun proofs_verified -> Common.wrap_domains ~proofs_verified)","counters":[]},{"line":"        [ 0; 1 ; 2 ]","counters":[]},{"line":"    in *)","counters":[]},{"line":"    let precomputations = Precomputed.Lagrange_precomputations.pallas in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let lagrange_commitment (d : Domains.t) (i : int) : Inner_curve.Constant.t =","counters":[]},{"line":"      let d =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Precomputed.Lagrange_precomputations.index_of_domain_log2","counters":[]},{"line":"          (Domain.log2_size d.h)","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"      in","counters":[]},{"line":"      match precomputations.(d).(i) with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | [| g |] ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Inner_curve.Constant.of_affine g","counters":[]},{"line":"      | _ ->","counters":[]},{"line":"          assert false","counters":[]},{"line":"    in","counters":[]},{"line":"    let select_curve_points (type k)","counters":[]},{"line":"        ~(points_for_domain : Domains.t -> (Inner_curve.Constant.t, k) Vector.t)","counters":[]},{"line":"        : (Inner_curve.t, k) Vector.t =","counters":[]},{"line":"      match domains with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | [] ->","counters":[]},{"line":"          assert false","counters":[]},{"line":"      | d :: ds ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          if Vector.for_all ds ~f:(fun d' -> Domain.equal d.h d'.h) then","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"            Vector.map ~f:Inner_curve.constant (points_for_domain d)","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"          else","counters":[]},{"line":"            Vector.map2","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"              (which :> (Boolean.var, n) Vector.t)","counters":[]},{"line":"              domains","counters":[]},{"line":"              ~f:(fun b d ->","counters":[]},{"line":"                let points = points_for_domain d in","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                Vector.map points ~f:(fun g ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                    let x, y = Inner_curve.constant g in","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                    Field.((b :> t) * x, (b :> t) * y) ) )","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"            |> Vector.reduce_exn","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                 ~f:(Vector.map2 ~f:(Double.map2 ~f:Field.( + )))","counters":[]},{"line":"            |> Vector.map ~f:(Double.map ~f:(Util.seal (module Impl)))","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"    in","counters":[]},{"line":"    let lagrange i =","counters":[]},{"line":"      select_curve_points ~points_for_domain:(fun d ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          [ lagrange_commitment d i ] )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"      |> Vector.unsingleton","counters":[]},{"line":"    in","counters":[]},{"line":"    let lagrange_with_correction (type n) ~input_length i :","counters":[]},{"line":"        (Inner_curve.t, Nat.N2.n) Vector.t =","counters":[]},{"line":"      let actual_shift =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (* TODO: num_bits should maybe be input_length - 1. *)","counters":[]},{"line":"        Ops.bits_per_chunk * Ops.chunks_needed ~num_bits:input_length","counters":[]},{"line":"      in","counters":[]},{"line":"      let rec pow2pow x i =","counters":[]},{"line":"        if i = 0 then x else pow2pow Inner_curve.Constant.(x + x) (i - 1)","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"      in","counters":[]},{"line":"      select_curve_points ~points_for_domain:(fun d ->","counters":[]},{"line":"          let g = lagrange_commitment d i in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let open Inner_curve.Constant in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          [ g; negate (pow2pow g actual_shift) ] )","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"    in","counters":[]},{"line":"    let x_hat =","counters":[]},{"line":"      let constant_part, non_constant_part =","counters":[]},{"line":"        List.partition_map","counters":[]},{"line":"          (Array.to_list (Array.mapi ~f:(fun i t -> (i, t)) public_input))","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"          ~f:(fun (i, t) ->","counters":[]},{"line":"            match t with","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            | `Field (Constant c) | `Packed_bits (Constant c, _) ->","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"                First","counters":[]},{"line":"                  ( if Field.Constant.(equal zero) c then None","counters":[{"col_start":43,"col_end":43,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"                  else if Field.Constant.(equal one) c then Some (lagrange i)","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":46,"col_end":46,"count":0},{"col_start":60,"col_end":60,"count":0},{"col_start":73,"col_end":73,"count":0}]},{"line":"                  else","counters":[]},{"line":"                    Some","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      ( select_curve_points ~points_for_domain:(fun d ->","counters":[]},{"line":"                            [ Inner_curve.Constant.scale","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"                                (lagrange_commitment d i)","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                                (Inner_curve.Constant.Scalar.project","counters":[{"col_start":67,"col_end":67,"count":0}]},{"line":"                                   (Field.Constant.unpack c) )","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"                            ] )","counters":[]},{"line":"                      |> Vector.unsingleton ) )","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"            | `Field x ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Second (i, (x, Public_input_scalar.Constant.size_in_bits))","counters":[]},{"line":"            | `Packed_bits (x, n) ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Second (i, (x, n)) )","counters":[]},{"line":"      in","counters":[]},{"line":"      let terms =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        List.map non_constant_part ~f:(fun (i, x) ->","counters":[]},{"line":"            match x with","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            | b, 1 ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                assert_ (Constraint.boolean (b :> Field.t)) ;","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"                `Cond_add (Boolean.Unsafe.of_cvar b, lagrange i)","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":48,"col_end":48,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"            | x, n ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                `Add_with_correction","counters":[]},{"line":"                  ((x, n), lagrange_with_correction ~input_length:n i) )","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"      in","counters":[]},{"line":"      let correction =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        List.reduce_exn","counters":[]},{"line":"          (List.filter_map terms ~f:(function","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"            | `Cond_add _ ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                None","counters":[]},{"line":"            | `Add_with_correction (_, [ _; corr ]) ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Some corr ) )","counters":[]},{"line":"          ~f:Ops.add_fast","counters":[]},{"line":"      in","counters":[]},{"line":"      let init =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        List.fold","counters":[]},{"line":"          (List.filter_map constant_part ~f:Fn.id)","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"          ~init:correction ~f:Ops.add_fast","counters":[]},{"line":"      in","counters":[]},{"line":"      List.fold terms ~init ~f:(fun acc term ->","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":14,"col_end":14,"count":0}]},{"line":"          match term with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | `Cond_add (b, g) ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              with_label __LOC__ (fun () ->","counters":[]},{"line":"                  Inner_curve.if_ b ~then_:(Ops.add_fast g acc) ~else_:acc )","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"          | `Add_with_correction ((x, num_bits), [ g; _ ]) ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Ops.add_fast acc","counters":[]},{"line":"                (Ops.scale_fast2' (module Public_input_scalar) g x ~num_bits) )","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"      |> Inner_curve.negate","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"    in","counters":[]},{"line":"    x_hat","counters":[]},{"line":"","counters":[]},{"line":"  let incrementally_verify_proof (type b)","counters":[]},{"line":"      (module Proofs_verified : Nat.Add.Intf with type n = b)","counters":[]},{"line":"      ~(domain :","counters":[]},{"line":"         [ `Known of Domain.t","counters":[]},{"line":"         | `Side_loaded of","counters":[]},{"line":"           _ Composition_types.Branch_data.Proofs_verified.One_hot.Checked.t ]","counters":[]},{"line":"         ) ~verification_key:(m : _ Plonk_verification_key_evals.t) ~xi ~sponge","counters":[]},{"line":"      ~sponge_after_index","counters":[]},{"line":"      ~(public_input :","counters":[]},{"line":"         [ `Field of Field.t | `Packed_bits of Field.t * int ] array )","counters":[]},{"line":"      ~(sg_old : (_, Proofs_verified.n) Vector.t) ~advice","counters":[]},{"line":"      ~proof:({ messages; opening } : Wrap_proof.Checked.t)","counters":[]},{"line":"      ~(plonk :","counters":[]},{"line":"         ( _","counters":[]},{"line":"         , _","counters":[]},{"line":"         , _ Shifted_value.Type2.t","counters":[]},{"line":"         , _ )","counters":[]},{"line":"         Types.Wrap.Proof_state.Deferred_values.Plonk.In_circuit.t ) =","counters":[]},{"line":"    with_label \"incrementally_verify_proof\" (fun () ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        let receive ty f =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          with_label \"receive\" (fun () ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              let x = f messages in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              absorb sponge ty x ; x )","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"        in","counters":[]},{"line":"        let sample () = squeeze_challenge sponge in","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"        let sample_scalar () = squeeze_scalar sponge in","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"        let open Plonk_types.Messages.In_circuit in","counters":[]},{"line":"        let without = Type.Without_degree_bound in","counters":[]},{"line":"        let absorb_g gs = absorb sponge without gs in","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"        let index_digest =","counters":[]},{"line":"          with_label \"absorb verifier index\" (fun () ->","counters":[]},{"line":"              let index_sponge = Sponge.copy sponge_after_index in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              Sponge.squeeze_field index_sponge )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"        in","counters":[]},{"line":"        absorb sponge Field index_digest ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let sg_old : (_, Wrap_hack.Padded_length.n) Vector.t =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Wrap_hack.Checked.pad_commitments sg_old","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"        in","counters":[]},{"line":"        Vector.iter ~f:(absorb sponge PC) sg_old ;","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"        let x_hat =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          with_label \"x_hat\" (fun () ->","counters":[]},{"line":"              match domain with","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              | `Known domain ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  multiscale_known","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"                    (Array.mapi public_input ~f:(fun i x ->","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                         (x, lagrange_commitment ~domain i) ) )","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"                  |> Inner_curve.negate","counters":[]},{"line":"              | `Side_loaded which ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  public_input_commitment_dynamic which","counters":[]},{"line":"                    (Vector.map","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                       ~f:(fun proofs_verified ->","counters":[]},{"line":"                         Common.wrap_domains ~proofs_verified )","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                       [ 0; 1; 2 ] )","counters":[]},{"line":"                    ~public_input )","counters":[]},{"line":"        in","counters":[]},{"line":"        let x_hat =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          with_label \"x_hat blinding\" (fun () ->","counters":[]},{"line":"              Ops.add_fast x_hat","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (Inner_curve.constant (Lazy.force Generators.h)) )","counters":[{"col_start":36,"col_end":36,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"        in","counters":[]},{"line":"        absorb sponge PC x_hat ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let w_comm = messages.w_comm in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Vector.iter ~f:absorb_g w_comm ;","counters":[]},{"line":"        let beta = sample () in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let gamma = sample () in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let z_comm = receive without z_comm in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let alpha = sample_scalar () in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let t_comm = receive without t_comm in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let zeta = sample_scalar () in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        (* At this point, we should use the previous \"bulletproof_challenges\" to","counters":[]},{"line":"           compute to compute f(beta_1) outside the snark","counters":[]},{"line":"           where f is the polynomial corresponding to sg_old","counters":[]},{"line":"        *)","counters":[]},{"line":"        let sponge_before_evaluations = Sponge.copy sponge in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let sponge_digest_before_evaluations = Sponge.squeeze_field sponge in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"        (* xi, r are sampled here using the other sponge. *)","counters":[]},{"line":"        (* No need to expose the polynomial evaluations as deferred values as they're","counters":[]},{"line":"           not needed here for the incremental verification. All we need is a_hat and","counters":[]},{"line":"           \"combined_inner_product\".","counters":[]},{"line":"","counters":[]},{"line":"           Then, in the other proof, we can witness the evaluations and check their correctness","counters":[]},{"line":"           against \"combined_inner_product\" *)","counters":[]},{"line":"        let sigma_comm_init, [ _ ] =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Vector.split m.sigma_comm","counters":[]},{"line":"            (snd (Plonk_types.Permuts_minus_1.add Nat.N1.n))","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"        in","counters":[]},{"line":"        let ft_comm =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          with_label __LOC__ (fun () ->","counters":[]},{"line":"              Common.ft_comm ~add:Ops.add_fast ~scale:scale_fast2","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ~negate:Inner_curve.negate ~endoscale:Scalar_challenge.endo","counters":[]},{"line":"                ~verification_key:m ~plonk ~alpha ~t_comm )","counters":[]},{"line":"        in","counters":[]},{"line":"        let bulletproof_challenges =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (* This sponge needs to be initialized with (some derivative of)","counters":[]},{"line":"             1. The polynomial commitments","counters":[]},{"line":"             2. The combined inner product","counters":[]},{"line":"             3. The challenge points.","counters":[]},{"line":"","counters":[]},{"line":"             It should be sufficient to fork the sponge after squeezing beta_3 and then to absorb","counters":[]},{"line":"             the combined inner product.","counters":[]},{"line":"          *)","counters":[]},{"line":"          let num_commitments_without_degree_bound = Nat.N26.n in","counters":[]},{"line":"          let without_degree_bound =","counters":[]},{"line":"            Vector.append","counters":[]},{"line":"              (Vector.map sg_old ~f:(fun g -> [| g |]))","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"              ( [| x_hat |] :: [| ft_comm |] :: z_comm :: [| m.generic_comm |]","counters":[]},{"line":"              :: [| m.psm_comm |]","counters":[]},{"line":"              :: Vector.append w_comm","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                   (Vector.map sigma_comm_init ~f:(fun g -> [| g |]))","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"                   (snd Plonk_types.(Columns.add Permuts_minus_1.n)) )","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"              (snd","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                 (Wrap_hack.Padded_length.add","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"                    num_commitments_without_degree_bound ) )","counters":[]},{"line":"          in","counters":[]},{"line":"          with_label \"check_bulletproof\" (fun () ->","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"              check_bulletproof","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ~pcs_batch:","counters":[]},{"line":"                  (Common.dlog_pcs_batch","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"                     (Wrap_hack.Padded_length.add","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"                        num_commitments_without_degree_bound ) )","counters":[]},{"line":"                ~sponge:sponge_before_evaluations ~xi ~advice ~opening","counters":[]},{"line":"                ~polynomials:(without_degree_bound, []) )","counters":[]},{"line":"        in","counters":[]},{"line":"        let joint_combiner =","counters":[]},{"line":"          if lookup_verification_enabled then failwith \"TODO\" else None","counters":[{"col_start":46,"col_end":46,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"        in","counters":[]},{"line":"        assert_eq_deferred_values","counters":[]},{"line":"          { alpha = plonk.alpha","counters":[]},{"line":"          ; beta = plonk.beta","counters":[]},{"line":"          ; gamma = plonk.gamma","counters":[]},{"line":"          ; zeta = plonk.zeta","counters":[]},{"line":"          ; joint_combiner","counters":[]},{"line":"          }","counters":[]},{"line":"          { alpha; beta; gamma; zeta; joint_combiner } ;","counters":[]},{"line":"        (sponge_digest_before_evaluations, bulletproof_challenges) )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"  let compute_challenges ~scalar chals =","counters":[]},{"line":"    with_label \"compute_challenges\" (fun () ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        Vector.map chals ~f:(fun { Bulletproof_challenge.prechallenge } ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            scalar prechallenge ) )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"","counters":[]},{"line":"  let challenge_polynomial =","counters":[]},{"line":"    Field.(Wrap_verifier.challenge_polynomial ~add ~mul ~one)","counters":[]},{"line":"","counters":[]},{"line":"  module Pseudo = Pseudo.Make (Impl)","counters":[]},{"line":"","counters":[]},{"line":"  module Bounded = struct","counters":[]},{"line":"    type t = { max : int; actual : Field.t }","counters":[]},{"line":"","counters":[]},{"line":"    let of_pseudo ((_, ns) as p : _ Pseudo.t) =","counters":[]},{"line":"      { max = Vector.reduce_exn ~f:Int.max ns","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"      ; actual = Pseudo.choose p ~f:Field.of_int","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"      }","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let vanishing_polynomial mask =","counters":[]},{"line":"    with_label \"vanishing_polynomial\" (fun () ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        let mask = Vector.to_array mask in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let max = Array.length mask in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        fun x ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let rec go acc i =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            if i >= max then acc","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"            else","counters":[]},{"line":"              let should_square = mask.(i) in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              let acc =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Field.if_ should_square ~then_:(Field.square acc) ~else_:acc","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"              in","counters":[]},{"line":"              go acc (i + 1)","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"          in","counters":[]},{"line":"          Field.sub (go x 0) Field.one )","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"  let shifts ~log2_size = Common.tick_shifts ~log2_size","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"","counters":[]},{"line":"  let domain_generator ~log2_size =","counters":[]},{"line":"    Backend.Tick.Field.domain_generator ~log2_size |> Impl.Field.constant","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let side_loaded_domain (type branches) =","counters":[]},{"line":"    let open Side_loaded_verification_key in","counters":[]},{"line":"    fun ~(log2_size : Field.t) ->","counters":[]},{"line":"      let domain ~max =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let (T max_n) = Nat.of_int max in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let mask = ones_vector (module Impl) max_n ~first_zero:log2_size in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let log2_sizes =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ( O.of_index log2_size ~length:(S max_n)","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"          , Vector.init (S max_n) ~f:Fn.id )","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"        in","counters":[]},{"line":"        let shifts = Pseudo.Domain.shifts log2_sizes ~shifts in","counters":[]},{"line":"        let generator = Pseudo.Domain.generator log2_sizes ~domain_generator in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let vanishing_polynomial = vanishing_polynomial mask in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        object","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          method log2_size = log2_size","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"          method vanishing_polynomial x = vanishing_polynomial x","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"","counters":[]},{"line":"          method shifts = shifts","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"","counters":[]},{"line":"          method generator = generator","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"        end","counters":[]},{"line":"      in","counters":[]},{"line":"      domain ~max:(Domain.log2_size max_domains.h)","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"","counters":[]},{"line":"  let%test_module \"side loaded domains\" =","counters":[]},{"line":"    ( module struct","counters":[]},{"line":"      let run k =","counters":[]},{"line":"        let y =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          run_and_check (fun () ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"              let y = k () in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              fun () -> As_prover.read_var y )","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"          |> Or_error.ok_exn","counters":[]},{"line":"        in","counters":[]},{"line":"        y","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      let%test_unit \"side loaded domains\" =","counters":[]},{"line":"        let module O = One_hot_vector.Make (Impl) in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let open Side_loaded_verification_key in","counters":[]},{"line":"        let domains = [ { Domains.h = 10 }; { h = 15 } ] in","counters":[]},{"line":"        let pt = Field.Constant.random () in","counters":[]},{"line":"        List.iteri domains ~f:(fun i ds ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            let d_unchecked =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Plonk_checks.domain","counters":[]},{"line":"                (module Field.Constant)","counters":[]},{"line":"                (Pow_2_roots_of_unity ds.h) ~shifts:Common.tick_shifts","counters":[]},{"line":"                ~domain_generator:Backend.Tick.Field.domain_generator","counters":[]},{"line":"            in","counters":[]},{"line":"            let checked_domain () =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              side_loaded_domain ~log2_size:(Field.of_int ds.h)","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"            in","counters":[]},{"line":"            [%test_eq: Field.Constant.t]","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"              (d_unchecked#vanishing_polynomial pt)","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"              (run (fun () ->","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                   (checked_domain ())#vanishing_polynomial (Field.constant pt) )","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":74,"col_end":74,"count":0}]},{"line":"              ) )","counters":[]},{"line":"    end )","counters":[]},{"line":"","counters":[]},{"line":"  module Split_evaluations = struct","counters":[]},{"line":"    open Plonk_types","counters":[]},{"line":"","counters":[]},{"line":"    let mask' { Bounded.max; actual } : Boolean.var array =","counters":[]},{"line":"      let (T max) = Nat.of_int max in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Vector.to_array (ones_vector (module Impl) ~first_zero:actual max)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"","counters":[]},{"line":"    let mask (type n) ~(lengths : (int, n) Vector.t)","counters":[]},{"line":"        (choice : n One_hot_vector.T(Impl).t) : Boolean.var array =","counters":[]},{"line":"      let max =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Option.value_exn","counters":[]},{"line":"          (List.max_elt ~compare:Int.compare (Vector.to_list lengths))","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"      in","counters":[]},{"line":"      let actual = Pseudo.choose (choice, lengths) ~f:Field.of_int in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      mask' { max; actual }","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let last =","counters":[]},{"line":"      Array.reduce_exn ~f:(fun (b_acc, x_acc) (b, x) ->","counters":[]},{"line":"          (Boolean.(b_acc ||| b), Field.if_ b ~then_:x ~else_:x_acc) )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"","counters":[]},{"line":"    let rec pow x bits_lsb =","counters":[]},{"line":"      with_label \"pow\" (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          let rec go acc bs =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            match bs with","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            | [] ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                acc","counters":[]},{"line":"            | b :: bs ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                let acc = Field.square acc in","counters":[]},{"line":"                let acc = Field.if_ b ~then_:Field.(x * acc) ~else_:acc in","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                go acc bs","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"          in","counters":[]},{"line":"          go Field.one (List.rev bits_lsb) )","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"","counters":[]},{"line":"    let mod_max_degree =","counters":[]},{"line":"      let k = Nat.to_int Backend.Tick.Rounds.n in","counters":[]},{"line":"      fun d ->","counters":[{"col_start":6,"col_end":6,"count":1}]},{"line":"        let d = Number.of_bits (Field.unpack ~length:max_log2_degree d) in","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"        Number.mod_pow_2 d (`Two_to_the k)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"    let mask_evals (type n) ~(lengths : (int, n) Vector.t Evals.t)","counters":[]},{"line":"        (choice : n One_hot_vector.T(Impl).t) (e : Field.t array Evals.t) :","counters":[]},{"line":"        (Boolean.var * Field.t) array Evals.t =","counters":[]},{"line":"      Evals.map2 lengths e ~f:(fun lengths e ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          Array.zip_exn (mask ~lengths choice) e )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let absorb_field sponge x = Sponge.absorb sponge (`Field x)","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"","counters":[]},{"line":"  (* pt^{2^n} *)","counters":[]},{"line":"  let pow2_pow (pt : Field.t) (n : int) : Field.t =","counters":[]},{"line":"    with_label \"pow2_pow\" (fun () ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        let rec go acc i =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          if i = 0 then acc else go (Field.square acc) (i - 1)","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"        in","counters":[]},{"line":"        go pt n )","counters":[]},{"line":"","counters":[]},{"line":"  let actual_evaluation (e : Field.t array) ~(pt_to_n : Field.t) : Field.t =","counters":[]},{"line":"    with_label \"actual_evaluation\" (fun () ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        match List.rev (Array.to_list e) with","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"        | e :: es ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            List.fold ~init:e es ~f:(fun acc fx -> Field.(fx + (pt_to_n * acc)))","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"        | [] ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Field.zero )","counters":[]},{"line":"","counters":[]},{"line":"  open Plonk_types","counters":[]},{"line":"","counters":[]},{"line":"  module Opt_sponge = struct","counters":[]},{"line":"    include Opt_sponge.Make (Impl) (Step_main_inputs.Sponge.Permutation)","counters":[]},{"line":"","counters":[]},{"line":"    let squeeze_challenge sponge : Field.t =","counters":[]},{"line":"      lowest_128_bits (squeeze sponge) ~constrain_low_bits:true","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let shift1 =","counters":[]},{"line":"    Shifted_value.Type1.Shift.(","counters":[]},{"line":"      map ~f:Field.constant (create (module Field.Constant)))","counters":[{"col_start":8,"col_end":8,"count":1},{"col_start":34,"col_end":34,"count":1}]},{"line":"","counters":[]},{"line":"  let shift2 =","counters":[]},{"line":"    Shifted_value.Type2.Shift.(","counters":[]},{"line":"      map ~f:Field.constant (create (module Field.Constant)))","counters":[{"col_start":8,"col_end":8,"count":1},{"col_start":34,"col_end":34,"count":1}]},{"line":"","counters":[]},{"line":"  let%test_unit \"endo scalar\" =","counters":[]},{"line":"    SC.test (module Impl) ~endo:Endo.Wrap_inner_curve.scalar","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  module Plonk = Types.Wrap.Proof_state.Deferred_values.Plonk","counters":[]},{"line":"","counters":[]},{"line":"  module Plonk_checks = struct","counters":[]},{"line":"    include Plonk_checks","counters":[]},{"line":"","counters":[]},{"line":"    include","counters":[]},{"line":"      Plonk_checks.Make","counters":[]},{"line":"        (Shifted_value.Type1)","counters":[]},{"line":"        (struct","counters":[]},{"line":"          let constant_term = Plonk_checks.Scalars.Tick.constant_term","counters":[]},{"line":"","counters":[]},{"line":"          let index_terms = Plonk_checks.Scalars.Tick_with_lookup.index_terms","counters":[]},{"line":"        end)","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let domain_for_compiled (type branches)","counters":[]},{"line":"      (domains : (Domains.t, branches) Vector.t)","counters":[]},{"line":"      (branch_data : Impl.field Branch_data.Checked.t) :","counters":[]},{"line":"      Field.t Plonk_checks.plonk_domain =","counters":[]},{"line":"    let (T unique_domains) =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      List.map (Vector.to_list domains) ~f:Domains.h","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"      |> List.dedup_and_sort ~compare:(fun d1 d2 ->","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"             Int.compare (Domain.log2_size d1) (Domain.log2_size d2) )","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"      |> Vector.of_list","counters":[]},{"line":"    in","counters":[]},{"line":"    let which_log2 =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Vector.map unique_domains ~f:(fun d ->","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"          Field.equal","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (Field.of_int (Domain.log2_size d))","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"            branch_data.domain_log2 )","counters":[]},{"line":"      |> O.of_vector_unsafe","counters":[]},{"line":"      (* This should be ok... think it through a little more *)","counters":[]},{"line":"    in","counters":[]},{"line":"    Pseudo.Domain.to_domain","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (which_log2, unique_domains)","counters":[]},{"line":"      ~shifts ~domain_generator","counters":[]},{"line":"","counters":[]},{"line":"  let field_array_if b ~then_ ~else_ =","counters":[]},{"line":"    Array.map2_exn then_ else_ ~f:(fun x1 x2 -> Field.if_ b ~then_:x1 ~else_:x2)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"","counters":[]},{"line":"  (* This finalizes the \"deferred values\" coming from a previous proof over the same field.","counters":[]},{"line":"     It","counters":[]},{"line":"     1. Checks that [xi] and [r] where sampled correctly. I.e., by absorbing all the","counters":[]},{"line":"     evaluation openings and then squeezing.","counters":[]},{"line":"     2. Checks that the \"combined inner product\" value used in the elliptic curve part of","counters":[]},{"line":"     the opening proof was computed correctly, in terms of the evaluation openings and the","counters":[]},{"line":"     evaluation points.","counters":[]},{"line":"     3. Check that the \"b\" value was computed correctly.","counters":[]},{"line":"     4. Perform the arithmetic checks from marlin. *)","counters":[]},{"line":"  (* TODO: This needs to handle the fact of variable length evaluations.","counters":[]},{"line":"     Meaning it needs opt sponge. *)","counters":[]},{"line":"  let finalize_other_proof (type b branches)","counters":[]},{"line":"      (module Proofs_verified : Nat.Add.Intf with type n = b)","counters":[]},{"line":"      ~(step_uses_lookup : Plonk_types.Opt.Flag.t)","counters":[]},{"line":"      ~(step_domains :","counters":[]},{"line":"         [ `Known of (Domains.t, branches) Vector.t | `Side_loaded ] )","counters":[]},{"line":"      ~(* TODO: Add \"actual proofs verified\" so that proofs don't","counters":[]},{"line":"          carry around dummy \"old bulletproof challenges\" *)","counters":[]},{"line":"       sponge ~(prev_challenges : (_, b) Vector.t)","counters":[]},{"line":"      ({ xi","counters":[]},{"line":"       ; combined_inner_product","counters":[]},{"line":"       ; bulletproof_challenges","counters":[]},{"line":"       ; branch_data","counters":[]},{"line":"       ; b","counters":[]},{"line":"       ; plonk","counters":[]},{"line":"       } :","counters":[]},{"line":"        ( Field.t","counters":[]},{"line":"        , _","counters":[]},{"line":"        , Field.t Shifted_value.Type1.t","counters":[]},{"line":"        , _","counters":[]},{"line":"        , _","counters":[]},{"line":"        , Field.Constant.t Branch_data.Checked.t )","counters":[]},{"line":"        Types.Wrap.Proof_state.Deferred_values.In_circuit.t )","counters":[]},{"line":"      { Plonk_types.All_evals.In_circuit.ft_eval1; evals } =","counters":[]},{"line":"    let open Vector in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let actual_width_mask = branch_data.proofs_verified_mask in","counters":[]},{"line":"    let T = Proofs_verified.eq in","counters":[]},{"line":"    (* You use the NEW bulletproof challenges to check b. Not the old ones. *)","counters":[]},{"line":"    let scalar =","counters":[]},{"line":"      SC.to_field_checked (module Impl) ~endo:Endo.Wrap_inner_curve.scalar","counters":[]},{"line":"    in","counters":[]},{"line":"    let plonk =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Types.Step.Proof_state.Deferred_values.Plonk.In_circuit.map_challenges","counters":[]},{"line":"        ~f:Fn.id ~scalar plonk","counters":[]},{"line":"    in","counters":[]},{"line":"    let domain =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      match step_domains with","counters":[]},{"line":"      | `Known ds ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          domain_for_compiled ds branch_data","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"      | `Side_loaded ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ( side_loaded_domain ~log2_size:branch_data.domain_log2","counters":[]},{"line":"            :> _ Plonk_checks.plonk_domain )","counters":[]},{"line":"    in","counters":[]},{"line":"    let zetaw = Field.mul domain#generator plonk.zeta in","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"    let sg_olds =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      with_label \"sg_olds\" (fun () ->","counters":[]},{"line":"          Vector.map prev_challenges ~f:(fun chals ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              unstage (challenge_polynomial (Vector.to_array chals)) ) )","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":42,"col_end":42,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"    in","counters":[]},{"line":"    let sg_evals1, sg_evals2 =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let sg_evals pt =","counters":[]},{"line":"        Vector.map2","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ~f:(fun keep f -> (keep, f pt))","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"          (Vector.trim actual_width_mask","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"             (Nat.lte_exn Proofs_verified.n Nat.N2.n) )","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"          sg_olds","counters":[]},{"line":"      in","counters":[]},{"line":"      (sg_evals plonk.zeta, sg_evals zetaw)","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"    in","counters":[]},{"line":"    let sponge_state =","counters":[]},{"line":"      let challenge_digest =","counters":[]},{"line":"        let opt_sponge = Opt_sponge.create sponge_params in","counters":[]},{"line":"        Vector.iter2","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (Vector.trim actual_width_mask","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"             (Nat.lte_exn Proofs_verified.n Nat.N2.n) )","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"          prev_challenges","counters":[]},{"line":"          ~f:(fun keep chals ->","counters":[]},{"line":"            Vector.iter chals ~f:(fun chal ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"                Opt_sponge.absorb opt_sponge (keep, chal) ) ) ;","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"        Opt_sponge.squeeze opt_sponge","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"      in","counters":[]},{"line":"      Sponge.absorb sponge (`Field challenge_digest) ;","counters":[]},{"line":"      Sponge.absorb sponge (`Field ft_eval1) ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Sponge.absorb sponge (`Field (fst evals.public_input)) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"      Sponge.absorb sponge (`Field (snd evals.public_input)) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"      let xs = Evals.In_circuit.to_absorption_sequence evals.evals in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Plonk_types.Opt.Early_stop_sequence.fold field_array_if xs ~init:()","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"        ~f:(fun () (x1, x2) ->","counters":[]},{"line":"          let absorb =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Array.iter ~f:(fun x -> Sponge.absorb sponge (`Field x))","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"          in","counters":[]},{"line":"          absorb x1 ; absorb x2 )","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"        ~finish:(fun () -> Array.copy sponge.state)","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"    in","counters":[]},{"line":"    sponge.state <- sponge_state ;","counters":[]},{"line":"    let squeeze () = squeeze_challenge sponge in","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"    let xi_actual = squeeze () in","counters":[]},{"line":"    let r_actual = squeeze () in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let xi_correct =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Field.equal xi_actual (match xi with { SC.SC.inner = xi } -> xi)","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"    in","counters":[]},{"line":"    let xi = scalar xi in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let r = scalar (SC.SC.create r_actual) in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"    let plonk_minimal = Plonk.to_minimal plonk ~to_option:Opt.to_option in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let combined_evals =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let n = Int.ceil_log2 Max_degree.step in","counters":[]},{"line":"      let zeta_n : Field.t = pow2_pow plonk.zeta n in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"      let zetaw_n : Field.t = pow2_pow zetaw n in","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"      Evals.In_circuit.map","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"        ~f:(fun (x0, x1) ->","counters":[]},{"line":"          ( actual_evaluation ~pt_to_n:zeta_n x0","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"          , actual_evaluation ~pt_to_n:zetaw_n x1 ) )","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"        evals.evals","counters":[]},{"line":"    in","counters":[]},{"line":"    let env =","counters":[]},{"line":"      with_label \"scalars_env\" (fun () ->","counters":[]},{"line":"          Plonk_checks.scalars_env","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (module Field)","counters":[]},{"line":"            ~srs_length_log2:Common.Max_degree.step_log2","counters":[]},{"line":"            ~endo:(Impl.Field.constant Endo.Step_inner_curve.base)","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"            ~mds:sponge_params.mds","counters":[]},{"line":"            ~field_of_hex:(fun s ->","counters":[]},{"line":"              Kimchi_pasta.Pasta.Bigint256.of_hex_string s","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"              |> Kimchi_pasta.Pasta.Fp.of_bigint |> Field.constant )","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"            ~domain plonk_minimal combined_evals )","counters":[]},{"line":"    in","counters":[]},{"line":"    let open Field in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let combined_inner_product_correct =","counters":[]},{"line":"      let evals1, evals2 =","counters":[]},{"line":"        All_evals.With_public_input.In_circuit.factor evals","counters":[]},{"line":"      in","counters":[]},{"line":"      let ft_eval0 : Field.t =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        with_label \"ft_eval0\" (fun () ->","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"            Plonk_checks.ft_eval0","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (module Field)","counters":[]},{"line":"              ~lookup_constant_term_part:","counters":[]},{"line":"                ( match step_uses_lookup with","counters":[]},{"line":"                | No ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    None","counters":[]},{"line":"                | Yes ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    Some Plonk_checks.tick_lookup_constant_term_part","counters":[]},{"line":"                | Maybe -> (","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    match plonk.lookup with","counters":[]},{"line":"                    | Maybe ((b : Boolean.var), _) ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        Some","counters":[]},{"line":"                          (fun env ->","counters":[]},{"line":"                            Field.(","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                              (b :> t)","counters":[]},{"line":"                              * Plonk_checks.tick_lookup_constant_term_part env)","counters":[{"col_start":74,"col_end":74,"count":0}]},{"line":"                            )","counters":[]},{"line":"                    | None | Some _ ->","counters":[]},{"line":"                        assert false ) )","counters":[]},{"line":"              ~env ~domain plonk_minimal combined_evals evals1.public_input )","counters":[]},{"line":"      in","counters":[]},{"line":"      print_fp \"ft_eval0\" ft_eval0 ;","counters":[]},{"line":"      print_fp \"ft_eval1\" ft_eval1 ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      (* sum_i r^i sum_j xi^j f_j(beta_i) *)","counters":[]},{"line":"      let actual_combined_inner_product =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let combine ~ft ~sg_evals x_hat","counters":[]},{"line":"            (e : (Field.t array, _) Evals.In_circuit.t) =","counters":[]},{"line":"          let sg_evals =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            sg_evals |> Vector.to_list","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"            |> List.map ~f:(fun (keep, eval) ->","counters":[]},{"line":"                   [| Plonk_types.Opt.Maybe (keep, eval) |] )","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"          in","counters":[]},{"line":"          let a =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Evals.In_circuit.to_list e","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"            |> List.map ~f:(function","counters":[]},{"line":"                 | None ->","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"                     [||]","counters":[]},{"line":"                 | Some a ->","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"                     Array.map a ~f:(fun x -> Plonk_types.Opt.Some x)","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"                 | Maybe (b, a) ->","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"                     Array.map a ~f:(fun x -> Plonk_types.Opt.Maybe (b, x)) )","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"          in","counters":[]},{"line":"          let v =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            List.append sg_evals ([| Some x_hat |] :: [| Some ft |] :: a)","counters":[]},{"line":"          in","counters":[]},{"line":"          Common.combined_evaluation (module Impl) ~xi v","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        in","counters":[]},{"line":"        with_label \"combine\" (fun () ->","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"            combine ~ft:ft_eval0 ~sg_evals:sg_evals1 evals1.public_input","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"              evals1.evals","counters":[]},{"line":"            + r","counters":[]},{"line":"              * combine ~ft:ft_eval1 ~sg_evals:sg_evals2 evals2.public_input","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                  evals2.evals )","counters":[]},{"line":"      in","counters":[]},{"line":"      let expected =","counters":[]},{"line":"        Shifted_value.Type1.to_field","counters":[]},{"line":"          (module Field)","counters":[]},{"line":"          ~shift:shift1 combined_inner_product","counters":[]},{"line":"      in","counters":[]},{"line":"      print_fp \"step_main cip expected\" expected ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      print_fp \"step_main cip actual\" actual_combined_inner_product ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      equal expected actual_combined_inner_product","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":10,"col_end":10,"count":0}]},{"line":"    in","counters":[]},{"line":"    let bulletproof_challenges =","counters":[]},{"line":"      compute_challenges ~scalar bulletproof_challenges","counters":[]},{"line":"    in","counters":[]},{"line":"    let b_correct =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      with_label \"b_correct\" (fun () ->","counters":[]},{"line":"          let challenge_poly =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            unstage","counters":[]},{"line":"              (challenge_polynomial (Vector.to_array bulletproof_challenges))","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"          in","counters":[]},{"line":"          let b_actual =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            challenge_poly plonk.zeta + (r * challenge_poly zetaw)","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"          in","counters":[]},{"line":"          let b_used =","counters":[]},{"line":"            Shifted_value.Type1.to_field (module Field) ~shift:shift1 b","counters":[]},{"line":"          in","counters":[]},{"line":"          equal b_used b_actual )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    in","counters":[]},{"line":"    let plonk_checks_passed =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      with_label \"plonk_checks_passed\" (fun () ->","counters":[]},{"line":"          Plonk_checks.checked","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (module Impl)","counters":[]},{"line":"            ~env ~shift:shift1 plonk combined_evals )","counters":[]},{"line":"    in","counters":[]},{"line":"    print_bool \"xi_correct\" xi_correct ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    print_bool \"combined_inner_product_correct\" combined_inner_product_correct ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    print_bool \"plonk_checks_passed\" plonk_checks_passed ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    print_bool \"b_correct\" b_correct ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    ( Boolean.all","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":16,"col_end":16,"count":0}]},{"line":"        [ xi_correct","counters":[]},{"line":"        ; b_correct","counters":[]},{"line":"        ; combined_inner_product_correct","counters":[]},{"line":"        ; plonk_checks_passed","counters":[]},{"line":"        ]","counters":[]},{"line":"    , bulletproof_challenges )","counters":[]},{"line":"","counters":[]},{"line":"  let sponge_after_index index =","counters":[]},{"line":"    let sponge = Sponge.create sponge_params in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Array.iter","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (Types.index_to_field_elements","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"         ~g:(fun (z : Inputs.Inner_curve.t) ->","counters":[]},{"line":"           List.to_array (Inner_curve.to_field_elements z) )","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"         index )","counters":[]},{"line":"      ~f:(fun x -> Sponge.absorb sponge (`Field x)) ;","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"    sponge","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let hash_messages_for_next_step_proof (type s) ~index","counters":[]},{"line":"      (state_to_field_elements : s -> Field.t array) =","counters":[]},{"line":"    let open Types.Step.Proof_state.Messages_for_next_step_proof in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let after_index = sponge_after_index index in","counters":[]},{"line":"    stage (fun (t : _ Types.Step.Proof_state.Messages_for_next_step_proof.t) ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        let sponge = Sponge.copy after_index in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Array.iter","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ~f:(fun x -> Sponge.absorb sponge (`Field x))","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"          (to_field_elements_without_index t ~app_state:state_to_field_elements","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"             ~g:Inner_curve.to_field_elements ) ;","counters":[]},{"line":"        Sponge.squeeze_field sponge )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"  let hash_messages_for_next_step_proof_opt (type s) ~index","counters":[]},{"line":"      (state_to_field_elements : s -> Field.t array) =","counters":[]},{"line":"    let open Types.Step.Proof_state.Messages_for_next_step_proof in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let after_index = sponge_after_index index in","counters":[]},{"line":"    ( after_index","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    , stage (fun t ~widths ~max_width ~proofs_verified_mask ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let sponge = Sponge.copy after_index in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let t =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            { t with","counters":[]},{"line":"              old_bulletproof_challenges =","counters":[]},{"line":"                Vector.map2 proofs_verified_mask t.old_bulletproof_challenges","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                  ~f:(fun b v -> Vector.map v ~f:(fun x -> `Opt (b, x)))","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"            ; challenge_polynomial_commitments =","counters":[]},{"line":"                Vector.map2 proofs_verified_mask","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                  t.challenge_polynomial_commitments ~f:(fun b g -> (b, g))","counters":[{"col_start":68,"col_end":68,"count":0}]},{"line":"            }","counters":[]},{"line":"          in","counters":[]},{"line":"          let not_opt x = `Not_opt x in","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"          let hash_inputs =","counters":[]},{"line":"            to_field_elements_without_index t","counters":[]},{"line":"              ~app_state:","counters":[]},{"line":"                (Fn.compose (Array.map ~f:not_opt) state_to_field_elements)","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"              ~g:(fun (b, g) ->","counters":[]},{"line":"                List.map","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  ~f:(fun x -> `Opt (b, x))","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                  (Inner_curve.to_field_elements g) )","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"          in","counters":[]},{"line":"          match","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Array.fold hash_inputs ~init:(`Not_opt sponge) ~f:(fun acc t ->","counters":[]},{"line":"                match (acc, t) with","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                | `Not_opt sponge, `Not_opt t ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    Sponge.absorb sponge (`Field t) ;","counters":[]},{"line":"                    acc","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                | `Not_opt sponge, `Opt t ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    let sponge = Opt_sponge.of_sponge sponge in","counters":[]},{"line":"                    Opt_sponge.absorb sponge t ; `Opt sponge","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"                | `Opt sponge, `Opt t ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    Opt_sponge.absorb sponge t ; acc","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"                | `Opt _, `Not_opt _ ->","counters":[]},{"line":"                    assert false )","counters":[]},{"line":"          with","counters":[]},{"line":"          | `Not_opt sponge ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (* This means there were no optional inputs. *)","counters":[]},{"line":"              Sponge.squeeze_field sponge","counters":[]},{"line":"          | `Opt sponge ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Opt_sponge.squeeze sponge ) )","counters":[]},{"line":"","counters":[]},{"line":"  let accumulation_verifier","counters":[]},{"line":"      (accumulator_verification_key : _ Types_map.For_step.t) prev_accumulators","counters":[]},{"line":"      proof new_accumulator : Boolean.var =","counters":[]},{"line":"    Boolean.false_","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let verify ~proofs_verified ~is_base_case ~sg_old ~sponge_after_index","counters":[]},{"line":"      ~lookup_parameters ~(proof : Wrap_proof.Checked.t) ~wrap_domain","counters":[]},{"line":"      ~wrap_verification_key statement","counters":[]},{"line":"      (unfinalized :","counters":[]},{"line":"        ( _","counters":[]},{"line":"        , _","counters":[]},{"line":"        , _ Shifted_value.Type2.t","counters":[]},{"line":"        , _","counters":[]},{"line":"        , _","counters":[]},{"line":"        , _","counters":[]},{"line":"        , _ )","counters":[]},{"line":"        Types.Step.Proof_state.Per_proof.In_circuit.t ) =","counters":[]},{"line":"    let public_input :","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        [ `Field of Field.t | `Packed_bits of Field.t * int ] array =","counters":[]},{"line":"      with_label \"pack_statement\" (fun () ->","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"          Spec.pack","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (module Impl)","counters":[]},{"line":"            (Types.Wrap.Statement.In_circuit.spec","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"               (module Impl)","counters":[]},{"line":"               lookup_parameters )","counters":[]},{"line":"            (Types.Wrap.Statement.In_circuit.to_data","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"               ~option_map:Plonk_types.Opt.map statement ) )","counters":[]},{"line":"      |> Array.map ~f:(function","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"           | `Field (Shifted_value.Type1.Shifted_value x) ->","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"               `Field x","counters":[]},{"line":"           | `Packed_bits (x, n) ->","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"               `Packed_bits (x, n) )","counters":[]},{"line":"    in","counters":[]},{"line":"    let sponge = Sponge.create sponge_params in","counters":[]},{"line":"    let { Types.Step.Proof_state.Deferred_values.xi; combined_inner_product; b }","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        =","counters":[]},{"line":"      unfinalized.deferred_values","counters":[]},{"line":"    in","counters":[]},{"line":"    let ( sponge_digest_before_evaluations_actual","counters":[]},{"line":"        , (`Success bulletproof_success, bulletproof_challenges_actual) ) =","counters":[]},{"line":"      incrementally_verify_proof proofs_verified ~domain:wrap_domain ~xi","counters":[]},{"line":"        ~verification_key:wrap_verification_key ~sponge ~sponge_after_index","counters":[]},{"line":"        ~public_input ~sg_old","counters":[]},{"line":"        ~advice:{ b; combined_inner_product }","counters":[]},{"line":"        ~proof ~plonk:unfinalized.deferred_values.plonk","counters":[]},{"line":"    in","counters":[]},{"line":"    with_label __LOC__ (fun () ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        with_label __LOC__ (fun () ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            Field.Assert.equal unfinalized.sponge_digest_before_evaluations","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              sponge_digest_before_evaluations_actual ) ;","counters":[]},{"line":"        Array.iteri","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (Vector.to_array unfinalized.deferred_values.bulletproof_challenges)","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"          ~f:(fun i c1 ->","counters":[]},{"line":"            let c2 = bulletproof_challenges_actual.(i) in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let { Import.Scalar_challenge.inner = c1 } =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              c1.Bulletproof_challenge.prechallenge","counters":[]},{"line":"            in","counters":[]},{"line":"            let c2 =","counters":[]},{"line":"              Field.if_ is_base_case ~then_:c1","counters":[]},{"line":"                ~else_:(match c2.prechallenge with { inner = c2 } -> c2)","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"            in","counters":[]},{"line":"            with_label (sprintf \"%s:%d\" __LOC__ i) (fun () ->","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"                Field.Assert.equal c1 c2 ) ) ) ;","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"    bulletproof_success","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"include Make (Step_main_inputs)","counters":[{"col_start":30,"col_end":30,"count":2}]}]}