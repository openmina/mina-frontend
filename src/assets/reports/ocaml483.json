{"filename":"src/lib/snarky_taylor/floating_point.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Snarky_backendless","counters":[]},{"line":"open Snark","counters":[]},{"line":"open Snarky_integer","counters":[]},{"line":"open Util","counters":[]},{"line":"module B = Bigint","counters":[]},{"line":"","counters":[]},{"line":"(* This module is for representing arbitrary precision rationals in the interval","counters":[]},{"line":"    [0, 1). We represent such a number as an integer [value] and an int [precision].","counters":[]},{"line":"","counters":[]},{"line":"    The interpretation is that it corresponds to the rational number","counters":[]},{"line":"","counters":[]},{"line":"    value / 2^precision","counters":[]},{"line":"*)","counters":[]},{"line":"","counters":[]},{"line":"type 'f t = { value : 'f Cvar.t; precision : int }","counters":[]},{"line":"","counters":[]},{"line":"let precision t = t.precision","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"","counters":[]},{"line":"let to_bignum (type f) ~m:((module M) as m : f m) t =","counters":[]},{"line":"  let open M in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let d = t.precision in","counters":[]},{"line":"  fun () ->","counters":[]},{"line":"    let t = As_prover.read_var t.value in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Bignum.(of_bigint (bigint_of_field ~m t) / of_bigint B.(one lsl d))","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"","counters":[]},{"line":"(*","counters":[]},{"line":"    x      y        x*y","counters":[]},{"line":"    ---- * ---- = ---------","counters":[]},{"line":"    2^px   2^py   2^(px+py)","counters":[]},{"line":"*)","counters":[]},{"line":"let mul (type f) ~m:((module I) : f m) x y =","counters":[]},{"line":"  let open I in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let new_precision = x.precision + y.precision in","counters":[]},{"line":"  assert (new_precision < Field.Constant.size_in_bits) ;","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"  { value = Field.(x.value * y.value); precision = new_precision }","counters":[]},{"line":"","counters":[]},{"line":"let constant (type f) ~m:((module M) as m : f m) ~value ~precision =","counters":[]},{"line":"  assert (B.(value < one lsl precision)) ;","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":9,"col_end":9,"count":0}]},{"line":"  let open M in","counters":[]},{"line":"  { value = Field.constant (bigint_to_field ~m value); precision }","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"","counters":[]},{"line":"(* x, x^2, ..., x^n *)","counters":[]},{"line":"let powers ~m x n =","counters":[]},{"line":"  let res = Array.create ~len:n x in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let rec go acc i =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    if i >= n then ()","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"    else","counters":[]},{"line":"      let acc = mul ~m x acc in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      res.(i) <- acc ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      go acc (i + 1)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  in","counters":[]},{"line":"  go x 1 ; res","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"","counters":[]},{"line":"let pow2 add ~one k =","counters":[]},{"line":"  let rec go acc i = if i = k then acc else go (add acc acc) (i + 1) in","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"  go one 0","counters":[]},{"line":"","counters":[]},{"line":"(*","counters":[]},{"line":"    Say px <= py.","counters":[]},{"line":"","counters":[]},{"line":"    x      y     2^(py-px) x + y","counters":[]},{"line":"    ---- + ---- = ---------------","counters":[]},{"line":"    2^px   2^py        2^py","counters":[]},{"line":"*)","counters":[]},{"line":"let add_signed (type f) ~m:((module M) : f m) t1 (sgn, t2) =","counters":[]},{"line":"  let open M in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let precision = max t1.precision t2.precision in","counters":[]},{"line":"  assert (precision < Field.Constant.size_in_bits) ;","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":9,"col_end":9,"count":0}]},{"line":"  let t1, t2 = if t1.precision < t2.precision then (t1, t2) else (t2, t1) in","counters":[{"col_start":51,"col_end":51,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"  let value =","counters":[]},{"line":"    let open Field in","counters":[]},{"line":"    let f = match sgn with `Pos -> ( + ) | `Neg -> ( - ) in","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"    f (pow2 add ~one Int.(t2.precision - t1.precision) * t1.value) t2.value","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":10,"col_end":10,"count":0}]},{"line":"  in","counters":[]},{"line":"  { precision; value }","counters":[]},{"line":"","counters":[]},{"line":"let add ~m x y = add_signed ~m x (`Pos, y)","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"","counters":[]},{"line":"let sub ~m x y = add_signed ~m x (`Neg, y)","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"","counters":[]},{"line":"let le (type f) ~m:((module M) : f m) t1 t2 =","counters":[]},{"line":"  let open M in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let precision = max t1.precision t2.precision in","counters":[]},{"line":"  assert (precision < Field.Constant.size_in_bits) ;","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":9,"col_end":9,"count":0}]},{"line":"  let padding =","counters":[]},{"line":"    let k = precision - min t1.precision t2.precision in","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"    let open Field in","counters":[]},{"line":"    constant (pow2 Constant.add ~one:Constant.one k)","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"  in","counters":[]},{"line":"  let x1, x2 =","counters":[]},{"line":"    let open Field in","counters":[]},{"line":"    let x1, x2 = (t1.value, t2.value) in","counters":[]},{"line":"    if t1.precision < t2.precision then (padding * x1, x2)","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"    else if t2.precision < t1.precision then (x1, padding * x2)","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"    else (x1, x2)","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"  in","counters":[]},{"line":"  (Field.compare ~bit_length:precision x1 x2).less_or_equal","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"","counters":[]},{"line":"(*","counters":[]},{"line":"    Compute the truncated fixed point representation of the quotient top / bottom.","counters":[]},{"line":"","counters":[]},{"line":"    This uses the fact that if","counters":[]},{"line":"","counters":[]},{"line":"    top","counters":[]},{"line":"    -----  = 0.b1 ... bk b_{k+1} ...","counters":[]},{"line":"    bottom","counters":[]},{"line":"","counters":[]},{"line":"    then","counters":[]},{"line":"","counters":[]},{"line":"    2^k top","counters":[]},{"line":"    ------- = b1 ... bk.b_{k+1} ...","counters":[]},{"line":"    bottom","counters":[]},{"line":"","counters":[]},{"line":"    so we can compute the first k bits of the binary expansion of","counters":[]},{"line":"    top / bottom as floor(2^k * top / bottom).","counters":[]},{"line":"*)","counters":[]},{"line":"let of_quotient ~m ~precision ~top ~bottom ~top_is_less_than_bottom:() =","counters":[]},{"line":"  let q, _r = Integer.(div_mod ~m (shift_left ~m top precision) bottom) in","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"  { value = Integer.to_field q; precision }","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"","counters":[]},{"line":"let of_bits (type f) ~m:((module M) : f m) bits ~precision =","counters":[]},{"line":"  assert (List.length bits <= precision) ;","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":9,"col_end":9,"count":0},{"col_start":20,"col_end":20,"count":0}]},{"line":"  { value = M.Field.pack bits; precision }","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":41,"col_end":41,"count":2}]}]}