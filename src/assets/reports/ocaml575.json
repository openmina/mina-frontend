{"filename":"src/lib/mina_lib/mina_lib.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Async","counters":[]},{"line":"open Mina_base","counters":[]},{"line":"open Mina_transaction","counters":[]},{"line":"module Ledger = Mina_ledger.Ledger","counters":[]},{"line":"open Mina_block","counters":[]},{"line":"open Pipe_lib","counters":[]},{"line":"open Strict_pipe","counters":[]},{"line":"open Signature_lib","counters":[]},{"line":"open Network_peer","counters":[]},{"line":"module Archive_client = Archive_client","counters":[]},{"line":"module Config = Config","counters":[]},{"line":"module Conf_dir = Conf_dir","counters":[]},{"line":"module Subscriptions = Mina_subscriptions","counters":[]},{"line":"module Snark_worker_lib = Snark_worker","counters":[]},{"line":"module Timeout = Timeout_lib.Core_time","counters":[]},{"line":"","counters":[]},{"line":"let daemon_start_time = Time_ns.now ()","counters":[{"col_start":34,"col_end":34,"count":1}]},{"line":"","counters":[]},{"line":"type Structured_log_events.t += Connecting","counters":[]},{"line":"  [@@deriving register_event { msg = \"Mina daemon is connecting\" }]","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":27,"col_end":27,"count":3}]},{"line":"","counters":[]},{"line":"type Structured_log_events.t += Listening","counters":[]},{"line":"  [@@deriving register_event { msg = \"Mina daemon is listening\" }]","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":27,"col_end":27,"count":3}]},{"line":"","counters":[]},{"line":"type Structured_log_events.t += Bootstrapping","counters":[]},{"line":"  [@@deriving register_event { msg = \"Mina daemon is bootstrapping\" }]","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":27,"col_end":27,"count":3}]},{"line":"","counters":[]},{"line":"type Structured_log_events.t += Ledger_catchup","counters":[]},{"line":"  [@@deriving register_event { msg = \"Mina daemon is doing ledger catchup\" }]","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":27,"col_end":27,"count":3}]},{"line":"","counters":[]},{"line":"type Structured_log_events.t += Synced","counters":[]},{"line":"  [@@deriving register_event { msg = \"Mina daemon is synced\" }]","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":27,"col_end":27,"count":3}]},{"line":"","counters":[]},{"line":"type Structured_log_events.t +=","counters":[]},{"line":"  | Rebroadcast_transition of { state_hash : State_hash.t }","counters":[{"col_start":45,"col_end":45,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"  [@@deriving register_event { msg = \"Rebroadcasting $state_hash\" }]","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":27,"col_end":27,"count":3}]},{"line":"","counters":[]},{"line":"exception Snark_worker_error of int","counters":[]},{"line":"","counters":[]},{"line":"exception Snark_worker_signal_interrupt of Signal.t","counters":[]},{"line":"","counters":[]},{"line":"(* A way to run a single snark worker for a daemon in a lazy manner. Forcing","counters":[]},{"line":"   this lazy value will run the snark worker process. A snark work is","counters":[]},{"line":"   assigned to a public key. This public key can change throughout the entire time","counters":[]},{"line":"   the daemon is running *)","counters":[]},{"line":"type snark_worker =","counters":[]},{"line":"  { public_key : Public_key.Compressed.t","counters":[]},{"line":"  ; process : Process.t Ivar.t","counters":[]},{"line":"  ; kill_ivar : unit Ivar.t","counters":[]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"type processes =","counters":[]},{"line":"  { prover : Prover.t","counters":[]},{"line":"  ; verifier : Verifier.t","counters":[]},{"line":"  ; vrf_evaluator : Vrf_evaluator.t","counters":[]},{"line":"  ; mutable snark_worker :","counters":[]},{"line":"      [ `On of snark_worker * Currency.Fee.t | `Off of Currency.Fee.t ]","counters":[]},{"line":"  ; uptime_snark_worker_opt : Uptime_service.Uptime_snark_worker.t option","counters":[]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"type components =","counters":[]},{"line":"  { net : Mina_networking.t","counters":[]},{"line":"  ; transaction_pool : Network_pool.Transaction_pool.t","counters":[]},{"line":"  ; snark_pool : Network_pool.Snark_pool.t","counters":[]},{"line":"  ; transition_frontier : Transition_frontier.t option Broadcast_pipe.Reader.t","counters":[]},{"line":"  ; most_recent_valid_block :","counters":[]},{"line":"      Mina_block.initial_valid_block Broadcast_pipe.Reader.t","counters":[]},{"line":"  ; block_produced_bvar : (Transition_frontier.Breadcrumb.t, read_write) Bvar.t","counters":[]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"(* tag commands so they can share a common pipe, to ensure sequentiality of nonces *)","counters":[]},{"line":"type command_inputs =","counters":[]},{"line":"  | Signed_command_inputs of User_command_input.t list","counters":[]},{"line":"  | Zkapp_command_command_inputs of Zkapp_command.t list","counters":[]},{"line":"","counters":[]},{"line":"type pipes =","counters":[]},{"line":"  { validated_transitions_reader : Mina_block.Validated.t Strict_pipe.Reader.t","counters":[]},{"line":"  ; producer_transition_writer :","counters":[]},{"line":"      ( Transition_frontier.Breadcrumb.t","counters":[]},{"line":"      , Strict_pipe.synchronous","counters":[]},{"line":"      , unit Deferred.t )","counters":[]},{"line":"      Strict_pipe.Writer.t","counters":[]},{"line":"  ; user_command_input_writer :","counters":[]},{"line":"      ( command_inputs","counters":[]},{"line":"        * (   ( [ `Broadcasted | `Not_broadcasted ]","counters":[]},{"line":"              * Network_pool.Transaction_pool.Resource_pool.Diff.t","counters":[]},{"line":"              * Network_pool.Transaction_pool.Resource_pool.Diff.Rejected.t )","counters":[]},{"line":"              Or_error.t","counters":[]},{"line":"           -> unit )","counters":[]},{"line":"        * (   Account_id.t","counters":[]},{"line":"           -> ( [ `Min of Mina_base.Account.Nonce.t ] * Mina_base.Account.Nonce.t","counters":[]},{"line":"              , string )","counters":[]},{"line":"              Result.t )","counters":[]},{"line":"        * (Account_id.t -> Account.t option Participating_state.T.t)","counters":[]},{"line":"      , Strict_pipe.synchronous","counters":[]},{"line":"      , unit Deferred.t )","counters":[]},{"line":"      Strict_pipe.Writer.t","counters":[]},{"line":"  ; tx_local_sink : Network_pool.Transaction_pool.Local_sink.t","counters":[]},{"line":"  ; snark_local_sink : Network_pool.Snark_pool.Local_sink.t","counters":[]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"type t =","counters":[{"col_start":0,"col_end":0,"count":0},{"col_start":5,"col_end":5,"count":0}]},{"line":"  { config : Config.t","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  ; processes : processes","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  ; components : components","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  ; initialization_finish_signal : unit Ivar.t","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  ; pipes : pipes","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  ; wallets : Secrets.Wallets.t","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  ; coinbase_receiver : Consensus.Coinbase_receiver.t ref","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  ; snark_job_state : Work_selector.State.t","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  ; mutable next_producer_timing :","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"      Daemon_rpcs.Types.Status.Next_producer_timing.t option","counters":[]},{"line":"  ; subscriptions : Mina_subscriptions.t","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  ; sync_status : Sync_status.t Mina_incremental.Status.Observer.t","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  ; precomputed_block_writer :","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ([ `Path of string ] option * [ `Log ] option) ref","counters":[]},{"line":"  ; block_production_status :","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      [ `Producing | `Producing_in_ms of float | `Free ] ref","counters":[]},{"line":"  }","counters":[]},{"line":"[@@deriving fields]","counters":[]},{"line":"","counters":[]},{"line":"let time_controller t = t.config.time_controller","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"","counters":[]},{"line":"let subscription t = t.subscriptions","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"","counters":[]},{"line":"let peek_frontier frontier_broadcast_pipe =","counters":[]},{"line":"  Broadcast_pipe.Reader.peek frontier_broadcast_pipe","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"  |> Result.of_option","counters":[]},{"line":"       ~error:","counters":[]},{"line":"         (Error.of_string","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"            \"Cannot retrieve transition frontier now. Bootstrapping right now.\" )","counters":[]},{"line":"","counters":[]},{"line":"let client_port t =","counters":[]},{"line":"  let { Node_addrs_and_ports.client_port; _ } =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    t.config.gossip_net_params.addrs_and_ports","counters":[]},{"line":"  in","counters":[]},{"line":"  client_port","counters":[]},{"line":"","counters":[]},{"line":"(* Get the most recently set public keys  *)","counters":[]},{"line":"let block_production_pubkeys t : Public_key.Compressed.Set.t =","counters":[]},{"line":"  t.config.block_production_keypairs |> Keypair.And_compressed_pk.Set.to_list","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":76,"col_end":76,"count":0}]},{"line":"  |> List.map ~f:snd |> Public_key.Compressed.Set.of_list","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"","counters":[]},{"line":"let coinbase_receiver t = !(t.coinbase_receiver)","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"","counters":[]},{"line":"let replace_coinbase_receiver t coinbase_receiver =","counters":[]},{"line":"  [%log' info t.config.logger]","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"    \"Changing the coinbase receiver for produced blocks from $old_receiver to \\","counters":[]},{"line":"     $new_receiver\"","counters":[]},{"line":"    ~metadata:","counters":[]},{"line":"      [ ( \"old_receiver\"","counters":[]},{"line":"        , Consensus.Coinbase_receiver.to_yojson !(t.coinbase_receiver) )","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"      ; (\"new_receiver\", Consensus.Coinbase_receiver.to_yojson coinbase_receiver)","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"      ] ;","counters":[]},{"line":"  t.coinbase_receiver := coinbase_receiver","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let log_snark_worker_warning t =","counters":[]},{"line":"  if Option.is_some t.config.snark_coordinator_key then","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    [%log' warn t.config.logger]","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"      \"The snark coordinator flag is set; running a snark worker will override \\","counters":[]},{"line":"       the snark coordinator key\"","counters":[]},{"line":"","counters":[]},{"line":"let log_snark_coordinator_warning (config : Config.t) snark_worker =","counters":[]},{"line":"  if Option.is_some config.snark_coordinator_key then","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    match snark_worker with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | `On _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [%log' warn config.logger]","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"          \"The snark coordinator key will be ignored because the snark worker \\","counters":[]},{"line":"           key is set \"","counters":[]},{"line":"    | _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ()","counters":[]},{"line":"","counters":[]},{"line":"module Snark_worker = struct","counters":[]},{"line":"  let run_process ~logger ~proof_level pids client_port kill_ivar num_threads =","counters":[]},{"line":"    let env =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Option.map","counters":[]},{"line":"        ~f:(fun num -> `Extend [ (\"RAYON_NUM_THREADS\", string_of_int num) ])","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"        num_threads","counters":[]},{"line":"    in","counters":[]},{"line":"    let%map snark_worker_process =","counters":[]},{"line":"      let our_binary = Sys.executable_name in","counters":[]},{"line":"      Process.create_exn () ~prog:our_binary ?env","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"        ~args:","counters":[]},{"line":"          ( \"internal\" :: Snark_worker.Intf.command_name","counters":[]},{"line":"          :: Snark_worker.arguments ~proof_level","counters":[]},{"line":"               ~daemon_address:","counters":[]},{"line":"                 (Host_and_port.create ~host:\"127.0.0.1\" ~port:client_port)","counters":[]},{"line":"               ~shutdown_on_disconnect:false )","counters":[]},{"line":"    in","counters":[]},{"line":"    Child_processes.Termination.register_process pids snark_worker_process","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Snark_worker ;","counters":[]},{"line":"    Child_processes.Termination.wait_for_process_log_errors ~logger","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      snark_worker_process ~module_:__MODULE__ ~location:__LOC__ ~here:[%here] ;","counters":[]},{"line":"    let close_stdin () =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Process.stdin snark_worker_process |> Async.Writer.close","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"    in","counters":[]},{"line":"    let remove_pid () =","counters":[]},{"line":"      let pid = Process.pid snark_worker_process in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Child_processes.Termination.remove pids pid","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    in","counters":[]},{"line":"    don't_wait_for","counters":[]},{"line":"      ( match%bind","counters":[]},{"line":"          Monitor.try_with ~here:[%here] (fun () ->","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"              Process.wait snark_worker_process )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"        with","counters":[]},{"line":"      | Ok signal_or_error -> (","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let%bind () = close_stdin () in","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"          remove_pid () ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          match signal_or_error with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | Ok () ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              [%log info] \"Snark worker process died\" ;","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"              if Ivar.is_full kill_ivar then","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                [%log error] \"Ivar.fill bug is here 222!\" ;","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"              Ivar.fill kill_ivar () ;","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              Deferred.unit","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"          | Error (`Exit_non_zero non_zero_error) ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              [%log fatal]","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                !\"Snark worker process died with a nonzero error %i\"","counters":[]},{"line":"                non_zero_error ;","counters":[]},{"line":"              raise (Snark_worker_error non_zero_error)","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"          | Error (`Signal signal) ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              [%log fatal]","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                !\"Snark worker died with signal %{sexp:Signal.t}. Aborting \\","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                  daemon\"","counters":[]},{"line":"                signal ;","counters":[]},{"line":"              raise (Snark_worker_signal_interrupt signal) )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"      | Error exn ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let%bind () = close_stdin () in","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"          remove_pid () ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          [%log info]","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":20,"col_end":20,"count":0}]},{"line":"            !\"Exception when waiting for snark worker process to terminate: \\","counters":[]},{"line":"              $exn\"","counters":[]},{"line":"            ~metadata:[ (\"exn\", `String (Exn.to_string exn)) ] ;","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"          Deferred.unit ) ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    [%log trace]","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"      !\"Created snark worker with pid: %i\"","counters":[]},{"line":"      (Pid.to_int @@ Process.pid snark_worker_process) ;","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"    (* We want these to be printfs so we don't double encode our logs here *)","counters":[]},{"line":"    Pipe.iter_without_pushback","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"      (Async.Reader.pipe (Process.stdout snark_worker_process))","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"      ~f:(fun s -> printf \"%s\" s)","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"    |> don't_wait_for ;","counters":[]},{"line":"    Pipe.iter_without_pushback","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"      (Async.Reader.pipe (Process.stderr snark_worker_process))","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"      ~f:(fun s -> printf \"%s\" s)","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"    |> don't_wait_for ;","counters":[]},{"line":"    snark_worker_process","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let start t =","counters":[]},{"line":"    match t.processes.snark_worker with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | `On ({ process = process_ivar; kill_ivar; _ }, _) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [%log' debug t.config.logger] !\"Starting snark worker process\" ;","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"        log_snark_worker_warning t ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let%map snark_worker_process =","counters":[]},{"line":"          run_process ~logger:t.config.logger","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"            ~proof_level:t.config.precomputed_values.proof_level t.config.pids","counters":[]},{"line":"            t.config.gossip_net_params.addrs_and_ports.client_port kill_ivar","counters":[]},{"line":"            t.config.snark_worker_config.num_threads","counters":[]},{"line":"        in","counters":[]},{"line":"        [%log' debug t.config.logger]","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"          ~metadata:","counters":[]},{"line":"            [ ( \"snark_worker_pid\"","counters":[]},{"line":"              , `Int (Pid.to_int (Process.pid snark_worker_process)) )","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"            ]","counters":[]},{"line":"          \"Started snark worker process with pid: $snark_worker_pid\" ;","counters":[]},{"line":"        if Ivar.is_full process_ivar then","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          [%log' error t.config.logger] \"Ivar.fill bug is here 333!\" ;","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"        Ivar.fill process_ivar snark_worker_process","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    | `Off _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [%log' info t.config.logger]","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"          !\"Attempted to turn on snark worker, but snark worker key is set to \\","counters":[]},{"line":"            none\" ;","counters":[]},{"line":"        Deferred.unit","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"  let stop ?(should_wait_kill = false) t =","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"    match t.processes.snark_worker with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | `On ({ public_key = _; process; kill_ivar }, _) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let%bind process = Ivar.read process in","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"        [%log' info t.config.logger]","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"          \"Killing snark worker process with pid: $snark_worker_pid\"","counters":[]},{"line":"          ~metadata:","counters":[]},{"line":"            [ (\"snark_worker_pid\", `Int (Pid.to_int (Process.pid process))) ] ;","counters":[{"col_start":50,"col_end":50,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"        Signal.send_exn Signal.term (`Pid (Process.pid process)) ;","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"        if should_wait_kill then Ivar.read kill_ivar else Deferred.unit","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"    | `Off _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [%log' warn t.config.logger]","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"          \"Attempted to turn off snark worker, but no snark worker was running\" ;","counters":[]},{"line":"        Deferred.unit","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"  let get_key { processes = { snark_worker; _ }; _ } =","counters":[]},{"line":"    match snark_worker with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | `On ({ public_key; _ }, _) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Some public_key","counters":[]},{"line":"    | `Off _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        None","counters":[]},{"line":"","counters":[]},{"line":"  let replace_key t new_key =","counters":[]},{"line":"    let snark_worker = t.processes.snark_worker in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let logger = t.config.logger in","counters":[]},{"line":"    match (snark_worker, new_key) with","counters":[]},{"line":"    | `Off _, None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [%log info]","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"          \"Snark work is still not happening since keys snark worker keys are \\","counters":[]},{"line":"           still set to None\" ;","counters":[]},{"line":"        Deferred.unit","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    | `Off fee, Some new_key ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let process = Ivar.create () in","counters":[]},{"line":"        let kill_ivar = Ivar.create () in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        t.processes.snark_worker <-","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          `On ({ public_key = new_key; process; kill_ivar }, fee) ;","counters":[]},{"line":"        start t","counters":[]},{"line":"    | `On ({ public_key = old; process; kill_ivar }, fee), Some new_key ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [%log debug]","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"          !\"Changing snark worker key from $old to $new\"","counters":[]},{"line":"          ~metadata:","counters":[]},{"line":"            [ (\"old\", Public_key.Compressed.to_yojson old)","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"            ; (\"new\", Public_key.Compressed.to_yojson new_key)","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"            ] ;","counters":[]},{"line":"        t.processes.snark_worker <-","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          `On ({ public_key = new_key; process; kill_ivar }, fee) ;","counters":[]},{"line":"        Deferred.unit","counters":[]},{"line":"    | `On (_, fee), None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let%map () = stop t in","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"        t.processes.snark_worker <- `Off fee","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let replace_snark_worker_key = Snark_worker.replace_key","counters":[]},{"line":"","counters":[]},{"line":"let snark_worker_key = Snark_worker.get_key","counters":[]},{"line":"","counters":[]},{"line":"let snark_coordinator_key t = t.config.snark_coordinator_key","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"","counters":[]},{"line":"let stop_snark_worker = Snark_worker.stop","counters":[]},{"line":"","counters":[]},{"line":"let best_tip_opt t =","counters":[]},{"line":"  let open Option.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%map frontier =","counters":[]},{"line":"    Broadcast_pipe.Reader.peek t.components.transition_frontier","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"  in","counters":[]},{"line":"  Transition_frontier.best_tip frontier","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let transition_frontier t = t.components.transition_frontier","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"","counters":[]},{"line":"let root_length_opt t =","counters":[]},{"line":"  let open Option.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%map frontier =","counters":[]},{"line":"    Broadcast_pipe.Reader.peek t.components.transition_frontier","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"  in","counters":[]},{"line":"  Transition_frontier.root_length frontier","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let best_staged_ledger_opt t =","counters":[]},{"line":"  let open Option.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%map tip = best_tip_opt t in","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"  Transition_frontier.Breadcrumb.staged_ledger tip","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let best_protocol_state_opt t =","counters":[]},{"line":"  let open Option.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%map tip = best_tip_opt t in","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"  Transition_frontier.Breadcrumb.protocol_state tip","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let best_ledger_opt t =","counters":[]},{"line":"  let open Option.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%map staged_ledger = best_staged_ledger_opt t in","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"  Staged_ledger.ledger staged_ledger","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let compose_of_option f =","counters":[]},{"line":"  Fn.compose","counters":[{"col_start":2,"col_end":2,"count":6}]},{"line":"    (Option.value_map ~default:`Bootstrapping ~f:(fun x -> `Active x))","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"    f","counters":[]},{"line":"","counters":[]},{"line":"let best_tip = compose_of_option best_tip_opt","counters":[{"col_start":31,"col_end":31,"count":1}]},{"line":"","counters":[]},{"line":"let root_length = compose_of_option root_length_opt","counters":[{"col_start":34,"col_end":34,"count":1}]},{"line":"","counters":[]},{"line":"let active_or_bootstrapping =","counters":[]},{"line":"  compose_of_option (fun t ->","counters":[{"col_start":18,"col_end":18,"count":1}]},{"line":"      Option.bind","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (Broadcast_pipe.Reader.peek t.components.transition_frontier)","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"        ~f:(Fn.const (Some ())) )","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"","counters":[]},{"line":"let get_node_state t =","counters":[]},{"line":"  let chain_id = t.config.chain_id in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let addrs_and_ports = t.config.gossip_net_params.addrs_and_ports in","counters":[]},{"line":"  let peer_id = (Node_addrs_and_ports.to_peer_exn addrs_and_ports).peer_id in","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"  let ip_address =","counters":[]},{"line":"    Node_addrs_and_ports.external_ip addrs_and_ports","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"    |> Core.Unix.Inet_addr.to_string","counters":[]},{"line":"  in","counters":[]},{"line":"  let public_key =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    let key_list =","counters":[]},{"line":"      block_production_pubkeys t |> Public_key.Compressed.Set.to_list","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"    in","counters":[]},{"line":"    if List.is_empty key_list then None else Some (List.hd_exn key_list)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"  in","counters":[]},{"line":"  let catchup_job_states =","counters":[]},{"line":"    match Broadcast_pipe.Reader.peek @@ transition_frontier t with","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        None","counters":[]},{"line":"    | Some tf -> (","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        match Transition_frontier.catchup_tree tf with","counters":[]},{"line":"        | Full catchup_tree ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Some","counters":[]},{"line":"              (Transition_frontier.Full_catchup_tree.to_node_status_report","counters":[{"col_start":73,"col_end":73,"count":0}]},{"line":"                 catchup_tree )","counters":[]},{"line":"        | _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            None )","counters":[]},{"line":"  in","counters":[]},{"line":"  let block_height_at_best_tip =","counters":[]},{"line":"    best_tip t","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"    |> Participating_state.map ~f:(fun b ->","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"           Transition_frontier.Breadcrumb.consensus_state b","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"           |> Consensus.Data.Consensus_state.blockchain_length","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"           |> Mina_numbers.Length.to_uint32 )","counters":[]},{"line":"    |> Participating_state.map ~f:Unsigned.UInt32.to_int","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"    |> Participating_state.active","counters":[]},{"line":"  in","counters":[]},{"line":"  let sync_status =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    sync_status t |> Mina_incremental.Status.Observer.value_exn","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"  in","counters":[]},{"line":"  let uptime_of_node =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Time.(","counters":[]},{"line":"      Span.to_string_hum","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"      @@ Time.diff (now ())","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"           (Time_ns.to_time_float_round_nearest_microsecond daemon_start_time))","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%map hardware_info = Conf_dir.get_hw_info () in","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"  { Node_error_service.peer_id","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  ; ip_address","counters":[]},{"line":"  ; chain_id","counters":[]},{"line":"  ; public_key","counters":[]},{"line":"  ; catchup_job_states","counters":[]},{"line":"  ; block_height_at_best_tip","counters":[]},{"line":"  ; sync_status","counters":[]},{"line":"  ; hardware_info","counters":[]},{"line":"  ; uptime_of_node","counters":[]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"(* This is a hack put in place to deal with nodes getting stuck","counters":[]},{"line":"   in Offline states, that is, not receiving blocks for an extended period.","counters":[]},{"line":"","counters":[]},{"line":"   To address this, we restart the libp2p helper when we become offline. *)","counters":[]},{"line":"let next_helper_restart = ref None","counters":[]},{"line":"","counters":[]},{"line":"let offline_shutdown = ref None","counters":[]},{"line":"","counters":[]},{"line":"exception Offline_shutdown","counters":[]},{"line":"","counters":[]},{"line":"let create_sync_status_observer ~logger ~is_seed ~demo_mode ~net","counters":[]},{"line":"    ~transition_frontier_and_catchup_signal_incr ~online_status_incr","counters":[]},{"line":"    ~first_connection_incr ~first_message_incr =","counters":[]},{"line":"  let open Mina_incremental.Status in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let restart_delay = Time.Span.of_min 5. in","counters":[]},{"line":"  let offline_shutdown_delay = Time.Span.of_min 25. in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let incremental_status =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    map4 online_status_incr transition_frontier_and_catchup_signal_incr","counters":[]},{"line":"      first_connection_incr first_message_incr","counters":[]},{"line":"      ~f:(fun online_status active_status first_connection first_message ->","counters":[]},{"line":"        (* Always be synced in demo mode, we don't expect peers to connect to us *)","counters":[]},{"line":"        if demo_mode then `Synced","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"        else","counters":[]},{"line":"          match online_status with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | `Offline ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              ( match !next_helper_restart with","counters":[]},{"line":"              | None ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  next_helper_restart :=","counters":[]},{"line":"                    Some","counters":[]},{"line":"                      (Async.Clock.Event.run_after restart_delay","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"                         (fun () ->","counters":[]},{"line":"                           [%log info]","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"                             \"Offline for too long; restarting libp2p_helper\" ;","counters":[]},{"line":"                           Mina_networking.restart_helper net ;","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                           next_helper_restart := None ;","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                           match !offline_shutdown with","counters":[]},{"line":"                           | None ->","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                               offline_shutdown :=","counters":[]},{"line":"                                 Some","counters":[]},{"line":"                                   (Async.Clock.Event.run_after","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"                                      offline_shutdown_delay","counters":[]},{"line":"                                      (fun () -> raise Offline_shutdown)","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"                                      () )","counters":[]},{"line":"                           | Some _ ->","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                               () )","counters":[]},{"line":"                         () )","counters":[]},{"line":"              | Some _ ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  () ) ;","counters":[]},{"line":"              let is_empty = function `Empty -> true | _ -> false in","counters":[{"col_start":38,"col_end":38,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"              if is_empty first_connection then (","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"                [%str_log info] Connecting ;","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                `Connecting )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"              else if is_empty first_message then (","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"                [%str_log info] Listening ;","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                `Listening )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"              else `Offline","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"          | `Online -> (","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Option.iter !next_helper_restart ~f:(fun e ->","counters":[]},{"line":"                  Async.Clock.Event.abort_if_possible e () ) ;","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"              next_helper_restart := None ;","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              Option.iter !offline_shutdown ~f:(fun e ->","counters":[]},{"line":"                  Async.Clock.Event.abort_if_possible e () ) ;","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"              offline_shutdown := None ;","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              match active_status with","counters":[]},{"line":"              | None ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  let logger = Logger.create () in","counters":[]},{"line":"                  [%str_log info] Bootstrapping ;","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"                  `Bootstrap","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"              | Some (_, catchup_jobs) ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  let logger = Logger.create () in","counters":[]},{"line":"                  if catchup_jobs > 0 then (","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"                    [%str_log info] Ledger_catchup ;","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"                    `Catchup )","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                  else (","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                    [%str_log info] Synced ;","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"                    `Synced ) ) )","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"  in","counters":[]},{"line":"  let observer = observe incremental_status in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  (* monitor Mina status, issue a warning if offline for too long (unless we are a seed node) *)","counters":[]},{"line":"  ( if not is_seed then","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    let offline_timeout_min = 15.0 in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let offline_timeout_duration = Time.Span.of_min offline_timeout_min in","counters":[]},{"line":"    let offline_timeout = ref None in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let offline_warned = ref false in","counters":[]},{"line":"    let log_offline_warning _tm =","counters":[]},{"line":"      [%log error]","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"        \"Daemon has not received any gossip messages for %0.0f minutes; check \\","counters":[]},{"line":"         the daemon's external port forwarding, if needed\"","counters":[]},{"line":"        offline_timeout_min ;","counters":[]},{"line":"      offline_warned := true","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    in","counters":[]},{"line":"    let start_offline_timeout () =","counters":[]},{"line":"      match !offline_timeout with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Some _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ()","counters":[]},{"line":"      | None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          offline_timeout :=","counters":[]},{"line":"            Some","counters":[]},{"line":"              (Timeout.create () offline_timeout_duration ~f:log_offline_warning)","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"    in","counters":[]},{"line":"    let stop_offline_timeout () =","counters":[]},{"line":"      match !offline_timeout with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Some timeout ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          if !offline_warned then (","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"            [%log info]","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"              \"Daemon had been offline (no gossip messages received), now back \\","counters":[]},{"line":"               online\" ;","counters":[]},{"line":"            offline_warned := false ) ;","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          Timeout.cancel () timeout () ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          offline_timeout := None","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"      | None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ()","counters":[]},{"line":"    in","counters":[]},{"line":"    let handle_status_change status =","counters":[]},{"line":"      if match status with `Offline -> true | _ -> false then","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"        start_offline_timeout ()","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      else stop_offline_timeout ()","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"    in","counters":[]},{"line":"    Observer.on_update_exn observer ~f:(function","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"      | Initialized value ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          handle_status_change value","counters":[]},{"line":"      | Changed (_, value) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          handle_status_change value","counters":[]},{"line":"      | Invalidated ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          () ) ) ;","counters":[]},{"line":"  (* recompute Mina status on an interval *)","counters":[]},{"line":"  let stabilize () = O1trace.sync_thread \"stabilize_sync_status\" stabilize in","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"  stabilize () ;","counters":[]},{"line":"  every (Time.Span.of_sec 15.0) ~stop:(never ()) stabilize ;","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"  observer","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let sync_status t = t.sync_status","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"","counters":[]},{"line":"let visualize_frontier ~filename =","counters":[]},{"line":"  compose_of_option","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  @@ fun t ->","counters":[]},{"line":"  let open Option.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%map frontier =","counters":[]},{"line":"    Broadcast_pipe.Reader.peek t.components.transition_frontier","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"  in","counters":[]},{"line":"  Transition_frontier.visualize ~filename frontier","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let best_staged_ledger = compose_of_option best_staged_ledger_opt","counters":[{"col_start":41,"col_end":41,"count":1}]},{"line":"","counters":[]},{"line":"let best_protocol_state = compose_of_option best_protocol_state_opt","counters":[{"col_start":42,"col_end":42,"count":1}]},{"line":"","counters":[]},{"line":"let best_ledger = compose_of_option best_ledger_opt","counters":[{"col_start":34,"col_end":34,"count":1}]},{"line":"","counters":[]},{"line":"let get_ledger t state_hash_opt =","counters":[]},{"line":"  let open Or_error.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%bind state_hash =","counters":[]},{"line":"    Option.value_map state_hash_opt ~f:Or_error.return","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"      ~default:","counters":[]},{"line":"        ( match best_tip t with","counters":[]},{"line":"        | `Active bc ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Or_error.return (Frontier_base.Breadcrumb.state_hash bc)","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"        | `Bootstrapping ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Or_error.error_string","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"              \"get_ledger: can't get staged ledger hash while bootstrapping\" )","counters":[]},{"line":"  in","counters":[]},{"line":"  let%bind frontier = t.components.transition_frontier |> peek_frontier in","counters":[{"col_start":70,"col_end":70,"count":0}]},{"line":"  match Transition_frontier.find frontier state_hash with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | Some b ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let staged_ledger = Transition_frontier.Breadcrumb.staged_ledger b in","counters":[]},{"line":"      Ok (Ledger.to_list (Staged_ledger.ledger staged_ledger))","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"  | None ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Or_error.error_string","counters":[]},{"line":"        \"get_ledger: state hash not found in transition frontier\"","counters":[]},{"line":"","counters":[]},{"line":"let get_snarked_ledger t state_hash_opt =","counters":[]},{"line":"  let open Or_error.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%bind state_hash =","counters":[]},{"line":"    Option.value_map state_hash_opt ~f:Or_error.return","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"      ~default:","counters":[]},{"line":"        ( match best_tip t with","counters":[]},{"line":"        | `Active bc ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Or_error.return (Frontier_base.Breadcrumb.state_hash bc)","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"        | `Bootstrapping ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Or_error.error_string","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"              \"get_snarked_ledger: can't get snarked ledger hash while \\","counters":[]},{"line":"               bootstrapping\" )","counters":[]},{"line":"  in","counters":[]},{"line":"  let%bind frontier = t.components.transition_frontier |> peek_frontier in","counters":[{"col_start":70,"col_end":70,"count":0}]},{"line":"  match Transition_frontier.find frontier state_hash with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | Some b ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let root_snarked_ledger =","counters":[]},{"line":"        Transition_frontier.root_snarked_ledger frontier","counters":[]},{"line":"      in","counters":[]},{"line":"      let ledger = Ledger.of_database root_snarked_ledger in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let path = Transition_frontier.path_map frontier b ~f:Fn.id in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%bind _ =","counters":[]},{"line":"        List.fold_until ~init:(Ok ()) path","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"          ~f:(fun _acc b ->","counters":[]},{"line":"            if Transition_frontier.Breadcrumb.just_emitted_a_proof b then","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              match","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Staged_ledger.proof_txns_with_state_hashes","counters":[]},{"line":"                  (Transition_frontier.Breadcrumb.staged_ledger b)","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"              with","counters":[]},{"line":"              | None ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Stop","counters":[]},{"line":"                    (Or_error.error_string","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"                       (sprintf","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                          \"No transactions corresponding to the emitted proof \\","counters":[]},{"line":"                           for state_hash:%s\"","counters":[]},{"line":"                          (State_hash.to_base58_check","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"                             (Transition_frontier.Breadcrumb.state_hash b) ) ) )","counters":[{"col_start":70,"col_end":70,"count":0}]},{"line":"              | Some txns -> (","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  match","counters":[]},{"line":"                    List.fold_until ~init:(Ok ())","counters":[]},{"line":"                      (Non_empty_list.to_list txns)","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"                      ~f:(fun _acc (txn, state_hash) ->","counters":[]},{"line":"                        (*Validate transactions against the protocol state associated with the transaction*)","counters":[]},{"line":"                        match","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          Transition_frontier.find_protocol_state frontier","counters":[]},{"line":"                            state_hash","counters":[]},{"line":"                        with","counters":[]},{"line":"                        | Some state -> (","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            let txn_state_view =","counters":[]},{"line":"                              Mina_state.Protocol_state.body state","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"                              |> Mina_state.Protocol_state.Body.view","counters":[]},{"line":"                            in","counters":[]},{"line":"                            match","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                              Ledger.apply_transaction","counters":[]},{"line":"                                ~constraint_constants:","counters":[]},{"line":"                                  t.config.precomputed_values","counters":[]},{"line":"                                    .constraint_constants ~txn_state_view ledger","counters":[]},{"line":"                                txn.data","counters":[]},{"line":"                            with","counters":[]},{"line":"                            | Ok _ ->","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                                Continue (Ok ())","counters":[]},{"line":"                            | e ->","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                                Stop (Or_error.map e ~f:ignore) )","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"                        | None ->","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            Stop","counters":[]},{"line":"                              (Or_error.errorf","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"                                 !\"Coudln't find protocol state with hash %s\"","counters":[]},{"line":"                                 (State_hash.to_base58_check state_hash) ) )","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"                      ~finish:Fn.id","counters":[]},{"line":"                  with","counters":[]},{"line":"                  | Ok _ ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      Continue (Ok ())","counters":[]},{"line":"                  | e ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      Stop e )","counters":[]},{"line":"            else Continue (Ok ()) )","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"          ~finish:Fn.id","counters":[]},{"line":"      in","counters":[]},{"line":"      let snarked_ledger_hash =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Transition_frontier.Breadcrumb.block b","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"        |> Mina_block.header |> Header.protocol_state","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"        |> Mina_state.Protocol_state.blockchain_state","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"        |> Mina_state.Blockchain_state.snarked_ledger_hash","counters":[]},{"line":"      in","counters":[]},{"line":"      let merkle_root = Ledger.merkle_root ledger in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      if Frozen_ledger_hash.equal snarked_ledger_hash merkle_root then (","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"        let res = Ledger.to_list ledger in","counters":[]},{"line":"        ignore @@ Ledger.unregister_mask_exn ~loc:__LOC__ ledger ;","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"        Ok res )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      else","counters":[]},{"line":"        Or_error.errorf","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          \"Expected snarked ledger hash %s but got %s for state hash %s\"","counters":[]},{"line":"          (Frozen_ledger_hash.to_base58_check snarked_ledger_hash)","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"          (Frozen_ledger_hash.to_base58_check merkle_root)","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"          (State_hash.to_base58_check state_hash)","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"  | None ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Or_error.error_string","counters":[]},{"line":"        \"get_snarked_ledger: state hash not found in transition frontier\"","counters":[]},{"line":"","counters":[]},{"line":"let get_account t aid =","counters":[]},{"line":"  let open Participating_state.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%map ledger = best_ledger t in","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"  let open Option.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%bind loc = Ledger.location_of_account ledger aid in","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"  Ledger.get ledger loc","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let get_inferred_nonce_from_transaction_pool_and_ledger t","counters":[]},{"line":"    (account_id : Account_id.t) =","counters":[]},{"line":"  let transaction_pool = t.components.transaction_pool in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let resource_pool =","counters":[]},{"line":"    Network_pool.Transaction_pool.resource_pool transaction_pool","counters":[]},{"line":"  in","counters":[]},{"line":"  let pooled_transactions =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Network_pool.Transaction_pool.Resource_pool.all_from_account resource_pool","counters":[]},{"line":"      account_id","counters":[]},{"line":"  in","counters":[]},{"line":"  let txn_pool_nonce =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    List.last pooled_transactions","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"    |> Option.map","counters":[]},{"line":"         ~f:","counters":[]},{"line":"           (Fn.compose User_command.expected_target_nonce","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"              Transaction_hash.User_command_with_valid_signature.command )","counters":[]},{"line":"  in","counters":[]},{"line":"  match txn_pool_nonce with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | Some nonce ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Participating_state.Option.return nonce","counters":[]},{"line":"  | None ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let open Participating_state.Option.Let_syntax in","counters":[]},{"line":"      let%map account = get_account t account_id in","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"      account.Account.Poly.nonce","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"let snark_job_state t = t.snark_job_state","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"","counters":[]},{"line":"let add_block_subscriber t public_key =","counters":[]},{"line":"  Mina_subscriptions.add_block_subscriber t.subscriptions public_key","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let add_payment_subscriber t public_key =","counters":[]},{"line":"  Mina_subscriptions.add_payment_subscriber t.subscriptions public_key","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let transaction_pool t = t.components.transaction_pool","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"let snark_pool t = t.components.snark_pool","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"","counters":[]},{"line":"let peers t = Mina_networking.peers t.components.net","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"","counters":[]},{"line":"let initial_peers t = Mina_networking.initial_peers t.components.net","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"let snark_work_fee t =","counters":[]},{"line":"  match t.processes.snark_worker with `On (_, fee) -> fee | `Off fee -> fee","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"","counters":[]},{"line":"let set_snark_work_fee t new_fee =","counters":[]},{"line":"  t.processes.snark_worker <-","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    ( match t.processes.snark_worker with","counters":[]},{"line":"    | `On (config, _) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        `On (config, new_fee)","counters":[]},{"line":"    | `Off _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        `Off new_fee )","counters":[]},{"line":"","counters":[]},{"line":"let top_level_logger t = t.config.logger","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"let most_recent_valid_transition t = t.components.most_recent_valid_block","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"let block_produced_bvar t = t.components.block_produced_bvar","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"","counters":[]},{"line":"let staged_ledger_ledger_proof t =","counters":[]},{"line":"  let open Option.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%bind sl = best_staged_ledger_opt t in","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"  Staged_ledger.current_ledger_proof sl","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let validated_transitions t = t.pipes.validated_transitions_reader","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"","counters":[]},{"line":"module Root_diff = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V2 = struct","counters":[]},{"line":"      type t =","counters":[{"col_start":6,"col_end":6,"count":2},{"col_start":11,"col_end":11,"count":2}]},{"line":"        { commands : User_command.Stable.V2.t With_status.Stable.V2.t list","counters":[]},{"line":"        ; root_length : int","counters":[]},{"line":"        }","counters":[{"col_start":8,"col_end":8,"count":5}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let initialization_finish_signal t = t.initialization_finish_signal","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"(* TODO: this is a bad pattern for two reasons:","counters":[]},{"line":" *   - uses an abstraction leak to patch new functionality instead of making a new extension","counters":[]},{"line":" *   - every call to this function will create a new, unique pipe with it's own thread for transfering","counters":[]},{"line":" *     items from the identity extension with no route for termination","counters":[]},{"line":" *)","counters":[]},{"line":"let root_diff t =","counters":[]},{"line":"  let root_diff_reader, root_diff_writer =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Strict_pipe.create ~name:\"root diff\"","counters":[]},{"line":"      (Buffered (`Capacity 30, `Overflow Crash))","counters":[]},{"line":"  in","counters":[]},{"line":"  O1trace.background_thread \"read_root_diffs\" (fun () ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      let open Root_diff.Stable.Latest in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let length_of_breadcrumb b =","counters":[]},{"line":"        Transition_frontier.Breadcrumb.consensus_state b","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"        |> Consensus.Data.Consensus_state.blockchain_length","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"        |> Mina_numbers.Length.to_uint32 |> Unsigned.UInt32.to_int","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"      in","counters":[]},{"line":"      Broadcast_pipe.Reader.iter t.components.transition_frontier ~f:(function","counters":[]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Deferred.unit","counters":[]},{"line":"        | Some frontier ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let root = Transition_frontier.root frontier in","counters":[]},{"line":"            Strict_pipe.Writer.write root_diff_writer","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              { commands =","counters":[]},{"line":"                  List.map","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                    ( Transition_frontier.Breadcrumb.validated_transition root","counters":[{"col_start":72,"col_end":72,"count":0}]},{"line":"                    |> Mina_block.Validated.valid_commands )","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"                    ~f:(With_status.map ~f:User_command.forget_check)","counters":[]},{"line":"              ; root_length = length_of_breadcrumb root","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"              } ;","counters":[]},{"line":"            Broadcast_pipe.Reader.iter","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Transition_frontier.(","counters":[]},{"line":"                Extensions.(get_view_pipe (extensions frontier) Identity))","counters":[{"col_start":40,"col_end":40,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"              ~f:","counters":[]},{"line":"                (Deferred.List.iter ~f:(function","counters":[]},{"line":"                  | Transition_frontier.Diff.Full.With_mutant.E (New_node _, _)","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                    ->","counters":[]},{"line":"                      Deferred.unit","counters":[]},{"line":"                  | Transition_frontier.Diff.Full.With_mutant.E","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      (Best_tip_changed _, _) ->","counters":[]},{"line":"                      Deferred.unit","counters":[]},{"line":"                  | Transition_frontier.Diff.Full.With_mutant.E","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      (Root_transitioned { new_root; _ }, _) ->","counters":[]},{"line":"                      let root_hash =","counters":[]},{"line":"                        (Transition_frontier.Root_data.Limited.hashes new_root)","counters":[{"col_start":68,"col_end":68,"count":0}]},{"line":"                          .state_hash","counters":[]},{"line":"                      in","counters":[]},{"line":"                      let new_root_breadcrumb =","counters":[]},{"line":"                        Transition_frontier.(find_exn frontier root_hash)","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"                      in","counters":[]},{"line":"                      Strict_pipe.Writer.write root_diff_writer","counters":[]},{"line":"                        { commands =","counters":[]},{"line":"                            Transition_frontier.Breadcrumb.validated_transition","counters":[{"col_start":78,"col_end":78,"count":0}]},{"line":"                              new_root_breadcrumb","counters":[]},{"line":"                            |> Mina_block.Validated.valid_commands","counters":[{"col_start":65,"col_end":65,"count":0}]},{"line":"                            |> List.map","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"                                 ~f:","counters":[]},{"line":"                                   (With_status.map ~f:User_command.forget_check)","counters":[]},{"line":"                        ; root_length = length_of_breadcrumb new_root_breadcrumb","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"                        } ;","counters":[]},{"line":"                      Deferred.unit ) ) ) ) ;","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"  root_diff_reader","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let dump_tf t =","counters":[]},{"line":"  peek_frontier t.components.transition_frontier","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":14,"col_end":14,"count":0}]},{"line":"  |> Or_error.map ~f:Transition_frontier.visualize_to_string","counters":[]},{"line":"","counters":[]},{"line":"(** The [best_path coda] is the list of state hashes from the root to the best_tip in the transition frontier. It includes the root hash and the hash *)","counters":[]},{"line":"let best_path t =","counters":[]},{"line":"  let open Option.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%map tf = Broadcast_pipe.Reader.peek t.components.transition_frontier in","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"  let bt = Transition_frontier.best_tip tf in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  List.cons","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Transition_frontier.(root tf |> Breadcrumb.state_hash)","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"    (Transition_frontier.hash_path tf bt)","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"","counters":[]},{"line":"let best_chain ?max_length t =","counters":[]},{"line":"  let open Option.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%map frontier =","counters":[]},{"line":"    Broadcast_pipe.Reader.peek t.components.transition_frontier","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"  in","counters":[]},{"line":"  let best_tip_path = Transition_frontier.best_tip_path ?max_length frontier in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  match max_length with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | Some max_length","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    when Mina_stdlib.List.Length.Compare.(best_tip_path > max_length) ->","counters":[]},{"line":"      (* The [best_tip_path] has already been truncated to the correct length,","counters":[]},{"line":"         we skip adding the root to stay below the maximum.","counters":[]},{"line":"      *)","counters":[]},{"line":"      best_tip_path","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  | _ ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Transition_frontier.root frontier :: best_tip_path","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"let request_work t =","counters":[]},{"line":"  let (module Work_selection_method) = t.config.work_selection_method in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let fee = snark_work_fee t in","counters":[]},{"line":"  let instances_opt =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Work_selection_method.work ~logger:t.config.logger ~fee","counters":[]},{"line":"      ~snark_pool:(snark_pool t) (snark_job_state t)","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"  in","counters":[]},{"line":"  Option.map instances_opt ~f:(fun instances ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      { Snark_work_lib.Work.Spec.instances; fee } )","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"let work_selection_method t = t.config.work_selection_method","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"","counters":[]},{"line":"let add_work t (work : Snark_worker_lib.Work.Result.t) =","counters":[]},{"line":"  let (module Work_selection_method) = t.config.work_selection_method in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let update_metrics () =","counters":[]},{"line":"    let snark_pool = snark_pool t in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let fee_opt =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Option.map (snark_worker_key t) ~f:(fun _ -> snark_work_fee t)","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"    in","counters":[]},{"line":"    let pending_work =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Work_selection_method.pending_work_statements ~snark_pool ~fee_opt","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"        t.snark_job_state","counters":[]},{"line":"      |> List.length","counters":[]},{"line":"    in","counters":[]},{"line":"    Mina_metrics.(","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Gauge.set Snark_work.pending_snark_work (Int.to_float pending_work))","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"  in","counters":[]},{"line":"  let spec = work.spec.instances in","counters":[]},{"line":"  let cb _ =","counters":[]},{"line":"    (* remove it from seen jobs after attempting to adding it to the pool to avoid this work being reassigned","counters":[]},{"line":"     * If the diff is accepted then remove it from the seen jobs.","counters":[]},{"line":"     * If not then the work should have already been in the pool with a lower fee or the statement isn't referenced anymore or any other error. In any case remove it from the seen jobs so that it can be picked up if needed *)","counters":[]},{"line":"    Work_selection_method.remove t.snark_job_state spec","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  in","counters":[]},{"line":"  ignore (Or_error.try_with (fun () -> update_metrics ()) : unit Or_error.t) ;","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"  Network_pool.Snark_pool.Local_sink.push t.pipes.snark_local_sink","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"    (Network_pool.Snark_pool.Resource_pool.Diff.of_result work, cb)","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"  |> Deferred.don't_wait_for","counters":[]},{"line":"","counters":[]},{"line":"let get_current_nonce t aid =","counters":[]},{"line":"  match","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Participating_state.active","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"      (get_inferred_nonce_from_transaction_pool_and_ledger t aid)","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"    |> Option.join","counters":[]},{"line":"  with","counters":[]},{"line":"  | None ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (* IMPORTANT! Do not change the content of this error without","counters":[]},{"line":"       * updating Rosetta's construction API to handle the changes *)","counters":[]},{"line":"      Error","counters":[]},{"line":"        \"Couldn't infer nonce for transaction from specified `sender` since \\","counters":[]},{"line":"         `sender` is not in the ledger or sent a transaction in transaction \\","counters":[]},{"line":"         pool.\"","counters":[]},{"line":"  | Some nonce ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let ledger_nonce =","counters":[]},{"line":"        Participating_state.active (get_account t aid)","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"        |> Option.join","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"        |> Option.map ~f:(fun { Account.Poly.nonce; _ } -> nonce)","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"        |> Option.value ~default:nonce","counters":[]},{"line":"      in","counters":[]},{"line":"      Ok (`Min ledger_nonce, nonce)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"let add_transactions t (uc_inputs : User_command_input.t list) =","counters":[]},{"line":"  let result_ivar = Ivar.create () in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let cmd_inputs = Signed_command_inputs uc_inputs in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  Strict_pipe.Writer.write t.pipes.user_command_input_writer","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"    (cmd_inputs, Ivar.fill result_ivar, get_current_nonce t, get_account t)","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":56,"col_end":56,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"  |> Deferred.don't_wait_for ;","counters":[]},{"line":"  Ivar.read result_ivar","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let add_full_transactions t user_commands =","counters":[]},{"line":"  let add_all_txns () =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    let result_ivar = Ivar.create () in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Network_pool.Transaction_pool.Local_sink.push t.pipes.tx_local_sink","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"      (user_commands, Ivar.fill result_ivar)","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"    |> Deferred.don't_wait_for ;","counters":[]},{"line":"    Ivar.read result_ivar","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  in","counters":[]},{"line":"  let too_big_err =","counters":[]},{"line":"    List.find_map user_commands ~f:(fun cmd ->","counters":[]},{"line":"        let size_validity =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          User_command.valid_size","counters":[]},{"line":"            ~genesis_constants:t.config.precomputed_values.genesis_constants cmd","counters":[]},{"line":"        in","counters":[]},{"line":"        match size_validity with Ok () -> None | Error err -> Some err )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"  in","counters":[]},{"line":"  match too_big_err with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | None ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      add_all_txns ()","counters":[]},{"line":"  | Some err ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Deferred.Result.fail err","counters":[]},{"line":"","counters":[]},{"line":"let add_zkapp_transactions t (zkapp_commands : Zkapp_command.t list) =","counters":[]},{"line":"  let add_all_txns () =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    let result_ivar = Ivar.create () in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let cmd_inputs = Zkapp_command_command_inputs zkapp_commands in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Strict_pipe.Writer.write t.pipes.user_command_input_writer","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"      (cmd_inputs, Ivar.fill result_ivar, get_current_nonce t, get_account t)","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":58,"col_end":58,"count":0},{"col_start":73,"col_end":73,"count":0}]},{"line":"    |> Deferred.don't_wait_for ;","counters":[]},{"line":"    Ivar.read result_ivar","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  in","counters":[]},{"line":"  let too_big_err =","counters":[]},{"line":"    List.find_map zkapp_commands ~f:(fun zkapp_command ->","counters":[]},{"line":"        let size_validity =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Zkapp_command.valid_size","counters":[]},{"line":"            ~genesis_constants:t.config.precomputed_values.genesis_constants","counters":[]},{"line":"            zkapp_command","counters":[]},{"line":"        in","counters":[]},{"line":"        match size_validity with Ok () -> None | Error err -> Some err )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"  in","counters":[]},{"line":"  match too_big_err with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | None ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      add_all_txns ()","counters":[]},{"line":"  | Some err ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Deferred.Result.fail err","counters":[]},{"line":"","counters":[]},{"line":"let next_producer_timing t = t.next_producer_timing","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"let staking_ledger t =","counters":[]},{"line":"  let open Option.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let consensus_constants = t.config.precomputed_values.consensus_constants in","counters":[]},{"line":"  let%map transition_frontier =","counters":[]},{"line":"    Broadcast_pipe.Reader.peek t.components.transition_frontier","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"  in","counters":[]},{"line":"  let consensus_state =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Transition_frontier.Breadcrumb.consensus_state","counters":[]},{"line":"      (Transition_frontier.best_tip transition_frontier)","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"  in","counters":[]},{"line":"  let local_state = t.config.consensus_local_state in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  Consensus.Hooks.get_epoch_ledger ~constants:consensus_constants","counters":[]},{"line":"    ~consensus_state ~local_state","counters":[]},{"line":"","counters":[]},{"line":"let next_epoch_ledger t =","counters":[]},{"line":"  let open Option.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%map frontier =","counters":[]},{"line":"    Broadcast_pipe.Reader.peek t.components.transition_frontier","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"  in","counters":[]},{"line":"  let root = Transition_frontier.root frontier in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let root_epoch =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Transition_frontier.Breadcrumb.consensus_state root","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"    |> Consensus.Data.Consensus_state.epoch_count","counters":[]},{"line":"  in","counters":[]},{"line":"  let best_tip = Transition_frontier.best_tip frontier in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let best_tip_epoch =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Transition_frontier.Breadcrumb.consensus_state best_tip","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"    |> Consensus.Data.Consensus_state.epoch_count","counters":[]},{"line":"  in","counters":[]},{"line":"  if","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Mina_numbers.Length.(","counters":[]},{"line":"      equal root_epoch best_tip_epoch || equal best_tip_epoch zero)","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"  then","counters":[]},{"line":"    (*root is in the same epoch as the best tip and so the next epoch ledger in the local state will be updated by Proof_of_stake.frontier_root_transition. Next epoch ledger in genesis epoch is the genesis ledger*)","counters":[]},{"line":"    `Finalized","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (Consensus.Data.Local_state.next_epoch_ledger","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"         t.config.consensus_local_state )","counters":[]},{"line":"  else","counters":[]},{"line":"    (*No blocks in the new epoch is finalized yet, return nothing*)","counters":[]},{"line":"    `Notfinalized","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"let find_delegators table pk =","counters":[]},{"line":"  Option.value_map","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    (Public_key.Compressed.Table.find table pk)","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"    ~default:[] ~f:Mina_base.Account.Index.Table.data","counters":[]},{"line":"","counters":[]},{"line":"let current_epoch_delegators t ~pk =","counters":[]},{"line":"  let open Option.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%map _transition_frontier =","counters":[]},{"line":"    Broadcast_pipe.Reader.peek t.components.transition_frontier","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"  in","counters":[]},{"line":"  let current_epoch_delegatee_table =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Consensus.Data.Local_state.current_epoch_delegatee_table","counters":[]},{"line":"      ~local_state:t.config.consensus_local_state","counters":[]},{"line":"  in","counters":[]},{"line":"  find_delegators current_epoch_delegatee_table pk","counters":[]},{"line":"","counters":[]},{"line":"let last_epoch_delegators t ~pk =","counters":[]},{"line":"  let open Option.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%bind _transition_frontier =","counters":[]},{"line":"    Broadcast_pipe.Reader.peek t.components.transition_frontier","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%map last_epoch_delegatee_table =","counters":[]},{"line":"    Consensus.Data.Local_state.last_epoch_delegatee_table","counters":[]},{"line":"      ~local_state:t.config.consensus_local_state","counters":[]},{"line":"  in","counters":[]},{"line":"  find_delegators last_epoch_delegatee_table pk","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let perform_compaction t =","counters":[]},{"line":"  match Mina_compile_config.compaction_interval_ms with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | None ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ()","counters":[]},{"line":"  | Some compaction_interval_compiled ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let slot_duration_ms =","counters":[]},{"line":"        let leeway = 1000 in","counters":[]},{"line":"        t.config.precomputed_values.constraint_constants","counters":[]},{"line":"          .block_window_duration_ms + leeway","counters":[]},{"line":"      in","counters":[]},{"line":"      let expected_time_for_compaction =","counters":[]},{"line":"        match Sys.getenv \"MINA_COMPACTION_MS\" with","counters":[]},{"line":"        | Some ms ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Float.of_string ms","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            6000.","counters":[]},{"line":"      in","counters":[]},{"line":"      let span ?(incr = 0.) ms = Float.(of_int ms +. incr) |> Time.Span.of_ms in","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"      let interval_configured =","counters":[]},{"line":"        match Sys.getenv \"MINA_COMPACTION_INTERVAL_MS\" with","counters":[]},{"line":"        | Some ms ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Time.Span.of_ms (Float.of_string ms)","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            span compaction_interval_compiled","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"      in","counters":[]},{"line":"      if Time.Span.(interval_configured <= of_ms expected_time_for_compaction)","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"      then (","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"        [%log' fatal t.config.logger]","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"          \"Time between compactions %f should be greater than the expected \\","counters":[]},{"line":"           time for compaction %f\"","counters":[]},{"line":"          (Time.Span.to_ms interval_configured)","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"          expected_time_for_compaction ;","counters":[]},{"line":"        failwith","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (sprintf","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"             \"Time between compactions %f should be greater than the expected \\","counters":[]},{"line":"              time for compaction %f\"","counters":[]},{"line":"             (Time.Span.to_ms interval_configured)","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"             expected_time_for_compaction ) ) ;","counters":[]},{"line":"      let call_compact () =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let start = Time.now () in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Gc.compact () ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let span = Time.diff (Time.now ()) start in","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"        [%log' debug t.config.logger]","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"          ~metadata:[ (\"time\", `Float (Time.Span.to_ms span)) ]","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"          \"Gc.compact took $time ms\"","counters":[]},{"line":"      in","counters":[]},{"line":"      let rec perform interval =","counters":[]},{"line":"        upon (after interval) (fun () ->","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"            match !(t.block_production_status) with","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            | `Free ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                call_compact () ;","counters":[]},{"line":"                perform interval_configured","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"            | `Producing ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                perform (span slot_duration_ms)","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"            | `Producing_in_ms ms ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                if Float.(ms < expected_time_for_compaction) then","counters":[]},{"line":"                  (*too close to block production; perform compaction after block production*)","counters":[]},{"line":"                  perform (span slot_duration_ms ~incr:ms)","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"                else (","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                  call_compact () ;","counters":[]},{"line":"                  perform interval_configured ) )","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"      in","counters":[]},{"line":"      perform interval_configured","counters":[]},{"line":"","counters":[]},{"line":"(* let check_and_stop_daemon t ~wait = *)","counters":[]},{"line":"(*   let uptime_mins = *)","counters":[]},{"line":"(*     Time_ns.(diff (now ()) daemon_start_time |> Span.to_min |> Int.of_float) *)","counters":[]},{"line":"(*   in *)","counters":[]},{"line":"(*   let max_catchup_time = Time.Span.of_hr 1. in *)","counters":[]},{"line":"(*   if uptime_mins <= wait then *)","counters":[]},{"line":"(*     `Check_in *)","counters":[]},{"line":"(*       (Block_time.Span.to_time_span *)","counters":[]},{"line":"(*          t.config.precomputed_values.consensus_constants.slot_duration_ms ) *)","counters":[]},{"line":"(*   else *)","counters":[]},{"line":"(*     match t.next_producer_timing with *)","counters":[]},{"line":"(*     | None -> *)","counters":[]},{"line":"(*         `Now *)","counters":[]},{"line":"(*     | Some timing -> ( *)","counters":[]},{"line":"(*         match timing.timing with *)","counters":[]},{"line":"(*         | Daemon_rpcs.Types.Status.Next_producer_timing.Check_again tm *)","counters":[]},{"line":"(*         | Produce { time = tm; _ } *)","counters":[]},{"line":"(*         | Produce_now { time = tm; _ } -> *)","counters":[]},{"line":"(*             let tm = Block_time.to_time_exn tm in *)","counters":[]},{"line":"(*             (\\*Assuming it takes at most 1hr to bootstrap and catchup*\\) *)","counters":[]},{"line":"(*             let next_block = *)","counters":[]},{"line":"(*               Time.add tm *)","counters":[]},{"line":"(*                 (Block_time.Span.to_time_span *)","counters":[]},{"line":"(*                    t.config.precomputed_values.consensus_constants *)","counters":[]},{"line":"(*                      .slot_duration_ms ) *)","counters":[]},{"line":"(*             in *)","counters":[]},{"line":"(*             let wait_for = Time.(diff next_block (now ())) in *)","counters":[]},{"line":"(*             if Time.Span.(wait_for > max_catchup_time) then `Now *)","counters":[]},{"line":"(*             else `Check_in wait_for *)","counters":[]},{"line":"(*         | Evaluating_vrf _last_checked_slot -> *)","counters":[]},{"line":"(*             `Check_in *)","counters":[]},{"line":"(*               (Core.Time.Span.of_ms *)","counters":[]},{"line":"(*                  (Mina_compile_config.vrf_poll_interval_ms * 2 |> Int.to_float) ) *)","counters":[]},{"line":"(*         ) *)","counters":[]},{"line":"","counters":[]},{"line":"(* let stop_long_running_daemon t = *)","counters":[]},{"line":"(*   let wait_mins = (t.config.stop_time * 60) + (Random.int 10 * 60) in *)","counters":[]},{"line":"(*   [%log' info t.config.logger] *)","counters":[]},{"line":"(* \"Stopping daemon after $wait mins and when there are no blocks to be \\ *)","counters":[]},{"line":"   (*      produced\" *)","counters":[]},{"line":"(*     ~metadata:[ (\"wait\", `Int wait_mins) ] ; *)","counters":[]},{"line":"(*   let stop_daemon () = *)","counters":[]},{"line":"(*     let uptime_mins = *)","counters":[]},{"line":"(*       Time_ns.(diff (now ()) daemon_start_time |> Span.to_min |> Int.of_float) *)","counters":[]},{"line":"(*     in *)","counters":[]},{"line":"(*     [%log' info t.config.logger] *)","counters":[]},{"line":"(*       \"Deamon has been running for $uptime mins. Stopping now...\" *)","counters":[]},{"line":"(*       ~metadata:[ (\"uptime\", `Int uptime_mins) ] ; *)","counters":[]},{"line":"(*     Scheduler.yield () *)","counters":[]},{"line":"(*     >>= (fun () -> return (Async.shutdown 1)) *)","counters":[]},{"line":"(*     |> don't_wait_for *)","counters":[]},{"line":"(*   in *)","counters":[]},{"line":"(*   let rec go interval = *)","counters":[]},{"line":"(*     upon (after interval) (fun () -> *)","counters":[]},{"line":"(*         match check_and_stop_daemon t ~wait:wait_mins with *)","counters":[]},{"line":"(*         | `Now -> *)","counters":[]},{"line":"(*             stop_daemon () *)","counters":[]},{"line":"(*         | `Check_in tm -> *)","counters":[]},{"line":"(*             go tm ) *)","counters":[]},{"line":"(*   in *)","counters":[]},{"line":"(*   go (Time.Span.of_ms (wait_mins * 60 * 1000 |> Float.of_int)) *)","counters":[]},{"line":"","counters":[]},{"line":"let offline_time","counters":[]},{"line":"    { Genesis_constants.Constraint_constants.block_window_duration_ms; _ } =","counters":[]},{"line":"  (* This is a bit of a hack, see #3232. *)","counters":[]},{"line":"  let inactivity_ms = block_window_duration_ms * 8 in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  Block_time.Span.of_ms @@ Int64.of_int inactivity_ms","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"","counters":[]},{"line":"let setup_timer ~constraint_constants time_controller sync_state_broadcaster =","counters":[]},{"line":"  Block_time.Timeout.create time_controller (offline_time constraint_constants)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"    ~f:(fun _ ->","counters":[]},{"line":"      Broadcast_pipe.Writer.write sync_state_broadcaster `Offline","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"      |> don't_wait_for )","counters":[]},{"line":"","counters":[]},{"line":"let online_broadcaster ~constraint_constants time_controller =","counters":[]},{"line":"  let online_reader, online_writer = Broadcast_pipe.create `Offline in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let init =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Block_time.Timeout.create time_controller","counters":[]},{"line":"      (Block_time.Span.of_ms Int64.zero)","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"      ~f:ignore","counters":[]},{"line":"  in","counters":[]},{"line":"  let current_timer = ref init in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let notify_online () =","counters":[]},{"line":"    let%map () = Broadcast_pipe.Writer.write online_writer `Online in","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"    Block_time.Timeout.cancel time_controller !current_timer () ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    current_timer :=","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      setup_timer ~constraint_constants time_controller online_writer","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"  in","counters":[]},{"line":"  (online_reader, notify_online)","counters":[]},{"line":"","counters":[]},{"line":"module type CONTEXT = sig","counters":[]},{"line":"  val logger : Logger.t","counters":[]},{"line":"","counters":[]},{"line":"  val precomputed_values : Precomputed_values.t","counters":[]},{"line":"","counters":[]},{"line":"  val constraint_constants : Genesis_constants.Constraint_constants.t","counters":[]},{"line":"","counters":[]},{"line":"  val consensus_constants : Consensus.Constants.t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let context (config : Config.t) : (module CONTEXT) =","counters":[]},{"line":"  ( module struct","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    let logger = config.logger","counters":[]},{"line":"","counters":[]},{"line":"    let precomputed_values = config.precomputed_values","counters":[]},{"line":"","counters":[]},{"line":"    let consensus_constants = precomputed_values.consensus_constants","counters":[]},{"line":"","counters":[]},{"line":"    let constraint_constants = precomputed_values.constraint_constants","counters":[]},{"line":"  end )","counters":[]},{"line":"","counters":[]},{"line":"let start t =","counters":[]},{"line":"  let set_next_producer_timing timing consensus_state =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    let block_production_status, next_producer_timing =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let generated_from_consensus_at :","counters":[]},{"line":"          Daemon_rpcs.Types.Status.Next_producer_timing.slot =","counters":[]},{"line":"        { slot = Consensus.Data.Consensus_state.curr_global_slot consensus_state","counters":[{"col_start":63,"col_end":63,"count":0}]},{"line":"        ; global_slot_since_genesis =","counters":[]},{"line":"            Consensus.Data.Consensus_state.global_slot_since_genesis","counters":[{"col_start":67,"col_end":67,"count":0}]},{"line":"              consensus_state","counters":[]},{"line":"        }","counters":[]},{"line":"      in","counters":[]},{"line":"      let info time (data : Consensus.Data.Block_data.t) :","counters":[]},{"line":"          Daemon_rpcs.Types.Status.Next_producer_timing.producing_time =","counters":[]},{"line":"        let for_slot : Daemon_rpcs.Types.Status.Next_producer_timing.slot =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          { slot = Consensus.Data.Block_data.global_slot data","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"          ; global_slot_since_genesis =","counters":[]},{"line":"              Consensus.Data.Block_data.global_slot_since_genesis data","counters":[{"col_start":64,"col_end":64,"count":0}]},{"line":"          }","counters":[]},{"line":"        in","counters":[]},{"line":"        { time; for_slot }","counters":[]},{"line":"      in","counters":[]},{"line":"      let status, timing =","counters":[]},{"line":"        match timing with","counters":[]},{"line":"        | `Check_again block_time ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ( `Free","counters":[]},{"line":"            , Daemon_rpcs.Types.Status.Next_producer_timing.Check_again","counters":[]},{"line":"                block_time )","counters":[]},{"line":"        | `Evaluating_vrf last_checked_slot ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (* Vrf evaluation is still going on, so treating it as if a block is being produced*)","counters":[]},{"line":"            (`Producing, Evaluating_vrf last_checked_slot)","counters":[]},{"line":"        | `Produce_now (block_data, _) ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let info :","counters":[]},{"line":"                Daemon_rpcs.Types.Status.Next_producer_timing.producing_time =","counters":[]},{"line":"              let time =","counters":[]},{"line":"                Consensus.Data.Consensus_time.of_global_slot","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"                  ~constants:t.config.precomputed_values.consensus_constants","counters":[]},{"line":"                  (Consensus.Data.Block_data.global_slot block_data)","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"                |> Consensus.Data.Consensus_time.to_time","counters":[]},{"line":"                     ~constants:t.config.precomputed_values.consensus_constants","counters":[]},{"line":"              in","counters":[]},{"line":"              info time block_data","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"            in","counters":[]},{"line":"            (`Producing, Produce_now info)","counters":[]},{"line":"        | `Produce (time, block_data, _) ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ( `Producing_in_ms (Int64.to_float time)","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"            , Produce","counters":[]},{"line":"                (info","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                   ( time |> Block_time.Span.of_ms","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"                   |> Block_time.of_span_since_epoch )","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                   block_data ) )","counters":[]},{"line":"      in","counters":[]},{"line":"      ( status","counters":[]},{"line":"      , { Daemon_rpcs.Types.Status.Next_producer_timing.timing","counters":[]},{"line":"        ; generated_from_consensus_at","counters":[]},{"line":"        } )","counters":[]},{"line":"    in","counters":[]},{"line":"    t.block_production_status := block_production_status ;","counters":[]},{"line":"    t.next_producer_timing <- Some next_producer_timing","counters":[]},{"line":"  in","counters":[]},{"line":"  if","counters":[]},{"line":"    not","counters":[]},{"line":"      (Keypair.And_compressed_pk.Set.is_empty t.config.block_production_keypairs)","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"  then","counters":[]},{"line":"    Block_producer.run ~context:(context t.config)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"      ~vrf_evaluator:t.processes.vrf_evaluator ~verifier:t.processes.verifier","counters":[]},{"line":"      ~set_next_producer_timing ~prover:t.processes.prover","counters":[]},{"line":"      ~trust_system:t.config.trust_system","counters":[]},{"line":"      ~transaction_resource_pool:","counters":[]},{"line":"        (Network_pool.Transaction_pool.resource_pool","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"           t.components.transaction_pool )","counters":[]},{"line":"      ~get_completed_work:","counters":[]},{"line":"        (Network_pool.Snark_pool.get_completed_work t.components.snark_pool)","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"      ~time_controller:t.config.time_controller","counters":[]},{"line":"      ~coinbase_receiver:t.coinbase_receiver","counters":[]},{"line":"      ~consensus_local_state:t.config.consensus_local_state","counters":[]},{"line":"      ~frontier_reader:t.components.transition_frontier","counters":[]},{"line":"      ~transition_writer:t.pipes.producer_transition_writer","counters":[]},{"line":"      ~log_block_creation:t.config.log_block_creation","counters":[]},{"line":"      ~block_reward_threshold:t.config.block_reward_threshold","counters":[]},{"line":"      ~block_produced_bvar:t.components.block_produced_bvar ;","counters":[]},{"line":"  perform_compaction t ;","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let () =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    match t.config.node_status_url with","counters":[]},{"line":"    | Some node_status_url ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Node_status_service.start ~logger:t.config.logger ~node_status_url","counters":[]},{"line":"          ~network:t.components.net","counters":[]},{"line":"          ~transition_frontier:t.components.transition_frontier","counters":[]},{"line":"          ~sync_status:t.sync_status","counters":[]},{"line":"          ~addrs_and_ports:t.config.gossip_net_params.addrs_and_ports","counters":[]},{"line":"          ~start_time:t.config.start_time","counters":[]},{"line":"          ~slot_duration:","counters":[]},{"line":"            (Block_time.Span.to_time_span","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"               t.config.precomputed_values.consensus_constants.slot_duration_ms )","counters":[]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ()","counters":[]},{"line":"  in","counters":[]},{"line":"  Uptime_service.start ~logger:t.config.logger ~uptime_url:t.config.uptime_url","counters":[]},{"line":"    ~snark_worker_opt:t.processes.uptime_snark_worker_opt","counters":[]},{"line":"    ~transition_frontier:t.components.transition_frontier","counters":[]},{"line":"    ~time_controller:t.config.time_controller","counters":[]},{"line":"    ~block_produced_bvar:t.components.block_produced_bvar","counters":[]},{"line":"    ~uptime_submitter_keypair:t.config.uptime_submitter_keypair","counters":[]},{"line":"    ~get_next_producer_timing:(fun () -> t.next_producer_timing)","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"    ~get_snark_work_fee:(fun () -> snark_work_fee t)","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"    ~get_peer:(fun () -> t.config.gossip_net_params.addrs_and_ports.peer) ;","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"  (* stop_long_running_daemon t ; *)","counters":[]},{"line":"  Snark_worker.start t","counters":[]},{"line":"","counters":[]},{"line":"let start_with_precomputed_blocks t blocks =","counters":[]},{"line":"  let%bind () =","counters":[]},{"line":"    Block_producer.run_precomputed ~context:(context t.config)","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"      ~verifier:t.processes.verifier ~trust_system:t.config.trust_system","counters":[]},{"line":"      ~time_controller:t.config.time_controller","counters":[]},{"line":"      ~frontier_reader:t.components.transition_frontier","counters":[]},{"line":"      ~transition_writer:t.pipes.producer_transition_writer","counters":[]},{"line":"      ~precomputed_blocks:blocks","counters":[]},{"line":"  in","counters":[]},{"line":"  start t","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let send_resource_pool_diff_or_wait ~rl ~diff_score ~max_per_15_seconds diff =","counters":[]},{"line":"  (* HACK: Pretend we're a remote peer so that we can rate limit","counters":[]},{"line":"                 ourselves.","counters":[]},{"line":"  *)","counters":[]},{"line":"  let us =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    { Network_peer.Peer.host = Unix.Inet_addr.of_string \"127.0.0.1\"","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"    ; libp2p_port = 0","counters":[]},{"line":"    ; peer_id = \"\"","counters":[]},{"line":"    }","counters":[]},{"line":"  in","counters":[]},{"line":"  let score = diff_score diff in","counters":[]},{"line":"  let rec able_to_send_or_wait () =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    match","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Network_pool.Rate_limiter.add rl (Remote us) ~now:(Time.now ()) ~score","counters":[{"col_start":64,"col_end":64,"count":0}]},{"line":"    with","counters":[]},{"line":"    | `Within_capacity ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Deferred.return ()","counters":[]},{"line":"    | `Capacity_exceeded ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        if score > max_per_15_seconds then (","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"          (* This will never pass the rate limiting; pass it on","counters":[]},{"line":"                             to progress in the queue. *)","counters":[]},{"line":"          ignore","counters":[]},{"line":"            ( Network_pool.Rate_limiter.add rl (Remote us) ~now:(Time.now ())","counters":[{"col_start":42,"col_end":42,"count":0},{"col_start":72,"col_end":72,"count":0}]},{"line":"                ~score:0","counters":[]},{"line":"              : [ `Within_capacity | `Capacity_exceeded ] ) ;","counters":[]},{"line":"          Deferred.return () )","counters":[]},{"line":"        else","counters":[]},{"line":"          let%bind () =","counters":[]},{"line":"            after","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"              Time.(","counters":[]},{"line":"                diff (now ())","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"                  (Network_pool.Rate_limiter.next_expires rl (Remote us)))","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"          in","counters":[]},{"line":"          able_to_send_or_wait ()","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"  in","counters":[]},{"line":"  able_to_send_or_wait ()","counters":[]},{"line":"","counters":[]},{"line":"let create ?wallets (config : Config.t) =","counters":[]},{"line":"  let module Context = (val context config) in","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"  let catchup_mode = if config.super_catchup then `Super else `Normal in","counters":[{"col_start":50,"col_end":50,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"  let constraint_constants = config.precomputed_values.constraint_constants in","counters":[]},{"line":"  let consensus_constants = config.precomputed_values.consensus_constants in","counters":[]},{"line":"  let monitor = Option.value ~default:(Monitor.create ()) config.monitor in","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"  Async.Scheduler.within' ~monitor (fun () ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      O1trace.thread \"mina_lib\" (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          let%bind prover =","counters":[]},{"line":"            Monitor.try_with ~here:[%here]","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"              ~rest:","counters":[]},{"line":"                (`Call","counters":[]},{"line":"                  (fun exn ->","counters":[]},{"line":"                    let err = Error.of_exn ~backtrace:`Get exn in","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                    [%log' warn config.logger]","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"                      \"unhandled exception from daemon-side prover server: $exn\"","counters":[]},{"line":"                      ~metadata:[ (\"exn\", Error_json.error_to_yojson err) ] ) )","counters":[{"col_start":67,"col_end":67,"count":0}]},{"line":"              (fun () ->","counters":[]},{"line":"                O1trace.thread \"manage_prover_subprocess\" (fun () ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                    Prover.create ~logger:config.logger","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      ~proof_level:config.precomputed_values.proof_level","counters":[]},{"line":"                      ~constraint_constants ~pids:config.pids","counters":[]},{"line":"                      ~conf_dir:config.conf_dir ) )","counters":[]},{"line":"            >>| Result.ok_exn","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%bind verifier =","counters":[]},{"line":"            Monitor.try_with ~here:[%here]","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"              ~rest:","counters":[]},{"line":"                (`Call","counters":[]},{"line":"                  (fun exn ->","counters":[]},{"line":"                    let err = Error.of_exn ~backtrace:`Get exn in","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                    [%log' warn config.logger]","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"                      \"unhandled exception from daemon-side verifier server: \\","counters":[]},{"line":"                       $exn\"","counters":[]},{"line":"                      ~metadata:[ (\"exn\", Error_json.error_to_yojson err) ] ) )","counters":[{"col_start":67,"col_end":67,"count":0}]},{"line":"              (fun () ->","counters":[]},{"line":"                O1trace.thread \"manage_verifier_subprocess\" (fun () ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                    Verifier.create ~logger:config.logger","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      ~proof_level:config.precomputed_values.proof_level","counters":[]},{"line":"                      ~constraint_constants:","counters":[]},{"line":"                        config.precomputed_values.constraint_constants","counters":[]},{"line":"                      ~pids:config.pids ~conf_dir:(Some config.conf_dir) ) )","counters":[]},{"line":"            >>| Result.ok_exn","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%bind vrf_evaluator =","counters":[]},{"line":"            Monitor.try_with ~here:[%here]","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"              ~rest:","counters":[]},{"line":"                (`Call","counters":[]},{"line":"                  (fun exn ->","counters":[]},{"line":"                    let err = Error.of_exn ~backtrace:`Get exn in","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                    [%log' warn config.logger]","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"                      \"unhandled exception from daemon-side vrf evaluator \\","counters":[]},{"line":"                       server: $exn\"","counters":[]},{"line":"                      ~metadata:[ (\"exn\", Error_json.error_to_yojson err) ] ) )","counters":[{"col_start":67,"col_end":67,"count":0}]},{"line":"              (fun () ->","counters":[]},{"line":"                O1trace.thread \"manage_vrf_evaluator_subprocess\" (fun () ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                    Vrf_evaluator.create ~constraint_constants ~pids:config.pids","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      ~logger:config.logger ~conf_dir:config.conf_dir","counters":[]},{"line":"                      ~consensus_constants","counters":[]},{"line":"                      ~keypairs:config.block_production_keypairs ) )","counters":[]},{"line":"            >>| Result.ok_exn","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"          in","counters":[]},{"line":"          let snark_worker =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Option.value_map config.snark_worker_config.initial_snark_worker_key","counters":[]},{"line":"              ~default:(`Off config.snark_work_fee) ~f:(fun public_key ->","counters":[]},{"line":"                `On","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  ( { public_key","counters":[]},{"line":"                    ; process = Ivar.create ()","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"                    ; kill_ivar = Ivar.create ()","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"                    }","counters":[]},{"line":"                  , config.snark_work_fee ) )","counters":[]},{"line":"          in","counters":[]},{"line":"          let%bind uptime_snark_worker_opt =","counters":[]},{"line":"            (* if uptime URL provided, run uptime service SNARK worker *)","counters":[]},{"line":"            Option.value_map config.uptime_url ~default:(return None)","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"              ~f:(fun _url ->","counters":[]},{"line":"                Monitor.try_with ~here:[%here]","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"                  ~rest:","counters":[]},{"line":"                    (`Call","counters":[]},{"line":"                      (fun exn ->","counters":[]},{"line":"                        let err = Error.of_exn ~backtrace:`Get exn in","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                        [%log' fatal config.logger]","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"                          \"unhandled exception from uptime service SNARK \\","counters":[]},{"line":"                           worker: $exn, terminating daemon\"","counters":[]},{"line":"                          ~metadata:[ (\"exn\", Error_json.error_to_yojson err) ] ;","counters":[{"col_start":71,"col_end":71,"count":0}]},{"line":"                        (* make sure Async shutdown handlers are called *)","counters":[]},{"line":"                        don't_wait_for (Async.exit 1) ) )","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"                  (fun () ->","counters":[]},{"line":"                    O1trace.thread \"manage_uptimer_snark_worker_subprocess\"","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      (fun () ->","counters":[]},{"line":"                        Uptime_service.Uptime_snark_worker.create","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          ~logger:config.logger ~pids:config.pids ) )","counters":[]},{"line":"                >>| Result.ok )","counters":[]},{"line":"          in","counters":[]},{"line":"          log_snark_coordinator_warning config snark_worker ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          Protocol_version.set_current config.initial_protocol_version ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          Protocol_version.set_proposed_opt config.proposed_protocol_version_opt ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let log_rate_limiter_occasionally rl ~label =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let t = Time.Span.of_min 1. in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            every t (fun () ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"                [%log' debug config.logger]","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"                  ~metadata:","counters":[]},{"line":"                    [ (\"rate_limiter\", Network_pool.Rate_limiter.summary rl) ]","counters":[{"col_start":71,"col_end":71,"count":0}]},{"line":"                  !\"%s $rate_limiter\" label )","counters":[]},{"line":"          in","counters":[]},{"line":"          let producer_transition_reader, producer_transition_writer =","counters":[]},{"line":"            Strict_pipe.create Synchronous","counters":[]},{"line":"          in","counters":[]},{"line":"          let frontier_broadcast_pipe_r, frontier_broadcast_pipe_w =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Broadcast_pipe.create None","counters":[]},{"line":"          in","counters":[]},{"line":"          Exit_handlers.register_async_shutdown_handler ~logger:config.logger","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ~description:\"Close transition frontier, if exists\" (fun () ->","counters":[]},{"line":"              match Broadcast_pipe.Reader.peek frontier_broadcast_pipe_r with","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              | None ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Deferred.unit","counters":[]},{"line":"              | Some frontier ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Transition_frontier.close ~loc:__LOC__ frontier ) ;","counters":[]},{"line":"          let handle_request name ~f query_env =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            O1trace.thread (\"handle_request_\" ^ name) (fun () ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"                let input = Envelope.Incoming.data query_env in","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                Deferred.return","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                @@","counters":[]},{"line":"                let open Option.Let_syntax in","counters":[]},{"line":"                let%bind frontier =","counters":[]},{"line":"                  Broadcast_pipe.Reader.peek frontier_broadcast_pipe_r","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"                in","counters":[]},{"line":"                f ~frontier input )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"          in","counters":[]},{"line":"          (* knot-tying hacks so we can pass a get_node_status function before net, Mina_lib.t created *)","counters":[]},{"line":"          let net_ref = ref None in","counters":[]},{"line":"          let sync_status_ref = ref None in","counters":[]},{"line":"          let get_node_status _env =","counters":[]},{"line":"            O1trace.thread \"handle_request_get_node_status\" (fun () ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"                let node_ip_addr =","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  config.gossip_net_params.addrs_and_ports.external_ip","counters":[]},{"line":"                in","counters":[]},{"line":"                let peer_opt = config.gossip_net_params.addrs_and_ports.peer in","counters":[]},{"line":"                let node_peer_id =","counters":[]},{"line":"                  Option.value_map peer_opt ~default:\"<UNKNOWN>\" ~f:(fun peer ->","counters":[]},{"line":"                      peer.peer_id )","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                in","counters":[]},{"line":"                if config.disable_node_status then","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Deferred.return","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  @@ Error","counters":[]},{"line":"                       (Error.of_string","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"                          (sprintf","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"                             !\"Node with IP address=%{sexp: Unix.Inet_addr.t}, \\","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                               peer ID=%s, node status is disabled\"","counters":[]},{"line":"                             node_ip_addr node_peer_id ) )","counters":[]},{"line":"                else","counters":[]},{"line":"                  match !net_ref with","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  | None ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      (* should be unreachable; without a network, we wouldn't receive this RPC call *)","counters":[]},{"line":"                      [%log' info config.logger]","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"                        \"Network not instantiated when node status requested\" ;","counters":[]},{"line":"                      Deferred.return","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                      @@ Error","counters":[]},{"line":"                           (Error.of_string","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"                              (sprintf","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                                 !\"Node with IP address=%{sexp: \\","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"                                   Unix.Inet_addr.t}, peer ID=%s, network not \\","counters":[]},{"line":"                                   instantiated when node status requested\"","counters":[]},{"line":"                                 node_ip_addr node_peer_id ) )","counters":[]},{"line":"                  | Some net ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      let ( protocol_state_hash","counters":[]},{"line":"                          , best_tip_opt","counters":[]},{"line":"                          , k_block_hashes_and_timestamps ) =","counters":[]},{"line":"                        match","counters":[]},{"line":"                          Broadcast_pipe.Reader.peek frontier_broadcast_pipe_r","counters":[]},{"line":"                        with","counters":[]},{"line":"                        | None ->","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            ( config.precomputed_values","counters":[]},{"line":"                                .protocol_state_with_hashes","counters":[]},{"line":"                                .hash","counters":[]},{"line":"                                .state_hash","counters":[]},{"line":"                            , None","counters":[]},{"line":"                            , [] )","counters":[]},{"line":"                        | Some frontier ->","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            let tip = Transition_frontier.best_tip frontier in","counters":[]},{"line":"                            let protocol_state_hash =","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                              Transition_frontier.Breadcrumb.state_hash tip","counters":[]},{"line":"                            in","counters":[]},{"line":"                            let k_breadcrumbs =","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                              Transition_frontier.root frontier","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"                              :: Transition_frontier.best_tip_path frontier","counters":[{"col_start":65,"col_end":65,"count":0}]},{"line":"                            in","counters":[]},{"line":"                            let k_block_hashes_and_timestamps =","counters":[]},{"line":"                              List.map k_breadcrumbs ~f:(fun bc ->","counters":[]},{"line":"                                  ( Transition_frontier.Breadcrumb.state_hash bc","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":76,"col_end":76,"count":0}]},{"line":"                                  , Option.value_map","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                                      (Transition_frontier.Breadcrumb","counters":[]},{"line":"                                       .transition_receipt_time bc )","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"                                      ~default:\"no timestamp available\"","counters":[]},{"line":"                                      ~f:","counters":[]},{"line":"                                        (Time.to_string_iso8601_basic","counters":[]},{"line":"                                           ~zone:Time.Zone.utc ) ) )","counters":[]},{"line":"                            in","counters":[]},{"line":"                            ( protocol_state_hash","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                            , Some tip","counters":[]},{"line":"                            , k_block_hashes_and_timestamps )","counters":[]},{"line":"                      in","counters":[]},{"line":"                      let%bind peers = Mina_networking.peers net in","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"                      let open Deferred.Or_error.Let_syntax in","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                      let%map sync_status =","counters":[]},{"line":"                        match !sync_status_ref with","counters":[]},{"line":"                        | None ->","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            Deferred.return (Ok `Offline)","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"                        | Some status ->","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            Deferred.return","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"                              (Mina_incremental.Status.Observer.value status)","counters":[{"col_start":68,"col_end":68,"count":0}]},{"line":"                      in","counters":[]},{"line":"                      let block_producers =","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        config.block_production_keypairs","counters":[]},{"line":"                        |> Public_key.Compressed.Set.map ~f:snd","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"                        |> Set.to_list","counters":[]},{"line":"                      in","counters":[]},{"line":"                      let ban_statuses =","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        Trust_system.Peer_trust.peer_statuses","counters":[]},{"line":"                          config.trust_system","counters":[]},{"line":"                      in","counters":[]},{"line":"                      let git_commit = Mina_version.commit_id_short in","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                      let uptime_minutes =","counters":[]},{"line":"                        let now = Time.now () in","counters":[]},{"line":"                        let minutes_float =","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          Time.diff now config.start_time |> Time.Span.to_min","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"                        in","counters":[]},{"line":"                        (* if rounding fails, just convert *)","counters":[]},{"line":"                        Option.value_map","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"                          (Float.iround_nearest minutes_float)","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"                          ~f:Fn.id","counters":[]},{"line":"                          ~default:(Float.to_int minutes_float)","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"                      in","counters":[]},{"line":"                      let block_height_opt =","counters":[]},{"line":"                        match best_tip_opt with","counters":[]},{"line":"                        | None ->","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            None","counters":[]},{"line":"                        | Some tip ->","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            let state =","counters":[]},{"line":"                              Transition_frontier.Breadcrumb.protocol_state tip","counters":[]},{"line":"                            in","counters":[]},{"line":"                            let consensus_state =","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                              state |> Mina_state.Protocol_state.consensus_state","counters":[]},{"line":"                            in","counters":[]},{"line":"                            Some","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                              ( Mina_numbers.Length.to_int","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"                              @@ Consensus.Data.Consensus_state","counters":[]},{"line":"                                 .blockchain_length consensus_state )","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                      in","counters":[]},{"line":"                      Mina_networking.Rpcs.Get_node_status.Node_status.","counters":[]},{"line":"                        { node_ip_addr","counters":[]},{"line":"                        ; node_peer_id","counters":[]},{"line":"                        ; sync_status","counters":[]},{"line":"                        ; peers","counters":[]},{"line":"                        ; block_producers","counters":[]},{"line":"                        ; protocol_state_hash","counters":[]},{"line":"                        ; ban_statuses","counters":[]},{"line":"                        ; k_block_hashes_and_timestamps","counters":[]},{"line":"                        ; git_commit","counters":[]},{"line":"                        ; uptime_minutes","counters":[]},{"line":"                        ; block_height_opt","counters":[]},{"line":"                        } )","counters":[]},{"line":"          in","counters":[]},{"line":"          let get_some_initial_peers _ =","counters":[]},{"line":"            O1trace.thread \"handle_request_get_some_initial_peers\" (fun () ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"                match !net_ref with","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                | None ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    (* should be unreachable; without a network, we wouldn't receive this RPC call *)","counters":[]},{"line":"                    [%log' error config.logger]","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"                      \"Network not instantiated when initial peers requested\" ;","counters":[]},{"line":"                    Deferred.return []","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                | Some net ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    Mina_networking.peers net )","counters":[]},{"line":"          in","counters":[]},{"line":"          let txn_pool_config =","counters":[]},{"line":"            Network_pool.Transaction_pool.Resource_pool.make_config ~verifier","counters":[]},{"line":"              ~trust_system:config.trust_system","counters":[]},{"line":"              ~pool_max_size:","counters":[]},{"line":"                config.precomputed_values.genesis_constants.txpool_max_size","counters":[]},{"line":"              ~genesis_constants:config.precomputed_values.genesis_constants","counters":[]},{"line":"          in","counters":[]},{"line":"          let first_received_message_signal = Ivar.create () in","counters":[]},{"line":"          let online_status, notify_online_impl =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            online_broadcaster","counters":[]},{"line":"              ~constraint_constants:config.net_config.constraint_constants","counters":[]},{"line":"              config.time_controller","counters":[]},{"line":"          in","counters":[]},{"line":"          let on_first_received_message ~f =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Ivar.read first_received_message_signal >>| f","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":20,"col_end":20,"count":0}]},{"line":"          in","counters":[]},{"line":"","counters":[]},{"line":"          (* TODO remove the line below after making sure notification will not lead","counters":[]},{"line":"             to a stale lock *)","counters":[]},{"line":"          let notify_online () =","counters":[]},{"line":"            Ivar.fill_if_empty first_received_message_signal () ;","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            notify_online_impl () |> don't_wait_for ;","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"            Deferred.unit","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          in","counters":[]},{"line":"          let transaction_pool, tx_remote_sink, tx_local_sink =","counters":[]},{"line":"            (* make transaction pool return writer for local and incoming diffs *)","counters":[]},{"line":"            Network_pool.Transaction_pool.create ~config:txn_pool_config","counters":[]},{"line":"              ~constraint_constants ~consensus_constants","counters":[]},{"line":"              ~time_controller:config.time_controller ~logger:config.logger","counters":[]},{"line":"              ~frontier_broadcast_pipe:frontier_broadcast_pipe_r","counters":[]},{"line":"              ~expiry_ns:","counters":[]},{"line":"                (Time_ns.Span.of_hr","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"                   (Float.of_int","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                      config.precomputed_values.genesis_constants","counters":[]},{"line":"                        .transaction_expiry_hr ) )","counters":[]},{"line":"              ~on_remote_push:notify_online","counters":[]},{"line":"              ~log_gossip_heard:","counters":[]},{"line":"                config.net_config.log_gossip_heard.transaction_pool_diff","counters":[]},{"line":"          in","counters":[]},{"line":"          let snark_pool_config =","counters":[]},{"line":"            Network_pool.Snark_pool.Resource_pool.make_config ~verifier","counters":[]},{"line":"              ~trust_system:config.trust_system","counters":[]},{"line":"              ~disk_location:config.snark_pool_disk_location","counters":[]},{"line":"          in","counters":[]},{"line":"          let%bind snark_pool, snark_remote_sink, snark_local_sink =","counters":[]},{"line":"            Network_pool.Snark_pool.load ~config:snark_pool_config","counters":[]},{"line":"              ~constraint_constants ~consensus_constants","counters":[]},{"line":"              ~time_controller:config.time_controller ~logger:config.logger","counters":[]},{"line":"              ~frontier_broadcast_pipe:frontier_broadcast_pipe_r","counters":[]},{"line":"              ~expiry_ns:","counters":[]},{"line":"                (Time_ns.Span.of_hr","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"                   (Float.of_int","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                      config.precomputed_values.genesis_constants","counters":[]},{"line":"                        .transaction_expiry_hr ) )","counters":[]},{"line":"              ~on_remote_push:notify_online","counters":[]},{"line":"              ~log_gossip_heard:","counters":[]},{"line":"                config.net_config.log_gossip_heard.snark_pool_diff","counters":[]},{"line":"          in","counters":[]},{"line":"          let block_reader, block_sink =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Transition_handler.Block_sink.create","counters":[]},{"line":"              { logger = config.logger","counters":[]},{"line":"              ; slot_duration_ms =","counters":[]},{"line":"                  config.precomputed_values.consensus_constants.slot_duration_ms","counters":[]},{"line":"              ; on_push = notify_online","counters":[]},{"line":"              ; log_gossip_heard = config.net_config.log_gossip_heard.new_state","counters":[]},{"line":"              ; time_controller = config.net_config.time_controller","counters":[]},{"line":"              ; consensus_constants = config.net_config.consensus_constants","counters":[]},{"line":"              ; genesis_constants = config.precomputed_values.genesis_constants","counters":[]},{"line":"              }","counters":[]},{"line":"          in","counters":[]},{"line":"          let sinks = (block_sink, tx_remote_sink, snark_remote_sink) in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let%bind net =","counters":[]},{"line":"            O1trace.thread \"mina_networking\" (fun () ->","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                Mina_networking.create config.net_config ~get_some_initial_peers","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  ~sinks","counters":[]},{"line":"                  ~get_staged_ledger_aux_and_pending_coinbases_at_hash:(fun query_env","counters":[]},{"line":"                                                                            ->","counters":[]},{"line":"                    O1trace.thread","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      \"handle_request_get_staged_ledger_aux_and_pending_coinbases_at_hash\"","counters":[]},{"line":"                      (fun () ->","counters":[]},{"line":"                        let input = Envelope.Incoming.data query_env in","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                        Deferred.return","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                        @@","counters":[]},{"line":"                        let open Option.Let_syntax in","counters":[]},{"line":"                        let%bind frontier =","counters":[]},{"line":"                          Broadcast_pipe.Reader.peek frontier_broadcast_pipe_r","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                        in","counters":[]},{"line":"                        let%map ( scan_state","counters":[]},{"line":"                                , expected_merkle_root","counters":[]},{"line":"                                , pending_coinbases","counters":[]},{"line":"                                , protocol_states ) =","counters":[]},{"line":"                          Sync_handler","counters":[]},{"line":"                          .get_staged_ledger_aux_and_pending_coinbases_at_hash","counters":[{"col_start":77,"col_end":77,"count":0}]},{"line":"                            ~frontier input","counters":[]},{"line":"                        in","counters":[]},{"line":"                        let staged_ledger_hash =","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          Staged_ledger_hash.of_aux_ledger_and_coinbase_hash","counters":[]},{"line":"                            (Staged_ledger.Scan_state.hash scan_state)","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"                            expected_merkle_root pending_coinbases","counters":[]},{"line":"                        in","counters":[]},{"line":"                        [%log' debug config.logger]","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"                          ~metadata:","counters":[]},{"line":"                            [ ( \"staged_ledger_hash\"","counters":[]},{"line":"                              , Staged_ledger_hash.to_yojson staged_ledger_hash","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"                              )","counters":[]},{"line":"                            ]","counters":[]},{"line":"                          \"sending scan state and pending coinbase\" ;","counters":[]},{"line":"                        ( scan_state","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                        , expected_merkle_root","counters":[]},{"line":"                        , pending_coinbases","counters":[]},{"line":"                        , protocol_states ) ) )","counters":[]},{"line":"                  ~answer_sync_ledger_query:(fun query_env ->","counters":[]},{"line":"                    let open Deferred.Or_error.Let_syntax in","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                    O1trace.thread \"handle_request_answer_sync_ledger_query\"","counters":[]},{"line":"                      (fun () ->","counters":[]},{"line":"                        let ledger_hash, _ = Envelope.Incoming.data query_env in","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                        let%bind frontier =","counters":[]},{"line":"                          Deferred.return","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"                          @@ peek_frontier frontier_broadcast_pipe_r","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"                        in","counters":[]},{"line":"                        Sync_handler.answer_query ~frontier ledger_hash","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"                          (Envelope.Incoming.map ~f:Tuple2.get2 query_env)","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"                          ~logger:config.logger","counters":[]},{"line":"                          ~trust_system:config.trust_system","counters":[]},{"line":"                        |> Deferred.map","counters":[]},{"line":"                           (* begin error string prefix so we can pattern-match *)","counters":[]},{"line":"                             ~f:","counters":[]},{"line":"                               (Result.of_option","counters":[]},{"line":"                                  ~error:","counters":[]},{"line":"                                    (Error.createf","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"                                       !\"%s for ledger_hash: \\","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"                                         %{sexp:Ledger_hash.t}\"","counters":[]},{"line":"                                       Mina_networking","counters":[]},{"line":"                                       .refused_answer_query_string ledger_hash ) ) )","counters":[]},{"line":"                    )","counters":[]},{"line":"                  ~get_ancestry:","counters":[]},{"line":"                    (handle_request \"get_ancestry\" ~f:(fun ~frontier s ->","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"                         s","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                         |> With_hash.map_hash ~f:(fun state_hash ->","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"                                { State_hash.State_hashes.state_hash","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                                ; state_body_hash = None","counters":[]},{"line":"                                } )","counters":[]},{"line":"                         |> Sync_handler.Root.prove","counters":[]},{"line":"                              ~context:(module Context)","counters":[]},{"line":"                              ~frontier ) )","counters":[]},{"line":"                  ~get_best_tip:","counters":[]},{"line":"                    (handle_request \"get_best_tip\" ~f:(fun ~frontier () ->","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"                         let open Option.Let_syntax in","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                         let open Proof_carrying_data in","counters":[]},{"line":"                         let%map proof_with_data =","counters":[]},{"line":"                           Best_tip_prover.prove","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"                             ~context:(module Context)","counters":[]},{"line":"                             frontier","counters":[]},{"line":"                         in","counters":[]},{"line":"                         { proof_with_data with","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                           data = With_hash.data proof_with_data.data","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"                         } ) )","counters":[]},{"line":"                  ~get_node_status","counters":[]},{"line":"                  ~get_transition_chain_proof:","counters":[]},{"line":"                    (handle_request \"get_transition_chain_proof\"","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"                       ~f:(fun ~frontier hash ->","counters":[]},{"line":"                         Transition_chain_prover.prove ~frontier hash ) )","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                  ~get_transition_chain:","counters":[]},{"line":"                    (handle_request \"get_transition_chain\"","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"                       ~f:Sync_handler.get_transition_chain )","counters":[]},{"line":"                  ~get_transition_knowledge:(fun _q ->","counters":[]},{"line":"                    O1trace.thread \"handle_request_get_transition_knowledge\"","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      (fun () ->","counters":[]},{"line":"                        return","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          ( match","counters":[]},{"line":"                              Broadcast_pipe.Reader.peek","counters":[]},{"line":"                                frontier_broadcast_pipe_r","counters":[]},{"line":"                            with","counters":[]},{"line":"                          | None ->","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                              []","counters":[]},{"line":"                          | Some frontier ->","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                              Sync_handler.best_tip_path ~frontier ) ) ) )","counters":[]},{"line":"          in","counters":[]},{"line":"          (* tie the first knot *)","counters":[]},{"line":"          net_ref := Some net ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let user_command_input_reader, user_command_input_writer =","counters":[]},{"line":"            Strict_pipe.(create ~name:\"local user transactions\" Synchronous)","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"          in","counters":[]},{"line":"          let block_produced_bvar = Bvar.create () in","counters":[]},{"line":"          (*Read from user_command_input_reader that has the user command inputs from client, infer nonce, create user command, and write it to the pipe consumed by the network pool*)","counters":[]},{"line":"          Strict_pipe.Reader.iter user_command_input_reader","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"            ~f:(fun (inputs, result_cb, get_current_nonce, get_account) ->","counters":[]},{"line":"              match inputs with","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              | Signed_command_inputs uc_inputs -> (","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  match%bind","counters":[]},{"line":"                    User_command_input.to_user_commands ~get_current_nonce","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"                      ~get_account ~constraint_constants ~logger:config.logger","counters":[]},{"line":"                      uc_inputs","counters":[]},{"line":"                  with","counters":[]},{"line":"                  | Ok signed_commands ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      if List.is_empty signed_commands then (","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"                        result_cb","counters":[]},{"line":"                          (Error (Error.of_string \"No user commands to send\")) ;","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"                        Deferred.unit )","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                      else","counters":[]},{"line":"                        (*callback for the result from transaction_pool.apply_diff*)","counters":[]},{"line":"                        Network_pool.Transaction_pool.Local_sink.push","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          tx_local_sink","counters":[]},{"line":"                          ( List.map signed_commands ~f:(fun c ->","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                                User_command.Signed_command c )","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                          , result_cb )","counters":[]},{"line":"                  | Error e ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      [%log' error config.logger]","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"                        \"Failed to submit user commands: $error\"","counters":[]},{"line":"                        ~metadata:[ (\"error\", Error_json.error_to_yojson e) ] ;","counters":[{"col_start":71,"col_end":71,"count":0}]},{"line":"                      result_cb (Error e) ;","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                      Deferred.unit )","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"              | Zkapp_command_command_inputs zkapp_commands ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  (* TODO: here, submit a Zkapp_command.t, which includes a nonce","counters":[]},{"line":"                     allow the nonce to be omitted, and infer it, as done","counters":[]},{"line":"                     for user command inputs","counters":[]},{"line":"                  *)","counters":[]},{"line":"                  (* too-big Zkapp_command.t's were filtered when writing to the user command pipe *)","counters":[]},{"line":"                  Network_pool.Transaction_pool.Local_sink.push tx_local_sink","counters":[]},{"line":"                    ( List.map zkapp_commands ~f:(fun zkapp_command ->","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                          User_command.Zkapp_command zkapp_command )","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                    , result_cb ) )","counters":[]},{"line":"          |> Deferred.don't_wait_for ;","counters":[]},{"line":"          let ((most_recent_valid_block_reader, _) as most_recent_valid_block) =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Broadcast_pipe.create","counters":[]},{"line":"              ( Mina_block.genesis ~precomputed_values:config.precomputed_values","counters":[]},{"line":"              |> Validation.reset_frontier_dependencies_validation","counters":[{"col_start":65,"col_end":65,"count":0}]},{"line":"              |> Validation.reset_staged_ledger_diff_validation )","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"          in","counters":[]},{"line":"          let valid_transitions, initialization_finish_signal =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Transition_router.run","counters":[]},{"line":"              ~context:(module Context)","counters":[]},{"line":"              ~trust_system:config.trust_system ~verifier ~network:net","counters":[]},{"line":"              ~is_seed:config.is_seed ~is_demo_mode:config.demo_mode","counters":[]},{"line":"              ~time_controller:config.time_controller","counters":[]},{"line":"              ~consensus_local_state:config.consensus_local_state","counters":[]},{"line":"              ~persistent_root_location:config.persistent_root_location","counters":[]},{"line":"              ~persistent_frontier_location:config.persistent_frontier_location","counters":[]},{"line":"              ~frontier_broadcast_pipe:","counters":[]},{"line":"                (frontier_broadcast_pipe_r, frontier_broadcast_pipe_w)","counters":[]},{"line":"              ~catchup_mode ~network_transition_reader:block_reader","counters":[]},{"line":"              ~producer_transition_reader ~most_recent_valid_block","counters":[]},{"line":"              ~notify_online","counters":[]},{"line":"          in","counters":[]},{"line":"          let ( valid_transitions_for_network","counters":[]},{"line":"              , valid_transitions_for_api","counters":[]},{"line":"              , new_blocks ) =","counters":[]},{"line":"            let network_pipe, downstream_pipe =","counters":[]},{"line":"              Strict_pipe.Reader.Fork.two valid_transitions","counters":[]},{"line":"            in","counters":[]},{"line":"            let api_pipe, new_blocks_pipe =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Strict_pipe.Reader.(","counters":[]},{"line":"                Fork.two","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                  (map downstream_pipe ~f:(fun (`Transition t, _, _) -> t)))","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":72,"col_end":72,"count":0}]},{"line":"            in","counters":[]},{"line":"            (network_pipe, api_pipe, new_blocks_pipe)","counters":[]},{"line":"          in","counters":[]},{"line":"          O1trace.background_thread \"broadcast_transaction_pool_diffs\"","counters":[]},{"line":"            (fun () ->","counters":[]},{"line":"              let rl = Network_pool.Transaction_pool.create_rate_limiter () in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              log_rate_limiter_occasionally rl ~label:\"broadcast_transactions\" ;","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              Linear_pipe.iter","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (Network_pool.Transaction_pool.broadcasts transaction_pool)","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"                ~f:(fun cmds ->","counters":[]},{"line":"                  (* the commands had valid sizes when added to the transaction pool","counters":[]},{"line":"                     don't need to check sizes again for broadcast","counters":[]},{"line":"                  *)","counters":[]},{"line":"                  let%bind () =","counters":[]},{"line":"                    send_resource_pool_diff_or_wait ~rl","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                      ~diff_score:","counters":[]},{"line":"                        Network_pool.Transaction_pool.Resource_pool.Diff.score","counters":[]},{"line":"                      ~max_per_15_seconds:","counters":[]},{"line":"                        Network_pool.Transaction_pool.Resource_pool.Diff","counters":[]},{"line":"                        .max_per_15_seconds cmds","counters":[]},{"line":"                  in","counters":[]},{"line":"                  Mina_networking.broadcast_transaction_pool_diff net cmds ) ) ;","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"          O1trace.background_thread \"broadcast_blocks\" (fun () ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              Strict_pipe.Reader.iter_without_pushback","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                valid_transitions_for_network","counters":[]},{"line":"                ~f:(fun","counters":[]},{"line":"                     (`Transition transition, `Source source, `Valid_cb valid_cb)","counters":[]},{"line":"                   ->","counters":[]},{"line":"                  let hash =","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    Mina_block.Validated.forget transition","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"                    |> State_hash.With_state_hashes.state_hash","counters":[]},{"line":"                  in","counters":[]},{"line":"                  let consensus_state =","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    transition |> Mina_block.Validated.header","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"                    |> Header.protocol_state","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"                    |> Mina_state.Protocol_state.consensus_state","counters":[]},{"line":"                  in","counters":[]},{"line":"                  let now =","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    let open Block_time in","counters":[]},{"line":"                    now config.time_controller |> to_span_since_epoch","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"                    |> Span.to_ms","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                  in","counters":[]},{"line":"                  match","counters":[]},{"line":"                    Consensus.Hooks.received_at_valid_time","counters":[]},{"line":"                      ~constants:consensus_constants ~time_received:now","counters":[]},{"line":"                      consensus_state","counters":[]},{"line":"                  with","counters":[]},{"line":"                  | Ok () -> (","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      match source with","counters":[]},{"line":"                      | `Gossip ->","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          [%str_log' info config.logger]","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"                            ~metadata:","counters":[]},{"line":"                              [ ( \"external_transition\"","counters":[]},{"line":"                                , Mina_block.Validated.to_yojson transition )","counters":[{"col_start":63,"col_end":63,"count":0}]},{"line":"                              ]","counters":[]},{"line":"                            (Rebroadcast_transition { state_hash = hash }) ;","counters":[]},{"line":"                          (*send callback to libp2p to forward the gossiped transition*)","counters":[]},{"line":"                          Option.iter","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            ~f:","counters":[]},{"line":"                              (Fn.flip","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                                 Mina_net2.Validation_callback","counters":[]},{"line":"                                 .fire_if_not_already_fired `Accept )","counters":[]},{"line":"                            valid_cb","counters":[]},{"line":"                      | `Internal ->","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          (*Send callback to publish the new block. Don't log rebroadcast message if it is internally generated; There is a broadcast log*)","counters":[]},{"line":"                          don't_wait_for","counters":[]},{"line":"                            (Mina_networking.broadcast_state net","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"                               (Mina_block.Validated.forget transition) ) ;","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"                          Option.iter","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            ~f:","counters":[]},{"line":"                              (Fn.flip","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                                 Mina_net2.Validation_callback","counters":[]},{"line":"                                 .fire_if_not_already_fired `Accept )","counters":[]},{"line":"                            valid_cb","counters":[]},{"line":"                      | `Catchup ->","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          (*Noop for directly downloaded transitions*)","counters":[]},{"line":"                          Option.iter","counters":[]},{"line":"                            ~f:","counters":[]},{"line":"                              (Fn.flip","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                                 Mina_net2.Validation_callback","counters":[]},{"line":"                                 .fire_if_not_already_fired `Accept )","counters":[]},{"line":"                            valid_cb )","counters":[]},{"line":"                  | Error reason -> (","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      let timing_error_json =","counters":[]},{"line":"                        match reason with","counters":[]},{"line":"                        | `Too_early ->","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            `String \"too early\"","counters":[]},{"line":"                        | `Too_late slots ->","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            `String (sprintf \"%Lu slots too late\" slots)","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"                      in","counters":[]},{"line":"                      let metadata =","counters":[]},{"line":"                        [ (\"state_hash\", State_hash.to_yojson hash)","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"                        ; (\"block\", Mina_block.Validated.to_yojson transition)","counters":[{"col_start":65,"col_end":65,"count":0}]},{"line":"                        ; (\"timing\", timing_error_json)","counters":[]},{"line":"                        ]","counters":[]},{"line":"                      in","counters":[]},{"line":"                      Option.iter","counters":[]},{"line":"                        ~f:","counters":[]},{"line":"                          (Fn.flip","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"                             Mina_net2.Validation_callback","counters":[]},{"line":"                             .fire_if_not_already_fired `Reject )","counters":[]},{"line":"                        valid_cb ;","counters":[]},{"line":"                      match source with","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                      | `Catchup ->","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          ()","counters":[]},{"line":"                      | `Internal ->","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          [%log' error config.logger] ~metadata","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"                            \"Internally generated block $state_hash cannot be \\","counters":[]},{"line":"                             rebroadcast because it's not a valid time to do \\","counters":[]},{"line":"                             so ($timing)\"","counters":[]},{"line":"                      | `Gossip ->","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          [%log' warn config.logger] ~metadata","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                            \"Not rebroadcasting block $state_hash because it \\","counters":[]},{"line":"                             was received $timing\" ) ) ) ;","counters":[]},{"line":"          (* FIXME #4093: augment ban_notifications with a Peer.ID so we can implement ban_notify","counters":[]},{"line":"             trace_task \"ban notification loop\" (fun () ->","counters":[]},{"line":"              Linear_pipe.iter (Mina_networking.ban_notification_reader net)","counters":[]},{"line":"                ~f:(fun notification ->","counters":[]},{"line":"                  let open Gossip_net in","counters":[]},{"line":"                  let peer = notification.banned_peer in","counters":[]},{"line":"                  let banned_until = notification.banned_until in","counters":[]},{"line":"                  (* if RPC call fails, will be logged in gossip net code *)","counters":[]},{"line":"                  let%map _ =","counters":[]},{"line":"                    Mina_networking.ban_notify net peer banned_until","counters":[]},{"line":"                  in","counters":[]},{"line":"                  () ) ) ; *)","counters":[]},{"line":"          don't_wait_for","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (Linear_pipe.iter","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"               (Mina_networking.ban_notification_reader net)","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"               ~f:(Fn.const Deferred.unit) ) ;","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"          let snark_jobs_state =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Work_selector.State.init","counters":[]},{"line":"              ~reassignment_wait:config.work_reassignment_wait","counters":[]},{"line":"              ~frontier_broadcast_pipe:frontier_broadcast_pipe_r","counters":[]},{"line":"              ~logger:config.logger","counters":[]},{"line":"          in","counters":[]},{"line":"          let%bind wallets =","counters":[]},{"line":"            match wallets with","counters":[]},{"line":"            | Some wallets ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                return wallets","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"            | None ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Secrets.Wallets.load ~logger:config.logger","counters":[]},{"line":"                  ~disk_location:config.wallets_disk_location","counters":[]},{"line":"          in","counters":[]},{"line":"          O1trace.background_thread \"broadcast_snark_pool_diffs\" (fun () ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              let rl = Network_pool.Snark_pool.create_rate_limiter () in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              log_rate_limiter_occasionally rl ~label:\"broadcast_snark_work\" ;","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              Linear_pipe.iter (Network_pool.Snark_pool.broadcasts snark_pool)","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"                ~f:(fun x ->","counters":[]},{"line":"                  let%bind () =","counters":[]},{"line":"                    send_resource_pool_diff_or_wait ~rl","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                      ~diff_score:","counters":[]},{"line":"                        Network_pool.Snark_pool.Resource_pool.Diff.score","counters":[]},{"line":"                      ~max_per_15_seconds:","counters":[]},{"line":"                        Network_pool.Snark_pool.Resource_pool.Diff","counters":[]},{"line":"                        .max_per_15_seconds x","counters":[]},{"line":"                  in","counters":[]},{"line":"                  Mina_networking.broadcast_snark_pool_diff net x ) ) ;","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"          Option.iter config.archive_process_location","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ~f:(fun archive_process_port ->","counters":[]},{"line":"              [%log' info config.logger]","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"                \"Communicating with the archive process\"","counters":[]},{"line":"                ~metadata:","counters":[]},{"line":"                  [ ( \"Host\"","counters":[]},{"line":"                    , `String (Host_and_port.host archive_process_port.value) )","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"                  ; ( \"Port\"","counters":[]},{"line":"                    , `Int (Host_and_port.port archive_process_port.value) )","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"                  ] ;","counters":[]},{"line":"              Archive_client.run ~logger:config.logger","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ~precomputed_values:config.precomputed_values","counters":[]},{"line":"                ~frontier_broadcast_pipe:frontier_broadcast_pipe_r","counters":[]},{"line":"                archive_process_port ) ;","counters":[]},{"line":"          let precomputed_block_writer =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ref","counters":[]},{"line":"              ( Option.map config.precomputed_blocks_path ~f:(fun path ->","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                    `Path path )","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"              , if config.log_precomputed_blocks then Some `Log else None )","counters":[{"col_start":54,"col_end":54,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"          in","counters":[]},{"line":"          let subscriptions =","counters":[]},{"line":"            Mina_subscriptions.create ~logger:config.logger","counters":[]},{"line":"              ~constraint_constants ~new_blocks ~wallets","counters":[]},{"line":"              ~transition_frontier:frontier_broadcast_pipe_r","counters":[]},{"line":"              ~is_storing_all:config.is_archive_rocksdb","counters":[]},{"line":"              ~upload_blocks_to_gcloud:config.upload_blocks_to_gcloud","counters":[]},{"line":"              ~time_controller:config.time_controller ~precomputed_block_writer","counters":[]},{"line":"          in","counters":[]},{"line":"          let open Mina_incremental.Status in","counters":[]},{"line":"          let transition_frontier_incr =","counters":[]},{"line":"            Var.watch @@ of_broadcast_pipe frontier_broadcast_pipe_r","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"          in","counters":[]},{"line":"          let transition_frontier_and_catchup_signal_incr =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            transition_frontier_incr","counters":[]},{"line":"            >>= function","counters":[]},{"line":"            | Some transition_frontier ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                of_broadcast_pipe Ledger_catchup.Catchup_jobs.reader","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                |> Var.watch","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                >>| fun catchup_signal ->","counters":[]},{"line":"                Some (transition_frontier, catchup_signal)","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"            | None ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                return None","counters":[]},{"line":"          in","counters":[]},{"line":"          let sync_status =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            create_sync_status_observer ~logger:config.logger ~net","counters":[]},{"line":"              ~is_seed:config.is_seed ~demo_mode:config.demo_mode","counters":[]},{"line":"              ~transition_frontier_and_catchup_signal_incr","counters":[]},{"line":"              ~online_status_incr:(Var.watch @@ of_broadcast_pipe online_status)","counters":[{"col_start":43,"col_end":43,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"              ~first_connection_incr:","counters":[]},{"line":"                ( Var.watch @@ of_deferred","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"                @@ Mina_networking.on_first_connect net ~f:Fn.id )","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"              ~first_message_incr:","counters":[]},{"line":"                (Var.watch @@ of_deferred @@ on_first_received_message ~f:Fn.id)","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"          in","counters":[]},{"line":"          (* tie other knot *)","counters":[]},{"line":"          sync_status_ref := Some sync_status ;","counters":[]},{"line":"          Deferred.return","counters":[]},{"line":"            { config","counters":[]},{"line":"            ; next_producer_timing = None","counters":[]},{"line":"            ; processes =","counters":[]},{"line":"                { prover","counters":[]},{"line":"                ; verifier","counters":[]},{"line":"                ; snark_worker","counters":[]},{"line":"                ; uptime_snark_worker_opt","counters":[]},{"line":"                ; vrf_evaluator","counters":[]},{"line":"                }","counters":[]},{"line":"            ; initialization_finish_signal","counters":[]},{"line":"            ; components =","counters":[]},{"line":"                { net","counters":[]},{"line":"                ; transaction_pool","counters":[]},{"line":"                ; snark_pool","counters":[]},{"line":"                ; transition_frontier = frontier_broadcast_pipe_r","counters":[]},{"line":"                ; most_recent_valid_block = most_recent_valid_block_reader","counters":[]},{"line":"                ; block_produced_bvar","counters":[]},{"line":"                }","counters":[]},{"line":"            ; pipes =","counters":[]},{"line":"                { validated_transitions_reader = valid_transitions_for_api","counters":[]},{"line":"                ; producer_transition_writer","counters":[]},{"line":"                ; user_command_input_writer","counters":[]},{"line":"                ; tx_local_sink","counters":[]},{"line":"                ; snark_local_sink","counters":[]},{"line":"                }","counters":[]},{"line":"            ; wallets","counters":[]},{"line":"            ; coinbase_receiver = ref config.coinbase_receiver","counters":[]},{"line":"            ; snark_job_state = snark_jobs_state","counters":[]},{"line":"            ; subscriptions","counters":[]},{"line":"            ; sync_status","counters":[]},{"line":"            ; precomputed_block_writer","counters":[]},{"line":"            ; block_production_status = ref `Free","counters":[]},{"line":"            } ) )","counters":[]},{"line":"","counters":[]},{"line":"let net { components = { net; _ }; _ } = net","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"","counters":[]},{"line":"let runtime_config { config = { precomputed_values; _ }; _ } =","counters":[]},{"line":"  Genesis_ledger_helper.runtime_config_of_precomputed_values precomputed_values","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let verifier { processes = { verifier; _ }; _ } = verifier","counters":[{"col_start":50,"col_end":50,"count":0},{"col_start":57,"col_end":57,"count":2}]}]}