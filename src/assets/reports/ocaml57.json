{"filename":"src/lib/mina_wire_types/pickles/pickles_composition_types.ml","lines":[{"line":"open Utils","counters":[]},{"line":"","counters":[]},{"line":"module Branch_data = struct","counters":[]},{"line":"  module Types = struct","counters":[]},{"line":"    module type S = sig","counters":[]},{"line":"      module Domain_log2 : V1S0","counters":[]},{"line":"","counters":[]},{"line":"      module V1 : sig","counters":[]},{"line":"        type t =","counters":[]},{"line":"          { proofs_verified : Pickles_base.Proofs_verified.V1.t","counters":[]},{"line":"          ; domain_log2 : Domain_log2.V1.t","counters":[]},{"line":"          }","counters":[]},{"line":"      end","counters":[]},{"line":"    end","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module type Concrete = Types.S with type Domain_log2.V1.t = char","counters":[]},{"line":"","counters":[]},{"line":"  module M = struct","counters":[]},{"line":"    module Domain_log2 = struct","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type t = char","counters":[]},{"line":"      end","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type t =","counters":[]},{"line":"        { proofs_verified : Pickles_base.Proofs_verified.V1.t","counters":[]},{"line":"        ; domain_log2 : Domain_log2.V1.t","counters":[]},{"line":"        }","counters":[]},{"line":"    end","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module type Local_sig = Signature(Types).S","counters":[]},{"line":"","counters":[]},{"line":"  module Make","counters":[]},{"line":"      (Signature : Local_sig) (F : functor (A : Concrete) -> Signature(A).S) =","counters":[]},{"line":"    F (M)","counters":[]},{"line":"  include M","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Wrap = struct","counters":[]},{"line":"  module Proof_state = struct","counters":[]},{"line":"    module Messages_for_next_wrap_proof = struct","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type ('g1, 'bulletproof_challenges) t =","counters":[]},{"line":"          { challenge_polynomial_commitment : 'g1","counters":[]},{"line":"          ; old_bulletproof_challenges : 'bulletproof_challenges","counters":[]},{"line":"          }","counters":[]},{"line":"      end","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Deferred_values = struct","counters":[]},{"line":"      module Plonk = struct","counters":[]},{"line":"        module Minimal = struct","counters":[]},{"line":"          module V1 = struct","counters":[]},{"line":"            type ('challenge, 'scalar_challenge) t =","counters":[]},{"line":"              { alpha : 'scalar_challenge","counters":[]},{"line":"              ; beta : 'challenge","counters":[]},{"line":"              ; gamma : 'challenge","counters":[]},{"line":"              ; zeta : 'scalar_challenge","counters":[]},{"line":"              ; joint_combiner : 'scalar_challenge option","counters":[]},{"line":"              }","counters":[]},{"line":"          end","counters":[]},{"line":"        end","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type ( 'plonk","counters":[]},{"line":"             , 'scalar_challenge","counters":[]},{"line":"             , 'fp","counters":[]},{"line":"             , 'bulletproof_challenges","counters":[]},{"line":"             , 'branch_data )","counters":[]},{"line":"             t =","counters":[]},{"line":"          { plonk : 'plonk","counters":[]},{"line":"          ; combined_inner_product : 'fp","counters":[]},{"line":"          ; b : 'fp","counters":[]},{"line":"          ; xi : 'scalar_challenge","counters":[]},{"line":"          ; bulletproof_challenges : 'bulletproof_challenges","counters":[]},{"line":"          ; branch_data : 'branch_data","counters":[]},{"line":"          }","counters":[]},{"line":"      end","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type ( 'plonk","counters":[]},{"line":"           , 'scalar_challenge","counters":[]},{"line":"           , 'fp","counters":[]},{"line":"           , 'messages_for_next_wrap_proof","counters":[]},{"line":"           , 'digest","counters":[]},{"line":"           , 'bp_chals","counters":[]},{"line":"           , 'index )","counters":[]},{"line":"           t =","counters":[]},{"line":"        { deferred_values :","counters":[]},{"line":"            ( 'plonk","counters":[]},{"line":"            , 'scalar_challenge","counters":[]},{"line":"            , 'fp","counters":[]},{"line":"            , 'bp_chals","counters":[]},{"line":"            , 'index )","counters":[]},{"line":"            Deferred_values.V1.t","counters":[]},{"line":"        ; sponge_digest_before_evaluations : 'digest","counters":[]},{"line":"        ; messages_for_next_wrap_proof : 'messages_for_next_wrap_proof","counters":[]},{"line":"        }","counters":[]},{"line":"    end","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Statement = struct","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type ( 'plonk","counters":[]},{"line":"           , 'scalar_challenge","counters":[]},{"line":"           , 'fp","counters":[]},{"line":"           , 'messages_for_next_wrap_proof","counters":[]},{"line":"           , 'digest","counters":[]},{"line":"           , 'messages_for_next_step_proof","counters":[]},{"line":"           , 'bp_chals","counters":[]},{"line":"           , 'index )","counters":[]},{"line":"           t =","counters":[]},{"line":"        { proof_state :","counters":[]},{"line":"            ( 'plonk","counters":[]},{"line":"            , 'scalar_challenge","counters":[]},{"line":"            , 'fp","counters":[]},{"line":"            , 'messages_for_next_wrap_proof","counters":[]},{"line":"            , 'digest","counters":[]},{"line":"            , 'bp_chals","counters":[]},{"line":"            , 'index )","counters":[]},{"line":"            Proof_state.V1.t","counters":[]},{"line":"        ; messages_for_next_step_proof : 'messages_for_next_step_proof","counters":[]},{"line":"        }","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Minimal = struct","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type ( 'challenge","counters":[]},{"line":"             , 'scalar_challenge","counters":[]},{"line":"             , 'fp","counters":[]},{"line":"             , 'messages_for_next_wrap_proof","counters":[]},{"line":"             , 'digest","counters":[]},{"line":"             , 'messages_for_next_step_proof","counters":[]},{"line":"             , 'bp_chals","counters":[]},{"line":"             , 'index )","counters":[]},{"line":"             t =","counters":[]},{"line":"          ( ( 'challenge","counters":[]},{"line":"            , 'scalar_challenge )","counters":[]},{"line":"            Proof_state.Deferred_values.Plonk.Minimal.V1.t","counters":[]},{"line":"          , 'scalar_challenge","counters":[]},{"line":"          , 'fp","counters":[]},{"line":"          , 'messages_for_next_wrap_proof","counters":[]},{"line":"          , 'digest","counters":[]},{"line":"          , 'messages_for_next_step_proof","counters":[]},{"line":"          , 'bp_chals","counters":[]},{"line":"          , 'index )","counters":[]},{"line":"          V1.t","counters":[]},{"line":"      end","counters":[]},{"line":"    end","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]}]}