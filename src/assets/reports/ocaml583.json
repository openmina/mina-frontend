{"filename":"src/lib/merkle_mask/maskable_merkle_tree.ml","lines":[{"line":"(* maskable_merkle_tree.ml -- Merkle tree that can have associated masks *)","counters":[]},{"line":"","counters":[{"col_start":0,"col_end":0,"count":1}]},{"line":"open Core","counters":[]},{"line":"module Rust = Mina_tree.Rust","counters":[]},{"line":"","counters":[]},{"line":"module type Inputs_intf = sig","counters":[]},{"line":"  include Inputs_intf.S","counters":[]},{"line":"","counters":[]},{"line":"  module Mask :","counters":[]},{"line":"    Masking_merkle_tree_intf.S","counters":[]},{"line":"      with module Location = Location","counters":[]},{"line":"       and type account := Account.t","counters":[]},{"line":"       and type location := Location.t","counters":[]},{"line":"       and type hash := Hash.t","counters":[]},{"line":"       and type key := Key.t","counters":[]},{"line":"       and type token_id := Token_id.t","counters":[]},{"line":"       and type token_id_set := Token_id.Set.t","counters":[]},{"line":"       and type account_id := Account_id.t","counters":[]},{"line":"       and type account_id_set := Account_id.Set.t","counters":[]},{"line":"       and type parent := Base.t","counters":[]},{"line":"","counters":[]},{"line":"  val mask_to_base : Mask.Attached.t -> Base.t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make (Inputs : Inputs_intf) = struct","counters":[]},{"line":"  open Inputs","counters":[]},{"line":"  include Base","counters":[]},{"line":"","counters":[]},{"line":"  (* (\\** Maps parent ledger UUIDs to child masks. *\\) *)","counters":[]},{"line":"  (* let (registered_masks : Mask.Attached.t list Uuid.Table.t) = *)","counters":[]},{"line":"  (*   Uuid.Table.create () *)","counters":[]},{"line":"","counters":[]},{"line":"  let location_to_rust location =","counters":[]},{"line":"    Location.to_path_exn location |> Addr.to_string","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"  let account_to_rust account =","counters":[]},{"line":"    let buf = Bigstring.create (Account.bin_size_t account) in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"    ignore (Account.bin_write_t buf ~pos:0 account : int) ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"    Bigstring.to_bytes buf","counters":[]},{"line":"","counters":[]},{"line":"  (* type t = Mina_tree.mask *)","counters":[]},{"line":"","counters":[]},{"line":"  (* type t = Mina_tree.mask *)","counters":[]},{"line":"","counters":[]},{"line":"  (* module Node = struct *)","counters":[]},{"line":"  (*   type t = Mask.Attached.t *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   type attached = *)","counters":[]},{"line":"  (*     { hash : string; uuid : string; total_currency : int; num_accounts : int } *)","counters":[]},{"line":"  (*   [@@deriving yojson] *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   type dangling = { uuid : string; nulled_at : string } [@@deriving yojson] *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   type display = [ `Attached of attached | `Dangling_parent of dangling ] *)","counters":[]},{"line":"  (*   [@@deriving yojson] *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   let format_uuid mask = *)","counters":[]},{"line":"  (*     Visualization.display_prefix_of_string @@ Uuid.to_string *)","counters":[]},{"line":"  (*     @@ Mask.Attached.get_uuid mask *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   let name mask = sprintf !\"\\\"%s \\\"\" (format_uuid mask) *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   let display_attached_mask mask = *)","counters":[]},{"line":"  (*     let root_hash = Mask.Attached.merkle_root mask in *)","counters":[]},{"line":"  (*     let num_accounts = Mask.Attached.num_accounts mask in *)","counters":[]},{"line":"  (*     let total_currency = *)","counters":[]},{"line":"  (*       Mask.Attached.foldi mask ~init:0 ~f:(fun _ total_currency account -> *)","counters":[]},{"line":"  (*           (\\* only default token matters for total currency *\\) *)","counters":[]},{"line":"  (*           if Token_id.equal (Account.token account) Token_id.default then *)","counters":[]},{"line":"  (*             total_currency + (Balance.to_int @@ Account.balance account) *)","counters":[]},{"line":"  (*           else total_currency ) *)","counters":[]},{"line":"  (*     in *)","counters":[]},{"line":"  (*     let uuid = format_uuid mask in *)","counters":[]},{"line":"  (*     { hash = *)","counters":[]},{"line":"  (*         Visualization.display_prefix_of_string *)","counters":[]},{"line":"  (*         @@ Hash.to_base58_check root_hash *)","counters":[]},{"line":"  (*     ; num_accounts *)","counters":[]},{"line":"  (*     ; total_currency *)","counters":[]},{"line":"  (*     ; uuid *)","counters":[]},{"line":"  (*     } *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   let display mask = *)","counters":[]},{"line":"  (*     try `Attached (display_attached_mask mask) *)","counters":[]},{"line":"  (*     with Mask.Attached.Dangling_parent_reference (_, nulled_at) -> *)","counters":[]},{"line":"  (*       `Dangling_parent { uuid = format_uuid mask; nulled_at } *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   let equal mask1 mask2 = *)","counters":[]},{"line":"  (*     let open Mask.Attached in *)","counters":[]},{"line":"  (*     Uuid.equal (get_uuid mask1) (get_uuid mask2) *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   let compare mask1 mask2 = *)","counters":[]},{"line":"  (*     let open Mask.Attached in *)","counters":[]},{"line":"  (*     Uuid.compare (get_uuid mask1) (get_uuid mask2) *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   let hash mask = Uuid.hash @@ Mask.Attached.get_uuid mask *)","counters":[]},{"line":"  (* end *)","counters":[]},{"line":"","counters":[]},{"line":"  (* module Graphviz = Visualization.Make_ocamlgraph (Node) *)","counters":[]},{"line":"","counters":[]},{"line":"  (* let to_graph () = *)","counters":[]},{"line":"  (*   let masks = List.concat @@ Uuid.Table.data registered_masks in *)","counters":[]},{"line":"  (*   let uuid_to_masks_table = *)","counters":[]},{"line":"  (*     Uuid.Table.of_alist_exn *)","counters":[]},{"line":"  (*       (List.map masks ~f:(fun mask -> (Mask.Attached.get_uuid mask, mask))) *)","counters":[]},{"line":"  (*   in *)","counters":[]},{"line":"  (*   let open Graphviz in *)","counters":[]},{"line":"  (*   Uuid.Table.fold uuid_to_masks_table ~init:empty *)","counters":[]},{"line":"  (*     ~f:(fun ~key:uuid ~data:mask graph -> *)","counters":[]},{"line":"  (*       let graph_with_mask = add_vertex graph mask in *)","counters":[]},{"line":"  (*       Uuid.Table.find registered_masks uuid *)","counters":[]},{"line":"  (*       |> Option.value_map ~default:graph_with_mask ~f:(fun children_masks -> *)","counters":[]},{"line":"  (*              List.fold ~init:graph_with_mask children_masks *)","counters":[]},{"line":"  (*                ~f:(fun graph_with_mask_and_child -> *)","counters":[]},{"line":"  (*                  add_edge graph_with_mask_and_child mask ) ) ) *)","counters":[]},{"line":"","counters":[]},{"line":"  (* module Debug = struct *)","counters":[]},{"line":"  (*   let visualize ~filename = *)","counters":[]},{"line":"  (*     Out_channel.with_file filename ~f:(fun output_channel -> *)","counters":[]},{"line":"  (*         let graph = to_graph () in *)","counters":[]},{"line":"  (*         Graphviz.output_graph output_channel graph ) *)","counters":[]},{"line":"  (* end *)","counters":[]},{"line":"","counters":[]},{"line":"  (* module Visualize = struct *)","counters":[]},{"line":"  (*   module Summary = struct *)","counters":[]},{"line":"  (*     type t = [ `Uuid of Uuid.t ] * [ `Hash of Hash.t ] [@@deriving sexp_of] *)","counters":[]},{"line":"  (*   end *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   type t = Leaf of Summary.t | Node of Summary.t * t list *)","counters":[]},{"line":"  (*   [@@deriving sexp_of] *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   module type Crawler_intf = sig *)","counters":[]},{"line":"  (*     type t *)","counters":[]},{"line":"","counters":[]},{"line":"  (*     val get_uuid : t -> Uuid.t *)","counters":[]},{"line":"","counters":[]},{"line":"  (*     val merkle_root : t -> Hash.t *)","counters":[]},{"line":"  (*   end *)","counters":[]},{"line":"","counters":[]},{"line":"  (*   let rec _crawl : type a. (module Crawler_intf with type t = a) -> a -> t = *)","counters":[]},{"line":"  (*    fun (module C) c -> *)","counters":[]},{"line":"  (*     let summary = *)","counters":[]},{"line":"  (*       let uuid = C.get_uuid c in *)","counters":[]},{"line":"  (*       ( `Uuid uuid *)","counters":[]},{"line":"  (*       , `Hash *)","counters":[]},{"line":"  (*           ( try C.merkle_root c *)","counters":[]},{"line":"  (*             with _ -> *)","counters":[]},{"line":"  (*               Core.printf !\"CAUGHT %{sexp: Uuid.t}\\n%!\" uuid ; *)","counters":[]},{"line":"  (*               Hash.empty_account ) ) *)","counters":[]},{"line":"  (*     in *)","counters":[]},{"line":"  (*     match Uuid.Table.find registered_masks (C.get_uuid c) with *)","counters":[]},{"line":"  (*     | None -> *)","counters":[]},{"line":"  (*         Leaf summary *)","counters":[]},{"line":"  (*     | Some masks -> *)","counters":[]},{"line":"  (*         Node (summary, List.map masks ~f:(_crawl (module Mask.Attached))) *)","counters":[]},{"line":"  (* end *)","counters":[]},{"line":"","counters":[]},{"line":"  (* let register_mask (m : t) (mask : t) : t = *)","counters":[]},{"line":"  (*   (\\* let register_mask (m : t) (mask : Mask.unattached) : Mask.Attached.t = *\\) *)","counters":[]},{"line":"  (*   (\\* failwith \"t_register_mask not implemented\" *\\) *)","counters":[]},{"line":"  (*   Rust.mask_register_mask m mask *)","counters":[]},{"line":"","counters":[]},{"line":"  external mask_register_mask : t -> Mask.unattached -> Mask.Attached.t","counters":[]},{"line":"    = \"rust_mask_register_mask\"","counters":[]},{"line":"","counters":[]},{"line":"  external mask_unregister_mask :","counters":[]},{"line":"    Mask.Attached.t -> Mina_tree.rust_grandchildren -> Mask.unattached","counters":[]},{"line":"    = \"rust_mask_unregister_mask\"","counters":[]},{"line":"","counters":[]},{"line":"  (* external mask_remove_and_reparent : t -> Mask.Attached.t -> unit *)","counters":[]},{"line":"  external mask_remove_and_reparent : t -> unit","counters":[]},{"line":"    = \"rust_mask_remove_and_reparent\"","counters":[]},{"line":"","counters":[]},{"line":"  (* let register_mask _m (_mask : t) : t = *)","counters":[]},{"line":"  let register_mask (m : t) (mask : Mask.unattached) : Mask.Attached.t =","counters":[]},{"line":"    (* failwith \"t_register_mask not implemented\" *)","counters":[]},{"line":"    mask_register_mask m mask","counters":[{"col_start":4,"col_end":4,"count":3}]},{"line":"  (* Rust.mask_register_mask m mask *)","counters":[]},{"line":"","counters":[]},{"line":"  (* let attached_mask = Mask.set_parent mask t in *)","counters":[]},{"line":"  (* List.iter (Uuid.Table.data registered_masks) ~f:(fun ms -> *)","counters":[]},{"line":"  (*     List.iter ms ~f:(fun m -> *)","counters":[]},{"line":"  (*         [%test_result: bool] *)","counters":[]},{"line":"  (*           ~message: *)","counters":[]},{"line":"  (*             \"We've already registered a mask with this UUID; you have a bug\" *)","counters":[]},{"line":"  (*           ~expect:false *)","counters":[]},{"line":"  (*           (Uuid.equal (Mask.Attached.get_uuid m) (Mask.get_uuid mask)) ) ) ; *)","counters":[]},{"line":"  (* (\\* handles cases where no entries for t, or where there are existing entries *\\) *)","counters":[]},{"line":"  (* Uuid.Table.add_multi registered_masks ~key:(get_uuid t) ~data:attached_mask ; *)","counters":[]},{"line":"  (* attached_mask *)","counters":[]},{"line":"","counters":[]},{"line":"  let behavior_to_rust behavior : Mina_tree.rust_grandchildren =","counters":[]},{"line":"    match behavior with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | `Check ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        `Check","counters":[]},{"line":"    | `Recursive ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        `Recursive","counters":[]},{"line":"    | `I_promise_I_am_reparenting_this_mask ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        `I_promise_I_am_reparenting_this_mask","counters":[]},{"line":"","counters":[]},{"line":"  (* [ `Check | `Recursive | `I_promise_I_am_reparenting_this_mask ] *)","counters":[]},{"line":"","counters":[]},{"line":"  let unregister_mask_exn ?(grandchildren = `Check) ~(loc : string)","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"      (mask : Mask.Attached.t) : Mask.unattached =","counters":[]},{"line":"    let _ = loc in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    mask_unregister_mask mask (behavior_to_rust grandchildren)","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"","counters":[]},{"line":"  (* let unregister_mask_exn ?(grandchildren = `Check) ~loc (mask : Mask.Attached.t) *)","counters":[]},{"line":"  (*     : Mask.unattached = *)","counters":[]},{"line":"  (*   Rust.mask_unregister_mask mask grandchildren *)","counters":[]},{"line":"","counters":[]},{"line":"  (* let rec unregister_mask_exn ?(grandchildren = `Check) ~loc *)","counters":[]},{"line":"  (*     (mask : Mask.Attached.t) : Mask.unattached = *)","counters":[]},{"line":"  (*   let parent_uuid = Mask.Attached.get_parent mask |> get_uuid in *)","counters":[]},{"line":"  (*   let error_msg suffix = *)","counters":[]},{"line":"  (*     sprintf \"Couldn't unregister mask with UUID %s from parent %s, %s\" *)","counters":[]},{"line":"  (*       (Mask.Attached.get_uuid mask |> Uuid.to_string_hum) *)","counters":[]},{"line":"  (*       (Uuid.to_string_hum parent_uuid) *)","counters":[]},{"line":"  (*       suffix *)","counters":[]},{"line":"  (*   in *)","counters":[]},{"line":"  (*   let trigger_detach_signal = *)","counters":[]},{"line":"  (*     match grandchildren with *)","counters":[]},{"line":"  (*     | `Check | `Recursive -> *)","counters":[]},{"line":"  (*         true *)","counters":[]},{"line":"  (*     | `I_promise_I_am_reparenting_this_mask -> *)","counters":[]},{"line":"  (*         false *)","counters":[]},{"line":"  (*   in *)","counters":[]},{"line":"  (*   ( match grandchildren with *)","counters":[]},{"line":"  (*   | `Check -> ( *)","counters":[]},{"line":"  (*       match Hashtbl.find registered_masks (Mask.Attached.get_uuid mask) with *)","counters":[]},{"line":"  (*       | Some children -> *)","counters":[]},{"line":"  (*           failwith @@ error_msg *)","counters":[]},{"line":"  (*           @@ sprintf *)","counters":[]},{"line":"  (* !\"mask has children that must be unregistered first: %{sexp: \\ *)","counters":[]},{"line":"     (*                  Uuid.t list}\" *)","counters":[]},{"line":"  (*                (List.map ~f:Mask.Attached.get_uuid children) *)","counters":[]},{"line":"  (*       | None -> *)","counters":[]},{"line":"  (*           () ) *)","counters":[]},{"line":"  (*   | `I_promise_I_am_reparenting_this_mask -> *)","counters":[]},{"line":"  (*       () *)","counters":[]},{"line":"  (*   | `Recursive -> *)","counters":[]},{"line":"  (*       (\\* You must not retain any references to children of the mask we're *)","counters":[]},{"line":"  (*          unregistering if you pass `Recursive, so this is only used in *)","counters":[]},{"line":"  (*          with_ephemeral_ledger. *\\) *)","counters":[]},{"line":"  (*       List.iter *)","counters":[]},{"line":"  (*         ( Hashtbl.find registered_masks (Mask.Attached.get_uuid mask) *)","counters":[]},{"line":"  (*         |> Option.value ~default:[] ) *)","counters":[]},{"line":"  (*         ~f:(fun child_mask -> *)","counters":[]},{"line":"  (*           ignore *)","counters":[]},{"line":"  (*           @@ unregister_mask_exn ~loc ~grandchildren:`Recursive child_mask ) *)","counters":[]},{"line":"  (*   ) ; *)","counters":[]},{"line":"  (*   match Uuid.Table.find registered_masks parent_uuid with *)","counters":[]},{"line":"  (*   | None -> *)","counters":[]},{"line":"  (*       failwith @@ error_msg \"parent not in registered_masks\" *)","counters":[]},{"line":"  (*   | Some masks -> *)","counters":[]},{"line":"  (*       ( match List.find masks ~f:(fun m -> phys_equal m mask) with *)","counters":[]},{"line":"  (*       | None -> *)","counters":[]},{"line":"  (*           failwith @@ error_msg \"mask not registered with that parent\" *)","counters":[]},{"line":"  (*       | Some _ -> ( *)","counters":[]},{"line":"  (*           let bad, good = *)","counters":[]},{"line":"  (*             List.partition_tf masks ~f:(fun m -> phys_equal m mask) *)","counters":[]},{"line":"  (*           in *)","counters":[]},{"line":"  (*           assert (List.length bad = 1) ; *)","counters":[]},{"line":"  (*           match good with *)","counters":[]},{"line":"  (*           | [] -> *)","counters":[]},{"line":"  (*               (\\* no other masks for this maskable *\\) *)","counters":[]},{"line":"  (*               Uuid.Table.remove registered_masks parent_uuid *)","counters":[]},{"line":"  (*           | other_masks -> *)","counters":[]},{"line":"  (*               Uuid.Table.set registered_masks ~key:parent_uuid *)","counters":[]},{"line":"  (*                 ~data:other_masks ) ) ; *)","counters":[]},{"line":"  (*       Mask.Attached.unset_parent ~trigger_signal:trigger_detach_signal ~loc *)","counters":[]},{"line":"  (*         mask *)","counters":[]},{"line":"","counters":[]},{"line":"  (* (\\** a set calls the Base implementation set, notifies registered mask childen *\\) *)","counters":[]},{"line":"  (* let set t location account = *)","counters":[]},{"line":"  (*   let location = location_to_rust location in *)","counters":[]},{"line":"  (*   Rust.mask_set t location (account_to_rust account) *)","counters":[]},{"line":"","counters":[]},{"line":"  (* let set t location account = *)","counters":[]},{"line":"  (*   Base.set t location account ; *)","counters":[]},{"line":"  (*   match Uuid.Table.find registered_masks (get_uuid t) with *)","counters":[]},{"line":"  (*   | None -> *)","counters":[]},{"line":"  (*       () *)","counters":[]},{"line":"  (*   | Some masks -> *)","counters":[]},{"line":"  (*       List.iter masks ~f:(fun mask -> *)","counters":[]},{"line":"  (*           Mask.Attached.parent_set_notify mask account ) *)","counters":[]},{"line":"","counters":[]},{"line":"  let remove_and_reparent_exn (m : t) (_t_as_mask : Mask.Attached.t) =","counters":[]},{"line":"    mask_remove_and_reparent m","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  (* let remove_and_reparent_exn t t_as_mask = *)","counters":[]},{"line":"  (*   let parent = Mask.Attached.get_parent t_as_mask in *)","counters":[]},{"line":"  (*   let merkle_root = Mask.Attached.merkle_root t_as_mask in *)","counters":[]},{"line":"  (*   (\\* we can only reparent if merkle roots are the same *\\) *)","counters":[]},{"line":"  (*   assert (Hash.equal (Base.merkle_root parent) merkle_root) ; *)","counters":[]},{"line":"  (*   let children = *)","counters":[]},{"line":"  (*     Hashtbl.find registered_masks (get_uuid t) |> Option.value ~default:[] *)","counters":[]},{"line":"  (*   in *)","counters":[]},{"line":"  (*   let dangling_masks = *)","counters":[]},{"line":"  (*     List.map children ~f:(fun c -> *)","counters":[]},{"line":"  (*         unregister_mask_exn ~loc:__LOC__ *)","counters":[]},{"line":"  (*           ~grandchildren:`I_promise_I_am_reparenting_this_mask c ) *)","counters":[]},{"line":"  (*   in *)","counters":[]},{"line":"  (*   ignore (unregister_mask_exn ~loc:__LOC__ t_as_mask : Mask.unattached) ; *)","counters":[]},{"line":"  (*   List.iter dangling_masks ~f:(fun m -> *)","counters":[]},{"line":"  (*       ignore (register_mask parent m : Mask.Attached.t) ) *)","counters":[]},{"line":"","counters":[]},{"line":"  (* let batch_notify_mask_children t accounts = *)","counters":[]},{"line":"  (*   match Uuid.Table.find registered_masks (get_uuid t) with *)","counters":[]},{"line":"  (*   | None -> *)","counters":[]},{"line":"  (*       () *)","counters":[]},{"line":"  (*   | Some masks -> *)","counters":[]},{"line":"  (*       List.iter masks ~f:(fun mask -> *)","counters":[]},{"line":"  (*           List.iter accounts ~f:(fun account -> *)","counters":[]},{"line":"  (*               Mask.Attached.parent_set_notify mask account ) ) *)","counters":[]},{"line":"","counters":[]},{"line":"  (* let set_batch t locations_and_accounts = *)","counters":[]},{"line":"  (*   let accounts = *)","counters":[]},{"line":"  (*     List.map locations_and_accounts ~f:(fun (location, account) -> *)","counters":[]},{"line":"  (*         (location_to_rust location, account_to_rust account) ) *)","counters":[]},{"line":"  (*   in *)","counters":[]},{"line":"  (*   Rust.mask_set_batch_accounts t accounts *)","counters":[]},{"line":"","counters":[]},{"line":"  (* let set_batch t locations_and_accounts = *)","counters":[]},{"line":"  (*   Base.set_batch t locations_and_accounts ; *)","counters":[]},{"line":"  (*   batch_notify_mask_children t (List.map locations_and_accounts ~f:snd) *)","counters":[]},{"line":"","counters":[]},{"line":"  (* let set_batch_accounts t addresses_and_accounts = *)","counters":[]},{"line":"  (*   let accounts = *)","counters":[]},{"line":"  (*     List.map addresses_and_accounts ~f:(fun (addr, account) -> *)","counters":[]},{"line":"  (*         (Addr.to_string addr, account_to_rust account) ) *)","counters":[]},{"line":"  (*   in *)","counters":[]},{"line":"  (*   Rust.mask_set_batch_accounts t accounts *)","counters":[]},{"line":"","counters":[]},{"line":"  (* let set_batch_accounts t addresses_and_accounts = *)","counters":[]},{"line":"  (*   Base.set_batch_accounts t addresses_and_accounts ; *)","counters":[]},{"line":"  (*   batch_notify_mask_children t (List.map addresses_and_accounts ~f:snd) *)","counters":[]},{"line":"","counters":[]},{"line":"  (* let set_all_accounts_rooted_at_exn t addr accounts = *)","counters":[]},{"line":"  (*   let accounts = List.map accounts ~f:account_to_rust in *)","counters":[]},{"line":"  (*   Rust.mask_set_all_accounts_rooted_at t (Addr.to_string addr) accounts *)","counters":[]},{"line":"","counters":[]},{"line":"  (* let set_all_accounts_rooted_at_exn t address accounts = *)","counters":[]},{"line":"  (*   Base.set_all_accounts_rooted_at_exn t address accounts ; *)","counters":[]},{"line":"  (*   batch_notify_mask_children t accounts *)","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}