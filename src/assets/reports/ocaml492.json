{"filename":"src/lib/child_processes/termination.ml","lines":[{"line":"(* termination.ml -- maintain a set of child pids","counters":[]},{"line":"   when a child not expected to terminate does terminate, raise an exception","counters":[]},{"line":"*)","counters":[]},{"line":"","counters":[{"col_start":0,"col_end":0,"count":1}]},{"line":"open Async","counters":[]},{"line":"open Core_kernel","counters":[]},{"line":"include Hashable.Make_binable (Pid)","counters":[]},{"line":"","counters":[]},{"line":"type process_kind =","counters":[{"col_start":0,"col_end":0,"count":0}]},{"line":"  | Prover","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | Verifier","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | Libp2p_helper","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | Snark_worker","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | Uptime_snark_worker","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | Vrf_evaluator","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"[@@deriving show { with_path = false }, yojson]","counters":[]},{"line":"","counters":[]},{"line":"type t = process_kind Pid.Table.t","counters":[]},{"line":"","counters":[]},{"line":"let create_pid_table () : t = Pid.Table.create ()","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"","counters":[]},{"line":"let register_process (t : t) process kind =","counters":[]},{"line":"  Pid.Table.add_exn t ~key:(Process.pid process) ~data:kind","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"","counters":[]},{"line":"let remove : t -> Pid.t -> unit = Pid.Table.remove","counters":[]},{"line":"","counters":[]},{"line":"(** for some signals that cause termination, offer a possible explanation *)","counters":[]},{"line":"let get_signal_cause_opt =","counters":[]},{"line":"  let open Signal in","counters":[]},{"line":"  let signal_causes_tbl : string Table.t = Table.create () in","counters":[{"col_start":54,"col_end":54,"count":1}]},{"line":"  List.iter","counters":[]},{"line":"    [ (kill, \"Process killed because out of memory\")","counters":[]},{"line":"    ; (int, \"Process interrupted by user or other program\")","counters":[]},{"line":"    ]","counters":[]},{"line":"    ~f:(fun (signal, msg) ->","counters":[]},{"line":"      Base.ignore (Table.add signal_causes_tbl ~key:signal ~data:msg) ) ;","counters":[{"col_start":6,"col_end":6,"count":2},{"col_start":27,"col_end":27,"count":2}]},{"line":"  fun signal -> Signal.Table.find signal_causes_tbl signal","counters":[{"col_start":2,"col_end":2,"count":1},{"col_start":16,"col_end":16,"count":0}]},{"line":"","counters":[]},{"line":"(** wait for a [process], which may resolve immediately or in a Deferred.t,","counters":[]},{"line":"    log any errors, attributing the source to the provided [module] and [location]","counters":[]},{"line":"*)","counters":[]},{"line":"let wait_for_process_log_errors ~logger process ~module_ ~location ~here =","counters":[]},{"line":"  (* Handle implicit raciness in the wait syscall by calling [Process.wait]","counters":[]},{"line":"     early, so that its value will be correctly cached when we actually need","counters":[]},{"line":"     it.","counters":[]},{"line":"  *)","counters":[]},{"line":"  match","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Or_error.try_with (fun () ->","counters":[]},{"line":"        (* Eagerly force [Process.wait], so that it won't be captured","counters":[]},{"line":"           elsewhere on exit.","counters":[]},{"line":"        *)","counters":[]},{"line":"        let waiting =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Monitor.try_with ~here ~run:`Now","counters":[]},{"line":"            ~rest:","counters":[]},{"line":"              (`Call","counters":[]},{"line":"                (fun exn ->","counters":[]},{"line":"                  let err = Error.of_exn exn in","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  Logger.error logger ~module_ ~location","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    \"Saw a deferred exception $exn after waiting for process\"","counters":[]},{"line":"                    ~metadata:[ (\"exn\", Error_json.error_to_yojson err) ] ) )","counters":[{"col_start":65,"col_end":65,"count":0}]},{"line":"            (fun () -> Process.wait process)","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"        in","counters":[]},{"line":"        don't_wait_for","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ( match%map waiting with","counters":[]},{"line":"          | Ok _ ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              ()","counters":[]},{"line":"          | Error exn ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let err = Error.of_exn exn in","counters":[]},{"line":"              Logger.error logger ~module_ ~location","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                \"Saw a deferred exception $exn while waiting for process\"","counters":[]},{"line":"                ~metadata:[ (\"exn\", Error_json.error_to_yojson err) ] ) )","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"  with","counters":[]},{"line":"  | Ok _ ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ()","counters":[]},{"line":"  | Error err ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Logger.error logger ~module_ ~location","counters":[]},{"line":"        \"Saw an immediate exception $exn while waiting for process\"","counters":[]},{"line":"        ~metadata:[ (\"exn\", Error_json.error_to_yojson err) ]","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"","counters":[]},{"line":"(** Call this as early as possible after the process is known, and store the","counters":[]},{"line":"    resulting [Deferred.t] somewhere to be used later.","counters":[]},{"line":"*)","counters":[]},{"line":"let wait_safe ~logger process ~module_ ~location ~here =","counters":[]},{"line":"  (* This is a little more nuanced than it may initially seem.","counters":[]},{"line":"     - The initial call to [Process.wait] runs a wait syscall -- with the","counters":[]},{"line":"       NOHANG flag -- synchronously.","counters":[]},{"line":"       * This may raise an error (WNOHANG or otherwise) that we have to handle","counters":[]},{"line":"         synchronously at call time.","counters":[]},{"line":"     - The [Process.wait] then returns a [Deferred.t] that resolves when a","counters":[]},{"line":"       second syscall returns.","counters":[]},{"line":"       * This may throw its own errors, so we need to ensure that this is also","counters":[]},{"line":"         wrapped to catch them.","counters":[]},{"line":"     - Once the child process has died and one or more wait syscalls have","counters":[]},{"line":"       resolved, the operating system will drop the process metadata. This","counters":[]},{"line":"       means that our wait may hang forever if 1) the process has already died","counters":[]},{"line":"       and 2) there was a wait call issued by some other code before we have a","counters":[]},{"line":"       chance.","counters":[]},{"line":"       * Thus, we should make this initial call while the child process is","counters":[]},{"line":"         still alive, preferably on startup, to avoid this hang.","counters":[]},{"line":"  *)","counters":[]},{"line":"  match","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Or_error.try_with (fun () ->","counters":[]},{"line":"        let deferred_wait =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Monitor.try_with ~here ~run:`Now","counters":[]},{"line":"            ~rest:","counters":[]},{"line":"              (`Call","counters":[]},{"line":"                (fun exn ->","counters":[]},{"line":"                  Logger.warn logger ~module_ ~location","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    \"Saw an error from Process.wait in wait_safe: $err\"","counters":[]},{"line":"                    ~metadata:","counters":[]},{"line":"                      [ (\"err\", Error_json.error_to_yojson (Error.of_exn exn)) ]","counters":[{"col_start":57,"col_end":57,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"                  ) )","counters":[]},{"line":"            (fun () -> Process.wait process)","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"        in","counters":[]},{"line":"        Deferred.Result.map_error ~f:Error.of_exn deferred_wait )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"  with","counters":[]},{"line":"  | Ok x ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      x","counters":[]},{"line":"  | Error err ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Deferred.Or_error.fail err","counters":[{"col_start":31,"col_end":31,"count":1}]}]}