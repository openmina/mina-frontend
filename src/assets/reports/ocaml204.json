{"filename":"src/lib/currency/intf.ml","lines":[{"line":"[%%import \"/src/config.mlh\"]","counters":[]},{"line":"","counters":[{"col_start":0,"col_end":0,"count":1}]},{"line":"open Core_kernel","counters":[]},{"line":"open Snark_bits","counters":[]},{"line":"open Snark_params.Tick","counters":[]},{"line":"","counters":[]},{"line":"type uint64 = Unsigned.uint64","counters":[]},{"line":"","counters":[]},{"line":"module type Basic = sig","counters":[]},{"line":"  type t [@@deriving sexp, compare, hash, yojson]","counters":[]},{"line":"","counters":[]},{"line":"  type magnitude = t [@@deriving sexp, compare]","counters":[]},{"line":"","counters":[]},{"line":"  (* not automatically derived *)","counters":[]},{"line":"  val dhall_type : Ppx_dhall_type.Dhall_type.t","counters":[]},{"line":"","counters":[]},{"line":"  val max_int : t","counters":[]},{"line":"","counters":[]},{"line":"  val length_in_bits : int","counters":[]},{"line":"","counters":[]},{"line":"  include Comparable.S with type t := t","counters":[]},{"line":"","counters":[]},{"line":"  val gen_incl : t -> t -> t Quickcheck.Generator.t","counters":[]},{"line":"","counters":[]},{"line":"  val gen : t Quickcheck.Generator.t","counters":[]},{"line":"","counters":[]},{"line":"  include Bits_intf.Convertible_bits with type t := t","counters":[]},{"line":"","counters":[]},{"line":"  val to_input : t -> Field.t Random_oracle.Input.Chunked.t","counters":[]},{"line":"","counters":[]},{"line":"  val to_input_legacy : t -> (_, bool) Random_oracle.Legacy.Input.t","counters":[]},{"line":"","counters":[]},{"line":"  val zero : t","counters":[]},{"line":"","counters":[]},{"line":"  val one : t","counters":[]},{"line":"","counters":[]},{"line":"  val of_string : string -> t","counters":[]},{"line":"","counters":[]},{"line":"  val to_string : t -> string","counters":[]},{"line":"","counters":[]},{"line":"  val of_formatted_string : string -> t","counters":[]},{"line":"","counters":[]},{"line":"  val to_formatted_string : t -> string","counters":[]},{"line":"","counters":[]},{"line":"  val of_int : int -> t","counters":[]},{"line":"","counters":[]},{"line":"  val to_int : t -> int","counters":[]},{"line":"","counters":[]},{"line":"  val to_uint64 : t -> uint64","counters":[]},{"line":"","counters":[]},{"line":"  val of_uint64 : uint64 -> t","counters":[]},{"line":"","counters":[]},{"line":"  [%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"  type var","counters":[]},{"line":"","counters":[]},{"line":"  val typ : (var, t) Typ.t","counters":[]},{"line":"","counters":[]},{"line":"  val var_of_t : t -> var","counters":[]},{"line":"","counters":[]},{"line":"  val var_to_bits :","counters":[]},{"line":"    var -> Boolean.var Bitstring_lib.Bitstring.Lsb_first.t Checked.t","counters":[]},{"line":"","counters":[]},{"line":"  val var_to_input : var -> Field.Var.t Random_oracle.Input.Chunked.t","counters":[]},{"line":"","counters":[]},{"line":"  val var_to_input_legacy :","counters":[]},{"line":"    var -> (Field.Var.t, Boolean.var) Random_oracle.Input.Legacy.t Checked.t","counters":[]},{"line":"","counters":[]},{"line":"  val equal_var : var -> var -> Boolean.var Checked.t","counters":[]},{"line":"","counters":[]},{"line":"  val pack_var : var -> Field.Var.t","counters":[]},{"line":"","counters":[]},{"line":"  [%%endif]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type Arithmetic_intf = sig","counters":[]},{"line":"  type t","counters":[]},{"line":"","counters":[]},{"line":"  val add : t -> t -> t option","counters":[]},{"line":"","counters":[]},{"line":"  val add_flagged : t -> t -> t * [ `Overflow of bool ]","counters":[]},{"line":"","counters":[]},{"line":"  val sub : t -> t -> t option","counters":[]},{"line":"","counters":[]},{"line":"  val sub_flagged : t -> t -> t * [ `Underflow of bool ]","counters":[]},{"line":"","counters":[]},{"line":"  val ( + ) : t -> t -> t option","counters":[]},{"line":"","counters":[]},{"line":"  val ( - ) : t -> t -> t option","counters":[]},{"line":"","counters":[]},{"line":"  val scale : t -> int -> t option","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type Signed_intf = sig","counters":[]},{"line":"  type magnitude","counters":[]},{"line":"","counters":[]},{"line":"  type signed_fee","counters":[]},{"line":"","counters":[]},{"line":"  [%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"  type magnitude_var","counters":[]},{"line":"","counters":[]},{"line":"  [%%endif]","counters":[]},{"line":"","counters":[]},{"line":"  type t = (magnitude, Sgn.t) Signed_poly.t","counters":[]},{"line":"  [@@deriving sexp, hash, compare, equal, yojson]","counters":[]},{"line":"","counters":[]},{"line":"  val gen : t Quickcheck.Generator.t","counters":[]},{"line":"","counters":[]},{"line":"  val create :","counters":[]},{"line":"    magnitude:'magnitude -> sgn:'sgn -> ('magnitude, 'sgn) Signed_poly.t","counters":[]},{"line":"","counters":[]},{"line":"  val sgn : t -> Sgn.t","counters":[]},{"line":"","counters":[]},{"line":"  val magnitude : t -> magnitude","counters":[]},{"line":"","counters":[]},{"line":"  val zero : t","counters":[]},{"line":"","counters":[]},{"line":"  val is_zero : t -> bool","counters":[]},{"line":"","counters":[]},{"line":"  val is_positive : t -> bool","counters":[]},{"line":"","counters":[]},{"line":"  val is_negative : t -> bool","counters":[]},{"line":"","counters":[]},{"line":"  val to_input : t -> Field.t Random_oracle.Input.Chunked.t","counters":[]},{"line":"","counters":[]},{"line":"  val to_input_legacy : t -> (_, bool) Random_oracle.Legacy.Input.t","counters":[]},{"line":"","counters":[]},{"line":"  val add : t -> t -> t option","counters":[]},{"line":"","counters":[]},{"line":"  val add_flagged : t -> t -> t * [ `Overflow of bool ]","counters":[]},{"line":"","counters":[]},{"line":"  val ( + ) : t -> t -> t option","counters":[]},{"line":"","counters":[]},{"line":"  val negate : t -> t","counters":[]},{"line":"","counters":[]},{"line":"  val of_unsigned : magnitude -> t","counters":[]},{"line":"","counters":[]},{"line":"  val to_fee : t -> signed_fee","counters":[]},{"line":"","counters":[]},{"line":"  val of_fee : signed_fee -> t","counters":[]},{"line":"","counters":[]},{"line":"  [%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"  type var (* = (magnitude_var, Sgn.var) Signed_poly.t *)","counters":[]},{"line":"","counters":[]},{"line":"  val create_var : magnitude:magnitude_var -> sgn:Sgn.var -> var","counters":[]},{"line":"","counters":[]},{"line":"  val typ : (var, t) Typ.t","counters":[]},{"line":"","counters":[]},{"line":"  module Checked : sig","counters":[]},{"line":"    type signed_fee_var","counters":[]},{"line":"","counters":[]},{"line":"    val constant : t -> var","counters":[]},{"line":"","counters":[]},{"line":"    val of_unsigned : magnitude_var -> var","counters":[]},{"line":"","counters":[]},{"line":"    val sgn : var -> Sgn.var Checked.t","counters":[]},{"line":"","counters":[]},{"line":"    val magnitude : var -> magnitude_var Checked.t","counters":[]},{"line":"","counters":[]},{"line":"    val negate : var -> var","counters":[]},{"line":"","counters":[]},{"line":"    val if_ : Boolean.var -> then_:var -> else_:var -> var Checked.t","counters":[]},{"line":"","counters":[]},{"line":"    val to_input : var -> Field.Var.t Random_oracle.Input.Chunked.t Checked.t","counters":[]},{"line":"","counters":[]},{"line":"    val to_input_legacy :","counters":[]},{"line":"      var -> (_, Boolean.var) Random_oracle.Legacy.Input.t Checked.t","counters":[]},{"line":"","counters":[]},{"line":"    val add : var -> var -> var Checked.t","counters":[]},{"line":"","counters":[]},{"line":"    val add_flagged :","counters":[]},{"line":"      var -> var -> (var * [ `Overflow of Boolean.var ]) Checked.t","counters":[]},{"line":"","counters":[]},{"line":"    val assert_equal : var -> var -> unit Checked.t","counters":[]},{"line":"","counters":[]},{"line":"    val equal : var -> var -> Boolean.var Checked.t","counters":[]},{"line":"","counters":[]},{"line":"    val ( + ) : var -> var -> var Checked.t","counters":[]},{"line":"","counters":[]},{"line":"    val to_field_var : var -> Field.Var.t Checked.t","counters":[]},{"line":"","counters":[]},{"line":"    val to_fee : var -> signed_fee_var","counters":[]},{"line":"","counters":[]},{"line":"    val of_fee : signed_fee_var -> var","counters":[]},{"line":"","counters":[]},{"line":"    type t = var","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  [%%endif]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"[%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"module type Checked_arithmetic_intf = sig","counters":[]},{"line":"  type value","counters":[]},{"line":"","counters":[]},{"line":"  type var","counters":[]},{"line":"","counters":[]},{"line":"  type t = var","counters":[]},{"line":"","counters":[]},{"line":"  type signed_var","counters":[]},{"line":"","counters":[]},{"line":"  val if_ : Boolean.var -> then_:var -> else_:var -> var Checked.t","counters":[]},{"line":"","counters":[]},{"line":"  val add : var -> var -> var Checked.t","counters":[]},{"line":"","counters":[]},{"line":"  val sub : var -> var -> var Checked.t","counters":[]},{"line":"","counters":[]},{"line":"  val sub_flagged :","counters":[]},{"line":"    var -> var -> (var * [ `Underflow of Boolean.var ]) Checked.t","counters":[]},{"line":"","counters":[]},{"line":"  val sub_or_zero : var -> var -> var Checked.t","counters":[]},{"line":"","counters":[]},{"line":"  val add_flagged : var -> var -> (var * [ `Overflow of Boolean.var ]) Checked.t","counters":[]},{"line":"","counters":[]},{"line":"  val ( + ) : var -> var -> var Checked.t","counters":[]},{"line":"","counters":[]},{"line":"  val ( - ) : var -> var -> var Checked.t","counters":[]},{"line":"","counters":[]},{"line":"  val add_signed : var -> signed_var -> var Checked.t","counters":[]},{"line":"","counters":[]},{"line":"  val add_signed_flagged :","counters":[]},{"line":"    var -> signed_var -> (var * [ `Overflow of Boolean.var ]) Checked.t","counters":[]},{"line":"","counters":[]},{"line":"  val assert_equal : var -> var -> unit Checked.t","counters":[]},{"line":"","counters":[]},{"line":"  val equal : var -> var -> Boolean.var Checked.t","counters":[]},{"line":"","counters":[]},{"line":"  val ( = ) : t -> t -> Boolean.var Checked.t","counters":[]},{"line":"","counters":[]},{"line":"  val ( < ) : t -> t -> Boolean.var Checked.t","counters":[]},{"line":"","counters":[]},{"line":"  val ( > ) : t -> t -> Boolean.var Checked.t","counters":[]},{"line":"","counters":[]},{"line":"  val ( <= ) : t -> t -> Boolean.var Checked.t","counters":[]},{"line":"","counters":[]},{"line":"  val ( >= ) : t -> t -> Boolean.var Checked.t","counters":[]},{"line":"","counters":[]},{"line":"  val scale : Field.Var.t -> var -> var Checked.t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"[%%endif]","counters":[]},{"line":"","counters":[]},{"line":"module type S = sig","counters":[]},{"line":"  include Basic","counters":[]},{"line":"","counters":[]},{"line":"  include Arithmetic_intf with type t := t","counters":[]},{"line":"","counters":[]},{"line":"  [%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"  module Signed :","counters":[]},{"line":"    Signed_intf with type magnitude := t and type magnitude_var := var","counters":[]},{"line":"","counters":[]},{"line":"  module Checked :","counters":[]},{"line":"    Checked_arithmetic_intf","counters":[]},{"line":"      with type var := var","counters":[]},{"line":"       and type signed_var := Signed.var","counters":[]},{"line":"       and type value := t","counters":[]},{"line":"","counters":[]},{"line":"  [%%else]","counters":[]},{"line":"","counters":[]},{"line":"  module Signed : Signed_intf with type magnitude := t","counters":[]},{"line":"","counters":[]},{"line":"  [%%endif]","counters":[]},{"line":"","counters":[]},{"line":"  val add_signed_flagged : t -> Signed.t -> t * [ `Overflow of bool ]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type Full = sig","counters":[]},{"line":"  [%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"  open Snark_params.Tick","counters":[]},{"line":"","counters":[]},{"line":"  module Signed_var : sig","counters":[]},{"line":"    type 'mag repr = ('mag, Sgn.var) Signed_poly.t","counters":[]},{"line":"","counters":[]},{"line":"    (* Invariant: At least one of these is Some *)","counters":[]},{"line":"    type nonrec 'mag t =","counters":[]},{"line":"      { repr : 'mag repr; mutable value : Field.Var.t option }","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  [%%endif]","counters":[]},{"line":"","counters":[]},{"line":"  module Signed_poly = Signed_poly","counters":[]},{"line":"","counters":[]},{"line":"  module Fee : sig","counters":[]},{"line":"    [%%versioned:","counters":[]},{"line":"    module Stable : sig","counters":[]},{"line":"      module V1 : sig","counters":[]},{"line":"        [@@@with_all_version_tags]","counters":[]},{"line":"","counters":[]},{"line":"        type t [@@deriving sexp, compare, hash, yojson, equal]","counters":[]},{"line":"","counters":[]},{"line":"        (* not automatically derived *)","counters":[]},{"line":"        val dhall_type : Ppx_dhall_type.Dhall_type.t","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    include Basic with type t := Stable.Latest.t","counters":[]},{"line":"","counters":[]},{"line":"    include Arithmetic_intf with type t := t","counters":[]},{"line":"","counters":[]},{"line":"    include Codable.S with type t := t","counters":[]},{"line":"","counters":[]},{"line":"    (* TODO: Get rid of signed fee, use signed amount *)","counters":[]},{"line":"    [%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"    module Signed :","counters":[]},{"line":"      Signed_intf","counters":[]},{"line":"        with type magnitude := t","counters":[]},{"line":"         and type magnitude_var := var","counters":[]},{"line":"         and type signed_fee := (t, Sgn.t) Signed_poly.t","counters":[]},{"line":"         and type Checked.signed_fee_var := Field.Var.t Signed_var.t","counters":[]},{"line":"","counters":[]},{"line":"    [%%else]","counters":[]},{"line":"","counters":[]},{"line":"    module Signed :","counters":[]},{"line":"      Signed_intf","counters":[]},{"line":"        with type magnitude := t","counters":[]},{"line":"         and type signed_fee := (t, Sgn.t) Signed_poly.t","counters":[]},{"line":"","counters":[]},{"line":"    [%%endif]","counters":[]},{"line":"","counters":[]},{"line":"    [%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"    module Checked : sig","counters":[]},{"line":"      include","counters":[]},{"line":"        Checked_arithmetic_intf","counters":[]},{"line":"          with type var := var","counters":[]},{"line":"           and type signed_var := Signed.var","counters":[]},{"line":"           and type value := t","counters":[]},{"line":"","counters":[]},{"line":"      val add_signed : var -> Signed.var -> var Checked.t","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    [%%endif]","counters":[]},{"line":"  end","counters":[]},{"line":"  [@@warning \"-32\"]","counters":[]},{"line":"","counters":[]},{"line":"  module Amount : sig","counters":[]},{"line":"    [%%versioned:","counters":[]},{"line":"    module Stable : sig","counters":[]},{"line":"      module V1 : sig","counters":[]},{"line":"        [@@@with_all_version_tags]","counters":[]},{"line":"","counters":[]},{"line":"        type t [@@deriving sexp, compare, hash, equal, yojson]","counters":[]},{"line":"","counters":[]},{"line":"        (* not automatically derived *)","counters":[]},{"line":"        val dhall_type : Ppx_dhall_type.Dhall_type.t","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    include Basic with type t := Stable.Latest.t","counters":[]},{"line":"","counters":[]},{"line":"    include Arithmetic_intf with type t := t","counters":[]},{"line":"","counters":[]},{"line":"    include Codable.S with type t := t","counters":[]},{"line":"","counters":[]},{"line":"    [%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"    module Signed :","counters":[]},{"line":"      Signed_intf","counters":[]},{"line":"        with type magnitude := t","counters":[]},{"line":"         and type magnitude_var := var","counters":[]},{"line":"         and type signed_fee := Fee.Signed.t","counters":[]},{"line":"         and type Checked.signed_fee_var := Fee.Signed.Checked.t","counters":[]},{"line":"","counters":[]},{"line":"    [%%else]","counters":[]},{"line":"","counters":[]},{"line":"    module Signed :","counters":[]},{"line":"      Signed_intf with type magnitude := t and type signed_fee := Fee.Signed.t","counters":[]},{"line":"","counters":[]},{"line":"    [%%endif]","counters":[]},{"line":"","counters":[]},{"line":"    (* TODO: Delete these functions *)","counters":[]},{"line":"","counters":[]},{"line":"    val of_fee : Fee.t -> t","counters":[]},{"line":"","counters":[]},{"line":"    val to_fee : t -> Fee.t","counters":[]},{"line":"","counters":[]},{"line":"    val add_fee : t -> Fee.t -> t option","counters":[]},{"line":"","counters":[]},{"line":"    val add_signed_flagged : t -> Signed.t -> t * [ `Overflow of bool ]","counters":[]},{"line":"","counters":[]},{"line":"    [%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"    module Checked : sig","counters":[]},{"line":"      include","counters":[]},{"line":"        Checked_arithmetic_intf","counters":[]},{"line":"          with type var := var","counters":[]},{"line":"           and type signed_var := Signed.var","counters":[]},{"line":"           and type value := t","counters":[]},{"line":"","counters":[]},{"line":"      val add_signed : var -> Signed.var -> var Checked.t","counters":[]},{"line":"","counters":[]},{"line":"      val add_signed_flagged :","counters":[]},{"line":"        var -> Signed.var -> (var * [ `Overflow of Boolean.var ]) Checked.t","counters":[]},{"line":"","counters":[]},{"line":"      val of_fee : Fee.var -> var","counters":[]},{"line":"","counters":[]},{"line":"      val to_fee : var -> Fee.var","counters":[]},{"line":"","counters":[]},{"line":"      module Unsafe : sig","counters":[]},{"line":"        val of_field : Field.Var.t -> t","counters":[]},{"line":"      end","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    [%%endif]","counters":[]},{"line":"  end","counters":[]},{"line":"  [@@warning \"-32\"]","counters":[]},{"line":"","counters":[]},{"line":"  module Balance : sig","counters":[]},{"line":"    [%%versioned:","counters":[]},{"line":"    module Stable : sig","counters":[]},{"line":"      module V1 : sig","counters":[]},{"line":"        type t [@@deriving sexp, compare, hash, yojson, equal]","counters":[]},{"line":"","counters":[]},{"line":"        (* not automatically derived *)","counters":[]},{"line":"        val dhall_type : Ppx_dhall_type.Dhall_type.t","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    include Basic with type t := Stable.Latest.t","counters":[]},{"line":"","counters":[]},{"line":"    val to_amount : t -> Amount.t","counters":[]},{"line":"","counters":[]},{"line":"    val add_amount : t -> Amount.t -> t option","counters":[]},{"line":"","counters":[]},{"line":"    val add_amount_flagged : t -> Amount.t -> t * [ `Overflow of bool ]","counters":[]},{"line":"","counters":[]},{"line":"    val sub_amount : t -> Amount.t -> t option","counters":[]},{"line":"","counters":[]},{"line":"    val sub_amount_flagged : t -> Amount.t -> t * [ `Underflow of bool ]","counters":[]},{"line":"","counters":[]},{"line":"    val add_signed_amount_flagged :","counters":[]},{"line":"      t -> Amount.Signed.t -> t * [ `Overflow of bool ]","counters":[]},{"line":"","counters":[]},{"line":"    val ( + ) : t -> Amount.t -> t option","counters":[]},{"line":"","counters":[]},{"line":"    val ( - ) : t -> Amount.t -> t option","counters":[]},{"line":"","counters":[]},{"line":"    [%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"    module Checked : sig","counters":[]},{"line":"      type t = var","counters":[]},{"line":"","counters":[]},{"line":"      val to_amount : t -> Amount.var","counters":[]},{"line":"","counters":[]},{"line":"      val add_signed_amount : var -> Amount.Signed.var -> var Checked.t","counters":[]},{"line":"","counters":[]},{"line":"      val add_amount : var -> Amount.var -> var Checked.t","counters":[]},{"line":"","counters":[]},{"line":"      val sub_amount : var -> Amount.var -> var Checked.t","counters":[]},{"line":"","counters":[]},{"line":"      val sub_amount_flagged :","counters":[]},{"line":"        var -> Amount.var -> (var * [ `Underflow of Boolean.var ]) Checked.t","counters":[]},{"line":"","counters":[]},{"line":"      val add_amount_flagged :","counters":[]},{"line":"        var -> Amount.var -> (var * [ `Overflow of Boolean.var ]) Checked.t","counters":[]},{"line":"","counters":[]},{"line":"      val add_signed_amount_flagged :","counters":[]},{"line":"           var","counters":[]},{"line":"        -> Amount.Signed.var","counters":[]},{"line":"        -> (var * [ `Overflow of Boolean.var ]) Checked.t","counters":[]},{"line":"","counters":[]},{"line":"      val sub_or_zero : var -> var -> var Checked.t","counters":[]},{"line":"","counters":[]},{"line":"      val ( + ) : var -> Amount.var -> var Checked.t","counters":[]},{"line":"","counters":[]},{"line":"      val ( - ) : var -> Amount.var -> var Checked.t","counters":[]},{"line":"","counters":[]},{"line":"      val equal : var -> var -> Boolean.var Checked.t","counters":[]},{"line":"","counters":[]},{"line":"      val ( = ) : var -> var -> Boolean.var Checked.t","counters":[]},{"line":"","counters":[]},{"line":"      val ( < ) : var -> var -> Boolean.var Checked.t","counters":[]},{"line":"","counters":[]},{"line":"      val ( > ) : var -> var -> Boolean.var Checked.t","counters":[]},{"line":"","counters":[]},{"line":"      val ( <= ) : var -> var -> Boolean.var Checked.t","counters":[]},{"line":"","counters":[]},{"line":"      val ( >= ) : var -> var -> Boolean.var Checked.t","counters":[]},{"line":"","counters":[]},{"line":"      val if_ : Boolean.var -> then_:var -> else_:var -> var Checked.t","counters":[]},{"line":"","counters":[]},{"line":"      module Unsafe : sig","counters":[]},{"line":"        val of_field : Field.Var.t -> var","counters":[]},{"line":"      end","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    [%%endif]","counters":[]},{"line":"  end","counters":[]},{"line":"  [@@warning \"-32\"]","counters":[]},{"line":"","counters":[]},{"line":"  module Fee_rate : sig","counters":[]},{"line":"    type t","counters":[]},{"line":"","counters":[]},{"line":"    include Arithmetic_intf with type t := t","counters":[]},{"line":"","counters":[]},{"line":"    include Comparable.S with type t := t","counters":[]},{"line":"","counters":[]},{"line":"    include Sexpable.S with type t := t","counters":[]},{"line":"","counters":[]},{"line":"    val of_q : Q.t -> t option","counters":[]},{"line":"","counters":[]},{"line":"    val of_q_exn : Q.t -> t","counters":[]},{"line":"","counters":[]},{"line":"    val to_q : t -> Q.t","counters":[]},{"line":"","counters":[]},{"line":"    (** construct a fee rate from a fee and a weight *)","counters":[]},{"line":"    val make : Fee.t -> int -> t option","counters":[]},{"line":"","counters":[]},{"line":"    (** construct a fee rate from a fee and a weight *)","counters":[]},{"line":"    val make_exn : Fee.t -> int -> t","counters":[]},{"line":"","counters":[]},{"line":"    (** convert to uint64, if the fee rate is equivalent to an integer. *)","counters":[]},{"line":"    val to_uint64 : t -> uint64 option","counters":[]},{"line":"","counters":[]},{"line":"    (** convert to uint64, if the fee rate is equivalent to an integer. *)","counters":[]},{"line":"    val to_uint64_exn : t -> uint64","counters":[]},{"line":"","counters":[]},{"line":"    val mul : t -> t -> t option","counters":[]},{"line":"","counters":[]},{"line":"    val scale_exn : t -> int -> t","counters":[]},{"line":"","counters":[]},{"line":"    val div : t -> t -> t option","counters":[]},{"line":"","counters":[]},{"line":"    val ( * ) : t -> t -> t option","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":1}]}]}