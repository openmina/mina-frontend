{"filename":"src/lib/mina_block/validation.ml","lines":[{"line":"(* TODO: refactor","counters":[]},{"line":"   - validations need to be simplified and merged","counters":[]},{"line":"     - also need to think if data-carrying validations makes sense or not","counters":[]},{"line":"   - initial validation properties should all be combined, with different validation entrypoints for each use case","counters":[]},{"line":"   - frontier validation needs re-thought","counters":[]},{"line":"*)","counters":[]},{"line":"","counters":[{"col_start":0,"col_end":0,"count":1}]},{"line":"open Async_kernel","counters":[]},{"line":"open Core_kernel","counters":[]},{"line":"open Mina_base","counters":[]},{"line":"open Mina_state","counters":[]},{"line":"open Consensus.Data","counters":[]},{"line":"include Validation_types","counters":[]},{"line":"","counters":[]},{"line":"module type CONTEXT = sig","counters":[]},{"line":"  val logger : Logger.t","counters":[]},{"line":"","counters":[]},{"line":"  val constraint_constants : Genesis_constants.Constraint_constants.t","counters":[]},{"line":"","counters":[]},{"line":"  val consensus_constants : Consensus.Constants.t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let validation (_, v) = v","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"","counters":[]},{"line":"let block_with_hash (b, _) = b","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"let block (b, _) = With_hash.data b","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"","counters":[]},{"line":"let wrap t : fully_invalid_with_block = (t, fully_invalid)","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"module Unsafe = struct","counters":[]},{"line":"  let set_valid_time_received :","counters":[]},{"line":"         ( [ `Time_received ] * unit Truth.false_t","counters":[]},{"line":"         , 'genesis_state","counters":[]},{"line":"         , 'proof","counters":[]},{"line":"         , 'delta_block_chain","counters":[]},{"line":"         , 'frontier_dependencies","counters":[]},{"line":"         , 'staged_ledger_diff","counters":[]},{"line":"         , 'protocol_versions )","counters":[]},{"line":"         t","counters":[]},{"line":"      -> ( [ `Time_received ] * unit Truth.true_t","counters":[]},{"line":"         , 'genesis_state","counters":[]},{"line":"         , 'proof","counters":[]},{"line":"         , 'delta_block_chain","counters":[]},{"line":"         , 'frontier_dependencies","counters":[]},{"line":"         , 'staged_ledger_diff","counters":[]},{"line":"         , 'protocol_versions )","counters":[]},{"line":"         t = function","counters":[]},{"line":"    | ( (`Time_received, Truth.False)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      , genesis_state","counters":[]},{"line":"      , proof","counters":[]},{"line":"      , delta_block_chain","counters":[]},{"line":"      , frontier_dependencies","counters":[]},{"line":"      , staged_ledger_diff","counters":[]},{"line":"      , protocol_versions ) ->","counters":[]},{"line":"        ( (`Time_received, Truth.True ())","counters":[]},{"line":"        , genesis_state","counters":[]},{"line":"        , proof","counters":[]},{"line":"        , delta_block_chain","counters":[]},{"line":"        , frontier_dependencies","counters":[]},{"line":"        , staged_ledger_diff","counters":[]},{"line":"        , protocol_versions )","counters":[]},{"line":"","counters":[]},{"line":"  let set_valid_proof :","counters":[]},{"line":"         ( 'time_received","counters":[]},{"line":"         , 'genesis_state","counters":[]},{"line":"         , [ `Proof ] * unit Truth.false_t","counters":[]},{"line":"         , 'delta_block_chain","counters":[]},{"line":"         , 'frontier_dependencies","counters":[]},{"line":"         , 'staged_ledger_diff","counters":[]},{"line":"         , 'protocol_versions )","counters":[]},{"line":"         t","counters":[]},{"line":"      -> ( 'time_received","counters":[]},{"line":"         , 'genesis_state","counters":[]},{"line":"         , [ `Proof ] * unit Truth.true_t","counters":[]},{"line":"         , 'delta_block_chain","counters":[]},{"line":"         , 'frontier_dependencies","counters":[]},{"line":"         , 'staged_ledger_diff","counters":[]},{"line":"         , 'protocol_versions )","counters":[]},{"line":"         t = function","counters":[]},{"line":"    | ( time_received","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      , genesis_state","counters":[]},{"line":"      , (`Proof, Truth.False)","counters":[]},{"line":"      , delta_block_chain","counters":[]},{"line":"      , frontier_dependencies","counters":[]},{"line":"      , staged_ledger_diff","counters":[]},{"line":"      , protocol_versions ) ->","counters":[]},{"line":"        ( time_received","counters":[]},{"line":"        , genesis_state","counters":[]},{"line":"        , (`Proof, Truth.True ())","counters":[]},{"line":"        , delta_block_chain","counters":[]},{"line":"        , frontier_dependencies","counters":[]},{"line":"        , staged_ledger_diff","counters":[]},{"line":"        , protocol_versions )","counters":[]},{"line":"","counters":[]},{"line":"  let set_valid_genesis_state :","counters":[]},{"line":"         ( 'time_received","counters":[]},{"line":"         , [ `Genesis_state ] * unit Truth.false_t","counters":[]},{"line":"         , 'proof","counters":[]},{"line":"         , 'delta_block_chain","counters":[]},{"line":"         , 'frontier_dependencies","counters":[]},{"line":"         , 'staged_ledger_diff","counters":[]},{"line":"         , 'protocol_versions )","counters":[]},{"line":"         t","counters":[]},{"line":"      -> ( 'time_received","counters":[]},{"line":"         , [ `Genesis_state ] * unit Truth.true_t","counters":[]},{"line":"         , 'proof","counters":[]},{"line":"         , 'delta_block_chain","counters":[]},{"line":"         , 'frontier_dependencies","counters":[]},{"line":"         , 'staged_ledger_diff","counters":[]},{"line":"         , 'protocol_versions )","counters":[]},{"line":"         t = function","counters":[]},{"line":"    | ( time_received","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      , (`Genesis_state, Truth.False)","counters":[]},{"line":"      , proof","counters":[]},{"line":"      , delta_block_chain","counters":[]},{"line":"      , frontier_dependencies","counters":[]},{"line":"      , staged_ledger_diff","counters":[]},{"line":"      , protocol_versions ) ->","counters":[]},{"line":"        ( time_received","counters":[]},{"line":"        , (`Genesis_state, Truth.True ())","counters":[]},{"line":"        , proof","counters":[]},{"line":"        , delta_block_chain","counters":[]},{"line":"        , frontier_dependencies","counters":[]},{"line":"        , staged_ledger_diff","counters":[]},{"line":"        , protocol_versions )","counters":[]},{"line":"","counters":[]},{"line":"  let set_valid_delta_block_chain :","counters":[]},{"line":"         ( 'time_received","counters":[]},{"line":"         , 'genesis_state","counters":[]},{"line":"         , 'proof","counters":[]},{"line":"         , [ `Delta_block_chain ] * State_hash.t Non_empty_list.t Truth.false_t","counters":[]},{"line":"         , 'frontier_dependencies","counters":[]},{"line":"         , 'staged_ledger_diff","counters":[]},{"line":"         , 'protocol_versions )","counters":[]},{"line":"         t","counters":[]},{"line":"      -> State_hash.t Non_empty_list.t","counters":[]},{"line":"      -> ( 'time_received","counters":[]},{"line":"         , 'genesis_state","counters":[]},{"line":"         , 'proof","counters":[]},{"line":"         , [ `Delta_block_chain ] * State_hash.t Non_empty_list.t Truth.true_t","counters":[]},{"line":"         , 'frontier_dependencies","counters":[]},{"line":"         , 'staged_ledger_diff","counters":[]},{"line":"         , 'protocol_versions )","counters":[]},{"line":"         t =","counters":[]},{"line":"   fun validation hashes ->","counters":[]},{"line":"    match validation with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | ( time_received","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      , genesis_state","counters":[]},{"line":"      , proof","counters":[]},{"line":"      , (`Delta_block_chain, Truth.False)","counters":[]},{"line":"      , frontier_dependencies","counters":[]},{"line":"      , staged_ledger_diff","counters":[]},{"line":"      , protocol_versions ) ->","counters":[]},{"line":"        ( time_received","counters":[]},{"line":"        , genesis_state","counters":[]},{"line":"        , proof","counters":[]},{"line":"        , (`Delta_block_chain, Truth.True hashes)","counters":[]},{"line":"        , frontier_dependencies","counters":[]},{"line":"        , staged_ledger_diff","counters":[]},{"line":"        , protocol_versions )","counters":[]},{"line":"","counters":[]},{"line":"  let set_valid_frontier_dependencies :","counters":[]},{"line":"         ( 'time_received","counters":[]},{"line":"         , 'genesis_state","counters":[]},{"line":"         , 'proof","counters":[]},{"line":"         , 'delta_block_chain","counters":[]},{"line":"         , [ `Frontier_dependencies ] * unit Truth.false_t","counters":[]},{"line":"         , 'staged_ledger_diff","counters":[]},{"line":"         , 'protocol_versions )","counters":[]},{"line":"         t","counters":[]},{"line":"      -> ( 'time_received","counters":[]},{"line":"         , 'genesis_state","counters":[]},{"line":"         , 'proof","counters":[]},{"line":"         , 'delta_block_chain","counters":[]},{"line":"         , [ `Frontier_dependencies ] * unit Truth.true_t","counters":[]},{"line":"         , 'staged_ledger_diff","counters":[]},{"line":"         , 'protocol_versions )","counters":[]},{"line":"         t = function","counters":[]},{"line":"    | ( time_received","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      , genesis_state","counters":[]},{"line":"      , proof","counters":[]},{"line":"      , delta_block_chain","counters":[]},{"line":"      , (`Frontier_dependencies, Truth.False)","counters":[]},{"line":"      , staged_ledger_diff","counters":[]},{"line":"      , protocol_versions ) ->","counters":[]},{"line":"        ( time_received","counters":[]},{"line":"        , genesis_state","counters":[]},{"line":"        , proof","counters":[]},{"line":"        , delta_block_chain","counters":[]},{"line":"        , (`Frontier_dependencies, Truth.True ())","counters":[]},{"line":"        , staged_ledger_diff","counters":[]},{"line":"        , protocol_versions )","counters":[]},{"line":"","counters":[]},{"line":"  let set_valid_staged_ledger_diff :","counters":[]},{"line":"         ( 'time_received","counters":[]},{"line":"         , 'genesis_state","counters":[]},{"line":"         , 'proof","counters":[]},{"line":"         , 'delta_block_chain","counters":[]},{"line":"         , 'frontier_dependencies","counters":[]},{"line":"         , [ `Staged_ledger_diff ] * unit Truth.false_t","counters":[]},{"line":"         , 'protocol_versions )","counters":[]},{"line":"         t","counters":[]},{"line":"      -> ( 'time_received","counters":[]},{"line":"         , 'genesis_state","counters":[]},{"line":"         , 'proof","counters":[]},{"line":"         , 'delta_block_chain","counters":[]},{"line":"         , 'frontier_dependencies","counters":[]},{"line":"         , [ `Staged_ledger_diff ] * unit Truth.true_t","counters":[]},{"line":"         , 'protocol_versions )","counters":[]},{"line":"         t = function","counters":[]},{"line":"    | ( time_received","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      , genesis_state","counters":[]},{"line":"      , proof","counters":[]},{"line":"      , delta_block_chain","counters":[]},{"line":"      , frontier_dependencies","counters":[]},{"line":"      , (`Staged_ledger_diff, Truth.False)","counters":[]},{"line":"      , protocol_versions ) ->","counters":[]},{"line":"        ( time_received","counters":[]},{"line":"        , genesis_state","counters":[]},{"line":"        , proof","counters":[]},{"line":"        , delta_block_chain","counters":[]},{"line":"        , frontier_dependencies","counters":[]},{"line":"        , (`Staged_ledger_diff, Truth.True ())","counters":[]},{"line":"        , protocol_versions )","counters":[]},{"line":"","counters":[]},{"line":"  let set_valid_protocol_versions :","counters":[]},{"line":"         ( 'time_received","counters":[]},{"line":"         , 'genesis_state","counters":[]},{"line":"         , 'proof","counters":[]},{"line":"         , 'delta_block_chain","counters":[]},{"line":"         , 'frontier_dependencies","counters":[]},{"line":"         , 'staged_ledger_diff","counters":[]},{"line":"         , [ `Protocol_versions ] * unit Truth.false_t )","counters":[]},{"line":"         t","counters":[]},{"line":"      -> ( 'time_received","counters":[]},{"line":"         , 'genesis_state","counters":[]},{"line":"         , 'proof","counters":[]},{"line":"         , 'delta_block_chain","counters":[]},{"line":"         , 'frontier_dependencies","counters":[]},{"line":"         , 'staged_ledger_diff","counters":[]},{"line":"         , [ `Protocol_versions ] * unit Truth.true_t )","counters":[]},{"line":"         t = function","counters":[]},{"line":"    | ( time_received","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      , genesis_state","counters":[]},{"line":"      , proof","counters":[]},{"line":"      , delta_block_chain","counters":[]},{"line":"      , frontier_dependencies","counters":[]},{"line":"      , staged_ledger_diff","counters":[]},{"line":"      , (`Protocol_versions, Truth.False) ) ->","counters":[]},{"line":"        ( time_received","counters":[]},{"line":"        , genesis_state","counters":[]},{"line":"        , proof","counters":[]},{"line":"        , delta_block_chain","counters":[]},{"line":"        , frontier_dependencies","counters":[]},{"line":"        , staged_ledger_diff","counters":[]},{"line":"        , (`Protocol_versions, Truth.True ()) )","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let validate_time_received ~(precomputed_values : Precomputed_values.t)","counters":[]},{"line":"    ~time_received (t, validation) =","counters":[]},{"line":"  let consensus_state =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    t |> With_hash.data |> Block.header |> Header.protocol_state","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"    |> Protocol_state.consensus_state","counters":[]},{"line":"  in","counters":[]},{"line":"  let constants = precomputed_values.consensus_constants in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let received_unix_timestamp =","counters":[]},{"line":"    Block_time.to_span_since_epoch time_received |> Block_time.Span.to_ms","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"  in","counters":[]},{"line":"  match","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Consensus.Hooks.received_at_valid_time ~constants consensus_state","counters":[]},{"line":"      ~time_received:received_unix_timestamp","counters":[]},{"line":"  with","counters":[]},{"line":"  | Ok () ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Ok (t, Unsafe.set_valid_time_received validation)","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"  | Error err ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Error (`Invalid_time_received err)","counters":[]},{"line":"","counters":[]},{"line":"let skip_time_received_validation `This_block_was_not_received_via_gossip","counters":[]},{"line":"    (t, validation) =","counters":[]},{"line":"  (t, Unsafe.set_valid_time_received validation)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"let validate_genesis_protocol_state ~genesis_state_hash (t, validation) =","counters":[]},{"line":"  let state = t |> With_hash.data |> Block.header |> Header.protocol_state in","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"  if","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    State_hash.equal","counters":[]},{"line":"      (Protocol_state.genesis_state_hash state)","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"      genesis_state_hash","counters":[]},{"line":"  then Ok (t, Unsafe.set_valid_genesis_state validation)","counters":[{"col_start":7,"col_end":7,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"  else Error `Invalid_genesis_protocol_state","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"","counters":[]},{"line":"let skip_genesis_protocol_state_validation `This_block_was_generated_internally","counters":[]},{"line":"    (t, validation) =","counters":[]},{"line":"  (t, Unsafe.set_valid_genesis_state validation)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"let reset_genesis_protocol_state_validation (block_with_hash, validation) =","counters":[]},{"line":"  match validation with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | ( time_received","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    , (`Genesis_state, Truth.True ())","counters":[]},{"line":"    , proof","counters":[]},{"line":"    , delta_block_chain","counters":[]},{"line":"    , frontier_dependencies","counters":[]},{"line":"    , staged_ledger_diff","counters":[]},{"line":"    , protocol_versions ) ->","counters":[]},{"line":"      ( block_with_hash","counters":[]},{"line":"      , ( time_received","counters":[]},{"line":"        , (`Genesis_state, Truth.False)","counters":[]},{"line":"        , proof","counters":[]},{"line":"        , delta_block_chain","counters":[]},{"line":"        , frontier_dependencies","counters":[]},{"line":"        , staged_ledger_diff","counters":[]},{"line":"        , protocol_versions ) )","counters":[]},{"line":"  | _ ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      failwith \"why can't this be refuted?\"","counters":[]},{"line":"","counters":[]},{"line":"let validate_proofs ~verifier ~genesis_state_hash tvs =","counters":[]},{"line":"  let to_verify =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    List.filter_map tvs ~f:(fun (t, _validation) ->","counters":[]},{"line":"        if","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          State_hash.equal","counters":[]},{"line":"            (State_hash.With_state_hashes.state_hash t)","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"            genesis_state_hash","counters":[]},{"line":"        then","counters":[]},{"line":"          (* Don't require a valid proof for the genesis block, since the","counters":[]},{"line":"             peer may not have one.","counters":[]},{"line":"          *)","counters":[]},{"line":"          None","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        else","counters":[]},{"line":"          let header = Block.header @@ With_hash.data t in","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"          Some","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (Blockchain_snark.Blockchain.create","counters":[]},{"line":"               ~state:(Header.protocol_state header)","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"               ~proof:(Header.protocol_state_proof header) ) )","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"  in","counters":[]},{"line":"  match%map.Deferred","counters":[]},{"line":"    match to_verify with","counters":[]},{"line":"    | [] ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (* Skip calling the verifier, nothing here to verify. *)","counters":[]},{"line":"        return (Ok true)","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"    | _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Verifier.verify_blockchain_snarks verifier to_verify","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"  with","counters":[]},{"line":"  | Ok verified ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      if verified then","counters":[]},{"line":"        Ok","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (List.map tvs ~f:(fun (t, validation) ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"               (t, Unsafe.set_valid_proof validation) ) )","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"      else Error `Invalid_proof","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"  | Error e ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Error (`Verifier_error e)","counters":[]},{"line":"","counters":[]},{"line":"let validate_single_proof ~verifier ~genesis_state_hash t =","counters":[]},{"line":"  let open Deferred.Result.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%map res = validate_proofs ~verifier ~genesis_state_hash [ t ] in","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"  List.hd_exn res","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let skip_proof_validation `This_block_was_generated_internally (t, validation) =","counters":[]},{"line":"  (t, Unsafe.set_valid_proof validation)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"","counters":[]},{"line":"let extract_delta_block_chain_witness = function","counters":[]},{"line":"  | _, _, _, (`Delta_block_chain, Truth.True delta_block_chain_witness), _, _, _","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    ->","counters":[]},{"line":"      delta_block_chain_witness","counters":[]},{"line":"  | _ ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      failwith \"why can't this be refuted?\"","counters":[]},{"line":"","counters":[]},{"line":"let validate_delta_block_chain (t, validation) =","counters":[]},{"line":"  let header = t |> With_hash.data |> Block.header in","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"  match","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Transition_chain_verifier.verify","counters":[]},{"line":"      ~target_hash:","counters":[]},{"line":"        (header |> Header.protocol_state |> Protocol_state.previous_state_hash)","counters":[{"col_start":39,"col_end":39,"count":0},{"col_start":77,"col_end":77,"count":0}]},{"line":"      ~transition_chain_proof:(Header.delta_block_chain_proof header)","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"  with","counters":[]},{"line":"  | Some hashes ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Ok (t, Unsafe.set_valid_delta_block_chain validation hashes)","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"  | None ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Error `Invalid_delta_block_chain_proof","counters":[]},{"line":"","counters":[]},{"line":"let skip_delta_block_chain_validation `This_block_was_not_received_via_gossip","counters":[]},{"line":"    (t, validation) =","counters":[]},{"line":"  let previous_protocol_state_hash =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    t |> With_hash.data |> Block.header |> Header.protocol_state","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"    |> Protocol_state.previous_state_hash","counters":[]},{"line":"  in","counters":[]},{"line":"  ( t","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  , Unsafe.set_valid_delta_block_chain validation","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"      (Non_empty_list.singleton previous_protocol_state_hash) )","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"","counters":[]},{"line":"let validate_frontier_dependencies ~context:(module Context : CONTEXT)","counters":[]},{"line":"    ~root_block ~get_block_by_hash (t, validation) =","counters":[]},{"line":"  let module Context = struct","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    include Context","counters":[]},{"line":"","counters":[]},{"line":"    let logger =","counters":[]},{"line":"      Logger.extend logger","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"        [ ( \"selection_context\"","counters":[]},{"line":"          , `String \"Mina_block.Validation.validate_frontier_dependencies\" )","counters":[]},{"line":"        ]","counters":[]},{"line":"  end in","counters":[]},{"line":"  let open Result.Let_syntax in","counters":[]},{"line":"  let hash = State_hash.With_state_hashes.state_hash t in","counters":[]},{"line":"  let protocol_state = Fn.compose Header.protocol_state Block.header in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let parent_hash =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Protocol_state.previous_state_hash (protocol_state @@ With_hash.data t)","counters":[{"col_start":53,"col_end":53,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"  in","counters":[]},{"line":"  let consensus_state =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Fn.compose Protocol_state.consensus_state protocol_state","counters":[]},{"line":"  in","counters":[]},{"line":"  let%bind () =","counters":[]},{"line":"    Result.ok_if_true","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"      (hash |> get_block_by_hash |> Option.is_none)","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"      ~error:`Already_in_frontier","counters":[]},{"line":"  in","counters":[]},{"line":"  let%bind () =","counters":[]},{"line":"    (* need pervasive (=) in scope for comparing polymorphic variant *)","counters":[]},{"line":"    let ( = ) = Stdlib.( = ) in","counters":[]},{"line":"    Result.ok_if_true","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"      ( `Take","counters":[]},{"line":"      = Consensus.Hooks.select","counters":[]},{"line":"          ~context:(module Context)","counters":[]},{"line":"          ~existing:(With_hash.map ~f:consensus_state root_block)","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"          ~candidate:(With_hash.map ~f:consensus_state t) )","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"      ~error:`Not_selected_over_frontier_root","counters":[]},{"line":"  in","counters":[]},{"line":"  let%map () =","counters":[]},{"line":"    Result.ok_if_true","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"      (parent_hash |> get_block_by_hash |> Option.is_some)","counters":[{"col_start":38,"col_end":38,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"      ~error:`Parent_missing_from_frontier","counters":[]},{"line":"  in","counters":[]},{"line":"  (t, Unsafe.set_valid_frontier_dependencies validation)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"","counters":[]},{"line":"let skip_frontier_dependencies_validation","counters":[]},{"line":"    (_ :","counters":[]},{"line":"      [ `This_block_belongs_to_a_detached_subtree","counters":[]},{"line":"      | `This_block_was_loaded_from_persistence ] ) (t, validation) =","counters":[]},{"line":"  (t, Unsafe.set_valid_frontier_dependencies validation)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"","counters":[]},{"line":"let reset_frontier_dependencies_validation (transition_with_hash, validation) =","counters":[]},{"line":"  match validation with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | ( time_received","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    , genesis_state","counters":[]},{"line":"    , proof","counters":[]},{"line":"    , delta_block_chain","counters":[]},{"line":"    , (`Frontier_dependencies, Truth.True ())","counters":[]},{"line":"    , staged_ledger_diff","counters":[]},{"line":"    , protocol_versions ) ->","counters":[]},{"line":"      ( transition_with_hash","counters":[]},{"line":"      , ( time_received","counters":[]},{"line":"        , genesis_state","counters":[]},{"line":"        , proof","counters":[]},{"line":"        , delta_block_chain","counters":[]},{"line":"        , (`Frontier_dependencies, Truth.False)","counters":[]},{"line":"        , staged_ledger_diff","counters":[]},{"line":"        , protocol_versions ) )","counters":[]},{"line":"  | _ ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      failwith \"why can't this be refuted?\"","counters":[]},{"line":"","counters":[]},{"line":"let validate_staged_ledger_diff ?skip_staged_ledger_verification ~logger","counters":[]},{"line":"    ~precomputed_values ~verifier ~parent_staged_ledger ~parent_protocol_state","counters":[]},{"line":"    (t, validation) =","counters":[]},{"line":"  let target_hash_of_ledger_proof =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Fn.compose Registers.ledger","counters":[]},{"line":"    @@ Fn.compose Ledger_proof.statement_target Ledger_proof.statement","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"  in","counters":[]},{"line":"  let block = With_hash.data t in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let header = Block.header block in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let protocol_state = Header.protocol_state header in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let blockchain_state = Protocol_state.blockchain_state protocol_state in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let consensus_state = Protocol_state.consensus_state protocol_state in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let body = Block.body block in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let apply_start_time = Core.Time.now () in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let body_ref_from_header = Blockchain_state.body_reference blockchain_state in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let body_ref_computed = Staged_ledger_diff.Body.compute_reference body in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%bind.Deferred.Result () =","counters":[]},{"line":"    if Blake2.equal body_ref_computed body_ref_from_header then","counters":[]},{"line":"      Deferred.Result.return ()","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"    else Deferred.Result.fail `Invalid_body_reference","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%bind.Deferred.Result ( `Hash_after_applying staged_ledger_hash","counters":[]},{"line":"                           , `Ledger_proof proof_opt","counters":[]},{"line":"                           , `Staged_ledger transitioned_staged_ledger","counters":[]},{"line":"                           , `Pending_coinbase_update _ ) =","counters":[]},{"line":"    Staged_ledger.apply ?skip_verification:skip_staged_ledger_verification","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"      ~constraint_constants:","counters":[]},{"line":"        precomputed_values.Precomputed_values.constraint_constants ~logger","counters":[]},{"line":"      ~verifier parent_staged_ledger","counters":[]},{"line":"      (Staged_ledger_diff.Body.staged_ledger_diff body)","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"      ~current_state_view:","counters":[]},{"line":"        Mina_state.Protocol_state.(Body.view @@ body parent_protocol_state)","counters":[{"col_start":43,"col_end":43,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"      ~state_and_body_hash:","counters":[]},{"line":"        (let body_hash =","counters":[]},{"line":"           Protocol_state.(Body.hash @@ body parent_protocol_state)","counters":[{"col_start":35,"col_end":35,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"         in","counters":[]},{"line":"         ( (Protocol_state.hashes_with_body parent_protocol_state ~body_hash)","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"             .state_hash","counters":[]},{"line":"         , body_hash ) )","counters":[]},{"line":"      ~coinbase_receiver:(Consensus_state.coinbase_receiver consensus_state)","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"      ~supercharge_coinbase:","counters":[]},{"line":"        (Consensus_state.supercharge_coinbase consensus_state)","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"    |> Deferred.Result.map_error ~f:(fun e ->","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"           `Staged_ledger_application_failed e )","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"  in","counters":[]},{"line":"  [%log debug]","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":13,"col_end":13,"count":0}]},{"line":"    ~metadata:","counters":[]},{"line":"      [ ( \"time_elapsed\"","counters":[]},{"line":"        , `Float Core.Time.(Span.to_ms @@ diff (now ()) apply_start_time) )","counters":[{"col_start":37,"col_end":37,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"      ]","counters":[]},{"line":"    \"Staged_ledger.apply takes $time_elapsed\" ;","counters":[]},{"line":"  let target_ledger_hash =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    match proof_opt with","counters":[]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Option.value_map","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"          (Staged_ledger.current_ledger_proof transitioned_staged_ledger)","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"          ~f:target_hash_of_ledger_proof","counters":[]},{"line":"          ~default:","counters":[]},{"line":"            ( Precomputed_values.genesis_ledger precomputed_values","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"            |> Lazy.force |> Mina_ledger.Ledger.merkle_root","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"            |> Frozen_ledger_hash.of_ledger_hash )","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"    | Some (proof, _) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        target_hash_of_ledger_proof proof","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"  in","counters":[]},{"line":"  let maybe_errors =","counters":[]},{"line":"    Option.all","counters":[]},{"line":"      [ Option.some_if","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"          (not","counters":[]},{"line":"             (Staged_ledger_hash.equal staged_ledger_hash","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                (Blockchain_state.staged_ledger_hash blockchain_state) ) )","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"          `Incorrect_target_staged_ledger_hash","counters":[]},{"line":"      ; Option.some_if","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"          (not","counters":[]},{"line":"             (Frozen_ledger_hash.equal target_ledger_hash","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                (Blockchain_state.snarked_ledger_hash blockchain_state) ) )","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"          `Incorrect_target_snarked_ledger_hash","counters":[]},{"line":"      ]","counters":[]},{"line":"  in","counters":[]},{"line":"  Deferred.return","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    ( match maybe_errors with","counters":[]},{"line":"    | Some errors ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Error (`Invalid_staged_ledger_diff errors)","counters":[]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Ok","counters":[]},{"line":"          ( `Just_emitted_a_proof (Option.is_some proof_opt)","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"          , `Block_with_validation","counters":[]},{"line":"              (t, Unsafe.set_valid_staged_ledger_diff validation)","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"          , `Staged_ledger transitioned_staged_ledger ) )","counters":[]},{"line":"","counters":[]},{"line":"let validate_staged_ledger_hash","counters":[]},{"line":"    (`Staged_ledger_already_materialized staged_ledger_hash) (t, validation) =","counters":[]},{"line":"  let state =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    t |> With_hash.data |> Block.header |> Header.protocol_state","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"    |> Protocol_state.blockchain_state","counters":[]},{"line":"  in","counters":[]},{"line":"  if","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Staged_ledger_hash.equal staged_ledger_hash","counters":[]},{"line":"      (Blockchain_state.staged_ledger_hash state)","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"  then Ok (t, Unsafe.set_valid_staged_ledger_diff validation)","counters":[{"col_start":7,"col_end":7,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"  else Error `Staged_ledger_hash_mismatch","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"","counters":[]},{"line":"let skip_staged_ledger_diff_validation `This_block_has_a_trusted_staged_ledger","counters":[]},{"line":"    (t, validation) =","counters":[]},{"line":"  (t, Unsafe.set_valid_staged_ledger_diff validation)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"let reset_staged_ledger_diff_validation (transition_with_hash, validation) =","counters":[]},{"line":"  match validation with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | ( time_received","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    , genesis_state","counters":[]},{"line":"    , proof","counters":[]},{"line":"    , delta_block_chain","counters":[]},{"line":"    , frontier_dependencies","counters":[]},{"line":"    , (`Staged_ledger_diff, Truth.True ())","counters":[]},{"line":"    , protocol_versions ) ->","counters":[]},{"line":"      ( transition_with_hash","counters":[]},{"line":"      , ( time_received","counters":[]},{"line":"        , genesis_state","counters":[]},{"line":"        , proof","counters":[]},{"line":"        , delta_block_chain","counters":[]},{"line":"        , frontier_dependencies","counters":[]},{"line":"        , (`Staged_ledger_diff, Truth.False)","counters":[]},{"line":"        , protocol_versions ) )","counters":[]},{"line":"  | _ ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      failwith \"why can't this be refuted?\"","counters":[]},{"line":"","counters":[]},{"line":"let validate_protocol_versions (t, validation) =","counters":[]},{"line":"  let { Header.valid_current; valid_next; matches_daemon } =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    t |> With_hash.data |> Block.header |> Header.protocol_version_status","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"  in","counters":[]},{"line":"  if not (valid_current && valid_next) then Error `Invalid_protocol_version","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"  else if not matches_daemon then Error `Mismatched_protocol_version","counters":[{"col_start":7,"col_end":7,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"  else Ok (t, Unsafe.set_valid_protocol_versions validation)","counters":[{"col_start":7,"col_end":7,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"","counters":[]},{"line":"let skip_protocol_versions_validation `This_block_has_valid_protocol_versions","counters":[]},{"line":"    (t, validation) =","counters":[]},{"line":"  (t, Unsafe.set_valid_protocol_versions validation)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":51,"col_end":51,"count":2}]}]}