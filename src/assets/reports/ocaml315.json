{"filename":"src/lib/network_pool/snark_pool.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Async","counters":[]},{"line":"open Pipe_lib","counters":[]},{"line":"open Network_peer","counters":[]},{"line":"module Statement_table = Transaction_snark_work.Statement.Table","counters":[]},{"line":"","counters":[]},{"line":"module Snark_tables = struct","counters":[]},{"line":"  module Serializable = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V2 = struct","counters":[]},{"line":"        type t =","counters":[{"col_start":8,"col_end":8,"count":2},{"col_start":13,"col_end":13,"count":1}]},{"line":"          ( Ledger_proof.Stable.V2.t One_or_two.Stable.V1.t","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            Priced_proof.Stable.V1.t","counters":[]},{"line":"          * [ `Rebroadcastable of Core.Time.Stable.With_utc_sexp.V2.t","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"            | `Not_rebroadcastable ] )","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"          Transaction_snark_work.Statement.Stable.V2.Table.t","counters":[]},{"line":"        [@@deriving sexp]","counters":[{"col_start":24,"col_end":24,"count":5}]},{"line":"","counters":[]},{"line":"        let to_latest = Fn.id","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  type t =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    { all :","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":8,"col_end":8,"count":0}]},{"line":"        Ledger_proof.t One_or_two.t Priced_proof.t","counters":[]},{"line":"        Transaction_snark_work.Statement.Table.t","counters":[]},{"line":"    ; rebroadcastable :","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":20,"col_end":20,"count":0}]},{"line":"        (Ledger_proof.t One_or_two.t Priced_proof.t * Core.Time.t)","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"        Transaction_snark_work.Statement.Table.t","counters":[]},{"line":"    }","counters":[]},{"line":"  [@@deriving sexp]","counters":[]},{"line":"","counters":[]},{"line":"  let compare t1 t2 =","counters":[]},{"line":"    let p t = (Hashtbl.to_alist t.all, Hashtbl.to_alist t.rebroadcastable) in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":14,"col_end":14,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"    [%compare:","counters":[]},{"line":"      ( Transaction_snark_work.Statement.t","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":8,"col_end":8,"count":0}]},{"line":"      * Ledger_proof.t One_or_two.t Priced_proof.t )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"      list","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      * ( Transaction_snark_work.Statement.t","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        * (Ledger_proof.t One_or_two.t Priced_proof.t * Core.Time.t) )","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"        list]","counters":[]},{"line":"      (p t1) (p t2)","counters":[{"col_start":7,"col_end":7,"count":0},{"col_start":14,"col_end":14,"count":0}]},{"line":"","counters":[]},{"line":"  let of_serializable (t : Serializable.t) : t =","counters":[]},{"line":"    { all = Hashtbl.map t ~f:fst","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"    ; rebroadcastable =","counters":[]},{"line":"        Hashtbl.filter_map t ~f:(fun (x, r) ->","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"            match r with","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            | `Rebroadcastable time ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Some (x, time)","counters":[]},{"line":"            | `Not_rebroadcastable ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                None )","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let to_serializable (t : t) : Serializable.t =","counters":[]},{"line":"    let res = Hashtbl.map t.all ~f:(fun x -> (x, `Not_rebroadcastable)) in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"    Hashtbl.iteri t.rebroadcastable ~f:(fun ~key ~data:(x, r) ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        Hashtbl.set res ~key ~data:(x, `Rebroadcastable r) ) ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    res","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type S = sig","counters":[]},{"line":"  type transition_frontier","counters":[]},{"line":"","counters":[]},{"line":"  module Resource_pool : sig","counters":[]},{"line":"    include","counters":[]},{"line":"      Intf.Snark_resource_pool_intf","counters":[]},{"line":"        with type transition_frontier := transition_frontier","counters":[]},{"line":"","counters":[]},{"line":"    val remove_solved_work : t -> Transaction_snark_work.Statement.t -> unit","counters":[]},{"line":"","counters":[]},{"line":"    module Diff : Intf.Snark_pool_diff_intf with type resource_pool := t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module For_tests : sig","counters":[]},{"line":"    val get_rebroadcastable :","counters":[]},{"line":"         Resource_pool.t","counters":[]},{"line":"      -> has_timed_out:(Time.t -> [ `Timed_out | `Ok ])","counters":[]},{"line":"      -> Resource_pool.Diff.t list","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  include","counters":[]},{"line":"    Intf.Network_pool_base_intf","counters":[]},{"line":"      with type resource_pool := Resource_pool.t","counters":[]},{"line":"       and type resource_pool_diff := Resource_pool.Diff.t","counters":[]},{"line":"       and type resource_pool_diff_verified := Resource_pool.Diff.t","counters":[]},{"line":"       and type transition_frontier := transition_frontier","counters":[]},{"line":"       and type config := Resource_pool.Config.t","counters":[]},{"line":"       and type transition_frontier_diff :=","counters":[]},{"line":"        Resource_pool.transition_frontier_diff","counters":[]},{"line":"       and type rejected_diff := Resource_pool.Diff.rejected","counters":[]},{"line":"","counters":[]},{"line":"  val get_completed_work :","counters":[]},{"line":"       t","counters":[]},{"line":"    -> Transaction_snark_work.Statement.t","counters":[]},{"line":"    -> Transaction_snark_work.Checked.t option","counters":[]},{"line":"","counters":[]},{"line":"  val load :","counters":[]},{"line":"       config:Resource_pool.Config.t","counters":[]},{"line":"    -> logger:Logger.t","counters":[]},{"line":"    -> constraint_constants:Genesis_constants.Constraint_constants.t","counters":[]},{"line":"    -> consensus_constants:Consensus.Constants.t","counters":[]},{"line":"    -> time_controller:Block_time.Controller.t","counters":[]},{"line":"    -> expiry_ns:Time_ns.Span.t","counters":[]},{"line":"    -> frontier_broadcast_pipe:","counters":[]},{"line":"         transition_frontier option Broadcast_pipe.Reader.t","counters":[]},{"line":"    -> log_gossip_heard:bool","counters":[]},{"line":"    -> on_remote_push:(unit -> unit Deferred.t)","counters":[]},{"line":"    -> (t * Remote_sink.t * Local_sink.t) Deferred.t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type Transition_frontier_intf = sig","counters":[]},{"line":"  type t","counters":[]},{"line":"","counters":[]},{"line":"  type staged_ledger","counters":[]},{"line":"","counters":[]},{"line":"  module Breadcrumb : sig","counters":[]},{"line":"    type t","counters":[]},{"line":"","counters":[]},{"line":"    val staged_ledger : t -> staged_ledger","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  type best_tip_diff","counters":[]},{"line":"","counters":[]},{"line":"  val best_tip : t -> Breadcrumb.t","counters":[]},{"line":"","counters":[]},{"line":"  val best_tip_diff_pipe : t -> best_tip_diff Broadcast_pipe.Reader.t","counters":[]},{"line":"","counters":[]},{"line":"  val snark_pool_refcount_pipe :","counters":[]},{"line":"       t","counters":[]},{"line":"    -> Transition_frontier.Extensions.Snark_pool_refcount.view","counters":[]},{"line":"       Pipe_lib.Broadcast_pipe.Reader.t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make","counters":[]},{"line":"    (Base_ledger : Intf.Base_ledger_intf) (Staged_ledger : sig","counters":[]},{"line":"      type t","counters":[]},{"line":"","counters":[]},{"line":"      val ledger : t -> Base_ledger.t","counters":[]},{"line":"    end)","counters":[]},{"line":"    (Transition_frontier : Transition_frontier_intf","counters":[]},{"line":"                             with type staged_ledger := Staged_ledger.t) =","counters":[]},{"line":"struct","counters":[]},{"line":"  module Resource_pool = struct","counters":[]},{"line":"    module T = struct","counters":[]},{"line":"      let label = \"snark_pool\"","counters":[]},{"line":"","counters":[]},{"line":"      module Config = struct","counters":[]},{"line":"        type t =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          { trust_system : (Trust_system.t[@sexp.opaque])","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"          ; verifier : (Verifier.t[@sexp.opaque])","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"          ; disk_location : string","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"          }","counters":[]},{"line":"        [@@deriving sexp, make]","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      type transition_frontier_diff =","counters":[]},{"line":"        [ `New_refcount_table of Extensions.Snark_pool_refcount.view","counters":[]},{"line":"        | `New_best_tip of Base_ledger.t ]","counters":[]},{"line":"","counters":[]},{"line":"      type t =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { snark_tables : Snark_tables.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"        ; snark_table_lock : (unit Throttle.Sequencer.t[@sexp.opaque])","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"        ; best_tip_ledger : (unit -> Base_ledger.t option[@sexp.opaque])","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"        ; mutable ref_table : int Statement_table.t option","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"              (** Tracks the number of blocks that have each work statement in","counters":[]},{"line":"                  their scan state.","counters":[]},{"line":"                  Work is included iff it is a member of some block scan state.","counters":[]},{"line":"                  Used to filter the pool, ensuring that only work referenced","counters":[]},{"line":"                  within the frontier is kept.","counters":[]},{"line":"              *)","counters":[]},{"line":"        ; mutable best_tip_table :","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"            Transaction_snark_work.Statement.Hash_set.t option","counters":[]},{"line":"              (** The set of all snark work statements present in the scan","counters":[]},{"line":"                  state for the last 10 blocks in the best chain.","counters":[]},{"line":"                  Used to filter broadcasts of locally produced work, so that","counters":[]},{"line":"                  irrelevant work is not broadcast.","counters":[]},{"line":"              *)","counters":[]},{"line":"        ; config : Config.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"        ; logger : (Logger.t[@sexp.opaque])","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"        ; mutable removed_counter : int","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"              (** A counter for transition frontier breadcrumbs removed. When","counters":[]},{"line":"                  this reaches a certain value, unreferenced snark work is","counters":[]},{"line":"                  removed from ref_table","counters":[]},{"line":"              *)","counters":[]},{"line":"        ; account_creation_fee : Currency.Fee.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"        ; batcher : Batcher.Snark_pool.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":16,"col_end":16,"count":0}]},{"line":"        }","counters":[]},{"line":"      [@@deriving sexp]","counters":[]},{"line":"","counters":[]},{"line":"      type serializable = Snark_tables.Serializable.Stable.Latest.t","counters":[{"col_start":6,"col_end":6,"count":1},{"col_start":22,"col_end":22,"count":1}]},{"line":"      [@@deriving bin_io_unversioned]","counters":[{"col_start":36,"col_end":36,"count":4}]},{"line":"","counters":[]},{"line":"      let make_config = Config.make","counters":[]},{"line":"","counters":[]},{"line":"      let removed_breadcrumb_wait = 10","counters":[]},{"line":"","counters":[]},{"line":"      let get_best_tip_ledger ~frontier_broadcast_pipe () =","counters":[]},{"line":"        Option.map (Broadcast_pipe.Reader.peek frontier_broadcast_pipe)","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"          ~f:(fun tf ->","counters":[]},{"line":"            Transition_frontier.best_tip tf","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"            |> Transition_frontier.Breadcrumb.staged_ledger","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"            |> Staged_ledger.ledger )","counters":[]},{"line":"","counters":[]},{"line":"      let of_serializable tables ~constraint_constants ~frontier_broadcast_pipe","counters":[]},{"line":"          ~config ~logger : t =","counters":[]},{"line":"        { snark_tables = Snark_tables.of_serializable tables","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"        ; snark_table_lock = Throttle.Sequencer.create ()","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"        ; best_tip_ledger = get_best_tip_ledger ~frontier_broadcast_pipe","counters":[]},{"line":"        ; batcher = Batcher.Snark_pool.create config.verifier","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"        ; account_creation_fee =","counters":[]},{"line":"            constraint_constants","counters":[]},{"line":"              .Genesis_constants.Constraint_constants.account_creation_fee","counters":[]},{"line":"        ; ref_table = None","counters":[]},{"line":"        ; best_tip_table = None","counters":[]},{"line":"        ; config","counters":[]},{"line":"        ; logger","counters":[]},{"line":"        ; removed_counter = removed_breadcrumb_wait","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"      let snark_pool_json t : Yojson.Safe.t =","counters":[]},{"line":"        `List","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (Statement_table.fold ~init:[] t.snark_tables.all","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"             ~f:(fun ~key ~data:{ proof = _; fee = { fee; prover } } acc ->","counters":[]},{"line":"               let work_ids =","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                 Transaction_snark_work.Statement.compact_json key","counters":[]},{"line":"               in","counters":[]},{"line":"               `Assoc","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                 [ (\"work_ids\", work_ids)","counters":[]},{"line":"                 ; (\"fee\", Currency.Fee.Stable.V1.to_yojson fee)","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"                 ; ( \"prover\"","counters":[]},{"line":"                   , Signature_lib.Public_key.Compressed.Stable.V1.to_yojson","counters":[{"col_start":75,"col_end":75,"count":0}]},{"line":"                       prover )","counters":[]},{"line":"                 ]","counters":[]},{"line":"               :: acc ) )","counters":[]},{"line":"","counters":[]},{"line":"      let all_completed_work (t : t) : Transaction_snark_work.Info.t list =","counters":[]},{"line":"        Statement_table.fold ~init:[] t.snark_tables.all","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ~f:(fun ~key ~data:{ proof = _; fee = { fee; prover } } acc ->","counters":[]},{"line":"            let work_ids = Transaction_snark_work.Statement.work_ids key in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            { Transaction_snark_work.Info.statements = key","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            ; work_ids","counters":[]},{"line":"            ; fee","counters":[]},{"line":"            ; prover","counters":[]},{"line":"            }","counters":[]},{"line":"            :: acc )","counters":[]},{"line":"","counters":[]},{"line":"      (** false when there is no active transition_frontier or","counters":[]},{"line":"          when the refcount for the given work is 0 *)","counters":[]},{"line":"      let work_is_referenced t work =","counters":[]},{"line":"        match t.ref_table with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            false","counters":[]},{"line":"        | Some ref_table -> (","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            match Statement_table.find ref_table work with","counters":[]},{"line":"            | None ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                false","counters":[]},{"line":"            | Some _ ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                true )","counters":[]},{"line":"","counters":[]},{"line":"      let fee_is_sufficient t ~fee ~account_exists =","counters":[]},{"line":"        Currency.Fee.(fee >= t.account_creation_fee) || account_exists","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":51,"col_end":51,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"","counters":[]},{"line":"      let handle_new_best_tip_ledger t ledger =","counters":[]},{"line":"        let open Mina_base in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let open Signature_lib in","counters":[]},{"line":"        Throttle.enqueue t.snark_table_lock (fun () ->","counters":[]},{"line":"            let%map _ =","counters":[]},{"line":"              let open Interruptible.Deferred_let_syntax in","counters":[]},{"line":"              Interruptible.force","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                (let%bind.Interruptible () =","counters":[]},{"line":"                   Interruptible.lift (Deferred.return ())","counters":[{"col_start":36,"col_end":36,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"                     (Base_ledger.detached_signal ledger)","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"                 in","counters":[]},{"line":"                 let%bind prover_account_ids =","counters":[]},{"line":"                   let account_ids =","counters":[]},{"line":"                     t.snark_tables.all |> Statement_table.data","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"                     |> List.map","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                          ~f:(fun { Priced_proof.fee = { prover; _ }; _ } ->","counters":[]},{"line":"                            prover )","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                     |> List.dedup_and_sort","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"                          ~compare:Public_key.Compressed.compare","counters":[]},{"line":"                     |> List.map ~f:(fun prover ->","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                            (prover, Account_id.create prover Token_id.default) )","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"                     |> Public_key.Compressed.Map.of_alist_exn","counters":[]},{"line":"                   in","counters":[]},{"line":"                   Deferred.map (Scheduler.yield ()) ~f:(Fn.const account_ids)","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":47,"col_end":47,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"                 in","counters":[]},{"line":"                 (* if this is still starving the scheduler, we can make `location_of_account_batch` yield while it traverses the masks *)","counters":[]},{"line":"                 let%bind prover_account_locations =","counters":[]},{"line":"                   let account_locations =","counters":[]},{"line":"                     prover_account_ids |> Map.data","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                     |> Base_ledger.location_of_account_batch ledger","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"                     |> Account_id.Map.of_alist_exn","counters":[]},{"line":"                   in","counters":[]},{"line":"                   Deferred.map (Scheduler.yield ())","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"                     ~f:(Fn.const account_locations)","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                 in","counters":[]},{"line":"                 let yield = Staged.unstage (Scheduler.yield_every ~n:50) in","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                 let%map () =","counters":[]},{"line":"                   let open Deferred.Let_syntax in","counters":[]},{"line":"                   Statement_table.fold ~init:Deferred.unit t.snark_tables.all","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"                     ~f:(fun ~key ~data:{ fee = { fee; prover }; _ } acc ->","counters":[]},{"line":"                       let%bind () = acc in","counters":[]},{"line":"                       let%map () = yield () in","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"                       let prover_account_exists =","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                         prover","counters":[]},{"line":"                         |> Map.find_exn prover_account_ids","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"                         |> Map.find_exn prover_account_locations","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"                         |> Option.is_some","counters":[]},{"line":"                       in","counters":[]},{"line":"                       let keep =","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                         fee_is_sufficient t ~fee","counters":[]},{"line":"                           ~account_exists:prover_account_exists","counters":[]},{"line":"                       in","counters":[]},{"line":"                       if not keep then (","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"                         Hashtbl.remove t.snark_tables.all key ;","counters":[]},{"line":"                         Hashtbl.remove t.snark_tables.rebroadcastable key ) )","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                 in","counters":[]},{"line":"                 () )","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"            in","counters":[]},{"line":"            () )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"","counters":[]},{"line":"      let handle_new_refcount_table t","counters":[]},{"line":"          ({ removed; refcount_table; best_tip_table } :","counters":[]},{"line":"            Extensions.Snark_pool_refcount.view ) =","counters":[]},{"line":"        t.ref_table <- Some refcount_table ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        t.best_tip_table <- Some best_tip_table ;","counters":[]},{"line":"        t.removed_counter <- t.removed_counter + removed ;","counters":[]},{"line":"        if t.removed_counter >= removed_breadcrumb_wait then (","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"          t.removed_counter <- 0 ;","counters":[]},{"line":"          Statement_table.filter_keys_inplace t.snark_tables.all ~f:(fun k ->","counters":[]},{"line":"              let keep = work_is_referenced t k in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              if not keep then Hashtbl.remove t.snark_tables.rebroadcastable k ;","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"              keep ) ;","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"          Mina_metrics.(","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Gauge.set Snark_work.snark_pool_size","counters":[]},{"line":"              (Float.of_int @@ Hashtbl.length t.snark_tables.all)) )","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"      let handle_transition_frontier_diff u t =","counters":[]},{"line":"        match u with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | `New_best_tip ledger ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            O1trace.thread \"apply_new_best_tip_ledger_to_snark_pool\" (fun () ->","counters":[]},{"line":"                handle_new_best_tip_ledger t ledger )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"        | `New_refcount_table refcount_table ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            O1trace.sync_thread \"apply_refcount_table_to_snark_pool\" (fun () ->","counters":[]},{"line":"                handle_new_refcount_table t refcount_table ) ;","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"            Deferred.unit","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"","counters":[]},{"line":"      (*TODO? add referenced statements from the transition frontier to ref_table here otherwise the work referenced in the root and not in any of the successor blocks will never be included. This may not be required because the chances of a new block from the root is very low (root's existing successor is 1 block away from finality)*)","counters":[]},{"line":"      let listen_to_frontier_broadcast_pipe frontier_broadcast_pipe (t : t)","counters":[]},{"line":"          ~tf_diff_writer =","counters":[]},{"line":"        (* start with empty ref table *)","counters":[]},{"line":"        t.ref_table <- None ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        t.best_tip_table <- None ;","counters":[]},{"line":"        let tf_deferred =","counters":[]},{"line":"          Broadcast_pipe.Reader.iter frontier_broadcast_pipe ~f:(function","counters":[]},{"line":"            | Some tf ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (* Start the count at the max so we flush after reconstructing","counters":[]},{"line":"                   the transition_frontier *)","counters":[]},{"line":"                t.removed_counter <- removed_breadcrumb_wait ;","counters":[]},{"line":"                Broadcast_pipe.Reader.iter","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"                  (Transition_frontier.snark_pool_refcount_pipe tf) ~f:(fun x ->","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"                    Strict_pipe.Writer.write tf_diff_writer","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      (`New_refcount_table x) )","counters":[]},{"line":"                |> Deferred.don't_wait_for ;","counters":[]},{"line":"                Broadcast_pipe.Reader.iter","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"                  (Transition_frontier.best_tip_diff_pipe tf) ~f:(fun _ ->","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"                    Strict_pipe.Writer.write tf_diff_writer","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      (`New_best_tip","counters":[]},{"line":"                        ( Transition_frontier.best_tip tf","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"                        |> Transition_frontier.Breadcrumb.staged_ledger","counters":[{"col_start":70,"col_end":70,"count":0}]},{"line":"                        |> Staged_ledger.ledger ) ) )","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"                |> Deferred.don't_wait_for ;","counters":[]},{"line":"                return ()","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"            | None ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                t.ref_table <- None ;","counters":[]},{"line":"                t.best_tip_table <- None ;","counters":[]},{"line":"                return () )","counters":[]},{"line":"        in","counters":[]},{"line":"        Deferred.don't_wait_for tf_deferred","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      let create ~constraint_constants ~consensus_constants:_ ~time_controller:_","counters":[]},{"line":"          ~expiry_ns:_ ~frontier_broadcast_pipe ~config ~logger ~tf_diff_writer","counters":[]},{"line":"          =","counters":[]},{"line":"        let t =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          { snark_tables =","counters":[]},{"line":"              { all = Statement_table.create ()","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"              ; rebroadcastable = Statement_table.create ()","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"              }","counters":[]},{"line":"          ; snark_table_lock = Throttle.Sequencer.create ()","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"          ; best_tip_ledger = get_best_tip_ledger ~frontier_broadcast_pipe","counters":[]},{"line":"          ; batcher = Batcher.Snark_pool.create config.verifier","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"          ; logger","counters":[]},{"line":"          ; config","counters":[]},{"line":"          ; ref_table = None","counters":[]},{"line":"          ; best_tip_table = None","counters":[]},{"line":"          ; account_creation_fee =","counters":[]},{"line":"              constraint_constants","counters":[]},{"line":"                .Genesis_constants.Constraint_constants.account_creation_fee","counters":[]},{"line":"          ; removed_counter = removed_breadcrumb_wait","counters":[]},{"line":"          }","counters":[]},{"line":"        in","counters":[]},{"line":"        listen_to_frontier_broadcast_pipe frontier_broadcast_pipe t","counters":[]},{"line":"          ~tf_diff_writer ;","counters":[]},{"line":"        t","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      let get_logger t = t.logger","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"      let request_proof t = Statement_table.find t.snark_tables.all","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"","counters":[]},{"line":"      let add_snark ?(is_local = false) t ~work","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"          ~(proof : Ledger_proof.t One_or_two.t) ~fee =","counters":[]},{"line":"        Throttle.enqueue t.snark_table_lock (fun () ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            Deferred.return","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              ( if work_is_referenced t work then (","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                (*Note: fee against existing proofs and the new proofs are checked in","counters":[]},{"line":"                  Diff.unsafe_apply which calls this function*)","counters":[]},{"line":"                Hashtbl.set t.snark_tables.all ~key:work ~data:{ proof; fee } ;","counters":[]},{"line":"                if is_local then","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Hashtbl.set t.snark_tables.rebroadcastable ~key:work","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"                    ~data:({ proof; fee }, Time.now ())","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                else","counters":[]},{"line":"                  (* Stop rebroadcasting locally generated snarks if they are","counters":[]},{"line":"                     overwritten. No-op if there is no rebroadcastable SNARK with that","counters":[]},{"line":"                     statement. *)","counters":[]},{"line":"                  Hashtbl.remove t.snark_tables.rebroadcastable work ;","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"                (*when snark work is added to the pool*)","counters":[]},{"line":"                Mina_metrics.(","counters":[]},{"line":"                  Gauge.set Snark_work.useful_snark_work_received_time_sec","counters":[]},{"line":"                    Time.(","counters":[]},{"line":"                      let x = now () |> to_span_since_epoch |> Span.to_sec in","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"                      x -. Mina_metrics.time_offset_sec) ;","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                  Gauge.set Snark_work.snark_pool_size","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    (Float.of_int @@ Hashtbl.length t.snark_tables.all) ;","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"                  Snark_work.Snark_fee_histogram.observe Snark_work.snark_fee","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"                    ( fee.Mina_base.Fee_with_prover.fee |> Currency.Fee.to_int","counters":[{"col_start":77,"col_end":77,"count":0}]},{"line":"                    |> Float.of_int )) ;","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"                `Added )","counters":[]},{"line":"              else","counters":[]},{"line":"                let origin =","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  if is_local then \"locally generated\" else \"gossiped\"","counters":[{"col_start":35,"col_end":35,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"                in","counters":[]},{"line":"                [%log' warn t.logger]","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"                  \"Rejecting %s snark work $stmt, statement not referenced\"","counters":[]},{"line":"                  origin","counters":[]},{"line":"                  ~metadata:","counters":[]},{"line":"                    [ ( \"stmt\"","counters":[]},{"line":"                      , One_or_two.to_yojson","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"                          Transaction_snark.Statement.to_yojson work )","counters":[]},{"line":"                    ] ;","counters":[]},{"line":"                `Statement_not_referenced ) )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"","counters":[]},{"line":"      let verify_and_act t ~work ~sender =","counters":[]},{"line":"        let statements, priced_proof = work in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let { Priced_proof.proof = proofs; fee = { prover; fee } } =","counters":[]},{"line":"          priced_proof","counters":[]},{"line":"        in","counters":[]},{"line":"        let trust_record =","counters":[]},{"line":"          Trust_system.record_envelope_sender t.config.trust_system t.logger","counters":[]},{"line":"            sender","counters":[]},{"line":"        in","counters":[]},{"line":"        let is_local = Envelope.Sender.(equal Local sender) in","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"        let metadata =","counters":[]},{"line":"          [ (\"prover\", Signature_lib.Public_key.Compressed.to_yojson prover)","counters":[{"col_start":67,"col_end":67,"count":0}]},{"line":"          ; (\"fee\", Currency.Fee.to_yojson fee)","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"          ; (\"sender\", Envelope.Sender.to_yojson sender)","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"          ]","counters":[]},{"line":"        in","counters":[]},{"line":"        let log_and_punish ?(punish = true) statement e =","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"          let metadata =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            [ (\"error\", Error_json.error_to_yojson e)","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"            ; (\"work_id\", `Int (Transaction_snark.Statement.hash statement))","counters":[{"col_start":63,"col_end":63,"count":0}]},{"line":"            ]","counters":[]},{"line":"            @ metadata","counters":[]},{"line":"          in","counters":[]},{"line":"          [%log' error t.logger] ~metadata","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"            \"Error verifying transaction snark from $sender: $error\" ;","counters":[]},{"line":"          if punish && not is_local then","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"            trust_record","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              ( Trust_system.Actions.Sent_invalid_proof","counters":[]},{"line":"              , Some (\"Error verifying transaction snark: $error\", metadata) )","counters":[]},{"line":"          else Deferred.return ()","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"        in","counters":[]},{"line":"        let message = Mina_base.Sok_message.create ~fee ~prover in","counters":[]},{"line":"        let verify proofs =","counters":[]},{"line":"          let open Deferred.Let_syntax in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let%bind statement_check =","counters":[]},{"line":"            One_or_two.Deferred_result.map proofs ~f:(fun (p, s) ->","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"                let proof_statement = Ledger_proof.statement p in","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                if Transaction_snark.Statement.( = ) proof_statement s then","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Deferred.Or_error.ok_unit","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                else","counters":[]},{"line":"                  let e = Error.of_string \"Statement and proof do not match\" in","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  if is_local then","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    [%log' debug t.logger] ~metadata","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"                      !\"Statement and proof mismatch. Proof statement: \\","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                        %{sexp:Transaction_snark.Statement.t} Statement \\","counters":[]},{"line":"                        %{sexp: Transaction_snark.Statement.t}\"","counters":[]},{"line":"                      proof_statement s ;","counters":[]},{"line":"                  let%map () = log_and_punish s e in","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"                  Error e )","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"          in","counters":[]},{"line":"          let work = One_or_two.map proofs ~f:snd in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let account_opt =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let open Mina_base in","counters":[]},{"line":"            let open Option.Let_syntax in","counters":[]},{"line":"            let%bind ledger = t.best_tip_ledger () in","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"            (* if Deferred.is_determined (Base_ledger.detached_signal ledger) then","counters":[]},{"line":"             *   None","counters":[]},{"line":"             * else *)","counters":[]},{"line":"            let%bind loc =","counters":[]},{"line":"              Account_id.create prover Token_id.default","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"              |> Base_ledger.location_of_account ledger","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"            in","counters":[]},{"line":"            Base_ledger.get ledger loc","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          in","counters":[]},{"line":"          let prover_account_exists = Option.is_some account_opt in","counters":[]},{"line":"          let prover_permitted_to_receive =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let open Option.Let_syntax in","counters":[]},{"line":"            let%map account = account_opt in","counters":[]},{"line":"            Mina_base.Account.has_permission ~to_:`Receive account","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          in","counters":[]},{"line":"          if","counters":[]},{"line":"            not (fee_is_sufficient t ~fee ~account_exists:prover_account_exists)","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"          then (","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"            [%log' debug t.logger]","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"              \"Snark work did not have sufficient fee to create prover $prover \\","counters":[]},{"line":"               acccount\"","counters":[]},{"line":"              ~metadata ;","counters":[]},{"line":"            return false )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          else if","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"            Option.value_map ~default:false ~f:not prover_permitted_to_receive","counters":[]},{"line":"          then (","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"            [%log' warn t.logger]","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"              \"Snark work prover $prover not permitted to receive fees. \\","counters":[]},{"line":"               Required permission to receive is $receive_permission\"","counters":[]},{"line":"              ~metadata:","counters":[]},{"line":"                ( ( \"receive_permission\"","counters":[]},{"line":"                  , Mina_base.Permissions.Auth_required.to_yojson","counters":[{"col_start":64,"col_end":64,"count":0}]},{"line":"                      (Option.value_map account_opt","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"                         ~default:Mina_base.Permissions.user_default","counters":[]},{"line":"                         ~f:(fun (a : Mina_base.Account.t) -> a.permissions) )","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"                        .receive )","counters":[]},{"line":"                :: metadata ) ;","counters":[]},{"line":"            return false )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          else if not (work_is_referenced t work) then (","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"            [%log' debug t.logger] \"Work $stmt not referenced\"","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"              ~metadata:","counters":[]},{"line":"                ( ( \"stmt\"","counters":[]},{"line":"                  , One_or_two.to_yojson Transaction_snark.Statement.to_yojson","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"                      work )","counters":[]},{"line":"                :: metadata ) ;","counters":[]},{"line":"            return false )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          else","counters":[]},{"line":"            match statement_check with","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            | Error _ ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                return false","counters":[]},{"line":"            | Ok _ -> (","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                let log ?punish e =","counters":[]},{"line":"                  Deferred.List.iter (One_or_two.to_list proofs)","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"                    ~f:(fun (_, s) -> log_and_punish ?punish s e)","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"                in","counters":[]},{"line":"                let proof_env =","counters":[]},{"line":"                  Envelope.Incoming.wrap","counters":[]},{"line":"                    ~data:(One_or_two.map proofs ~f:fst, message)","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"                    ~sender","counters":[]},{"line":"                in","counters":[]},{"line":"                match Signature_lib.Public_key.decompress prover with","counters":[]},{"line":"                | None ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    (* We may need to decompress the key when paying the fee","counters":[]},{"line":"                       transfer, so check that we can do it now.","counters":[]},{"line":"                    *)","counters":[]},{"line":"                    [%log' error t.logger]","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"                      \"Proof had an invalid key: $public_key\"","counters":[]},{"line":"                      ~metadata:","counters":[]},{"line":"                        [ ( \"public_key\"","counters":[]},{"line":"                          , Signature_lib.Public_key.Compressed.to_yojson prover","counters":[{"col_start":72,"col_end":72,"count":0}]},{"line":"                          )","counters":[]},{"line":"                        ] ;","counters":[]},{"line":"                    Deferred.return false","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                | Some _ -> (","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    match%bind","counters":[]},{"line":"                      Batcher.Snark_pool.verify t.batcher proof_env","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"                    with","counters":[]},{"line":"                    | Ok true ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        return true","counters":[]},{"line":"                    | Ok false ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        (* if this proof is in the set of invalid proofs*)","counters":[]},{"line":"                        let e = Error.of_string \"Invalid proof\" in","counters":[]},{"line":"                        let%map () = log e in","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"                        false","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                    | Error e ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        (* Verifier crashed or other errors at our end. Don't punish the peer*)","counters":[]},{"line":"                        let%map () = log ~punish:false e in","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"                        false ) )","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"        in","counters":[]},{"line":"        match One_or_two.zip proofs statements with","counters":[]},{"line":"        | Ok pairs ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            verify pairs","counters":[]},{"line":"        | Error e ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            [%log' error t.logger]","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"              ~metadata:","counters":[]},{"line":"                ( [ (\"error\", Error_json.error_to_yojson e)","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"                  ; ( \"work_ids\"","counters":[]},{"line":"                    , Transaction_snark_work.Statement.compact_json statements","counters":[{"col_start":66,"col_end":66,"count":0}]},{"line":"                    )","counters":[]},{"line":"                  ]","counters":[]},{"line":"                @ metadata )","counters":[]},{"line":"              \"One_or_two length mismatch: $error\" ;","counters":[]},{"line":"            Deferred.return false","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    include T","counters":[]},{"line":"    module Diff = Snark_pool_diff.Make (Transition_frontier) (T)","counters":[]},{"line":"","counters":[]},{"line":"    (** Returns locally-generated snark work for re-broadcast.","counters":[]},{"line":"        This is limited to recent work which is yet to appear in a block.","counters":[]},{"line":"    *)","counters":[]},{"line":"    let get_rebroadcastable t ~has_timed_out:_ =","counters":[]},{"line":"      let in_best_tip_table =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        match t.best_tip_table with","counters":[]},{"line":"        | Some best_tip_table ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Hash_set.mem best_tip_table","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Fn.const false","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"      in","counters":[]},{"line":"      Hashtbl.to_alist t.snark_tables.rebroadcastable","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"      |> List.filter_map ~f:(fun (stmt, (snark, _time)) ->","counters":[]},{"line":"             if in_best_tip_table stmt then","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"               Some (Diff.Add_solved_work (stmt, snark))","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"             else None )","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"","counters":[]},{"line":"    let remove_solved_work t work =","counters":[]},{"line":"      Statement_table.remove t.snark_tables.all work ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Statement_table.remove t.snark_tables.rebroadcastable work","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  include Network_pool_base.Make (Transition_frontier) (Resource_pool)","counters":[]},{"line":"","counters":[]},{"line":"  module For_tests = struct","counters":[]},{"line":"    let get_rebroadcastable = Resource_pool.get_rebroadcastable","counters":[]},{"line":"","counters":[]},{"line":"    let snark_tables (t : Resource_pool.t) = t.snark_tables","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let get_completed_work t statement =","counters":[]},{"line":"    Option.map","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (Resource_pool.request_proof (resource_pool t) statement)","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"      ~f:(fun Priced_proof.{ proof; fee = { fee; prover } } ->","counters":[]},{"line":"        Transaction_snark_work.Checked.create_unsafe","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          { Transaction_snark_work.fee; proofs = proof; prover } )","counters":[]},{"line":"","counters":[]},{"line":"  (* This causes a snark pool to never be GC'd. This is fine as it should live as long as the daemon lives. *)","counters":[]},{"line":"  let store_periodically (t : Resource_pool.t) =","counters":[]},{"line":"    Clock.every' (Time.Span.of_min 3.) (fun () ->","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"        let before = Time.now () in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let%map () =","counters":[]},{"line":"          Writer.save_bin_prot t.config.disk_location","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"            Snark_tables.Serializable.Stable.Latest.bin_writer_t","counters":[]},{"line":"            (Snark_tables.to_serializable t.snark_tables)","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"        in","counters":[]},{"line":"        let elapsed = Time.(diff (now ()) before |> Span.to_ms) in","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"        Mina_metrics.(","counters":[]},{"line":"          Snark_work.Snark_pool_serialization_ms_histogram.observe","counters":[{"col_start":65,"col_end":65,"count":0}]},{"line":"            Snark_work.snark_pool_serialization_ms elapsed) ;","counters":[]},{"line":"        [%log' debug t.logger] \"SNARK pool serialization took $time ms\"","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"          ~metadata:[ (\"time\", `Float elapsed) ] )","counters":[]},{"line":"","counters":[]},{"line":"  let loaded = ref false","counters":[]},{"line":"","counters":[]},{"line":"  let load ~config ~logger ~constraint_constants ~consensus_constants","counters":[]},{"line":"      ~time_controller ~expiry_ns ~frontier_broadcast_pipe ~log_gossip_heard","counters":[]},{"line":"      ~on_remote_push =","counters":[]},{"line":"    if !loaded then","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      failwith","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        \"Snark_pool.load should only be called once. It has been called twice.\" ;","counters":[]},{"line":"    loaded := true ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let tf_diff_reader, tf_diff_writer =","counters":[]},{"line":"      Strict_pipe.(","counters":[]},{"line":"        create ~name:\"Snark pool Transition frontier diffs\" Synchronous)","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"    in","counters":[]},{"line":"    let%map pool, r_sink, l_sink =","counters":[]},{"line":"      match%map","counters":[]},{"line":"        Async.Reader.load_bin_prot config.Resource_pool.Config.disk_location","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"          Snark_tables.Serializable.Stable.Latest.bin_reader_t","counters":[]},{"line":"      with","counters":[]},{"line":"      | Ok snark_table ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let pool =","counters":[]},{"line":"            Resource_pool.of_serializable snark_table ~constraint_constants","counters":[]},{"line":"              ~config ~logger ~frontier_broadcast_pipe","counters":[]},{"line":"          in","counters":[]},{"line":"          let res =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            of_resource_pool_and_diffs pool ~logger ~constraint_constants","counters":[]},{"line":"              ~tf_diffs:tf_diff_reader ~log_gossip_heard ~on_remote_push","counters":[]},{"line":"          in","counters":[]},{"line":"          Resource_pool.listen_to_frontier_broadcast_pipe","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            frontier_broadcast_pipe pool ~tf_diff_writer ;","counters":[]},{"line":"          res","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"      | Error _e ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          create ~config ~logger ~constraint_constants ~consensus_constants","counters":[]},{"line":"            ~time_controller ~expiry_ns ~frontier_broadcast_pipe","counters":[]},{"line":"            ~log_gossip_heard ~on_remote_push","counters":[]},{"line":"    in","counters":[]},{"line":"    store_periodically (resource_pool pool) ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"    (pool, r_sink, l_sink)","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(* TODO: defunctor or remove monkey patching (#3731) *)","counters":[]},{"line":"include","counters":[]},{"line":"  Make (Mina_ledger.Ledger) (Staged_ledger)","counters":[]},{"line":"    (struct","counters":[]},{"line":"      include Transition_frontier","counters":[]},{"line":"","counters":[]},{"line":"      type best_tip_diff = Extensions.Best_tip_diff.view","counters":[]},{"line":"","counters":[]},{"line":"      let best_tip_diff_pipe t =","counters":[]},{"line":"        Extensions.(get_view_pipe (extensions t) Best_tip_diff)","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"      let snark_pool_refcount_pipe t =","counters":[]},{"line":"        Extensions.(get_view_pipe (extensions t) Snark_pool_refcount)","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"    end)","counters":[]},{"line":"","counters":[]},{"line":"module Diff_versioned = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    [@@@no_toplevel_latest_type]","counters":[]},{"line":"","counters":[]},{"line":"    module V2 = struct","counters":[]},{"line":"      type t = Resource_pool.Diff.t =","counters":[{"col_start":6,"col_end":6,"count":2},{"col_start":11,"col_end":11,"count":2}]},{"line":"        | Add_solved_work of","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            Transaction_snark_work.Statement.Stable.V2.t","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"            * Ledger_proof.Stable.V2.t One_or_two.Stable.V1.t","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"              Priced_proof.Stable.V1.t","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"        | Empty","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      [@@deriving compare, sexp, to_yojson, hash]","counters":[{"col_start":48,"col_end":48,"count":5}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  type t = Stable.Latest.t =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    | Add_solved_work of","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        Transaction_snark_work.Statement.t","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"        * Ledger_proof.t One_or_two.t Priced_proof.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"    | Empty","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  [@@deriving compare, sexp, to_yojson, hash]","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(* Only show stdout for failed inline tests. *)","counters":[]},{"line":"open Inline_test_quiet_logs","counters":[]},{"line":"","counters":[]},{"line":"let%test_module \"random set test\" =","counters":[]},{"line":"  ( module struct","counters":[]},{"line":"    open Mina_base","counters":[]},{"line":"","counters":[]},{"line":"    let trust_system = Mocks.trust_system","counters":[]},{"line":"","counters":[]},{"line":"    let precomputed_values = Lazy.force Precomputed_values.for_unit_tests","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"","counters":[]},{"line":"    (* SNARK work is rejected if the prover doesn't have an account and the fee","counters":[]},{"line":"       is below the account creation fee. So, just to make generating valid SNARK","counters":[]},{"line":"       work easier for testing, we set the account creation fee to 0. *)","counters":[]},{"line":"    let constraint_constants =","counters":[]},{"line":"      { precomputed_values.constraint_constants with","counters":[]},{"line":"        account_creation_fee = Currency.Fee.zero","counters":[]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    let consensus_constants = precomputed_values.consensus_constants","counters":[]},{"line":"","counters":[]},{"line":"    let proof_level = precomputed_values.proof_level","counters":[]},{"line":"","counters":[]},{"line":"    let logger = Logger.null ()","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"","counters":[]},{"line":"    let time_controller = Block_time.Controller.basic ~logger","counters":[]},{"line":"","counters":[]},{"line":"    let expiry_ns =","counters":[]},{"line":"      Time_ns.Span.of_hr","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"        (Float.of_int precomputed_values.genesis_constants.transaction_expiry_hr)","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"","counters":[]},{"line":"    let verifier =","counters":[]},{"line":"      Async.Thread_safe.block_on_async_exn (fun () ->","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"          Verifier.create ~logger ~proof_level ~constraint_constants","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ~conf_dir:None","counters":[]},{"line":"            ~pids:(Child_processes.Termination.create_pid_table ()) )","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"","counters":[]},{"line":"    module Mock_snark_pool =","counters":[]},{"line":"      Make (Mocks.Base_ledger) (Mocks.Staged_ledger) (Mocks.Transition_frontier)","counters":[]},{"line":"    open Ledger_proof.For_tests","counters":[]},{"line":"","counters":[]},{"line":"    let apply_diff resource_pool work","counters":[]},{"line":"        ?(proof = One_or_two.map ~f:mk_dummy_proof)","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"        ?(sender = Envelope.Sender.Local) fee =","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"      let diff =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Mock_snark_pool.Resource_pool.Diff.Add_solved_work","counters":[]},{"line":"          (work, { Priced_proof.Stable.Latest.proof = proof work; fee })","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"      in","counters":[]},{"line":"      let enveloped_diff = Envelope.Incoming.wrap ~data:diff ~sender in","counters":[]},{"line":"      match%bind","counters":[]},{"line":"        Mock_snark_pool.Resource_pool.Diff.verify resource_pool enveloped_diff","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"      with","counters":[]},{"line":"      | Ok _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Mock_snark_pool.Resource_pool.Diff.unsafe_apply resource_pool","counters":[]},{"line":"            enveloped_diff","counters":[]},{"line":"      | Error _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Deferred.return (Error (`Other (Error.of_string \"Invalid diff\")))","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"","counters":[]},{"line":"    let config =","counters":[]},{"line":"      Mock_snark_pool.Resource_pool.make_config ~verifier ~trust_system","counters":[]},{"line":"        ~disk_location:\"/tmp/snark-pool\"","counters":[]},{"line":"","counters":[]},{"line":"    let gen ?length () =","counters":[]},{"line":"      let open Quickcheck.Generator.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let gen_entry =","counters":[]},{"line":"        Quickcheck.Generator.tuple2 Mocks.Transaction_snark_work.Statement.gen","counters":[]},{"line":"          Fee_with_prover.gen","counters":[]},{"line":"      in","counters":[]},{"line":"      let%map sample_solved_work =","counters":[]},{"line":"        match length with","counters":[]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Quickcheck.Generator.list gen_entry","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"        | Some n ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Quickcheck.Generator.list_with_length n gen_entry","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"      in","counters":[]},{"line":"      let tf = Mocks.Transition_frontier.create [] in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let frontier_broadcast_pipe_r, _ = Broadcast_pipe.create (Some tf) in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let open Deferred.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let mock_pool, _r_sink, _l_sink =","counters":[]},{"line":"        Mock_snark_pool.create ~config ~logger ~constraint_constants","counters":[]},{"line":"          ~consensus_constants ~time_controller ~expiry_ns","counters":[]},{"line":"          ~frontier_broadcast_pipe:frontier_broadcast_pipe_r","counters":[]},{"line":"          ~log_gossip_heard:false ~on_remote_push:(Fn.const Deferred.unit)","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"        (* |>  *)","counters":[]},{"line":"      in","counters":[]},{"line":"      let pool = Mock_snark_pool.resource_pool mock_pool in","counters":[]},{"line":"      (*Statements should be referenced before work for those can be included*)","counters":[]},{"line":"      let%bind () =","counters":[]},{"line":"        Mocks.Transition_frontier.refer_statements tf","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"          (List.unzip sample_solved_work |> fst)","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"      in","counters":[]},{"line":"      let%map () =","counters":[]},{"line":"        Deferred.List.iter sample_solved_work ~f:(fun (work, fee) ->","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"            let%map res = apply_diff pool work fee in","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"            assert (Result.is_ok res) )","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"      in","counters":[]},{"line":"      (pool, tf)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"serialization\" =","counters":[]},{"line":"      let t, _tf =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Async.Thread_safe.block_on_async_exn (fun () ->","counters":[]},{"line":"            Quickcheck.random_value (gen ~length:100 ()) )","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"      in","counters":[]},{"line":"      let s0 = Mock_snark_pool.For_tests.snark_tables t in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let s1 =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Snark_tables.to_serializable s0 |> Snark_tables.of_serializable","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"      in","counters":[]},{"line":"      [%test_eq: Snark_tables.t] s0 s1","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"Invalid proofs are not accepted\" =","counters":[]},{"line":"      let open Quickcheck.Generator.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let invalid_work_gen =","counters":[]},{"line":"        let gen =","counters":[]},{"line":"          let gen_entry =","counters":[]},{"line":"            Quickcheck.Generator.tuple3","counters":[]},{"line":"              Mocks.Transaction_snark_work.Statement.gen Fee_with_prover.gen","counters":[]},{"line":"              Signature_lib.Public_key.Compressed.gen","counters":[]},{"line":"          in","counters":[]},{"line":"          let%map solved_work = Quickcheck.Generator.list gen_entry in","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"          List.fold ~init:[] solved_work","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ~f:(fun acc (work, fee, some_other_pk) ->","counters":[]},{"line":"              (*Making it invalid by forging*)","counters":[]},{"line":"              let invalid_sok_digest =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Sok_message.(","counters":[]},{"line":"                  digest @@ create ~prover:some_other_pk ~fee:fee.fee)","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"              in","counters":[]},{"line":"              ( work","counters":[]},{"line":"              , One_or_two.map work ~f:(fun statement ->","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                    Ledger_proof.create ~statement","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      ~sok_digest:invalid_sok_digest","counters":[]},{"line":"                      ~proof:Proof.transaction_dummy )","counters":[]},{"line":"              , fee","counters":[]},{"line":"              , some_other_pk )","counters":[]},{"line":"              :: acc )","counters":[]},{"line":"        in","counters":[]},{"line":"        Quickcheck.Generator.filter gen ~f:(fun ls ->","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"            List.for_all ls ~f:(fun (_, _, fee, mal_pk) ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"                not","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                @@ Signature_lib.Public_key.Compressed.equal mal_pk fee.prover ) )","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"      in","counters":[]},{"line":"      Quickcheck.test ~trials:5","counters":[]},{"line":"        ~sexp_of:","counters":[]},{"line":"          [%sexp_of:","counters":[]},{"line":"            (Mock_snark_pool.Resource_pool.t * Mocks.Transition_frontier.t)","counters":[]},{"line":"            Deferred.t","counters":[]},{"line":"            * ( Transaction_snark_work.Statement.t","counters":[]},{"line":"              * Ledger_proof.t One_or_two.t","counters":[]},{"line":"              * Fee_with_prover.t","counters":[]},{"line":"              * Signature_lib.Public_key.Compressed.t )","counters":[]},{"line":"              list]","counters":[]},{"line":"        (Quickcheck.Generator.tuple2 (gen ()) invalid_work_gen)","counters":[{"col_start":35,"col_end":35,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"        ~f:(fun (t, invalid_work_lst) ->","counters":[]},{"line":"          Async.Thread_safe.block_on_async_exn (fun () ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              let open Deferred.Let_syntax in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              let%bind t, tf = t in","counters":[]},{"line":"              let completed_works =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Mock_snark_pool.Resource_pool.all_completed_work t","counters":[]},{"line":"              in","counters":[]},{"line":"              (*Statements should be referenced before work for those can be included*)","counters":[]},{"line":"              let%bind () =","counters":[]},{"line":"                Mocks.Transition_frontier.refer_statements tf","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"                  (List.map invalid_work_lst ~f:(fun (stmt, _, _, _) -> stmt))","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":72,"col_end":72,"count":0}]},{"line":"              in","counters":[]},{"line":"              let%map () =","counters":[]},{"line":"                Deferred.List.iter invalid_work_lst","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"                  ~f:(fun (statements, proofs, fee, _) ->","counters":[]},{"line":"                    let diff =","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      Mock_snark_pool.Resource_pool.Diff.Add_solved_work","counters":[]},{"line":"                        ( statements","counters":[]},{"line":"                        , { Priced_proof.Stable.Latest.proof = proofs; fee } )","counters":[]},{"line":"                      |> Envelope.Incoming.local","counters":[]},{"line":"                    in","counters":[]},{"line":"                    let%map res =","counters":[]},{"line":"                      Mock_snark_pool.Resource_pool.Diff.verify t diff","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"                    in","counters":[]},{"line":"                    assert (Result.is_error res) )","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"              in","counters":[]},{"line":"              [%test_eq: Transaction_snark_work.Info.t list] completed_works","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"                (Mock_snark_pool.Resource_pool.all_completed_work t) ) )","counters":[{"col_start":64,"col_end":64,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"When two priced proofs of the same work are inserted into \\","counters":[]},{"line":"                   the snark pool, the fee of the work is at most the minimum \\","counters":[]},{"line":"                   of those fees\" =","counters":[]},{"line":"      Quickcheck.test ~trials:5","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ~sexp_of:","counters":[]},{"line":"          [%sexp_of:","counters":[]},{"line":"            (Mock_snark_pool.Resource_pool.t * Mocks.Transition_frontier.t)","counters":[]},{"line":"            Deferred.t","counters":[]},{"line":"            * Mocks.Transaction_snark_work.Statement.t","counters":[]},{"line":"            * Fee_with_prover.t","counters":[]},{"line":"            * Fee_with_prover.t]","counters":[]},{"line":"        (Async.Quickcheck.Generator.tuple4 (gen ())","counters":[{"col_start":41,"col_end":41,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"           Mocks.Transaction_snark_work.Statement.gen Fee_with_prover.gen","counters":[]},{"line":"           Fee_with_prover.gen )","counters":[]},{"line":"        ~f:(fun (t, work, fee_1, fee_2) ->","counters":[]},{"line":"          Async.Thread_safe.block_on_async_exn (fun () ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              let%bind t, tf = t in","counters":[]},{"line":"              (*Statements should be referenced before work for those can be included*)","counters":[]},{"line":"              let%bind () =","counters":[]},{"line":"                Mocks.Transition_frontier.refer_statements tf [ work ]","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"              in","counters":[]},{"line":"              let%bind _ = apply_diff t work fee_1 in","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"              let%map _ = apply_diff t work fee_2 in","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"              let fee_upper_bound = Currency.Fee.min fee_1.fee fee_2.fee in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              let { Priced_proof.fee = { fee; _ }; _ } =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Option.value_exn","counters":[]},{"line":"                  (Mock_snark_pool.Resource_pool.request_proof t work)","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"              in","counters":[]},{"line":"              assert (Currency.Fee.(fee <= fee_upper_bound)) ) )","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"A priced proof of a work will replace an existing priced \\","counters":[]},{"line":"                   proof of the same work only if it's fee is smaller than the \\","counters":[]},{"line":"                   existing priced proof\" =","counters":[]},{"line":"      Quickcheck.test ~trials:5","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ~sexp_of:","counters":[]},{"line":"          [%sexp_of:","counters":[]},{"line":"            (Mock_snark_pool.Resource_pool.t * Mocks.Transition_frontier.t)","counters":[]},{"line":"            Deferred.t","counters":[]},{"line":"            * Mocks.Transaction_snark_work.Statement.t","counters":[]},{"line":"            * Fee_with_prover.t","counters":[]},{"line":"            * Fee_with_prover.t]","counters":[]},{"line":"        (Quickcheck.Generator.tuple4 (gen ())","counters":[{"col_start":35,"col_end":35,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"           Mocks.Transaction_snark_work.Statement.gen Fee_with_prover.gen","counters":[]},{"line":"           Fee_with_prover.gen )","counters":[]},{"line":"        ~f:(fun (t, work, fee_1, fee_2) ->","counters":[]},{"line":"          Async.Thread_safe.block_on_async_exn (fun () ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              let%bind t, tf = t in","counters":[]},{"line":"              (*Statements should be referenced before work for those can be included*)","counters":[]},{"line":"              let%bind () =","counters":[]},{"line":"                Mocks.Transition_frontier.refer_statements tf [ work ]","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"              in","counters":[]},{"line":"              Mock_snark_pool.Resource_pool.remove_solved_work t work ;","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              let expensive_fee = Fee_with_prover.max fee_1 fee_2","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"              and cheap_fee = Fee_with_prover.min fee_1 fee_2 in","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"              let%bind _ = apply_diff t work cheap_fee in","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"              let%map res = apply_diff t work expensive_fee in","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"              assert (Result.is_error res) ;","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"              assert (","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                Currency.Fee.equal cheap_fee.fee","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"                  (Option.value_exn","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"                     (Mock_snark_pool.Resource_pool.request_proof t work) )","counters":[{"col_start":64,"col_end":64,"count":0}]},{"line":"                    .fee","counters":[]},{"line":"                    .fee ) ) )","counters":[]},{"line":"","counters":[]},{"line":"    let fake_work =","counters":[]},{"line":"      `One","counters":[]},{"line":"        (Quickcheck.random_value ~seed:(`Deterministic \"worktest\")","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"           Transaction_snark.Statement.gen )","counters":[]},{"line":"","counters":[]},{"line":"    let%test_unit \"Work that gets fed into apply_and_broadcast will be \\","counters":[]},{"line":"                   received in the pool's reader\" =","counters":[]},{"line":"      Async.Thread_safe.block_on_async_exn (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          let frontier_broadcast_pipe_r, _ =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Broadcast_pipe.create (Some (Mocks.Transition_frontier.create []))","counters":[{"col_start":72,"col_end":72,"count":0}]},{"line":"          in","counters":[]},{"line":"          let network_pool, _, _ =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Mock_snark_pool.create ~config ~constraint_constants","counters":[]},{"line":"              ~consensus_constants ~time_controller ~expiry_ns ~logger","counters":[]},{"line":"              ~frontier_broadcast_pipe:frontier_broadcast_pipe_r","counters":[]},{"line":"              ~log_gossip_heard:false ~on_remote_push:(Fn.const Deferred.unit)","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"          in","counters":[]},{"line":"          let priced_proof =","counters":[]},{"line":"            { Priced_proof.proof =","counters":[]},{"line":"                `One","counters":[]},{"line":"                  (mk_dummy_proof","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                     (Quickcheck.random_value","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"                        ~seed:(`Deterministic \"test proof\")","counters":[]},{"line":"                        Transaction_snark.Statement.gen ) )","counters":[]},{"line":"            ; fee =","counters":[]},{"line":"                { fee = Currency.Fee.of_int 0","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"                ; prover = Signature_lib.Public_key.Compressed.empty","counters":[]},{"line":"                }","counters":[]},{"line":"            }","counters":[]},{"line":"          in","counters":[]},{"line":"          let command =","counters":[]},{"line":"            Mock_snark_pool.Resource_pool.Diff.Add_solved_work","counters":[]},{"line":"              (fake_work, priced_proof)","counters":[]},{"line":"          in","counters":[]},{"line":"          don't_wait_for","counters":[]},{"line":"          @@ Linear_pipe.iter (Mock_snark_pool.broadcasts network_pool)","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"               ~f:(fun _ ->","counters":[]},{"line":"                 let pool = Mock_snark_pool.resource_pool network_pool in","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                 ( match","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                     Mock_snark_pool.Resource_pool.request_proof pool fake_work","counters":[]},{"line":"                   with","counters":[]},{"line":"                 | Some { proof; fee = _ } ->","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"                     assert (","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                       [%equal: Ledger_proof.t One_or_two.t] proof","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"                         priced_proof.proof )","counters":[]},{"line":"                 | None ->","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"                     failwith \"There should have been a proof here\" ) ;","counters":[]},{"line":"                 Deferred.unit ) ;","counters":[]},{"line":"          Mock_snark_pool.apply_and_broadcast network_pool","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (Envelope.Incoming.local command)","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"            (Mock_snark_pool.Broadcast_callback.Local (Fn.const ())) )","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"when creating a network, the incoming diffs and locally \\","counters":[]},{"line":"                   generated diffs in reader pipes will automatically get \\","counters":[]},{"line":"                   process\" =","counters":[]},{"line":"      Async.Thread_safe.block_on_async_exn (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          let work_count = 10 in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let works =","counters":[]},{"line":"            Quickcheck.random_sequence ~seed:(`Deterministic \"works\")","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"              Transaction_snark.Statement.gen","counters":[]},{"line":"            |> Fn.flip Sequence.take work_count","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"            |> Sequence.map ~f:(fun x -> `One x)","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"            |> Sequence.to_list","counters":[]},{"line":"          in","counters":[]},{"line":"          let per_reader = work_count / 2 in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let create_work work =","counters":[]},{"line":"            Mock_snark_pool.Resource_pool.Diff.Add_solved_work","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              ( work","counters":[]},{"line":"              , Priced_proof.","counters":[]},{"line":"                  { proof = One_or_two.map ~f:mk_dummy_proof work","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"                  ; fee =","counters":[]},{"line":"                      { fee = Currency.Fee.of_int 0","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"                      ; prover = Signature_lib.Public_key.Compressed.empty","counters":[]},{"line":"                      }","counters":[]},{"line":"                  } )","counters":[]},{"line":"          in","counters":[]},{"line":"          let verify_unsolved_work () =","counters":[]},{"line":"            (*incomming diffs*)","counters":[]},{"line":"            let%bind () = Async.Scheduler.yield_until_no_jobs_remain () in","counters":[{"col_start":67,"col_end":67,"count":0}]},{"line":"            let frontier_broadcast_pipe_r, _ =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Broadcast_pipe.create (Some (Mocks.Transition_frontier.create []))","counters":[{"col_start":74,"col_end":74,"count":0}]},{"line":"            in","counters":[]},{"line":"            let network_pool, remote_sink, local_sink =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Mock_snark_pool.create ~logger ~config ~constraint_constants","counters":[]},{"line":"                ~consensus_constants ~time_controller ~expiry_ns","counters":[]},{"line":"                ~frontier_broadcast_pipe:frontier_broadcast_pipe_r","counters":[]},{"line":"                ~log_gossip_heard:false ~on_remote_push:(Fn.const Deferred.unit)","counters":[{"col_start":64,"col_end":64,"count":0}]},{"line":"            in","counters":[]},{"line":"            List.map (List.take works per_reader) ~f:create_work","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"            |> List.map ~f:(fun work ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                   ( Envelope.Incoming.local work","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"                   , Mina_net2.Validation_callback.create_without_expiration ()","counters":[{"col_start":75,"col_end":75,"count":0}]},{"line":"                   ) )","counters":[]},{"line":"            |> List.iter ~f:(fun diff ->","counters":[]},{"line":"                   Mock_snark_pool.Remote_sink.push remote_sink diff","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"                   |> Deferred.don't_wait_for ) ;","counters":[]},{"line":"            (* locally generated diffs *)","counters":[]},{"line":"            List.map (List.drop works per_reader) ~f:create_work","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"            |> List.iter ~f:(fun diff ->","counters":[]},{"line":"                   Mock_snark_pool.Local_sink.push local_sink (diff, Fn.const ())","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":49,"col_end":49,"count":0},{"col_start":76,"col_end":76,"count":0}]},{"line":"                   |> Deferred.don't_wait_for ) ;","counters":[]},{"line":"            don't_wait_for","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            @@ Linear_pipe.iter (Mock_snark_pool.broadcasts network_pool)","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"                 ~f:(fun work_command ->","counters":[]},{"line":"                   let work =","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"                     match work_command with","counters":[]},{"line":"                     | Mock_snark_pool.Resource_pool.Diff.Add_solved_work","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                         (work, _) ->","counters":[]},{"line":"                         work","counters":[]},{"line":"                     | Mock_snark_pool.Resource_pool.Diff.Empty ->","counters":[]},{"line":"                         assert false","counters":[]},{"line":"                   in","counters":[]},{"line":"                   assert (","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                     List.mem works work","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                       ~equal:","counters":[]},{"line":"                         [%equal: Transaction_snark.Statement.t One_or_two.t] ) ;","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"                   Deferred.unit ) ;","counters":[]},{"line":"            Deferred.unit","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          in","counters":[]},{"line":"          verify_unsolved_work () )","counters":[]},{"line":"","counters":[]},{"line":"    let%test_unit \"rebroadcast behavior\" =","counters":[]},{"line":"      let tf = Mocks.Transition_frontier.create [] in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let frontier_broadcast_pipe_r, _w = Broadcast_pipe.create (Some tf) in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let stmt1, stmt2, stmt3, stmt4 =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let gen_not_any l =","counters":[]},{"line":"          Quickcheck.Generator.filter Mocks.Transaction_snark_work.Statement.gen","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ~f:(fun x ->","counters":[]},{"line":"              List.for_all l ~f:(fun y ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                  Mocks.Transaction_snark_work.Statement.compare x y <> 0 ) )","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"        in","counters":[]},{"line":"        let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"        Quickcheck.random_value ~seed:(`Deterministic \"\")","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"          (let%bind a = gen_not_any [] in","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"           let%bind b = gen_not_any [ a ] in","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"           let%bind c = gen_not_any [ a; b ] in","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"           let%map d = gen_not_any [ a; b; c ] in","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"           (a, b, c, d) )","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"      in","counters":[]},{"line":"      let fee1, fee2, fee3, fee4 =","counters":[]},{"line":"        Quickcheck.random_value ~seed:(`Deterministic \"\")","counters":[]},{"line":"          (Quickcheck.Generator.tuple4 Fee_with_prover.gen Fee_with_prover.gen","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"             Fee_with_prover.gen Fee_with_prover.gen )","counters":[]},{"line":"      in","counters":[]},{"line":"      let fake_sender =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Envelope.Sender.Remote","counters":[]},{"line":"          (Peer.create","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"             (Unix.Inet_addr.of_string \"1.2.3.4\")","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"             ~peer_id:(Peer.Id.unsafe_of_string \"contents should be irrelevant\")","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"             ~libp2p_port:8302 )","counters":[]},{"line":"      in","counters":[]},{"line":"      let compare_work (x : Mock_snark_pool.Resource_pool.Diff.t)","counters":[]},{"line":"          (y : Mock_snark_pool.Resource_pool.Diff.t) =","counters":[]},{"line":"        match (x, y) with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | Add_solved_work (stmt1, _), Add_solved_work (stmt2, _) ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Transaction_snark_work.Statement.compare stmt1 stmt2","counters":[]},{"line":"        | _ ->","counters":[]},{"line":"            assert false","counters":[]},{"line":"      in","counters":[]},{"line":"      let check_work ~expected ~got =","counters":[]},{"line":"        let sort = List.sort ~compare:compare_work in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        [%test_eq: Mock_snark_pool.Resource_pool.Diff.t list] (sort got)","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":56,"col_end":56,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"          (sort expected)","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"      in","counters":[]},{"line":"      Async.Thread_safe.block_on_async_exn (fun () ->","counters":[]},{"line":"          let open Deferred.Let_syntax in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let network_pool, _, _ =","counters":[]},{"line":"            Mock_snark_pool.create ~logger:(Logger.null ()) ~config","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"              ~constraint_constants ~consensus_constants ~time_controller","counters":[]},{"line":"              ~expiry_ns ~frontier_broadcast_pipe:frontier_broadcast_pipe_r","counters":[]},{"line":"              ~log_gossip_heard:false ~on_remote_push:(Fn.const Deferred.unit)","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"          in","counters":[]},{"line":"          let resource_pool = Mock_snark_pool.resource_pool network_pool in","counters":[]},{"line":"          let%bind () =","counters":[]},{"line":"            Mocks.Transition_frontier.refer_statements tf","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"              [ stmt1; stmt2; stmt3; stmt4 ]","counters":[]},{"line":"          in","counters":[]},{"line":"          let%bind res1 =","counters":[]},{"line":"            apply_diff ~sender:fake_sender resource_pool stmt1 fee1","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"          in","counters":[]},{"line":"          let ok_exn = function","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            | Ok e ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                e","counters":[]},{"line":"            | Error (`Other e) ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Or_error.ok_exn (Error e)","counters":[]},{"line":"            | Error (`Locally_generated _) ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                failwith \"rejected because locally generated\"","counters":[]},{"line":"          in","counters":[]},{"line":"          ignore","counters":[]},{"line":"            ( ok_exn res1","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"              : [ `Accept | `Reject ]","counters":[]},{"line":"                * Mock_snark_pool.Resource_pool.Diff.verified","counters":[]},{"line":"                * Mock_snark_pool.Resource_pool.Diff.rejected ) ;","counters":[]},{"line":"          let rebroadcastable1 =","counters":[]},{"line":"            Mock_snark_pool.For_tests.get_rebroadcastable resource_pool","counters":[]},{"line":"              ~has_timed_out:(Fn.const `Ok)","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"          in","counters":[]},{"line":"          check_work ~got:rebroadcastable1 ~expected:[] ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let%bind res2 = apply_diff resource_pool stmt2 fee2 in","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"          let proof2 = One_or_two.map ~f:mk_dummy_proof stmt2 in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          ignore","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ( ok_exn res2","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"              : [ `Accept | `Reject ]","counters":[]},{"line":"                * Mock_snark_pool.Resource_pool.Diff.verified","counters":[]},{"line":"                * Mock_snark_pool.Resource_pool.Diff.rejected ) ;","counters":[]},{"line":"          let rebroadcastable2 =","counters":[]},{"line":"            Mock_snark_pool.For_tests.get_rebroadcastable resource_pool","counters":[]},{"line":"              ~has_timed_out:(Fn.const `Ok)","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"          in","counters":[]},{"line":"          check_work ~got:rebroadcastable2","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ~expected:","counters":[]},{"line":"              [ Add_solved_work (stmt2, { proof = proof2; fee = fee2 }) ] ;","counters":[]},{"line":"          let%bind res3 = apply_diff resource_pool stmt3 fee3 in","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"          let proof3 = One_or_two.map ~f:mk_dummy_proof stmt3 in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          ignore","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ( ok_exn res3","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"              : [ `Accept | `Reject ]","counters":[]},{"line":"                * Mock_snark_pool.Resource_pool.Diff.verified","counters":[]},{"line":"                * Mock_snark_pool.Resource_pool.Diff.rejected ) ;","counters":[]},{"line":"          let rebroadcastable3 =","counters":[]},{"line":"            Mock_snark_pool.For_tests.get_rebroadcastable resource_pool","counters":[]},{"line":"              ~has_timed_out:(Fn.const `Ok)","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"          in","counters":[]},{"line":"          check_work ~got:rebroadcastable3","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ~expected:","counters":[]},{"line":"              [ Add_solved_work (stmt2, { proof = proof2; fee = fee2 })","counters":[]},{"line":"              ; Add_solved_work (stmt3, { proof = proof3; fee = fee3 })","counters":[]},{"line":"              ] ;","counters":[]},{"line":"          (* Keep rebroadcasting even after the timeout, as long as the work","counters":[]},{"line":"             hasn't appeared in a block yet.","counters":[]},{"line":"          *)","counters":[]},{"line":"          let rebroadcastable4 =","counters":[]},{"line":"            Mock_snark_pool.For_tests.get_rebroadcastable resource_pool","counters":[]},{"line":"              ~has_timed_out:(Fn.const `Timed_out)","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"          in","counters":[]},{"line":"          check_work ~got:rebroadcastable4","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ~expected:","counters":[]},{"line":"              [ Add_solved_work (stmt2, { proof = proof2; fee = fee2 })","counters":[]},{"line":"              ; Add_solved_work (stmt3, { proof = proof3; fee = fee3 })","counters":[]},{"line":"              ] ;","counters":[]},{"line":"          let%bind res6 = apply_diff resource_pool stmt4 fee4 in","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"          let proof4 = One_or_two.map ~f:mk_dummy_proof stmt4 in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          ignore","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ( ok_exn res6","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"              : [ `Accept | `Reject ]","counters":[]},{"line":"                * Mock_snark_pool.Resource_pool.Diff.verified","counters":[]},{"line":"                * Mock_snark_pool.Resource_pool.Diff.rejected ) ;","counters":[]},{"line":"          (* Mark best tip as not including stmt3. *)","counters":[]},{"line":"          let%bind () =","counters":[]},{"line":"            Mocks.Transition_frontier.remove_from_best_tip tf [ stmt3 ]","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"          in","counters":[]},{"line":"          let rebroadcastable5 =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Mock_snark_pool.For_tests.get_rebroadcastable resource_pool","counters":[]},{"line":"              ~has_timed_out:(Fn.const `Ok)","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"          in","counters":[]},{"line":"          check_work ~got:rebroadcastable5","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ~expected:","counters":[]},{"line":"              [ Add_solved_work (stmt2, { proof = proof2; fee = fee2 })","counters":[]},{"line":"              ; Add_solved_work (stmt4, { proof = proof4; fee = fee4 })","counters":[]},{"line":"              ] ;","counters":[]},{"line":"          Deferred.unit )","counters":[]},{"line":"  end )","counters":[{"col_start":6,"col_end":6,"count":1}]}]}