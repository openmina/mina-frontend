{"filename":"src/lib/pickles/side_loaded_verification_key.ml","lines":[{"line":"(** A verification key for a pickles proof, whose contents are not fixed within","counters":[]},{"line":"    the verifier circuit.","counters":[]},{"line":"    This is used to verify a proof where the verification key is determined by","counters":[]},{"line":"    some other constraint, for example to use a verification key provided as","counters":[]},{"line":"    input to the circuit, or loaded from an account that was chosen based upon","counters":[]},{"line":"    the circuit inputs.","counters":[]},{"line":"","counters":[]},{"line":"    Here and elsewhere, we use the terms","counters":[]},{"line":"    * **width**:","counters":[]},{"line":"      - the number of proofs that a proof has verified itself;","counters":[]},{"line":"      - (equivalently) the maximum number of proofs that a proof depends upon","counters":[]},{"line":"        directly.","counters":[]},{"line":"      - NB: This does not include recursively-verified proofs, this only refers","counters":[]},{"line":"        to proofs that were provided directly to pickles when the proof was","counters":[]},{"line":"        being generated.","counters":[]},{"line":"    * **branch**:","counters":[]},{"line":"      - a single 'rule' or 'circuit' for which a proof can be generated, where","counters":[]},{"line":"        a verification key verifies a proof for any of these branches.","counters":[]},{"line":"      - It is common to have a 'base' branch and a 'recursion' branch. For","counters":[]},{"line":"        example, the transaction snark has a 'transaction' proof that evaluates","counters":[]},{"line":"        a single transaction and a 'merge' proof that combines two transaction","counters":[]},{"line":"        snark proofs that prove sequential updates, each of which may be either","counters":[]},{"line":"        a 'transaction' or a 'merge'.","counters":[]},{"line":"*)","counters":[]},{"line":"","counters":[{"col_start":0,"col_end":0,"count":1}]},{"line":"open Core_kernel","counters":[]},{"line":"open Pickles_types","counters":[]},{"line":"open Common","counters":[]},{"line":"open Import","counters":[]},{"line":"module V = Pickles_base.Side_loaded_verification_key","counters":[]},{"line":"","counters":[]},{"line":"include (","counters":[]},{"line":"  V :","counters":[]},{"line":"    module type of V","counters":[]},{"line":"      with module Width := V.Width","counters":[]},{"line":"       and module Domains := V.Domains )","counters":[]},{"line":"","counters":[]},{"line":"let bits = V.bits","counters":[]},{"line":"","counters":[]},{"line":"let input_size ~of_int ~add ~mul w =","counters":[]},{"line":"  let open Composition_types in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  (* This should be an affine function in [a]. *)","counters":[]},{"line":"  let size a =","counters":[]},{"line":"    let (T (Typ typ, _conv, _conv_inv)) =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Impls.Step.input ~proofs_verified:a ~wrap_rounds:Backend.Tock.Rounds.n","counters":[]},{"line":"        ~uses_lookup:No","counters":[]},{"line":"    in","counters":[]},{"line":"    typ.size_in_field_elements","counters":[]},{"line":"  in","counters":[]},{"line":"  let f0 = size Nat.N0.n in","counters":[]},{"line":"  let slope = size Nat.N1.n - f0 in","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"  add (of_int f0) (mul (of_int slope) w)","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"module Width : sig","counters":[]},{"line":"  [%%versioned:","counters":[]},{"line":"  module Stable : sig","counters":[]},{"line":"    module V1 : sig","counters":[]},{"line":"      type t = V.Width.Stable.V1.t","counters":[]},{"line":"      [@@deriving sexp, equal, compare, hash, yojson]","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  val of_int_exn : int -> t","counters":[]},{"line":"","counters":[]},{"line":"  val to_int : t -> int","counters":[]},{"line":"","counters":[]},{"line":"  val to_bits : t -> bool list","counters":[]},{"line":"","counters":[]},{"line":"  val zero : t","counters":[]},{"line":"","counters":[]},{"line":"  open Impls.Step","counters":[]},{"line":"","counters":[]},{"line":"  module Checked : sig","counters":[]},{"line":"    type t","counters":[]},{"line":"","counters":[]},{"line":"    val to_field : t -> Field.t","counters":[]},{"line":"","counters":[]},{"line":"    val to_bits : t -> Boolean.var list","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  val typ : (Checked.t, t) Typ.t","counters":[]},{"line":"","counters":[]},{"line":"  module Max = Nat.N2","counters":[]},{"line":"","counters":[]},{"line":"  module Max_vector : Vector.With_version(Max).S","counters":[]},{"line":"","counters":[]},{"line":"  module Max_at_most : sig","counters":[]},{"line":"    [%%versioned:","counters":[]},{"line":"    module Stable : sig","counters":[]},{"line":"      module V1 : sig","counters":[]},{"line":"        type 'a t = ('a, Max.n) At_most.t","counters":[]},{"line":"        [@@deriving compare, sexp, yojson, hash, equal]","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Length : Nat.Add.Intf_transparent","counters":[]},{"line":"end = struct","counters":[]},{"line":"  include V.Width","counters":[]},{"line":"  open Impls.Step","counters":[]},{"line":"","counters":[]},{"line":"  module Checked = struct","counters":[]},{"line":"    (* A \"width\" is represented by a 4 bit integer. *)","counters":[]},{"line":"    type t = (Boolean.var, Length.n) Vector.t","counters":[]},{"line":"","counters":[]},{"line":"    let to_field : t -> Field.t = Fn.compose Field.project Vector.to_list","counters":[{"col_start":43,"col_end":43,"count":1}]},{"line":"","counters":[]},{"line":"    let to_bits = Vector.to_list","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let typ : (Checked.t, t) Typ.t =","counters":[]},{"line":"    Typ.transport","counters":[{"col_start":16,"col_end":16,"count":1}]},{"line":"      (Vector.typ Boolean.typ Length.n)","counters":[{"col_start":16,"col_end":16,"count":1}]},{"line":"      ~there:(fun x ->","counters":[]},{"line":"        let x = to_int x in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Vector.init Length.n ~f:(fun i -> (x lsr i) land 1 = 1) )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"      ~back:(fun v ->","counters":[]},{"line":"        Vector.foldi v ~init:0 ~f:(fun i acc b ->","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"            if b then acc lor (1 lsl i) else acc )","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"        |> of_int_exn )","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Domain = struct","counters":[]},{"line":"  type 'a t = Pow_2_roots_of_unity of 'a [@@deriving sexp]","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":14,"col_end":14,"count":0}]},{"line":"","counters":[]},{"line":"  let log2_size (Pow_2_roots_of_unity x) = x","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Domains = struct","counters":[]},{"line":"  include V.Domains","counters":[]},{"line":"","counters":[]},{"line":"  let typ =","counters":[]},{"line":"    let open Impls.Step in","counters":[]},{"line":"    let dom =","counters":[]},{"line":"      Typ.transport Typ.field","counters":[{"col_start":18,"col_end":18,"count":1}]},{"line":"        ~there:(fun (Plonk_checks.Domain.Pow_2_roots_of_unity n) ->","counters":[]},{"line":"          Field.Constant.of_int n )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        ~back:(fun _ -> assert false)","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"      |> Typ.transport_var","counters":[]},{"line":"           ~there:(fun (Domain.Pow_2_roots_of_unity n) -> n)","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"           ~back:(fun n -> Domain.Pow_2_roots_of_unity n)","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"    in","counters":[]},{"line":"    Typ.of_hlistable [ dom ] ~var_to_hlist:to_hlist ~value_to_hlist:to_hlist","counters":[{"col_start":4,"col_end":4,"count":1},{"col_start":19,"col_end":19,"count":1}]},{"line":"      ~var_of_hlist:of_hlist ~value_of_hlist:of_hlist","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let max_domains =","counters":[]},{"line":"  { Domains.h = Domain.Pow_2_roots_of_unity (Nat.to_int Backend.Tick.Rounds.n) }","counters":[{"col_start":54,"col_end":54,"count":1}]},{"line":"","counters":[]},{"line":"module Vk = struct","counters":[]},{"line":"  type t = (Impls.Wrap.Verification_key.t[@sexp.opaque]) [@@deriving sexp]","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"  let to_yojson _ = `String \"opaque\"","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"","counters":[]},{"line":"  let of_yojson _ = Error \"Vk: yojson not supported\"","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"","counters":[]},{"line":"  let hash _ = Unit.hash ()","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"","counters":[]},{"line":"  let hash_fold_t s _ = Unit.hash_fold_t s ()","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"","counters":[]},{"line":"  let equal _ _ = true","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"","counters":[]},{"line":"  let compare _ _ = 0","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module R = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V2 = struct","counters":[]},{"line":"      type t = Backend.Tock.Curve.Affine.Stable.V1.t Repr.Stable.V2.t","counters":[{"col_start":6,"col_end":6,"count":2},{"col_start":11,"col_end":11,"count":1},{"col_start":15,"col_end":15,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"      [@@deriving sexp, equal, compare, yojson]","counters":[{"col_start":46,"col_end":46,"count":5}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"[%%versioned_binable","counters":[]},{"line":"module Stable = struct","counters":[]},{"line":"  module V2 = struct","counters":[]},{"line":"    module T = struct","counters":[{"col_start":4,"col_end":4,"count":1}]},{"line":"      type t =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ( Backend.Tock.Curve.Affine.t","counters":[]},{"line":"        , Pickles_base.Proofs_verified.Stable.V1.t","counters":[]},{"line":"        , Vk.t )","counters":[]},{"line":"        Poly.Stable.V2.t","counters":[]},{"line":"      [@@deriving hash]","counters":[]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"      let description = \"Verification key\"","counters":[]},{"line":"","counters":[]},{"line":"      let version_byte = Base58_check.Version_bytes.verification_key","counters":[]},{"line":"","counters":[]},{"line":"      let to_repr { Poly.max_proofs_verified; wrap_index; wrap_vk = _ } =","counters":[]},{"line":"        { Repr.Stable.V2.max_proofs_verified; wrap_index }","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      let of_repr","counters":[]},{"line":"          ({ Repr.Stable.V2.max_proofs_verified; wrap_index = c } :","counters":[]},{"line":"            R.Stable.V2.t ) : t =","counters":[]},{"line":"        let d =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (Common.wrap_domains","counters":[]},{"line":"             ~proofs_verified:","counters":[]},{"line":"               (Pickles_base.Proofs_verified.to_int max_proofs_verified) )","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"            .h","counters":[]},{"line":"        in","counters":[]},{"line":"        let log2_size = Import.Domain.log2_size d in","counters":[]},{"line":"        let max_quot_size = Common.max_quot_size_int (Import.Domain.size d) in","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"        let public =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let (T (input, conv, _conv_inv)) = Impls.Wrap.input () in","counters":[]},{"line":"          let (Typ typ) = input in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          typ.size_in_field_elements","counters":[]},{"line":"        in","counters":[]},{"line":"        (* we only compute the wrap_vk if the srs can be loaded *)","counters":[]},{"line":"        let srs =","counters":[]},{"line":"          try Some (Backend.Tock.Keypair.load_urs ()) with _ -> None","counters":[{"col_start":48,"col_end":48,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"        in","counters":[]},{"line":"        let wrap_vk =","counters":[]},{"line":"          Option.map srs ~f:(fun srs : Impls.Wrap.Verification_key.t ->","counters":[]},{"line":"              { domain =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                  { log_size_of_group = log2_size","counters":[]},{"line":"                  ; group_gen = Backend.Tock.Field.domain_generator ~log2_size","counters":[]},{"line":"                  }","counters":[]},{"line":"              ; max_poly_size = 1 lsl Nat.to_int Backend.Tock.Rounds.n","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"              ; max_quot_size","counters":[]},{"line":"              ; public","counters":[]},{"line":"              ; prev_challenges = 2 (* Due to Wrap_hack *)","counters":[]},{"line":"              ; srs","counters":[]},{"line":"              ; evals =","counters":[]},{"line":"                  (let g (x, y) =","counters":[]},{"line":"                     { Kimchi_types.unshifted = [| Kimchi_types.Finite (x, y) |]","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                     ; shifted = None","counters":[]},{"line":"                     }","counters":[]},{"line":"                   in","counters":[]},{"line":"                   { sigma_comm = Array.map ~f:g (Vector.to_array c.sigma_comm)","counters":[{"col_start":42,"col_end":42,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"                   ; coefficients_comm =","counters":[]},{"line":"                       Array.map ~f:g (Vector.to_array c.coefficients_comm)","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"                   ; generic_comm = g c.generic_comm","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"                   ; mul_comm = g c.mul_comm","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                   ; psm_comm = g c.psm_comm","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                   ; emul_comm = g c.emul_comm","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"                   ; complete_add_comm = g c.complete_add_comm","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"                   ; endomul_scalar_comm = g c.endomul_scalar_comm","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"                   ; chacha_comm = None","counters":[]},{"line":"                   } )","counters":[]},{"line":"              ; shifts = Common.tock_shifts ~log2_size","counters":[]},{"line":"              ; lookup_index = None","counters":[]},{"line":"              } )","counters":[]},{"line":"        in","counters":[]},{"line":"        { Poly.max_proofs_verified; wrap_index = c; wrap_vk }","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      (* Proxy derivers to [R.t]'s, ignoring [wrap_vk] *)","counters":[]},{"line":"","counters":[]},{"line":"      let sexp_of_t t = R.sexp_of_t (to_repr t)","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"","counters":[]},{"line":"      let t_of_sexp sexp = of_repr (R.t_of_sexp sexp)","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"","counters":[]},{"line":"      let to_yojson t = R.to_yojson (to_repr t)","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"","counters":[]},{"line":"      let of_yojson json = Result.map ~f:of_repr (R.of_yojson json)","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"","counters":[]},{"line":"      let equal x y = R.equal (to_repr x) (to_repr y)","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"","counters":[]},{"line":"      let compare x y = R.compare (to_repr x) (to_repr y)","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"","counters":[]},{"line":"      include","counters":[]},{"line":"        Binable.Of_binable","counters":[]},{"line":"          (R.Stable.V2)","counters":[]},{"line":"          (struct","counters":[]},{"line":"            type nonrec t = t","counters":[]},{"line":"","counters":[]},{"line":"            let to_binable r = to_repr r","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"","counters":[]},{"line":"            let of_binable r = of_repr r","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"          end)","counters":[]},{"line":"    end","counters":[{"col_start":6,"col_end":6,"count":1}]},{"line":"","counters":[]},{"line":"    include T","counters":[]},{"line":"    include Codable.Make_base58_check (T)","counters":[]},{"line":"    include Codable.Make_base64 (T)","counters":[]},{"line":"  end","counters":[]},{"line":"end]","counters":[]},{"line":"","counters":[]},{"line":"[%%define_locally","counters":[]},{"line":"Stable.Latest.","counters":[]},{"line":"  ( to_base58_check","counters":[]},{"line":"  , of_base58_check","counters":[]},{"line":"  , of_base58_check_exn","counters":[]},{"line":"  , to_base64","counters":[]},{"line":"  , of_base64","counters":[]},{"line":"  , sexp_of_t","counters":[]},{"line":"  , t_of_sexp","counters":[]},{"line":"  , to_yojson","counters":[]},{"line":"  , of_yojson","counters":[]},{"line":"  , equal","counters":[]},{"line":"  , compare )]","counters":[]},{"line":"","counters":[]},{"line":"let dummy : t =","counters":[]},{"line":"  { max_proofs_verified = N2","counters":[]},{"line":"  ; wrap_index =","counters":[]},{"line":"      (let g = Backend.Tock.Curve.(to_affine_exn one) in","counters":[{"col_start":47,"col_end":47,"count":1}]},{"line":"       { sigma_comm = Vector.init Plonk_types.Permuts.n ~f:(fun _ -> g)","counters":[{"col_start":32,"col_end":32,"count":1},{"col_start":69,"col_end":69,"count":7}]},{"line":"       ; coefficients_comm = Vector.init Plonk_types.Columns.n ~f:(fun _ -> g)","counters":[{"col_start":39,"col_end":39,"count":1},{"col_start":76,"col_end":76,"count":15}]},{"line":"       ; generic_comm = g","counters":[]},{"line":"       ; psm_comm = g","counters":[]},{"line":"       ; complete_add_comm = g","counters":[]},{"line":"       ; mul_comm = g","counters":[]},{"line":"       ; emul_comm = g","counters":[]},{"line":"       ; endomul_scalar_comm = g","counters":[]},{"line":"       } )","counters":[]},{"line":"  ; wrap_vk = None","counters":[]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"module Checked = struct","counters":[]},{"line":"  open Step_main_inputs","counters":[]},{"line":"  open Impl","counters":[]},{"line":"","counters":[]},{"line":"  type t =","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":7,"col_end":7,"count":0}]},{"line":"    { max_proofs_verified :","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Impl.field Pickles_base.Proofs_verified.One_hot.Checked.t","counters":[]},{"line":"          (** The maximum of all of the [step_widths]. *)","counters":[]},{"line":"    ; wrap_index : Inner_curve.t Plonk_verification_key_evals.t","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          (** The plonk verification key for the 'wrapping' proof that this key","counters":[]},{"line":"              is used to verify.","counters":[]},{"line":"          *)","counters":[]},{"line":"    }","counters":[]},{"line":"  [@@deriving hlist, fields]","counters":[]},{"line":"","counters":[]},{"line":"  (** [log_2] of the width. *)","counters":[]},{"line":"  let width_size = Nat.to_int Width.Length.n","counters":[{"col_start":28,"col_end":28,"count":1}]},{"line":"","counters":[]},{"line":"  let to_input =","counters":[]},{"line":"    let open Random_oracle_input.Chunked in","counters":[]},{"line":"    fun { max_proofs_verified; wrap_index } : _ Random_oracle_input.Chunked.t ->","counters":[]},{"line":"      let max_proofs_verified =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Pickles_base.Proofs_verified.One_hot.Checked.to_input","counters":[]},{"line":"          max_proofs_verified","counters":[]},{"line":"      in","counters":[]},{"line":"      List.reduce_exn ~f:append","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [ max_proofs_verified","counters":[]},{"line":"        ; wrap_index_to_input","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"            (Fn.compose Array.of_list Inner_curve.to_field_elements)","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"            wrap_index","counters":[]},{"line":"        ]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let%test_unit \"input_size\" =","counters":[]},{"line":"  List.iter","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    (List.range 0 (Nat.to_int Width.Max.n) ~stop:`inclusive ~start:`inclusive)","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"    ~f:(fun n ->","counters":[]},{"line":"      [%test_eq: int]","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"        (input_size ~of_int:Fn.id ~add:( + ) ~mul:( * ) n)","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"        (let (T a) = Nat.of_int n in","counters":[]},{"line":"         let (T (Typ typ, _conv, _conv_inv)) =","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"           Impls.Step.input ~proofs_verified:a","counters":[]},{"line":"             ~wrap_rounds:Backend.Tock.Rounds.n ~uses_lookup:No","counters":[]},{"line":"         in","counters":[]},{"line":"         typ.size_in_field_elements ) )","counters":[]},{"line":"","counters":[]},{"line":"let typ : (Checked.t, t) Impls.Step.Typ.t =","counters":[]},{"line":"  let open Step_main_inputs in","counters":[]},{"line":"  let open Impl in","counters":[]},{"line":"  Typ.of_hlistable","counters":[{"col_start":17,"col_end":17,"count":1}]},{"line":"    [ Pickles_base.Proofs_verified.One_hot.typ (module Impls.Step)","counters":[{"col_start":45,"col_end":45,"count":1}]},{"line":"    ; Plonk_verification_key_evals.typ Inner_curve.typ","counters":[{"col_start":37,"col_end":37,"count":1}]},{"line":"    ]","counters":[]},{"line":"    ~var_to_hlist:Checked.to_hlist ~var_of_hlist:Checked.of_hlist","counters":[]},{"line":"    ~value_of_hlist:(fun _ ->","counters":[]},{"line":"      failwith \"Side_loaded_verification_key: value_of_hlist\" )","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    ~value_to_hlist:(fun { Poly.wrap_index; max_proofs_verified; _ } ->","counters":[]},{"line":"      [ max_proofs_verified; wrap_index ] )","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":42,"col_end":42,"count":2}]}]}