{"filename":"src/lib/one_or_two/one_or_two.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Async_kernel","counters":[]},{"line":"","counters":[]},{"line":"[%%versioned","counters":[]},{"line":"module Stable = struct","counters":[]},{"line":"  module V1 = struct","counters":[]},{"line":"    type 'a t = [ `One of 'a | `Two of 'a * 'a ]","counters":[{"col_start":4,"col_end":4,"count":11},{"col_start":9,"col_end":9,"count":0},{"col_start":12,"col_end":12,"count":3},{"col_start":16,"col_end":16,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"    [@@deriving equal, compare, hash, sexp, yojson]","counters":[{"col_start":50,"col_end":50,"count":23}]},{"line":"","counters":[]},{"line":"    let to_latest a_latest = function","counters":[]},{"line":"      | `One x ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          `One (a_latest x)","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"      | `Two (x, y) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          `Two (a_latest x, a_latest y)","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"    let of_latest a_latest = function","counters":[]},{"line":"      | `One x ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let open Result.Let_syntax in","counters":[]},{"line":"          let%map x = a_latest x in","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"          `One x","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"      | `Two (x, y) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let open Result.Let_syntax in","counters":[]},{"line":"          let%map x = a_latest x and y = a_latest y in","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"          `Two (x, y)","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"  end","counters":[]},{"line":"end]","counters":[]},{"line":"","counters":[]},{"line":"let length = function `One _ -> 1 | `Two _ -> 2","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"","counters":[]},{"line":"let to_list = function `One a -> [ a ] | `Two (a, b) -> [ a; b ]","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"","counters":[]},{"line":"let to_numbered_list = function","counters":[]},{"line":"  | `One a ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      [ (0, a) ]","counters":[]},{"line":"  | `Two (a, b) ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      [ (0, a); (1, b) ]","counters":[]},{"line":"","counters":[]},{"line":"let group_sequence : 'a Sequence.t -> 'a t Sequence.t =","counters":[]},{"line":" fun to_group ->","counters":[]},{"line":"  Sequence.unfold ~init:to_group ~f:(fun acc ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      match Sequence.next acc with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          None","counters":[]},{"line":"      | Some (a, rest_1) -> (","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          match Sequence.next rest_1 with","counters":[]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Some (`One a, Sequence.empty)","counters":[]},{"line":"          | Some (b, rest_2) ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Some (`Two (a, b), rest_2) ) )","counters":[]},{"line":"","counters":[]},{"line":"let group_list : 'a list -> 'a t list =","counters":[]},{"line":" fun xs -> xs |> Sequence.of_list |> group_sequence |> Sequence.to_list","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"","counters":[]},{"line":"let zip : 'a t -> 'b t -> ('a * 'b) t Or_error.t =","counters":[]},{"line":" fun a b ->","counters":[]},{"line":"  match (a, b) with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | `One a1, `One b1 ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Ok (`One (a1, b1))","counters":[]},{"line":"  | `Two (a1, a2), `Two (b1, b2) ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Ok (`Two ((a1, b1), (a2, b2)))","counters":[]},{"line":"  | _ ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Or_error.error_string \"One_or_two.zip mismatched\"","counters":[]},{"line":"","counters":[]},{"line":"let zip_exn : 'a t -> 'b t -> ('a * 'b) t =","counters":[]},{"line":" fun a b -> Or_error.ok_exn @@ zip a b","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"","counters":[]},{"line":"module Monadic2 (M : Monad.S2) :","counters":[]},{"line":"  Intfs.Monadic2 with type ('a, 'e) m := ('a, 'e) M.t = struct","counters":[]},{"line":"  let sequence : ('a, 'e) M.t t -> ('a t, 'e) M.t = function","counters":[]},{"line":"    | `One def ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        M.map def ~f:(fun x -> `One x)","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"    | `Two (def1, def2) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let open M.Let_syntax in","counters":[]},{"line":"        let%bind a = def1 in","counters":[]},{"line":"        let%map b = def2 in","counters":[]},{"line":"        `Two (a, b)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"  let map : 'a t -> f:('a -> ('b, 'e) M.t) -> ('b t, 'e) M.t =","counters":[]},{"line":"   fun t ~f ->","counters":[]},{"line":"    (* We could use sequence here, but this approach saves us computation in the","counters":[]},{"line":"       Result and option monads when the first component of a `Two fails. *)","counters":[]},{"line":"    match t with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | `One a ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        M.map ~f:(fun x -> `One x) (f a)","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"    | `Two (a, b) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let open M.Let_syntax in","counters":[]},{"line":"        let%bind a' = f a in","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"        let%map b' = f b in","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"        `Two (a', b')","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"  let fold :","counters":[]},{"line":"         'a t","counters":[]},{"line":"      -> init:'accum","counters":[]},{"line":"      -> f:('accum -> 'a -> ('accum, 'e) M.t)","counters":[]},{"line":"      -> ('accum, 'e) M.t =","counters":[]},{"line":"   fun t ~init ~f ->","counters":[]},{"line":"    match t with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | `One a ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        f init a","counters":[]},{"line":"    | `Two (a, b) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        M.bind (f init a) ~f:(fun x -> f x b)","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Monadic (M : Monad.S) : Intfs.Monadic with type 'a m := 'a M.t =","counters":[]},{"line":"  Monadic2 (Base__.Monad_intf.S_to_S2 (M))","counters":[]},{"line":"","counters":[]},{"line":"module Deferred_result = Monadic2 (Deferred.Result)","counters":[]},{"line":"module Ident = Monadic (Monad.Ident)","counters":[]},{"line":"module Deferred = Monadic (Deferred)","counters":[]},{"line":"module Option = Monadic (Option)","counters":[]},{"line":"module Or_error = Monadic (Or_error)","counters":[]},{"line":"","counters":[]},{"line":"let map = Ident.map","counters":[]},{"line":"","counters":[]},{"line":"let fold = Ident.fold","counters":[]},{"line":"","counters":[]},{"line":"let iter t ~f = match t with `One a -> f a | `Two (a, b) -> f a ; f b","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"","counters":[]},{"line":"let fold_until ~init ~f ~finish t =","counters":[]},{"line":"  Container.fold_until ~fold ~init ~f ~finish t","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let gen inner_gen =","counters":[]},{"line":"  Quickcheck.Generator.(","counters":[{"col_start":2,"col_end":2,"count":2}]},{"line":"    union","counters":[]},{"line":"      [ map inner_gen ~f:(fun x -> `One x)","counters":[{"col_start":10,"col_end":10,"count":2},{"col_start":35,"col_end":35,"count":0}]},{"line":"      ; map (tuple2 inner_gen inner_gen) ~f:(fun pair -> `Two pair)","counters":[{"col_start":10,"col_end":10,"count":2},{"col_start":18,"col_end":18,"count":2},{"col_start":57,"col_end":57,"count":0}]},{"line":"      ])","counters":[]}]}