{"filename":"src/lib/pickles/sponge_inputs.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"module type Field = sig","counters":[]},{"line":"  include Sponge.Intf.Field","counters":[]},{"line":"","counters":[]},{"line":"  val square : t -> t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make","counters":[]},{"line":"    (Impl : Snarky_backendless.Snark_intf.Run) (B : sig","counters":[]},{"line":"      open Impl","counters":[]},{"line":"","counters":[]},{"line":"      val params : field Sponge.Params.t","counters":[]},{"line":"","counters":[]},{"line":"      val to_the_alpha : field -> field","counters":[]},{"line":"","counters":[]},{"line":"      module Operations : sig","counters":[]},{"line":"        val apply_affine_map :","counters":[]},{"line":"          field array array * field array -> field array -> field array","counters":[]},{"line":"      end","counters":[]},{"line":"    end) =","counters":[]},{"line":"struct","counters":[]},{"line":"  include Make_sponge.Rounds","counters":[]},{"line":"","counters":[]},{"line":"  let round_table start =","counters":[]},{"line":"    let ({ round_constants; mds } : _ Sponge.Params.t) = B.params in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    (* sbox -> mds -> ark *)","counters":[]},{"line":"    let apply_round i s =","counters":[]},{"line":"      let s' = Array.map s ~f:B.to_the_alpha in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      B.Operations.apply_affine_map (mds, round_constants.(i)) s'","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    in","counters":[]},{"line":"    let res =","counters":[]},{"line":"      Array.init (rounds_full + 1) ~f:(fun _ ->","counters":[]},{"line":"          Array.create ~len:3 Impl.Field.Constant.zero )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    in","counters":[]},{"line":"    res.(0) <- start ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    for i = 0 to rounds_full - 1 do","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      res.(i + 1) <- apply_round i res.(i)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"    done ;","counters":[]},{"line":"    res","counters":[]},{"line":"","counters":[]},{"line":"  open Impl","counters":[]},{"line":"  open Field","counters":[]},{"line":"  module Field = Field","counters":[]},{"line":"","counters":[]},{"line":"  let block_cipher (params : _ Sponge.Params.t) init =","counters":[]},{"line":"    Impl.with_label __LOC__ (fun () ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        let t =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          exists","counters":[]},{"line":"            (Typ.array","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"               ~length:Int.(rounds_full + 1)","counters":[]},{"line":"               (Typ.array ~length:3 Field.typ) )","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"            ~compute:","counters":[]},{"line":"              As_prover.(fun () -> round_table (Array.map init ~f:read_var))","counters":[{"col_start":35,"col_end":35,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"        in","counters":[]},{"line":"        t.(0) <- init ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        (let open Kimchi_backend_common.Plonk_constraint_system.Plonk_constraint in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        with_label __LOC__ (fun () ->","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"            Impl.assert_","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              { basic = T (Poseidon { state = t })","counters":[]},{"line":"              ; annotation = Some \"plonk-poseidon\"","counters":[]},{"line":"              } )) ;","counters":[]},{"line":"        t.(Int.(Array.length t - 1)) )","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"","counters":[]},{"line":"  let add_assign ~state i x =","counters":[]},{"line":"    state.(i) <- Util.seal (module Impl) (state.(i) + x)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"  let copy = Array.copy","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}