{"filename":"src/lib/merkle_mask/masking_merkle_tree_intf.ml","lines":[{"line":"(* masking_merkle_tree_intf.ml *)","counters":[]},{"line":"(* the type of a Merkle tree mask associated with a parent Merkle tree *)","counters":[{"col_start":73,"col_end":73,"count":1}]},{"line":"module type S = sig","counters":[]},{"line":"  type t","counters":[]},{"line":"","counters":[]},{"line":"  type unattached = t","counters":[]},{"line":"","counters":[]},{"line":"  type parent","counters":[]},{"line":"","counters":[]},{"line":"  type account","counters":[]},{"line":"","counters":[]},{"line":"  type location","counters":[]},{"line":"","counters":[]},{"line":"  type hash","counters":[]},{"line":"","counters":[]},{"line":"  type key","counters":[]},{"line":"","counters":[]},{"line":"  type token_id","counters":[]},{"line":"","counters":[]},{"line":"  type token_id_set","counters":[]},{"line":"","counters":[]},{"line":"  type account_id","counters":[]},{"line":"","counters":[]},{"line":"  type account_id_set","counters":[]},{"line":"","counters":[]},{"line":"  module Location : Merkle_ledger.Location_intf.S","counters":[]},{"line":"","counters":[]},{"line":"  module Addr = Location.Addr","counters":[]},{"line":"","counters":[]},{"line":"  (** create a mask with no parent *)","counters":[]},{"line":"  val create : depth:int -> unit -> t","counters":[]},{"line":"","counters":[]},{"line":"  val get_uuid : t -> Uuid.t","counters":[]},{"line":"","counters":[]},{"line":"  module Attached : sig","counters":[]},{"line":"    include","counters":[]},{"line":"      Base_merkle_tree_intf.S","counters":[]},{"line":"        with module Addr = Addr","counters":[]},{"line":"        with module Location = Location","counters":[]},{"line":"        with type account := account","counters":[]},{"line":"         and type root_hash := hash","counters":[]},{"line":"         and type hash := hash","counters":[]},{"line":"         and type key := key","counters":[]},{"line":"         and type token_id := token_id","counters":[]},{"line":"         and type token_id_set := token_id_set","counters":[]},{"line":"         and type account_id := account_id","counters":[]},{"line":"         and type account_id_set := account_id_set","counters":[]},{"line":"","counters":[]},{"line":"    exception","counters":[]},{"line":"      Dangling_parent_reference of","counters":[]},{"line":"        Uuid.t * (* Location where null was set*) string","counters":[]},{"line":"","counters":[]},{"line":"    (* (\\** get hash from mask, if present, else from its parent *\\)","counters":[]},{"line":"     * val get_hash : t -> Addr.t -> hash option *)","counters":[]},{"line":"","counters":[]},{"line":"    (** commit all state to the parent, flush state locally *)","counters":[]},{"line":"    val commit : t -> unit","counters":[]},{"line":"","counters":[]},{"line":"    (** [unset_parent ?trigger_signal ~loc:__LOC__ t] detaches the parent from","counters":[]},{"line":"        [t]. The [loc] argument is shown in the [Dangling_parent_reference]","counters":[]},{"line":"        exception, which will be raised if [t] is used while no parent is","counters":[]},{"line":"        registered.","counters":[]},{"line":"","counters":[]},{"line":"        If the [trigger_signal] optional argument is [true] or omitted,","counters":[]},{"line":"        [detached_signal] for [t] will be resolved. This should only be set to","counters":[]},{"line":"        [false] when the mask will be reparented.","counters":[]},{"line":"    *)","counters":[]},{"line":"    (* val unset_parent : ?trigger_signal:bool -> loc:string -> t -> unattached *)","counters":[]},{"line":"","counters":[]},{"line":"    (* val get_parent : t -> t *)","counters":[]},{"line":"","counters":[]},{"line":"    (** get mask parent *)","counters":[]},{"line":"    (* val get_parent : t -> parent *)","counters":[]},{"line":"","counters":[]},{"line":"    (** called when parent sets an account; update local state *)","counters":[]},{"line":"    (* val parent_set_notify : t -> account -> unit *)","counters":[]},{"line":"","counters":[]},{"line":"    val copy : t -> t","counters":[]},{"line":"","counters":[]},{"line":"    (* makes new mask instance with copied tables, re-use parent *)","counters":[]},{"line":"","counters":[]},{"line":"    (** already have module For_testing from include above *)","counters":[]},{"line":"    module For_testing : sig","counters":[]},{"line":"      val location_in_mask : t -> location -> bool","counters":[]},{"line":"","counters":[]},{"line":"      val address_in_mask : t -> Addr.t -> bool","counters":[]},{"line":"","counters":[]},{"line":"      val current_location : t -> Location.t option","counters":[]},{"line":"    end","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  val set_parent : unattached -> parent -> Attached.t","counters":[]},{"line":"  (* val set_parent : unattached -> t -> Attached.t *)","counters":[]},{"line":"","counters":[]},{"line":"  (** tell mask about parent *)","counters":[]},{"line":"  (* val set_parent : unattached -> parent -> Attached.t *)","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}