{"filename":"src/lib/pickles/impls.ml","lines":[{"line":"open Pickles_types","counters":[]},{"line":"open Core_kernel","counters":[]},{"line":"open Import","counters":[]},{"line":"open Backend","counters":[]},{"line":"module Wrap_impl = Snarky_backendless.Snark.Run.Make (Tock)","counters":[]},{"line":"","counters":[]},{"line":"(** returns [true] if the [i]th bit of [x] is set to 1 *)","counters":[]},{"line":"let test_bit x i = B.(shift_right x i land one = one)","counters":[{"col_start":19,"col_end":19,"count":4},{"col_start":32,"col_end":32,"count":4}]},{"line":"","counters":[]},{"line":"(* TODO: I think there are other forbidden values as well. *)","counters":[]},{"line":"","counters":[]},{"line":"(** returns all the values that can fit in [~size_in_bits] bits and that are","counters":[]},{"line":" * either congruent with -2^[~size_in_bits] mod [~modulus] ","counters":[]},{"line":" * or congruent with -2^[~size_in_bits] - 1 mod [~modulus] ","counters":[]},{"line":" *)","counters":[]},{"line":"let forbidden_shifted_values ~modulus:r ~size_in_bits =","counters":[]},{"line":"  let two_to_n = B.(pow (of_int 2) (of_int size_in_bits)) in","counters":[{"col_start":2,"col_end":2,"count":2},{"col_start":22,"col_end":22,"count":2},{"col_start":30,"col_end":30,"count":2},{"col_start":41,"col_end":41,"count":2}]},{"line":"  (* this function doesn't make sense if the modulus is smaller *)","counters":[]},{"line":"  assert (B.(r < two_to_n)) ;","counters":[{"col_start":9,"col_end":9,"count":2}]},{"line":"  let neg_two_to_n = B.(neg two_to_n) in","counters":[{"col_start":26,"col_end":26,"count":2}]},{"line":"  let representatives x =","counters":[]},{"line":"    let open Sequence in","counters":[{"col_start":4,"col_end":4,"count":4}]},{"line":"    (* All values equivalent to x mod r that fit in [size_in_bits]","counters":[]},{"line":"       many bits. *)","counters":[]},{"line":"    let fits_in_n_bits x = B.(x < two_to_n) in","counters":[{"col_start":27,"col_end":27,"count":12}]},{"line":"    unfold ~init:B.(x % r) ~f:(fun x -> Some (x, B.(x + r)))","counters":[{"col_start":22,"col_end":22,"count":4},{"col_start":40,"col_end":40,"count":12}]},{"line":"    |> take_while ~f:fits_in_n_bits","counters":[{"col_start":16,"col_end":16,"count":4}]},{"line":"    |> to_list","counters":[]},{"line":"  in","counters":[]},{"line":"  List.concat_map [ neg_two_to_n; B.(neg_two_to_n - one) ] ~f:representatives","counters":[{"col_start":16,"col_end":16,"count":2}]},{"line":"  |> List.dedup_and_sort ~compare:B.compare","counters":[]},{"line":"","counters":[]},{"line":"module Step = struct","counters":[]},{"line":"  module Impl = Snarky_backendless.Snark.Run.Make (Tick)","counters":[]},{"line":"  include Impl","counters":[]},{"line":"  module Verification_key = Tick.Verification_key","counters":[]},{"line":"  module Proving_key = Tick.Proving_key","counters":[]},{"line":"","counters":[]},{"line":"  module Keypair = struct","counters":[]},{"line":"    type t = { pk : Proving_key.t; vk : Verification_key.t } [@@deriving fields]","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":9,"col_end":9,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"    let create = Fields.create","counters":[]},{"line":"","counters":[]},{"line":"    let generate ~prev_challenges cs =","counters":[]},{"line":"      let open Tick.Keypair in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let keypair = create ~prev_challenges cs in","counters":[]},{"line":"      { pk = pk keypair; vk = vk keypair }","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":14,"col_end":14,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Other_field = struct","counters":[]},{"line":"    (* Tick.Field.t = p < q = Tock.Field.t *)","counters":[]},{"line":"    let size_in_bits = Tock.Field.size_in_bits","counters":[]},{"line":"","counters":[]},{"line":"    module Constant = Tock.Field","counters":[]},{"line":"","counters":[]},{"line":"    type t = (* Low bits, high bit *)","counters":[]},{"line":"      Field.t * Boolean.var","counters":[]},{"line":"","counters":[]},{"line":"    let forbidden_shifted_values =","counters":[]},{"line":"      let size_in_bits = Constant.size_in_bits in","counters":[]},{"line":"      let other_mod = Wrap_impl.Bigint.to_bignum_bigint Constant.size in","counters":[]},{"line":"      let values = forbidden_shifted_values ~size_in_bits ~modulus:other_mod in","counters":[{"col_start":6,"col_end":6,"count":1}]},{"line":"      let f x =","counters":[]},{"line":"        let hi = test_bit x (Field.size_in_bits - 1) in","counters":[{"col_start":8,"col_end":8,"count":4}]},{"line":"        let lo = B.shift_right x 1 in","counters":[{"col_start":8,"col_end":8,"count":4}]},{"line":"        let lo =","counters":[{"col_start":8,"col_end":8,"count":4}]},{"line":"          (* IMPORTANT: in practice we should filter such values","counters":[]},{"line":"             see: https://github.com/MinaProtocol/mina/pull/9324/commits/82b14cd7f11fb938ab6d88aac19516bd7ea05e94","counters":[]},{"line":"             but the circuit needs to remain the same, which is to use 0 when a value is larger than the modulus here (tested by the unit test below)","counters":[]},{"line":"          *)","counters":[]},{"line":"          let modulus = Impl.Field.size in","counters":[]},{"line":"          if B.compare modulus lo <= 0 then Tick.Field.zero","counters":[{"col_start":21,"col_end":21,"count":4},{"col_start":44,"col_end":44,"count":0}]},{"line":"          else Impl.Bigint.(to_field (of_bignum_bigint lo))","counters":[{"col_start":15,"col_end":15,"count":4},{"col_start":35,"col_end":35,"count":4},{"col_start":53,"col_end":53,"count":4}]},{"line":"        in","counters":[]},{"line":"        (lo, hi)","counters":[]},{"line":"      in","counters":[]},{"line":"      values |> List.map ~f","counters":[{"col_start":23,"col_end":23,"count":1}]},{"line":"","counters":[]},{"line":"    let%test_unit \"preserve circuit behavior for Step\" =","counters":[]},{"line":"      let expected_list =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [ (\"45560315531506369815346746415080538112\", false)","counters":[]},{"line":"        ; (\"45560315531506369815346746415080538113\", false)","counters":[]},{"line":"        ; ( \"14474011154664524427946373126085988481727088556502330059655218120611762012161\"","counters":[]},{"line":"          , true )","counters":[]},{"line":"        ; ( \"14474011154664524427946373126085988481727088556502330059655218120611762012161\"","counters":[]},{"line":"          , true )","counters":[]},{"line":"        ]","counters":[]},{"line":"      in","counters":[]},{"line":"      let str_list =","counters":[]},{"line":"        List.map forbidden_shifted_values ~f:(fun (a, b) ->","counters":[]},{"line":"            (Tick.Field.to_string a, b) )","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"      in","counters":[]},{"line":"      assert ([%equal: (string * bool) list] str_list expected_list)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"    let typ_unchecked : (t, Constant.t) Typ.t =","counters":[]},{"line":"      Typ.transport","counters":[{"col_start":18,"col_end":18,"count":1}]},{"line":"        (Typ.tuple2 Field.typ Boolean.typ)","counters":[{"col_start":18,"col_end":18,"count":1}]},{"line":"        ~there:(fun x ->","counters":[]},{"line":"          match Tock.Field.to_bits x with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | [] ->","counters":[]},{"line":"              assert false","counters":[]},{"line":"          | low :: high ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (Field.Constant.project high, low) )","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"        ~back:(fun (high, low) ->","counters":[]},{"line":"          let high = Field.Constant.unpack high in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          Tock.Field.of_bits (low :: high) )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"    let check t =","counters":[]},{"line":"      let open Internal_Basic in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let open Let_syntax in","counters":[]},{"line":"      let equal (x1, b1) (x2, b2) =","counters":[]},{"line":"        let%bind x_eq = Field.Checked.equal x1 (Field.Var.constant x2) in","counters":[{"col_start":42,"col_end":42,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"        let b_eq = match b2 with true -> b1 | false -> Boolean.not b1 in","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":46,"col_end":46,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"        Boolean.( && ) x_eq b_eq","counters":[]},{"line":"      in","counters":[]},{"line":"      let (Typ typ_unchecked) = typ_unchecked in","counters":[]},{"line":"      make_checked_ast","counters":[]},{"line":"      @@ let%bind () = run_checked_ast @@ typ_unchecked.check t in","counters":[{"col_start":37,"col_end":37,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"         Checked.List.map forbidden_shifted_values ~f:(equal t)","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"         >>= Boolean.any >>| Boolean.not >>= Boolean.Assert.is_true","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"","counters":[]},{"line":"    let typ : _ Snarky_backendless.Typ.t =","counters":[]},{"line":"      let (Typ typ_unchecked) = typ_unchecked in","counters":[]},{"line":"      Typ { typ_unchecked with check }","counters":[]},{"line":"","counters":[]},{"line":"    let to_bits (x, b) = Field.unpack x ~length:(Field.size_in_bits - 1) @ [ b ]","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Digest = Digest.Make (Impl)","counters":[]},{"line":"  module Challenge = Challenge.Make (Impl)","counters":[]},{"line":"","counters":[]},{"line":"  let input ~proofs_verified ~wrap_rounds ~uses_lookup =","counters":[]},{"line":"    let open Types.Step.Statement in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let lookup :","counters":[]},{"line":"        ( Challenge.Constant.t","counters":[]},{"line":"        , Impl.Field.t","counters":[]},{"line":"        , Other_field.Constant.t Pickles_types.Shifted_value.Type2.t","counters":[]},{"line":"        , Other_field.t Pickles_types.Shifted_value.Type2.t )","counters":[]},{"line":"        Types.Wrap.Lookup_parameters.t =","counters":[]},{"line":"      { use = uses_lookup","counters":[]},{"line":"      ; zero =","counters":[]},{"line":"          { value =","counters":[]},{"line":"              { challenge = Limb_vector.Challenge.Constant.zero","counters":[]},{"line":"              ; scalar = Shifted_value Other_field.Constant.zero","counters":[]},{"line":"              }","counters":[]},{"line":"          ; var =","counters":[]},{"line":"              { challenge = Field.zero","counters":[]},{"line":"              ; scalar = Shifted_value (Field.zero, Boolean.false_)","counters":[]},{"line":"              }","counters":[]},{"line":"          }","counters":[]},{"line":"      }","counters":[]},{"line":"    in","counters":[]},{"line":"    let spec = spec (module Impl) proofs_verified wrap_rounds lookup in","counters":[]},{"line":"    let (T (typ, f, f_inv)) =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Spec.packed_typ","counters":[]},{"line":"        (module Impl)","counters":[]},{"line":"        (T","counters":[]},{"line":"           ( Shifted_value.Type2.typ Other_field.typ_unchecked","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"           , (fun (Shifted_value.Type2.Shifted_value x as t) ->","counters":[]},{"line":"               Impl.run_checked_ast (Other_field.check x) ;","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"               t )","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"           , Fn.id ) )","counters":[]},{"line":"        spec","counters":[]},{"line":"    in","counters":[]},{"line":"    let typ =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Typ.transport typ","counters":[]},{"line":"        ~there:(to_data ~option_map:Option.map)","counters":[]},{"line":"        ~back:(of_data ~option_map:Option.map)","counters":[]},{"line":"    in","counters":[]},{"line":"    Spec.ETyp.T","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ( typ","counters":[]},{"line":"      , (fun x -> of_data ~option_map:Plonk_types.Opt.map (f x))","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"      , fun x -> f_inv (to_data ~option_map:Plonk_types.Opt.map x) )","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Wrap = struct","counters":[]},{"line":"  module Impl = Wrap_impl","counters":[]},{"line":"  include Impl","counters":[]},{"line":"  module Challenge = Challenge.Make (Impl)","counters":[]},{"line":"  module Digest = Digest.Make (Impl)","counters":[]},{"line":"  module Wrap_field = Tock.Field","counters":[]},{"line":"  module Step_field = Tick.Field","counters":[]},{"line":"  module Verification_key = Tock.Verification_key","counters":[]},{"line":"  module Proving_key = Tock.Proving_key","counters":[]},{"line":"","counters":[]},{"line":"  module Keypair = struct","counters":[]},{"line":"    type t = { pk : Proving_key.t; vk : Verification_key.t } [@@deriving fields]","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":9,"col_end":9,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"    let create = Fields.create","counters":[]},{"line":"","counters":[]},{"line":"    let generate ~prev_challenges cs =","counters":[]},{"line":"      let open Tock.Keypair in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let keypair = create ~prev_challenges cs in","counters":[]},{"line":"      { pk = pk keypair; vk = vk keypair }","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":14,"col_end":14,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Other_field = struct","counters":[]},{"line":"    module Constant = Tick.Field","counters":[]},{"line":"    open Impl","counters":[]},{"line":"","counters":[]},{"line":"    type t = Field.t","counters":[]},{"line":"","counters":[]},{"line":"    let forbidden_shifted_values =","counters":[]},{"line":"      let other_mod = Step.Impl.Bigint.to_bignum_bigint Constant.size in","counters":[]},{"line":"      let size_in_bits = Constant.size_in_bits in","counters":[{"col_start":6,"col_end":6,"count":1}]},{"line":"      let values = forbidden_shifted_values ~size_in_bits ~modulus:other_mod in","counters":[]},{"line":"      let f x =","counters":[]},{"line":"        let modulus = Impl.Field.size in","counters":[{"col_start":8,"col_end":8,"count":4}]},{"line":"        (* IMPORTANT: in practice we should filter such values","counters":[]},{"line":"           see: https://github.com/MinaProtocol/mina/pull/9324/commits/82b14cd7f11fb938ab6d88aac19516bd7ea05e94","counters":[]},{"line":"           but the circuit needs to remain the same, which is to use 0 when a value is larger than the modulus here (tested by the unit test below)","counters":[]},{"line":"        *)","counters":[]},{"line":"        if B.compare modulus x <= 0 then Wrap_field.zero","counters":[{"col_start":19,"col_end":19,"count":4},{"col_start":41,"col_end":41,"count":2}]},{"line":"        else Impl.Bigint.(to_field (of_bignum_bigint x))","counters":[{"col_start":13,"col_end":13,"count":2},{"col_start":51,"col_end":51,"count":2}]},{"line":"      in","counters":[]},{"line":"      values |> List.map ~f","counters":[{"col_start":23,"col_end":23,"count":1}]},{"line":"","counters":[]},{"line":"    let%test_unit \"preserve circuit behavior for Wrap\" =","counters":[]},{"line":"      let expected_list =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [ \"91120631062839412180561524743370440705\"","counters":[]},{"line":"        ; \"91120631062839412180561524743370440706\"","counters":[]},{"line":"        ; \"0\"","counters":[]},{"line":"        ; \"0\"","counters":[]},{"line":"        ]","counters":[]},{"line":"      in","counters":[]},{"line":"      let str_list =","counters":[]},{"line":"        List.map forbidden_shifted_values ~f:Wrap_field.to_string","counters":[]},{"line":"      in","counters":[]},{"line":"      assert ([%equal: string list] str_list expected_list)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"","counters":[]},{"line":"    let typ_unchecked, check =","counters":[]},{"line":"      (* Tick -> Tock *)","counters":[]},{"line":"      let (Typ t0 as typ_unchecked) =","counters":[]},{"line":"        Typ.transport Field.typ","counters":[]},{"line":"          ~there:(Fn.compose Tock.Field.of_bits Tick.Field.to_bits)","counters":[{"col_start":27,"col_end":27,"count":1}]},{"line":"          ~back:(Fn.compose Tick.Field.of_bits Tock.Field.to_bits)","counters":[{"col_start":26,"col_end":26,"count":1}]},{"line":"      in","counters":[]},{"line":"      let check t =","counters":[{"col_start":6,"col_end":6,"count":1}]},{"line":"        let open Internal_Basic in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let open Let_syntax in","counters":[]},{"line":"        let equal x1 x2 = Field.Checked.equal x1 (Field.Var.constant x2) in","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"        make_checked_ast","counters":[]},{"line":"        @@ let%bind () = run_checked_ast @@ t0.check t in","counters":[{"col_start":39,"col_end":39,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"           Checked.List.map forbidden_shifted_values ~f:(equal t)","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"           >>= Boolean.any >>| Boolean.not >>= Boolean.Assert.is_true","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"      in","counters":[]},{"line":"      (typ_unchecked, check)","counters":[]},{"line":"","counters":[]},{"line":"    let typ : _ Snarky_backendless.Typ.t =","counters":[]},{"line":"      let (Typ typ_unchecked) = typ_unchecked in","counters":[]},{"line":"      Typ { typ_unchecked with check }","counters":[]},{"line":"","counters":[]},{"line":"    let to_bits x = Field.unpack x ~length:Field.size_in_bits","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let input () =","counters":[]},{"line":"    let lookup =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      { Types.Wrap.Lookup_parameters.use = No","counters":[]},{"line":"      ; zero =","counters":[]},{"line":"          { value =","counters":[]},{"line":"              { challenge = Limb_vector.Challenge.Constant.zero","counters":[]},{"line":"              ; scalar =","counters":[]},{"line":"                  Shifted_value.Type1.Shifted_value Other_field.Constant.zero","counters":[]},{"line":"              }","counters":[]},{"line":"          ; var =","counters":[]},{"line":"              { challenge = Impl.Field.zero","counters":[]},{"line":"              ; scalar = Shifted_value.Type1.Shifted_value Impl.Field.zero","counters":[]},{"line":"              }","counters":[]},{"line":"          }","counters":[]},{"line":"      }","counters":[]},{"line":"    in","counters":[]},{"line":"    let fp : (Impl.Field.t, Other_field.Constant.t) Typ.t =","counters":[]},{"line":"      Other_field.typ_unchecked","counters":[]},{"line":"    in","counters":[]},{"line":"    let open Types.Wrap.Statement in","counters":[]},{"line":"    let (T (typ, f, f_inv)) =","counters":[]},{"line":"      Spec.packed_typ","counters":[]},{"line":"        (module Impl)","counters":[]},{"line":"        (T","counters":[]},{"line":"           ( Shifted_value.Type1.typ fp","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"           , (fun (Shifted_value x as t) ->","counters":[]},{"line":"               Impl.run_checked_ast (Other_field.check x) ;","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"               t )","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"           , Fn.id ) )","counters":[]},{"line":"        (In_circuit.spec (module Impl) lookup)","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"    in","counters":[]},{"line":"    let typ =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Typ.transport typ","counters":[]},{"line":"        ~there:(In_circuit.to_data ~option_map:Option.map)","counters":[]},{"line":"        ~back:(In_circuit.of_data ~option_map:Option.map)","counters":[]},{"line":"    in","counters":[]},{"line":"    Spec.ETyp.T","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ( typ","counters":[]},{"line":"      , (fun x -> In_circuit.of_data ~option_map:Plonk_types.Opt.map (f x))","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":70,"col_end":70,"count":0}]},{"line":"      , fun x -> f_inv (In_circuit.to_data ~option_map:Plonk_types.Opt.map x) )","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}