{"filename":"src/lib/mina_ledger/ledger.ml","lines":[{"line":"open Core","counters":[]},{"line":"open Signature_lib","counters":[]},{"line":"open Merkle_ledger","counters":[]},{"line":"open Mina_base","counters":[]},{"line":"","counters":[]},{"line":"module Ledger_inner = struct","counters":[]},{"line":"  module Location_at_depth : Merkle_ledger.Location_intf.S =","counters":[]},{"line":"    Merkle_ledger.Location.T","counters":[]},{"line":"","counters":[]},{"line":"  module Location_binable = struct","counters":[]},{"line":"    module Arg = struct","counters":[]},{"line":"      type t = Location_at_depth.t =","counters":[{"col_start":6,"col_end":6,"count":1},{"col_start":11,"col_end":11,"count":2}]},{"line":"        | Generic of Location.Bigstring.Stable.Latest.t","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | Account of Location_at_depth.Addr.Stable.Latest.t","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | Hash of Location_at_depth.Addr.Stable.Latest.t","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      [@@deriving bin_io_unversioned, hash, sexp, compare]","counters":[{"col_start":57,"col_end":57,"count":4}]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    type t = Arg.t =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      | Generic of Location.Bigstring.t","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Account of Location_at_depth.Addr.t","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Hash of Location_at_depth.Addr.t","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    [@@deriving hash, sexp, compare]","counters":[]},{"line":"","counters":[]},{"line":"    include Hashable.Make_binable (Arg) [@@deriving sexp, compare, hash, yojson]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Kvdb : Intf.Key_value_database with type config := string =","counters":[]},{"line":"    Rocksdb.Database","counters":[]},{"line":"","counters":[]},{"line":"  module Storage_locations : Intf.Storage_locations = struct","counters":[]},{"line":"    let key_value_db_dir = \"coda_key_value_db\"","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Hash = struct","counters":[]},{"line":"    module Arg = struct","counters":[]},{"line":"      type t = Ledger_hash.Stable.Latest.t","counters":[{"col_start":6,"col_end":6,"count":1},{"col_start":11,"col_end":11,"count":1}]},{"line":"      [@@deriving sexp, compare, hash, bin_io_unversioned]","counters":[{"col_start":57,"col_end":57,"count":4}]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type t = Ledger_hash.Stable.V1.t","counters":[{"col_start":8,"col_end":8,"count":2},{"col_start":13,"col_end":13,"count":1},{"col_start":17,"col_end":17,"count":0}]},{"line":"        [@@deriving sexp, compare, hash, equal, yojson]","counters":[{"col_start":54,"col_end":54,"count":5}]},{"line":"","counters":[]},{"line":"        type _unused = unit constraint t = Arg.t","counters":[]},{"line":"","counters":[]},{"line":"        let to_latest = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"        include Hashable.Make_binable (Arg)","counters":[]},{"line":"","counters":[]},{"line":"        let to_base58_check = Ledger_hash.to_base58_check","counters":[]},{"line":"","counters":[]},{"line":"        let merge = Ledger_hash.merge","counters":[]},{"line":"","counters":[]},{"line":"        let hash_account = Fn.compose Ledger_hash.of_digest Account.digest","counters":[{"col_start":36,"col_end":36,"count":1}]},{"line":"","counters":[]},{"line":"        let empty_account = Ledger_hash.of_digest Account.empty_digest","counters":[{"col_start":48,"col_end":48,"count":1}]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Account = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V2 = struct","counters":[]},{"line":"        type t = Account.Stable.V2.t [@@deriving equal, compare, sexp]","counters":[{"col_start":8,"col_end":8,"count":2},{"col_start":13,"col_end":13,"count":1},{"col_start":69,"col_end":69,"count":5}]},{"line":"","counters":[]},{"line":"        let to_latest = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"        let identifier = Account.identifier","counters":[]},{"line":"","counters":[]},{"line":"        let balance Account.Poly.{ balance; _ } = balance","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"","counters":[]},{"line":"        let empty = Account.empty","counters":[]},{"line":"","counters":[]},{"line":"        let token = Account.Poly.token_id","counters":[]},{"line":"","counters":[]},{"line":"        let token_owner ({ token_permissions; _ } : t) =","counters":[]},{"line":"          match token_permissions with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | Token_owned _ ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              true","counters":[]},{"line":"          | Not_owned _ ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              false","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    let empty = Stable.Latest.empty","counters":[]},{"line":"","counters":[]},{"line":"    let initialize = Account.initialize","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Inputs = struct","counters":[]},{"line":"    module Key = Public_key.Compressed","counters":[]},{"line":"    module Token_id = Token_id","counters":[]},{"line":"    module Account_id = Account_id","counters":[]},{"line":"    module Balance = Currency.Balance","counters":[]},{"line":"    module Account = Account.Stable.Latest","counters":[]},{"line":"    module Hash = Hash.Stable.Latest","counters":[]},{"line":"    module Kvdb = Kvdb","counters":[]},{"line":"    module Location = Location_at_depth","counters":[]},{"line":"    module Location_binable = Location_binable","counters":[]},{"line":"    module Storage_locations = Storage_locations","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Db :","counters":[]},{"line":"    Merkle_ledger.Database_intf.S","counters":[]},{"line":"      with module Location = Location_at_depth","counters":[]},{"line":"      with module Addr = Location_at_depth.Addr","counters":[]},{"line":"      with type root_hash := Ledger_hash.t","counters":[]},{"line":"       and type hash := Ledger_hash.t","counters":[]},{"line":"       and type key := Public_key.Compressed.t","counters":[]},{"line":"       and type token_id := Token_id.t","counters":[]},{"line":"       and type token_id_set := Token_id.Set.t","counters":[]},{"line":"       and type account := Account.t","counters":[]},{"line":"       and type account_id_set := Account_id.Set.t","counters":[]},{"line":"       and type account_id := Account_id.t =","counters":[]},{"line":"    Database.Make (Inputs)","counters":[]},{"line":"","counters":[]},{"line":"  module Null = Null_ledger.Make (Inputs)","counters":[]},{"line":"","counters":[]},{"line":"  module Any_ledger :","counters":[]},{"line":"    Merkle_ledger.Any_ledger.S","counters":[]},{"line":"      with module Location = Location_at_depth","counters":[]},{"line":"      with type account := Account.t","counters":[]},{"line":"       and type key := Public_key.Compressed.t","counters":[]},{"line":"       and type token_id := Token_id.t","counters":[]},{"line":"       and type token_id_set := Token_id.Set.t","counters":[]},{"line":"       and type account_id := Account_id.t","counters":[]},{"line":"       and type account_id_set := Account_id.Set.t","counters":[]},{"line":"       and type hash := Hash.t =","counters":[]},{"line":"    Merkle_ledger.Any_ledger.Make_base (Inputs)","counters":[]},{"line":"","counters":[]},{"line":"  module Mask :","counters":[]},{"line":"    Merkle_mask.Masking_merkle_tree_intf.S","counters":[]},{"line":"      with module Location = Location_at_depth","counters":[]},{"line":"       and module Attached.Addr = Location_at_depth.Addr","counters":[]},{"line":"      with type account := Account.t","counters":[]},{"line":"       and type key := Public_key.Compressed.t","counters":[]},{"line":"       and type token_id := Token_id.t","counters":[]},{"line":"       and type token_id_set := Token_id.Set.t","counters":[]},{"line":"       and type account_id := Account_id.t","counters":[]},{"line":"       and type account_id_set := Account_id.Set.t","counters":[]},{"line":"       and type hash := Hash.t","counters":[]},{"line":"       and type location := Location_at_depth.t","counters":[]},{"line":"       and type parent := Any_ledger.M.t =","counters":[]},{"line":"  Merkle_mask.Masking_merkle_tree.Make (struct","counters":[]},{"line":"    include Inputs","counters":[]},{"line":"    module Base = Any_ledger.M","counters":[]},{"line":"  end)","counters":[]},{"line":"","counters":[]},{"line":"  module Maskable :","counters":[]},{"line":"    Merkle_mask.Maskable_merkle_tree_intf.S","counters":[]},{"line":"      with module Location = Location_at_depth","counters":[]},{"line":"      with module Addr = Location_at_depth.Addr","counters":[]},{"line":"      with type account := Account.t","counters":[]},{"line":"       and type key := Public_key.Compressed.t","counters":[]},{"line":"       and type token_id := Token_id.t","counters":[]},{"line":"       and type token_id_set := Token_id.Set.t","counters":[]},{"line":"       and type account_id := Account_id.t","counters":[]},{"line":"       and type account_id_set := Account_id.Set.t","counters":[]},{"line":"       and type hash := Hash.t","counters":[]},{"line":"       and type root_hash := Hash.t","counters":[]},{"line":"       and type unattached_mask := Mask.t","counters":[]},{"line":"       and type attached_mask := Mask.Attached.t","counters":[]},{"line":"       and type t := Any_ledger.M.t =","counters":[]},{"line":"  Merkle_mask.Maskable_merkle_tree.Make (struct","counters":[]},{"line":"    include Inputs","counters":[]},{"line":"    module Base = Any_ledger.M","counters":[]},{"line":"    module Mask = Mask","counters":[]},{"line":"","counters":[]},{"line":"    let mask_to_base m = Any_ledger.cast (module Mask.Attached) m","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"  end)","counters":[]},{"line":"","counters":[]},{"line":"  include Mask.Attached","counters":[]},{"line":"  (* module Debug = Maskable.Debug *)","counters":[]},{"line":"","counters":[]},{"line":"  type maskable_ledger = t","counters":[]},{"line":"","counters":[]},{"line":"  let of_database db =","counters":[]},{"line":"    (* Printf.eprintf \"MY_LOG.MINA_LEDGER.LEDGER.of_database\\n%!\" ; *)","counters":[]},{"line":"    (* let casted = Any_ledger.cast (module Db) db in *)","counters":[]},{"line":"    let depth = Db.depth db in","counters":[{"col_start":4,"col_end":4,"count":2}]},{"line":"    let casted = Any_ledger.cast_database_to_mask (module Db) db in","counters":[{"col_start":4,"col_end":4,"count":2}]},{"line":"    let mask = Mask.create ~depth () in","counters":[{"col_start":4,"col_end":4,"count":2}]},{"line":"    (* let mask = Mask.create ~depth:(Db.depth db) () in *)","counters":[]},{"line":"    Maskable.register_mask casted mask","counters":[{"col_start":4,"col_end":4,"count":2}]},{"line":"","counters":[]},{"line":"  (* Mask.Attached.create () fails, can't create an attached mask directly","counters":[]},{"line":"     shadow create in order to create an attached mask","counters":[]},{"line":"  *)","counters":[]},{"line":"  let create ?directory_name ~depth () =","counters":[]},{"line":"    (* Printf.eprintf \"MY_LOG.MINA_LEDGER.LEDGER.create\\n%!\" ; *)","counters":[]},{"line":"    of_database (Db.create ?directory_name ~depth ())","counters":[{"col_start":4,"col_end":4,"count":2},{"col_start":25,"col_end":25,"count":2}]},{"line":"","counters":[]},{"line":"  (* let create_ephemeral_with_base ~depth () =","counters":[]},{"line":"   *   Printf.eprintf \"MY_LOG.MINA_LEDGER.LEDGER.create_ephemeral_with_base\\n%!\" ;","counters":[]},{"line":"   *   let maskable = Null.create ~depth () in","counters":[]},{"line":"   *   let casted = Any_ledger.cast (module Null) maskable in","counters":[]},{"line":"   *   let parent = Mask.create ~depth () in","counters":[]},{"line":"   *   let parent_casted = Any_ledger.cast (module Null) parent in","counters":[]},{"line":"   *   let mask = Mask.create ~depth () in","counters":[]},{"line":"   *   (casted, Maskable.register_mask parent_casted mask)","counters":[]},{"line":"   *","counters":[]},{"line":"   * let create_ephemeral ~depth () =","counters":[]},{"line":"   *   Printf.eprintf \"MY_LOG.MINA_LEDGER.LEDGER.create_ephemeral\\n%!\" ;","counters":[]},{"line":"   *   let _base, mask = create_ephemeral_with_base ~depth () in","counters":[]},{"line":"   *   mask *)","counters":[]},{"line":"","counters":[]},{"line":"  let create_ephemeral_with_base ~depth () =","counters":[]},{"line":"    (*Printf.eprintf \"MY_LOG.MINA_LEDGER.LEDGER.create_ephemeral_with_base\\n%!\" ;*)","counters":[]},{"line":"    let maskable = Null.create ~depth () in","counters":[{"col_start":4,"col_end":4,"count":1}]},{"line":"    let casted = Any_ledger.cast (module Null) maskable in","counters":[{"col_start":4,"col_end":4,"count":1}]},{"line":"    let mask = Mask.create ~depth () in","counters":[{"col_start":4,"col_end":4,"count":1}]},{"line":"    (casted, Maskable.register_mask casted mask)","counters":[{"col_start":4,"col_end":4,"count":1},{"col_start":34,"col_end":34,"count":1}]},{"line":"","counters":[]},{"line":"  let create_ephemeral ~depth () =","counters":[]},{"line":"    (*Printf.eprintf \"MY_LOG.MINA_LEDGER.LEDGER.create_ephemeral\\n%!\" ;*)","counters":[]},{"line":"    let _base, mask = create_ephemeral_with_base ~depth () in","counters":[{"col_start":4,"col_end":4,"count":1}]},{"line":"    mask","counters":[{"col_start":4,"col_end":4,"count":1}]},{"line":"","counters":[]},{"line":"  (** Create a new empty ledger.","counters":[]},{"line":"","counters":[]},{"line":"      Warning: This skips mask registration, for use in transaction logic,","counters":[]},{"line":"      where we always have either 0 or 1 masks, and the mask is always either","counters":[]},{"line":"      committed or discarded. This function is deliberately not exposed in the","counters":[]},{"line":"      public API of this module.","counters":[]},{"line":"","counters":[]},{"line":"      This should *NOT* be used to create a ledger for other purposes.","counters":[]},{"line":"  *)","counters":[]},{"line":"  let empty ~depth () =","counters":[]},{"line":"    (*Printf.eprintf \"MY_LOG.MINA_LEDGER.LEDGER.empty\\n%!\" ;*)","counters":[]},{"line":"    let mask = Mask.create ~depth () in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    (* We don't register the mask here. This is only used in transaction logic,","counters":[]},{"line":"       where we don't want to unregister. Transaction logic is also","counters":[]},{"line":"       synchronous, so we don't need to worry that our mask will be reparented.","counters":[]},{"line":"    *)","counters":[]},{"line":"    Mask.set_parent mask (Any_ledger.cast (module Null) (Null.create ~depth ()))","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"","counters":[]},{"line":"  (** Create a ledger as a mask on top of the existing ledger.","counters":[]},{"line":"","counters":[]},{"line":"      Warning: This skips mask registration, for use in transaction logic,","counters":[]},{"line":"      where we always have either 0 or 1 masks, and the mask is always either","counters":[]},{"line":"      committed or discarded. This function is deliberately not exposed in the","counters":[]},{"line":"      public API of this module.","counters":[]},{"line":"","counters":[]},{"line":"      This should *NOT* be used to create a ledger for other purposes.","counters":[]},{"line":"  *)","counters":[]},{"line":"  let create_masked (t : t) : t =","counters":[]},{"line":"    let mask = Mask.create ~depth:(depth t) () in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"    (* We don't register the mask here. This is only used in transaction logic,","counters":[]},{"line":"       where we don't want to unregister. Transaction logic is also","counters":[]},{"line":"       synchronous, so we don't need to worry that our mask will be reparented.","counters":[]},{"line":"    *)","counters":[]},{"line":"    Mask.set_parent mask (Any_ledger.cast (module Mask.Attached) t)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"  (** Apply a mask to a ledger.","counters":[]},{"line":"","counters":[]},{"line":"      Warning: The first argument is ignored, instead calling [commit]","counters":[]},{"line":"      directly. This is used to support the different ledger kinds in","counters":[]},{"line":"      transaction logic, where some of the 'masks' returned by [create_masked]","counters":[]},{"line":"      do not hold a reference to their parent. This function is deliberately","counters":[]},{"line":"      not exposed in the public API of this module.","counters":[]},{"line":"","counters":[]},{"line":"      This should *NOT* be used to apply a mask for other purposes.","counters":[]},{"line":"  *)","counters":[]},{"line":"  let apply_mask (_t : t) ~(masked : t) = commit masked","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"","counters":[]},{"line":"  let with_ledger ~depth ~f =","counters":[]},{"line":"    let ledger = create ~depth () in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    try","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let result = f ledger in","counters":[]},{"line":"      close ledger ; result","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"    with exn -> close ledger ; raise exn","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"","counters":[]},{"line":"  let with_ephemeral_ledger ~depth ~f =","counters":[]},{"line":"    let _base_ledger, masked_ledger = create_ephemeral_with_base ~depth () in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    try","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let result = f masked_ledger in","counters":[]},{"line":"      let (_ : Mask.t) =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Maskable.unregister_mask_exn ~loc:__LOC__ ~grandchildren:`Recursive","counters":[]},{"line":"          masked_ledger","counters":[]},{"line":"      in","counters":[]},{"line":"      result","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    with exn ->","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"      let (_ : Mask.t) =","counters":[]},{"line":"        Maskable.unregister_mask_exn ~loc:__LOC__ ~grandchildren:`Recursive","counters":[]},{"line":"          masked_ledger","counters":[]},{"line":"      in","counters":[]},{"line":"      raise exn","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"  let packed t = Any_ledger.cast (module Mask.Attached) t","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"","counters":[]},{"line":"  let register_mask t mask = Maskable.register_mask (packed t) mask","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"","counters":[]},{"line":"  let unregister_mask_exn ~loc mask = Maskable.unregister_mask_exn ~loc mask","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"","counters":[]},{"line":"  let remove_and_reparent_exn t t_as_mask =","counters":[]},{"line":"    Maskable.remove_and_reparent_exn (packed t) t_as_mask","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"","counters":[]},{"line":"  type unattached_mask = Mask.t","counters":[]},{"line":"","counters":[]},{"line":"  type attached_mask = Mask.Attached.t","counters":[]},{"line":"","counters":[]},{"line":"  (* inside MaskedLedger, the functor argument has assigned to location, account, and path","counters":[]},{"line":"     but the module signature for the functor result wants them, so we declare them here *)","counters":[]},{"line":"  type location = Location.t","counters":[]},{"line":"","counters":[]},{"line":"  (* TODO: Don't allocate: see Issue #1191 *)","counters":[]},{"line":"  let fold_until t ~init ~f ~finish =","counters":[]},{"line":"    let accounts = to_list t in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    List.fold_until accounts ~init ~f ~finish","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let create_new_account_exn t account_id account =","counters":[]},{"line":"    let action, _ =","counters":[{"col_start":4,"col_end":4,"count":38}]},{"line":"      get_or_create_account t account_id account |> Or_error.ok_exn","counters":[{"col_start":52,"col_end":52,"count":38}]},{"line":"    in","counters":[]},{"line":"    if [%equal: [ `Existed | `Added ]] action `Existed then","counters":[{"col_start":4,"col_end":4,"count":38},{"col_start":16,"col_end":16,"count":114}]},{"line":"      failwith","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (sprintf","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"           !\"Could not create a new account with pk \\","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"             %{sexp:Public_key.Compressed.t}: Account already exists\"","counters":[]},{"line":"           (Account_id.public_key account_id) )","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"","counters":[]},{"line":"  let create_new_account t account_id account =","counters":[]},{"line":"    Or_error.try_with (fun () -> create_new_account_exn t account_id account)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"","counters":[]},{"line":"  (* shadows definition in MaskedLedger, extra assurance hash is of right type  *)","counters":[]},{"line":"  let merkle_root t =","counters":[]},{"line":"    Ledger_hash.of_hash (merkle_root t :> Random_oracle.Digest.t)","counters":[{"col_start":4,"col_end":4,"count":16},{"col_start":35,"col_end":35,"count":16}]},{"line":"","counters":[]},{"line":"  let get_or_create ledger account_id =","counters":[]},{"line":"    let open Or_error.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let%bind action, loc =","counters":[]},{"line":"      get_or_create_account ledger account_id (Account.initialize account_id)","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"    in","counters":[]},{"line":"    let%map account =","counters":[]},{"line":"      Result.of_option (get ledger loc)","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"        ~error:","counters":[]},{"line":"          (Error.of_string","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"             \"get_or_create: Account was not found in the ledger after creation\" )","counters":[]},{"line":"    in","counters":[]},{"line":"    (action, account, loc)","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let create_empty_exn ledger account_id =","counters":[]},{"line":"    let start_hash = merkle_root ledger in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    match","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      get_or_create_account ledger account_id Account.empty |> Or_error.ok_exn","counters":[{"col_start":63,"col_end":63,"count":0}]},{"line":"    with","counters":[]},{"line":"    | `Existed, _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        failwith \"create_empty for a key already present\"","counters":[]},{"line":"    | `Added, new_loc ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Debug_assert.debug_assert (fun () ->","counters":[]},{"line":"            [%test_eq: Ledger_hash.t] start_hash (merkle_root ledger) ) ;","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"        (merkle_path ledger new_loc, Account.empty)","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"","counters":[]},{"line":"  let _handler t =","counters":[]},{"line":"    let open Snark_params.Tick in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let path_exn idx =","counters":[]},{"line":"      List.map (merkle_path_at_index_exn t idx) ~f:(function","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"        | `Left h ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            h","counters":[]},{"line":"        | `Right h ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            h )","counters":[]},{"line":"    in","counters":[]},{"line":"    stage (fun (With { request; respond }) ->","counters":[]},{"line":"        match request with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | Ledger_hash.Get_element idx ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let elt = get_at_index_exn t idx in","counters":[]},{"line":"            let path = (path_exn idx :> Random_oracle.Digest.t list) in","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"            respond (Provide (elt, path))","counters":[]},{"line":"        | Ledger_hash.Get_path idx ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let path = (path_exn idx :> Random_oracle.Digest.t list) in","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"            respond (Provide path)","counters":[]},{"line":"        | Ledger_hash.Set (idx, account) ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            set_at_index_exn t idx account ;","counters":[]},{"line":"            respond (Provide ())","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"        | Ledger_hash.Find_index pk ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let index = index_of_account_exn t pk in","counters":[]},{"line":"            respond (Provide index)","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"        | _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            unhandled )","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"include Ledger_inner","counters":[]},{"line":"include Mina_transaction_logic.Make (Ledger_inner)","counters":[]},{"line":"","counters":[]},{"line":"let apply_transaction ~constraint_constants ~txn_state_view l t =","counters":[]},{"line":"  O1trace.sync_thread \"apply_transaction\" (fun () ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      apply_transaction ~constraint_constants ~txn_state_view l t )","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"(* use mask to restore ledger after application *)","counters":[]},{"line":"let merkle_root_after_zkapp_command_exn ~constraint_constants ~txn_state_view","counters":[]},{"line":"    ledger zkapp_command =","counters":[]},{"line":"  let mask = Mask.create ~depth:(depth ledger) () in","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"  let masked_ledger = register_mask ledger mask in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let _applied =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Or_error.ok_exn","counters":[]},{"line":"      (apply_zkapp_command_unchecked ~constraint_constants","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"         ~state_view:txn_state_view masked_ledger","counters":[]},{"line":"         (Zkapp_command.Valid.forget zkapp_command) )","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"  in","counters":[]},{"line":"  let root = merkle_root masked_ledger in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  ignore (unregister_mask_exn ~loc:__LOC__ masked_ledger : unattached_mask) ;","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"  root","counters":[]},{"line":"","counters":[]},{"line":"(* use mask to restore ledger after application *)","counters":[]},{"line":"let merkle_root_after_user_command_exn ~constraint_constants ~txn_global_slot","counters":[]},{"line":"    ledger cmd =","counters":[]},{"line":"  let mask = Mask.create ~depth:(depth ledger) () in","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"  let masked_ledger = register_mask ledger mask in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let _applied =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Or_error.ok_exn","counters":[]},{"line":"      (apply_user_command ~constraint_constants ~txn_global_slot masked_ledger","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"         cmd )","counters":[]},{"line":"  in","counters":[]},{"line":"  let root = merkle_root masked_ledger in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  ignore (unregister_mask_exn ~loc:__LOC__ masked_ledger : unattached_mask) ;","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"  root","counters":[]},{"line":"","counters":[]},{"line":"type init_state =","counters":[{"col_start":0,"col_end":0,"count":0}]},{"line":"  ( Signature_lib.Keypair.t","counters":[]},{"line":"  * Currency.Amount.t","counters":[]},{"line":"  * Mina_numbers.Account_nonce.t","counters":[]},{"line":"  * Account_timing.t )","counters":[]},{"line":"  array","counters":[]},{"line":"[@@deriving sexp_of]","counters":[]},{"line":"","counters":[]},{"line":"let gen_initial_ledger_state : init_state Quickcheck.Generator.t =","counters":[]},{"line":"  let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"  let%bind n_accounts = Int.gen_incl 2 10 in","counters":[{"col_start":35,"col_end":35,"count":1}]},{"line":"  let%bind keypairs = Quickcheck_lib.replicate_gen Keypair.gen n_accounts in","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"  let%bind balances =","counters":[]},{"line":"    let gen_balance =","counters":[]},{"line":"      let%map whole_balance = Int.gen_incl 500_000_000 1_000_000_000 in","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"      Currency.Amount.of_int (whole_balance * 1_000_000_000)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    in","counters":[]},{"line":"    Quickcheck_lib.replicate_gen gen_balance n_accounts","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"  in","counters":[]},{"line":"  let%bind nonces =","counters":[]},{"line":"    Quickcheck_lib.replicate_gen","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"      ( Quickcheck.Generator.map ~f:Mina_numbers.Account_nonce.of_int","counters":[{"col_start":68,"col_end":68,"count":0}]},{"line":"      @@ Int.gen_incl 0 1000 )","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"      n_accounts","counters":[]},{"line":"  in","counters":[]},{"line":"  let rec zip3_exn a b c =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    match (a, b, c) with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | [], [], [] ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        []","counters":[]},{"line":"    | x :: xs, y :: ys, z :: zs ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (x, y, z, Account_timing.Untimed) :: zip3_exn xs ys zs","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"    | _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        failwith \"zip3 unequal lengths\"","counters":[]},{"line":"  in","counters":[]},{"line":"  return @@ Array.of_list @@ zip3_exn keypairs balances nonces","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"","counters":[]},{"line":"let apply_initial_ledger_state : t -> init_state -> unit =","counters":[]},{"line":" fun t accounts ->","counters":[]},{"line":"  Array.iter accounts ~f:(fun (kp, balance, nonce, timing) ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      let pk_compressed = Public_key.compress kp.public_key in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let account_id = Account_id.create pk_compressed Token_id.default in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let account = Account.initialize account_id in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let account' =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { account with","counters":[]},{"line":"          balance = Currency.Balance.of_int (Currency.Amount.to_int balance)","counters":[{"col_start":42,"col_end":42,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"        ; nonce","counters":[]},{"line":"        ; timing","counters":[]},{"line":"        }","counters":[]},{"line":"      in","counters":[]},{"line":"      create_new_account_exn t account_id account' )","counters":[]},{"line":"","counters":[]},{"line":"let%test_unit \"tokens test\" =","counters":[]},{"line":"  let open Mina_transaction_logic.For_tests in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let open Zkapp_command_builder in","counters":[]},{"line":"  let constraint_constants =","counters":[]},{"line":"    Genesis_constants.Constraint_constants.for_unit_tests","counters":[]},{"line":"  in","counters":[]},{"line":"  let keypair_and_amounts = Quickcheck.random_value (Init_ledger.gen ()) in","counters":[{"col_start":67,"col_end":67,"count":0}]},{"line":"  let ledger_get_exn ledger pk token =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    match","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Ledger_inner.get_or_create ledger (Account_id.create pk token)","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"      |> Or_error.ok_exn","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"    with","counters":[]},{"line":"    | `Added, _, _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        failwith \"Account did not exist\"","counters":[]},{"line":"    | `Existed, acct, _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        acct","counters":[]},{"line":"  in","counters":[]},{"line":"  let pk =","counters":[]},{"line":"    let kp, _ = keypair_and_amounts.(0) in","counters":[]},{"line":"    Public_key.compress kp.public_key","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"  in","counters":[]},{"line":"  let main (ledger : t) =","counters":[]},{"line":"    let execute_zkapp_command_transaction","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        (zkapp_command :","counters":[]},{"line":"          (Account_update.Body.Simple.t, unit, unit) Zkapp_command.Call_forest.t","counters":[]},{"line":"          ) : unit =","counters":[]},{"line":"      let _, ({ nonce; _ } : Account.t), _ =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Ledger_inner.get_or_create ledger","counters":[]},{"line":"          (Account_id.create pk Token_id.default)","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"        |> Or_error.ok_exn","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"      in","counters":[]},{"line":"      match","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        apply_zkapp_command_unchecked ~constraint_constants ~state_view:view","counters":[]},{"line":"          ledger","counters":[]},{"line":"          (mk_zkapp_command ~fee:7 ~fee_payer_pk:pk ~fee_payer_nonce:nonce","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"             zkapp_command )","counters":[]},{"line":"      with","counters":[]},{"line":"      | Ok ({ command = { status; _ }; _ }, _) -> (","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          match status with","counters":[]},{"line":"          | Transaction_status.Applied ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              ()","counters":[]},{"line":"          | Failed failures ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let indexed_failures :","counters":[]},{"line":"                  (int * Transaction_status.Failure.t list) list =","counters":[]},{"line":"                Transaction_status.Failure.Collection.to_display failures","counters":[{"col_start":63,"col_end":63,"count":0}]},{"line":"              in","counters":[]},{"line":"              let formatted_failures =","counters":[]},{"line":"                List.map indexed_failures ~f:(fun (ndx, fails) ->","counters":[]},{"line":"                    sprintf \"Index: %d  Failures: %s\" ndx","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      ( List.map fails ~f:Transaction_status.Failure.to_string","counters":[]},{"line":"                      |> String.concat ~sep:\",\" ) )","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"                |> String.concat ~sep:\"; \"","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"              in","counters":[]},{"line":"              failwithf \"Transaction failed: %s\" formatted_failures () )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"      | Error err ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          failwithf \"Error executing transaction: %s\" (Error.to_string_hum err)","counters":[{"col_start":73,"col_end":73,"count":0}]},{"line":"            ()","counters":[]},{"line":"    in","counters":[]},{"line":"    let token_funder, _ = keypair_and_amounts.(1) in","counters":[]},{"line":"    let token_owner = Keypair.create () in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let token_account1 = Keypair.create () in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let token_account2 = Keypair.create () in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let account_creation_fee =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Currency.Fee.to_int constraint_constants.account_creation_fee","counters":[]},{"line":"    in","counters":[]},{"line":"    let create_token :","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        (Account_update.Body.Simple.t, unit, unit) Zkapp_command.Call_forest.t =","counters":[]},{"line":"      mk_forest","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"        [ mk_node","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"            (mk_account_update_body Signature Call token_funder Token_id.default","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"               (-(4 * account_creation_fee)) )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"            []","counters":[]},{"line":"        ; mk_node","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"            (mk_account_update_body Proof Call token_owner Token_id.default","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"               (3 * account_creation_fee) )","counters":[]},{"line":"            []","counters":[]},{"line":"        ]","counters":[]},{"line":"    in","counters":[]},{"line":"    let custom_token_id =","counters":[]},{"line":"      Account_id.derive_token_id","counters":[]},{"line":"        ~owner:","counters":[]},{"line":"          (Account_id.create","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"             (Public_key.compress token_owner.public_key)","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"             Token_id.default )","counters":[]},{"line":"    in","counters":[]},{"line":"    let token_minting =","counters":[]},{"line":"      mk_forest","counters":[]},{"line":"        [ mk_node","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"            (mk_account_update_body Signature Call token_owner Token_id.default","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"               (-account_creation_fee) )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"            [ mk_node","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                (mk_account_update_body None_given Call token_account1","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"                   custom_token_id 100 )","counters":[]},{"line":"                []","counters":[]},{"line":"            ]","counters":[]},{"line":"        ]","counters":[]},{"line":"    in","counters":[]},{"line":"    let token_transfers =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      mk_forest","counters":[]},{"line":"        [ mk_node","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"            (mk_account_update_body Signature Call token_owner Token_id.default","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"               (-account_creation_fee) )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"            [ mk_node","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                (mk_account_update_body Signature Call token_account1","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"                   custom_token_id (-30) )","counters":[]},{"line":"                []","counters":[]},{"line":"            ; mk_node","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                (mk_account_update_body None_given Call token_account2","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"                   custom_token_id 30 )","counters":[]},{"line":"                []","counters":[]},{"line":"            ; mk_node","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                (mk_account_update_body Signature Call token_account1","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"                   custom_token_id (-10) )","counters":[]},{"line":"                []","counters":[]},{"line":"            ; mk_node","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                (mk_account_update_body None_given Call token_account2","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"                   custom_token_id 10 )","counters":[]},{"line":"                []","counters":[]},{"line":"            ; mk_node","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                (mk_account_update_body Signature Call token_account2","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"                   custom_token_id (-5) )","counters":[]},{"line":"                []","counters":[]},{"line":"            ; mk_node","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                (mk_account_update_body None_given Call token_account1","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"                   custom_token_id 5 )","counters":[]},{"line":"                []","counters":[]},{"line":"            ]","counters":[]},{"line":"        ]","counters":[]},{"line":"    in","counters":[]},{"line":"    let check_token_balance k balance =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      [%test_eq: Currency.Balance.t]","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"        (ledger_get_exn ledger","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"           (Public_key.compress k.Keypair.public_key)","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"           custom_token_id )","counters":[]},{"line":"          .balance","counters":[]},{"line":"        (Currency.Balance.of_int balance)","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"    in","counters":[]},{"line":"    execute_zkapp_command_transaction create_token ;","counters":[]},{"line":"    (* Check that token_owner exists *)","counters":[]},{"line":"    ledger_get_exn ledger","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (Public_key.compress token_owner.public_key)","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"      Token_id.default","counters":[]},{"line":"    |> ignore ;","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"    execute_zkapp_command_transaction token_minting ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    check_token_balance token_account1 100 ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    execute_zkapp_command_transaction token_transfers ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    check_token_balance token_account1 65 ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    check_token_balance token_account2 35","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  in","counters":[]},{"line":"  Ledger_inner.with_ledger ~depth ~f:(fun ledger ->","counters":[]},{"line":"      Init_ledger.init","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (module Ledger_inner)","counters":[]},{"line":"        [| keypair_and_amounts.(0); keypair_and_amounts.(1) |]","counters":[]},{"line":"        ledger ;","counters":[]},{"line":"      main ledger )","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"let%test_unit \"zkapp_command payment test\" =","counters":[]},{"line":"  let open Mina_transaction_logic.For_tests in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let module L = Ledger_inner in","counters":[]},{"line":"  let constraint_constants =","counters":[]},{"line":"    { Genesis_constants.Constraint_constants.for_unit_tests with","counters":[]},{"line":"      account_creation_fee = Currency.Fee.of_int 1","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"    }","counters":[]},{"line":"  in","counters":[]},{"line":"  Quickcheck.test ~trials:1 Test_spec.gen ~f:(fun { init_ledger; specs } ->","counters":[]},{"line":"      let ts1 : Signed_command.t list = List.map specs ~f:command_send in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"      let ts2 : Zkapp_command.t list =","counters":[]},{"line":"        List.map specs ~f:(fun s ->","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"            let use_full_commitment =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Quickcheck.random_value Bool.quickcheck_generator","counters":[]},{"line":"            in","counters":[]},{"line":"            account_update_send ~constraint_constants ~use_full_commitment s )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"      in","counters":[]},{"line":"      L.with_ledger ~depth ~f:(fun l1 ->","counters":[]},{"line":"          L.with_ledger ~depth ~f:(fun l2 ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              Init_ledger.init (module L) init_ledger l1 ;","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              Init_ledger.init (module L) init_ledger l2 ;","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              let open Result.Let_syntax in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              let%bind () =","counters":[]},{"line":"                iter_err ts1 ~f:(fun t ->","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                    apply_user_command_unchecked l1 t ~constraint_constants","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      ~txn_global_slot )","counters":[]},{"line":"              in","counters":[]},{"line":"              let%bind () =","counters":[]},{"line":"                iter_err ts2 ~f:(fun t ->","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                    apply_zkapp_command_unchecked l2 t ~constraint_constants","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      ~state_view:view )","counters":[]},{"line":"              in","counters":[]},{"line":"              let accounts =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                List.concat_map ~f:Zkapp_command.accounts_referenced ts2","counters":[]},{"line":"              in","counters":[]},{"line":"              (* TODO: Hack. The nonces are inconsistent between the 2","counters":[]},{"line":"                 versions. See the comment in","counters":[]},{"line":"                 [Mina_transaction_logic.For_tests.account_update_send] for more info.","counters":[]},{"line":"              *)","counters":[]},{"line":"              L.iteri l1 ~f:(fun index account ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                  L.set_at_index_exn l1 index","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    { account with","counters":[]},{"line":"                      nonce =","counters":[]},{"line":"                        account.nonce |> Mina_numbers.Account_nonce.to_uint32","counters":[]},{"line":"                        |> Unsigned.UInt32.(mul (of_int 2))","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":46,"col_end":46,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"                        |> Mina_numbers.Account_nonce.to_uint32","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"                    } ) ;","counters":[]},{"line":"              test_eq (module L) accounts l1 l2 ) )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"      |> Or_error.ok_exn )","counters":[{"col_start":25,"col_end":25,"count":1}]}]}