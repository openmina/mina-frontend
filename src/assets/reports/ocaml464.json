{"filename":"src/lib/transition_frontier/frontier_base/breadcrumb.ml","lines":[{"line":"open Async_kernel","counters":[]},{"line":"open Core","counters":[]},{"line":"open Mina_base","counters":[]},{"line":"open Mina_state","counters":[]},{"line":"open Mina_block","counters":[]},{"line":"open Network_peer","counters":[]},{"line":"","counters":[]},{"line":"module T = struct","counters":[]},{"line":"  let id = \"breadcrumb\"","counters":[]},{"line":"","counters":[]},{"line":"  type t =","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":7,"col_end":7,"count":0}]},{"line":"    { validated_transition : Mina_block.Validated.t","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"    ; staged_ledger : Staged_ledger.t [@sexp.opaque]","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"    ; just_emitted_a_proof : bool","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"    ; transition_receipt_time : Time.t option","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"    }","counters":[]},{"line":"  [@@deriving sexp, fields]","counters":[]},{"line":"","counters":[]},{"line":"  type 'a creator =","counters":[]},{"line":"       validated_transition:Mina_block.Validated.t","counters":[]},{"line":"    -> staged_ledger:Staged_ledger.t","counters":[]},{"line":"    -> just_emitted_a_proof:bool","counters":[]},{"line":"    -> transition_receipt_time:Time.t option","counters":[]},{"line":"    -> 'a","counters":[]},{"line":"","counters":[]},{"line":"  let map_creator creator ~f ~validated_transition ~staged_ledger","counters":[]},{"line":"      ~just_emitted_a_proof ~transition_receipt_time =","counters":[]},{"line":"    f","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (creator ~validated_transition ~staged_ledger ~just_emitted_a_proof","counters":[]},{"line":"         ~transition_receipt_time )","counters":[]},{"line":"","counters":[]},{"line":"  let create ~validated_transition ~staged_ledger ~just_emitted_a_proof","counters":[]},{"line":"      ~transition_receipt_time =","counters":[]},{"line":"    { validated_transition","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    ; staged_ledger","counters":[]},{"line":"    ; just_emitted_a_proof","counters":[]},{"line":"    ; transition_receipt_time","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let to_yojson","counters":[]},{"line":"      { validated_transition","counters":[]},{"line":"      ; staged_ledger = _","counters":[]},{"line":"      ; just_emitted_a_proof","counters":[]},{"line":"      ; transition_receipt_time","counters":[]},{"line":"      } =","counters":[]},{"line":"    `Assoc","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      [ ( \"validated_transition\"","counters":[]},{"line":"        , Mina_block.Validated.to_yojson validated_transition )","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"      ; (\"staged_ledger\", `String \"<opaque>\")","counters":[]},{"line":"      ; (\"just_emitted_a_proof\", `Bool just_emitted_a_proof)","counters":[]},{"line":"      ; ( \"transition_receipt_time\"","counters":[]},{"line":"        , `String","counters":[]},{"line":"            (Option.value_map transition_receipt_time ~default:\"<not available>\"","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"               ~f:(Time.to_string_iso8601_basic ~zone:Time.Zone.utc) ) )","counters":[]},{"line":"      ]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"[%%define_locally","counters":[]},{"line":"T.","counters":[]},{"line":"  ( validated_transition","counters":[]},{"line":"  , staged_ledger","counters":[]},{"line":"  , just_emitted_a_proof","counters":[]},{"line":"  , transition_receipt_time","counters":[]},{"line":"  , to_yojson )]","counters":[]},{"line":"","counters":[]},{"line":"include Allocation_functor.Make.Sexp (T)","counters":[]},{"line":"","counters":[]},{"line":"let build ?skip_staged_ledger_verification ~logger ~precomputed_values ~verifier","counters":[]},{"line":"    ~trust_system ~parent","counters":[]},{"line":"    ~transition:(transition_with_validation : Mina_block.almost_valid_block)","counters":[]},{"line":"    ~sender ~transition_receipt_time () =","counters":[]},{"line":"  O1trace.thread \"build_breadcrumb\" (fun () ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      let open Deferred.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      match%bind","counters":[]},{"line":"        Validation.validate_staged_ledger_diff ?skip_staged_ledger_verification","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"          ~logger ~precomputed_values ~verifier","counters":[]},{"line":"          ~parent_staged_ledger:(staged_ledger parent)","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"          ~parent_protocol_state:","counters":[]},{"line":"            ( parent.validated_transition |> Mina_block.Validated.header","counters":[{"col_start":71,"col_end":71,"count":0}]},{"line":"            |> Mina_block.Header.protocol_state )","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"          transition_with_validation","counters":[]},{"line":"      with","counters":[]},{"line":"      | Ok","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ( `Just_emitted_a_proof just_emitted_a_proof","counters":[]},{"line":"          , `Block_with_validation fully_valid_block","counters":[]},{"line":"          , `Staged_ledger transitioned_staged_ledger ) ->","counters":[]},{"line":"          Deferred.Result.return","counters":[]},{"line":"            (create","counters":[]},{"line":"               ~validated_transition:","counters":[]},{"line":"                 (Mina_block.Validated.lift fully_valid_block)","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"               ~staged_ledger:transitioned_staged_ledger ~just_emitted_a_proof","counters":[]},{"line":"               ~transition_receipt_time )","counters":[]},{"line":"      | Error `Invalid_body_reference ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let message = \"invalid body reference\" in","counters":[]},{"line":"          let%map () =","counters":[]},{"line":"            match sender with","counters":[]},{"line":"            | None | Some Envelope.Sender.Local ->","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"                return ()","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"            | Some (Envelope.Sender.Remote peer) ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Trust_system.(","counters":[]},{"line":"                  record trust_system logger peer","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                    Actions.(Gossiped_invalid_transition, Some (message, [])))","counters":[]},{"line":"          in","counters":[]},{"line":"          Error (`Invalid_staged_ledger_diff (Error.of_string message))","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"      | Error (`Invalid_staged_ledger_diff errors) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let reasons =","counters":[]},{"line":"            String.concat ~sep:\" && \"","counters":[]},{"line":"              (List.map errors ~f:(function","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                | `Incorrect_target_staged_ledger_hash ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    \"staged ledger hash\"","counters":[]},{"line":"                | `Incorrect_target_snarked_ledger_hash ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    \"snarked ledger hash\" ) )","counters":[]},{"line":"          in","counters":[]},{"line":"          let message = \"invalid staged ledger diff: incorrect \" ^ reasons in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let%map () =","counters":[]},{"line":"            match sender with","counters":[]},{"line":"            | None | Some Envelope.Sender.Local ->","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"                return ()","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"            | Some (Envelope.Sender.Remote peer) ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Trust_system.(","counters":[]},{"line":"                  record trust_system logger peer","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                    Actions.(Gossiped_invalid_transition, Some (message, [])))","counters":[]},{"line":"          in","counters":[]},{"line":"          Error (`Invalid_staged_ledger_hash (Error.of_string message))","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"      | Error (`Staged_ledger_application_failed staged_ledger_error) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let%map () =","counters":[]},{"line":"            match sender with","counters":[]},{"line":"            | None | Some Envelope.Sender.Local ->","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"                return ()","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"            | Some (Envelope.Sender.Remote peer) ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                let error_string =","counters":[]},{"line":"                  Staged_ledger.Staged_ledger_error.to_string","counters":[]},{"line":"                    staged_ledger_error","counters":[]},{"line":"                in","counters":[]},{"line":"                let make_actions action =","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  ( action","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  , Some","counters":[]},{"line":"                      ( \"Staged_ledger error: $error\"","counters":[]},{"line":"                      , [ (\"error\", `String error_string) ] ) )","counters":[]},{"line":"                in","counters":[]},{"line":"                let open Trust_system.Actions in","counters":[]},{"line":"                (* TODO : refine these actions (#2375) *)","counters":[]},{"line":"                let open Staged_ledger.Pre_diff_info.Error in","counters":[]},{"line":"                with_return (fun { return } ->","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                    let action =","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      match staged_ledger_error with","counters":[]},{"line":"                      | Couldn't_reach_verifier _ ->","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          return Deferred.unit","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                      | Invalid_proofs _ ->","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          make_actions Sent_invalid_proof","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                      | Pre_diff (Verification_failed _) ->","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          make_actions Sent_invalid_signature_or_proof","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                      | Pre_diff _","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                      | Non_zero_fee_excess _","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                      | Insufficient_work _","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                      | Mismatched_statuses _","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                      | Invalid_public_key _","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                      | Unexpected _ ->","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          make_actions Gossiped_invalid_transition","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                    in","counters":[]},{"line":"                    Trust_system.record trust_system logger peer action )","counters":[]},{"line":"          in","counters":[]},{"line":"          Error","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (`Invalid_staged_ledger_diff","counters":[]},{"line":"              (Staged_ledger.Staged_ledger_error.to_error staged_ledger_error)","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"              ) )","counters":[]},{"line":"","counters":[]},{"line":"let block_with_hash =","counters":[]},{"line":"  Fn.compose Mina_block.Validated.forget validated_transition","counters":[{"col_start":11,"col_end":11,"count":1}]},{"line":"","counters":[]},{"line":"let block = Fn.compose With_hash.data block_with_hash","counters":[{"col_start":21,"col_end":21,"count":1}]},{"line":"","counters":[]},{"line":"let state_hash = Fn.compose Mina_block.Validated.state_hash validated_transition","counters":[{"col_start":26,"col_end":26,"count":1}]},{"line":"","counters":[]},{"line":"let protocol_state b =","counters":[]},{"line":"  b |> block |> Mina_block.header |> Mina_block.Header.protocol_state","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":11,"col_end":11,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"","counters":[]},{"line":"let protocol_state_with_hashes breadcrumb =","counters":[]},{"line":"  breadcrumb |> validated_transition |> Mina_block.Validated.forget","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"  |> With_hash.map ~f:(Fn.compose Header.protocol_state Mina_block.header)","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"","counters":[]},{"line":"let consensus_state = Fn.compose Protocol_state.consensus_state protocol_state","counters":[{"col_start":31,"col_end":31,"count":1}]},{"line":"","counters":[]},{"line":"let consensus_state_with_hashes breadcrumb =","counters":[]},{"line":"  breadcrumb |> block_with_hash","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"  |> With_hash.map ~f:(fun block ->","counters":[]},{"line":"         block |> Mina_block.header |> Mina_block.Header.protocol_state","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":70,"col_end":70,"count":0}]},{"line":"         |> Protocol_state.consensus_state )","counters":[]},{"line":"","counters":[]},{"line":"let parent_hash b = b |> protocol_state |> Protocol_state.previous_state_hash","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"","counters":[]},{"line":"let mask = Fn.compose Staged_ledger.ledger staged_ledger","counters":[{"col_start":20,"col_end":20,"count":1}]},{"line":"","counters":[]},{"line":"let equal breadcrumb1 breadcrumb2 =","counters":[]},{"line":"  State_hash.equal (state_hash breadcrumb1) (state_hash breadcrumb2)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"","counters":[]},{"line":"let compare breadcrumb1 breadcrumb2 =","counters":[]},{"line":"  State_hash.compare (state_hash breadcrumb1) (state_hash breadcrumb2)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"","counters":[]},{"line":"let hash = Fn.compose State_hash.hash state_hash","counters":[{"col_start":20,"col_end":20,"count":1}]},{"line":"","counters":[]},{"line":"let name t =","counters":[]},{"line":"  Visualization.display_prefix_of_string @@ State_hash.to_base58_check","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"  @@ state_hash t","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"","counters":[]},{"line":"type display =","counters":[{"col_start":0,"col_end":0,"count":0}]},{"line":"  { state_hash : string","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"  ; blockchain_state : Blockchain_state.display","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"  ; consensus_state : Consensus.Data.Consensus_state.display","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"  ; parent : string","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"  }","counters":[]},{"line":"[@@deriving yojson]","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"","counters":[]},{"line":"let display t =","counters":[]},{"line":"  let protocol_state =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    t |> block |> Mina_block.header |> Mina_block.Header.protocol_state","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"  in","counters":[]},{"line":"  let blockchain_state =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Blockchain_state.display (Protocol_state.blockchain_state protocol_state)","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"  in","counters":[]},{"line":"  let consensus_state = Protocol_state.consensus_state protocol_state in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let parent =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    t |> parent_hash |> State_hash.to_base58_check","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"    |> Visualization.display_prefix_of_string","counters":[]},{"line":"  in","counters":[]},{"line":"  { state_hash = name t","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":20,"col_end":20,"count":0}]},{"line":"  ; blockchain_state","counters":[]},{"line":"  ; consensus_state = Consensus.Data.Consensus_state.display consensus_state","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"  ; parent","counters":[]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"module For_tests = struct","counters":[]},{"line":"  open Currency","counters":[]},{"line":"  open Signature_lib","counters":[]},{"line":"","counters":[]},{"line":"  (* Generate valid payments for each blockchain state by having","counters":[]},{"line":"     each user send a payment of one coin to another random","counters":[]},{"line":"     user if they have at least one coin*)","counters":[]},{"line":"  let gen_payments ~send_to_random_pk staged_ledger accounts_with_secret_keys :","counters":[]},{"line":"      Signed_command.With_valid_signature.t Sequence.t =","counters":[]},{"line":"    let account_ids =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      List.map accounts_with_secret_keys ~f:(fun (_, account) ->","counters":[]},{"line":"          Account.identifier account )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    in","counters":[]},{"line":"    (* One transaction is sent to a random address to make sure generated block","counters":[]},{"line":"       contains a transaction to new account, not only to existing *)","counters":[]},{"line":"    let random_pk =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      lazy","counters":[]},{"line":"        ( Private_key.create () |> Public_key.of_private_key_exn","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"        |> Public_key.compress )","counters":[]},{"line":"    in","counters":[]},{"line":"    Sequence.filter_map (accounts_with_secret_keys |> Sequence.of_list)","counters":[{"col_start":69,"col_end":69,"count":0}]},{"line":"      ~f:(fun (sender_sk, sender_account) ->","counters":[]},{"line":"        let open Option.Let_syntax in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let%bind sender_sk = sender_sk in","counters":[]},{"line":"        let sender_keypair = Keypair.of_private_key_exn sender_sk in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let token = sender_account.token_id in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        (* Send some transactions to the new accounts *)","counters":[]},{"line":"        let%bind receiver_pk =","counters":[]},{"line":"          if send_to_random_pk && not (Lazy.is_val random_pk) then","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"            Some (Lazy.force random_pk)","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"          else","counters":[]},{"line":"            account_ids","counters":[]},{"line":"            |> List.filter","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                 ~f:(Fn.compose (Token_id.equal token) Account_id.token_id)","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"            |> List.random_element >>| Account_id.public_key","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"        in","counters":[]},{"line":"        let nonce =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let ledger = Staged_ledger.ledger staged_ledger in","counters":[]},{"line":"          let status, account_location =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Mina_ledger.Ledger.get_or_create_account ledger","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"              (Account.identifier sender_account)","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"              sender_account","counters":[]},{"line":"            |> Or_error.ok_exn","counters":[]},{"line":"          in","counters":[]},{"line":"          assert ([%equal: [ `Existed | `Added ]] status `Existed) ;","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"          (Option.value_exn (Mina_ledger.Ledger.get ledger account_location))","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"            .nonce","counters":[]},{"line":"        in","counters":[]},{"line":"        let send_amount = Currency.Amount.of_int 1000000001 in","counters":[]},{"line":"        let sender_account_amount =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          sender_account.Account.Poly.balance |> Currency.Balance.to_amount","counters":[]},{"line":"        in","counters":[]},{"line":"        let%map _ = Currency.Amount.sub sender_account_amount send_amount in","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"        let sender_pk = Account.public_key sender_account in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let payload : Signed_command.Payload.t =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Signed_command.Payload.create ~fee:Fee.zero ~fee_payer_pk:sender_pk","counters":[]},{"line":"            ~nonce ~valid_until:None ~memo:Signed_command_memo.dummy","counters":[]},{"line":"            ~body:","counters":[]},{"line":"              (Payment","counters":[]},{"line":"                 { source_pk = sender_pk; receiver_pk; amount = send_amount } )","counters":[]},{"line":"        in","counters":[]},{"line":"        Signed_command.sign sender_keypair payload )","counters":[]},{"line":"","counters":[]},{"line":"  let gen ?(logger = Logger.null ()) ?(send_to_random_pk = false)","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"      ~(precomputed_values : Precomputed_values.t) ~verifier","counters":[]},{"line":"      ?(trust_system = Trust_system.null ()) ~accounts_with_secret_keys () :","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"      (t -> t Deferred.t) Quickcheck.Generator.t =","counters":[]},{"line":"    let open Quickcheck.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let gen_slot_advancement = Int.gen_incl 1 10 in","counters":[]},{"line":"    let%bind make_next_consensus_state =","counters":[]},{"line":"      Consensus_state_hooks.For_tests.gen_consensus_state ~gen_slot_advancement","counters":[]},{"line":"        ~constraint_constants:","counters":[]},{"line":"          precomputed_values.Precomputed_values.constraint_constants","counters":[]},{"line":"        ~constants:precomputed_values.consensus_constants","counters":[]},{"line":"    in","counters":[]},{"line":"    let%map supercharge_coinbase = Quickcheck.Generator.bool in","counters":[]},{"line":"    fun parent_breadcrumb ->","counters":[]},{"line":"      let open Deferred.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let parent_staged_ledger = staged_ledger parent_breadcrumb in","counters":[]},{"line":"      let transactions =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        gen_payments ~send_to_random_pk parent_staged_ledger","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"          accounts_with_secret_keys","counters":[]},{"line":"        |> Sequence.map ~f:(fun x -> User_command.Signed_command x)","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"      in","counters":[]},{"line":"      let _, largest_account =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        List.max_elt accounts_with_secret_keys","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"          ~compare:(fun (_, acc1) (_, acc2) -> Account.compare acc1 acc2)","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"        |> Option.value_exn","counters":[]},{"line":"      in","counters":[]},{"line":"      let largest_account_public_key = Account.public_key largest_account in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let get_completed_work stmts =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let { Keypair.public_key; _ } = Keypair.create () in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let prover = Public_key.compress public_key in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Some","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Transaction_snark_work.Checked.","counters":[]},{"line":"            { fee = Fee.of_int 1","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"            ; proofs =","counters":[]},{"line":"                One_or_two.map stmts ~f:(fun statement ->","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                    Ledger_proof.create ~statement","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      ~sok_digest:Sok_message.Digest.default","counters":[]},{"line":"                      ~proof:Proof.transaction_dummy )","counters":[]},{"line":"            ; prover","counters":[]},{"line":"            }","counters":[]},{"line":"      in","counters":[]},{"line":"      let current_state_view, state_and_body_hash =","counters":[]},{"line":"        let prev_state =","counters":[]},{"line":"          parent_breadcrumb |> block |> Mina_block.header","counters":[{"col_start":35,"col_end":35,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"          |> Mina_block.Header.protocol_state","counters":[]},{"line":"        in","counters":[]},{"line":"        let prev_state_hashes = Protocol_state.hashes prev_state in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let current_state_view =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Protocol_state.body prev_state |> Protocol_state.Body.view","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"        in","counters":[]},{"line":"        ( current_state_view","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        , ( prev_state_hashes.state_hash","counters":[]},{"line":"          , Option.value_exn prev_state_hashes.state_body_hash ) )","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"      in","counters":[]},{"line":"      let coinbase_receiver = largest_account_public_key in","counters":[]},{"line":"      let staged_ledger_diff, _invalid_txns =","counters":[]},{"line":"        Staged_ledger.create_diff parent_staged_ledger ~logger","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"          ~constraint_constants:precomputed_values.constraint_constants","counters":[]},{"line":"          ~coinbase_receiver ~current_state_view ~supercharge_coinbase","counters":[]},{"line":"          ~transactions_by_fee:transactions ~get_completed_work","counters":[]},{"line":"        |> Result.map_error ~f:Staged_ledger.Pre_diff_info.Error.to_error","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"        |> Or_error.ok_exn","counters":[]},{"line":"      in","counters":[]},{"line":"      let body =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Mina_block.Body.create @@ Staged_ledger_diff.forget staged_ledger_diff","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"      in","counters":[]},{"line":"      let%bind ( `Hash_after_applying next_staged_ledger_hash","counters":[]},{"line":"               , `Ledger_proof ledger_proof_opt","counters":[]},{"line":"               , `Staged_ledger _","counters":[]},{"line":"               , `Pending_coinbase_update _ ) =","counters":[]},{"line":"        match%bind","counters":[]},{"line":"          Staged_ledger.apply_diff_unchecked parent_staged_ledger","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"            ~coinbase_receiver ~logger staged_ledger_diff","counters":[]},{"line":"            ~constraint_constants:precomputed_values.constraint_constants","counters":[]},{"line":"            ~current_state_view ~state_and_body_hash ~supercharge_coinbase","counters":[]},{"line":"        with","counters":[]},{"line":"        | Ok r ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            return r","counters":[]},{"line":"        | Error e ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            failwith (Staged_ledger.Staged_ledger_error.to_string e)","counters":[{"col_start":64,"col_end":64,"count":0}]},{"line":"      in","counters":[]},{"line":"      let previous_protocol_state =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        parent_breadcrumb |> block |> Mina_block.header","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"        |> Mina_block.Header.protocol_state","counters":[]},{"line":"      in","counters":[]},{"line":"      let previous_registers =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        previous_protocol_state |> Protocol_state.blockchain_state","counters":[{"col_start":65,"col_end":65,"count":0}]},{"line":"        |> Blockchain_state.registers","counters":[]},{"line":"      in","counters":[]},{"line":"      let next_registers =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Option.value_map ledger_proof_opt","counters":[]},{"line":"          ~f:(fun (proof, _) ->","counters":[]},{"line":"            { (Ledger_proof.statement proof |> Ledger_proof.statement_target) with","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":75,"col_end":75,"count":0}]},{"line":"              pending_coinbase_stack = ()","counters":[]},{"line":"            } )","counters":[]},{"line":"          ~default:previous_registers","counters":[]},{"line":"      in","counters":[]},{"line":"      let genesis_ledger_hash =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        previous_protocol_state |> Protocol_state.blockchain_state","counters":[{"col_start":65,"col_end":65,"count":0}]},{"line":"        |> Blockchain_state.genesis_ledger_hash","counters":[]},{"line":"      in","counters":[]},{"line":"      let next_blockchain_state =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Blockchain_state.create_value","counters":[]},{"line":"          ~timestamp:(Block_time.now @@ Block_time.Controller.basic ~logger)","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"          ~registers:next_registers ~staged_ledger_hash:next_staged_ledger_hash","counters":[]},{"line":"          ~genesis_ledger_hash","counters":[]},{"line":"          ~body_reference:(Body.compute_reference body)","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"      in","counters":[]},{"line":"      let previous_state_hashes =","counters":[]},{"line":"        Protocol_state.hashes previous_protocol_state","counters":[]},{"line":"      in","counters":[]},{"line":"      let consensus_state =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        make_next_consensus_state ~snarked_ledger_hash:previous_registers.ledger","counters":[]},{"line":"          ~previous_protocol_state:","counters":[]},{"line":"            With_hash.","counters":[]},{"line":"              { data = previous_protocol_state; hash = previous_state_hashes }","counters":[]},{"line":"          ~coinbase_receiver ~supercharge_coinbase","counters":[]},{"line":"      in","counters":[]},{"line":"      let genesis_state_hash =","counters":[]},{"line":"        Protocol_state.genesis_state_hash","counters":[]},{"line":"          ~state_hash:(Some previous_state_hashes.state_hash)","counters":[]},{"line":"          previous_protocol_state","counters":[]},{"line":"      in","counters":[]},{"line":"      let protocol_state =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Protocol_state.create_value ~genesis_state_hash","counters":[]},{"line":"          ~previous_state_hash:previous_state_hashes.state_hash","counters":[]},{"line":"          ~blockchain_state:next_blockchain_state ~consensus_state","counters":[]},{"line":"          ~constants:(Protocol_state.constants previous_protocol_state)","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"      in","counters":[]},{"line":"      Protocol_version.(set_current zero) ;","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"      let next_block =","counters":[]},{"line":"        let header =","counters":[]},{"line":"          Mina_block.Header.create ~protocol_state","counters":[]},{"line":"            ~protocol_state_proof:Proof.blockchain_dummy","counters":[]},{"line":"            ~delta_block_chain_proof:(previous_state_hashes.state_hash, [])","counters":[]},{"line":"            ()","counters":[]},{"line":"        in","counters":[]},{"line":"        (* We manually created a validated an block *)","counters":[]},{"line":"        let block =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          { With_hash.hash = Protocol_state.hashes protocol_state","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"          ; data = Mina_block.create ~header ~body","counters":[]},{"line":"          }","counters":[]},{"line":"        in","counters":[]},{"line":"        Mina_block.Validated.unsafe_of_trusted_block","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"          ~delta_block_chain_proof:","counters":[]},{"line":"            (Non_empty_list.singleton previous_state_hashes.state_hash)","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"          (`This_block_is_trusted_to_be_safe block)","counters":[]},{"line":"      in","counters":[]},{"line":"      let transition_receipt_time = Some (Time.now ()) in","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"      match%map","counters":[]},{"line":"        build ~logger ~precomputed_values ~trust_system ~verifier","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          ~parent:parent_breadcrumb","counters":[]},{"line":"          ~transition:","counters":[]},{"line":"            ( next_block |> Mina_block.Validated.remember","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"            |> Validation.reset_staged_ledger_diff_validation )","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"          ~sender:None ~skip_staged_ledger_verification:`All","counters":[]},{"line":"          ~transition_receipt_time ()","counters":[]},{"line":"      with","counters":[]},{"line":"      | Ok new_breadcrumb ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          [%log info]","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"            ~metadata:","counters":[]},{"line":"              [ (\"state_hash\", state_hash new_breadcrumb |> State_hash.to_yojson)","counters":[{"col_start":40,"col_end":40,"count":0},{"col_start":79,"col_end":79,"count":0}]},{"line":"              ]","counters":[]},{"line":"            \"Producing a breadcrumb with hash: $state_hash\" ;","counters":[]},{"line":"          new_breadcrumb","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"      | Error (`Fatal_error exn) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          raise exn","counters":[]},{"line":"      | Error (`Invalid_staged_ledger_diff e) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          failwithf !\"Invalid staged ledger diff: %{sexp:Error.t}\" e ()","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"      | Error (`Invalid_staged_ledger_hash e) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          failwithf !\"Invalid staged ledger hash: %{sexp:Error.t}\" e ()","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"","counters":[]},{"line":"  let gen_non_deferred ?logger ~precomputed_values ~verifier ?trust_system","counters":[]},{"line":"      ~accounts_with_secret_keys () =","counters":[]},{"line":"    let open Quickcheck.Generator.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let%map make_deferred =","counters":[]},{"line":"      gen ?logger ~verifier ~precomputed_values ?trust_system","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        ~accounts_with_secret_keys ()","counters":[]},{"line":"    in","counters":[]},{"line":"    fun x -> Async.Thread_safe.block_on_async_exn (fun () -> make_deferred x)","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"","counters":[]},{"line":"  let gen_seq ?logger ~precomputed_values ~verifier ?trust_system","counters":[]},{"line":"      ~accounts_with_secret_keys n =","counters":[]},{"line":"    let open Quickcheck.Generator.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let gen_list =","counters":[]},{"line":"      List.gen_with_length n","counters":[]},{"line":"        (gen ?logger ~precomputed_values ~verifier ?trust_system","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"           ~accounts_with_secret_keys () )","counters":[]},{"line":"    in","counters":[]},{"line":"    let%map breadcrumbs_constructors = gen_list in","counters":[]},{"line":"    fun root ->","counters":[]},{"line":"      let open Deferred.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%map _, ls =","counters":[]},{"line":"        Deferred.List.fold breadcrumbs_constructors ~init:(root, [])","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"          ~f:(fun (previous, acc) make_breadcrumb ->","counters":[]},{"line":"            let%map breadcrumb = make_breadcrumb previous in","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"            (breadcrumb, breadcrumb :: acc) )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"      in","counters":[]},{"line":"      List.rev ls","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"  let build_fail ?skip_staged_ledger_verification:_ ~logger:_","counters":[]},{"line":"      ~precomputed_values:_ ~verifier:_ ~trust_system:_ ~parent:_ ~transition:_","counters":[]},{"line":"      ~sender:_ ~transition_receipt_time:_ () :","counters":[]},{"line":"      ( t","counters":[]},{"line":"      , [> `Fatal_error of exn","counters":[]},{"line":"        | `Invalid_staged_ledger_diff of Core_kernel.Error.t","counters":[]},{"line":"        | `Invalid_staged_ledger_hash of Core_kernel.Error.t ] )","counters":[]},{"line":"      result","counters":[]},{"line":"      Async_kernel.Deferred.t =","counters":[]},{"line":"    Deferred.return","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (Error (`Fatal_error (failwith \"deliberately failing for unit tests\")))","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}