{"filename":"src/lib/merkle_ledger/util.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"module type Inputs_intf = sig","counters":[]},{"line":"  module Location : Location_intf.S","counters":[]},{"line":"","counters":[]},{"line":"  module Location_binable : Hashable.S_binable with type t := Location.t","counters":[]},{"line":"","counters":[]},{"line":"  module Key : Intf.Key","counters":[]},{"line":"","counters":[]},{"line":"  module Token_id : Intf.Token_id","counters":[]},{"line":"","counters":[]},{"line":"  module Account_id :","counters":[]},{"line":"    Intf.Account_id with type key := Key.t and type token_id := Token_id.t","counters":[]},{"line":"","counters":[]},{"line":"  module Balance : Intf.Balance","counters":[]},{"line":"","counters":[]},{"line":"  module Account :","counters":[]},{"line":"    Intf.Account","counters":[]},{"line":"      with type balance := Balance.t","counters":[]},{"line":"       and type account_id := Account_id.t","counters":[]},{"line":"       and type token_id := Token_id.t","counters":[]},{"line":"","counters":[]},{"line":"  module Hash : Intf.Hash with type account := Account.t","counters":[]},{"line":"","counters":[]},{"line":"  module Base : sig","counters":[]},{"line":"    type t","counters":[]},{"line":"","counters":[]},{"line":"    val get : t -> Location.t -> Account.t option","counters":[]},{"line":"","counters":[]},{"line":"    val last_filled : t -> Location.t option","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  val get_hash : Base.t -> Location.t -> Hash.t","counters":[]},{"line":"","counters":[]},{"line":"  val location_of_account_addr : Location.Addr.t -> Location.t","counters":[]},{"line":"","counters":[]},{"line":"  val location_of_hash_addr : Location.Addr.t -> Location.t","counters":[]},{"line":"","counters":[]},{"line":"  val ledger_depth : Base.t -> int","counters":[]},{"line":"","counters":[]},{"line":"  val set_raw_hash_batch : Base.t -> (Location.t * Hash.t) list -> unit","counters":[]},{"line":"","counters":[]},{"line":"  val set_raw_account_batch : Base.t -> (Location.t * Account.t) list -> unit","counters":[]},{"line":"","counters":[]},{"line":"  val set_location_batch :","counters":[]},{"line":"       last_location:Location.t","counters":[]},{"line":"    -> Base.t","counters":[]},{"line":"    -> (Account_id.t * Location.t) Non_empty_list.t","counters":[]},{"line":"    -> unit","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make (Inputs : Inputs_intf) : sig","counters":[]},{"line":"  val get_all_accounts_rooted_at_exn :","counters":[]},{"line":"       Inputs.Base.t","counters":[]},{"line":"    -> Inputs.Location.Addr.t","counters":[]},{"line":"    -> (Inputs.Location.Addr.t * Inputs.Account.t) list","counters":[]},{"line":"","counters":[]},{"line":"  val set_hash_batch :","counters":[]},{"line":"    Inputs.Base.t -> (Inputs.Location.t * Inputs.Hash.t) list -> unit","counters":[]},{"line":"","counters":[]},{"line":"  val set_batch :","counters":[]},{"line":"    Inputs.Base.t -> (Inputs.Location.t * Inputs.Account.t) list -> unit","counters":[]},{"line":"","counters":[]},{"line":"  val set_batch_accounts :","counters":[]},{"line":"    Inputs.Base.t -> (Inputs.Location.Addr.t * Inputs.Account.t) list -> unit","counters":[]},{"line":"","counters":[]},{"line":"  val set_all_accounts_rooted_at_exn :","counters":[]},{"line":"    Inputs.Base.t -> Inputs.Location.Addr.t -> Inputs.Account.t list -> unit","counters":[]},{"line":"end = struct","counters":[]},{"line":"  let get_all_accounts_rooted_at_exn t address =","counters":[]},{"line":"    let open Inputs in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let result =","counters":[]},{"line":"      Location.Addr.Range.fold","counters":[]},{"line":"        (Location.Addr.Range.subtree_range ~ledger_depth:(Inputs.ledger_depth t)","counters":[{"col_start":41,"col_end":41,"count":0},{"col_start":76,"col_end":76,"count":0}]},{"line":"           address )","counters":[]},{"line":"        ~init:[]","counters":[]},{"line":"        ~f:(fun bit_index acc ->","counters":[]},{"line":"          let account = Base.get t (location_of_account_addr bit_index) in","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"          (bit_index, account) :: acc )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    in","counters":[]},{"line":"    List.rev_filter_map result ~f:(function","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      | _, None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          None","counters":[]},{"line":"      | addr, Some account ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Some (addr, account) )","counters":[]},{"line":"","counters":[]},{"line":"  let rec compute_affected_locations_and_hashes t locations_and_hashes acc =","counters":[]},{"line":"    let ledger_depth = Inputs.ledger_depth t in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    if not @@ List.is_empty locations_and_hashes then","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"      let height =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Inputs.Location.height ~ledger_depth","counters":[]},{"line":"        @@ fst","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"        @@ List.hd_exn locations_and_hashes","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"      in","counters":[]},{"line":"      if height < ledger_depth then","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let parents_to_children =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          List.fold locations_and_hashes ~init:Inputs.Location.Map.empty","counters":[]},{"line":"            ~f:(fun parents_to_children (location, hash) ->","counters":[]},{"line":"              let parent_location = Inputs.Location.parent location in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              Map.update parents_to_children parent_location ~f:(function","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                | Some (`One_side (sibling_location, sibling_hash)) ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    assert (","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                      not (Inputs.Location.equal location sibling_location) ) ;","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"                    (* If we have already recorded the sibling, we can compute","counters":[]},{"line":"                       the hash now.","counters":[]},{"line":"                    *)","counters":[]},{"line":"                    let parent_hash =","counters":[]},{"line":"                      let left_hash, right_hash =","counters":[]},{"line":"                        Inputs.Location.order_siblings location hash","counters":[]},{"line":"                          sibling_hash","counters":[]},{"line":"                      in","counters":[]},{"line":"                      Inputs.Hash.merge ~height left_hash right_hash","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"                    in","counters":[]},{"line":"                    `Hash parent_hash","counters":[]},{"line":"                | Some (`Hash _) ->","counters":[]},{"line":"                    assert false","counters":[]},{"line":"                | None ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    (* This is the first child of its parent that we have","counters":[]},{"line":"                       encountered.","counters":[]},{"line":"                    *)","counters":[]},{"line":"                    `One_side (location, hash) ) )","counters":[]},{"line":"        in","counters":[]},{"line":"        let rev_parent_locations_and_hashes =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Map.fold parents_to_children ~init:[] ~f:(fun ~key ~data acc ->","counters":[]},{"line":"              match data with","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              | `One_side (location, hash) ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  (* We haven't recorded the sibling, so query the ledger to get","counters":[]},{"line":"                     the hash.","counters":[]},{"line":"                  *)","counters":[]},{"line":"                  let sibling_location = Inputs.Location.sibling location in","counters":[]},{"line":"                  let sibling_hash = Inputs.get_hash t sibling_location in","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  let parent_hash =","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    let left_hash, right_hash =","counters":[]},{"line":"                      Inputs.Location.order_siblings location hash sibling_hash","counters":[]},{"line":"                    in","counters":[]},{"line":"                    Inputs.Hash.merge ~height left_hash right_hash","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"                  in","counters":[]},{"line":"                  (key, parent_hash) :: acc","counters":[]},{"line":"              | `Hash parent_hash ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  (* We have already computed the hash above. *)","counters":[]},{"line":"                  (key, parent_hash) :: acc )","counters":[]},{"line":"        in","counters":[]},{"line":"        compute_affected_locations_and_hashes t rev_parent_locations_and_hashes","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (List.rev_append rev_parent_locations_and_hashes acc)","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"      else acc","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"    else acc","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"  let set_hash_batch t locations_and_hashes =","counters":[]},{"line":"    Inputs.set_raw_hash_batch t","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (compute_affected_locations_and_hashes t locations_and_hashes","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"         locations_and_hashes )","counters":[]},{"line":"","counters":[]},{"line":"  let compute_last_index addresses =","counters":[]},{"line":"    Non_empty_list.map addresses","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"      ~f:(Fn.compose Inputs.Location.Addr.to_int Inputs.Location.to_path_exn)","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"    |> Non_empty_list.max_elt ~compare:Int.compare","counters":[]},{"line":"","counters":[]},{"line":"  let set_raw_addresses t addresses_and_accounts =","counters":[]},{"line":"    let ledger_depth = Inputs.ledger_depth t in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Option.iter (Non_empty_list.of_list_opt addresses_and_accounts)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"      ~f:(fun nonempty_addresses_and_accounts ->","counters":[]},{"line":"        let key_locations =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Non_empty_list.map nonempty_addresses_and_accounts","counters":[]},{"line":"            ~f:(fun (address, account) ->","counters":[]},{"line":"              (Inputs.Account.identifier account, address) )","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"        in","counters":[]},{"line":"        let new_last_location =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let current_last_index =","counters":[]},{"line":"            let open Option.Let_syntax in","counters":[]},{"line":"            let%map last_location = Inputs.Base.last_filled t in","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"            Inputs.Location.Addr.to_int","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            @@ Inputs.Location.to_path_exn last_location","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"          in","counters":[]},{"line":"          let foreign_last_index =","counters":[]},{"line":"            compute_last_index","counters":[]},{"line":"              (Non_empty_list.map nonempty_addresses_and_accounts ~f:fst)","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"          in","counters":[]},{"line":"          let max_index_in_all_accounts =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Option.value_map current_last_index ~default:foreign_last_index","counters":[]},{"line":"              ~f:(fun max_index -> Int.max max_index foreign_last_index)","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"          in","counters":[]},{"line":"          Inputs.Location.(","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Account (Addr.of_int_exn ~ledger_depth max_index_in_all_accounts))","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"        in","counters":[]},{"line":"        let last_location = new_last_location in","counters":[]},{"line":"        Inputs.set_location_batch ~last_location t key_locations )","counters":[]},{"line":"","counters":[]},{"line":"  (* TODO: When we do batch on a database, we should add accounts, locations and hashes","counters":[]},{"line":"     simulatenously for full atomicity. *)","counters":[]},{"line":"  let set_batch t locations_and_accounts =","counters":[]},{"line":"    set_raw_addresses t locations_and_accounts ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Inputs.set_raw_account_batch t locations_and_accounts ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    set_hash_batch t","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    @@ List.map locations_and_accounts ~f:(fun (location, account) ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"           ( Inputs.location_of_hash_addr (Inputs.Location.to_path_exn location)","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"           , Inputs.Hash.hash_account account ) )","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"","counters":[]},{"line":"  let set_batch_accounts t addresses_and_accounts =","counters":[]},{"line":"    set_batch t","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    @@ List.map addresses_and_accounts ~f:(fun (addr, account) ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"           (Inputs.location_of_account_addr addr, account) )","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"","counters":[]},{"line":"  let set_all_accounts_rooted_at_exn t address accounts =","counters":[]},{"line":"    let addresses =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Sequence.to_list","counters":[]},{"line":"      @@ Inputs.Location.Addr.Range.subtree_range_seq","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"           ~ledger_depth:(Inputs.ledger_depth t) address","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"    in","counters":[]},{"line":"    let num_accounts = List.length accounts in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    List.(zip_exn (take addresses num_accounts) accounts)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"    |> set_batch_accounts t","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}