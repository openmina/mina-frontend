{"filename":"src/lib/merkle_mask/masking_merkle_tree.ml","lines":[{"line":"(* masking_merkle_tree.ml -- implements a mask in front of a Merkle tree; see","counters":[]},{"line":"   RFC 0004 and docs/specs/merkle_tree.md *)","counters":[]},{"line":"","counters":[{"col_start":0,"col_end":0,"count":1}]},{"line":"open Core","counters":[]},{"line":"module Rust = Mina_tree.Rust","counters":[]},{"line":"","counters":[]},{"line":"(* builds a Merkle tree mask; it's a Merkle tree, with some additional","counters":[]},{"line":"   operations *)","counters":[]},{"line":"module Make (Inputs : Inputs_intf.S) = struct","counters":[]},{"line":"  open Inputs","counters":[]},{"line":"","counters":[]},{"line":"  type account = Account.t","counters":[]},{"line":"","counters":[]},{"line":"  type hash = Hash.t","counters":[]},{"line":"","counters":[]},{"line":"  type account_id = Account_id.t","counters":[]},{"line":"","counters":[]},{"line":"  type account_id_set = Account_id.Set.t","counters":[]},{"line":"","counters":[]},{"line":"  type location = Location.t","counters":[]},{"line":"","counters":[]},{"line":"  module Location = Location","counters":[]},{"line":"  module Addr = Location.Addr","counters":[]},{"line":"","counters":[]},{"line":"  let hash_from_rust hash =","counters":[]},{"line":"    hash |> Bigstring.of_bytes |> Hash.bin_read_t ~pos_ref:(ref 0)","counters":[{"col_start":4,"col_end":4,"count":16},{"col_start":29,"col_end":29,"count":16}]},{"line":"","counters":[]},{"line":"  let path_from_rust path =","counters":[]},{"line":"    match path with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | `Left hash ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        `Left (hash_from_rust hash)","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"    | `Right hash ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        `Right (hash_from_rust hash)","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"  let location_to_rust location =","counters":[]},{"line":"    Location.to_path_exn location |> Addr.to_string","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"  let account_location_from_rust addr = Location.Account (Addr.of_string addr)","counters":[{"col_start":40,"col_end":40,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"","counters":[]},{"line":"  let account_from_rust account =","counters":[]},{"line":"    Account.bin_read_t (Bigstring.of_bytes account) ~pos_ref:(ref 0)","counters":[{"col_start":4,"col_end":4,"count":216},{"col_start":41,"col_end":41,"count":216}]},{"line":"","counters":[]},{"line":"  let account_to_rust account =","counters":[]},{"line":"    let buf = Bigstring.create (Account.bin_size_t account) in","counters":[{"col_start":4,"col_end":4,"count":38},{"col_start":49,"col_end":49,"count":38}]},{"line":"    ignore (Account.bin_write_t buf ~pos:0 account : int) ;","counters":[{"col_start":4,"col_end":4,"count":38},{"col_start":30,"col_end":30,"count":38}]},{"line":"    Bigstring.to_bytes buf","counters":[]},{"line":"","counters":[]},{"line":"  let account_id_from_rust account_id =","counters":[]},{"line":"    Account_id.Stable.Latest.bin_read_t","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (Bigstring.of_bytes account_id)","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"      ~pos_ref:(ref 0)","counters":[]},{"line":"","counters":[]},{"line":"  let account_id_to_rust account_id =","counters":[]},{"line":"    let buf =","counters":[{"col_start":4,"col_end":4,"count":38}]},{"line":"      Bigstring.create (Account_id.Stable.Latest.bin_size_t account_id)","counters":[{"col_start":58,"col_end":58,"count":38}]},{"line":"    in","counters":[]},{"line":"    ignore (Account_id.Stable.Latest.bin_write_t buf ~pos:0 account_id : int) ;","counters":[{"col_start":4,"col_end":4,"count":38},{"col_start":47,"col_end":47,"count":38}]},{"line":"    Bigstring.to_bytes buf","counters":[]},{"line":"","counters":[]},{"line":"  let token_id_from_rust token_id =","counters":[]},{"line":"    Token_id.Stable.Latest.bin_read_t","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (Bigstring.of_bytes token_id)","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"      ~pos_ref:(ref 0)","counters":[]},{"line":"","counters":[]},{"line":"  let token_id_to_rust token_id =","counters":[]},{"line":"    let buf = Bigstring.create (Token_id.Stable.Latest.bin_size_t token_id) in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"    ignore (Token_id.Stable.Latest.bin_write_t buf ~pos:0 token_id : int) ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"    Bigstring.to_bytes buf","counters":[]},{"line":"","counters":[]},{"line":"  let pubkey_to_rust pubkey =","counters":[]},{"line":"    let buf = Bigstring.create (Key.Stable.Latest.bin_size_t pubkey) in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"    ignore (Key.Stable.Latest.bin_write_t buf ~pos:0 pubkey : int) ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"    Bigstring.to_bytes buf","counters":[]},{"line":"","counters":[]},{"line":"  (** Invariant is that parent is None in unattached mask and `Some` in the","counters":[]},{"line":"      attached one. We can capture this with a GADT but there's some annoying","counters":[]},{"line":"      issues with bin_io to do so *)","counters":[]},{"line":"  module Parent = struct","counters":[]},{"line":"    type t = (Base.t, string (* Location where null was set *)) Result.t","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    [@@deriving sexp]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Detached_parent_signal = struct","counters":[]},{"line":"    type t = unit Async.Ivar.t","counters":[]},{"line":"","counters":[]},{"line":"    let sexp_of_t (_ : t) = Sexp.List []","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"","counters":[]},{"line":"    let t_of_sexp (_ : Sexp.t) : t = Async.Ivar.create ()","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  type t = Mina_tree.mask","counters":[]},{"line":"","counters":[]},{"line":"  (* type t = *)","counters":[]},{"line":"  (*   { uuid : Uuid.Stable.V1.t *)","counters":[]},{"line":"  (*   ; account_tbl : Account.t Location_binable.Table.t *)","counters":[]},{"line":"  (*   ; token_owners : Account_id.t Token_id.Table.t *)","counters":[]},{"line":"  (*   ; mutable parent : Parent.t *)","counters":[]},{"line":"  (*   ; detached_parent_signal : Detached_parent_signal.t *)","counters":[]},{"line":"  (*   ; hash_tbl : Hash.t Addr.Table.t *)","counters":[]},{"line":"  (*   ; location_tbl : Location.t Account_id.Table.t *)","counters":[]},{"line":"  (*   ; mutable current_location : Location.t option *)","counters":[]},{"line":"  (*   ; depth : int *)","counters":[]},{"line":"  (*   } *)","counters":[]},{"line":"  (* [@@deriving sexp] *)","counters":[]},{"line":"","counters":[]},{"line":"  (* type unattached = Mina_tree.mask *)","counters":[]},{"line":"  type unattached = t","counters":[]},{"line":"  (* type unattached = t [@@deriving sexp] *)","counters":[]},{"line":"","counters":[]},{"line":"  let create ~depth () =","counters":[]},{"line":"    (*Printf.eprintf \"MY_LOG.MERKLE_MASK.MASKING.CREATE\\n%!\" ;*)","counters":[]},{"line":"    let rust_mask = Rust.mask_create depth in","counters":[{"col_start":4,"col_end":4,"count":3}]},{"line":"    rust_mask","counters":[{"col_start":4,"col_end":4,"count":3}]},{"line":"","counters":[]},{"line":"  (* let create ~depth () = *)","counters":[]},{"line":"  (*   let uuid = Uuid_unix.create () in *)","counters":[]},{"line":"  (*   Printf.eprintf \"MY_LOG.MERKLE_MASK.MASKING.CREATE %s\\n%!\" *)","counters":[]},{"line":"  (*     (Uuid.to_string uuid) ; *)","counters":[]},{"line":"  (*   { uuid *)","counters":[]},{"line":"  (*   ; parent = Error __LOC__ *)","counters":[]},{"line":"  (*   ; detached_parent_signal = Async.Ivar.create () *)","counters":[]},{"line":"  (*   ; account_tbl = Location_binable.Table.create () *)","counters":[]},{"line":"  (*   ; token_owners = Token_id.Table.create () *)","counters":[]},{"line":"  (*   ; hash_tbl = Addr.Table.create () *)","counters":[]},{"line":"  (*   ; location_tbl = Account_id.Table.create () *)","counters":[]},{"line":"  (*   ; current_location = None *)","counters":[]},{"line":"  (*   ; depth *)","counters":[]},{"line":"  (*   } *)","counters":[]},{"line":"","counters":[]},{"line":"  let get_uuid t = Rust.mask_get_uuid t |> Uuid.of_string","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"","counters":[]},{"line":"  (* let get_uuid { uuid; _ } = uuid *)","counters":[]},{"line":"","counters":[]},{"line":"  let depth t = Rust.mask_depth t","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"  (* let depth t = t.depth *)","counters":[]},{"line":"","counters":[]},{"line":"  let with_ledger ~f =","counters":[]},{"line":"    let mask = create () in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    f mask","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  module Attached = struct","counters":[]},{"line":"    (* type parent = Base.t [@@deriving sexp] *)","counters":[]},{"line":"    (* type parent = Base.t *)","counters":[]},{"line":"    type parent = t","counters":[]},{"line":"","counters":[]},{"line":"    (* type t = unattached [@@deriving sexp] *)","counters":[]},{"line":"    type t = unattached","counters":[]},{"line":"    (* type t = Mina_tree.mask *)","counters":[]},{"line":"","counters":[]},{"line":"    module Path = Base.Path","counters":[]},{"line":"    module Addr = Location.Addr","counters":[]},{"line":"    module Location = Location","counters":[]},{"line":"","counters":[]},{"line":"    type index = int","counters":[]},{"line":"","counters":[]},{"line":"    type path = Path.t","counters":[]},{"line":"","counters":[]},{"line":"    type root_hash = Hash.t","counters":[]},{"line":"","counters":[]},{"line":"    exception Location_is_not_account of Location.t","counters":[]},{"line":"","counters":[]},{"line":"    exception","counters":[]},{"line":"      Dangling_parent_reference of","counters":[]},{"line":"        Uuid.t * (* Location where null was set*) string","counters":[]},{"line":"","counters":[]},{"line":"    let sexp_of_t (_ : t) = Sexp.List []","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"","counters":[]},{"line":"    let t_of_sexp (_ : Sexp.t) : t = failwith \"t_of_sexp: not implemented\"","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"    let create () =","counters":[]},{"line":"      failwith","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        \"Mask.Attached.create: cannot create an attached mask; use Mask.create \\","counters":[]},{"line":"         and Mask.set_parent\"","counters":[]},{"line":"","counters":[]},{"line":"    let with_ledger ~f:_ =","counters":[]},{"line":"      failwith","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        \"Mask.Attached.with_ledger: cannot create an attached mask; use \\","counters":[]},{"line":"         Mask.create and Mask.set_parent\"","counters":[]},{"line":"","counters":[]},{"line":"    (* let unset_parent ?(trigger_signal = true) ~loc t = *)","counters":[]},{"line":"    (*   assert (Result.is_ok t.parent) ; *)","counters":[]},{"line":"    (*   t.parent <- Error loc ; *)","counters":[]},{"line":"    (*   if trigger_signal then *)","counters":[]},{"line":"    (*     Async.Ivar.fill_if_empty t.detached_parent_signal () ; *)","counters":[]},{"line":"    (*   t *)","counters":[]},{"line":"","counters":[]},{"line":"    (* let assert_is_attached t = *)","counters":[]},{"line":"    (*   match t.parent with *)","counters":[]},{"line":"    (*   | Error loc -> *)","counters":[]},{"line":"    (*       raise (Dangling_parent_reference (t.uuid, loc)) *)","counters":[]},{"line":"    (*   | Ok _ -> *)","counters":[]},{"line":"    (*       () *)","counters":[]},{"line":"","counters":[]},{"line":"    (* let detached_signal t = Async.Ivar.read t.detached_parent_signal *)","counters":[]},{"line":"","counters":[]},{"line":"    (* let get_parent t = Rust.mask_get_parent t *)","counters":[]},{"line":"","counters":[]},{"line":"    (* let get_parent ({ parent = opt; _ } as t) = *)","counters":[]},{"line":"    (*   assert_is_attached t ; Result.ok_or_failwith opt *)","counters":[]},{"line":"","counters":[]},{"line":"    let get_uuid t = Rust.mask_get_uuid t |> Uuid.of_string","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"    (* let get_uuid t = assert_is_attached t ; t.uuid *)","counters":[]},{"line":"","counters":[]},{"line":"    let get_directory t = Rust.mask_get_directory t","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"","counters":[]},{"line":"    (* let get_directory t = *)","counters":[]},{"line":"    (*   assert_is_attached t ; *)","counters":[]},{"line":"    (*   Base.get_directory (Result.ok_or_failwith t.parent) *)","counters":[]},{"line":"","counters":[]},{"line":"    let depth t = Rust.mask_depth t","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"    (* let depth t = assert_is_attached t ; t.depth *)","counters":[]},{"line":"","counters":[]},{"line":"    (* (\\* don't rely on a particular implementation *\\) *)","counters":[]},{"line":"    (* let self_find_hash t address = *)","counters":[]},{"line":"    (*   assert_is_attached t ; *)","counters":[]},{"line":"    (*   Addr.Table.find t.hash_tbl address *)","counters":[]},{"line":"","counters":[]},{"line":"    (* let self_set_hash t address hash = *)","counters":[]},{"line":"    (*   (\\* Printf.eprintf \"MY_LOG.MERKLE_MASK.MASKING.SET_HASH %s addr=%s\\n%!\" *\\) *)","counters":[]},{"line":"    (*   (\\*   (Uuid.to_string t.uuid) (Addr.to_string address) ; *\\) *)","counters":[]},{"line":"    (*   assert_is_attached t ; *)","counters":[]},{"line":"    (*   Addr.Table.set t.hash_tbl ~key:address ~data:hash *)","counters":[]},{"line":"","counters":[]},{"line":"    (* let set_inner_hash_at_addr_exn t address hash = *)","counters":[]},{"line":"    (*   assert_is_attached t ; *)","counters":[]},{"line":"    (*   assert (Addr.depth address <= t.depth) ; *)","counters":[]},{"line":"    (*   self_set_hash t address hash *)","counters":[]},{"line":"","counters":[]},{"line":"    (* (\\* don't rely on a particular implementation *\\) *)","counters":[]},{"line":"    (* let self_find_location t account_id = *)","counters":[]},{"line":"    (*   assert_is_attached t ; *)","counters":[]},{"line":"    (*   Account_id.Table.find t.location_tbl account_id *)","counters":[]},{"line":"","counters":[]},{"line":"    (* let self_set_location t account_id location = *)","counters":[]},{"line":"    (*   assert_is_attached t ; *)","counters":[]},{"line":"    (*   Account_id.Table.set t.location_tbl ~key:account_id ~data:location *)","counters":[]},{"line":"","counters":[]},{"line":"    (* (\\* don't rely on a particular implementation *\\) *)","counters":[]},{"line":"    (* let self_find_account t location = *)","counters":[]},{"line":"    (*   assert_is_attached t ; *)","counters":[]},{"line":"    (*   Location_binable.Table.find t.account_tbl location *)","counters":[]},{"line":"","counters":[]},{"line":"    (* let self_find_all_accounts t = *)","counters":[]},{"line":"    (*   assert_is_attached t ; *)","counters":[]},{"line":"    (*   Location_binable.Table.data t.account_tbl *)","counters":[]},{"line":"","counters":[]},{"line":"    (* let self_set_account t location account = *)","counters":[]},{"line":"    (*   (\\* Printf.eprintf \"MY_LOG.MERKLE_MASK.MASKING.SET_ACCOUNT %s\\n%!\" *\\) *)","counters":[]},{"line":"    (*   (\\*   (Uuid.to_string t.uuid) ; *\\) *)","counters":[]},{"line":"    (*   assert_is_attached t ; *)","counters":[]},{"line":"    (*   Location_binable.Table.set t.account_tbl ~key:location ~data:account ; *)","counters":[]},{"line":"    (*   self_set_location t (Account.identifier account) location *)","counters":[]},{"line":"","counters":[]},{"line":"    (* a read does a lookup in the account_tbl; if that fails, delegate to","counters":[]},{"line":"       parent *)","counters":[]},{"line":"","counters":[]},{"line":"    let get t location =","counters":[]},{"line":"      let addr = location_to_rust location in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Rust.mask_get t addr |> Option.map ~f:account_from_rust","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"","counters":[]},{"line":"    (* let get t location = *)","counters":[]},{"line":"    (*   assert_is_attached t ; *)","counters":[]},{"line":"    (*   match self_find_account t location with *)","counters":[]},{"line":"    (*   | Some account -> *)","counters":[]},{"line":"    (*       Some account *)","counters":[]},{"line":"    (*   | None -> *)","counters":[]},{"line":"    (*       Base.get (get_parent t) location *)","counters":[]},{"line":"","counters":[]},{"line":"    let get_batch t locations =","counters":[]},{"line":"      let addrs = List.map locations ~f:location_to_rust in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Rust.mask_get_batch t addrs","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"      |> List.map ~f:(fun (addr, account) ->","counters":[]},{"line":"             ( account_location_from_rust addr","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"             , Option.map account ~f:account_from_rust ) )","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"","counters":[]},{"line":"    (* let get_batch t locations = *)","counters":[]},{"line":"    (*   assert_is_attached t ; *)","counters":[]},{"line":"    (*   let found_accounts, leftover_locations = *)","counters":[]},{"line":"    (*     List.partition_map locations ~f:(fun location -> *)","counters":[]},{"line":"    (*         match self_find_account t location with *)","counters":[]},{"line":"    (*         | Some account -> *)","counters":[]},{"line":"    (*             Either.first (location, Some account) *)","counters":[]},{"line":"    (*         | None -> *)","counters":[]},{"line":"    (*             Either.second location ) *)","counters":[]},{"line":"    (*   in *)","counters":[]},{"line":"    (*   found_accounts @ Base.get_batch (get_parent t) leftover_locations *)","counters":[]},{"line":"","counters":[]},{"line":"    (* fixup_merkle_path patches a Merkle path reported by the parent,","counters":[]},{"line":"       overriding with hashes which are stored in the mask *)","counters":[]},{"line":"","counters":[]},{"line":"    (* let fixup_merkle_path t path address = *)","counters":[]},{"line":"    (*   let rec build_fixed_path path address accum = *)","counters":[]},{"line":"    (*     if List.is_empty path then List.rev accum *)","counters":[]},{"line":"    (*     else *)","counters":[]},{"line":"    (*       (\\* first element in the path contains hash at sibling of address *\\) *)","counters":[]},{"line":"    (*       let curr_element = List.hd_exn path in *)","counters":[]},{"line":"    (*       let merkle_node_address = Addr.sibling address in *)","counters":[]},{"line":"    (*       let mask_hash = self_find_hash t merkle_node_address in *)","counters":[]},{"line":"    (*       let parent_hash = match curr_element with `Left h | `Right h -> h in *)","counters":[]},{"line":"    (*       let new_hash = Option.value mask_hash ~default:parent_hash in *)","counters":[]},{"line":"    (*       let new_element = *)","counters":[]},{"line":"    (*         match curr_element with *)","counters":[]},{"line":"    (*         | `Left _ -> *)","counters":[]},{"line":"    (*             `Left new_hash *)","counters":[]},{"line":"    (*         | `Right _ -> *)","counters":[]},{"line":"    (*             `Right new_hash *)","counters":[]},{"line":"    (*       in *)","counters":[]},{"line":"    (*       build_fixed_path (List.tl_exn path) (Addr.parent_exn address) *)","counters":[]},{"line":"    (*         (new_element :: accum) *)","counters":[]},{"line":"    (*   in *)","counters":[]},{"line":"    (*   build_fixed_path path address [] *)","counters":[]},{"line":"","counters":[]},{"line":"    (* the following merkle_path_* functions report the Merkle path for the","counters":[]},{"line":"       mask *)","counters":[]},{"line":"","counters":[]},{"line":"    let merkle_path t location =","counters":[]},{"line":"      Rust.mask_merkle_path t (location_to_rust location)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"      |> List.map ~f:path_from_rust","counters":[]},{"line":"","counters":[]},{"line":"    let merkle_path_at_addr_exn t addr =","counters":[]},{"line":"      Rust.mask_merkle_path_at_addr t (Addr.to_string addr)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"      |> List.map ~f:path_from_rust","counters":[]},{"line":"","counters":[]},{"line":"    let merkle_path_at_index_exn t index =","counters":[]},{"line":"      Rust.mask_merkle_path_at_index t index |> List.map ~f:path_from_rust","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"    (* let merkle_path_at_addr_exn t address = *)","counters":[]},{"line":"    (*   assert_is_attached t ; *)","counters":[]},{"line":"    (*   let parent_merkle_path = *)","counters":[]},{"line":"    (*     Base.merkle_path_at_addr_exn (get_parent t) address *)","counters":[]},{"line":"    (*   in *)","counters":[]},{"line":"    (*   fixup_merkle_path t parent_merkle_path address *)","counters":[]},{"line":"","counters":[]},{"line":"    (* let merkle_path_at_index_exn t index = *)","counters":[]},{"line":"    (*   assert_is_attached t ; *)","counters":[]},{"line":"    (*   let address = Addr.of_int_exn ~ledger_depth:t.depth index in *)","counters":[]},{"line":"    (*   let parent_merkle_path = *)","counters":[]},{"line":"    (*     Base.merkle_path_at_addr_exn (get_parent t) address *)","counters":[]},{"line":"    (*   in *)","counters":[]},{"line":"    (*   fixup_merkle_path t parent_merkle_path address *)","counters":[]},{"line":"","counters":[]},{"line":"    (* let merkle_path t location = *)","counters":[]},{"line":"    (*   assert_is_attached t ; *)","counters":[]},{"line":"    (*   let address = Location.to_path_exn location in *)","counters":[]},{"line":"    (*   let parent_merkle_path = Base.merkle_path (get_parent t) location in *)","counters":[]},{"line":"    (*   fixup_merkle_path t parent_merkle_path address *)","counters":[]},{"line":"","counters":[]},{"line":"    (* given a Merkle path corresponding to a starting address, calculate","counters":[]},{"line":"       addresses and hashes for each node affected by the starting hash; that is,","counters":[]},{"line":"       along the path from the account address to root *)","counters":[]},{"line":"    (* let addresses_and_hashes_from_merkle_path_exn merkle_path starting_address *)","counters":[]},{"line":"    (*     starting_hash : (Addr.t * Hash.t) list = *)","counters":[]},{"line":"    (*   let get_addresses_hashes height accum node = *)","counters":[]},{"line":"    (*     let last_address, last_hash = List.hd_exn accum in *)","counters":[]},{"line":"    (*     let next_address = Addr.parent_exn last_address in *)","counters":[]},{"line":"    (*     let next_hash = *)","counters":[]},{"line":"    (*       match node with *)","counters":[]},{"line":"    (*       | `Left sibling_hash -> *)","counters":[]},{"line":"    (*           Hash.merge ~height last_hash sibling_hash *)","counters":[]},{"line":"    (*       | `Right sibling_hash -> *)","counters":[]},{"line":"    (*           Hash.merge ~height sibling_hash last_hash *)","counters":[]},{"line":"    (*     in *)","counters":[]},{"line":"    (*     (next_address, next_hash) :: accum *)","counters":[]},{"line":"    (*   in *)","counters":[]},{"line":"    (*   List.foldi merkle_path *)","counters":[]},{"line":"    (*     ~init:[ (starting_address, starting_hash) ] *)","counters":[]},{"line":"    (*     ~f:get_addresses_hashes *)","counters":[]},{"line":"","counters":[]},{"line":"    (* use mask Merkle root, if it exists, else get from parent *)","counters":[]},{"line":"    let merkle_root t = Rust.mask_merkle_root t |> hash_from_rust","counters":[{"col_start":24,"col_end":24,"count":16},{"col_start":44,"col_end":44,"count":16}]},{"line":"","counters":[]},{"line":"    (* let merkle_root t = *)","counters":[]},{"line":"    (*   (\\* Printf.eprintf \"MY_LOG.MERKLE_MASK.MASKING.MERKLE_ROOT uuid=%s\\n%!\" *\\) *)","counters":[]},{"line":"    (*   (\\*   (Uuid.to_string t.uuid) ; *\\) *)","counters":[]},{"line":"    (*   assert_is_attached t ; *)","counters":[]},{"line":"    (*   match self_find_hash t (Addr.root ()) with *)","counters":[]},{"line":"    (*   | Some hash -> *)","counters":[]},{"line":"    (*       hash *)","counters":[]},{"line":"    (*   | None -> *)","counters":[]},{"line":"    (*       Base.merkle_root (get_parent t) *)","counters":[]},{"line":"","counters":[]},{"line":"    (* let remove_account_and_update_hashes t location = *)","counters":[]},{"line":"    (*   assert_is_attached t ; *)","counters":[]},{"line":"    (*   (\\* remove account and key from tables *\\) *)","counters":[]},{"line":"    (*   let account = Option.value_exn (self_find_account t location) in *)","counters":[]},{"line":"    (*   Location_binable.Table.remove t.account_tbl location ; *)","counters":[]},{"line":"    (*   (\\* Update token info. *\\) *)","counters":[]},{"line":"    (*   let account_id = Account.identifier account in *)","counters":[]},{"line":"    (*   Token_id.Table.remove t.token_owners *)","counters":[]},{"line":"    (*     (Account_id.derive_token_id ~owner:account_id) ; *)","counters":[]},{"line":"    (*   (\\* TODO : use stack database to save unused location, which can be used *)","counters":[]},{"line":"    (*      when allocating a location *\\) *)","counters":[]},{"line":"    (*   Account_id.Table.remove t.location_tbl account_id ; *)","counters":[]},{"line":"    (*   (\\* reuse location if possible *\\) *)","counters":[]},{"line":"    (*   Option.iter t.current_location ~f:(fun curr_loc -> *)","counters":[]},{"line":"    (*       if Location.equal location curr_loc then *)","counters":[]},{"line":"    (*         match Location.prev location with *)","counters":[]},{"line":"    (*         | Some prev_loc -> *)","counters":[]},{"line":"    (*             t.current_location <- Some prev_loc *)","counters":[]},{"line":"    (*         | None -> *)","counters":[]},{"line":"    (*             t.current_location <- None ) ; *)","counters":[]},{"line":"    (*   (\\* update hashes *\\) *)","counters":[]},{"line":"    (*   let account_address = Location.to_path_exn location in *)","counters":[]},{"line":"    (*   let account_hash = Hash.empty_account in *)","counters":[]},{"line":"    (*   let merkle_path = merkle_path t location in *)","counters":[]},{"line":"    (*   let addresses_and_hashes = *)","counters":[]},{"line":"    (*     addresses_and_hashes_from_merkle_path_exn merkle_path account_address *)","counters":[]},{"line":"    (*       account_hash *)","counters":[]},{"line":"    (*   in *)","counters":[]},{"line":"    (*   List.iter addresses_and_hashes ~f:(fun (addr, hash) -> *)","counters":[]},{"line":"    (*       self_set_hash t addr hash ) *)","counters":[]},{"line":"","counters":[]},{"line":"    (* a write writes only to the mask, parent is not involved need to update","counters":[]},{"line":"       both account and hash pieces of the mask *)","counters":[]},{"line":"    let set t location account =","counters":[]},{"line":"      let location = location_to_rust location in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Rust.mask_set t location (account_to_rust account)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"","counters":[]},{"line":"    (* let set t location account = *)","counters":[]},{"line":"    (*   (\\* Printf.eprintf \"MY_LOG.MERKLE_MASK.MASKING.SET\\n%!\" ; *\\) *)","counters":[]},{"line":"    (*   assert_is_attached t ; *)","counters":[]},{"line":"    (*   self_set_account t location account ; *)","counters":[]},{"line":"    (*   (\\* Update token info. *\\) *)","counters":[]},{"line":"    (*   let account_id = Account.identifier account in *)","counters":[]},{"line":"    (*   Token_id.Table.set t.token_owners *)","counters":[]},{"line":"    (*     ~key:(Account_id.derive_token_id ~owner:account_id) *)","counters":[]},{"line":"    (*     ~data:account_id ; *)","counters":[]},{"line":"    (*   (\\* Update merkle path. *\\) *)","counters":[]},{"line":"    (*   let account_address = Location.to_path_exn location in *)","counters":[]},{"line":"    (*   let account_hash = Hash.hash_account account in *)","counters":[]},{"line":"    (*   let merkle_path = merkle_path t location in *)","counters":[]},{"line":"    (*   let addresses_and_hashes = *)","counters":[]},{"line":"    (*     addresses_and_hashes_from_merkle_path_exn merkle_path account_address *)","counters":[]},{"line":"    (*       account_hash *)","counters":[]},{"line":"    (*   in *)","counters":[]},{"line":"    (*   List.iter addresses_and_hashes ~f:(fun (addr, hash) -> *)","counters":[]},{"line":"    (*       (\\* Printf.eprintf \"SELF_SET_HASH %s\\n%!\" (Addr.to_string addr) ; *\\) *)","counters":[]},{"line":"    (*       self_set_hash t addr hash ) *)","counters":[]},{"line":"","counters":[]},{"line":"    (* if the mask's parent sets an account, we can prune an entry in the mask","counters":[]},{"line":"       if the account in the parent is the same in the mask *)","counters":[]},{"line":"    (* let parent_set_notify t account = *)","counters":[]},{"line":"    (*   assert_is_attached t ; *)","counters":[]},{"line":"    (*   match self_find_location t (Account.identifier account) with *)","counters":[]},{"line":"    (*   | None -> *)","counters":[]},{"line":"    (*       () *)","counters":[]},{"line":"    (*   | Some location -> ( *)","counters":[]},{"line":"    (*       match self_find_account t location with *)","counters":[]},{"line":"    (*       | Some existing_account -> *)","counters":[]},{"line":"    (*           if Account.equal account existing_account then *)","counters":[]},{"line":"    (*             remove_account_and_update_hashes t location *)","counters":[]},{"line":"    (*       | None -> *)","counters":[]},{"line":"    (*           () ) *)","counters":[]},{"line":"","counters":[]},{"line":"    (* as for accounts, we see if we have it in the mask, else delegate to","counters":[]},{"line":"       parent *)","counters":[]},{"line":"    (* let get_hash t addr =","counters":[]},{"line":"     *   Rust.mask_get_hash t (Addr.to_string addr) |> hash_from_rust |> Some *)","counters":[]},{"line":"","counters":[]},{"line":"    (* let get_hash t addr = *)","counters":[]},{"line":"    (*   assert_is_attached t ; *)","counters":[]},{"line":"    (*   match self_find_hash t addr with *)","counters":[]},{"line":"    (*   | Some hash -> *)","counters":[]},{"line":"    (*       Some hash *)","counters":[]},{"line":"    (*   | None -> ( *)","counters":[]},{"line":"    (*       try *)","counters":[]},{"line":"    (*         (\\* Printf.eprintf \"inner hash here\\n%!\" ; *\\) *)","counters":[]},{"line":"    (*         let hash = Base.get_inner_hash_at_addr_exn (get_parent t) addr in *)","counters":[]},{"line":"    (*         Some hash *)","counters":[]},{"line":"    (*       with _ -> None ) *)","counters":[]},{"line":"","counters":[]},{"line":"    (* batch operations TODO: rely on availability of batch operations in Base","counters":[]},{"line":"       for speed *)","counters":[]},{"line":"    (* NB: rocksdb does not support batch reads; should we offer this? *)","counters":[]},{"line":"","counters":[]},{"line":"    let set_batch t locations_and_accounts =","counters":[]},{"line":"      let accounts =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        List.map locations_and_accounts ~f:(fun (location, account) ->","counters":[]},{"line":"            (location_to_rust location, account_to_rust account) )","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"      in","counters":[]},{"line":"      Rust.mask_set_batch_accounts t accounts","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let get_batch_exn t locations =","counters":[]},{"line":"      let addrs = List.map locations ~f:location_to_rust in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Rust.mask_get_batch t addrs","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"      |> List.map ~f:(fun (addr, account) ->","counters":[]},{"line":"             ( account_location_from_rust addr","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"             , Option.map account ~f:account_from_rust ) )","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"","counters":[]},{"line":"    let detached_signal _t = Async.Ivar.read (Async.Ivar.create ())","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"","counters":[]},{"line":"    (* Printf.eprintf \"MY_LOG.MERKLE_MASK.DETACHED_SIGNAL\\n%!\" *)","counters":[]},{"line":"","counters":[]},{"line":"    (* let detached_signal _t = failwith \"detached_signal: not implemented\" *)","counters":[]},{"line":"","counters":[]},{"line":"    (* let get_batch_exn t locations = *)","counters":[]},{"line":"    (*   assert_is_attached t ; *)","counters":[]},{"line":"    (*   List.map locations ~f:(fun location -> get t location) *)","counters":[]},{"line":"","counters":[]},{"line":"    (* NB: rocksdb does not support batch reads; is this needed? *)","counters":[]},{"line":"    (* let get_hash_batch_exn t addrs = *)","counters":[]},{"line":"    (*   assert_is_attached t ; *)","counters":[]},{"line":"    (*   List.map addrs ~f:(fun addr -> *)","counters":[]},{"line":"    (*       match self_find_hash t addr with *)","counters":[]},{"line":"    (*       | Some account -> *)","counters":[]},{"line":"    (*           Some account *)","counters":[]},{"line":"    (*       | None -> ( *)","counters":[]},{"line":"    (*           try Some (Base.get_inner_hash_at_addr_exn (get_parent t) addr) *)","counters":[]},{"line":"    (*           with _ -> None ) ) *)","counters":[]},{"line":"","counters":[]},{"line":"    (* transfer state from mask to parent; flush local state *)","counters":[]},{"line":"    let commit t = Rust.mask_commit t","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"","counters":[]},{"line":"    (* let commit t = *)","counters":[]},{"line":"    (*   assert_is_attached t ; *)","counters":[]},{"line":"    (*   (\\* Printf.eprintf \"AAA\\n%!\" ; *\\) *)","counters":[]},{"line":"    (*   let old_root_hash = merkle_root t in *)","counters":[]},{"line":"    (*   (\\* Printf.eprintf \"BBB\\n%!\" ; *\\) *)","counters":[]},{"line":"    (*   let account_data = Location_binable.Table.to_alist t.account_tbl in *)","counters":[]},{"line":"    (*   (\\* Printf.eprintf \"NACCOUNTS=%d\\n%!\" (List.length account_data) ; *\\) *)","counters":[]},{"line":"    (*   Base.set_batch (get_parent t) account_data ; *)","counters":[]},{"line":"    (*   Location_binable.Table.clear t.account_tbl ; *)","counters":[]},{"line":"    (*   Addr.Table.clear t.hash_tbl ; *)","counters":[]},{"line":"    (*   (\\* Printf.eprintf \"CCC\\n%!\" ; *\\) *)","counters":[]},{"line":"    (*   Debug_assert.debug_assert (fun () -> *)","counters":[]},{"line":"    (*       [%test_result: Hash.t] *)","counters":[]},{"line":"    (*         ~message: *)","counters":[]},{"line":"    (* \"Parent merkle root after committing should be the same as the \\ *)","counters":[]},{"line":"       (*            old one in the mask\" *)","counters":[]},{"line":"    (*         ~expect:old_root_hash *)","counters":[]},{"line":"    (*         (Base.merkle_root (get_parent t)) ; *)","counters":[]},{"line":"    (*       [%test_result: Hash.t] *)","counters":[]},{"line":"    (*         ~message:\"Merkle root of the mask should delegate to the parent now\" *)","counters":[]},{"line":"    (*         ~expect:(merkle_root t) *)","counters":[]},{"line":"    (*         (Base.merkle_root (get_parent t)) ) *)","counters":[]},{"line":"","counters":[]},{"line":"    (* copy tables in t; use same parent *)","counters":[]},{"line":"    let copy t = Rust.mask_copy t","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"","counters":[]},{"line":"    (* let copy t = *)","counters":[]},{"line":"    (*   { uuid = Uuid_unix.create () *)","counters":[]},{"line":"    (*   ; parent = Ok (get_parent t) *)","counters":[]},{"line":"    (*   ; detached_parent_signal = Async.Ivar.create () *)","counters":[]},{"line":"    (*   ; account_tbl = Location_binable.Table.copy t.account_tbl *)","counters":[]},{"line":"    (*   ; token_owners = Token_id.Table.copy t.token_owners *)","counters":[]},{"line":"    (*   ; location_tbl = Account_id.Table.copy t.location_tbl *)","counters":[]},{"line":"    (*   ; hash_tbl = Addr.Table.copy t.hash_tbl *)","counters":[]},{"line":"    (*   ; current_location = t.current_location *)","counters":[]},{"line":"    (*   ; depth = t.depth *)","counters":[]},{"line":"    (*   } *)","counters":[]},{"line":"","counters":[]},{"line":"    let last_filled t =","counters":[]},{"line":"      Rust.mask_last_filled t","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"      |> Option.map ~f:(fun last -> Location.Account (Addr.of_string last))","counters":[{"col_start":36,"col_end":36,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"","counters":[]},{"line":"    (* let last_filled t = *)","counters":[]},{"line":"    (*   assert_is_attached t ; *)","counters":[]},{"line":"    (*   Option.value_map *)","counters":[]},{"line":"    (*     (Base.last_filled (get_parent t)) *)","counters":[]},{"line":"    (*     ~default:t.current_location *)","counters":[]},{"line":"    (*     ~f:(fun parent_loc -> *)","counters":[]},{"line":"    (*       match t.current_location with *)","counters":[]},{"line":"    (*       | None -> *)","counters":[]},{"line":"    (*           Some parent_loc *)","counters":[]},{"line":"    (*       | Some our_loc -> ( *)","counters":[]},{"line":"    (*           match (parent_loc, our_loc) with *)","counters":[]},{"line":"    (*           | Account parent_addr, Account our_addr -> *)","counters":[]},{"line":"    (*               (\\* Addr.compare is Bitstring.compare, essentially String.compare *\\) *)","counters":[]},{"line":"    (*               let loc = *)","counters":[]},{"line":"    (*                 if Addr.compare parent_addr our_addr >= 0 then parent_loc *)","counters":[]},{"line":"    (*                 else our_loc *)","counters":[]},{"line":"    (*               in *)","counters":[]},{"line":"    (*               Some loc *)","counters":[]},{"line":"    (*           | _ -> *)","counters":[]},{"line":"    (*               failwith *)","counters":[]},{"line":"    (* \"last_filled: expected account locations for the parent \\ *)","counters":[]},{"line":"       (*                  and mask\" ) ) *)","counters":[]},{"line":"","counters":[]},{"line":"    (* include Merkle_ledger.Util.Make (struct *)","counters":[]},{"line":"    (*   module Location = Location *)","counters":[]},{"line":"    (*   module Location_binable = Location_binable *)","counters":[]},{"line":"    (*   module Key = Key *)","counters":[]},{"line":"    (*   module Token_id = Token_id *)","counters":[]},{"line":"    (*   module Account_id = Account_id *)","counters":[]},{"line":"    (*   module Account = Account *)","counters":[]},{"line":"    (*   module Hash = Hash *)","counters":[]},{"line":"    (*   module Balance = Balance *)","counters":[]},{"line":"","counters":[]},{"line":"    (*   module Base = struct *)","counters":[]},{"line":"    (*     type nonrec t = t *)","counters":[]},{"line":"","counters":[]},{"line":"    (*     let get = get *)","counters":[]},{"line":"","counters":[]},{"line":"    (*     let last_filled = last_filled *)","counters":[]},{"line":"    (*   end *)","counters":[]},{"line":"","counters":[]},{"line":"    (*   let ledger_depth = depth *)","counters":[]},{"line":"","counters":[]},{"line":"    (*   let location_of_account_addr addr = Location.Account addr *)","counters":[]},{"line":"","counters":[]},{"line":"    (*   let location_of_hash_addr addr = Location.Hash addr *)","counters":[]},{"line":"","counters":[]},{"line":"    (*   let get_hash t location = *)","counters":[]},{"line":"    (*     Option.value_exn (get_hash t (Location.to_path_exn location)) *)","counters":[]},{"line":"","counters":[]},{"line":"    (*   let set_raw_hash_batch t locations_and_hashes = *)","counters":[]},{"line":"    (*     List.iter locations_and_hashes ~f:(fun (location, hash) -> *)","counters":[]},{"line":"    (*         self_set_hash t (Location.to_path_exn location) hash ) *)","counters":[]},{"line":"","counters":[]},{"line":"    (*   let set_location_batch ~last_location t account_to_location_list = *)","counters":[]},{"line":"    (*     t.current_location <- Some last_location ; *)","counters":[]},{"line":"    (*     Non_empty_list.iter account_to_location_list ~f:(fun (key, data) -> *)","counters":[]},{"line":"    (*         Account_id.Table.set t.location_tbl ~key ~data ) *)","counters":[]},{"line":"","counters":[]},{"line":"    (*   let set_raw_account_batch t locations_and_accounts = *)","counters":[]},{"line":"    (*     List.iter locations_and_accounts ~f:(fun (location, account) -> *)","counters":[]},{"line":"    (*         let account_id = Account.identifier account in *)","counters":[]},{"line":"    (*         Token_id.Table.set t.token_owners *)","counters":[]},{"line":"    (*           ~key:(Account_id.derive_token_id ~owner:account_id) *)","counters":[]},{"line":"    (*           ~data:account_id ; *)","counters":[]},{"line":"    (*         self_set_account t location account ) *)","counters":[]},{"line":"    (* end) *)","counters":[]},{"line":"","counters":[]},{"line":"    let set_batch_accounts t addresses_and_accounts =","counters":[]},{"line":"      (* Printf.eprintf \"SET_BATCH_ACCOUNT '%s'\\n%!\" *)","counters":[]},{"line":"      (*   (Addr.to_string (Addr.of_string \"0101011111\")) ; *)","counters":[]},{"line":"      let accounts =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        List.map addresses_and_accounts ~f:(fun (addr, account) ->","counters":[]},{"line":"            (* Printf.eprintf \"ADDR HERE %s\\n%!\" (Addr.to_string addr) ; *)","counters":[]},{"line":"            (Addr.to_string addr, account_to_rust account) )","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"      in","counters":[]},{"line":"      Rust.mask_set_batch_accounts t accounts","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    (* let set_batch_accounts t addresses_and_accounts = *)","counters":[]},{"line":"    (*   (\\* Printf.eprintf \"MY_LOG.MERKLE_MASK.MASKING.SET_BATCH_ACCOUNTS\\n%!\" ; *\\) *)","counters":[]},{"line":"    (*   assert_is_attached t ; *)","counters":[]},{"line":"    (*   set_batch_accounts t addresses_and_accounts *)","counters":[]},{"line":"","counters":[]},{"line":"    (* set accounts in mask *)","counters":[]},{"line":"","counters":[]},{"line":"    let get_all_accounts_rooted_at_exn t addr =","counters":[]},{"line":"      let accounts =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Rust.mask_get_all_accounts_rooted_at t (Addr.to_string addr)","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"      in","counters":[]},{"line":"      List.map accounts ~f:(fun (addr, account) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          (Addr.of_string addr, account_from_rust account) )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"","counters":[]},{"line":"    let set_all_accounts_rooted_at_exn t addr accounts =","counters":[]},{"line":"      let accounts = List.map accounts ~f:account_to_rust in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Rust.mask_set_all_accounts_rooted_at t (Addr.to_string addr) accounts","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"","counters":[]},{"line":"    (* let set_all_accounts_rooted_at_exn t address (accounts : Account.t list) = *)","counters":[]},{"line":"    (*   assert_is_attached t ; *)","counters":[]},{"line":"    (*   set_all_accounts_rooted_at_exn t address accounts *)","counters":[]},{"line":"","counters":[]},{"line":"    (* keys from this mask and all ancestors *)","counters":[]},{"line":"","counters":[]},{"line":"    let accounts t =","counters":[]},{"line":"      Rust.mask_get_list t","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"      |> List.map ~f:account_id_from_rust","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"      |> Account_id.Set.of_list","counters":[]},{"line":"","counters":[]},{"line":"    (* let accounts t = *)","counters":[]},{"line":"    (*   assert_is_attached t ; *)","counters":[]},{"line":"    (*   let mask_keys = *)","counters":[]},{"line":"    (*     Location_binable.Table.data t.account_tbl *)","counters":[]},{"line":"    (*     |> List.map ~f:Account.identifier *)","counters":[]},{"line":"    (*     |> Account_id.Set.of_list *)","counters":[]},{"line":"    (*   in *)","counters":[]},{"line":"    (*   let parent_keys = Base.accounts (get_parent t) in *)","counters":[]},{"line":"    (*   Account_id.Set.union parent_keys mask_keys *)","counters":[]},{"line":"","counters":[]},{"line":"    let token_owner t token_id =","counters":[]},{"line":"      Rust.mask_token_owner t (token_id_to_rust token_id)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"      |> Option.map ~f:(fun owner -> account_id_from_rust owner)","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"    (* let token_owner (t : t) (tid : Token_id.t) : Account_id.t option = *)","counters":[]},{"line":"    (*   assert_is_attached t ; *)","counters":[]},{"line":"    (*   match Token_id.Table.find t.token_owners tid with *)","counters":[]},{"line":"    (*   | Some id -> *)","counters":[]},{"line":"    (*       Some id *)","counters":[]},{"line":"    (*   | None -> *)","counters":[]},{"line":"    (*       Base.token_owner (get_parent t) tid *)","counters":[]},{"line":"","counters":[]},{"line":"    let token_owners (t : t) : Account_id.Set.t =","counters":[]},{"line":"      let list = Rust.mask_token_owners t in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let list =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        List.map list ~f:(fun v ->","counters":[]},{"line":"            Account_id.Stable.Latest.bin_read_t (Bigstring.of_bytes v)","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"              ~pos_ref:(ref 0) )","counters":[]},{"line":"      in","counters":[]},{"line":"      Account_id.Set.of_list list","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    (* let token_owners (t : t) : Account_id.Set.t = *)","counters":[]},{"line":"    (*   assert_is_attached t ; *)","counters":[]},{"line":"    (*   let mask_owners = *)","counters":[]},{"line":"    (*     Hashtbl.fold t.token_owners ~init:Account_id.Set.empty *)","counters":[]},{"line":"    (*       ~f:(fun ~key:_tid ~data:owner acc -> Set.add acc owner) *)","counters":[]},{"line":"    (*   in *)","counters":[]},{"line":"    (*   Set.union mask_owners (Base.token_owners (get_parent t)) *)","counters":[]},{"line":"","counters":[]},{"line":"    let tokens t key =","counters":[]},{"line":"      Rust.mask_tokens t (pubkey_to_rust key)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"      |> List.map ~f:token_id_from_rust","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"      |> Token_id.Set.of_list","counters":[]},{"line":"","counters":[]},{"line":"    (* let tokens t pk = *)","counters":[]},{"line":"    (*   assert_is_attached t ; *)","counters":[]},{"line":"    (*   let mask_tokens = *)","counters":[]},{"line":"    (*     Account_id.Table.keys t.location_tbl *)","counters":[]},{"line":"    (*     |> List.filter_map ~f:(fun aid -> *)","counters":[]},{"line":"    (*            if Key.equal pk (Account_id.public_key aid) then *)","counters":[]},{"line":"    (*              Some (Account_id.token_id aid) *)","counters":[]},{"line":"    (*            else None ) *)","counters":[]},{"line":"    (*     |> Token_id.Set.of_list *)","counters":[]},{"line":"    (*   in *)","counters":[]},{"line":"    (*   Set.union mask_tokens (Base.tokens (get_parent t) pk) *)","counters":[]},{"line":"","counters":[]},{"line":"    let num_accounts t = Rust.mask_num_accounts t","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"    (* let num_accounts t = *)","counters":[]},{"line":"    (*   assert_is_attached t ; *)","counters":[]},{"line":"    (*   match t.current_location with *)","counters":[]},{"line":"    (*   | None -> *)","counters":[]},{"line":"    (*       0 *)","counters":[]},{"line":"    (*   | Some location -> ( *)","counters":[]},{"line":"    (*       match location with *)","counters":[]},{"line":"    (*       | Account addr -> *)","counters":[]},{"line":"    (*           Addr.to_int addr + 1 *)","counters":[]},{"line":"    (*       | _ -> *)","counters":[]},{"line":"    (*           failwith \"Expected mask current location to represent an account\" *)","counters":[]},{"line":"    (*       ) *)","counters":[]},{"line":"","counters":[]},{"line":"    let location_of_account t account_id =","counters":[]},{"line":"      Rust.mask_location_of_account t (account_id_to_rust account_id)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"      |> Option.map ~f:(fun addr -> Location.Account (Addr.of_string addr))","counters":[{"col_start":36,"col_end":36,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"","counters":[]},{"line":"    let location_of_account_batch t account_ids =","counters":[]},{"line":"      let account_ids =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        List.map account_ids ~f:(fun account_id ->","counters":[]},{"line":"            account_id_to_rust account_id )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"      in","counters":[]},{"line":"      let list =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Rust.mask_location_of_account_batch t account_ids","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"        |> List.map ~f:(fun (account_id, addr) ->","counters":[]},{"line":"               ( account_id_from_rust account_id","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"               , Option.map addr ~f:(fun addr ->","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                     Location.Account (Addr.of_string addr) ) ) )","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"      in","counters":[]},{"line":"      list","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    (* let location_of_account t account_id = *)","counters":[]},{"line":"    (*   assert_is_attached t ; *)","counters":[]},{"line":"    (*   let mask_result = self_find_location t account_id in *)","counters":[]},{"line":"    (*   match mask_result with *)","counters":[]},{"line":"    (*   | Some _ -> *)","counters":[]},{"line":"    (*       mask_result *)","counters":[]},{"line":"    (*   | None -> *)","counters":[]},{"line":"    (*       Base.location_of_account (get_parent t) account_id *)","counters":[]},{"line":"","counters":[]},{"line":"    (* let location_of_account_batch t account_ids = *)","counters":[]},{"line":"    (*   assert_is_attached t ; *)","counters":[]},{"line":"    (*   let found_locations, leftover_account_ids = *)","counters":[]},{"line":"    (*     List.partition_map account_ids ~f:(fun account_id -> *)","counters":[]},{"line":"    (*         match self_find_location t account_id with *)","counters":[]},{"line":"    (*         | Some location -> *)","counters":[]},{"line":"    (*             Either.first (account_id, Some location) *)","counters":[]},{"line":"    (*         | None -> *)","counters":[]},{"line":"    (*             Either.second account_id ) *)","counters":[]},{"line":"    (*   in *)","counters":[]},{"line":"    (*   found_locations *)","counters":[]},{"line":"    (*   @ Base.location_of_account_batch (get_parent t) leftover_account_ids *)","counters":[]},{"line":"","counters":[]},{"line":"    (* not needed for in-memory mask; in the database, it's currently a NOP *)","counters":[]},{"line":"    let make_space_for _t _tot = ()","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"    (* let make_space_for _t = () *)","counters":[]},{"line":"    (* assert_is_attached t ; *)","counters":[]},{"line":"    (* Base.make_space_for (get_parent t) *)","counters":[]},{"line":"","counters":[]},{"line":"    let get_inner_hash_at_addr_exn t address =","counters":[]},{"line":"      let hash =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Rust.mask_get_inner_hash_at_addr t (Addr.to_string address)","counters":[{"col_start":39,"col_end":39,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"        |> hash_from_rust","counters":[]},{"line":"      in","counters":[]},{"line":"      hash","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let set_inner_hash_at_addr_exn t address hash =","counters":[]},{"line":"      let buf = Bigstring.create (Hash.bin_size_t hash) in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"      ignore (Hash.bin_write_t buf ~pos:0 hash : int) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"      Rust.mask_set_inner_hash_at_addr t (Addr.to_string address)","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"        (Bigstring.to_bytes buf)","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"","counters":[]},{"line":"    (* let get_inner_hash_at_addr_exn t address = *)","counters":[]},{"line":"    (*   assert_is_attached t ; *)","counters":[]},{"line":"    (*   assert (Addr.depth address <= t.depth) ; *)","counters":[]},{"line":"    (*   get_hash t address |> Option.value_exn *)","counters":[]},{"line":"","counters":[]},{"line":"    let remove_accounts_exn t account_ids =","counters":[]},{"line":"      let account_ids = List.map account_ids ~f:account_id_to_rust in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Rust.mask_remove_accounts t account_ids","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    (* let remove_accounts_exn t keys = *)","counters":[]},{"line":"    (*   assert_is_attached t ; *)","counters":[]},{"line":"    (*   let rec loop keys parent_keys mask_locations = *)","counters":[]},{"line":"    (*     match keys with *)","counters":[]},{"line":"    (*     | [] -> *)","counters":[]},{"line":"    (*         (parent_keys, mask_locations) *)","counters":[]},{"line":"    (*     | key :: rest -> ( *)","counters":[]},{"line":"    (*         match self_find_location t key with *)","counters":[]},{"line":"    (*         | None -> *)","counters":[]},{"line":"    (*             loop rest (key :: parent_keys) mask_locations *)","counters":[]},{"line":"    (*         | Some loc -> *)","counters":[]},{"line":"    (*             loop rest parent_keys (loc :: mask_locations) ) *)","counters":[]},{"line":"    (*   in *)","counters":[]},{"line":"    (*   (\\* parent_keys not in mask, may be in parent mask_locations definitely in *)","counters":[]},{"line":"    (*      mask *\\) *)","counters":[]},{"line":"    (*   let parent_keys, mask_locations = loop keys [] [] in *)","counters":[]},{"line":"    (*   (\\* allow call to parent to raise an exception if raised, the parent *)","counters":[]},{"line":"    (*      hasn't removed any accounts, and we don't try to remove any accounts *)","counters":[]},{"line":"    (*      from mask *\\) *)","counters":[]},{"line":"    (*   Base.remove_accounts_exn (get_parent t) parent_keys ; *)","counters":[]},{"line":"    (*   (\\* removing accounts in parent succeeded, so proceed with removing *)","counters":[]},{"line":"    (*      accounts from mask we sort mask locations in reverse order, *)","counters":[]},{"line":"    (*      potentially allowing reuse of locations *\\) *)","counters":[]},{"line":"    (*   let rev_sorted_mask_locations = *)","counters":[]},{"line":"    (*     List.sort mask_locations ~compare:(fun loc1 loc2 -> *)","counters":[]},{"line":"    (*         let loc1 = Location.to_path_exn loc1 in *)","counters":[]},{"line":"    (*         let loc2 = Location.to_path_exn loc2 in *)","counters":[]},{"line":"    (*         Location.Addr.compare loc2 loc1 ) *)","counters":[]},{"line":"    (*   in *)","counters":[]},{"line":"    (*   List.iter rev_sorted_mask_locations *)","counters":[]},{"line":"    (*     ~f:(remove_account_and_update_hashes t) *)","counters":[]},{"line":"","counters":[]},{"line":"    (* Destroy intentionally does not commit before destroying","counters":[]},{"line":"       as sometimes this is desired behavior *)","counters":[]},{"line":"    let close t = Rust.mask_close t","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"","counters":[]},{"line":"    (* let close t = *)","counters":[]},{"line":"    (*   assert_is_attached t ; *)","counters":[]},{"line":"    (*   Location_binable.Table.clear t.account_tbl ; *)","counters":[]},{"line":"    (*   Addr.Table.clear t.hash_tbl ; *)","counters":[]},{"line":"    (*   Account_id.Table.clear t.location_tbl ; *)","counters":[]},{"line":"    (*   Async.Ivar.fill_if_empty t.detached_parent_signal () *)","counters":[]},{"line":"","counters":[]},{"line":"    let index_of_account_exn t account_id =","counters":[]},{"line":"      Rust.mask_index_of_account t (account_id_to_rust account_id)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"","counters":[]},{"line":"    (* let index_of_account_exn t key = *)","counters":[]},{"line":"    (*   assert_is_attached t ; *)","counters":[]},{"line":"    (*   let location = location_of_account t key |> Option.value_exn in *)","counters":[]},{"line":"    (*   let addr = Location.to_path_exn location in *)","counters":[]},{"line":"    (*   Addr.to_int addr *)","counters":[]},{"line":"","counters":[]},{"line":"    let get_at_index_exn t index =","counters":[]},{"line":"      Rust.mask_get_at_index t index |> account_from_rust","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"","counters":[]},{"line":"    (* let get_at_index_exn t index = *)","counters":[]},{"line":"    (*   assert_is_attached t ; *)","counters":[]},{"line":"    (*   let addr = Addr.of_int_exn ~ledger_depth:t.depth index in *)","counters":[]},{"line":"    (*   get t (Location.Account addr) |> Option.value_exn *)","counters":[]},{"line":"","counters":[]},{"line":"    let set_at_index_exn t index account =","counters":[]},{"line":"      Rust.mask_set_at_index t index (account_to_rust account)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"","counters":[]},{"line":"    (* let set_at_index_exn t index account = *)","counters":[]},{"line":"    (*   (\\* Printf.eprintf \"MY_LOG.MERKLE_MASK.MASKING.SET_AT_INDEX\\n%!\" ; *\\) *)","counters":[]},{"line":"    (*   assert_is_attached t ; *)","counters":[]},{"line":"    (*   let addr = Addr.of_int_exn ~ledger_depth:t.depth index in *)","counters":[]},{"line":"    (*   set t (Location.Account addr) account *)","counters":[]},{"line":"","counters":[]},{"line":"    let to_list t = Rust.mask_get_list t |> List.map ~f:account_from_rust","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"    (* let to_list t = *)","counters":[]},{"line":"    (*   assert_is_attached t ; *)","counters":[]},{"line":"    (*   accounts t |> Set.to_list *)","counters":[]},{"line":"    (*   |> List.map ~f:(fun key -> *)","counters":[]},{"line":"    (*          let location = location_of_account t key |> Option.value_exn in *)","counters":[]},{"line":"    (*          match location with *)","counters":[]},{"line":"    (*          | Account addr -> *)","counters":[]},{"line":"    (*              (Addr.to_int addr, get t location |> Option.value_exn) *)","counters":[]},{"line":"    (*          | location -> *)","counters":[]},{"line":"    (*              raise (Location_is_not_account location) ) *)","counters":[]},{"line":"    (*   |> List.sort ~compare:(fun (addr1, _) (addr2, _) -> *)","counters":[]},{"line":"    (*          Int.compare addr1 addr2 ) *)","counters":[]},{"line":"    (*   |> List.map ~f:(fun (_, account) -> account) *)","counters":[]},{"line":"","counters":[]},{"line":"    let iteri (t : t) ~(f : int -> Account.t -> unit) =","counters":[]},{"line":"      Rust.mask_iter t (fun index bytes -> f index (account_from_rust bytes))","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":43,"col_end":43,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"","counters":[]},{"line":"    (* let iteri t ~f = *)","counters":[]},{"line":"    (*   let account_ids = accounts t |> Account_id.Set.to_list in *)","counters":[]},{"line":"    (*   let idx_account_pairs_unsorted = *)","counters":[]},{"line":"    (*     List.map account_ids ~f:(fun acct_id -> *)","counters":[]},{"line":"    (*         let idx = *)","counters":[]},{"line":"    (*           try index_of_account_exn t acct_id *)","counters":[]},{"line":"    (*           with exn -> *)","counters":[]},{"line":"    (*             failwith *)","counters":[]},{"line":"    (*               (sprintf *)","counters":[]},{"line":"    (* !\"iter: index_of_account_exn failed, mask uuid: %{sexp: \\ *)","counters":[]},{"line":"       (*                    Uuid.t} account id: %{sexp: Account_id.t}, exception: \\ *)","counters":[]},{"line":"       (*                    %s\" *)","counters":[]},{"line":"    (*                  (get_uuid t) acct_id (Exn.to_string exn) ) *)","counters":[]},{"line":"    (*         in *)","counters":[]},{"line":"    (*         match location_of_account t acct_id with *)","counters":[]},{"line":"    (*         | None -> *)","counters":[]},{"line":"    (*             failwith *)","counters":[]},{"line":"    (*               (sprintf *)","counters":[]},{"line":"    (* !\"iter: location_of_account returned None, mask uuid: \\ *)","counters":[]},{"line":"       (*                    %{sexp: Uuid.t} account id: %{sexp: Account_id.t}\" *)","counters":[]},{"line":"    (*                  (get_uuid t) acct_id ) *)","counters":[]},{"line":"    (*         | Some loc -> ( *)","counters":[]},{"line":"    (*             match get t loc with *)","counters":[]},{"line":"    (*             | None -> *)","counters":[]},{"line":"    (*                 failwith *)","counters":[]},{"line":"    (*                   (sprintf *)","counters":[]},{"line":"    (* !\"iter: get returned None, mask uuid: %{sexp: Uuid.t} \\ *)","counters":[]},{"line":"       (*                        account id: %{sexp: Account_id.t}\" *)","counters":[]},{"line":"    (*                      (get_uuid t) acct_id ) *)","counters":[]},{"line":"    (*             | Some acct -> *)","counters":[]},{"line":"    (*                 (idx, acct) ) ) *)","counters":[]},{"line":"    (*   in *)","counters":[]},{"line":"    (*   (\\* in case iteration order matters *\\) *)","counters":[]},{"line":"    (*   let idx_account_pairs = *)","counters":[]},{"line":"    (*     List.sort idx_account_pairs_unsorted *)","counters":[]},{"line":"    (*       ~compare:(fun (idx1, _) (idx2, _) -> Int.compare idx1 idx2) *)","counters":[]},{"line":"    (*   in *)","counters":[]},{"line":"    (*   List.iter idx_account_pairs ~f:(fun (idx, acct) -> f idx acct) *)","counters":[]},{"line":"","counters":[]},{"line":"    let foldi_with_ignored_accounts t ignored_accounts ~init ~f =","counters":[]},{"line":"      let accum = ref init in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let ignored_accounts =","counters":[]},{"line":"        Account_id.Set.to_list ignored_accounts","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"        |> List.map ~f:account_id_to_rust","counters":[]},{"line":"      in","counters":[]},{"line":"      Rust.mask_foldi_with_ignored_accounts t ignored_accounts","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (fun addr account ->","counters":[]},{"line":"          accum := f (Addr.of_string addr) !accum (account_from_rust account) ) ;","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"      !accum","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    (* let foldi_with_ignored_accounts t ignored_accounts ~init ~f = *)","counters":[]},{"line":"    (*   assert_is_attached t ; *)","counters":[]},{"line":"    (*   let locations_and_accounts = *)","counters":[]},{"line":"    (*     Location_binable.Table.to_alist t.account_tbl *)","counters":[]},{"line":"    (*   in *)","counters":[]},{"line":"    (*   (\\* parent should ignore accounts in this mask *\\) *)","counters":[]},{"line":"    (*   let mask_accounts = *)","counters":[]},{"line":"    (*     List.map locations_and_accounts ~f:(fun (_loc, acct) -> *)","counters":[]},{"line":"    (*         Account.identifier acct ) *)","counters":[]},{"line":"    (*   in *)","counters":[]},{"line":"    (*   let mask_ignored_accounts = Account_id.Set.of_list mask_accounts in *)","counters":[]},{"line":"    (*   let all_ignored_accounts = *)","counters":[]},{"line":"    (*     Account_id.Set.union ignored_accounts mask_ignored_accounts *)","counters":[]},{"line":"    (*   in *)","counters":[]},{"line":"    (*   (\\* in parent, ignore any passed-in ignored accounts and accounts in mask *\\) *)","counters":[]},{"line":"    (*   let parent_result = *)","counters":[]},{"line":"    (*     Base.foldi_with_ignored_accounts (get_parent t) all_ignored_accounts *)","counters":[]},{"line":"    (*       ~init ~f *)","counters":[]},{"line":"    (*   in *)","counters":[]},{"line":"    (*   let f' accum (location, account) = *)","counters":[]},{"line":"    (*     (\\* for mask, ignore just passed-in ignored accounts *\\) *)","counters":[]},{"line":"    (*     if Account_id.Set.mem ignored_accounts (Account.identifier account) then *)","counters":[]},{"line":"    (*       accum *)","counters":[]},{"line":"    (*     else *)","counters":[]},{"line":"    (*       let address = Location.to_path_exn location in *)","counters":[]},{"line":"    (*       f address accum account *)","counters":[]},{"line":"    (*   in *)","counters":[]},{"line":"    (*   List.fold locations_and_accounts ~init:parent_result ~f:f' *)","counters":[]},{"line":"","counters":[]},{"line":"    let foldi t ~init ~f =","counters":[]},{"line":"      let accum = ref init in","counters":[{"col_start":6,"col_end":6,"count":12}]},{"line":"      Rust.mask_foldi t (fun addr account ->","counters":[]},{"line":"          accum := f (Addr.of_string addr) !accum (account_from_rust account) ) ;","counters":[{"col_start":10,"col_end":10,"count":216},{"col_start":19,"col_end":19,"count":216},{"col_start":35,"col_end":35,"count":216},{"col_start":67,"col_end":67,"count":216}]},{"line":"      !accum","counters":[{"col_start":6,"col_end":6,"count":12}]},{"line":"","counters":[]},{"line":"    (* let foldi t ~init ~f = *)","counters":[]},{"line":"    (*   assert_is_attached t ; *)","counters":[]},{"line":"    (*   foldi_with_ignored_accounts t Account_id.Set.empty ~init ~f *)","counters":[]},{"line":"","counters":[]},{"line":"    (* we would want fold_until to combine results from the parent and the mask","counters":[]},{"line":"       way (1): use the parent result as the init of the mask fold (or","counters":[]},{"line":"         vice-versa) the parent result may be of different type than the mask","counters":[]},{"line":"         fold init, so we get a less general type than the signature indicates,","counters":[]},{"line":"         so compilation fails","counters":[]},{"line":"       way (2): make the folds independent, but there's not a specified way to","counters":[]},{"line":"         combine the results","counters":[]},{"line":"       way (3): load parent accounts into an in-memory list, merge with mask","counters":[]},{"line":"         accounts, then fold; this becomes intractable if the parent has a large","counters":[]},{"line":"         number of entries *)","counters":[]},{"line":"    let fold_until _t ~init:_ ~f:_ ~finish:_ =","counters":[]},{"line":"      failwith \"fold_until: not implemented\"","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    module For_testing = struct","counters":[]},{"line":"      let location_in_mask _t _location =","counters":[]},{"line":"        failwith \"location_in_mask: not implemented\"","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      (* Option.is_some (self_find_account t location) *)","counters":[]},{"line":"","counters":[]},{"line":"      let address_in_mask _t _addr = failwith \"address_in_mask: not implemented\"","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"      (* Option.is_some (self_find_hash t addr) *)","counters":[]},{"line":"","counters":[]},{"line":"      let current_location _t = failwith \"current_location: not implemented\"","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"      (* t.current_location *)","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    (* leftmost location *)","counters":[]},{"line":"    (* let first_location ~ledger_depth = *)","counters":[]},{"line":"    (*   Location.Account *)","counters":[]},{"line":"    (*     ( Addr.of_directions *)","counters":[]},{"line":"    (*     @@ List.init ledger_depth ~f:(fun _ -> Direction.Left) ) *)","counters":[]},{"line":"","counters":[]},{"line":"    (* let loc_max a b = *)","counters":[]},{"line":"    (*   let a' = Location.to_path_exn a in *)","counters":[]},{"line":"    (*   let b' = Location.to_path_exn b in *)","counters":[]},{"line":"    (*   if Location.Addr.compare a' b' > 0 then a else b *)","counters":[]},{"line":"","counters":[]},{"line":"    (* NB: updates the mutable current_location field in t *)","counters":[]},{"line":"","counters":[]},{"line":"    let get_or_create_account t account_id account =","counters":[]},{"line":"      let account_id = account_id_to_rust account_id in","counters":[{"col_start":6,"col_end":6,"count":38}]},{"line":"      let account = account_to_rust account in","counters":[{"col_start":6,"col_end":6,"count":38}]},{"line":"      match Rust.mask_get_or_create_account t account_id account with","counters":[{"col_start":6,"col_end":6,"count":38}]},{"line":"      | Ok (location, addr) ->","counters":[{"col_start":8,"col_end":8,"count":38}]},{"line":"          Ok (location, Location.Account (Addr.of_string addr))","counters":[{"col_start":55,"col_end":55,"count":38}]},{"line":"      | Error _err ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Error (Error.of_string \"get_or_create_account\")","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"","counters":[]},{"line":"    (* let get_or_create_account t account_id account = *)","counters":[]},{"line":"    (*   (\\* Printf.eprintf \"MY_LOG.MERKLE_MASK.MASKING.GET_OR_CREATE_ACCOUNT\\n%!\" ; *\\) *)","counters":[]},{"line":"    (*   assert_is_attached t ; *)","counters":[]},{"line":"    (*   match self_find_location t account_id with *)","counters":[]},{"line":"    (*   | None -> ( *)","counters":[]},{"line":"    (*       (\\* not in mask, maybe in parent *\\) *)","counters":[]},{"line":"    (*       match Base.location_of_account (get_parent t) account_id with *)","counters":[]},{"line":"    (*       | Some location -> *)","counters":[]},{"line":"    (*           Ok (`Existed, location) *)","counters":[]},{"line":"    (*       | None -> ( *)","counters":[]},{"line":"    (*           (\\* not in parent, create new location *\\) *)","counters":[]},{"line":"    (*           let maybe_location = *)","counters":[]},{"line":"    (*             match last_filled t with *)","counters":[]},{"line":"    (*             | None -> *)","counters":[]},{"line":"    (*                 Some (first_location ~ledger_depth:t.depth) *)","counters":[]},{"line":"    (*             | Some loc -> *)","counters":[]},{"line":"    (*                 Location.next loc *)","counters":[]},{"line":"    (*           in *)","counters":[]},{"line":"    (*           match maybe_location with *)","counters":[]},{"line":"    (*           | None -> *)","counters":[]},{"line":"    (*               Or_error.error_string \"Db_error.Out_of_leaves\" *)","counters":[]},{"line":"    (*           | Some location -> *)","counters":[]},{"line":"    (*               set t location account ; *)","counters":[]},{"line":"    (*               self_set_location t account_id location ; *)","counters":[]},{"line":"    (*               t.current_location <- Some location ; *)","counters":[]},{"line":"    (*               Ok (`Added, location) ) ) *)","counters":[]},{"line":"    (*   | Some location -> *)","counters":[]},{"line":"    (*       Ok (`Existed, location) *)","counters":[]},{"line":"","counters":[]},{"line":"    (* let sexp_of_location = Location.sexp_of_t *)","counters":[]},{"line":"","counters":[]},{"line":"    (* let location_of_sexp = Location.t_of_sexp *)","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  (* val set_parent : unattached -> t -> Attached.t *)","counters":[]},{"line":"","counters":[]},{"line":"  (* val set_parent : unattached -> parent -> Attached.t *)","counters":[]},{"line":"","counters":[]},{"line":"  (* type parent *)","counters":[]},{"line":"","counters":[]},{"line":"  external mask_set_parent : unattached -> Base.t -> Attached.t","counters":[]},{"line":"    = \"rust_mask_set_parent\"","counters":[]},{"line":"","counters":[]},{"line":"  let set_parent t parent =","counters":[]},{"line":"    (* failwith \"ok\" *)","counters":[]},{"line":"    mask_set_parent t parent","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  (* assert (Result.is_error t.parent) ; *)","counters":[]},{"line":"  (* assert (Option.is_none (Async.Ivar.peek t.detached_parent_signal)) ; *)","counters":[]},{"line":"  (* assert (Int.equal t.depth (Base.depth parent)) ; *)","counters":[]},{"line":"  (* t.parent <- Ok parent ; *)","counters":[]},{"line":"  (* t.current_location <- Attached.last_filled t ; *)","counters":[]},{"line":"  (* t *)","counters":[]},{"line":"","counters":[]},{"line":"  (* let set_parent t parent = *)","counters":[]},{"line":"  (*   assert (Result.is_error t.parent) ; *)","counters":[]},{"line":"  (*   assert (Option.is_none (Async.Ivar.peek t.detached_parent_signal)) ; *)","counters":[]},{"line":"  (*   assert (Int.equal t.depth (Base.depth parent)) ; *)","counters":[]},{"line":"  (*   t.parent <- Ok parent ; *)","counters":[]},{"line":"  (*   t.current_location <- Attached.last_filled t ; *)","counters":[]},{"line":"  (*   t *)","counters":[]},{"line":"","counters":[]},{"line":"  let addr_to_location addr = Location.Account addr","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}