{"filename":"src/lib/snarky_field_extensions/field_extensions.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"module Make_test (F : Intf.Basic) = struct","counters":[]},{"line":"  let test arg_typ gen_arg sexp_of_arg label unchecked checked =","counters":[]},{"line":"    let open F.Impl in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let converted x =","counters":[]},{"line":"      let r =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        run_and_check","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"          (let open Checked.Let_syntax in","counters":[]},{"line":"          let%bind x = exists arg_typ ~compute:(As_prover.return x) in","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"          checked x >>| As_prover.read F.typ)","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"        |> Or_error.ok_exn","counters":[]},{"line":"      in","counters":[]},{"line":"      r","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    in","counters":[]},{"line":"    let open Quickcheck in","counters":[]},{"line":"    test ~trials:50 gen_arg ~f:(fun x ->","counters":[]},{"line":"        let r1 = unchecked x in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let r2 = converted x in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        if not (F.Unchecked.equal r1 r2) then","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"          failwithf","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            !\"%s test failure: %{sexp:arg} -> %{sexp:F.Unchecked.t} vs \\","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"              %{sexp:F.Unchecked.t}\"","counters":[]},{"line":"            label x r1 r2 ()","counters":[]},{"line":"        else () )","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"  let test1 l f g = test F.typ F.Unchecked.gen F.Unchecked.sexp_of_t l f g","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"","counters":[]},{"line":"  let test2 l f g =","counters":[]},{"line":"    let open F in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    test (Impl.Typ.( * ) typ typ)","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"      (Quickcheck.Generator.tuple2 Unchecked.gen Unchecked.gen)","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"      [%sexp_of: Unchecked.t * Unchecked.t] l (Tuple2.uncurry f)","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"      (Tuple2.uncurry g)","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make (F : Intf.Basic) = struct","counters":[]},{"line":"  open F.Impl","counters":[]},{"line":"  open Let_syntax","counters":[]},{"line":"  open F","counters":[]},{"line":"","counters":[]},{"line":"  let typ = F.typ","counters":[]},{"line":"","counters":[]},{"line":"  let constant = F.constant","counters":[]},{"line":"","counters":[]},{"line":"  let scale = F.scale","counters":[]},{"line":"","counters":[]},{"line":"  let assert_r1cs = F.assert_r1cs","counters":[]},{"line":"","counters":[]},{"line":"  let equal x y =","counters":[]},{"line":"    Checked.all","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":14,"col_end":14,"count":0}]},{"line":"      (List.map2_exn (F.to_list x) (F.to_list y) ~f:Field.Checked.equal)","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"    >>= Boolean.all","counters":[]},{"line":"","counters":[]},{"line":"  let assert_equal x y =","counters":[]},{"line":"    assert_all","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (List.map2_exn","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"         ~f:(fun x y -> Constraint.equal x y)","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"         (F.to_list x) (F.to_list y) )","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"","counters":[]},{"line":"  let ( + ) = F.( + )","counters":[]},{"line":"","counters":[]},{"line":"  let%test_unit \"add\" =","counters":[]},{"line":"    let module M = Make_test (F) in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    M.test2 \"add\" Unchecked.( + ) (fun x y -> return (x + y))","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"","counters":[]},{"line":"  let ( - ) = F.( - )","counters":[]},{"line":"","counters":[]},{"line":"  let negate = F.negate","counters":[]},{"line":"","counters":[]},{"line":"  let zero = constant Unchecked.zero","counters":[{"col_start":20,"col_end":20,"count":2}]},{"line":"","counters":[]},{"line":"  let one = constant Unchecked.one","counters":[{"col_start":19,"col_end":19,"count":2}]},{"line":"","counters":[]},{"line":"  let div_unsafe x y =","counters":[]},{"line":"    match (to_constant x, to_constant y) with","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"    | Some x, Some y ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        return (constant Unchecked.(x / y))","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"    | _, _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let%bind x_over_y =","counters":[]},{"line":"          exists typ","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"            ~compute:","counters":[]},{"line":"              As_prover.(map2 (read typ x) (read typ y) ~f:Unchecked.( / ))","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"        in","counters":[]},{"line":"        let%map () = assert_r1cs y x_over_y x in","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"        x_over_y","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"  let assert_square =","counters":[]},{"line":"    match assert_square with","counters":[]},{"line":"    | `Custom f ->","counters":[{"col_start":6,"col_end":6,"count":2}]},{"line":"        f","counters":[]},{"line":"    | `Define ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        fun a a2 -> assert_r1cs a a a2","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"","counters":[]},{"line":"  let ( * ) =","counters":[]},{"line":"    match ( * ) with","counters":[]},{"line":"    | `Custom f ->","counters":[{"col_start":6,"col_end":6,"count":2}]},{"line":"        f","counters":[]},{"line":"    | `Define -> (","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        fun x y ->","counters":[]},{"line":"          match (to_constant x, to_constant y) with","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"          | Some x, Some y ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              return (constant Unchecked.(x * y))","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"          | _, _ ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let%bind res =","counters":[]},{"line":"                exists typ","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                  ~compute:","counters":[]},{"line":"                    As_prover.(","counters":[]},{"line":"                      map2 (read typ x) (read typ y) ~f:Unchecked.( * ))","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"              in","counters":[]},{"line":"              let%map () = assert_r1cs x y res in","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"              res )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"","counters":[]},{"line":"  let%test_unit \"mul\" =","counters":[]},{"line":"    let module M = Make_test (F) in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    M.test2 \"mul\" Unchecked.( * ) ( * )","counters":[]},{"line":"","counters":[]},{"line":"  let square =","counters":[]},{"line":"    match square with","counters":[]},{"line":"    | `Custom f ->","counters":[{"col_start":6,"col_end":6,"count":2}]},{"line":"        f","counters":[]},{"line":"    | `Define -> (","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        fun x ->","counters":[]},{"line":"          match to_constant x with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | Some x ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              return (constant (Unchecked.square x))","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let%bind res =","counters":[]},{"line":"                exists typ","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                  ~compute:As_prover.(map (read typ x) ~f:Unchecked.square)","counters":[{"col_start":40,"col_end":40,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"              in","counters":[]},{"line":"              let%map () = assert_square x res in","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"              res )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"","counters":[]},{"line":"  let%test_unit \"square\" =","counters":[]},{"line":"    let module M = Make_test (F) in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    M.test1 \"square\" Unchecked.square square","counters":[]},{"line":"","counters":[]},{"line":"  let inv_exn =","counters":[]},{"line":"    match inv_exn with","counters":[]},{"line":"    | `Custom f ->","counters":[{"col_start":6,"col_end":6,"count":2}]},{"line":"        f","counters":[]},{"line":"    | `Define -> (","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        fun t ->","counters":[]},{"line":"          match to_constant t with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | Some x ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              return (constant (Unchecked.inv x))","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let%bind res =","counters":[]},{"line":"                exists typ","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                  ~compute:As_prover.(map (read typ t) ~f:Unchecked.inv)","counters":[{"col_start":40,"col_end":40,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"              in","counters":[]},{"line":"              let%map () = assert_r1cs t res one in","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"              res )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make_applicative","counters":[]},{"line":"    (F : Intf.S)","counters":[]},{"line":"    (A : Intf.Traversable_applicative with module Impl := F.Impl) =","counters":[]},{"line":"struct","counters":[]},{"line":"  type t = F.t A.t","counters":[]},{"line":"","counters":[]},{"line":"  type 'a t_ = 'a F.t_ A.t","counters":[]},{"line":"","counters":[]},{"line":"  let constant = A.map ~f:F.constant","counters":[]},{"line":"","counters":[]},{"line":"  let to_constant =","counters":[]},{"line":"    let exception None_exn in","counters":[]},{"line":"    fun t ->","counters":[]},{"line":"      try","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Some","counters":[]},{"line":"          (A.map t ~f:(fun x ->","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"               match F.to_constant x with Some x -> x | None -> raise None_exn )","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":42,"col_end":42,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"          )","counters":[]},{"line":"      with None_exn -> None","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"","counters":[]},{"line":"  let if_ b ~then_ ~else_ =","counters":[]},{"line":"    A.sequence (A.map2 then_ else_ ~f:(fun t e -> F.if_ b ~then_:t ~else_:e))","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"","counters":[]},{"line":"  let scale t x = A.map t ~f:(fun a -> F.scale a x)","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"  let scale' t x = A.map t ~f:(fun a -> F.scale x a)","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"  let negate t = A.map t ~f:F.negate","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"","counters":[]},{"line":"  let ( + ) = A.map2 ~f:F.( + )","counters":[]},{"line":"","counters":[]},{"line":"  let ( - ) = A.map2 ~f:F.( - )","counters":[]},{"line":"","counters":[]},{"line":"  let map_ t ~f = A.map t ~f:(F.map_ ~f)","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"","counters":[]},{"line":"  let map2_ t1 t2 ~f = A.map2 t1 t2 ~f:(fun x1 x2 -> F.map2_ x1 x2 ~f)","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module F (Impl : Snarky_backendless.Snark_intf.S) :","counters":[]},{"line":"  Intf.S with type 'a Base.t_ = 'a and type 'a A.t = 'a and module Impl = Impl =","counters":[]},{"line":"struct","counters":[]},{"line":"  module T = struct","counters":[]},{"line":"    module Unchecked = struct","counters":[]},{"line":"      include Impl.Field","counters":[]},{"line":"      module Nat = Snarkette.Nat","counters":[]},{"line":"","counters":[]},{"line":"      let order = Snarkette.Nat.of_string (Bigint.to_string Impl.Field.size)","counters":[{"col_start":40,"col_end":40,"count":2},{"col_start":58,"col_end":58,"count":2}]},{"line":"","counters":[]},{"line":"      let to_yojson x = `String (to_string x)","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"","counters":[]},{"line":"      let of_yojson = function","counters":[]},{"line":"        | `String s ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Ok (of_string s)","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"        | _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Error \"Field.of_yojson: expected string\"","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Impl = Impl","counters":[]},{"line":"    open Impl","counters":[]},{"line":"","counters":[]},{"line":"    let map_ t ~f = f t","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"","counters":[]},{"line":"    let map2_ t1 t2 ~f = f t1 t2","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"    module Base = struct","counters":[]},{"line":"      type 'a t_ = 'a","counters":[]},{"line":"","counters":[]},{"line":"      module Unchecked = struct","counters":[]},{"line":"        type t = Field.t t_","counters":[]},{"line":"","counters":[]},{"line":"        let to_yojson x = `String (Field.to_string x)","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"","counters":[]},{"line":"        let of_yojson = function","counters":[]},{"line":"          | `String s ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Ok (Field.of_string s)","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"          | _ ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Error \"Field.of_yojson: expected string\"","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      type t = Field.Var.t t_","counters":[]},{"line":"","counters":[]},{"line":"      let map_ = map_","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module A = struct","counters":[]},{"line":"      type 'a t = 'a","counters":[]},{"line":"","counters":[]},{"line":"      let map = map_","counters":[]},{"line":"","counters":[]},{"line":"      let map2 = map2_","counters":[]},{"line":"","counters":[]},{"line":"      let sequence = Fn.id","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    type 'a t_ = 'a","counters":[]},{"line":"","counters":[]},{"line":"    let to_list x = [ x ]","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"","counters":[]},{"line":"    type t = Field.Var.t","counters":[]},{"line":"","counters":[]},{"line":"    let if_ = Field.Checked.if_","counters":[]},{"line":"","counters":[]},{"line":"    let typ = Field.typ","counters":[]},{"line":"","counters":[]},{"line":"    let constant = Field.Var.constant","counters":[]},{"line":"","counters":[]},{"line":"    let to_constant = Field.Var.to_constant","counters":[]},{"line":"","counters":[]},{"line":"    let scale = Field.Var.scale","counters":[]},{"line":"","counters":[]},{"line":"    let mul_field = Field.Checked.mul","counters":[]},{"line":"","counters":[]},{"line":"    let assert_r1cs a b c = assert_r1cs a b c","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"","counters":[]},{"line":"    let ( + ) = Field.Checked.( + )","counters":[]},{"line":"","counters":[]},{"line":"    let ( - ) = Field.Checked.( - )","counters":[]},{"line":"","counters":[]},{"line":"    let negate t = Field.Var.scale t Unchecked.(negate one)","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"","counters":[]},{"line":"    let assert_square = `Custom (fun a c -> assert_square a c)","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"    let ( * ) = `Custom Field.Checked.mul","counters":[]},{"line":"","counters":[]},{"line":"    let square = `Custom Field.Checked.square","counters":[]},{"line":"","counters":[]},{"line":"    let inv_exn = `Custom Field.Checked.inv","counters":[]},{"line":"","counters":[]},{"line":"    let real_part = Fn.id","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  include T","counters":[]},{"line":"  include Make (T)","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(* Given a field F and s : F (called [non_residue] below)","counters":[]},{"line":"   such that x^2 - s does not have a root in F, construct","counters":[]},{"line":"   the field F(sqrt(s)) = F[x] / (x^2 - s) *)","counters":[]},{"line":"module E2","counters":[]},{"line":"    (F : Intf.S) (Params : sig","counters":[]},{"line":"      val non_residue : F.Unchecked.t","counters":[]},{"line":"","counters":[]},{"line":"      val mul_by_non_residue : F.t -> F.t","counters":[]},{"line":"    end) : sig","counters":[]},{"line":"  include","counters":[]},{"line":"    Intf.S_with_primitive_element","counters":[]},{"line":"      with module Impl = F.Impl","counters":[]},{"line":"       and module Base = F","counters":[]},{"line":"       and type 'a A.t = 'a * 'a","counters":[]},{"line":"","counters":[]},{"line":"  val unitary_inverse : t -> t","counters":[]},{"line":"end = struct","counters":[]},{"line":"  open Params","counters":[]},{"line":"","counters":[]},{"line":"  module T = struct","counters":[]},{"line":"    module Base = F","counters":[]},{"line":"    module Impl = F.Impl","counters":[]},{"line":"    open Impl","counters":[]},{"line":"    module Unchecked = Snarkette.Fields.Make_fp2 (F.Unchecked) (Params)","counters":[]},{"line":"","counters":[]},{"line":"    module A = struct","counters":[]},{"line":"      type 'a t = 'a * 'a","counters":[]},{"line":"","counters":[]},{"line":"      let map (x, y) ~f = (f x, f y)","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"","counters":[]},{"line":"      let map2 (x1, y1) (x2, y2) ~f = (f x1 x2, f y1 y2)","counters":[{"col_start":38,"col_end":38,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"","counters":[]},{"line":"      let sequence (x, y) =","counters":[]},{"line":"        let%map x = x and y = y in","counters":[]},{"line":"        (x, y)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    let to_list (x, y) = F.to_list x @ F.to_list y","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"","counters":[]},{"line":"    (* A value [(a, b) : t] should be thought of as the field element","counters":[]},{"line":"       a + b sqrt(s). Then all operations are just what follow algebraically. *)","counters":[]},{"line":"","counters":[]},{"line":"    include Make_applicative (Base) (A)","counters":[]},{"line":"","counters":[]},{"line":"    let mul_field (a, b) x =","counters":[]},{"line":"      let%map a = Base.mul_field a x and b = Base.mul_field b x in","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"      (a, b)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let typ = Typ.tuple2 F.typ F.typ","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"    (*","counters":[]},{"line":"       (a + b sqrt(s))^2","counters":[]},{"line":"       = a^2 + b^2 s + 2 a b sqrt(s)","counters":[]},{"line":"","counters":[]},{"line":"       So it is clear that the second coordinate of the below definition is correct. Let's","counters":[]},{"line":"       examine the first coordinate.","counters":[]},{"line":"","counters":[]},{"line":"       t - ab - ab sqrt(s)","counters":[]},{"line":"       = (a + b) (a + s b) - ab - s a b","counters":[]},{"line":"       = a^2 + a b + s a b + s b^2 - a b - s a b","counters":[]},{"line":"       = a^2 + s b^2","counters":[]},{"line":"","counters":[]},{"line":"       so this is correct as well.","counters":[]},{"line":"    *)","counters":[]},{"line":"    let square (a, b) =","counters":[]},{"line":"      let open F in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%map ab = a * b and t = (a + b) * (a + mul_by_non_residue b) in","counters":[{"col_start":65,"col_end":65,"count":0}]},{"line":"      (t - ab - mul_by_non_residue ab, ab + ab)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"","counters":[]},{"line":"    let assert_square (a, b) (a2, b2) =","counters":[]},{"line":"      let open F in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let ab = scale b2 Field.(one / of_int 2) in","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"      let%map () = assert_r1cs a b ab","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"      and () =","counters":[]},{"line":"        assert_r1cs (a + b)","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"          (a + mul_by_non_residue b)","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"          (a2 + ab + mul_by_non_residue ab)","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"      in","counters":[]},{"line":"      ()","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    (*","counters":[]},{"line":"       (a1 + b1 sqrt(s)) (a2 + b2 sqrt(s))","counters":[]},{"line":"       = (a1 a2 + b1 b2 s) + (a2 b1 + a1 b2) sqrt(s)","counters":[]},{"line":"","counters":[]},{"line":"       So it is clear that the first coordinate is correct. Let's examine the second","counters":[]},{"line":"       coordinate.","counters":[]},{"line":"","counters":[]},{"line":"       t - a1 a2 - b1 b2","counters":[]},{"line":"       = (a1 + b1) (a2 + b2) - a1 a2 - b1 b2","counters":[]},{"line":"       = a1 a2 + b2 b2 + a1 b2 + a2 b1 - a1 a2 - b1 b2","counters":[]},{"line":"       = a1 b2 + a2 b1","counters":[]},{"line":"","counters":[]},{"line":"       So this is correct as well.","counters":[]},{"line":"    *)","counters":[]},{"line":"    let ( * ) (a1, b1) (a2, b2) =","counters":[]},{"line":"      let open F in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%map a = a1 * a2 and b = b1 * b2 and t = (a1 + b1) * (a2 + b2) in","counters":[]},{"line":"      (a + mul_by_non_residue b, t - a - b)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"","counters":[]},{"line":"    let mul_by_primitive_element (a, b) = (mul_by_non_residue b, a)","counters":[{"col_start":42,"col_end":42,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"","counters":[]},{"line":"    let assert_r1cs (a1, b1) (a2, b2) (a3, b3) =","counters":[]},{"line":"      let open F in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%bind b = b1 * b2 in","counters":[]},{"line":"      let a = a3 - mul_by_non_residue b in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"      let%map () = assert_r1cs a1 a2 a","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"      and () = assert_r1cs (a1 + b1) (a2 + b2) (b3 + a + b) in","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"      ()","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let square = `Custom square","counters":[]},{"line":"","counters":[]},{"line":"    let ( * ) = `Custom ( * )","counters":[]},{"line":"","counters":[]},{"line":"    let inv_exn = `Define","counters":[]},{"line":"","counters":[]},{"line":"    let assert_square = `Custom assert_square","counters":[]},{"line":"","counters":[]},{"line":"    let real_part (x, _) = Base.real_part x","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  include T","counters":[]},{"line":"  include Make (T)","counters":[]},{"line":"","counters":[]},{"line":"  let unitary_inverse (a, b) = (a, Base.negate b)","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(* Given a prime order field F and s : F (called [non_residue] below)","counters":[]},{"line":"   such that x^3 - s is irreducible, construct","counters":[]},{"line":"   the field F(cube_root(s)) = F[x] / (x^3 - s).","counters":[]},{"line":"","counters":[]},{"line":"   Let S = cube_root(s) in the following.","counters":[]},{"line":"*)","counters":[]},{"line":"","counters":[]},{"line":"module T3 = struct","counters":[]},{"line":"  type 'a t = 'a * 'a * 'a","counters":[]},{"line":"","counters":[]},{"line":"  let map (x, y, z) ~f = (f x, f y, f z)","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"","counters":[]},{"line":"  let map2 (x1, y1, z1) (x2, y2, z2) ~f = (f x1 x2, f y1 y2, f z1 z2)","counters":[{"col_start":42,"col_end":42,"count":0},{"col_start":43,"col_end":43,"count":0},{"col_start":52,"col_end":52,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module E3","counters":[]},{"line":"    (F : Intf.S) (Params : sig","counters":[]},{"line":"      val non_residue : F.Unchecked.t","counters":[]},{"line":"","counters":[]},{"line":"      val frobenius_coeffs_c1 : F.Unchecked.t array","counters":[]},{"line":"","counters":[]},{"line":"      val frobenius_coeffs_c2 : F.Unchecked.t array","counters":[]},{"line":"","counters":[]},{"line":"      val mul_by_non_residue : F.t -> F.t","counters":[]},{"line":"    end) :","counters":[]},{"line":"  Intf.S_with_primitive_element","counters":[]},{"line":"    with module Impl = F.Impl","counters":[]},{"line":"     and module Base = F","counters":[]},{"line":"     and type 'a A.t = 'a * 'a * 'a = struct","counters":[]},{"line":"  module T = struct","counters":[]},{"line":"    module Base = F","counters":[]},{"line":"    module Unchecked = Snarkette.Fields.Make_fp3 (F.Unchecked) (Params)","counters":[]},{"line":"    module Impl = F.Impl","counters":[]},{"line":"    open Impl","counters":[]},{"line":"","counters":[]},{"line":"    module A = struct","counters":[]},{"line":"      include T3","counters":[]},{"line":"","counters":[]},{"line":"      let sequence (x, y, z) =","counters":[]},{"line":"        let%map x = x and y = y and z = z in","counters":[]},{"line":"        (x, y, z)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    let to_list (x, y, z) = F.to_list x @ F.to_list y @ F.to_list z","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":50,"col_end":50,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"","counters":[]},{"line":"    include Make_applicative (Base) (A)","counters":[]},{"line":"","counters":[]},{"line":"    let typ = Typ.tuple3 F.typ F.typ F.typ","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"    let mul_field (a, b, c) x =","counters":[]},{"line":"      let%map a = Base.mul_field a x","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"      and b = Base.mul_field b x","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"      and c = Base.mul_field c x in","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"      (a, b, c)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    (*","counters":[]},{"line":"       (a1 + S b1 + S^2 c1) (a2 + S b2 + S^2 c2)","counters":[]},{"line":"       = a1 a2 + S a1 b2 + S^2 a1 c2","counters":[]},{"line":"         + S b1 a2 + S^2 b1 b2 + S^3 b1 c2","counters":[]},{"line":"         + S^2 c1 a2 + S^3 c1 b2 + S^4 c1 c2","counters":[]},{"line":"       = a1 a2 + S a1 b2 + S^2 a1 c2","counters":[]},{"line":"         + S b1 a2 + S^2 b1 b2 + s b1 c2","counters":[]},{"line":"         + S^2 c1 a2 + s c1 b2 + s S c1 c2","counters":[]},{"line":"       = (a1 a2 + s b1 c2 + s c1 b2)","counters":[]},{"line":"       + S (a1 b2 + b1 a2 + s c1 c2)","counters":[]},{"line":"       + S^2 (a1 c2 + c1 a2 + b1 b2)","counters":[]},{"line":"","counters":[]},{"line":"       Let us examine the three coordinates in turn.","counters":[]},{"line":"","counters":[]},{"line":"       First coordinate:","counters":[]},{"line":"       a + s (t1 - b - c)","counters":[]},{"line":"       = a1 a2 + s ( (b1 + c1) (b2 + c2) - b - c)","counters":[]},{"line":"       = a1 a2 + s (b1 c2 + b2 c1)","counters":[]},{"line":"       which is evidently correct.","counters":[]},{"line":"","counters":[]},{"line":"       Second coordinate:","counters":[]},{"line":"       t2 - a - b + s c","counters":[]},{"line":"       (a1 + b1) (a2 + b2) - a - b + s c","counters":[]},{"line":"       a1 b2 + b1 a2 + s c","counters":[]},{"line":"       which is evidently correct.","counters":[]},{"line":"","counters":[]},{"line":"       Third coordinate:","counters":[]},{"line":"       t3 - a + b - c","counters":[]},{"line":"       = (a1 + c1) (a2 + c2) - a + b - c","counters":[]},{"line":"       = a1 c2 + c1 a2 + b","counters":[]},{"line":"       which is evidently correct.","counters":[]},{"line":"    *)","counters":[]},{"line":"    let ( * ) (a1, b1, c1) (a2, b2, c2) =","counters":[]},{"line":"      with_label __LOC__ (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          let open F in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let%map a = a1 * a2","counters":[]},{"line":"          and b = b1 * b2","counters":[]},{"line":"          and c = c1 * c2","counters":[]},{"line":"          and t1 = (b1 + c1) * (b2 + c2)","counters":[]},{"line":"          and t2 = (a1 + b1) * (a2 + b2)","counters":[]},{"line":"          and t3 = (a1 + c1) * (a2 + c2) in","counters":[]},{"line":"          ( a + Params.mul_by_non_residue (t1 - b - c)","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"          , t2 - a - b + Params.mul_by_non_residue c","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"          , t3 - a + b - c ) )","counters":[]},{"line":"","counters":[]},{"line":"    (*","counters":[]},{"line":"       (a + S b + S^2 c)^2","counters":[]},{"line":"       = a^2 + S a b + S^2 a c","counters":[]},{"line":"       + S a b + S^2 b^2 + S^3 b c","counters":[]},{"line":"       + S^2 a c + S^3 b c + S^4 c^2","counters":[]},{"line":"       = a^2 + S a b + S^2 a c","counters":[]},{"line":"       + S a b + S^2 b^2 + s b c","counters":[]},{"line":"       + S^2 a c + s b c + S s c^2","counters":[]},{"line":"       = (a^2 + 2 s b c)","counters":[]},{"line":"       + S (2 a b + s c^2)","counters":[]},{"line":"       + S^2 (b^2 + 2 a c)","counters":[]},{"line":"","counters":[]},{"line":"       Let us examine the three coordinates in turn.","counters":[]},{"line":"","counters":[]},{"line":"       First coordinate:","counters":[]},{"line":"       s0 + s s3","counters":[]},{"line":"       = a^2 + 2 s b c","counters":[]},{"line":"       which is evidently correct.","counters":[]},{"line":"","counters":[]},{"line":"       Second coordinate:","counters":[]},{"line":"       s1 + s s4","counters":[]},{"line":"       = 2 a b + s c^2","counters":[]},{"line":"       which is evidently correct.","counters":[]},{"line":"","counters":[]},{"line":"       Third coordinate:","counters":[]},{"line":"       s1 + s2 + s3 - s0 - s4","counters":[]},{"line":"       = 2 a b + (a - b + c)^2 + 2 b c - a^2 - c^2","counters":[]},{"line":"       = 2 a b + a^2 - 2 a b + 2 a c - 2 b c + b^2 + c^2 + 2 b c - a^2 - c^2","counters":[]},{"line":"       = 2 a c + b^2","counters":[]},{"line":"       which is evidently correct.","counters":[]},{"line":"    *)","counters":[]},{"line":"    let square (a, b, c) =","counters":[]},{"line":"      let open F in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%map s0 = square a","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"      and ab = a * b","counters":[]},{"line":"      and bc = b * c","counters":[]},{"line":"      and s2 = square (a - b + c)","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"      and s4 = square c in","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"      let s1 = ab + ab in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let s3 = bc + bc in","counters":[]},{"line":"      ( s0 + Params.mul_by_non_residue s3","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"      , s1 + Params.mul_by_non_residue s4","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"      , s1 + s2 + s3 - s0 - s4 )","counters":[]},{"line":"","counters":[]},{"line":"    let mul_by_primitive_element (a, b, c) = (Params.mul_by_non_residue c, a, b)","counters":[{"col_start":45,"col_end":45,"count":0},{"col_start":70,"col_end":70,"count":0}]},{"line":"","counters":[]},{"line":"    let assert_r1cs (a1, b1, c1) (a2, b2, c2) (a3, b3, c3) =","counters":[]},{"line":"      with_label __LOC__ (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          let open F in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let%bind b = b1 * b2 and c = c1 * c2 and t1 = (b1 + c1) * (b2 + c2) in","counters":[]},{"line":"          let a = a3 - Params.mul_by_non_residue (t1 - b - c) in","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"          let%map () = assert_r1cs a1 a2 a","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"          and () =","counters":[]},{"line":"            assert_r1cs (a1 + b1) (a2 + b2)","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"              (b3 + a + b - Params.mul_by_non_residue c)","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"          and () = assert_r1cs (a1 + c1) (a2 + c2) (c3 + a - b + c) in","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"          () )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"    let square = `Custom square","counters":[]},{"line":"","counters":[]},{"line":"    let ( * ) = `Custom ( * )","counters":[]},{"line":"","counters":[]},{"line":"    let inv_exn = `Define","counters":[]},{"line":"","counters":[]},{"line":"    let assert_square = `Define","counters":[]},{"line":"","counters":[]},{"line":"    let real_part (a, _, _) = F.real_part a","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  include T","counters":[]},{"line":"  include Make (T)","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module F3","counters":[]},{"line":"    (F : Intf.S with type 'a A.t = 'a and type 'a Base.t_ = 'a) (Params : sig","counters":[]},{"line":"      val non_residue : F.Unchecked.t","counters":[]},{"line":"","counters":[]},{"line":"      val frobenius_coeffs_c1 : F.Unchecked.t array","counters":[]},{"line":"","counters":[]},{"line":"      val frobenius_coeffs_c2 : F.Unchecked.t array","counters":[]},{"line":"    end) :","counters":[]},{"line":"  Intf.S_with_primitive_element","counters":[]},{"line":"    with module Impl = F.Impl","counters":[]},{"line":"     and module Base = F","counters":[]},{"line":"     and type 'a A.t = 'a * 'a * 'a = struct","counters":[]},{"line":"  module T = struct","counters":[]},{"line":"    module Base = F","counters":[]},{"line":"    module Unchecked = Snarkette.Fields.Make_fp3 (F.Unchecked) (Params)","counters":[]},{"line":"    module Impl = F.Impl","counters":[]},{"line":"    open Impl","counters":[]},{"line":"","counters":[]},{"line":"    let mul_by_primitive_element (a, b, c) = (F.scale c Params.non_residue, a, b)","counters":[{"col_start":45,"col_end":45,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"","counters":[]},{"line":"    module A = struct","counters":[]},{"line":"      include T3","counters":[]},{"line":"","counters":[]},{"line":"      let sequence (x, y, z) =","counters":[]},{"line":"        let%map x = x and y = y and z = z in","counters":[]},{"line":"        (x, y, z)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    let to_list (x, y, z) = [ x; y; z ]","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"","counters":[]},{"line":"    include Make_applicative (Base) (A)","counters":[]},{"line":"","counters":[]},{"line":"    let typ = Typ.tuple3 F.typ F.typ F.typ","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"    let mul_field (a, b, c) x =","counters":[]},{"line":"      let%map a = Base.mul_field a x","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"      and b = Base.mul_field b x","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"      and c = Base.mul_field c x in","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"      (a, b, c)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let assert_r1cs (a0, a1, a2) (b0, b1, b2) (c0, c1, c2) =","counters":[]},{"line":"      let open F in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%bind v0 = a0 * b0 and v4 = a2 * b2 in","counters":[]},{"line":"      let beta = Params.non_residue in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let beta_inv = F.Unchecked.inv beta in","counters":[]},{"line":"      let%map () =","counters":[]},{"line":"        assert_r1cs","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"          (a0 + a1 + a2)","counters":[]},{"line":"          (b0 + b1 + b2)","counters":[]},{"line":"          ( c1 + c2 + F.scale c0 beta_inv","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"          + F.(scale v0 Unchecked.(one - beta_inv))","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"          + F.(scale v4 Unchecked.(one - beta)) )","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"      and () =","counters":[]},{"line":"        assert_r1cs","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"          (a0 - a1 + a2)","counters":[]},{"line":"          (b0 - b1 + b2)","counters":[]},{"line":"          ( c2 - c1","counters":[]},{"line":"          + F.(scale v0 Unchecked.(one + beta_inv))","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"          - F.scale c0 beta_inv","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"          + F.(scale v4 Unchecked.(one + beta)) )","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"      and () =","counters":[]},{"line":"        let two = Impl.Field.of_int 2 in","counters":[]},{"line":"        let four = Impl.Field.of_int 4 in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let sixteen = Impl.Field.of_int 16 in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let eight_beta_inv = Impl.Field.(mul (of_int 8) beta_inv) in","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":43,"col_end":43,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"        assert_r1cs","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"          (a0 + F.scale a1 two + F.scale a2 four)","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"          (b0 + F.scale b1 two + F.scale b2 four)","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"          ( F.scale c1 two + F.scale c2 four + F.scale c0 eight_beta_inv","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"          + F.(scale v0 Unchecked.(one - eight_beta_inv))","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"          + F.(scale v4 Unchecked.(sixteen - (beta + beta))) )","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"      in","counters":[]},{"line":"      ()","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let ( * ) = `Define","counters":[]},{"line":"","counters":[]},{"line":"    let inv_exn = `Define","counters":[]},{"line":"","counters":[]},{"line":"    let square = `Define","counters":[]},{"line":"","counters":[]},{"line":"    let assert_square = `Define","counters":[]},{"line":"","counters":[]},{"line":"    let real_part (a, _, _) = F.real_part a","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  include T","counters":[]},{"line":"  include Make (T)","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Cyclotomic_square = struct","counters":[]},{"line":"  module Make_F4 (F2 : Intf.S_with_primitive_element) = struct","counters":[]},{"line":"    let cyclotomic_square (c0, c1) =","counters":[]},{"line":"      let open F2 in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let open Impl in","counters":[]},{"line":"      let%map b_squared = square (c0 + c1) and a = square c1 in","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"      let c = b_squared - a in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let d = mul_by_primitive_element a in","counters":[]},{"line":"      let e = c - d in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let f = scale d (Field.of_int 2) + one in","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"      let g = e - one in","counters":[]},{"line":"      (f, g)","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Make_F6","counters":[]},{"line":"      (F2 : Intf.S_with_primitive_element","counters":[]},{"line":"              with type 'a A.t = 'a * 'a","counters":[]},{"line":"               and type 'a Base.t_ = 'a)","counters":[]},{"line":"      (Params : sig","counters":[]},{"line":"        val cubic_non_residue : F2.Impl.Field.t","counters":[]},{"line":"      end) =","counters":[]},{"line":"  struct","counters":[]},{"line":"    let cyclotomic_square ((x00, x01, x02), (x10, x11, x12)) =","counters":[]},{"line":"      let open F2.Impl in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let ((a0, a1) as a) = (x00, x11) in","counters":[]},{"line":"      let ((b0, b1) as b) = (x10, x02) in","counters":[]},{"line":"      let ((c0, c1) as c) = (x01, x12) in","counters":[]},{"line":"      let%map asq0, asq1 = F2.square a","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"      and bsq0, bsq1 = F2.square b","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"      and csq0, csq1 = F2.square c in","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"      let fpos x y =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Field.(Var.(add (scale x (of_int 3)) (scale y (of_int 2))))","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":50,"col_end":50,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"      in","counters":[]},{"line":"      let fneg x y =","counters":[]},{"line":"        Field.(Var.(sub (scale x (of_int 3)) (scale y (of_int 2))))","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":50,"col_end":50,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"      in","counters":[]},{"line":"      ( (fneg asq0 a0, fneg bsq0 c0, fneg csq0 b1)","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"      , ( fpos (Field.Var.scale csq1 Params.cubic_non_residue) b0","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"        , fpos asq1 a1","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"        , fpos bsq1 c1 ) )","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module F6","counters":[]},{"line":"    (Fq : Intf.S with type 'a A.t = 'a and type 'a Base.t_ = 'a)","counters":[]},{"line":"    (Fq2 : Intf.S_with_primitive_element","counters":[]},{"line":"             with module Impl = Fq.Impl","counters":[]},{"line":"              and type 'a A.t = 'a * 'a","counters":[]},{"line":"              and type 'a Base.t_ = 'a Fq.t_)","counters":[]},{"line":"    (Fq3 : sig","counters":[]},{"line":"      include","counters":[]},{"line":"        Intf.S_with_primitive_element","counters":[]},{"line":"          with module Impl = Fq.Impl","counters":[]},{"line":"           and type 'a A.t = 'a * 'a * 'a","counters":[]},{"line":"           and type 'a Base.t_ = 'a Fq.t_","counters":[]},{"line":"","counters":[]},{"line":"      module Params : sig","counters":[]},{"line":"        val non_residue : Fq.Unchecked.t","counters":[]},{"line":"","counters":[]},{"line":"        val frobenius_coeffs_c1 : Fq.Unchecked.t array","counters":[]},{"line":"","counters":[]},{"line":"        val frobenius_coeffs_c2 : Fq.Unchecked.t array","counters":[]},{"line":"      end","counters":[]},{"line":"    end) (Params : sig","counters":[]},{"line":"      val frobenius_coeffs_c1 : Fq.Unchecked.t array","counters":[]},{"line":"    end) =","counters":[]},{"line":"struct","counters":[]},{"line":"  include","counters":[]},{"line":"    E2","counters":[]},{"line":"      (Fq3)","counters":[]},{"line":"      (struct","counters":[]},{"line":"        let non_residue : Fq3.Unchecked.t = Fq.Unchecked.(zero, one, zero)","counters":[]},{"line":"","counters":[]},{"line":"        let mul_by_non_residue = Fq3.mul_by_primitive_element","counters":[]},{"line":"      end)","counters":[]},{"line":"","counters":[]},{"line":"  let fq_mul_by_non_residue x = Fq.scale x Fq3.Params.non_residue","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"","counters":[]},{"line":"  let special_mul (a0, a1) (b0, b1) =","counters":[]},{"line":"    let open Impl in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let%bind v1 = Fq3.(a1 * b1) in","counters":[]},{"line":"    let%bind v0 =","counters":[]},{"line":"      let a00, a01, a02 = a0 in","counters":[]},{"line":"      let _, _, b02 = b0 in","counters":[]},{"line":"      let%map a00b02 = Fq.(a00 * b02)","counters":[]},{"line":"      and a01b02 = Fq.(a01 * b02)","counters":[]},{"line":"      and a02b02 = Fq.(a02 * b02) in","counters":[]},{"line":"      (fq_mul_by_non_residue a01b02, fq_mul_by_non_residue a02b02, a00b02)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"    in","counters":[]},{"line":"    let beta_v1 = Fq3.mul_by_primitive_element v1 in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let%map t = Fq3.((a0 + a1) * (b0 + b1)) in","counters":[]},{"line":"    Fq3.(v0 + beta_v1, t - v0 - v1)","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let assert_special_mul ((((a00, a01, a02) as a0), a1) : t)","counters":[]},{"line":"      ((((_, _, b02) as b0), b1) : t) ((c00, c01, c02), c1) =","counters":[]},{"line":"    let open Impl in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let%bind ((v10, v11, v12) as v1) = Fq3.(a1 * b1) in","counters":[]},{"line":"    let%bind v0 =","counters":[]},{"line":"      exists Fq3.typ","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"        ~compute:","counters":[]},{"line":"          As_prover.(","counters":[]},{"line":"            map2 ~f:Fq3.Unchecked.( * ) (read Fq3.typ a0) (read Fq3.typ b0))","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"      (* v0","counters":[]},{"line":"           = (a00 + s a01 s^2 a02) (s^2 b02)","counters":[]},{"line":"         = non_residue a01 b02 + non_residue s a02 b02 + s^2 a00 b02 *)","counters":[]},{"line":"    in","counters":[]},{"line":"    let%map () =","counters":[]},{"line":"      let%map () =","counters":[]},{"line":"        Fq.assert_r1cs a01","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"          (Fq.scale b02 Fq3.Params.non_residue)","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"          (Field.Var.linear_combination","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"             [ (Field.one, c00); (Field.negate Fq3.Params.non_residue, v12) ] )","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"      and () =","counters":[]},{"line":"        Fq.assert_r1cs a02 (Fq.scale b02 Fq3.Params.non_residue) Fq.(c01 - v10)","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"      and () = Fq.assert_r1cs a00 b02 Fq.(c02 - v11) in","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"      ()","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    and () = Fq3.assert_r1cs Fq3.(a0 + a1) Fq3.(b0 + b1) Fq3.(c1 + v0 + v1) in","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"    ()","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let special_div_unsafe a b =","counters":[]},{"line":"    let open Impl in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let%bind result =","counters":[]},{"line":"      exists typ","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"        ~compute:As_prover.(map2 ~f:Unchecked.( / ) (read typ a) (read typ b))","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":56,"col_end":56,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"    in","counters":[]},{"line":"    (* result * b = a *)","counters":[]},{"line":"    let%map () = assert_special_mul result b a in","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"    result","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  (* TODO: Make sure this is ok *)","counters":[]},{"line":"  let special_div = special_div_unsafe","counters":[]},{"line":"","counters":[]},{"line":"  include","counters":[]},{"line":"    Cyclotomic_square.Make_F6","counters":[]},{"line":"      (Fq2)","counters":[]},{"line":"      (struct","counters":[]},{"line":"        let cubic_non_residue = Fq3.Params.non_residue","counters":[]},{"line":"      end)","counters":[]},{"line":"","counters":[]},{"line":"  let frobenius ((c00, c01, c02), (c10, c11, c12)) power =","counters":[]},{"line":"    let module Field = Impl.Field in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let p3 = power mod 3 in","counters":[]},{"line":"    let p6 = power mod 6 in","counters":[]},{"line":"    let ( * ) s x = Field.Var.scale x s in","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"    ( ( c00","counters":[]},{"line":"      , Fq3.Params.frobenius_coeffs_c1.(p3) * c01","counters":[]},{"line":"      , Fq3.Params.frobenius_coeffs_c2.(p3) * c02 )","counters":[]},{"line":"    , ( Params.frobenius_coeffs_c1.(p6) * c10","counters":[]},{"line":"      , Field.mul","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"          Params.frobenius_coeffs_c1.(p6)","counters":[]},{"line":"          Fq3.Params.frobenius_coeffs_c1.(p3)","counters":[]},{"line":"        * c11","counters":[]},{"line":"      , Field.mul","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"          Params.frobenius_coeffs_c1.(p6)","counters":[]},{"line":"          Fq3.Params.frobenius_coeffs_c2.(p3)","counters":[]},{"line":"        * c12 ) )","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module F4","counters":[]},{"line":"    (Fq2 : Intf.S_with_primitive_element","counters":[]},{"line":"             with type 'a A.t = 'a * 'a","counters":[]},{"line":"              and type 'a Base.t_ = 'a)","counters":[]},{"line":"    (Params : sig","counters":[]},{"line":"      val frobenius_coeffs_c1 : Fq2.Impl.Field.t array","counters":[]},{"line":"    end) =","counters":[]},{"line":"struct","counters":[]},{"line":"  include","counters":[]},{"line":"    E2","counters":[]},{"line":"      (Fq2)","counters":[]},{"line":"      (struct","counters":[]},{"line":"        let non_residue = Fq2.Impl.Field.(zero, one)","counters":[]},{"line":"","counters":[]},{"line":"        let mul_by_non_residue = Fq2.mul_by_primitive_element","counters":[]},{"line":"      end)","counters":[]},{"line":"","counters":[]},{"line":"  let special_mul = ( * )","counters":[]},{"line":"","counters":[]},{"line":"  (* TODO: Make sure this is ok *)","counters":[]},{"line":"  let special_div = div_unsafe","counters":[]},{"line":"","counters":[]},{"line":"  include Cyclotomic_square.Make_F4 (Fq2)","counters":[]},{"line":"","counters":[]},{"line":"  let frobenius ((c00, c01), (c10, c11)) power =","counters":[]},{"line":"    let module Field = Impl.Field in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let p2 = Params.frobenius_coeffs_c1.(Int.( * ) (power mod 2) 2) in","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"    let p4 = Params.frobenius_coeffs_c1.(power mod 4) in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let ( * ) s x = Field.Var.scale x s in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":20,"col_end":20,"count":0}]},{"line":"    ((c00, p2 * c01), (p4 * c10, Field.(p4 * p2) * c11))","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}