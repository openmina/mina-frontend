{"filename":"src/mask/mask.rs","lines":[{"line":"use std::{","counters":[]},{"line":"    collections::{HashMap, HashSet},","counters":[]},{"line":"    path::PathBuf,","counters":[]},{"line":"    sync::{Arc, Mutex},","counters":[]},{"line":"};","counters":[]},{"line":"","counters":[]},{"line":"use mina_hasher::Fp;","counters":[]},{"line":"use mina_signer::CompressedPubKey;","counters":[]},{"line":"","counters":[]},{"line":"use crate::{","counters":[]},{"line":"    account::{Account, AccountId, TokenId},","counters":[]},{"line":"    address::Address,","counters":[]},{"line":"    base::{next_uuid, AccountIndex, BaseLedger, GetOrCreated, MerklePath, Uuid},","counters":[]},{"line":"    database::{Database, DatabaseError},","counters":[]},{"line":"    tree_version::V2,","counters":[]},{"line":"    HashesMatrix,","counters":[]},{"line":"};","counters":[]},{"line":"","counters":[]},{"line":"use super::mask_impl::{MaskImpl, MaskImplShort};","counters":[]},{"line":"","counters":[]},{"line":"#[derive(Clone, Debug)]","counters":[{"col_start":9,"col_end":14,"count":0},{"col_start":16,"col_end":21,"count":0}]},{"line":"pub struct Mask {","counters":[]},{"line":"    // Using a mutex for now but this can be replaced with a RefCell","counters":[]},{"line":"    pub inner: Arc<Mutex<MaskImpl>>,","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Drop for Mask {","counters":[]},{"line":"    fn drop(&mut self) {","counters":[{"col_start":4,"col_end":24,"count":0}]},{"line":"        if Arc::strong_count(&self.inner) > 2 {","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"            // Don't drop because of counter","counters":[]},{"line":"            return;","counters":[{"col_start":12,"col_end":18,"count":0}]},{"line":"        }","counters":[{"col_start":9,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"        let Ok(inner) = self.inner.try_lock() else {","counters":[{"col_start":15,"col_end":20,"count":0},{"col_start":24,"col_end":45,"count":0}]},{"line":"            // The Mask is used somewhere else","counters":[]},{"line":"            return","counters":[{"col_start":12,"col_end":18,"count":0}]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        if inner.any_child_alive() {","counters":[{"col_start":11,"col_end":34,"count":0}]},{"line":"            // Still got childs, don't do anything","counters":[]},{"line":"            return;","counters":[{"col_start":12,"col_end":18,"count":0}]},{"line":"        }","counters":[{"col_start":9,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"        let Some(parent) = inner.get_parent() else {","counters":[{"col_start":17,"col_end":23,"count":0},{"col_start":27,"col_end":45,"count":0}]},{"line":"             // No parent, we don't need to do anything","counters":[]},{"line":"            return","counters":[{"col_start":12,"col_end":18,"count":236}]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        // We reached a point where we don't have childs, and it remains at most 2","counters":[]},{"line":"        // pointers of our mask:","counters":[]},{"line":"        // - 1 pointer from the parent (having us in its `MaskImpl::childs` )","counters":[]},{"line":"        // - 1 currently dropping pointer","counters":[]},{"line":"        //","counters":[]},{"line":"        // Unregister our mask from the parent (remove us from its `MaskImpl::childs`)","counters":[]},{"line":"        // It will recursively drop/deallocate any parent with the same conditions","counters":[]},{"line":"","counters":[]},{"line":"        // Note:","counters":[]},{"line":"        // There is a case where the parent does not have any pointer of us:","counters":[]},{"line":"        // During transaction application, we don't call `register_mask`","counters":[]},{"line":"        // In that case, the `remove_child_uuid` below has no effect","counters":[]},{"line":"        // https://github.com/MinaProtocol/mina/blob/f6756507ff7380a691516ce02a3cf7d9d32915ae/src/lib/mina_ledger/ledger.ml#L204","counters":[]},{"line":"","counters":[]},{"line":"        parent.remove_child_uuid(inner.get_uuid());","counters":[{"col_start":8,"col_end":50,"count":0}]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":236}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"#[derive(Debug)]","counters":[{"col_start":9,"col_end":10,"count":0},{"col_start":13,"col_end":14,"count":0}]},{"line":"pub enum UnregisterBehavior {","counters":[]},{"line":"    Check,","counters":[]},{"line":"    Recursive,","counters":[]},{"line":"    IPromiseIAmReparentingThisMask,","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Mask {","counters":[]},{"line":"    pub(super) fn with<F, R>(&self, fun: F) -> R","counters":[{"col_start":4,"col_end":48,"count":17688}]},{"line":"    where","counters":[{"col_start":0,"col_end":9,"count":17688}]},{"line":"        F: FnOnce(&mut MaskImpl) -> R,","counters":[{"col_start":0,"col_end":38,"count":17688}]},{"line":"    {","counters":[{"col_start":0,"col_end":5,"count":17688}]},{"line":"        let mut inner = self.inner.try_lock().expect(\"lock failed\");","counters":[{"col_start":0,"col_end":68,"count":17688}]},{"line":"        fun(&mut inner)","counters":[{"col_start":0,"col_end":23,"count":17688}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":17688}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl Mask {","counters":[]},{"line":"    pub fn new_root(db: Database<V2>) -> Self {","counters":[{"col_start":4,"col_end":47,"count":3}]},{"line":"        let uuid = db.get_uuid();","counters":[{"col_start":0,"col_end":33,"count":3}]},{"line":"        let mask = Self {","counters":[{"col_start":0,"col_end":25,"count":3}]},{"line":"            inner: Arc::new(Mutex::new(MaskImpl::Root {","counters":[{"col_start":0,"col_end":55,"count":3}]},{"line":"                database: db,","counters":[{"col_start":0,"col_end":29,"count":3}]},{"line":"                childs: HashMap::with_capacity(2),","counters":[{"col_start":0,"col_end":50,"count":3}]},{"line":"            })),","counters":[{"col_start":0,"col_end":16,"count":3}]},{"line":"        };","counters":[{"col_start":0,"col_end":10,"count":3}]},{"line":"        super::tests::add_mask(&uuid);","counters":[{"col_start":0,"col_end":38,"count":3}]},{"line":"        mask","counters":[{"col_start":0,"col_end":12,"count":3}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":3}]},{"line":"","counters":[]},{"line":"    pub fn new_unattached(depth: usize) -> Self {","counters":[{"col_start":4,"col_end":49,"count":0}]},{"line":"        let uuid = next_uuid();","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"","counters":[]},{"line":"        let mask = Self {","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"            inner: Arc::new(Mutex::new(MaskImpl::Unattached {","counters":[{"col_start":0,"col_end":61,"count":0}]},{"line":"                owning_account: Default::default(),","counters":[{"col_start":0,"col_end":51,"count":0}]},{"line":"                token_to_account: Default::default(),","counters":[{"col_start":0,"col_end":53,"count":0}]},{"line":"                id_to_addr: Default::default(),","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"                last_location: None,","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"                depth: depth as u8,","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"                childs: HashMap::with_capacity(2),","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"                uuid: uuid.clone(),","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"                hashes: HashesMatrix::new(depth),","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"            })),","counters":[{"col_start":0,"col_end":16,"count":0}]},{"line":"        };","counters":[{"col_start":0,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"        super::tests::add_mask(&uuid);","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"","counters":[]},{"line":"        mask","counters":[{"col_start":0,"col_end":12,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn create(depth: usize) -> Self {","counters":[{"col_start":4,"col_end":41,"count":0}]},{"line":"        Self::new_root(Database::create(depth as u8))","counters":[{"col_start":0,"col_end":53,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn make_child(&self) -> Mask {","counters":[{"col_start":4,"col_end":38,"count":0}]},{"line":"        let new_mask = Mask::new_unattached(self.depth() as usize);","counters":[{"col_start":0,"col_end":67,"count":0}]},{"line":"        self.register_mask(new_mask)","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn set_parent(&self, parent: Mask, parent_last_filled: Option<Option<Address>>) -> Mask {","counters":[{"col_start":4,"col_end":97,"count":3}]},{"line":"        let this = self.clone();","counters":[{"col_start":0,"col_end":32,"count":3}]},{"line":"        self.with(|this| this.set_parent(parent, parent_last_filled));","counters":[{"col_start":0,"col_end":18,"count":3},{"col_start":25,"col_end":68,"count":0},{"col_start":68,"col_end":70,"count":3}]},{"line":"        this","counters":[{"col_start":0,"col_end":12,"count":3}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":3}]},{"line":"","counters":[]},{"line":"    pub fn copy(&self) -> Mask {","counters":[{"col_start":4,"col_end":32,"count":0}]},{"line":"        let mask = self.with(|this| this.clone());","counters":[{"col_start":0,"col_end":29,"count":0},{"col_start":36,"col_end":48,"count":0},{"col_start":48,"col_end":50,"count":0}]},{"line":"        Self {","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"            inner: Arc::new(Mutex::new(mask)),","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    /// Make `mask` a child of `self`","counters":[]},{"line":"    pub fn register_mask(&self, mask: Mask) -> Mask {","counters":[{"col_start":4,"col_end":53,"count":0}]},{"line":"        // elog!(\"self={:p} mask={:p}\", &self.inner, &mask.inner);","counters":[{"col_start":0,"col_end":66,"count":0}]},{"line":"","counters":[]},{"line":"        let self_mask = self.clone();","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"        self.with(|this| this.register_mask(self_mask, mask))","counters":[{"col_start":0,"col_end":18,"count":0},{"col_start":25,"col_end":60,"count":0},{"col_start":60,"col_end":61,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    /// Detach this mask from its parent","counters":[]},{"line":"    pub fn unregister_mask(&self, behavior: UnregisterBehavior) -> Mask {","counters":[{"col_start":4,"col_end":73,"count":0}]},{"line":"        self.unregister_mask_impl(behavior, true)","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub(super) fn unregister_mask_impl(","counters":[{"col_start":4,"col_end":39,"count":0}]},{"line":"        &self,","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"        behavior: UnregisterBehavior,","counters":[{"col_start":0,"col_end":37,"count":0}]},{"line":"        remove_from_parent: bool,","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"    ) -> Mask {","counters":[{"col_start":0,"col_end":15,"count":0}]},{"line":"        let this = self.clone();","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"        self.with(|this| this.unregister_mask(behavior, remove_from_parent));","counters":[{"col_start":0,"col_end":18,"count":0},{"col_start":25,"col_end":75,"count":0},{"col_start":75,"col_end":77,"count":0}]},{"line":"        this","counters":[{"col_start":0,"col_end":12,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub(super) fn remove_child_uuid(&self, uuid: Uuid) -> Option<Mask> {","counters":[{"col_start":4,"col_end":72,"count":0}]},{"line":"        self.with(|this| this.remove_child_uuid(uuid))","counters":[{"col_start":0,"col_end":18,"count":0},{"col_start":25,"col_end":53,"count":0},{"col_start":53,"col_end":54,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn is_attached(&self) -> bool {","counters":[{"col_start":4,"col_end":39,"count":0}]},{"line":"        self.with(|this| this.is_attached())","counters":[{"col_start":0,"col_end":18,"count":0},{"col_start":25,"col_end":43,"count":0},{"col_start":43,"col_end":44,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn uuid(&self) -> Uuid {","counters":[]},{"line":"        self.with(|this| this.get_uuid())","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    pub fn get_parent(&self) -> Option<Mask> {","counters":[{"col_start":4,"col_end":46,"count":0}]},{"line":"        self.with(|this| this.get_parent())","counters":[{"col_start":0,"col_end":18,"count":0},{"col_start":25,"col_end":42,"count":0},{"col_start":42,"col_end":43,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn unset_parent(&self, trigger_detach_signal: bool) {","counters":[{"col_start":4,"col_end":61,"count":0}]},{"line":"        self.with(|this| this.unset_parent(trigger_detach_signal))","counters":[{"col_start":0,"col_end":18,"count":0},{"col_start":25,"col_end":65,"count":0},{"col_start":65,"col_end":66,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    /// //             o","counters":[]},{"line":"    /// //            /","counters":[]},{"line":"    /// //           /","counters":[]},{"line":"    /// //  o --- o -","counters":[]},{"line":"    /// //  ^     ^  \\","counters":[]},{"line":"    /// // parent |   \\","counters":[]},{"line":"    /// //       mask  o","counters":[]},{"line":"    /// //           children","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// Removes the attached mask from its parent and attaches the children to the","counters":[]},{"line":"    /// parent instead. Raises an exception if the merkle roots of the mask and the","counters":[]},{"line":"    /// parent are not the same.","counters":[]},{"line":"    pub fn remove_and_reparent(&self) {","counters":[{"col_start":4,"col_end":39,"count":0}]},{"line":"        self.with(|this| this.remove_and_reparent())","counters":[{"col_start":0,"col_end":18,"count":0},{"col_start":25,"col_end":51,"count":0},{"col_start":51,"col_end":52,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    /// get hash from mask, if present, else from its parent","counters":[]},{"line":"    pub fn get_hash(&self, addr: Address) -> Option<Fp> {","counters":[{"col_start":4,"col_end":57,"count":0}]},{"line":"        self.with(|this| this.get_hash(addr))","counters":[{"col_start":0,"col_end":18,"count":0},{"col_start":25,"col_end":44,"count":0},{"col_start":44,"col_end":45,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    /// commit all state to the parent, flush state locally","counters":[]},{"line":"    pub fn commit(&self) {","counters":[{"col_start":4,"col_end":26,"count":0}]},{"line":"        self.with(|this| this.commit())","counters":[{"col_start":0,"col_end":18,"count":0},{"col_start":25,"col_end":38,"count":0},{"col_start":38,"col_end":39,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    /// called when parent sets an account; update local state","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// if the mask's parent sets an account, we can prune an entry in the mask","counters":[]},{"line":"    /// if the account in the parent is the same in the mask *)","counters":[]},{"line":"    pub fn parent_set_notify(&self, account_index: AccountIndex, account: &Account) {","counters":[{"col_start":4,"col_end":85,"count":0}]},{"line":"        self.with(|this| this.parent_set_notify(account_index, account))","counters":[{"col_start":0,"col_end":18,"count":0},{"col_start":25,"col_end":71,"count":0},{"col_start":71,"col_end":72,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn remove_parent(&self) -> Option<Mask> {","counters":[{"col_start":4,"col_end":49,"count":0}]},{"line":"        self.with(|this| this.remove_parent())","counters":[{"col_start":0,"col_end":18,"count":0},{"col_start":25,"col_end":45,"count":0},{"col_start":45,"col_end":46,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn depth(&self) -> u8 {","counters":[{"col_start":4,"col_end":31,"count":10}]},{"line":"        self.with(|this| this.depth())","counters":[{"col_start":0,"col_end":18,"count":10},{"col_start":25,"col_end":37,"count":90},{"col_start":37,"col_end":38,"count":10}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":10}]},{"line":"","counters":[]},{"line":"    pub(super) fn set_impl(&mut self, addr: Address, account: Account, ignore: Option<Uuid>) {","counters":[{"col_start":4,"col_end":94,"count":0}]},{"line":"        self.with(|this| this.set_impl(addr, account, ignore))","counters":[{"col_start":0,"col_end":18,"count":0},{"col_start":25,"col_end":61,"count":0},{"col_start":61,"col_end":62,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub(super) fn remove_accounts_without_notif(&mut self, ids: &[AccountId]) {","counters":[{"col_start":4,"col_end":79,"count":0}]},{"line":"        self.with(|this| this.remove_accounts_without_notif(ids))","counters":[{"col_start":0,"col_end":18,"count":0},{"col_start":25,"col_end":64,"count":0},{"col_start":64,"col_end":65,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    pub fn short(&self) -> MaskImplShort {","counters":[{"col_start":4,"col_end":42,"count":0}]},{"line":"        self.with(|this| this.short())","counters":[{"col_start":0,"col_end":18,"count":0},{"col_start":25,"col_end":37,"count":0},{"col_start":37,"col_end":38,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    /// For tests only, check if the address is in the mask, without checking parent","counters":[]},{"line":"    #[cfg(test)]","counters":[]},{"line":"    fn test_is_in_mask(&self, addr: &Address) -> bool {","counters":[]},{"line":"        self.with(|this| this.test_is_in_mask(addr))","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// For tests only","counters":[]},{"line":"    #[cfg(test)]","counters":[]},{"line":"    fn test_matrix(&self) -> HashesMatrix {","counters":[]},{"line":"        self.with(|this| this.test_matrix())","counters":[]},{"line":"    }","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl BaseLedger for Mask {","counters":[]},{"line":"    fn to_list(&self) -> Vec<Account> {","counters":[{"col_start":4,"col_end":39,"count":10136}]},{"line":"        self.with(|this| this.to_list())","counters":[{"col_start":0,"col_end":18,"count":10136},{"col_start":25,"col_end":39,"count":3811},{"col_start":39,"col_end":40,"count":10136}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":10136}]},{"line":"","counters":[]},{"line":"    fn iter<F>(&self, fun: F)","counters":[]},{"line":"    where","counters":[]},{"line":"        F: FnMut(&Account),","counters":[]},{"line":"    {","counters":[]},{"line":"        self.with(|this| this.iter(fun))","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn fold<B, F>(&self, init: B, fun: F) -> B","counters":[]},{"line":"    where","counters":[]},{"line":"        F: FnMut(B, &Account) -> B,","counters":[]},{"line":"    {","counters":[]},{"line":"        self.with(|this| this.fold(init, fun))","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn fold_with_ignored_accounts<B, F>(&self, ignoreds: HashSet<AccountId>, init: B, fun: F) -> B","counters":[]},{"line":"    where","counters":[]},{"line":"        F: FnMut(B, &Account) -> B,","counters":[]},{"line":"    {","counters":[]},{"line":"        self.with(|this| this.fold_with_ignored_accounts(ignoreds, init, fun))","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn fold_until<B, F>(&self, init: B, fun: F) -> B","counters":[]},{"line":"    where","counters":[]},{"line":"        F: FnMut(B, &Account) -> std::ops::ControlFlow<B, B>,","counters":[]},{"line":"    {","counters":[]},{"line":"        self.with(|this| this.fold_until(init, fun))","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn accounts(&self) -> HashSet<AccountId> {","counters":[{"col_start":4,"col_end":46,"count":88333}]},{"line":"        self.with(|this| this.accounts())","counters":[{"col_start":0,"col_end":18,"count":88333},{"col_start":25,"col_end":40,"count":29972},{"col_start":40,"col_end":41,"count":88333}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":88333}]},{"line":"","counters":[]},{"line":"    fn token_owner(&self, token_id: TokenId) -> Option<AccountId> {","counters":[{"col_start":4,"col_end":67,"count":272}]},{"line":"        self.with(|this| this.token_owner(token_id))","counters":[{"col_start":0,"col_end":18,"count":272},{"col_start":25,"col_end":51,"count":233},{"col_start":51,"col_end":52,"count":272}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":272}]},{"line":"","counters":[]},{"line":"    fn token_owners(&self) -> HashSet<AccountId> {","counters":[{"col_start":4,"col_end":50,"count":212}]},{"line":"        self.with(|this| this.token_owners())","counters":[{"col_start":0,"col_end":18,"count":212},{"col_start":25,"col_end":44,"count":897},{"col_start":44,"col_end":45,"count":212}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":212}]},{"line":"","counters":[]},{"line":"    fn tokens(&self, public_key: CompressedPubKey) -> HashSet<TokenId> {","counters":[{"col_start":4,"col_end":72,"count":0}]},{"line":"        self.with(|this| this.tokens(public_key))","counters":[{"col_start":0,"col_end":18,"count":0},{"col_start":25,"col_end":48,"count":0},{"col_start":48,"col_end":49,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn location_of_account(&self, account_id: &AccountId) -> Option<Address> {","counters":[{"col_start":4,"col_end":78,"count":0}]},{"line":"        self.with(|this| this.location_of_account(account_id))","counters":[{"col_start":0,"col_end":18,"count":0},{"col_start":25,"col_end":61,"count":0},{"col_start":61,"col_end":62,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn location_of_account_batch(","counters":[{"col_start":4,"col_end":33,"count":0}]},{"line":"        &self,","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"        account_ids: &[AccountId],","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"    ) -> Vec<(AccountId, Option<Address>)> {","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"        self.with(|this| this.location_of_account_batch(account_ids))","counters":[{"col_start":0,"col_end":18,"count":0},{"col_start":25,"col_end":68,"count":0},{"col_start":68,"col_end":69,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn get_or_create_account(","counters":[{"col_start":4,"col_end":29,"count":0}]},{"line":"        &mut self,","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"        account_id: AccountId,","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"        account: Account,","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"    ) -> Result<GetOrCreated, DatabaseError> {","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"        self.with(|this| this.get_or_create_account(account_id, account))","counters":[{"col_start":0,"col_end":18,"count":0},{"col_start":25,"col_end":72,"count":0},{"col_start":72,"col_end":73,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn close(&self) {","counters":[{"col_start":4,"col_end":21,"count":0}]},{"line":"        // Drop self","counters":[{"col_start":0,"col_end":20,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn last_filled(&self) -> Option<Address> {","counters":[{"col_start":4,"col_end":46,"count":0}]},{"line":"        self.with(|this| this.last_filled())","counters":[{"col_start":0,"col_end":18,"count":0},{"col_start":25,"col_end":43,"count":0},{"col_start":43,"col_end":44,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn get_uuid(&self) -> Uuid {","counters":[{"col_start":4,"col_end":32,"count":0}]},{"line":"        self.with(|this| this.get_uuid())","counters":[{"col_start":0,"col_end":18,"count":0},{"col_start":25,"col_end":40,"count":0},{"col_start":40,"col_end":41,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn get_directory(&self) -> Option<PathBuf> {","counters":[{"col_start":4,"col_end":48,"count":0}]},{"line":"        self.with(|this| this.get_directory())","counters":[{"col_start":0,"col_end":18,"count":0},{"col_start":25,"col_end":45,"count":0},{"col_start":45,"col_end":46,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn get_account_hash(&mut self, account_index: AccountIndex) -> Option<Fp> {","counters":[{"col_start":4,"col_end":79,"count":0}]},{"line":"        self.with(|this| this.get_account_hash(account_index))","counters":[{"col_start":0,"col_end":18,"count":0},{"col_start":25,"col_end":61,"count":0},{"col_start":61,"col_end":62,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn get(&self, addr: Address) -> Option<Account> {","counters":[{"col_start":4,"col_end":53,"count":0}]},{"line":"        self.with(|this| this.get(addr))","counters":[{"col_start":0,"col_end":18,"count":0},{"col_start":25,"col_end":39,"count":0},{"col_start":39,"col_end":40,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn get_batch(&self, addr: &[Address]) -> Vec<(Address, Option<Account>)> {","counters":[{"col_start":4,"col_end":78,"count":0}]},{"line":"        self.with(|this| this.get_batch(addr))","counters":[{"col_start":0,"col_end":18,"count":0},{"col_start":25,"col_end":45,"count":0},{"col_start":45,"col_end":46,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn set(&mut self, addr: Address, account: Account) {","counters":[{"col_start":4,"col_end":56,"count":0}]},{"line":"        self.with(|this| this.set(addr, account))","counters":[{"col_start":0,"col_end":18,"count":0},{"col_start":25,"col_end":48,"count":2},{"col_start":48,"col_end":49,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn set_batch(&mut self, list: &[(Address, Account)]) {","counters":[{"col_start":4,"col_end":58,"count":0}]},{"line":"        self.with(|this| this.set_batch(list))","counters":[{"col_start":0,"col_end":18,"count":0},{"col_start":25,"col_end":45,"count":608},{"col_start":45,"col_end":46,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn get_at_index(&self, index: AccountIndex) -> Option<Account> {","counters":[{"col_start":4,"col_end":68,"count":0}]},{"line":"        self.with(|this| this.get_at_index(index))","counters":[{"col_start":0,"col_end":18,"count":0},{"col_start":25,"col_end":49,"count":0},{"col_start":49,"col_end":50,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn set_at_index(&mut self, index: AccountIndex, account: Account) -> Result<(), ()> {","counters":[{"col_start":4,"col_end":89,"count":0}]},{"line":"        self.with(|this| this.set_at_index(index, account))","counters":[{"col_start":0,"col_end":18,"count":0},{"col_start":25,"col_end":58,"count":0},{"col_start":58,"col_end":59,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn index_of_account(&self, account_id: AccountId) -> Option<AccountIndex> {","counters":[{"col_start":4,"col_end":79,"count":38}]},{"line":"        self.with(|this| this.index_of_account(account_id))","counters":[{"col_start":0,"col_end":18,"count":38},{"col_start":25,"col_end":58,"count":0},{"col_start":58,"col_end":59,"count":38}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":38}]},{"line":"","counters":[]},{"line":"    fn merkle_root(&mut self) -> Fp {","counters":[{"col_start":4,"col_end":37,"count":0}]},{"line":"        self.with(|this| this.merkle_root())","counters":[{"col_start":0,"col_end":18,"count":0},{"col_start":25,"col_end":43,"count":10},{"col_start":43,"col_end":44,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn merkle_path(&mut self, addr: Address) -> Vec<MerklePath> {","counters":[{"col_start":4,"col_end":65,"count":2524}]},{"line":"        let addr_length = addr.length();","counters":[{"col_start":0,"col_end":40,"count":2524}]},{"line":"        let res = self.with(|this| this.merkle_path(addr.clone()));","counters":[{"col_start":0,"col_end":28,"count":2524},{"col_start":35,"col_end":65,"count":0},{"col_start":65,"col_end":67,"count":2524}]},{"line":"        assert_eq!(res.len(), addr_length);","counters":[{"col_start":0,"col_end":42,"count":2524}]},{"line":"","counters":[]},{"line":"        // elog!(","counters":[]},{"line":"        //     \"merkle_path addr={:?} path_len={:?} path={:?}\",","counters":[]},{"line":"        //     addr,","counters":[]},{"line":"        //     res.len(),","counters":[]},{"line":"        //     res","counters":[]},{"line":"        // );","counters":[]},{"line":"","counters":[]},{"line":"        res","counters":[{"col_start":8,"col_end":11,"count":2514}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":2514}]},{"line":"","counters":[]},{"line":"    fn merkle_path_at_index(&mut self, index: AccountIndex) -> Vec<MerklePath> {","counters":[{"col_start":4,"col_end":80,"count":1287}]},{"line":"        self.with(|this| this.merkle_path_at_index(index))","counters":[{"col_start":0,"col_end":18,"count":1287},{"col_start":25,"col_end":57,"count":10},{"col_start":57,"col_end":58,"count":1287}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":1287}]},{"line":"","counters":[]},{"line":"    fn remove_accounts(&mut self, ids: &[AccountId]) {","counters":[{"col_start":4,"col_end":54,"count":1277}]},{"line":"        self.with(|this| this.remove_accounts(ids))","counters":[{"col_start":0,"col_end":18,"count":1277},{"col_start":25,"col_end":50,"count":0},{"col_start":50,"col_end":51,"count":1277}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":1277}]},{"line":"","counters":[]},{"line":"    fn detached_signal(&mut self) {","counters":[{"col_start":4,"col_end":35,"count":0}]},{"line":"        self.with(|this| this.detached_signal())","counters":[{"col_start":0,"col_end":18,"count":0},{"col_start":25,"col_end":47,"count":10},{"col_start":47,"col_end":48,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn depth(&self) -> u8 {","counters":[{"col_start":4,"col_end":27,"count":0}]},{"line":"        self.with(|this| this.depth())","counters":[{"col_start":0,"col_end":18,"count":0},{"col_start":25,"col_end":37,"count":0},{"col_start":37,"col_end":38,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn num_accounts(&self) -> usize {","counters":[{"col_start":4,"col_end":37,"count":0}]},{"line":"        self.with(|this| this.num_accounts())","counters":[{"col_start":0,"col_end":18,"count":0},{"col_start":25,"col_end":44,"count":0},{"col_start":44,"col_end":45,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn merkle_path_at_addr(&mut self, addr: Address) -> Vec<MerklePath> {","counters":[{"col_start":4,"col_end":73,"count":76}]},{"line":"        self.with(|this| this.merkle_path_at_addr(addr))","counters":[{"col_start":0,"col_end":18,"count":76},{"col_start":25,"col_end":55,"count":0},{"col_start":55,"col_end":56,"count":76}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":76}]},{"line":"","counters":[]},{"line":"    fn get_inner_hash_at_addr(&mut self, addr: Address) -> Result<Fp, ()> {","counters":[{"col_start":4,"col_end":75,"count":0}]},{"line":"        self.with(|this| this.get_inner_hash_at_addr(addr))","counters":[{"col_start":0,"col_end":18,"count":0},{"col_start":25,"col_end":58,"count":0},{"col_start":58,"col_end":59,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn set_inner_hash_at_addr(&mut self, addr: Address, hash: Fp) -> Result<(), ()> {","counters":[{"col_start":4,"col_end":85,"count":0}]},{"line":"        self.with(|this| this.set_inner_hash_at_addr(addr, hash))","counters":[{"col_start":0,"col_end":18,"count":0},{"col_start":25,"col_end":64,"count":155},{"col_start":64,"col_end":65,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn set_all_accounts_rooted_at(","counters":[{"col_start":4,"col_end":34,"count":155}]},{"line":"        &mut self,","counters":[{"col_start":0,"col_end":18,"count":155}]},{"line":"        addr: Address,","counters":[{"col_start":0,"col_end":22,"count":155}]},{"line":"        accounts: &[Account],","counters":[{"col_start":0,"col_end":29,"count":155}]},{"line":"    ) -> Result<(), ()> {","counters":[{"col_start":0,"col_end":25,"count":155}]},{"line":"        self.with(|this| this.set_all_accounts_rooted_at(addr, accounts))","counters":[{"col_start":0,"col_end":18,"count":155},{"col_start":25,"col_end":72,"count":0},{"col_start":72,"col_end":73,"count":155}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":155}]},{"line":"","counters":[]},{"line":"    fn get_all_accounts_rooted_at(&self, addr: Address) -> Option<Vec<(Address, Account)>> {","counters":[{"col_start":4,"col_end":92,"count":51}]},{"line":"        self.with(|this| this.get_all_accounts_rooted_at(addr))","counters":[{"col_start":0,"col_end":18,"count":51},{"col_start":25,"col_end":62,"count":44},{"col_start":62,"col_end":63,"count":51}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":51}]},{"line":"","counters":[]},{"line":"    fn make_space_for(&mut self, space: usize) {","counters":[{"col_start":4,"col_end":48,"count":0}]},{"line":"        self.with(|this| this.make_space_for(space))","counters":[{"col_start":0,"col_end":18,"count":0},{"col_start":25,"col_end":51,"count":0},{"col_start":51,"col_end":52,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn commit(&mut self) {","counters":[{"col_start":4,"col_end":26,"count":9129}]},{"line":"        self.with(|this| this.commit())","counters":[{"col_start":0,"col_end":18,"count":9129},{"col_start":25,"col_end":38,"count":2943},{"col_start":38,"col_end":39,"count":9129}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":9129}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"#[cfg(test)]","counters":[]},{"line":"mod tests {","counters":[]},{"line":"    use super::*;","counters":[]},{"line":"    use tests_mask_ocaml::*;","counters":[]},{"line":"","counters":[]},{"line":"    #[cfg(target_family = \"wasm\")]","counters":[]},{"line":"    use wasm_bindgen_test::wasm_bindgen_test as test;","counters":[]},{"line":"","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn test_drop_mask() {","counters":[]},{"line":"        let root_uuid;","counters":[]},{"line":"        let child1_uuid;","counters":[]},{"line":"        let child2_uuid;","counters":[]},{"line":"","counters":[]},{"line":"        let child = {","counters":[]},{"line":"            let child = {","counters":[]},{"line":"                println!(\"A\");","counters":[]},{"line":"                let root = Mask::new_unattached(25);","counters":[]},{"line":"                root_uuid = root.get_uuid();","counters":[]},{"line":"                println!(\"root={:?}\", root.get_uuid());","counters":[]},{"line":"                // let root = Mask::new_root(crate::Database::create(35.try_into().unwrap()));","counters":[]},{"line":"                println!(\"B\");","counters":[]},{"line":"                let child = root.make_child();","counters":[]},{"line":"                println!(\"child={:?}\", child.get_uuid());","counters":[]},{"line":"                child1_uuid = child.get_uuid();","counters":[]},{"line":"                child","counters":[]},{"line":"            };","counters":[]},{"line":"            println!(\"C\");","counters":[]},{"line":"            assert!(child.is_attached());","counters":[]},{"line":"","counters":[]},{"line":"            let child = child.make_child();","counters":[]},{"line":"            child2_uuid = child.get_uuid();","counters":[]},{"line":"            child","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        println!(\"D\");","counters":[]},{"line":"        println!(\"child2={:?}\", child.get_uuid());","counters":[]},{"line":"        assert!(child.is_attached());","counters":[]},{"line":"","counters":[]},{"line":"        {","counters":[]},{"line":"            let parent = child.get_parent().unwrap();","counters":[]},{"line":"            let parent = parent.get_parent().unwrap();","counters":[]},{"line":"            assert_eq!(parent.get_uuid(), root_uuid);","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        // The 3 masks should still be alive","counters":[]},{"line":"        assert!(crate::mask::tests::is_mask_alive(&root_uuid));","counters":[]},{"line":"        assert!(crate::mask::tests::is_mask_alive(&child1_uuid));","counters":[]},{"line":"        assert!(crate::mask::tests::is_mask_alive(&child2_uuid));","counters":[]},{"line":"","counters":[]},{"line":"        std::mem::drop(child);","counters":[]},{"line":"","counters":[]},{"line":"        // Now they are all drop/deallocated","counters":[]},{"line":"        assert!(!crate::mask::tests::is_mask_alive(&root_uuid));","counters":[]},{"line":"        assert!(!crate::mask::tests::is_mask_alive(&child1_uuid));","counters":[]},{"line":"        assert!(!crate::mask::tests::is_mask_alive(&child2_uuid));","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn test_merkle_path_one_account() {","counters":[]},{"line":"        let (mut root, mask) = new_instances(DEPTH);","counters":[]},{"line":"        let mut mask = root.register_mask(mask);","counters":[]},{"line":"","counters":[]},{"line":"        let account = Account::rand();","counters":[]},{"line":"","counters":[]},{"line":"        let addr = root","counters":[]},{"line":"            .get_or_create_account(account.id(), account)","counters":[]},{"line":"            .unwrap()","counters":[]},{"line":"            .addr();","counters":[]},{"line":"","counters":[]},{"line":"        let path = mask.merkle_path(addr);","counters":[]},{"line":"        assert_eq!(path.len(), DEPTH);","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn test_masks() {","counters":[]},{"line":"        const DEPTH: usize = 20;","counters":[]},{"line":"","counters":[]},{"line":"        let root = Mask::new_unattached(DEPTH);","counters":[]},{"line":"        let mask = Mask::new_unattached(DEPTH);","counters":[]},{"line":"","counters":[]},{"line":"        let mut mask = root.register_mask(mask);","counters":[]},{"line":"","counters":[]},{"line":"        let accounts: Vec<_> = (0..18).map(|_| Account::rand()).collect();","counters":[]},{"line":"","counters":[]},{"line":"        for account in &accounts {","counters":[]},{"line":"            mask.get_or_create_account(account.id(), account.clone())","counters":[]},{"line":"                .unwrap();","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        let mask_paths: Vec<_> = (0..18)","counters":[]},{"line":"            .map(|index| {","counters":[]},{"line":"                let index: AccountIndex = index.into();","counters":[]},{"line":"                let addr = Address::from_index(index, DEPTH);","counters":[]},{"line":"                mask.merkle_path(addr)","counters":[]},{"line":"            })","counters":[]},{"line":"            .collect();","counters":[]},{"line":"","counters":[]},{"line":"        let mask_root_hash = mask.merkle_root();","counters":[]},{"line":"","counters":[]},{"line":"        let mut db = Database::create(DEPTH as u8);","counters":[]},{"line":"        for account in &accounts {","counters":[]},{"line":"            db.get_or_create_account(account.id(), account.clone())","counters":[]},{"line":"                .unwrap();","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        let db_paths: Vec<_> = (0..18)","counters":[]},{"line":"            .map(|index| {","counters":[]},{"line":"                let index: AccountIndex = index.into();","counters":[]},{"line":"                let addr = Address::from_index(index, DEPTH);","counters":[]},{"line":"                mask.merkle_path(addr)","counters":[]},{"line":"            })","counters":[]},{"line":"            .collect();","counters":[]},{"line":"","counters":[]},{"line":"        let db_root_hash = db.merkle_root();","counters":[]},{"line":"","counters":[]},{"line":"        assert_eq!(mask_root_hash, db_root_hash);","counters":[]},{"line":"        assert_eq!(mask_paths, db_paths);","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn test_masks_unregister_recursive() {","counters":[]},{"line":"        let (_root, layer1, layer2) = new_chain(DEPTH);","counters":[]},{"line":"","counters":[]},{"line":"        let layer3 = layer2.make_child();","counters":[]},{"line":"        let layer4 = layer2.make_child();","counters":[]},{"line":"","counters":[]},{"line":"        for mask in [&layer1, &layer2, &layer3, &layer4] {","counters":[]},{"line":"            assert!(mask.get_parent().is_some());","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        // This should not panic","counters":[]},{"line":"        layer1.unregister_mask(UnregisterBehavior::Recursive);","counters":[]},{"line":"","counters":[]},{"line":"        for mask in [&layer1, &layer2, &layer3, &layer4] {","counters":[]},{"line":"            assert!(mask.get_parent().is_none());","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    // Make sure hashes are correctly invalided in masks (parents/childs)","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn test_masks_cached_hashes() {","counters":[]},{"line":"        for case in 0..2 {","counters":[]},{"line":"            let (mut root, mut layer1, mut layer2) = new_chain(DEPTH);","counters":[]},{"line":"","counters":[]},{"line":"            let acc1 = Account::rand();","counters":[]},{"line":"            let acc2 = Account::rand();","counters":[]},{"line":"            let acc3 = Account::rand();","counters":[]},{"line":"","counters":[]},{"line":"            let _loc1 = root.get_or_create_account(acc1.id(), acc1).unwrap().addr();","counters":[]},{"line":"            let _loc2 = layer1","counters":[]},{"line":"                .get_or_create_account(acc2.id(), acc2.clone())","counters":[]},{"line":"                .unwrap()","counters":[]},{"line":"                .addr();","counters":[]},{"line":"            let _loc3 = layer2","counters":[]},{"line":"                .get_or_create_account(acc3.id(), acc3)","counters":[]},{"line":"                .unwrap()","counters":[]},{"line":"                .addr();","counters":[]},{"line":"","counters":[]},{"line":"            let root_hash = layer2.merkle_root();","counters":[]},{"line":"","counters":[]},{"line":"            // Different cases where is should result in a different hash for the childs","counters":[]},{"line":"","counters":[]},{"line":"            if case == 0 {","counters":[]},{"line":"                layer1.remove_accounts(&[acc2.id()]);","counters":[]},{"line":"            } else if case == 1 {","counters":[]},{"line":"                let account_index = AccountIndex::from(1);","counters":[]},{"line":"                let addr = Address::from_index(account_index, DEPTH);","counters":[]},{"line":"                let new_account = Account::rand();","counters":[]},{"line":"","counters":[]},{"line":"                assert_ne!(layer1.get(addr.clone()).unwrap(), new_account);","counters":[]},{"line":"","counters":[]},{"line":"                layer1.set(addr, new_account);","counters":[]},{"line":"            }","counters":[]},{"line":"","counters":[]},{"line":"            assert_ne!(root_hash, layer2.merkle_root(), \"case {:?}\", case);","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn test_cached_merkle_path() {","counters":[]},{"line":"        let (mut root, mask) = new_instances(DEPTH);","counters":[]},{"line":"        let mut mask = root.register_mask(mask);","counters":[]},{"line":"","counters":[]},{"line":"        let account = Account::rand();","counters":[]},{"line":"        let addr = Address::first(DEPTH);","counters":[]},{"line":"","counters":[]},{"line":"        mask.set(addr.clone(), account.clone());","counters":[]},{"line":"        mask.merkle_root();","counters":[]},{"line":"        let mask_merkle_path = mask.merkle_path(addr.clone());","counters":[]},{"line":"","counters":[]},{"line":"        root.set(addr.clone(), account);","counters":[]},{"line":"        root.merkle_root();","counters":[]},{"line":"        let root_merkle_path = root.merkle_path(addr);","counters":[]},{"line":"","counters":[]},{"line":"        assert!(!mask_merkle_path.is_empty());","counters":[]},{"line":"        assert_eq!(mask_merkle_path, root_merkle_path);","counters":[]},{"line":"        elog!(\"path={:?}\", mask_merkle_path);","counters":[]},{"line":"    }","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"#[cfg(test)]","counters":[]},{"line":"mod tests_mask_ocaml {","counters":[]},{"line":"    use crate::scan_state::currency::{Balance, Magnitude};","counters":[]},{"line":"","counters":[]},{"line":"    use super::*;","counters":[]},{"line":"","counters":[]},{"line":"    use rand::{thread_rng, Rng};","counters":[]},{"line":"","counters":[]},{"line":"    #[cfg(target_family = \"wasm\")]","counters":[]},{"line":"    use wasm_bindgen_test::wasm_bindgen_test as test;","counters":[]},{"line":"","counters":[]},{"line":"    pub const DEPTH: usize = 4;","counters":[]},{"line":"    pub const FIRST_LOC: Address = Address::first(DEPTH);","counters":[]},{"line":"","counters":[]},{"line":"    pub fn new_instances(depth: usize) -> (Mask, Mask) {","counters":[]},{"line":"        let db = Database::<V2>::create(depth as u8);","counters":[]},{"line":"        (Mask::new_root(db), Mask::new_unattached(depth))","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    pub fn new_chain(depth: usize) -> (Mask, Mask, Mask) {","counters":[]},{"line":"        let db = Database::<V2>::create(depth as u8);","counters":[]},{"line":"        let layer1 = Mask::new_unattached(depth);","counters":[]},{"line":"        let layer2 = Mask::new_unattached(depth);","counters":[]},{"line":"","counters":[]},{"line":"        let root = Mask::new_root(db);","counters":[]},{"line":"        let layer1 = root.register_mask(layer1);","counters":[]},{"line":"        let layer2 = layer1.register_mask(layer2);","counters":[]},{"line":"","counters":[]},{"line":"        (root, layer1, layer2)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn make_full_accounts(depth: usize) -> Vec<Account> {","counters":[]},{"line":"        (0..2u64.pow(depth as u32))","counters":[]},{"line":"            .map(|_| Account::rand())","counters":[]},{"line":"            .collect()","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    // \"parent, mask agree on set\"","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn test_parent_mask_agree_on_set() {","counters":[]},{"line":"        let (mut root, mask) = new_instances(DEPTH);","counters":[]},{"line":"        let mask = root.register_mask(mask);","counters":[]},{"line":"","counters":[]},{"line":"        root.set(FIRST_LOC, Account::rand());","counters":[]},{"line":"","counters":[]},{"line":"        let root_account = root.get(FIRST_LOC).unwrap();","counters":[]},{"line":"        let mask_account = mask.get(FIRST_LOC).unwrap();","counters":[]},{"line":"","counters":[]},{"line":"        assert_eq!(root_account, mask_account);","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    // \"parent, mask agree on set\"","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn test_parent_mask_agree_on_set2() {","counters":[]},{"line":"        let (mut root, mask) = new_instances(DEPTH);","counters":[]},{"line":"        let mut mask = root.register_mask(mask);","counters":[]},{"line":"","counters":[]},{"line":"        let account = Account::rand();","counters":[]},{"line":"        root.set(FIRST_LOC, account.clone());","counters":[]},{"line":"        mask.set(FIRST_LOC, account);","counters":[]},{"line":"","counters":[]},{"line":"        let root_account = root.get(FIRST_LOC).unwrap();","counters":[]},{"line":"        let mask_account = mask.get(FIRST_LOC).unwrap();","counters":[]},{"line":"","counters":[]},{"line":"        assert_eq!(root_account, mask_account);","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    // \"parent, mask agree on hashes; set in both mask and parent\"","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn test_parent_mask_agree_on_hashes() {","counters":[]},{"line":"        let (mut root, mask) = new_instances(DEPTH);","counters":[]},{"line":"        let mut mask = root.register_mask(mask);","counters":[]},{"line":"","counters":[]},{"line":"        let account = Account::rand();","counters":[]},{"line":"        root.set(FIRST_LOC, account.clone());","counters":[]},{"line":"        mask.set(FIRST_LOC, account);","counters":[]},{"line":"","counters":[]},{"line":"        assert_eq!(root.merkle_root(), mask.merkle_root());","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    // \"parent, mask agree on hashes; set only in parent\"","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn test_parent_mask_agree_on_hashes_set_parent_only() {","counters":[]},{"line":"        let (mut root, mask) = new_instances(DEPTH);","counters":[]},{"line":"        let mut mask = root.register_mask(mask);","counters":[]},{"line":"","counters":[]},{"line":"        let account = Account::rand();","counters":[]},{"line":"        root.set(FIRST_LOC, account);","counters":[]},{"line":"","counters":[]},{"line":"        assert_eq!(root.merkle_root(), mask.merkle_root());","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    // \"mask delegates to parent\"","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn test_mask_delegate_to_parent() {","counters":[]},{"line":"        let (mut root, mask) = new_instances(DEPTH);","counters":[]},{"line":"        let mask = root.register_mask(mask);","counters":[]},{"line":"","counters":[]},{"line":"        let account = Account::rand();","counters":[]},{"line":"        root.set(FIRST_LOC, account.clone());","counters":[]},{"line":"","counters":[]},{"line":"        let child_account = mask.get(FIRST_LOC).unwrap();","counters":[]},{"line":"","counters":[]},{"line":"        assert_eq!(account, child_account);","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    // \"mask prune after parent notification\"","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn test_mask_prune_after_parent_notif() {","counters":[]},{"line":"        let (mut root, mask) = new_instances(DEPTH);","counters":[]},{"line":"        let mut mask = root.register_mask(mask);","counters":[]},{"line":"","counters":[]},{"line":"        // Set in mask","counters":[]},{"line":"        let account = Account::rand();","counters":[]},{"line":"        mask.set(FIRST_LOC, account.clone());","counters":[]},{"line":"","counters":[]},{"line":"        assert!(mask.test_is_in_mask(&FIRST_LOC));","counters":[]},{"line":"","counters":[]},{"line":"        root.set(FIRST_LOC, account);","counters":[]},{"line":"","counters":[]},{"line":"        // The address is no more in the mask","counters":[]},{"line":"        assert!(!mask.test_is_in_mask(&FIRST_LOC));","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    // \"commit puts mask contents in parent, flushes mask\"","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn test_commit_puts_mask_in_parent_and_flush_mask() {","counters":[]},{"line":"        let (root, mask) = new_instances(DEPTH);","counters":[]},{"line":"        let mut mask = root.register_mask(mask);","counters":[]},{"line":"","counters":[]},{"line":"        let account = Account::rand();","counters":[]},{"line":"        mask.set(FIRST_LOC, account);","counters":[]},{"line":"","counters":[]},{"line":"        assert!(mask.test_is_in_mask(&FIRST_LOC));","counters":[]},{"line":"","counters":[]},{"line":"        mask.commit();","counters":[]},{"line":"","counters":[]},{"line":"        // No more in mask","counters":[]},{"line":"        assert!(!mask.test_is_in_mask(&FIRST_LOC));","counters":[]},{"line":"        // The parent get the account","counters":[]},{"line":"        assert!(root.get(FIRST_LOC).is_some());","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    // \"commit at layer2, dumps to layer1, not in base\"","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn test_commit_layer2_dumps_to_layer1_not_in_base() {","counters":[]},{"line":"        let (root, layer1, mut layer2) = new_chain(DEPTH);","counters":[]},{"line":"","counters":[]},{"line":"        let account = Account::rand();","counters":[]},{"line":"","counters":[]},{"line":"        layer2.set(FIRST_LOC, account);","counters":[]},{"line":"        assert!(layer2.test_is_in_mask(&FIRST_LOC));","counters":[]},{"line":"        assert!(!layer1.test_is_in_mask(&FIRST_LOC));","counters":[]},{"line":"","counters":[]},{"line":"        layer2.commit();","counters":[]},{"line":"        assert!(!layer2.test_is_in_mask(&FIRST_LOC));","counters":[]},{"line":"        assert!(layer1.test_is_in_mask(&FIRST_LOC));","counters":[]},{"line":"        assert!(!root.test_is_in_mask(&FIRST_LOC));","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    // \"register and unregister mask\"","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn test_register_unregister_mask() {","counters":[]},{"line":"        let (root, mask) = new_instances(DEPTH);","counters":[]},{"line":"        let mask = root.register_mask(mask);","counters":[]},{"line":"        mask.unregister_mask(UnregisterBehavior::Recursive);","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    // \"mask and parent agree on Merkle path\"","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn test_mask_and_parent_agree_on_merkle_path() {","counters":[]},{"line":"        let (mut root, mask) = new_instances(DEPTH);","counters":[]},{"line":"        let mut mask = root.register_mask(mask);","counters":[]},{"line":"","counters":[]},{"line":"        let account = Account::rand();","counters":[]},{"line":"        let addr = Address::first(DEPTH);","counters":[]},{"line":"","counters":[]},{"line":"        mask.set(addr.clone(), account.clone());","counters":[]},{"line":"        let mask_merkle_path = mask.merkle_path(addr.clone());","counters":[]},{"line":"","counters":[]},{"line":"        root.set(addr.clone(), account);","counters":[]},{"line":"        let root_merkle_path = root.merkle_path(addr);","counters":[]},{"line":"","counters":[]},{"line":"        assert!(!mask_merkle_path.is_empty());","counters":[]},{"line":"        assert_eq!(mask_merkle_path, root_merkle_path);","counters":[]},{"line":"        elog!(\"path={:?}\", mask_merkle_path);","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    // \"mask and parent agree on Merkle root before set\"","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn test_agree_on_root_hash_before_set() {","counters":[]},{"line":"        let (mut root, mask) = new_instances(DEPTH);","counters":[]},{"line":"        let mut mask = root.register_mask(mask);","counters":[]},{"line":"","counters":[]},{"line":"        assert_eq!(root.merkle_root(), mask.merkle_root());","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    // \"mask and parent agree on Merkle root after set\"","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn test_agree_on_root_hash_after_set() {","counters":[]},{"line":"        let (mut root, mask) = new_instances(DEPTH);","counters":[]},{"line":"        let mut mask = root.register_mask(mask);","counters":[]},{"line":"","counters":[]},{"line":"        let account = Account::rand();","counters":[]},{"line":"","counters":[]},{"line":"        // the order of sets matters here; if we set in the mask first,","counters":[]},{"line":"        // the set in the maskable notifies the mask, which then removes","counters":[]},{"line":"        // the account, changing the Merkle root to what it was before the set","counters":[]},{"line":"","counters":[]},{"line":"        root.set(FIRST_LOC, account.clone());","counters":[]},{"line":"        mask.set(FIRST_LOC, account);","counters":[]},{"line":"","counters":[]},{"line":"        assert!(root.test_is_in_mask(&FIRST_LOC));","counters":[]},{"line":"        assert!(mask.test_is_in_mask(&FIRST_LOC));","counters":[]},{"line":"        assert_eq!(root.merkle_root(), mask.merkle_root());","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    // \"add and retrieve a block of accounts\"","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn test_add_retrieve_block_of_accounts() {","counters":[]},{"line":"        let (root, mask) = new_instances(DEPTH);","counters":[]},{"line":"        let mut mask = root.register_mask(mask);","counters":[]},{"line":"","counters":[]},{"line":"        let accounts = make_full_accounts(DEPTH);","counters":[]},{"line":"","counters":[]},{"line":"        for account in &accounts {","counters":[]},{"line":"            let account_id = account.id();","counters":[]},{"line":"            let res = mask","counters":[]},{"line":"                .get_or_create_account(account_id, account.clone())","counters":[]},{"line":"                .unwrap();","counters":[]},{"line":"            assert!(matches!(res, GetOrCreated::Added(_)));","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        let retrieved_accounts = mask","counters":[]},{"line":"            .get_all_accounts_rooted_at(Address::root())","counters":[]},{"line":"            .unwrap()","counters":[]},{"line":"            .into_iter()","counters":[]},{"line":"            .map(|(_, acc)| acc)","counters":[]},{"line":"            .collect::<Vec<_>>();","counters":[]},{"line":"","counters":[]},{"line":"        assert_eq!(accounts, retrieved_accounts);","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    // \"removing accounts from mask restores Merkle root\"","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn test_removing_accounts_from_mask_restore_root_hash() {","counters":[]},{"line":"        let (root, mask) = new_instances(DEPTH);","counters":[]},{"line":"        let mut mask = root.register_mask(mask);","counters":[]},{"line":"","counters":[]},{"line":"        let accounts = (0..5).map(|_| Account::rand()).collect::<Vec<_>>();","counters":[]},{"line":"        let accounts_ids = accounts.iter().map(Account::id).collect::<Vec<_>>();","counters":[]},{"line":"        let root_hash0 = mask.merkle_root();","counters":[]},{"line":"","counters":[]},{"line":"        for account in accounts {","counters":[]},{"line":"            mask.get_or_create_account(account.id(), account).unwrap();","counters":[]},{"line":"        }","counters":[]},{"line":"        assert_ne!(root_hash0, mask.merkle_root());","counters":[]},{"line":"","counters":[]},{"line":"        mask.remove_accounts(&accounts_ids);","counters":[]},{"line":"        assert_eq!(root_hash0, mask.merkle_root());","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    // \"removing accounts from parent restores Merkle root\"","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn test_removing_accounts_from_parent_restore_root_hash() {","counters":[]},{"line":"        let (mut root, mask) = new_instances(DEPTH);","counters":[]},{"line":"        let mut mask = root.register_mask(mask);","counters":[]},{"line":"","counters":[]},{"line":"        let accounts = (0..5).map(|_| Account::rand()).collect::<Vec<_>>();","counters":[]},{"line":"        let accounts_ids = accounts.iter().map(Account::id).collect::<Vec<_>>();","counters":[]},{"line":"        let root_hash0 = mask.merkle_root();","counters":[]},{"line":"","counters":[]},{"line":"        for account in accounts {","counters":[]},{"line":"            root.get_or_create_account(account.id(), account).unwrap();","counters":[]},{"line":"        }","counters":[]},{"line":"        assert_ne!(root_hash0, mask.merkle_root());","counters":[]},{"line":"","counters":[]},{"line":"        mask.remove_accounts(&accounts_ids);","counters":[]},{"line":"        assert_eq!(root_hash0, mask.merkle_root());","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    // \"removing accounts from parent and mask restores Merkle root\"","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn test_removing_accounts_from_parent_and_mask_restore_root_hash() {","counters":[]},{"line":"        let (mut root, mask) = new_instances(DEPTH);","counters":[]},{"line":"        let mut mask = root.register_mask(mask);","counters":[]},{"line":"","counters":[]},{"line":"        let accounts = (0..10).map(|_| Account::rand()).collect::<Vec<_>>();","counters":[]},{"line":"        let (accounts_parent, accounts_mask) = accounts.split_at(5);","counters":[]},{"line":"        let accounts_ids = accounts.iter().map(Account::id).collect::<Vec<_>>();","counters":[]},{"line":"","counters":[]},{"line":"        let root_hash0 = mask.merkle_root();","counters":[]},{"line":"","counters":[]},{"line":"        for account in accounts_parent {","counters":[]},{"line":"            root.get_or_create_account(account.id(), account.clone())","counters":[]},{"line":"                .unwrap();","counters":[]},{"line":"        }","counters":[]},{"line":"        for account in accounts_mask {","counters":[]},{"line":"            mask.get_or_create_account(account.id(), account.clone())","counters":[]},{"line":"                .unwrap();","counters":[]},{"line":"        }","counters":[]},{"line":"        assert_ne!(root_hash0, mask.merkle_root());","counters":[]},{"line":"","counters":[]},{"line":"        mask.remove_accounts(&accounts_ids);","counters":[]},{"line":"        assert_eq!(root_hash0, mask.merkle_root());","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    // \"fold of addition over account balances in parent and mask\"","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn test_fold_of_addition_over_account_balance_in_parent_and_mask() {","counters":[]},{"line":"        let (mut root, mask) = new_instances(DEPTH);","counters":[]},{"line":"        let mut mask = root.register_mask(mask);","counters":[]},{"line":"","counters":[]},{"line":"        let accounts = (0..10).map(|_| Account::rand()).collect::<Vec<_>>();","counters":[]},{"line":"        let balance = accounts","counters":[]},{"line":"            .iter()","counters":[]},{"line":"            .fold(0u128, |acc, account| acc + account.balance.as_u64() as u128);","counters":[]},{"line":"","counters":[]},{"line":"        let (accounts_parent, accounts_mask) = accounts.split_at(5);","counters":[]},{"line":"","counters":[]},{"line":"        for account in accounts_parent {","counters":[]},{"line":"            root.get_or_create_account(account.id(), account.clone())","counters":[]},{"line":"                .unwrap();","counters":[]},{"line":"        }","counters":[]},{"line":"        for account in accounts_mask {","counters":[]},{"line":"            mask.get_or_create_account(account.id(), account.clone())","counters":[]},{"line":"                .unwrap();","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        let retrieved_balance =","counters":[]},{"line":"            mask.fold(0u128, |acc, account| acc + account.balance.as_u64() as u128);","counters":[]},{"line":"        assert_eq!(balance, retrieved_balance);","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn create_existing_account(mask: &mut Mask, account: Account) {","counters":[]},{"line":"        match mask","counters":[]},{"line":"            .get_or_create_account(account.id(), account.clone())","counters":[]},{"line":"            .unwrap()","counters":[]},{"line":"        {","counters":[]},{"line":"            GetOrCreated::Added(_) => panic!(\"Should add an existing account\"),","counters":[]},{"line":"            GetOrCreated::Existed(addr) => {","counters":[]},{"line":"                mask.set(addr, account);","counters":[]},{"line":"            }","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    // \"masking in to_list\"","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn test_masking_in_to_list() {","counters":[]},{"line":"        let (mut root, mask) = new_instances(DEPTH);","counters":[]},{"line":"        let mut mask = root.register_mask(mask);","counters":[]},{"line":"","counters":[]},{"line":"        let mut accounts = (0..10).map(|_| Account::rand()).collect::<Vec<_>>();","counters":[]},{"line":"        // Make balances non-zero","counters":[]},{"line":"        let one = Balance::from_u64(1);","counters":[]},{"line":"        accounts.iter_mut().for_each(|account| {","counters":[]},{"line":"            account.balance = account.balance.checked_add(&one).unwrap_or(one.clone())","counters":[]},{"line":"        });","counters":[]},{"line":"","counters":[]},{"line":"        for account in &accounts {","counters":[]},{"line":"            root.get_or_create_account(account.id(), account.clone())","counters":[]},{"line":"                .unwrap();","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        let parent_list = root.to_list();","counters":[]},{"line":"","counters":[]},{"line":"        // Make balances to zero for those same account","counters":[]},{"line":"        accounts","counters":[]},{"line":"            .iter_mut()","counters":[]},{"line":"            .for_each(|account| account.balance = Balance::zero());","counters":[]},{"line":"","counters":[]},{"line":"        for account in accounts {","counters":[]},{"line":"            create_existing_account(&mut mask, account);","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        let mask_list = mask.to_list();","counters":[]},{"line":"","counters":[]},{"line":"        assert_eq!(parent_list.len(), mask_list.len());","counters":[]},{"line":"        // Same accounts and order","counters":[]},{"line":"        assert_eq!(","counters":[]},{"line":"            parent_list.iter().map(Account::id).collect::<Vec<_>>(),","counters":[]},{"line":"            mask_list.iter().map(Account::id).collect::<Vec<_>>(),","counters":[]},{"line":"        );","counters":[]},{"line":"        // Balances of mask are zero","counters":[]},{"line":"        assert_eq!(","counters":[]},{"line":"            mask_list","counters":[]},{"line":"                .iter()","counters":[]},{"line":"                .fold(0u128, |acc, account| acc + account.balance.as_u64() as u128),","counters":[]},{"line":"            0","counters":[]},{"line":"        );","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    // \"masking in foldi\"","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn test_masking_in_to_foldi() {","counters":[]},{"line":"        let (mut root, mask) = new_instances(DEPTH);","counters":[]},{"line":"        let mut mask = root.register_mask(mask);","counters":[]},{"line":"","counters":[]},{"line":"        let mut accounts = (0..10).map(|_| Account::rand()).collect::<Vec<_>>();","counters":[]},{"line":"        // Make balances non-zero","counters":[]},{"line":"        let one = Balance::from_u64(1);","counters":[]},{"line":"        accounts.iter_mut().for_each(|account| {","counters":[]},{"line":"            account.balance = account.balance.checked_add(&one).unwrap_or(one.clone())","counters":[]},{"line":"        });","counters":[]},{"line":"","counters":[]},{"line":"        for account in &accounts {","counters":[]},{"line":"            root.get_or_create_account(account.id(), account.clone())","counters":[]},{"line":"                .unwrap();","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        let parent_sum_balance =","counters":[]},{"line":"            root.fold(0u128, |acc, account| acc + account.balance.as_u64() as u128);","counters":[]},{"line":"        assert_ne!(parent_sum_balance, 0);","counters":[]},{"line":"","counters":[]},{"line":"        // Make balances to zero for those same account","counters":[]},{"line":"        accounts","counters":[]},{"line":"            .iter_mut()","counters":[]},{"line":"            .for_each(|account| account.balance = Balance::zero());","counters":[]},{"line":"","counters":[]},{"line":"        for account in accounts {","counters":[]},{"line":"            create_existing_account(&mut mask, account);","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        let mask_sum_balance =","counters":[]},{"line":"            mask.fold(0u128, |acc, account| acc + account.balance.as_u64() as u128);","counters":[]},{"line":"        assert_eq!(mask_sum_balance, 0);","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    // \"create_empty doesn't modify the hash\"","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn test_create_empty_doesnt_modify_the_hash() {","counters":[]},{"line":"        let (root, mask) = new_instances(DEPTH);","counters":[]},{"line":"        let mut mask = root.register_mask(mask);","counters":[]},{"line":"","counters":[]},{"line":"        let start_hash = mask.merkle_root();","counters":[]},{"line":"","counters":[]},{"line":"        let account = Account::empty();","counters":[]},{"line":"        mask.get_or_create_account(account.id(), account).unwrap();","counters":[]},{"line":"","counters":[]},{"line":"        assert_eq!(mask.num_accounts(), 1);","counters":[]},{"line":"        assert_eq!(start_hash, mask.merkle_root());","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    // \"reuse of locations for removed accounts\"","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn test_reuse_of_locations_for_removed_accounts() {","counters":[]},{"line":"        let (root, mask) = new_instances(DEPTH);","counters":[]},{"line":"        let mut mask = root.register_mask(mask);","counters":[]},{"line":"","counters":[]},{"line":"        let accounts = (0..10).map(|_| Account::rand()).collect::<Vec<_>>();","counters":[]},{"line":"        let accounts_ids = accounts.iter().map(Account::id).collect::<Vec<_>>();","counters":[]},{"line":"","counters":[]},{"line":"        assert!(mask.last_filled().is_none());","counters":[]},{"line":"        for account in accounts {","counters":[]},{"line":"            mask.get_or_create_account(account.id(), account.clone())","counters":[]},{"line":"                .unwrap();","counters":[]},{"line":"        }","counters":[]},{"line":"        assert!(mask.last_filled().is_some());","counters":[]},{"line":"","counters":[]},{"line":"        mask.remove_accounts(&accounts_ids);","counters":[]},{"line":"        assert!(mask.last_filled().is_none());","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    // \"num_accounts for unique keys in mask and parent\"","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn test_num_accounts_for_unique_keys_in_mask_and_parent() {","counters":[]},{"line":"        let (mut root, mask) = new_instances(DEPTH);","counters":[]},{"line":"        let mut mask = root.register_mask(mask);","counters":[]},{"line":"","counters":[]},{"line":"        let accounts = (0..10).map(|_| Account::rand()).collect::<Vec<_>>();","counters":[]},{"line":"","counters":[]},{"line":"        for account in &accounts {","counters":[]},{"line":"            mask.get_or_create_account(account.id(), account.clone())","counters":[]},{"line":"                .unwrap();","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        let mask_num_accounts_before = mask.num_accounts();","counters":[]},{"line":"","counters":[]},{"line":"        // Add same accounts to parent","counters":[]},{"line":"        for account in &accounts {","counters":[]},{"line":"            root.get_or_create_account(account.id(), account.clone())","counters":[]},{"line":"                .unwrap();","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        let parent_num_accounts = root.num_accounts();","counters":[]},{"line":"        let mask_num_accounts_after = mask.num_accounts();","counters":[]},{"line":"","counters":[]},{"line":"        assert_eq!(accounts.len(), parent_num_accounts);","counters":[]},{"line":"        assert_eq!(parent_num_accounts, mask_num_accounts_before);","counters":[]},{"line":"        assert_eq!(parent_num_accounts, mask_num_accounts_after);","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    // \"Mask reparenting works\"","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn test_mask_reparenting_works() {","counters":[]},{"line":"        let (mut root, mut layer1, mut layer2) = new_chain(DEPTH);","counters":[]},{"line":"","counters":[]},{"line":"        let acc1 = Account::rand();","counters":[]},{"line":"        let acc2 = Account::rand();","counters":[]},{"line":"        let acc3 = Account::rand();","counters":[]},{"line":"","counters":[]},{"line":"        let loc1 = root.get_or_create_account(acc1.id(), acc1).unwrap().addr();","counters":[]},{"line":"        let loc2 = layer1","counters":[]},{"line":"            .get_or_create_account(acc2.id(), acc2)","counters":[]},{"line":"            .unwrap()","counters":[]},{"line":"            .addr();","counters":[]},{"line":"        let loc3 = layer2","counters":[]},{"line":"            .get_or_create_account(acc3.id(), acc3)","counters":[]},{"line":"            .unwrap()","counters":[]},{"line":"            .addr();","counters":[]},{"line":"","counters":[]},{"line":"        // All accounts are accessible from layer2","counters":[]},{"line":"        assert!(layer2.get(loc1.clone()).is_some());","counters":[]},{"line":"        assert!(layer2.get(loc2.clone()).is_some());","counters":[]},{"line":"        assert!(layer2.get(loc3.clone()).is_some());","counters":[]},{"line":"","counters":[]},{"line":"        // acc1 is in root","counters":[]},{"line":"        assert!(root.get(loc1.clone()).is_some());","counters":[]},{"line":"","counters":[]},{"line":"        layer1.commit();","counters":[]},{"line":"","counters":[]},{"line":"        // acc2 is in root","counters":[]},{"line":"        assert!(root.get(loc2.clone()).is_some());","counters":[]},{"line":"","counters":[]},{"line":"        layer1.remove_and_reparent();","counters":[]},{"line":"","counters":[]},{"line":"        // acc1, acc2 are in root","counters":[]},{"line":"        assert!(root.get(loc1.clone()).is_some());","counters":[]},{"line":"        assert!(root.get(loc2.clone()).is_some());","counters":[]},{"line":"","counters":[]},{"line":"        // acc3 not in root","counters":[]},{"line":"        assert!(root.get(loc3.clone()).is_none());","counters":[]},{"line":"","counters":[]},{"line":"        // All accounts are accessible from layer2","counters":[]},{"line":"        assert!(layer2.get(loc1).is_some());","counters":[]},{"line":"        assert!(layer2.get(loc2).is_some());","counters":[]},{"line":"        assert!(layer2.get(loc3).is_some());","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    // \"setting an account in the parent doesn't remove the masked","counters":[]},{"line":"    // copy if the mask is still dirty for that account\"","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn test_set_account_in_parent_doesnt_remove_if_mask_is_dirty() {","counters":[]},{"line":"        let (mut root, mask) = new_instances(DEPTH);","counters":[]},{"line":"        let mut mask = root.register_mask(mask);","counters":[]},{"line":"","counters":[]},{"line":"        let mut account = Account::rand();","counters":[]},{"line":"        let mut account2 = account.clone();","counters":[]},{"line":"","counters":[]},{"line":"        account.balance = Balance::from_u64(10);","counters":[]},{"line":"        account2.balance = Balance::from_u64(5);","counters":[]},{"line":"","counters":[]},{"line":"        let loc = mask","counters":[]},{"line":"            .get_or_create_account(account.id(), account.clone())","counters":[]},{"line":"            .unwrap()","counters":[]},{"line":"            .addr();","counters":[]},{"line":"","counters":[]},{"line":"        root.set(loc.clone(), account2);","counters":[]},{"line":"","counters":[]},{"line":"        assert_eq!(mask.get(loc).unwrap(), account);","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    // \"get_all_accounts should preserve the ordering of accounts by","counters":[]},{"line":"    // location with noncontiguous updates of accounts on the mask\"","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn test_get_all_accounts_should_preserve_ordering() {","counters":[]},{"line":"        let (_root, mut layer1, mut layer2) = new_chain(DEPTH);","counters":[]},{"line":"","counters":[]},{"line":"        let accounts = make_full_accounts(DEPTH);","counters":[]},{"line":"","counters":[]},{"line":"        for account in &accounts {","counters":[]},{"line":"            layer1","counters":[]},{"line":"                .get_or_create_account(account.id(), account.clone())","counters":[]},{"line":"                .unwrap();","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        let mut updated_accounts = accounts.clone();","counters":[]},{"line":"        let mut rng = thread_rng();","counters":[]},{"line":"        let mut nmodified = 0;","counters":[]},{"line":"","counters":[]},{"line":"        for account in updated_accounts.iter_mut() {","counters":[]},{"line":"            if rng.gen::<u8>() >= 150 {","counters":[]},{"line":"                continue;","counters":[]},{"line":"            }","counters":[]},{"line":"            account.balance = rng.gen();","counters":[]},{"line":"","counters":[]},{"line":"            create_existing_account(&mut layer2, account.clone());","counters":[]},{"line":"            nmodified += 1;","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        assert!(nmodified > 0);","counters":[]},{"line":"        assert_eq!(","counters":[]},{"line":"            updated_accounts,","counters":[]},{"line":"            layer2","counters":[]},{"line":"                .get_all_accounts_rooted_at(Address::root())","counters":[]},{"line":"                .unwrap()","counters":[]},{"line":"                .into_iter()","counters":[]},{"line":"                .map(|(_, account)| account)","counters":[]},{"line":"                .collect::<Vec<_>>()","counters":[]},{"line":"        );","counters":[]},{"line":"        assert_eq!(","counters":[]},{"line":"            accounts,","counters":[]},{"line":"            layer1","counters":[]},{"line":"                .get_all_accounts_rooted_at(Address::root())","counters":[]},{"line":"                .unwrap()","counters":[]},{"line":"                .into_iter()","counters":[]},{"line":"                .map(|(_, account)| account)","counters":[]},{"line":"                .collect::<Vec<_>>()","counters":[]},{"line":"        );","counters":[]},{"line":"    }","counters":[]},{"line":"}","counters":[]}]}