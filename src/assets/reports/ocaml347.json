{"filename":"src/lib/secrets/libp2p_keypair.ml","lines":[{"line":"open Core","counters":[]},{"line":"open Async","counters":[]},{"line":"open Async.Deferred.Let_syntax","counters":[]},{"line":"open Keypair_common","counters":[]},{"line":"","counters":[]},{"line":"module T = struct","counters":[]},{"line":"  type t = Mina_net2.Keypair.t","counters":[]},{"line":"","counters":[]},{"line":"  let env = \"MINA_LIBP2P_PASS\"","counters":[]},{"line":"","counters":[]},{"line":"  let which = \"libp2p keypair\"","counters":[]},{"line":"","counters":[]},{"line":"  (** Writes a keypair to [privkey_path] and [privkey_path ^ \".pub\"] using [Secret_file] *)","counters":[]},{"line":"  let write_exn kp ~(privkey_path : string) ~(password : Secret_file.password) :","counters":[]},{"line":"      unit Deferred.t =","counters":[]},{"line":"    let str = Mina_net2.Keypair.to_string kp in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    match%bind","counters":[]},{"line":"      Secret_file.write ~path:privkey_path ~mkdir:true","counters":[]},{"line":"        ~plaintext:(Bytes.of_string str) ~password","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"    with","counters":[]},{"line":"    | Ok () ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (* The hope is that if [Secret_file.write] succeeded then this ought to","counters":[]},{"line":"           as well, letting [handle_open] stay inside [Secret_file]. It might not","counters":[]},{"line":"           if the environment changes underneath us, and we won't have nice errors","counters":[]},{"line":"           in that case. *)","counters":[]},{"line":"        let%bind pubkey_f = Writer.open_file (privkey_path ^ \".peerid\") in","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"        Writer.write_line pubkey_f (Mina_net2.Keypair.to_peer_id kp) ;","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"        Writer.close pubkey_f","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    | Error e ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Privkey_error.raise ~which e","counters":[]},{"line":"","counters":[]},{"line":"  (** Reads a private key from [privkey_path] using [Secret_file] *)","counters":[]},{"line":"  let read ~(privkey_path : string) ~(password : Secret_file.password) :","counters":[]},{"line":"      (t, Privkey_error.t) Deferred.Result.t =","counters":[]},{"line":"    let open Deferred.Result.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let%bind bytes = Secret_file.read ~path:privkey_path ~password in","counters":[]},{"line":"    Deferred.return","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    @@","counters":[]},{"line":"    match Mina_net2.Keypair.of_string (Bytes.to_string bytes) with","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"    | Ok kp ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Ok kp","counters":[]},{"line":"    | Error e ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Privkey_error.corrupted_privkey e","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"","counters":[]},{"line":"  (** Reads a private key from [privkey_path] using [Secret_file], throws on failure *)","counters":[]},{"line":"  let read_exn ~(privkey_path : string) ~(password : Secret_file.password) :","counters":[]},{"line":"      t Deferred.t =","counters":[]},{"line":"    match%map read ~privkey_path ~password with","counters":[]},{"line":"    | Ok keypair ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        keypair","counters":[]},{"line":"    | Error priv_key_error ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Privkey_error.raise ~which priv_key_error","counters":[]},{"line":"","counters":[]},{"line":"  let read_exn' path =","counters":[]},{"line":"    read_exn ~privkey_path:path","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ~password:","counters":[]},{"line":"        (lazy (Password.hidden_line_or_env \"Libp2p secret key password: \" ~env))","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"include T","counters":[]},{"line":"module Terminal_stdin = Make_terminal_stdin (T)","counters":[{"col_start":46,"col_end":46,"count":2}]}]}