{"filename":"src/lib/vrf_lib/standalone.ml","lines":[{"line":"open Core","counters":[]},{"line":"","counters":[]},{"line":"module Context = struct","counters":[]},{"line":"  type ('message, 'pk) t = { message : 'message; public_key : 'pk }","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":49,"col_end":49,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"  [@@deriving sexp, hlist]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Evaluation = struct","counters":[]},{"line":"  module Discrete_log_equality = struct","counters":[]},{"line":"    module Poly = struct","counters":[]},{"line":"      [%%versioned","counters":[]},{"line":"      module Stable = struct","counters":[]},{"line":"        module V1 = struct","counters":[]},{"line":"          type 'scalar t = { c : 'scalar; s : 'scalar } [@@deriving sexp]","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":23,"col_end":23,"count":4},{"col_start":29,"col_end":29,"count":0},{"col_start":42,"col_end":42,"count":0},{"col_start":72,"col_end":72,"count":1}]},{"line":"","counters":[]},{"line":"          let to_latest = Fn.id","counters":[]},{"line":"        end","counters":[]},{"line":"      end]","counters":[]},{"line":"    end","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Poly = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type ('group, 'dleq) t =","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":29,"col_end":29,"count":5}]},{"line":"          { discrete_log_equality : 'dleq; scaled_message_hash : 'group }","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":43,"col_end":43,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"        [@@deriving sexp]","counters":[{"col_start":24,"col_end":24,"count":1}]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make","counters":[]},{"line":"    (Impl : Snarky_backendless.Snark_intf.S) (Scalar : sig","counters":[]},{"line":"      type t [@@deriving equal, sexp]","counters":[]},{"line":"","counters":[]},{"line":"      val random : unit -> t","counters":[]},{"line":"","counters":[]},{"line":"      val add : t -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"      val mul : t -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"      type var","counters":[]},{"line":"","counters":[]},{"line":"      val typ : (var, t) Impl.Typ.t","counters":[]},{"line":"","counters":[]},{"line":"      module Checked : sig","counters":[]},{"line":"        open Impl","counters":[]},{"line":"","counters":[]},{"line":"        val to_bits : var -> Boolean.var Bitstring_lib.Bitstring.Lsb_first.t","counters":[]},{"line":"","counters":[]},{"line":"        module Assert : sig","counters":[]},{"line":"          val equal : var -> var -> unit Checked.t","counters":[]},{"line":"        end","counters":[]},{"line":"      end","counters":[]},{"line":"    end) (Group : sig","counters":[]},{"line":"      type t [@@deriving sexp]","counters":[]},{"line":"","counters":[]},{"line":"      val add : t -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"      val negate : t -> t","counters":[]},{"line":"","counters":[]},{"line":"      val scale : t -> Scalar.t -> t","counters":[]},{"line":"","counters":[]},{"line":"      val generator : t","counters":[]},{"line":"","counters":[]},{"line":"      type var","counters":[]},{"line":"","counters":[]},{"line":"      val typ : (var, t) Impl.Typ.t","counters":[]},{"line":"","counters":[]},{"line":"      module Checked :","counters":[]},{"line":"        Snarky_curves.Weierstrass_checked_intf","counters":[]},{"line":"          with module Impl := Impl","counters":[]},{"line":"           and type unchecked := t","counters":[]},{"line":"           and type t = var","counters":[]},{"line":"    end) (Message : sig","counters":[]},{"line":"      open Impl","counters":[]},{"line":"","counters":[]},{"line":"      type value [@@deriving sexp]","counters":[]},{"line":"","counters":[]},{"line":"      type var","counters":[]},{"line":"","counters":[]},{"line":"      val typ : (var, value) Typ.t","counters":[]},{"line":"","counters":[]},{"line":"      (* This hash function can be merely collision-resistant *)","counters":[]},{"line":"","counters":[]},{"line":"      val hash_to_group : value -> Group.t","counters":[]},{"line":"","counters":[]},{"line":"      module Checked : sig","counters":[]},{"line":"        val hash_to_group : var -> Group.var Checked.t","counters":[]},{"line":"      end","counters":[]},{"line":"    end) (Output_hash : sig","counters":[]},{"line":"      type t","counters":[]},{"line":"","counters":[]},{"line":"      type var","counters":[]},{"line":"","counters":[]},{"line":"      (* I believe this has to be a random oracle *)","counters":[]},{"line":"","counters":[]},{"line":"      val hash : Message.value -> Group.t -> t","counters":[]},{"line":"","counters":[]},{"line":"      module Checked : sig","counters":[]},{"line":"        val hash : Message.var -> Group.var -> var Impl.Checked.t","counters":[]},{"line":"      end","counters":[]},{"line":"    end) (Hash : sig","counters":[]},{"line":"      (* I believe this has to be a random oracle *)","counters":[]},{"line":"","counters":[]},{"line":"      val hash_for_proof :","counters":[]},{"line":"        Message.value -> Group.t -> Group.t -> Group.t -> Scalar.t","counters":[]},{"line":"","counters":[]},{"line":"      module Checked : sig","counters":[]},{"line":"        val hash_for_proof :","counters":[]},{"line":"             Message.var","counters":[]},{"line":"          -> Group.var","counters":[]},{"line":"          -> Group.var","counters":[]},{"line":"          -> Group.var","counters":[]},{"line":"          -> Scalar.var Impl.Checked.t","counters":[]},{"line":"      end","counters":[]},{"line":"    end) : sig","counters":[]},{"line":"  module Public_key : sig","counters":[]},{"line":"    type t = Group.t","counters":[]},{"line":"","counters":[]},{"line":"    type var = Group.var","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Private_key : sig","counters":[]},{"line":"    type t = Scalar.t","counters":[]},{"line":"","counters":[]},{"line":"    type var = Scalar.var","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Context : sig","counters":[]},{"line":"    type t = (Message.value, Public_key.t) Context.t [@@deriving sexp]","counters":[]},{"line":"","counters":[]},{"line":"    type var = (Message.var, Public_key.var) Context.t","counters":[]},{"line":"","counters":[]},{"line":"    val typ : (var, t) Impl.Typ.t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Evaluation : sig","counters":[]},{"line":"    type t =","counters":[]},{"line":"      ( Group.t","counters":[]},{"line":"      , Scalar.t Evaluation.Discrete_log_equality.Poly.t )","counters":[]},{"line":"      Evaluation.Poly.t","counters":[]},{"line":"    [@@deriving sexp]","counters":[]},{"line":"","counters":[]},{"line":"    type var","counters":[]},{"line":"","counters":[]},{"line":"    val typ : (var, t) Impl.Typ.t","counters":[]},{"line":"","counters":[]},{"line":"    val create : Private_key.t -> Message.value -> t","counters":[]},{"line":"","counters":[]},{"line":"    val verified_output : t -> Context.t -> Output_hash.t option","counters":[]},{"line":"","counters":[]},{"line":"    module Checked : sig","counters":[]},{"line":"      val verified_output :","counters":[]},{"line":"           (module Group.Checked.Shifted.S with type t = 'shifted)","counters":[]},{"line":"        -> var","counters":[]},{"line":"        -> Context.var","counters":[]},{"line":"        -> Output_hash.var Impl.Checked.t","counters":[]},{"line":"    end","counters":[]},{"line":"  end","counters":[]},{"line":"end = struct","counters":[]},{"line":"  module Public_key = Group","counters":[]},{"line":"","counters":[]},{"line":"  module Context = struct","counters":[]},{"line":"    type t = (Message.value, Public_key.t) Context.t [@@deriving sexp]","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"    type var = (Message.var, Public_key.var) Context.t","counters":[]},{"line":"","counters":[]},{"line":"    let typ =","counters":[]},{"line":"      Impl.Typ.of_hlistable","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"        [ Message.typ; Public_key.typ ]","counters":[]},{"line":"        ~var_to_hlist:Context.to_hlist ~var_of_hlist:Context.of_hlist","counters":[]},{"line":"        ~value_to_hlist:Context.to_hlist ~value_of_hlist:Context.of_hlist","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Private_key = Scalar","counters":[]},{"line":"","counters":[]},{"line":"  module Evaluation = struct","counters":[]},{"line":"    module Discrete_log_equality = struct","counters":[]},{"line":"      type 'scalar t_ = 'scalar Evaluation.Discrete_log_equality.Poly.t =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { c : 'scalar; s : 'scalar }","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"      [@@deriving sexp, hlist]","counters":[]},{"line":"","counters":[]},{"line":"      type t = Scalar.t t_ [@@deriving sexp]","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"      type var = Scalar.var t_","counters":[]},{"line":"","counters":[]},{"line":"      open Impl","counters":[]},{"line":"","counters":[]},{"line":"      let typ : (var, t) Typ.t =","counters":[]},{"line":"        Typ.of_hlistable [ Scalar.typ; Scalar.typ ] ~var_to_hlist:t__to_hlist","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"          ~var_of_hlist:t__of_hlist ~value_to_hlist:t__to_hlist","counters":[]},{"line":"          ~value_of_hlist:t__of_hlist","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    type ('group, 'dleq) t_ = ('group, 'dleq) Evaluation.Poly.t =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      { discrete_log_equality : 'dleq; scaled_message_hash : 'group }","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"    [@@deriving sexp]","counters":[]},{"line":"","counters":[]},{"line":"    type t = (Group.t, Discrete_log_equality.t) t_ [@@deriving sexp]","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"    type var = (Group.var, Discrete_log_equality.var) t_","counters":[]},{"line":"","counters":[]},{"line":"    let typ : (var, t) Impl.Typ.t =","counters":[]},{"line":"      let open Snarky_backendless.H_list in","counters":[]},{"line":"      Impl.Typ.of_hlistable","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"        [ Discrete_log_equality.typ; Group.typ ]","counters":[]},{"line":"        ~var_to_hlist:(fun { discrete_log_equality; scaled_message_hash } ->","counters":[]},{"line":"          [ discrete_log_equality; scaled_message_hash ] )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        ~value_to_hlist:(fun { discrete_log_equality; scaled_message_hash } ->","counters":[]},{"line":"          [ discrete_log_equality; scaled_message_hash ] )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        ~value_of_hlist:(fun [ discrete_log_equality; scaled_message_hash ] ->","counters":[]},{"line":"          { discrete_log_equality; scaled_message_hash } )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        ~var_of_hlist:(fun [ discrete_log_equality; scaled_message_hash ] ->","counters":[]},{"line":"          { discrete_log_equality; scaled_message_hash } )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"    let create (k : Private_key.t) message : t =","counters":[]},{"line":"      let public_key = Group.scale Group.generator k in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let message_hash = Message.hash_to_group message in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let discrete_log_equality : Discrete_log_equality.t =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let r = Scalar.random () in","counters":[]},{"line":"        let c =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Hash.hash_for_proof message public_key","counters":[]},{"line":"            Group.(scale generator r)","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"            Group.(scale message_hash r)","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"        in","counters":[]},{"line":"        { c; s = Scalar.(add r (mul k c)) }","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"      in","counters":[]},{"line":"      { discrete_log_equality","counters":[]},{"line":"      ; scaled_message_hash = Group.scale message_hash k","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    let verified_output","counters":[]},{"line":"        ({ scaled_message_hash; discrete_log_equality = { c; s } } : t)","counters":[]},{"line":"        ({ message; public_key } : Context.t) =","counters":[]},{"line":"      let g = Group.generator in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let ( + ) = Group.add in","counters":[]},{"line":"      let ( * ) s g = Group.scale g s in","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"      let message_hash = Message.hash_to_group message in","counters":[]},{"line":"      let dleq =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Scalar.equal c","counters":[]},{"line":"          (Hash.hash_for_proof message public_key","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"             ((s * g) + (c * Group.negate public_key))","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"             ((s * message_hash) + (c * Group.negate scaled_message_hash)) )","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"      in","counters":[]},{"line":"      if dleq then Some (Output_hash.hash message scaled_message_hash) else None","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":76,"col_end":76,"count":0}]},{"line":"","counters":[]},{"line":"    module Checked = struct","counters":[]},{"line":"      let verified_output (type shifted)","counters":[]},{"line":"          ((module Shifted) as shifted :","counters":[]},{"line":"            (module Group.Checked.Shifted.S with type t = shifted) )","counters":[]},{"line":"          ({ scaled_message_hash; discrete_log_equality = { c; s } } : var)","counters":[]},{"line":"          ({ message; public_key } : Context.var) =","counters":[]},{"line":"        let open Impl.Checked in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let%bind () =","counters":[]},{"line":"          let%bind a =","counters":[]},{"line":"            (* s * g - c * public_key *)","counters":[]},{"line":"            let%bind sg =","counters":[]},{"line":"              Group.Checked.scale_known shifted Group.generator","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"                (Scalar.Checked.to_bits s) ~init:Shifted.zero","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"            in","counters":[]},{"line":"            Group.Checked.(","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              scale shifted (negate public_key) (Scalar.Checked.to_bits c)","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":70,"col_end":70,"count":0}]},{"line":"                ~init:sg)","counters":[]},{"line":"            >>= Shifted.unshift_nonzero","counters":[]},{"line":"          and b =","counters":[]},{"line":"            (* s * H(m) - c * scaled_message_hash *)","counters":[]},{"line":"            let%bind sx =","counters":[]},{"line":"              let%bind message_hash = Message.Checked.hash_to_group message in","counters":[{"col_start":66,"col_end":66,"count":0}]},{"line":"              Group.Checked.scale shifted message_hash","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (Scalar.Checked.to_bits s) ~init:Shifted.zero","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"            in","counters":[]},{"line":"            Group.Checked.(","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              scale shifted","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                (negate scaled_message_hash)","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                (Scalar.Checked.to_bits c) ~init:sx)","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"            >>= Shifted.unshift_nonzero","counters":[]},{"line":"          in","counters":[]},{"line":"          Hash.Checked.hash_for_proof message public_key a b","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"          >>= Scalar.Checked.Assert.equal c","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"        in","counters":[]},{"line":"        (* TODO: This could just hash (message_hash, message_hash^k) instead","counters":[]},{"line":"           if it were cheaper *)","counters":[]},{"line":"        Output_hash.Checked.hash message scaled_message_hash","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    end","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"open Core","counters":[]},{"line":"","counters":[]},{"line":"module Bigint_scalar","counters":[]},{"line":"    (Impl : Snarky_backendless.Snark_intf.S) (M : sig","counters":[]},{"line":"      val modulus : Bigint.t","counters":[]},{"line":"","counters":[]},{"line":"      val random : unit -> Bigint.t","counters":[]},{"line":"    end) =","counters":[]},{"line":"struct","counters":[]},{"line":"  let pack bs =","counters":[]},{"line":"    let pack_char bs =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Char.of_int_exn","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (List.foldi bs ~init:0 ~f:(fun i acc b ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"             if b then acc lor (1 lsl i) else acc ) )","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"    in","counters":[]},{"line":"    String.of_char_list (List.map ~f:pack_char (List.chunks_of ~length:8 bs))","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"    |> Z.of_bits |> Bigint.of_zarith_bigint","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"","counters":[]},{"line":"  include Bigint","counters":[]},{"line":"  include M","counters":[]},{"line":"","counters":[]},{"line":"  let gen = gen_incl zero (modulus - one)","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"","counters":[]},{"line":"  let test_bit t i = shift_right t i land one = one","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"","counters":[]},{"line":"  let add x y =","counters":[]},{"line":"    let z = x + y in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    if z < modulus then z else z - modulus","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"","counters":[]},{"line":"  let%test_unit \"add is correct\" =","counters":[]},{"line":"    Quickcheck.test (Quickcheck.Generator.tuple2 gen gen) ~f:(fun (x, y) ->","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"        assert (equal (add x y) ((x + y) % modulus)) )","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"","counters":[]},{"line":"  let mul x y = x * y % modulus","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"","counters":[]},{"line":"  let length_in_bits = Z.log2up (Bigint.to_zarith_bigint (modulus - one))","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"","counters":[]},{"line":"  let to_bits n = List.init length_in_bits ~f:(test_bit n)","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"","counters":[]},{"line":"  let of_bits bs =","counters":[]},{"line":"    List.fold_left bs ~init:(zero, one) ~f:(fun (acc, pt) b ->","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"        ((if b then add acc pt else acc), add pt pt) )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"    |> fst","counters":[]},{"line":"","counters":[]},{"line":"  let%test_unit \"of_bits . to_bits = identity\" =","counters":[]},{"line":"    Quickcheck.test gen ~f:(fun x -> assert (equal x (of_bits (to_bits x))))","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":49,"col_end":49,"count":0},{"col_start":60,"col_end":60,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"","counters":[]},{"line":"  open Impl","counters":[]},{"line":"","counters":[]},{"line":"  type var = Boolean.var list","counters":[]},{"line":"","counters":[]},{"line":"  let typ : (var, t) Typ.t =","counters":[]},{"line":"    let open Typ in","counters":[]},{"line":"    transport","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"      (list ~length:length_in_bits Boolean.typ)","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"      ~there:(fun n ->","counters":[]},{"line":"        List.init length_in_bits ~f:(Z.testbit (to_zarith_bigint n)) )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"      ~back:pack","counters":[]},{"line":"","counters":[]},{"line":"  module Checked = struct","counters":[]},{"line":"    let equal = Bitstring_checked.equal","counters":[]},{"line":"","counters":[]},{"line":"    module Assert = struct","counters":[]},{"line":"      let equal = Bitstring_checked.Assert.equal","counters":[]},{"line":"    end","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}