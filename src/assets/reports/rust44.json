{"filename":"src/staged_ledger/hash.rs","lines":[{"line":"use ark_ff::{PrimeField, ToBytes};","counters":[]},{"line":"use mina_hasher::Fp;","counters":[]},{"line":"use sha2::{Digest, Sha256};","counters":[]},{"line":"","counters":[]},{"line":"use crate::{scan_state::pending_coinbase::PendingCoinbase, ToInputs};","counters":[]},{"line":"","counters":[]},{"line":"/// Convert to/from OCaml strings, such as","counters":[]},{"line":"/// \"u~\\218kzX\\228$\\027qG\\239\\135\\255:\\143\\171\\186\\011\\200P\\243\\163\\135\\223T>\\017\\172\\254\\1906\"","counters":[]},{"line":"pub trait OCamlString {","counters":[]},{"line":"    fn to_ocaml_str(&self) -> String;","counters":[]},{"line":"    fn from_ocaml_str(s: &str) -> Self;","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl<const N: usize> OCamlString for [u8; N] {","counters":[]},{"line":"    fn to_ocaml_str(&self) -> String {","counters":[{"col_start":4,"col_end":38,"count":0}]},{"line":"        to_ocaml_str(self)","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn from_ocaml_str(s: &str) -> Self {","counters":[]},{"line":"        from_ocaml_str(s)","counters":[]},{"line":"    }","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"pub fn to_ocaml_str(bytes: &[u8]) -> String {","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"    let mut s = String::with_capacity(256);","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"","counters":[]},{"line":"    for b in bytes {","counters":[{"col_start":8,"col_end":9,"count":0},{"col_start":13,"col_end":18,"count":0}]},{"line":"        let c = char::from(*b);","counters":[{"col_start":12,"col_end":31,"count":0}]},{"line":"        if c == '\\\\' {","counters":[{"col_start":0,"col_end":20,"count":0},{"col_start":21,"col_end":22,"count":0}]},{"line":"            s.push_str(\"\\\\\\\\\");","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"        } else if c.is_ascii() && !c.is_ascii_control() {","counters":[{"col_start":0,"col_end":9,"count":0},{"col_start":18,"col_end":30,"count":0},{"col_start":34,"col_end":55,"count":0},{"col_start":56,"col_end":57,"count":0}]},{"line":"            s.push(c);","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"        } else {","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"            match b {","counters":[{"col_start":18,"col_end":19,"count":0}]},{"line":"                7 => s.push_str(r\"\\a\"),","counters":[{"col_start":21,"col_end":38,"count":0}]},{"line":"                8 => s.push_str(r\"\\b\"),","counters":[{"col_start":21,"col_end":38,"count":0}]},{"line":"                9 => s.push_str(r\"\\t\"),","counters":[{"col_start":21,"col_end":38,"count":0}]},{"line":"                10 => s.push_str(r\"\\n\"),","counters":[{"col_start":22,"col_end":39,"count":0}]},{"line":"                // 11 => s.push_str(r\"\\v\"),","counters":[]},{"line":"                12 => s.push_str(r\"\\f\"),","counters":[{"col_start":22,"col_end":39,"count":0}]},{"line":"                13 => s.push_str(r\"\\r\"),","counters":[{"col_start":22,"col_end":39,"count":0}]},{"line":"                _ => s.push_str(&format!(\"\\\\{:<03}\", b)),","counters":[{"col_start":21,"col_end":56,"count":0}]},{"line":"            }","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    s","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"pub fn from_ocaml_str<const N: usize>(s: &str) -> [u8; N] {","counters":[{"col_start":0,"col_end":59,"count":0}]},{"line":"    let mut bytes = [0; N];","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"    let mut b_index = 0;","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"","counters":[]},{"line":"    let mut index = 0;","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"    let s = s.as_bytes();","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"    while index < s.len() {","counters":[{"col_start":10,"col_end":25,"count":26}]},{"line":"        if s[index] == b'\\\\' {","counters":[{"col_start":11,"col_end":28,"count":26}]},{"line":"            if s.get(index + 1).map(|next| *next == b'\\\\').unwrap_or(false) {","counters":[{"col_start":15,"col_end":36,"count":26},{"col_start":43,"col_end":57,"count":0},{"col_start":57,"col_end":75,"count":26},{"col_start":76,"col_end":77,"count":13}]},{"line":"                bytes[b_index] = b'\\\\';","counters":[{"col_start":0,"col_end":39,"count":13}]},{"line":"                index += 2;","counters":[{"col_start":0,"col_end":27,"count":13}]},{"line":"            } else if s","counters":[{"col_start":0,"col_end":13,"count":13},{"col_start":22,"col_end":23,"count":13}]},{"line":"                .get(index + 1)","counters":[{"col_start":0,"col_end":31,"count":13}]},{"line":"                .map(|next| \"abtnfr\".contains(char::from(*next)))","counters":[{"col_start":0,"col_end":21,"count":13},{"col_start":28,"col_end":64,"count":0},{"col_start":64,"col_end":65,"count":13}]},{"line":"                // .map(|next| \"abtnvfr\".contains(char::from(*next)))","counters":[{"col_start":0,"col_end":69,"count":13}]},{"line":"                .unwrap_or(false)","counters":[{"col_start":0,"col_end":33,"count":13}]},{"line":"            {","counters":[{"col_start":12,"col_end":13,"count":13}]},{"line":"                bytes[b_index] = match s[index + 1] {","counters":[{"col_start":0,"col_end":30,"count":13},{"col_start":39,"col_end":51,"count":13}]},{"line":"                    b'a' => 7,","counters":[{"col_start":28,"col_end":29,"count":0}]},{"line":"                    b'b' => 8,","counters":[{"col_start":28,"col_end":29,"count":0}]},{"line":"                    b't' => 9,","counters":[{"col_start":28,"col_end":29,"count":0}]},{"line":"                    b'n' => 10,","counters":[{"col_start":28,"col_end":30,"count":0}]},{"line":"                    // b'v' => 11,","counters":[]},{"line":"                    b'f' => 12,","counters":[{"col_start":28,"col_end":30,"count":13}]},{"line":"                    b'r' => 13,","counters":[{"col_start":28,"col_end":30,"count":0}]},{"line":"                    _ => unreachable!(),","counters":[{"col_start":25,"col_end":39,"count":0}]},{"line":"                };","counters":[]},{"line":"                index += 2;","counters":[{"col_start":16,"col_end":26,"count":13}]},{"line":"            } else {","counters":[{"col_start":19,"col_end":20,"count":0}]},{"line":"                let n1 = s[index + 1] - b'0';","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"                let n2 = s[index + 2] - b'0';","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"                let n3 = s[index + 3] - b'0';","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"                bytes[b_index] = (n1 * 100) + (n2 * 10) + n3;","counters":[{"col_start":0,"col_end":61,"count":0}]},{"line":"                index += 4;","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"            }","counters":[{"col_start":0,"col_end":13,"count":0}]},{"line":"        } else {","counters":[{"col_start":15,"col_end":16,"count":0}]},{"line":"            bytes[b_index] = s[index];","counters":[{"col_start":0,"col_end":38,"count":0}]},{"line":"            index += 1;","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"        b_index += 1;","counters":[{"col_start":8,"col_end":20,"count":26}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    bytes","counters":[{"col_start":4,"col_end":9,"count":0}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"/// https://github.com/MinaProtocol/mina/blob/3fe924c80a4d01f418b69f27398f5f93eb652514/src/lib/mina_base/staged_ledger_hash.ml#L27","counters":[]},{"line":"#[derive(PartialEq, Eq)]","counters":[]},{"line":"pub struct AuxHash(pub [u8; 32]);","counters":[]},{"line":"","counters":[]},{"line":"impl std::fmt::Debug for AuxHash {","counters":[]},{"line":"    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {","counters":[{"col_start":4,"col_end":72,"count":0}]},{"line":"        f.write_fmt(format_args!(\"AuxHash({})\", self.to_ocaml_str()))","counters":[{"col_start":0,"col_end":69,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl AuxHash {","counters":[]},{"line":"    fn to_ocaml_str(&self) -> String {","counters":[{"col_start":4,"col_end":38,"count":0}]},{"line":"        to_ocaml_str(&self.0)","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn from_ocaml_str(s: &str) -> Self {","counters":[]},{"line":"        Self(from_ocaml_str(s))","counters":[]},{"line":"    }","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"/// https://github.com/MinaProtocol/mina/blob/3fe924c80a4d01f418b69f27398f5f93eb652514/src/lib/mina_base/staged_ledger_hash.ml#L110","counters":[]},{"line":"#[derive(PartialEq, Eq)]","counters":[]},{"line":"pub struct PendingCoinbaseAux(pub [u8; 32]);","counters":[]},{"line":"","counters":[]},{"line":"impl std::fmt::Debug for PendingCoinbaseAux {","counters":[]},{"line":"    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {","counters":[{"col_start":4,"col_end":72,"count":0}]},{"line":"        f.write_fmt(format_args!(\"PendingCoinbaseAux({})\", self.to_ocaml_str()))","counters":[{"col_start":0,"col_end":80,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl PendingCoinbaseAux {","counters":[]},{"line":"    fn to_ocaml_str(&self) -> String {","counters":[{"col_start":4,"col_end":38,"count":0}]},{"line":"        to_ocaml_str(&self.0)","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn from_ocaml_str(s: &str) -> Self {","counters":[]},{"line":"        Self(from_ocaml_str(s))","counters":[]},{"line":"    }","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"/// https://github.com/MinaProtocol/mina/blob/3fe924c80a4d01f418b69f27398f5f93eb652514/src/lib/mina_base/staged_ledger_hash.ml#L152","counters":[]},{"line":"#[derive(Debug, PartialEq, Eq)]","counters":[{"col_start":9,"col_end":14,"count":0}]},{"line":"pub struct NonStark {","counters":[]},{"line":"    ledger_hash: Fp,","counters":[]},{"line":"    aux_hash: AuxHash,","counters":[]},{"line":"    pending_coinbase_aux: PendingCoinbaseAux,","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl NonStark {","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3fe924c80a4d01f418b69f27398f5f93eb652514/src/lib/mina_base/staged_ledger_hash.ml#L182","counters":[]},{"line":"    pub fn digest(&self) -> [u8; 32] {","counters":[{"col_start":4,"col_end":38,"count":0}]},{"line":"        let Self {","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"            ledger_hash,","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"            aux_hash,","counters":[{"col_start":0,"col_end":21,"count":0}]},{"line":"            pending_coinbase_aux,","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"        } = self;","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"","counters":[]},{"line":"        let mut sha: Sha256 = Sha256::new();","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"        let mut ledger_hash_bytes: [u8; 32] = <[u8; 32]>::default();","counters":[{"col_start":0,"col_end":68,"count":0}]},{"line":"","counters":[]},{"line":"        let ledger_hash = ledger_hash.into_repr();","counters":[{"col_start":0,"col_end":50,"count":0}]},{"line":"        ledger_hash.write(ledger_hash_bytes.as_mut_slice()).unwrap();","counters":[{"col_start":0,"col_end":69,"count":0}]},{"line":"        ledger_hash_bytes.reverse();","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"","counters":[]},{"line":"        sha.update(ledger_hash_bytes.as_slice());","counters":[{"col_start":0,"col_end":49,"count":0}]},{"line":"        sha.update(aux_hash.0.as_slice());","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":"        sha.update(pending_coinbase_aux.0.as_slice());","counters":[{"col_start":0,"col_end":54,"count":0}]},{"line":"","counters":[]},{"line":"        sha.finalize().into()","counters":[{"col_start":0,"col_end":29,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl ToInputs for NonStark {","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3fe924c80a4d01f418b69f27398f5f93eb652514/src/lib/mina_base/staged_ledger_hash.ml#L193","counters":[]},{"line":"    fn to_inputs(&self, inputs: &mut crate::Inputs) {","counters":[{"col_start":4,"col_end":53,"count":0}]},{"line":"        let digest = self.digest();","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"        inputs.append_bytes(digest.as_slice());","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"/// Staged ledger hash has two parts","counters":[]},{"line":"///","counters":[]},{"line":"/// 1) merkle root of the pending coinbases","counters":[]},{"line":"/// 2) ledger hash, aux hash, and the FIFO order of the coinbase stacks(Non snark).","counters":[]},{"line":"///","counters":[]},{"line":"/// Only part 1 is required for blockchain snark computation and therefore the","counters":[]},{"line":"/// remaining fields of the staged ledger are grouped together as \"Non_snark\"","counters":[]},{"line":"///","counters":[]},{"line":"/// https://github.com/MinaProtocol/mina/blob/3fe924c80a4d01f418b69f27398f5f93eb652514/src/lib/mina_base/staged_ledger_hash.ml#L259","counters":[]},{"line":"#[derive(Debug, PartialEq, Eq)]","counters":[{"col_start":9,"col_end":14,"count":0}]},{"line":"pub struct StagedLedgerHash {","counters":[]},{"line":"    non_snark: NonStark,","counters":[]},{"line":"    pending_coinbase_hash: Fp,","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl StagedLedgerHash {","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3fe924c80a4d01f418b69f27398f5f93eb652514/src/lib/mina_base/staged_ledger_hash.ml#L290","counters":[]},{"line":"    pub fn of_aux_ledger_and_coinbase_hash(","counters":[{"col_start":4,"col_end":43,"count":0}]},{"line":"        aux_hash: AuxHash,","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"        ledger_hash: Fp,","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"        pending_coinbase: &mut PendingCoinbase,","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"    ) -> Self {","counters":[{"col_start":0,"col_end":15,"count":0}]},{"line":"        Self {","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"            non_snark: NonStark {","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"                ledger_hash,","counters":[{"col_start":0,"col_end":28,"count":0}]},{"line":"                aux_hash,","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"                pending_coinbase_aux: pending_coinbase.hash_extra(),","counters":[{"col_start":0,"col_end":68,"count":0}]},{"line":"            },","counters":[{"col_start":0,"col_end":14,"count":0}]},{"line":"            pending_coinbase_hash: pending_coinbase.merkle_root(),","counters":[{"col_start":0,"col_end":66,"count":0}]},{"line":"        }","counters":[{"col_start":0,"col_end":9,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    /// Used for tests only","counters":[]},{"line":"    #[cfg(test)]","counters":[]},{"line":"    pub fn from_ocaml_strings(","counters":[]},{"line":"        ledger_hash: &str,","counters":[]},{"line":"        aux_hash: &str,","counters":[]},{"line":"        pending_coinbase_aux: &str,","counters":[]},{"line":"        pending_coinbase_hash: &str,","counters":[]},{"line":"    ) -> Self {","counters":[]},{"line":"        use std::str::FromStr;","counters":[]},{"line":"","counters":[]},{"line":"        Self {","counters":[]},{"line":"            non_snark: NonStark {","counters":[]},{"line":"                ledger_hash: Fp::from_str(ledger_hash).unwrap(),","counters":[]},{"line":"                aux_hash: AuxHash::from_ocaml_str(aux_hash),","counters":[]},{"line":"                pending_coinbase_aux: PendingCoinbaseAux::from_ocaml_str(pending_coinbase_aux),","counters":[]},{"line":"            },","counters":[]},{"line":"            pending_coinbase_hash: Fp::from_str(pending_coinbase_hash).unwrap(),","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl ToInputs for StagedLedgerHash {","counters":[]},{"line":"    fn to_inputs(&self, inputs: &mut crate::Inputs) {","counters":[{"col_start":4,"col_end":53,"count":0}]},{"line":"        let Self {","counters":[{"col_start":0,"col_end":18,"count":0}]},{"line":"            non_snark,","counters":[{"col_start":0,"col_end":22,"count":0}]},{"line":"            pending_coinbase_hash,","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"        } = self;","counters":[{"col_start":0,"col_end":17,"count":0}]},{"line":"","counters":[]},{"line":"        inputs.append(non_snark);","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"        inputs.append(pending_coinbase_hash);","counters":[{"col_start":0,"col_end":45,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"#[cfg(test)]","counters":[]},{"line":"mod tests {","counters":[]},{"line":"    use std::str::FromStr;","counters":[]},{"line":"","counters":[]},{"line":"    #[cfg(target_family = \"wasm\")]","counters":[]},{"line":"    use wasm_bindgen_test::wasm_bindgen_test as test;","counters":[]},{"line":"","counters":[]},{"line":"    use super::*;","counters":[]},{"line":"","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn test_convert() {","counters":[]},{"line":"        // stage_ledger_hash=StagedLedgerHash {","counters":[]},{"line":"        //     non_snark: NonStark {","counters":[]},{"line":"        //         ledger_hash: Fp(7213023165825031994332898585791275635753820608093286100176380057570051468967),","counters":[]},{"line":"        //         aux_hash: AuxHash(\\\\\\249\\245k\\176]TJ\\216\\183\\001\\204\\177\\131\\030\\244o\\178\\188\\191US\\156\\192Hi\\194P\\223\\004\\000\\003),","counters":[]},{"line":"        //         pending_coinbase_aux: PendingCoinbaseAux(\\\\\\236\\235f\\255\\200o8\\217Rxlmily\\194\\219\\1949\\221N\\145\\180g)\\215:'\\251W\\233),","counters":[]},{"line":"        //     },","counters":[]},{"line":"        //     pending_coinbase_hash: Fp(25504365445533103805898245102289650498571312278321176071043666991586378788150),","counters":[]},{"line":"        // }","counters":[]},{"line":"","counters":[]},{"line":"        let s = r\"\\\\\\236\\235f\\255\\200o8\\217Rxlmily\\194\\219\\1949\\221N\\145\\180g)\\215:'\\251W\\233\";","counters":[]},{"line":"        let pending_coinbase_aux = PendingCoinbaseAux::from_ocaml_str(s);","counters":[]},{"line":"        assert_eq!(s, pending_coinbase_aux.to_ocaml_str());","counters":[]},{"line":"","counters":[]},{"line":"        let s = r\"\\\\\\249\\245k\\176]TJ\\216\\183\\001\\204\\177\\131\\030\\244o\\178\\188\\191US\\156\\192Hi\\194P\\223\\004\\000\\003\";","counters":[]},{"line":"        let aux_hash = AuxHash::from_ocaml_str(s);","counters":[]},{"line":"        assert_eq!(s, aux_hash.to_ocaml_str());","counters":[]},{"line":"","counters":[]},{"line":"        // non_snark digest=\"\\t\\204S\\160F\\227\\022\\142\\146\\172\\220.R'\\222L&b\\191\\138;\\022\\235\\137\\190>\\205.\\031\\195-\\231\"","counters":[]},{"line":"        // digest=9,204,83,160,70,227,22,142,146,172,220,46,82,39,222,76,38,98,191,138,59,22,235,137,190,62,205,46,31,195,45,231","counters":[]},{"line":"","counters":[]},{"line":"        let a = AuxHash([","counters":[]},{"line":"            9, 204, 83, 160, 70, 227, 22, 142, 146, 172, 220, 46, 82, 39, 222, 76, 38, 98, 191,","counters":[]},{"line":"            138, 59, 22, 235, 137, 190, 62, 205, 46, 31, 195, 45, 231,","counters":[]},{"line":"        ]);","counters":[]},{"line":"","counters":[]},{"line":"        println!(\"a={}\", a.to_ocaml_str());","counters":[]},{"line":"","counters":[]},{"line":"        let s = r\"\\t\\204S\\160F\\227\\022\\142\\146\\172\\220.R'\\222L&b\\191\\138;\\022\\235\\137\\190>\\205.\\031\\195-\\231\";","counters":[]},{"line":"        assert_eq!(s, a.to_ocaml_str());","counters":[]},{"line":"        let aux_hash = AuxHash::from_ocaml_str(s);","counters":[]},{"line":"        assert_eq!(s, aux_hash.to_ocaml_str());","counters":[]},{"line":"","counters":[]},{"line":"        let s = r\"\\000 \\014WQ\\192&\\229C\\178\\232\\171.\\176`\\153\\218\\161\\209\\229\\223Gw\\143w\\135\\250\\171E\\205\\241/\\227\\168\";","counters":[]},{"line":"        let memo = <[u8; 34]>::from_ocaml_str(s);","counters":[]},{"line":"        assert_eq!(s, memo.to_ocaml_str());","counters":[]},{"line":"","counters":[]},{"line":"        // let bytes = [10,220,211,153,14,65,191,6,19,231,47,244,155,5,212,131,48,124,227,133,176,79,196,131,23,116,152,178,130,63,206,85];","counters":[]},{"line":"","counters":[]},{"line":"        // let s = bytes.to_ocaml_str();","counters":[]},{"line":"        // println!(\"s='{}'\", s);","counters":[]},{"line":"","counters":[]},{"line":"        let s = r\"\\n\\220\\211\\153\\014A\\191\\006\\019\\231/\\244\\155\\005\\212\\1310|\\227\\133\\176O\\196\\131\\023t\\152\\178\\130?\\206U\";","counters":[]},{"line":"        let pending_coinbase_aux = PendingCoinbaseAux::from_ocaml_str(s);","counters":[]},{"line":"        assert_eq!(s, pending_coinbase_aux.to_ocaml_str());","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn test_non_snark_digest() {","counters":[]},{"line":"        // ((non_snark","counters":[]},{"line":"        //   ((ledger_hash","counters":[]},{"line":"        //     7213023165825031994332898585791275635753820608093286100176380057570051468967)","counters":[]},{"line":"        //    (aux_hash","counters":[]},{"line":"        //     \"T\\249\\245k\\176]TJ\\216\\183\\001\\204\\177\\131\\030\\244o\\178\\188\\191US\\156\\192Hi\\194P\\223\\004\\000\\003\")","counters":[]},{"line":"        //    (pending_coinbase_aux","counters":[]},{"line":"        //     \"_\\236\\235f\\255\\200o8\\217Rxlmily\\194\\219\\1949\\221N\\145\\180g)\\215:'\\251W\\233\")))","counters":[]},{"line":"","counters":[]},{"line":"        let non_snark = NonStark {","counters":[]},{"line":"            ledger_hash: Fp::from_str(","counters":[]},{"line":"                \"7213023165825031994332898585791275635753820608093286100176380057570051468967\",","counters":[]},{"line":"            )","counters":[]},{"line":"            .unwrap(),","counters":[]},{"line":"            aux_hash: AuxHash::from_ocaml_str(","counters":[]},{"line":"                r\"T\\249\\245k\\176]TJ\\216\\183\\001\\204\\177\\131\\030\\244o\\178\\188\\191US\\156\\192Hi\\194P\\223\\004\\000\\003\",","counters":[]},{"line":"            ),","counters":[]},{"line":"            pending_coinbase_aux: PendingCoinbaseAux::from_ocaml_str(","counters":[]},{"line":"                r\"_\\236\\235f\\255\\200o8\\217Rxlmily\\194\\219\\1949\\221N\\145\\180g)\\215:'\\251W\\233\",","counters":[]},{"line":"            ),","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        assert_eq!(","counters":[]},{"line":"            non_snark.digest().to_ocaml_str(),","counters":[]},{"line":"            r\"\\t\\204S\\160F\\227\\022\\142\\146\\172\\220.R'\\222L&b\\191\\138;\\022\\235\\137\\190>\\205.\\031\\195-\\231\"","counters":[]},{"line":"        );","counters":[]},{"line":"","counters":[]},{"line":"        // non_snark=((ledger_hash","counters":[]},{"line":"        //   18582860218764414485081234471609377222894570081548691702645303871998665679024)","counters":[]},{"line":"        //  (aux_hash","counters":[]},{"line":"        //   \"0\\136Wg\\182DbX\\203kLi\\212%\\199\\206\\142#\\213`L\\160bpCB\\1413\\240\\193\\171K\")","counters":[]},{"line":"        //  (pending_coinbase_aux","counters":[]},{"line":"        //    \"\\","counters":[]},{"line":"        //   \\n\\220\\211\\153\\014A\\191\\006\\019\\231/\\244\\155\\005\\212\\1310|\\227\\133\\176O\\196\\131\\023t\\152\\178\\130?\\206U\"))","counters":[]},{"line":"","counters":[]},{"line":"        let non_snark = NonStark {","counters":[]},{"line":"            ledger_hash: Fp::from_str(","counters":[]},{"line":"                \"18582860218764414485081234471609377222894570081548691702645303871998665679024\",","counters":[]},{"line":"            )","counters":[]},{"line":"            .unwrap(),","counters":[]},{"line":"            aux_hash: AuxHash::from_ocaml_str(","counters":[]},{"line":"                r\"0\\136Wg\\182DbX\\203kLi\\212%\\199\\206\\142#\\213`L\\160bpCB\\1413\\240\\193\\171K\",","counters":[]},{"line":"            ),","counters":[]},{"line":"            pending_coinbase_aux: PendingCoinbaseAux::from_ocaml_str(","counters":[]},{"line":"                r\"\\n\\220\\211\\153\\014A\\191\\006\\019\\231/\\244\\155\\005\\212\\1310|\\227\\133\\176O\\196\\131\\023t\\152\\178\\130?\\206U\",","counters":[]},{"line":"            ),","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        assert_eq!(","counters":[]},{"line":"            non_snark.digest().to_ocaml_str(),","counters":[]},{"line":"            r\"u~\\218kzX\\228$\\027qG\\239\\135\\255:\\143\\171\\186\\011\\200P\\243\\163\\135\\223T>\\017\\172\\254\\1906\",","counters":[]},{"line":"        );","counters":[]},{"line":"    }","counters":[]},{"line":"}","counters":[]}]}