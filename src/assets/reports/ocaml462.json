{"filename":"src/lib/transaction_snark/transaction_snark.ml","lines":[{"line":"open Core","counters":[]},{"line":"open Signature_lib","counters":[]},{"line":"open Mina_base","counters":[]},{"line":"open Mina_transaction","counters":[]},{"line":"open Mina_state","counters":[]},{"line":"open Snark_params","counters":[]},{"line":"module Global_slot = Mina_numbers.Global_slot","counters":[]},{"line":"open Currency","counters":[]},{"line":"open Pickles_types","counters":[]},{"line":"module Wire_types = Mina_wire_types.Transaction_snark","counters":[]},{"line":"","counters":[]},{"line":"module Make_sig (A : Wire_types.Types.S) = struct","counters":[]},{"line":"  module type S =","counters":[]},{"line":"    Transaction_snark_intf.Full","counters":[]},{"line":"      with type ( 'ledger_hash","counters":[]},{"line":"                , 'amount","counters":[]},{"line":"                , 'pending_coinbase","counters":[]},{"line":"                , 'fee_excess","counters":[]},{"line":"                , 'sok_digest","counters":[]},{"line":"                , 'local_state )","counters":[]},{"line":"                Statement.Poly.Stable.V2.t =","counters":[]},{"line":"        ( 'ledger_hash","counters":[]},{"line":"        , 'amount","counters":[]},{"line":"        , 'pending_coinbase","counters":[]},{"line":"        , 'fee_excess","counters":[]},{"line":"        , 'sok_digest","counters":[]},{"line":"        , 'local_state )","counters":[]},{"line":"        A.Statement.Poly.V2.t","counters":[]},{"line":"       and type Stable.V2.t = A.V2.t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make_str (A : Wire_types.Concrete) = struct","counters":[]},{"line":"  module Impl = Pickles.Impls.Step","counters":[]},{"line":"  module Ledger = Mina_ledger.Ledger","counters":[]},{"line":"  module Sparse_ledger = Mina_ledger.Sparse_ledger","counters":[]},{"line":"  module Transaction_validator = Transaction_validator","counters":[]},{"line":"","counters":[]},{"line":"  let top_hash_logging_enabled = ref false","counters":[]},{"line":"","counters":[]},{"line":"  let to_preunion (t : Transaction.t) =","counters":[]},{"line":"    match t with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Command (Signed_command x) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        `Transaction (Transaction.Command x)","counters":[]},{"line":"    | Fee_transfer x ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        `Transaction (Fee_transfer x)","counters":[]},{"line":"    | Coinbase x ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        `Transaction (Coinbase x)","counters":[]},{"line":"    | Command (Zkapp_command x) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        `Zkapp_command x","counters":[]},{"line":"","counters":[]},{"line":"  let with_top_hash_logging f =","counters":[]},{"line":"    let old = !top_hash_logging_enabled in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    top_hash_logging_enabled := true ;","counters":[]},{"line":"    try","counters":[]},{"line":"      let ret = f () in","counters":[]},{"line":"      top_hash_logging_enabled := old ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      ret","counters":[]},{"line":"    with err ->","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"      top_hash_logging_enabled := old ;","counters":[]},{"line":"      raise err","counters":[]},{"line":"","counters":[]},{"line":"  module Proof_type = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type t = [ `Base | `Merge ]","counters":[{"col_start":8,"col_end":8,"count":2},{"col_start":13,"col_end":13,"count":1},{"col_start":17,"col_end":17,"count":0}]},{"line":"        [@@deriving compare, equal, hash, sexp, yojson]","counters":[{"col_start":54,"col_end":54,"count":5}]},{"line":"","counters":[]},{"line":"        let to_latest = Fn.id","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Pending_coinbase_stack_state = struct","counters":[]},{"line":"    module Init_stack = struct","counters":[]},{"line":"      [%%versioned","counters":[]},{"line":"      module Stable = struct","counters":[]},{"line":"        module V1 = struct","counters":[]},{"line":"          type t =","counters":[{"col_start":10,"col_end":10,"count":2},{"col_start":15,"col_end":15,"count":2}]},{"line":"            | Base of Pending_coinbase.Stack_versioned.Stable.V1.t","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"            | Merge","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          [@@deriving sexp, hash, compare, equal, yojson]","counters":[{"col_start":56,"col_end":56,"count":5}]},{"line":"","counters":[]},{"line":"          let to_latest = Fn.id","counters":[]},{"line":"        end","counters":[]},{"line":"      end]","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Poly = struct","counters":[]},{"line":"      [%%versioned","counters":[]},{"line":"      module Stable = struct","counters":[]},{"line":"        module V1 = struct","counters":[]},{"line":"          type 'pending_coinbase t =","counters":[{"col_start":10,"col_end":10,"count":1},{"col_start":33,"col_end":33,"count":4}]},{"line":"            { source : 'pending_coinbase; target : 'pending_coinbase }","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":42,"col_end":42,"count":0},{"col_start":47,"col_end":47,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"          [@@deriving sexp, hash, compare, equal, fields, yojson, hlist]","counters":[{"col_start":71,"col_end":71,"count":3}]},{"line":"","counters":[]},{"line":"          let to_latest pending_coinbase { source; target } =","counters":[]},{"line":"            { source = pending_coinbase source","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"            ; target = pending_coinbase target","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"            }","counters":[]},{"line":"        end","counters":[]},{"line":"      end]","counters":[]},{"line":"","counters":[]},{"line":"      let typ pending_coinbase =","counters":[]},{"line":"        Tick.Typ.of_hlistable","counters":[{"col_start":8,"col_end":8,"count":1}]},{"line":"          [ pending_coinbase; pending_coinbase ]","counters":[]},{"line":"          ~var_to_hlist:to_hlist ~var_of_hlist:of_hlist ~value_to_hlist:to_hlist","counters":[]},{"line":"          ~value_of_hlist:of_hlist","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    type 'pending_coinbase poly = 'pending_coinbase Poly.t =","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"      { source : 'pending_coinbase; target : 'pending_coinbase }","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"    [@@deriving sexp, hash, compare, equal, fields, yojson]","counters":[]},{"line":"","counters":[]},{"line":"    (* State of the coinbase stack for the current transaction snark *)","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type t = Pending_coinbase.Stack_versioned.Stable.V1.t Poly.Stable.V1.t","counters":[{"col_start":8,"col_end":8,"count":2},{"col_start":13,"col_end":13,"count":1},{"col_start":17,"col_end":17,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"        [@@deriving sexp, hash, compare, equal, yojson]","counters":[{"col_start":54,"col_end":54,"count":5}]},{"line":"","counters":[]},{"line":"        let to_latest = Fn.id","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    type var = Pending_coinbase.Stack.var Poly.t","counters":[]},{"line":"","counters":[]},{"line":"    let typ = Poly.typ Pending_coinbase.Stack.typ","counters":[{"col_start":21,"col_end":21,"count":1}]},{"line":"","counters":[]},{"line":"    let to_input ({ source; target } : t) =","counters":[]},{"line":"      Random_oracle.Input.Chunked.append","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (Pending_coinbase.Stack.to_input source)","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"        (Pending_coinbase.Stack.to_input target)","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"    let var_to_input ({ source; target } : var) =","counters":[]},{"line":"      Random_oracle.Input.Chunked.append","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (Pending_coinbase.Stack.var_to_input source)","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"        (Pending_coinbase.Stack.var_to_input target)","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"","counters":[]},{"line":"    include Hashable.Make_binable (Stable.Latest)","counters":[]},{"line":"    include Comparable.Make (Stable.Latest)","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Statement = struct","counters":[]},{"line":"    module Poly = struct","counters":[]},{"line":"      [%%versioned","counters":[]},{"line":"      module Stable = struct","counters":[]},{"line":"        module V2 = struct","counters":[]},{"line":"          type ( 'ledger_hash","counters":[{"col_start":10,"col_end":10,"count":2}]},{"line":"               , 'amount","counters":[]},{"line":"               , 'pending_coinbase","counters":[]},{"line":"               , 'fee_excess","counters":[]},{"line":"               , 'sok_digest","counters":[]},{"line":"               , 'local_state )","counters":[]},{"line":"               t =","counters":[{"col_start":15,"col_end":15,"count":9}]},{"line":"                ( 'ledger_hash","counters":[]},{"line":"                , 'amount","counters":[]},{"line":"                , 'pending_coinbase","counters":[]},{"line":"                , 'fee_excess","counters":[]},{"line":"                , 'sok_digest","counters":[]},{"line":"                , 'local_state )","counters":[]},{"line":"                A.Statement.Poly.V2.t =","counters":[]},{"line":"            { source :","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"                ( 'ledger_hash","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"                , 'pending_coinbase","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                , 'local_state )","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                Registers.Stable.V1.t","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"            ; target :","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"                ( 'ledger_hash","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"                , 'pending_coinbase","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                , 'local_state )","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                Registers.Stable.V1.t","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"            ; supply_increase : 'amount","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"            ; fee_excess : 'fee_excess","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"            ; sok_digest : 'sok_digest","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"            }","counters":[]},{"line":"          [@@deriving compare, equal, hash, sexp, yojson, hlist]","counters":[{"col_start":63,"col_end":63,"count":5}]},{"line":"        end","counters":[]},{"line":"      end]","counters":[]},{"line":"","counters":[]},{"line":"      let with_empty_local_state ~supply_increase ~fee_excess ~sok_digest","counters":[]},{"line":"          ~source ~target ~pending_coinbase_stack_state : _ t =","counters":[]},{"line":"        { supply_increase","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        ; fee_excess","counters":[]},{"line":"        ; sok_digest","counters":[]},{"line":"        ; source =","counters":[]},{"line":"            { ledger = source","counters":[]},{"line":"            ; pending_coinbase_stack =","counters":[]},{"line":"                pending_coinbase_stack_state.Pending_coinbase_stack_state.source","counters":[]},{"line":"            ; local_state = Local_state.empty ()","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"            }","counters":[]},{"line":"        ; target =","counters":[]},{"line":"            { ledger = target","counters":[]},{"line":"            ; pending_coinbase_stack = pending_coinbase_stack_state.target","counters":[]},{"line":"            ; local_state = Local_state.empty ()","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"            }","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"      let typ ledger_hash amount pending_coinbase fee_excess sok_digest","counters":[]},{"line":"          local_state_typ =","counters":[]},{"line":"        let registers =","counters":[{"col_start":8,"col_end":8,"count":1}]},{"line":"          let open Registers in","counters":[]},{"line":"          Tick.Typ.of_hlistable","counters":[{"col_start":30,"col_end":30,"count":1}]},{"line":"            [ ledger_hash; pending_coinbase; local_state_typ ]","counters":[]},{"line":"            ~var_to_hlist:to_hlist ~var_of_hlist:of_hlist","counters":[]},{"line":"            ~value_to_hlist:to_hlist ~value_of_hlist:of_hlist","counters":[]},{"line":"        in","counters":[]},{"line":"        Tick.Typ.of_hlistable","counters":[]},{"line":"          [ registers; registers; amount; fee_excess; sok_digest ]","counters":[]},{"line":"          ~var_to_hlist:to_hlist ~var_of_hlist:of_hlist ~value_to_hlist:to_hlist","counters":[]},{"line":"          ~value_of_hlist:of_hlist","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    type ( 'ledger_hash","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"         , 'amount","counters":[]},{"line":"         , 'pending_coinbase","counters":[]},{"line":"         , 'fee_excess","counters":[]},{"line":"         , 'sok_digest","counters":[]},{"line":"         , 'local_state )","counters":[]},{"line":"         poly =","counters":[]},{"line":"          ( 'ledger_hash","counters":[]},{"line":"          , 'amount","counters":[]},{"line":"          , 'pending_coinbase","counters":[]},{"line":"          , 'fee_excess","counters":[]},{"line":"          , 'sok_digest","counters":[]},{"line":"          , 'local_state )","counters":[]},{"line":"          Poly.t =","counters":[]},{"line":"      { source : ('ledger_hash, 'pending_coinbase, 'local_state) Registers.t","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":51,"col_end":51,"count":0},{"col_start":65,"col_end":65,"count":0},{"col_start":75,"col_end":75,"count":0}]},{"line":"      ; target : ('ledger_hash, 'pending_coinbase, 'local_state) Registers.t","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":51,"col_end":51,"count":0},{"col_start":65,"col_end":65,"count":0},{"col_start":75,"col_end":75,"count":0}]},{"line":"      ; supply_increase : 'amount","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"      ; fee_excess : 'fee_excess","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"      ; sok_digest : 'sok_digest","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"      }","counters":[]},{"line":"    [@@deriving compare, equal, hash, sexp, yojson]","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V2 = struct","counters":[]},{"line":"        type t =","counters":[{"col_start":8,"col_end":8,"count":2},{"col_start":13,"col_end":13,"count":1}]},{"line":"          ( Frozen_ledger_hash.Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":12,"col_end":12,"count":0}]},{"line":"          , (Amount.Stable.V1.t, Sgn.Stable.V1.t) Signed_poly.Stable.V1.t","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"          , Pending_coinbase.Stack_versioned.Stable.V1.t","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          , Fee_excess.Stable.V1.t","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          , unit","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          , Local_state.Stable.V1.t )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          Poly.Stable.V2.t","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        [@@deriving compare, equal, hash, sexp, yojson]","counters":[{"col_start":54,"col_end":54,"count":5}]},{"line":"","counters":[]},{"line":"        let to_latest = Fn.id","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    module With_sok = struct","counters":[]},{"line":"      [%%versioned","counters":[]},{"line":"      module Stable = struct","counters":[]},{"line":"        module V2 = struct","counters":[]},{"line":"          type t =","counters":[{"col_start":10,"col_end":10,"count":2},{"col_start":15,"col_end":15,"count":1}]},{"line":"            ( Frozen_ledger_hash.Stable.V1.t","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":14,"col_end":14,"count":0}]},{"line":"            , (Amount.Stable.V1.t, Sgn.Stable.V1.t) Signed_poly.Stable.V1.t","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"            , Pending_coinbase.Stack_versioned.Stable.V1.t","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"            , Fee_excess.Stable.V1.t","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"            , Sok_message.Digest.Stable.V1.t","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"            , Local_state.Stable.V1.t )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"            Poly.Stable.V2.t","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          [@@deriving compare, equal, hash, sexp, yojson]","counters":[{"col_start":56,"col_end":56,"count":5}]},{"line":"","counters":[]},{"line":"          let to_latest = Fn.id","counters":[]},{"line":"        end","counters":[]},{"line":"      end]","counters":[]},{"line":"","counters":[]},{"line":"      type var =","counters":[]},{"line":"        ( Frozen_ledger_hash.var","counters":[]},{"line":"        , Currency.Amount.Signed.var","counters":[]},{"line":"        , Pending_coinbase.Stack.var","counters":[]},{"line":"        , Fee_excess.var","counters":[]},{"line":"        , Sok_message.Digest.Checked.t","counters":[]},{"line":"        , Local_state.Checked.t )","counters":[]},{"line":"        Poly.t","counters":[]},{"line":"","counters":[]},{"line":"      let typ : (var, t) Tick.Typ.t =","counters":[]},{"line":"        Poly.typ Frozen_ledger_hash.typ Currency.Amount.Signed.typ","counters":[{"col_start":15,"col_end":15,"count":1}]},{"line":"          Pending_coinbase.Stack.typ Fee_excess.typ Sok_message.Digest.typ","counters":[]},{"line":"          Local_state.typ","counters":[]},{"line":"","counters":[]},{"line":"      let to_input { source; target; supply_increase; fee_excess; sok_digest } =","counters":[]},{"line":"        let input =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Array.reduce_exn ~f:Random_oracle.Input.Chunked.append","counters":[]},{"line":"            [| Sok_message.Digest.to_input sok_digest","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"             ; Registers.to_input source","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"             ; Registers.to_input target","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"             ; Amount.Signed.to_input supply_increase","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"             ; Fee_excess.to_input fee_excess","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"            |]","counters":[]},{"line":"        in","counters":[]},{"line":"        if !top_hash_logging_enabled then","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Format.eprintf","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"            !\"@[<v>Generating unchecked top hash from:@,\\","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"              %{sexp: Tick.Field.t Random_oracle.Input.Chunked.t}@]@.\"","counters":[]},{"line":"            input ;","counters":[]},{"line":"        input","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      let to_field_elements t = Random_oracle.pack_input (to_input t)","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"","counters":[]},{"line":"      module Checked = struct","counters":[]},{"line":"        type t = var","counters":[]},{"line":"","counters":[]},{"line":"        let to_input { source; target; supply_increase; fee_excess; sok_digest }","counters":[]},{"line":"            =","counters":[]},{"line":"          let open Tick in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let open Checked.Let_syntax in","counters":[]},{"line":"          let%bind fee_excess = Fee_excess.to_input_checked fee_excess in","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"          let source = Registers.Checked.to_input source","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"          and target = Registers.Checked.to_input target in","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"          let%bind supply_increase =","counters":[]},{"line":"            Amount.Signed.Checked.to_input supply_increase","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"          in","counters":[]},{"line":"          let input =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Array.reduce_exn ~f:Random_oracle.Input.Chunked.append","counters":[]},{"line":"              [| Sok_message.Digest.Checked.to_input sok_digest","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"               ; source","counters":[]},{"line":"               ; target","counters":[]},{"line":"               ; supply_increase","counters":[]},{"line":"               ; fee_excess","counters":[]},{"line":"              |]","counters":[]},{"line":"          in","counters":[]},{"line":"          let%map () =","counters":[]},{"line":"            as_prover","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"              As_prover.(","counters":[]},{"line":"                if !top_hash_logging_enabled then","counters":[]},{"line":"                  let%map input = Random_oracle.read_typ' input in","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"                  Format.eprintf","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    !\"@[<v>Generating checked top hash from:@,\\","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                      %{sexp: Field.t Random_oracle.Input.Chunked.t}@]@.\"","counters":[]},{"line":"                    input","counters":[]},{"line":"                else return ())","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"          in","counters":[]},{"line":"          input","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"        let to_field_elements t =","counters":[]},{"line":"          let open Tick.Checked.Let_syntax in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          Tick.Run.run_checked (to_input t >>| Random_oracle.Checked.pack_input)","counters":[{"col_start":39,"col_end":39,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"      end","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    let option lab =","counters":[]},{"line":"      Option.value_map ~default:(Or_error.error_string lab) ~f:(fun x -> Ok x)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":53,"col_end":53,"count":0},{"col_start":73,"col_end":73,"count":0}]},{"line":"","counters":[]},{"line":"    let merge (s1 : _ Poly.t) (s2 : _ Poly.t) =","counters":[]},{"line":"      let open Or_error.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let registers_check_equal (t1 : _ Registers.t) (t2 : _ Registers.t) =","counters":[]},{"line":"        let check' k f =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let x1 = Field.get f t1 and x2 = Field.get f t2 in","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"          k x1 x2","counters":[]},{"line":"        in","counters":[]},{"line":"        let module S = struct","counters":[]},{"line":"          module type S = sig","counters":[]},{"line":"            type t [@@deriving eq, sexp_of]","counters":[]},{"line":"          end","counters":[]},{"line":"        end in","counters":[]},{"line":"        let check (type t) (module T : S.S with type t = t) f =","counters":[]},{"line":"          let open T in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          check'","counters":[]},{"line":"            (fun x1 x2 ->","counters":[]},{"line":"              if equal x1 x2 then return ()","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"              else","counters":[]},{"line":"                Or_error.errorf","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  !\"%s is inconsistent between transitions (%{sexp: t} vs \\","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"                    %{sexp: t})\"","counters":[]},{"line":"                  (Field.name f) x1 x2 )","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"            f","counters":[]},{"line":"        in","counters":[]},{"line":"        let module PC = struct","counters":[]},{"line":"          type t = Pending_coinbase.Stack.t [@@deriving sexp_of]","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"          let equal t1 t2 =","counters":[]},{"line":"            Pending_coinbase.Stack.connected ~first:t1 ~second:t2 ()","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"        end in","counters":[]},{"line":"        Registers.Fields.to_list","counters":[]},{"line":"          ~ledger:(check (module Ledger_hash))","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"          ~pending_coinbase_stack:(check (module PC))","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"          ~local_state:(check (module Local_state))","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"        |> Or_error.combine_errors_unit","counters":[]},{"line":"      in","counters":[]},{"line":"      let%map fee_excess = Fee_excess.combine s1.fee_excess s2.fee_excess","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"      and supply_increase =","counters":[]},{"line":"        Currency.Amount.Signed.add s1.supply_increase s2.supply_increase","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"        |> option \"Error adding supply_increase\"","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"      and () = registers_check_equal s1.target s2.source in","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"      ( { source = s1.source","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        ; target = s2.target","counters":[]},{"line":"        ; fee_excess","counters":[]},{"line":"        ; supply_increase","counters":[]},{"line":"        ; sok_digest = ()","counters":[]},{"line":"        }","counters":[]},{"line":"        : t )","counters":[]},{"line":"","counters":[]},{"line":"    include Hashable.Make_binable (Stable.Latest)","counters":[]},{"line":"    include Comparable.Make (Stable.Latest)","counters":[]},{"line":"","counters":[]},{"line":"    let gen =","counters":[]},{"line":"      let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"      let%map source = Registers.gen","counters":[]},{"line":"      and target = Registers.gen","counters":[]},{"line":"      and fee_excess = Fee_excess.gen","counters":[]},{"line":"      and supply_increase = Currency.Amount.Signed.gen in","counters":[]},{"line":"      ({ source; target; fee_excess; supply_increase; sok_digest = () } : t)","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Proof = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V2 = struct","counters":[]},{"line":"        type t = Pickles.Proof.Proofs_verified_2.Stable.V2.t","counters":[{"col_start":8,"col_end":8,"count":2},{"col_start":13,"col_end":13,"count":1},{"col_start":17,"col_end":17,"count":0}]},{"line":"        [@@deriving yojson, compare, equal, sexp, hash]","counters":[{"col_start":54,"col_end":54,"count":5}]},{"line":"","counters":[]},{"line":"        let to_latest = Fn.id","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V2 = struct","counters":[]},{"line":"      type t = A.V2.t =","counters":[{"col_start":6,"col_end":6,"count":2},{"col_start":11,"col_end":11,"count":2}]},{"line":"        { statement : Statement.With_sok.Stable.V2.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"        ; proof : Proof.Stable.V2.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":14,"col_end":14,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"        }","counters":[]},{"line":"      [@@deriving compare, equal, fields, sexp, version, yojson, hash]","counters":[{"col_start":69,"col_end":69,"count":5}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  let proof t = t.proof","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"","counters":[]},{"line":"  let statement t = { t.statement with sok_digest = () }","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"","counters":[]},{"line":"  let sok_digest t = t.statement.sok_digest","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"","counters":[]},{"line":"  let to_yojson = Stable.Latest.to_yojson","counters":[]},{"line":"","counters":[]},{"line":"  let create ~statement ~proof = { statement; proof }","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"","counters":[]},{"line":"  open Tick","counters":[]},{"line":"  open Let_syntax","counters":[]},{"line":"","counters":[]},{"line":"  let chain if_ b ~then_ ~else_ =","counters":[]},{"line":"    let%bind then_ = then_ and else_ = else_ in","counters":[]},{"line":"    if_ b ~then_ ~else_","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  module Zkapp_command_segment = struct","counters":[]},{"line":"    module Spec = struct","counters":[]},{"line":"      type single =","counters":[]},{"line":"        { auth_type : Control.Tag.t","counters":[]},{"line":"        ; is_start : [ `Yes | `No | `Compute_in_circuit ]","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"      type t = single list","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Basic = struct","counters":[]},{"line":"      module N = Side_loaded_verification_key.Max_branches","counters":[]},{"line":"","counters":[]},{"line":"      [%%versioned","counters":[]},{"line":"      module Stable = struct","counters":[]},{"line":"        module V1 = struct","counters":[]},{"line":"          type t = Opt_signed_opt_signed | Opt_signed | Proved","counters":[{"col_start":10,"col_end":10,"count":2},{"col_start":15,"col_end":15,"count":2},{"col_start":19,"col_end":19,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"          [@@deriving sexp, yojson]","counters":[{"col_start":34,"col_end":34,"count":5}]},{"line":"","counters":[]},{"line":"          let to_latest = Fn.id","counters":[]},{"line":"        end","counters":[]},{"line":"      end]","counters":[]},{"line":"","counters":[]},{"line":"      let of_controls = function","counters":[]},{"line":"        | [ Control.Proof _ ] ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Proved","counters":[]},{"line":"        | [ (Control.Signature _ | Control.None_given) ] ->","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"            Opt_signed","counters":[]},{"line":"        | [ Control.(Signature _ | None_given)","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"          ; Control.(Signature _ | None_given)","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"          ] ->","counters":[]},{"line":"            Opt_signed_opt_signed","counters":[]},{"line":"        | _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            failwith","counters":[]},{"line":"              \"Zkapp_command_segment.Basic.of_controls: Unsupported combination\"","counters":[]},{"line":"","counters":[]},{"line":"      let opt_signed ~is_start : Spec.single =","counters":[]},{"line":"        { auth_type = Signature; is_start }","counters":[{"col_start":8,"col_end":8,"count":1}]},{"line":"","counters":[]},{"line":"      let opt_signed = opt_signed ~is_start:`Compute_in_circuit","counters":[]},{"line":"","counters":[]},{"line":"      let to_single_list : t -> Spec.single list =","counters":[]},{"line":"       fun t ->","counters":[]},{"line":"        match t with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | Opt_signed_opt_signed ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            [ opt_signed; opt_signed ]","counters":[]},{"line":"        | Opt_signed ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            [ opt_signed ]","counters":[]},{"line":"        | Proved ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            [ { auth_type = Proof; is_start = `No } ]","counters":[]},{"line":"","counters":[]},{"line":"      type (_, _, _, _) t_typed =","counters":[]},{"line":"        | Opt_signed_opt_signed : (unit, unit, unit, unit) t_typed","counters":[]},{"line":"        | Opt_signed : (unit, unit, unit, unit) t_typed","counters":[]},{"line":"        | Proved","counters":[]},{"line":"            : ( Zkapp_statement.Checked.t * unit","counters":[]},{"line":"              , Zkapp_statement.t * unit","counters":[]},{"line":"              , Nat.N2.n * unit","counters":[]},{"line":"              , N.n * unit )","counters":[]},{"line":"              t_typed","counters":[]},{"line":"","counters":[]},{"line":"      let spec : type a b c d. (a, b, c, d) t_typed -> Spec.single list =","counters":[]},{"line":"       fun t ->","counters":[]},{"line":"        match t with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | Opt_signed_opt_signed ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            [ opt_signed; opt_signed ]","counters":[]},{"line":"        | Opt_signed ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            [ opt_signed ]","counters":[]},{"line":"        | Proved ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            [ { auth_type = Proof; is_start = `No } ]","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Witness = Transaction_witness.Zkapp_command_segment_witness","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  (* Currently, a circuit must have at least 1 of every type of constraint. *)","counters":[]},{"line":"  let dummy_constraints () =","counters":[]},{"line":"    make_checked","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Impl.(","counters":[]},{"line":"        fun () ->","counters":[]},{"line":"          let x =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            exists Field.typ ~compute:(fun () -> Field.Constant.of_int 3)","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"          in","counters":[]},{"line":"          let g = exists Inner_curve.typ ~compute:(fun _ -> Inner_curve.one) in","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"          ignore","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ( Pickles.Scalar_challenge.to_field_checked'","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"                (module Impl)","counters":[]},{"line":"                ~num_bits:16","counters":[]},{"line":"                (Kimchi_backend_common.Scalar_challenge.create x)","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"              : Field.t * Field.t * Field.t ) ;","counters":[]},{"line":"          ignore","counters":[]},{"line":"            ( Pickles.Step_main_inputs.Ops.scale_fast g ~num_bits:5","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"                (Shifted_value x)","counters":[]},{"line":"              : Pickles.Step_main_inputs.Inner_curve.t ) ;","counters":[]},{"line":"          ignore","counters":[]},{"line":"            ( Pickles.Step_main_inputs.Ops.scale_fast g ~num_bits:5","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"                (Shifted_value x)","counters":[]},{"line":"              : Pickles.Step_main_inputs.Inner_curve.t ) ;","counters":[]},{"line":"          ignore","counters":[]},{"line":"            ( Pickles.Step_verifier.Scalar_challenge.endo g ~num_bits:4","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"                (Kimchi_backend_common.Scalar_challenge.create x)","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"              : Field.t * Field.t ))","counters":[]},{"line":"","counters":[]},{"line":"  module Base = struct","counters":[]},{"line":"    module User_command_failure = struct","counters":[]},{"line":"      (** The various ways that a user command may fail. These should be computed","counters":[]},{"line":"        before applying the snark, to ensure that only the base fee is charged","counters":[]},{"line":"        to the fee-payer if executing the user command will later fail.","counters":[]},{"line":"    *)","counters":[]},{"line":"      type 'bool t =","counters":[]},{"line":"        { predicate_failed : 'bool (* User commands *)","counters":[]},{"line":"        ; source_not_present : 'bool (* User commands *)","counters":[]},{"line":"        ; receiver_not_present : 'bool (* Delegate, Mint_tokens *)","counters":[]},{"line":"        ; amount_insufficient_to_create : 'bool (* Payment only *)","counters":[]},{"line":"        ; token_cannot_create : 'bool (* Payment only, token<>default *)","counters":[]},{"line":"        ; source_insufficient_balance : 'bool (* Payment only *)","counters":[]},{"line":"        ; source_minimum_balance_violation : 'bool (* Payment only *)","counters":[]},{"line":"        ; source_bad_timing : 'bool (* Payment only *)","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"      let num_fields = 8","counters":[]},{"line":"","counters":[]},{"line":"      let to_list","counters":[]},{"line":"          { predicate_failed","counters":[]},{"line":"          ; source_not_present","counters":[]},{"line":"          ; receiver_not_present","counters":[]},{"line":"          ; amount_insufficient_to_create","counters":[]},{"line":"          ; token_cannot_create","counters":[]},{"line":"          ; source_insufficient_balance","counters":[]},{"line":"          ; source_minimum_balance_violation","counters":[]},{"line":"          ; source_bad_timing","counters":[]},{"line":"          } =","counters":[]},{"line":"        [ predicate_failed","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        ; source_not_present","counters":[]},{"line":"        ; receiver_not_present","counters":[]},{"line":"        ; amount_insufficient_to_create","counters":[]},{"line":"        ; token_cannot_create","counters":[]},{"line":"        ; source_insufficient_balance","counters":[]},{"line":"        ; source_minimum_balance_violation","counters":[]},{"line":"        ; source_bad_timing","counters":[]},{"line":"        ]","counters":[]},{"line":"","counters":[]},{"line":"      let of_list = function","counters":[]},{"line":"        | [ predicate_failed","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          ; source_not_present","counters":[]},{"line":"          ; receiver_not_present","counters":[]},{"line":"          ; amount_insufficient_to_create","counters":[]},{"line":"          ; token_cannot_create","counters":[]},{"line":"          ; source_insufficient_balance","counters":[]},{"line":"          ; source_minimum_balance_violation","counters":[]},{"line":"          ; source_bad_timing","counters":[]},{"line":"          ] ->","counters":[]},{"line":"            { predicate_failed","counters":[]},{"line":"            ; source_not_present","counters":[]},{"line":"            ; receiver_not_present","counters":[]},{"line":"            ; amount_insufficient_to_create","counters":[]},{"line":"            ; token_cannot_create","counters":[]},{"line":"            ; source_insufficient_balance","counters":[]},{"line":"            ; source_minimum_balance_violation","counters":[]},{"line":"            ; source_bad_timing","counters":[]},{"line":"            }","counters":[]},{"line":"        | _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            failwith","counters":[]},{"line":"              \"Transaction_snark.Base.User_command_failure.to_list: bad length\"","counters":[]},{"line":"","counters":[]},{"line":"      let typ : (Boolean.var t, bool t) Typ.t =","counters":[]},{"line":"        let open Typ in","counters":[]},{"line":"        list ~length:num_fields Boolean.typ","counters":[{"col_start":11,"col_end":11,"count":1}]},{"line":"        |> transport ~there:to_list ~back:of_list","counters":[{"col_start":19,"col_end":19,"count":1}]},{"line":"        |> transport_var ~there:to_list ~back:of_list","counters":[{"col_start":23,"col_end":23,"count":1}]},{"line":"","counters":[]},{"line":"      let any t = Boolean.any (to_list t)","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"      (** Compute which -- if any -- of the failure cases will be hit when","counters":[]},{"line":"        evaluating the given user command, and indicate whether the fee-payer","counters":[]},{"line":"        would need to pay the account creation fee if the user command were to","counters":[]},{"line":"        succeed (irrespective or whether it actually will or not).","counters":[]},{"line":"    *)","counters":[]},{"line":"      let compute_unchecked","counters":[]},{"line":"          ~(constraint_constants : Genesis_constants.Constraint_constants.t)","counters":[]},{"line":"          ~txn_global_slot ~(fee_payer_account : Account.t)","counters":[]},{"line":"          ~(receiver_account : Account.t) ~(source_account : Account.t)","counters":[]},{"line":"          ({ payload; signature = _; signer = _ } : Transaction_union.t) =","counters":[]},{"line":"        match payload.body.tag with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | Fee_transfer | Coinbase ->","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"            (* Not user commands, return no failure. *)","counters":[]},{"line":"            of_list (List.init num_fields ~f:(fun _ -> false))","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"        | _ -> (","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let fail s =","counters":[]},{"line":"              failwithf","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                \"Transaction_snark.Base.User_command_failure.compute_unchecked: \\","counters":[]},{"line":"                 %s\"","counters":[]},{"line":"                s ()","counters":[]},{"line":"            in","counters":[]},{"line":"            let fee_token = payload.common.fee_token in","counters":[]},{"line":"            let token = payload.body.token_id in","counters":[]},{"line":"            let fee_payer =","counters":[]},{"line":"              Account_id.create payload.common.fee_payer_pk fee_token","counters":[]},{"line":"            in","counters":[]},{"line":"            let source = Account_id.create payload.body.source_pk token in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let receiver = Account_id.create payload.body.receiver_pk token in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            (* This should shadow the logic in [Sparse_ledger]. *)","counters":[]},{"line":"            let fee_payer_account =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              { fee_payer_account with","counters":[]},{"line":"                balance =","counters":[]},{"line":"                  Option.value_exn ?here:None ?error:None ?message:None","counters":[{"col_start":70,"col_end":70,"count":0}]},{"line":"                  @@ Balance.sub_amount fee_payer_account.balance","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"                       (Amount.of_fee payload.common.fee)","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"              }","counters":[]},{"line":"            in","counters":[]},{"line":"            let predicate_failed =","counters":[]},{"line":"              if","counters":[]},{"line":"                Public_key.Compressed.equal payload.common.fee_payer_pk","counters":[]},{"line":"                  payload.body.source_pk","counters":[]},{"line":"              then false","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"              else","counters":[]},{"line":"                match payload.body.tag with","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                | Create_account | Mint_tokens ->","counters":[]},{"line":"                    assert false","counters":[]},{"line":"                | Payment | Stake_delegation ->","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"                    (* TODO(#4554): Hook account_precondition evaluation in here once","counters":[]},{"line":"                       implemented.","counters":[]},{"line":"                    *)","counters":[]},{"line":"                    true","counters":[]},{"line":"                | Fee_transfer | Coinbase ->","counters":[]},{"line":"                    assert false","counters":[]},{"line":"            in","counters":[]},{"line":"            match payload.body.tag with","counters":[]},{"line":"            | Fee_transfer | Coinbase ->","counters":[]},{"line":"                assert false","counters":[]},{"line":"            | Stake_delegation ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                let receiver_account =","counters":[]},{"line":"                  if Account_id.equal receiver fee_payer then fee_payer_account","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"                  else receiver_account","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                in","counters":[]},{"line":"                let receiver_not_present =","counters":[]},{"line":"                  let id = Account.identifier receiver_account in","counters":[]},{"line":"                  if Account_id.equal Account_id.empty id then true","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"                  else if Account_id.equal receiver id then false","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"                  else fail \"bad receiver account ID\"","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"                in","counters":[]},{"line":"                let source_account =","counters":[]},{"line":"                  if Account_id.equal source fee_payer then fee_payer_account","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"                  else source_account","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                in","counters":[]},{"line":"                let source_not_present =","counters":[]},{"line":"                  let id = Account.identifier source_account in","counters":[]},{"line":"                  if Account_id.equal Account_id.empty id then true","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"                  else if Account_id.equal source id then false","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"                  else fail \"bad source account ID\"","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"                in","counters":[]},{"line":"                { predicate_failed","counters":[]},{"line":"                ; source_not_present","counters":[]},{"line":"                ; receiver_not_present","counters":[]},{"line":"                ; amount_insufficient_to_create = false","counters":[]},{"line":"                ; token_cannot_create = false","counters":[]},{"line":"                ; source_insufficient_balance = false","counters":[]},{"line":"                ; source_minimum_balance_violation = false","counters":[]},{"line":"                ; source_bad_timing = false","counters":[]},{"line":"                }","counters":[]},{"line":"            | Payment ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                let receiver_account =","counters":[]},{"line":"                  if Account_id.equal receiver fee_payer then fee_payer_account","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"                  else receiver_account","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                in","counters":[]},{"line":"                let receiver_needs_creating =","counters":[]},{"line":"                  let id = Account.identifier receiver_account in","counters":[]},{"line":"                  if Account_id.equal Account_id.empty id then true","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"                  else if Account_id.equal receiver id then false","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"                  else fail \"bad receiver account ID\"","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"                in","counters":[]},{"line":"                let token_is_default = true in","counters":[]},{"line":"                let token_cannot_create =","counters":[]},{"line":"                  receiver_needs_creating && not token_is_default","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"                in","counters":[]},{"line":"                let amount_insufficient_to_create =","counters":[]},{"line":"                  let creation_amount =","counters":[]},{"line":"                    Amount.of_fee constraint_constants.account_creation_fee","counters":[]},{"line":"                  in","counters":[]},{"line":"                  receiver_needs_creating","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  && Option.is_none","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"                       (Amount.sub payload.body.amount creation_amount)","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"                in","counters":[]},{"line":"                let fee_payer_is_source = Account_id.equal fee_payer source in","counters":[]},{"line":"                let source_account =","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  if fee_payer_is_source then fee_payer_account","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"                  else source_account","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                in","counters":[]},{"line":"                let source_not_present =","counters":[]},{"line":"                  let id = Account.identifier source_account in","counters":[]},{"line":"                  if Account_id.equal Account_id.empty id then true","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"                  else if Account_id.equal source id then false","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"                  else fail \"bad source account ID\"","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"                in","counters":[]},{"line":"                let source_insufficient_balance =","counters":[]},{"line":"                  (* This failure is fatal if fee-payer and source account are","counters":[]},{"line":"                     the same. This is checked in the transaction pool.","counters":[]},{"line":"                  *)","counters":[]},{"line":"                  (not fee_payer_is_source)","counters":[]},{"line":"                  &&","counters":[]},{"line":"                  if Account_id.equal source receiver then","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    (* The final balance will be [0 - account_creation_fee]. *)","counters":[]},{"line":"                    receiver_needs_creating","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                  else","counters":[]},{"line":"                    Amount.(","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      Balance.to_amount source_account.balance","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"                      < payload.body.amount)","counters":[]},{"line":"                in","counters":[]},{"line":"                let timing_or_error =","counters":[]},{"line":"                  Mina_transaction_logic.validate_timing","counters":[]},{"line":"                    ~txn_amount:payload.body.amount ~txn_global_slot","counters":[]},{"line":"                    ~account:source_account","counters":[]},{"line":"                in","counters":[]},{"line":"                let source_minimum_balance_violation =","counters":[]},{"line":"                  match timing_or_error with","counters":[]},{"line":"                  | Ok _ ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      false","counters":[]},{"line":"                  | Error err ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      let open Mina_base in","counters":[]},{"line":"                      Transaction_status.Failure.equal","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"                        (Mina_transaction_logic","counters":[]},{"line":"                         .timing_error_to_user_command_status err )","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"                        Transaction_status.Failure","counters":[]},{"line":"                        .Source_minimum_balance_violation","counters":[]},{"line":"                in","counters":[]},{"line":"                let source_bad_timing =","counters":[]},{"line":"                  (* This failure is fatal if fee-payer and source account are","counters":[]},{"line":"                     the same. This is checked in the transaction pool.","counters":[]},{"line":"                  *)","counters":[]},{"line":"                  (not fee_payer_is_source)","counters":[]},{"line":"                  && (not source_insufficient_balance)","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                  && Or_error.is_error timing_or_error","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"                in","counters":[]},{"line":"                { predicate_failed","counters":[]},{"line":"                ; source_not_present","counters":[]},{"line":"                ; receiver_not_present = false","counters":[]},{"line":"                ; amount_insufficient_to_create","counters":[]},{"line":"                ; token_cannot_create","counters":[]},{"line":"                ; source_insufficient_balance","counters":[]},{"line":"                ; source_minimum_balance_violation","counters":[]},{"line":"                ; source_bad_timing","counters":[]},{"line":"                }","counters":[]},{"line":"            | Mint_tokens | Create_account ->","counters":[]},{"line":"                assert false )","counters":[]},{"line":"","counters":[]},{"line":"      let%snarkydef_ compute_as_prover ~constraint_constants ~txn_global_slot","counters":[]},{"line":"          (txn : Transaction_union.var) =","counters":[]},{"line":"        let%bind data =","counters":[]},{"line":"          exists (Typ.Internal.ref ())","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"            ~compute:","counters":[]},{"line":"              As_prover.(","counters":[]},{"line":"                let%map txn = read Transaction_union.typ txn in","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"                let fee_token = txn.payload.common.fee_token in","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                let token = txn.payload.body.token_id in","counters":[]},{"line":"                let fee_payer =","counters":[]},{"line":"                  Account_id.create txn.payload.common.fee_payer_pk fee_token","counters":[]},{"line":"                in","counters":[]},{"line":"                let source =","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Account_id.create txn.payload.body.source_pk token","counters":[]},{"line":"                in","counters":[]},{"line":"                let receiver =","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Account_id.create txn.payload.body.receiver_pk token","counters":[]},{"line":"                in","counters":[]},{"line":"                (txn, fee_payer, source, receiver))","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"        in","counters":[]},{"line":"        let%bind fee_payer_idx =","counters":[]},{"line":"          exists (Typ.Internal.ref ())","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"            ~request:","counters":[]},{"line":"              As_prover.(","counters":[]},{"line":"                let%map _txn, fee_payer, _source, _receiver =","counters":[]},{"line":"                  read (Typ.Internal.ref ()) data","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"                in","counters":[]},{"line":"                Ledger_hash.Find_index fee_payer)","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"        in","counters":[]},{"line":"        let%bind fee_payer_account =","counters":[]},{"line":"          exists (Typ.Internal.ref ())","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"            ~request:","counters":[]},{"line":"              As_prover.(","counters":[]},{"line":"                let%map fee_payer_idx =","counters":[]},{"line":"                  read (Typ.Internal.ref ()) fee_payer_idx","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"                in","counters":[]},{"line":"                Ledger_hash.Get_element fee_payer_idx)","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"        in","counters":[]},{"line":"        let%bind source_idx =","counters":[]},{"line":"          exists (Typ.Internal.ref ())","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"            ~request:","counters":[]},{"line":"              As_prover.(","counters":[]},{"line":"                let%map _txn, _fee_payer, source, _receiver =","counters":[]},{"line":"                  read (Typ.Internal.ref ()) data","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"                in","counters":[]},{"line":"                Ledger_hash.Find_index source)","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"        in","counters":[]},{"line":"        let%bind source_account =","counters":[]},{"line":"          exists (Typ.Internal.ref ())","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"            ~request:","counters":[]},{"line":"              As_prover.(","counters":[]},{"line":"                let%map source_idx = read (Typ.Internal.ref ()) source_idx in","counters":[{"col_start":40,"col_end":40,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"                Ledger_hash.Get_element source_idx)","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"        in","counters":[]},{"line":"        let%bind receiver_idx =","counters":[]},{"line":"          exists (Typ.Internal.ref ())","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"            ~request:","counters":[]},{"line":"              As_prover.(","counters":[]},{"line":"                let%map _txn, _fee_payer, _source, receiver =","counters":[]},{"line":"                  read (Typ.Internal.ref ()) data","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"                in","counters":[]},{"line":"                Ledger_hash.Find_index receiver)","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"        in","counters":[]},{"line":"        let%bind receiver_account =","counters":[]},{"line":"          exists (Typ.Internal.ref ())","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"            ~request:","counters":[]},{"line":"              As_prover.(","counters":[]},{"line":"                let%map receiver_idx =","counters":[]},{"line":"                  read (Typ.Internal.ref ()) receiver_idx","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"                in","counters":[]},{"line":"                Ledger_hash.Get_element receiver_idx)","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"        in","counters":[]},{"line":"        exists typ","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ~compute:","counters":[]},{"line":"            As_prover.(","counters":[]},{"line":"              let%bind txn, _fee_payer, _source, _receiver =","counters":[]},{"line":"                read (Typ.Internal.ref ()) data","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"              in","counters":[]},{"line":"              let%bind fee_payer_account, _path =","counters":[]},{"line":"                read (Typ.Internal.ref ()) fee_payer_account","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"              in","counters":[]},{"line":"              let%bind source_account, _path =","counters":[]},{"line":"                read (Typ.Internal.ref ()) source_account","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"              in","counters":[]},{"line":"              let%bind receiver_account, _path =","counters":[]},{"line":"                read (Typ.Internal.ref ()) receiver_account","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"              in","counters":[]},{"line":"              let%map txn_global_slot = read Global_slot.typ txn_global_slot in","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"              compute_unchecked ~constraint_constants ~txn_global_slot","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ~fee_payer_account ~source_account ~receiver_account txn)","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    let%snarkydef_ check_signature shifted ~payload ~is_user_command ~signer","counters":[]},{"line":"        ~signature =","counters":[]},{"line":"      let%bind input =","counters":[]},{"line":"        Transaction_union_payload.Checked.to_input_legacy payload","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"      in","counters":[]},{"line":"      let%bind verifies =","counters":[]},{"line":"        Schnorr.Legacy.Checked.verifies shifted signature signer input","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"      in","counters":[]},{"line":"      [%with_label_ \"check signature\"] (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"          Boolean.Assert.any [ Boolean.not is_user_command; verifies ] )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"","counters":[]},{"line":"    let check_timing ~balance_check ~timed_balance_check ~account ~txn_amount","counters":[]},{"line":"        ~txn_global_slot =","counters":[]},{"line":"      (* calculations should track Mina_transaction_logic.validate_timing *)","counters":[]},{"line":"      let open Account.Poly in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let open Account.Timing.As_record in","counters":[]},{"line":"      let { is_timed","counters":[]},{"line":"          ; initial_minimum_balance","counters":[]},{"line":"          ; cliff_time","counters":[]},{"line":"          ; cliff_amount","counters":[]},{"line":"          ; vesting_period","counters":[]},{"line":"          ; vesting_increment","counters":[]},{"line":"          } =","counters":[]},{"line":"        account.timing","counters":[]},{"line":"      in","counters":[]},{"line":"      let%bind curr_min_balance =","counters":[]},{"line":"        Account.Checked.min_balance_at_slot ~global_slot:txn_global_slot","counters":[]},{"line":"          ~cliff_time ~cliff_amount ~vesting_period ~vesting_increment","counters":[]},{"line":"          ~initial_minimum_balance","counters":[]},{"line":"      in","counters":[]},{"line":"      let%bind proposed_balance =","counters":[]},{"line":"        match txn_amount with","counters":[]},{"line":"        | Some txn_amount ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let%bind proposed_balance, `Underflow underflow =","counters":[]},{"line":"              Balance.Checked.sub_amount_flagged account.balance txn_amount","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"            in","counters":[]},{"line":"            (* underflow indicates insufficient balance *)","counters":[]},{"line":"            let%map () = balance_check (Boolean.not underflow) in","counters":[{"col_start":37,"col_end":37,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"            proposed_balance","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            return account.balance","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"      in","counters":[]},{"line":"      let%bind sufficient_timed_balance =","counters":[]},{"line":"        Balance.Checked.( >= ) proposed_balance curr_min_balance","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"      in","counters":[]},{"line":"      let%bind () =","counters":[]},{"line":"        let%bind ok =","counters":[]},{"line":"          Boolean.(any [ not is_timed; sufficient_timed_balance ])","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"        in","counters":[]},{"line":"        timed_balance_check ok","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      in","counters":[]},{"line":"      let%bind is_timed_balance_zero =","counters":[]},{"line":"        Balance.Checked.equal curr_min_balance","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"          (Balance.Checked.Unsafe.of_field Field.(Var.constant zero))","counters":[{"col_start":41,"col_end":41,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"      in","counters":[]},{"line":"      (* if current min balance is zero, then timing becomes untimed *)","counters":[]},{"line":"      let%bind is_untimed =","counters":[]},{"line":"        Boolean.((not is_timed) ||| is_timed_balance_zero)","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"      in","counters":[]},{"line":"      let%map timing =","counters":[]},{"line":"        Account.Timing.if_ is_untimed ~then_:Account.Timing.untimed_var","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"          ~else_:account.timing","counters":[]},{"line":"      in","counters":[]},{"line":"      (`Min_balance curr_min_balance, timing)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let side_loaded =","counters":[]},{"line":"      Memo.of_comparable","counters":[{"col_start":23,"col_end":23,"count":1}]},{"line":"        (module Int)","counters":[]},{"line":"        (fun i ->","counters":[]},{"line":"          let open Zkapp_statement in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          Pickles.Side_loaded.create ~typ ~name:(sprintf \"zkapp_%d\" i)","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"            ~uses_lookup:Maybe","counters":[]},{"line":"            ~max_proofs_verified:","counters":[]},{"line":"              (module Pickles.Side_loaded.Verification_key.Max_width) )","counters":[]},{"line":"","counters":[]},{"line":"    let signature_verifies ~shifted ~payload_digest signature pk =","counters":[]},{"line":"      let%bind pk =","counters":[]},{"line":"        Public_key.decompress_var pk","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"        (*           (Account_id.Checked.public_key fee_payer_id) *)","counters":[]},{"line":"      in","counters":[]},{"line":"      Schnorr.Chunked.Checked.verifies shifted signature pk","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (Random_oracle.Input.Chunked.field payload_digest)","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"","counters":[]},{"line":"    module Zkapp_command_snark = struct","counters":[]},{"line":"      open Zkapp_command_segment","counters":[]},{"line":"      open Spec","counters":[]},{"line":"","counters":[]},{"line":"      module Global_state = struct","counters":[]},{"line":"        type t =","counters":[]},{"line":"          { ledger : Ledger_hash.var * Sparse_ledger.t Prover_value.t","counters":[]},{"line":"          ; fee_excess : Amount.Signed.var","counters":[]},{"line":"          ; supply_increase : Amount.Signed.var","counters":[]},{"line":"          ; protocol_state : Zkapp_precondition.Protocol_state.View.Checked.t","counters":[]},{"line":"          }","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      let implied_root account incl =","counters":[]},{"line":"        let open Impl in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        List.foldi incl","counters":[]},{"line":"          ~init:(Lazy.force (With_hash.hash account))","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"          ~f:(fun height acc (b, h) ->","counters":[]},{"line":"            let l = Field.if_ b ~then_:h ~else_:acc","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"            and r = Field.if_ b ~then_:acc ~else_:h in","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"            let acc' = Ledger_hash.merge_var ~height l r in","counters":[]},{"line":"            acc' )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"","counters":[]},{"line":"      module type Single_inputs = sig","counters":[]},{"line":"        val constraint_constants : Genesis_constants.Constraint_constants.t","counters":[]},{"line":"","counters":[]},{"line":"        val spec : single","counters":[]},{"line":"","counters":[]},{"line":"        val set_zkapp_input : Zkapp_statement.Checked.t -> unit","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      type account_update = Zkapp_call_forest.Checked.account_update =","counters":[]},{"line":"        { account_update :","counters":[]},{"line":"            ( Account_update.Body.Checked.t","counters":[]},{"line":"            , Zkapp_command.Digest.Account_update.Checked.t )","counters":[]},{"line":"            With_hash.t","counters":[]},{"line":"        ; control : Control.t Prover_value.t","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"      module Inputs = struct","counters":[]},{"line":"        module V = Prover_value","counters":[]},{"line":"        open Impl","counters":[]},{"line":"","counters":[]},{"line":"        module Transaction_commitment = struct","counters":[]},{"line":"          type t = Field.t","counters":[]},{"line":"","counters":[]},{"line":"          let if_ = Field.if_","counters":[]},{"line":"","counters":[]},{"line":"          let empty = Field.constant Zkapp_command.Transaction_commitment.empty","counters":[{"col_start":35,"col_end":35,"count":1}]},{"line":"","counters":[]},{"line":"          let commitment","counters":[]},{"line":"              ~account_updates:{ With_hash.hash = account_updates_hash; _ } =","counters":[]},{"line":"            Zkapp_command.Transaction_commitment.Checked.create","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              ~account_updates_hash","counters":[]},{"line":"","counters":[]},{"line":"          let full_commitment ~account_update:{ account_update; _ } ~memo_hash","counters":[]},{"line":"              ~commitment =","counters":[]},{"line":"            Zkapp_command.Transaction_commitment.Checked.create_complete","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              commitment ~memo_hash ~fee_payer_hash:account_update.hash","counters":[]},{"line":"        end","counters":[]},{"line":"","counters":[]},{"line":"        module Bool = struct","counters":[]},{"line":"          type t = Boolean.var","counters":[]},{"line":"","counters":[]},{"line":"          [%%define_locally","counters":[]},{"line":"          Boolean.(( ||| ), ( &&& ), if_, true_, false_, equal, not, all)]","counters":[]},{"line":"","counters":[]},{"line":"          module Assert = struct","counters":[]},{"line":"            let raise_failure ~pos msg =","counters":[]},{"line":"              let file, line, col, ecol = pos in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              raise","counters":[]},{"line":"                (Failure","counters":[]},{"line":"                   (sprintf \"File %S, line %d, characters %d-%d: %s\" file line","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                      col ecol msg ) )","counters":[]},{"line":"","counters":[]},{"line":"            let is_true ~pos b =","counters":[]},{"line":"              try Boolean.Assert.is_true b","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"              with Failure msg -> raise_failure ~pos msg","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"","counters":[]},{"line":"            let any ~pos bs =","counters":[]},{"line":"              try Boolean.Assert.any bs","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"              with Failure msg -> raise_failure ~pos msg","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"          end","counters":[]},{"line":"","counters":[]},{"line":"          let display _b ~label:_ = \"\"","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"","counters":[]},{"line":"          type failure_status = unit","counters":[]},{"line":"","counters":[]},{"line":"          type failure_status_tbl = unit","counters":[]},{"line":"","counters":[]},{"line":"          let assert_with_failure_status_tbl ~pos b _failure_status_tbl =","counters":[]},{"line":"            Assert.is_true ~pos b","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"        end","counters":[]},{"line":"","counters":[]},{"line":"        module Index = struct","counters":[]},{"line":"          open Mina_numbers.Index.Checked","counters":[]},{"line":"","counters":[]},{"line":"          type t = var","counters":[]},{"line":"","counters":[]},{"line":"          let zero = zero","counters":[]},{"line":"","counters":[]},{"line":"          let succ t = succ t |> run_checked","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"","counters":[]},{"line":"          let if_ b ~then_ ~else_ = if_ b ~then_ ~else_ |> run_checked","counters":[{"col_start":36,"col_end":36,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"        end","counters":[]},{"line":"","counters":[]},{"line":"        module Account_id = struct","counters":[]},{"line":"          type t = Account_id.var","counters":[]},{"line":"","counters":[]},{"line":"          let if_ b ~then_ ~else_ =","counters":[]},{"line":"            run_checked (Account_id.Checked.if_ b ~then_ ~else_)","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"","counters":[]},{"line":"          let derive_token_id = Account_id.Checked.derive_token_id","counters":[]},{"line":"","counters":[]},{"line":"          let constant id =","counters":[]},{"line":"            Account_id.(","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"              Checked.create","counters":[]},{"line":"                (Public_key.Compressed.var_of_t (public_key id))","counters":[{"col_start":46,"col_end":46,"count":1},{"col_start":58,"col_end":58,"count":1}]},{"line":"                (Token_id.Checked.constant (token_id id)))","counters":[{"col_start":41,"col_end":41,"count":1},{"col_start":51,"col_end":51,"count":1}]},{"line":"","counters":[]},{"line":"          let invalid = constant Account_id.invalid","counters":[{"col_start":31,"col_end":31,"count":1}]},{"line":"","counters":[]},{"line":"          let equal x y = Account_id.Checked.equal x y |> run_checked","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"","counters":[]},{"line":"          let create = Account_id.Checked.create","counters":[]},{"line":"        end","counters":[]},{"line":"","counters":[]},{"line":"        module Global_slot = struct","counters":[]},{"line":"          include Global_slot.Checked","counters":[]},{"line":"","counters":[]},{"line":"          let ( > ) x y = run_checked (x > y)","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"","counters":[]},{"line":"          let if_ b ~then_ ~else_ = run_checked (if_ b ~then_ ~else_)","counters":[{"col_start":36,"col_end":36,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"","counters":[]},{"line":"          let equal x y = run_checked (equal x y)","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"        end","counters":[]},{"line":"","counters":[]},{"line":"        module Nonce = struct","counters":[]},{"line":"          type t = Account.Nonce.Checked.t","counters":[]},{"line":"","counters":[]},{"line":"          let if_ b ~then_ ~else_ =","counters":[]},{"line":"            run_checked (Account.Nonce.Checked.if_ b ~then_ ~else_)","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"","counters":[]},{"line":"          let succ t = run_checked (Account.Nonce.Checked.succ t)","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"        end","counters":[]},{"line":"","counters":[]},{"line":"        module State_hash = struct","counters":[]},{"line":"          type t = State_hash.var","counters":[]},{"line":"","counters":[]},{"line":"          let if_ b ~then_ ~else_ = run_checked (State_hash.if_ b ~then_ ~else_)","counters":[{"col_start":36,"col_end":36,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"        end","counters":[]},{"line":"","counters":[]},{"line":"        module Timing = struct","counters":[]},{"line":"          type t = Account_timing.var","counters":[]},{"line":"","counters":[]},{"line":"          let if_ b ~then_ ~else_ =","counters":[]},{"line":"            run_checked (Account_timing.if_ b ~then_ ~else_)","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"","counters":[]},{"line":"          let vesting_period (t : t) = t.vesting_period","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"        end","counters":[]},{"line":"","counters":[]},{"line":"        module Balance = struct","counters":[]},{"line":"          include Balance.Checked","counters":[]},{"line":"","counters":[]},{"line":"          let if_ b ~then_ ~else_ = run_checked (if_ b ~then_ ~else_)","counters":[{"col_start":36,"col_end":36,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"","counters":[]},{"line":"          let sub_amount_flagged x y = run_checked (sub_amount_flagged x y)","counters":[{"col_start":39,"col_end":39,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"","counters":[]},{"line":"          let add_signed_amount_flagged x y =","counters":[]},{"line":"            run_checked (add_signed_amount_flagged x y)","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"        end","counters":[]},{"line":"","counters":[]},{"line":"        module Receipt_chain_hash = struct","counters":[]},{"line":"          open Receipt.Chain_hash.Checked","counters":[]},{"line":"","counters":[]},{"line":"          type nonrec t = t","counters":[]},{"line":"","counters":[]},{"line":"          module Elt = struct","counters":[]},{"line":"            type t = Zkapp_command_elt.t","counters":[]},{"line":"","counters":[]},{"line":"            let of_transaction_commitment tc =","counters":[]},{"line":"              Zkapp_command_elt.Zkapp_command_commitment tc","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"          end","counters":[]},{"line":"","counters":[]},{"line":"          let cons_zkapp_command_commitment index elt t =","counters":[]},{"line":"            run_checked (cons_zkapp_command_commitment index elt t)","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"","counters":[]},{"line":"          let if_ b ~then_ ~else_ = run_checked (if_ b ~then_ ~else_)","counters":[{"col_start":36,"col_end":36,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"        end","counters":[]},{"line":"","counters":[]},{"line":"        module Verification_key = struct","counters":[]},{"line":"          type t =","counters":[]},{"line":"            ( Boolean.var","counters":[]},{"line":"            , ( Side_loaded_verification_key.t option","counters":[]},{"line":"              , Field.Constant.t )","counters":[]},{"line":"              With_hash.t","counters":[]},{"line":"              Data_as_hash.t )","counters":[]},{"line":"            Zkapp_basic.Flagged_option.t","counters":[]},{"line":"","counters":[]},{"line":"          let if_ b ~(then_ : t) ~(else_ : t) : t =","counters":[]},{"line":"            Zkapp_basic.Flagged_option.if_ ~if_:Data_as_hash.if_ b ~then_ ~else_","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"        end","counters":[]},{"line":"","counters":[]},{"line":"        module Sequence_events = struct","counters":[]},{"line":"          type t = Zkapp_account.Sequence_events.var","counters":[]},{"line":"","counters":[]},{"line":"          let is_empty x =","counters":[]},{"line":"            run_checked (Account_update.Sequence_events.is_empty_var x)","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"","counters":[]},{"line":"          let push_events = Account_update.Sequence_events.push_events_checked","counters":[]},{"line":"        end","counters":[]},{"line":"","counters":[]},{"line":"        module Zkapp_uri = struct","counters":[]},{"line":"          type t = string Data_as_hash.t","counters":[]},{"line":"","counters":[]},{"line":"          let if_ = Data_as_hash.if_","counters":[]},{"line":"        end","counters":[]},{"line":"","counters":[]},{"line":"        module Token_symbol = struct","counters":[]},{"line":"          type t = Account.Token_symbol.var","counters":[]},{"line":"","counters":[]},{"line":"          let if_ = Account.Token_symbol.if_","counters":[]},{"line":"        end","counters":[]},{"line":"","counters":[]},{"line":"        module Account = struct","counters":[]},{"line":"          type t = (Account.Checked.Unhashed.t, Field.t Lazy.t) With_hash.t","counters":[]},{"line":"","counters":[]},{"line":"          module Permissions = struct","counters":[]},{"line":"            type controller = Permissions.Auth_required.Checked.t","counters":[]},{"line":"","counters":[]},{"line":"            let edit_state : t -> controller =","counters":[]},{"line":"             fun a -> a.data.permissions.edit_state","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"            let send : t -> controller = fun a -> a.data.permissions.send","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"","counters":[]},{"line":"            let receive : t -> controller = fun a -> a.data.permissions.receive","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"","counters":[]},{"line":"            let set_delegate : t -> controller =","counters":[]},{"line":"             fun a -> a.data.permissions.set_delegate","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"            let set_permissions : t -> controller =","counters":[]},{"line":"             fun a -> a.data.permissions.set_permissions","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"            let set_verification_key : t -> controller =","counters":[]},{"line":"             fun a -> a.data.permissions.set_verification_key","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"            let set_zkapp_uri : t -> controller =","counters":[]},{"line":"             fun a -> a.data.permissions.set_zkapp_uri","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"            let edit_sequence_state : t -> controller =","counters":[]},{"line":"             fun a -> a.data.permissions.edit_sequence_state","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"            let set_token_symbol : t -> controller =","counters":[]},{"line":"             fun a -> a.data.permissions.set_token_symbol","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"            let increment_nonce : t -> controller =","counters":[]},{"line":"             fun a -> a.data.permissions.increment_nonce","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"            let set_voting_for : t -> controller =","counters":[]},{"line":"             fun a -> a.data.permissions.set_voting_for","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"            type t = Permissions.Checked.t","counters":[]},{"line":"","counters":[]},{"line":"            let if_ b ~then_ ~else_ = Permissions.Checked.if_ b ~then_ ~else_","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"          end","counters":[]},{"line":"","counters":[]},{"line":"          let account_with_hash (account : Account.Checked.Unhashed.t) : t =","counters":[]},{"line":"            With_hash.of_data account ~hash_data:(fun a ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"                lazy","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  (let a =","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                     { a with","counters":[]},{"line":"                       zkapp =","counters":[]},{"line":"                         ( Zkapp_account.Checked.digest a.zkapp","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"                         , As_prover.Ref.create (fun () -> None) )","counters":[{"col_start":46,"col_end":46,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"                     }","counters":[]},{"line":"                   in","counters":[]},{"line":"                   run_checked (Account.Checked.digest a) ) )","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"","counters":[]},{"line":"          type timing = Account_timing.var","counters":[]},{"line":"","counters":[]},{"line":"          let timing (account : t) : timing = account.data.timing","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"","counters":[]},{"line":"          let set_timing (account : t) (timing : timing) : t =","counters":[]},{"line":"            { account with data = { account.data with timing } }","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"","counters":[]},{"line":"          let is_timed ({ data = account; _ } : t) =","counters":[]},{"line":"            let open Account.Poly in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let open Account.Timing.As_record in","counters":[]},{"line":"            let { is_timed; _ } = account.timing in","counters":[]},{"line":"            is_timed","counters":[]},{"line":"","counters":[]},{"line":"          let set_token_id (account : t) (token_id : Token_id.Checked.t) : t =","counters":[]},{"line":"            account_with_hash { account.data with token_id }","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"","counters":[]},{"line":"          let balance (a : t) : Balance.t = a.data.balance","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"          let set_balance (balance : Balance.t) ({ data = a; hash } : t) : t =","counters":[]},{"line":"            { data = { a with balance }; hash }","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"","counters":[]},{"line":"          let check_timing ~txn_global_slot ({ data = account; _ } : t) =","counters":[]},{"line":"            let invalid_timing = ref None in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let balance_check _ = failwith \"Should not be called\" in","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"            let timed_balance_check b =","counters":[]},{"line":"              invalid_timing := Some (Boolean.not b) ;","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"              return ()","counters":[]},{"line":"            in","counters":[]},{"line":"            let `Min_balance _, timing =","counters":[]},{"line":"              run_checked","counters":[]},{"line":"              @@ [%with_label.Snark_params.Tick \"Check zkapp timing\"] (fun () ->","counters":[{"col_start":67,"col_end":67,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"                     check_timing ~balance_check ~timed_balance_check ~account","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                       ~txn_amount:None ~txn_global_slot )","counters":[]},{"line":"            in","counters":[]},{"line":"            (`Invalid_timing (Option.value_exn !invalid_timing), timing)","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"","counters":[]},{"line":"          let receipt_chain_hash (a : t) : Receipt_chain_hash.t =","counters":[]},{"line":"            a.data.receipt_chain_hash","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"","counters":[]},{"line":"          let set_receipt_chain_hash (a : t)","counters":[]},{"line":"              (receipt_chain_hash : Receipt_chain_hash.t) : t =","counters":[]},{"line":"            { a with data = { a.data with receipt_chain_hash } }","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"","counters":[]},{"line":"          let make_zkapp (a : t) = a","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"          let unmake_zkapp (a : t) = a","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"          let proved_state (a : t) = a.data.zkapp.proved_state","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"          let set_proved_state proved_state ({ data = a; hash } : t) : t =","counters":[]},{"line":"            { data = { a with zkapp = { a.zkapp with proved_state } }; hash }","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"","counters":[]},{"line":"          let app_state (a : t) = a.data.zkapp.app_state","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"","counters":[]},{"line":"          let set_app_state app_state ({ data = a; hash } : t) : t =","counters":[]},{"line":"            { data = { a with zkapp = { a.zkapp with app_state } }; hash }","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"","counters":[]},{"line":"          let verification_key (a : t) : Verification_key.t =","counters":[]},{"line":"            a.data.zkapp.verification_key","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"","counters":[]},{"line":"          let set_verification_key (verification_key : Verification_key.t)","counters":[]},{"line":"              ({ data = a; hash } : t) : t =","counters":[]},{"line":"            { data = { a with zkapp = { a.zkapp with verification_key } }","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            ; hash","counters":[]},{"line":"            }","counters":[]},{"line":"","counters":[]},{"line":"          let last_sequence_slot (a : t) = a.data.zkapp.last_sequence_slot","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"","counters":[]},{"line":"          let set_last_sequence_slot last_sequence_slot ({ data = a; hash } : t)","counters":[]},{"line":"              : t =","counters":[]},{"line":"            { data = { a with zkapp = { a.zkapp with last_sequence_slot } }","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            ; hash","counters":[]},{"line":"            }","counters":[]},{"line":"","counters":[]},{"line":"          let sequence_state (a : t) = a.data.zkapp.sequence_state","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"          let set_sequence_state sequence_state ({ data = a; hash } : t) : t =","counters":[]},{"line":"            { data = { a with zkapp = { a.zkapp with sequence_state } }; hash }","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"","counters":[]},{"line":"          let zkapp_uri (a : t) = a.data.zkapp.zkapp_uri","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"","counters":[]},{"line":"          let set_zkapp_uri zkapp_uri ({ data = a; hash } : t) : t =","counters":[]},{"line":"            { data = { a with zkapp = { a.zkapp with zkapp_uri } }; hash }","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"","counters":[]},{"line":"          let token_symbol (a : t) = a.data.token_symbol","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"          let set_token_symbol token_symbol ({ data = a; hash } : t) : t =","counters":[]},{"line":"            { data = { a with token_symbol }; hash }","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"","counters":[]},{"line":"          let public_key (a : t) = a.data.public_key","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"          let set_public_key public_key ({ data = a; hash } : t) : t =","counters":[]},{"line":"            { data = { a with public_key }; hash }","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"","counters":[]},{"line":"          let delegate (a : t) = a.data.delegate","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"","counters":[]},{"line":"          let set_delegate delegate ({ data = a; hash } : t) : t =","counters":[]},{"line":"            { data = { a with delegate }; hash }","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"","counters":[]},{"line":"          let nonce (a : t) = a.data.nonce","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"","counters":[]},{"line":"          let set_nonce nonce ({ data = a; hash } : t) : t =","counters":[]},{"line":"            { data = { a with nonce }; hash }","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"","counters":[]},{"line":"          let voting_for (a : t) = a.data.voting_for","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"          let set_voting_for voting_for ({ data = a; hash } : t) : t =","counters":[]},{"line":"            { data = { a with voting_for }; hash }","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"","counters":[]},{"line":"          let permissions (a : t) = a.data.permissions","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"","counters":[]},{"line":"          let set_permissions permissions ({ data = a; hash } : t) : t =","counters":[]},{"line":"            { data = { a with permissions }; hash }","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"        end","counters":[]},{"line":"","counters":[]},{"line":"        module Opt = struct","counters":[]},{"line":"          open Zkapp_basic","counters":[]},{"line":"","counters":[]},{"line":"          type 'a t = (Bool.t, 'a) Flagged_option.t","counters":[]},{"line":"","counters":[]},{"line":"          let is_some = Flagged_option.is_some","counters":[]},{"line":"","counters":[]},{"line":"          let map x ~f = Flagged_option.map ~f x","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"          let or_default ~if_ x ~default =","counters":[]},{"line":"            if_ (is_some x) ~then_:(Flagged_option.data x) ~else_:default","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"","counters":[]},{"line":"          let or_exn x =","counters":[]},{"line":"            with_label \"or_exn is_some\" (fun () ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"                Bool.Assert.is_true ~pos:__POS__ (is_some x) ) ;","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"            Flagged_option.data x","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"        end","counters":[]},{"line":"","counters":[]},{"line":"        module Call_forest = Zkapp_call_forest.Checked","counters":[]},{"line":"","counters":[]},{"line":"        module Stack_frame = struct","counters":[]},{"line":"          type frame = (Token_id.Checked.t, Call_forest.t) Stack_frame.t","counters":[]},{"line":"","counters":[]},{"line":"          type t = (frame, Stack_frame.Digest.Checked.t Lazy.t) With_hash.t","counters":[]},{"line":"","counters":[]},{"line":"          let if_ b ~then_:(t1 : t) ~else_:(t2 : t) : t =","counters":[]},{"line":"            { With_hash.hash =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"                lazy","counters":[]},{"line":"                  (Stack_frame.Digest.Checked.if_ b ~then_:(Lazy.force t1.hash)","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"                     ~else_:(Lazy.force t2.hash) )","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"            ; data =","counters":[]},{"line":"                Stack_frame.Checked.if_ Call_forest.if_ b ~then_:t1.data","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"                  ~else_:t2.data","counters":[]},{"line":"            }","counters":[]},{"line":"","counters":[]},{"line":"          let caller (t : t) = t.data.caller","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"","counters":[]},{"line":"          let caller_caller (t : t) = t.data.caller_caller","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"","counters":[]},{"line":"          let calls (t : t) = t.data.calls","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"","counters":[]},{"line":"          let of_frame (frame : frame) : t =","counters":[]},{"line":"            { data = frame","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            ; hash =","counters":[]},{"line":"                lazy","counters":[]},{"line":"                  (Stack_frame.Digest.Checked.create","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                     ~hash_zkapp_command:(fun (calls : Call_forest.t) ->","counters":[]},{"line":"                       calls.hash )","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                     frame )","counters":[]},{"line":"            }","counters":[]},{"line":"","counters":[]},{"line":"          let make ~caller ~caller_caller ~calls : t =","counters":[]},{"line":"            Stack_frame.make ~caller ~caller_caller ~calls |> of_frame","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"","counters":[]},{"line":"          let hash (t : t) : Stack_frame.Digest.Checked.t = Lazy.force t.hash","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"","counters":[]},{"line":"          let unhash (h : Stack_frame.Digest.Checked.t)","counters":[]},{"line":"              (frame :","counters":[]},{"line":"                ( Mina_base.Token_id.Stable.V2.t","counters":[]},{"line":"                , Mina_base.Zkapp_command.Call_forest.With_hashes.Stable.V1.t","counters":[]},{"line":"                )","counters":[]},{"line":"                Stack_frame.Stable.V1.t","counters":[]},{"line":"                V.t ) : t =","counters":[]},{"line":"            with_label \"unhash\" (fun () ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"                let frame : frame =","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  { caller =","counters":[]},{"line":"                      exists Token_id.typ ~compute:(fun () ->","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                          (V.get frame).caller )","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"                  ; caller_caller =","counters":[]},{"line":"                      exists Token_id.typ ~compute:(fun () ->","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                          (V.get frame).caller_caller )","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"                  ; calls =","counters":[]},{"line":"                      { hash =","counters":[]},{"line":"                          exists Mina_base.Zkapp_command.Digest.Forest.typ","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                            ~compute:(fun () ->","counters":[]},{"line":"                              (V.get frame).calls","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"                              |> Mina_base.Zkapp_command.Call_forest.hash )","counters":[]},{"line":"                      ; data = V.map frame ~f:(fun frame -> frame.calls)","counters":[{"col_start":35,"col_end":35,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"                      }","counters":[]},{"line":"                  }","counters":[]},{"line":"                in","counters":[]},{"line":"                let t = of_frame frame in","counters":[]},{"line":"                Stack_frame.Digest.Checked.Assert.equal","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  (hash (of_frame frame))","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"                  h ;","counters":[]},{"line":"                t )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"        end","counters":[]},{"line":"","counters":[]},{"line":"        module Call_stack = struct","counters":[]},{"line":"          module Value = struct","counters":[]},{"line":"            open Mina_base","counters":[]},{"line":"","counters":[]},{"line":"            type caller = Token_id.t","counters":[]},{"line":"","counters":[]},{"line":"            type frame =","counters":[]},{"line":"              ( caller","counters":[]},{"line":"              , ( Account_update.t","counters":[]},{"line":"                , Zkapp_command.Digest.Account_update.t","counters":[]},{"line":"                , Zkapp_command.Digest.Forest.t )","counters":[]},{"line":"                Zkapp_command.Call_forest.t )","counters":[]},{"line":"              Stack_frame.t","counters":[]},{"line":"          end","counters":[]},{"line":"","counters":[]},{"line":"          type elt = Stack_frame.t","counters":[]},{"line":"","counters":[]},{"line":"          module Elt = struct","counters":[]},{"line":"            type t = (Value.frame, Mina_base.Stack_frame.Digest.t) With_hash.t","counters":[]},{"line":"","counters":[]},{"line":"            let default : unit -> t =","counters":[]},{"line":"              Memo.unit (fun () : t ->","counters":[{"col_start":22,"col_end":22,"count":1}]},{"line":"                  With_hash.of_data","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    ~hash_data:Mina_base.Stack_frame.Digest.create","counters":[]},{"line":"                    ( { caller = Mina_base.Token_id.default","counters":[]},{"line":"                      ; caller_caller = Mina_base.Token_id.default","counters":[]},{"line":"                      ; calls = []","counters":[]},{"line":"                      }","counters":[]},{"line":"                      : Value.frame ) )","counters":[]},{"line":"          end","counters":[]},{"line":"","counters":[]},{"line":"          let hash (type a)","counters":[]},{"line":"              (xs : (a, Call_stack_digest.t) With_stack_hash.t list) :","counters":[]},{"line":"              Call_stack_digest.t =","counters":[]},{"line":"            match xs with","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            | [] ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Call_stack_digest.empty","counters":[]},{"line":"            | x :: _ ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                x.stack_hash","counters":[]},{"line":"","counters":[]},{"line":"          type t =","counters":[]},{"line":"            ( (Elt.t, Call_stack_digest.t) With_stack_hash.t list V.t","counters":[]},{"line":"            , Call_stack_digest.Checked.t )","counters":[]},{"line":"            With_hash.t","counters":[]},{"line":"","counters":[]},{"line":"          let if_ b ~then_:(t : t) ~else_:(e : t) : t =","counters":[]},{"line":"            { hash = Call_stack_digest.Checked.if_ b ~then_:t.hash ~else_:e.hash","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"            ; data = V.if_ b ~then_:t.data ~else_:e.data","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"            }","counters":[]},{"line":"","counters":[]},{"line":"          let empty = Call_stack_digest.(constant empty)","counters":[{"col_start":48,"col_end":48,"count":1}]},{"line":"","counters":[]},{"line":"          let is_empty ({ hash = x; _ } : t) =","counters":[]},{"line":"            Call_stack_digest.Checked.equal empty x","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"","counters":[]},{"line":"          let empty () : t = { hash = empty; data = V.create (fun () -> []) }","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":59,"col_end":59,"count":0},{"col_start":72,"col_end":72,"count":0}]},{"line":"","counters":[]},{"line":"          let exists_elt (elt_ref : (Value.frame, _) With_hash.t V.t) :","counters":[]},{"line":"              Stack_frame.t =","counters":[]},{"line":"            let elt : Stack_frame.frame =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let calls : Call_forest.t =","counters":[]},{"line":"                { hash =","counters":[]},{"line":"                    exists Mina_base.Zkapp_command.Digest.Forest.typ","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                      ~compute:(fun () ->","counters":[]},{"line":"                        (V.get elt_ref).data.calls","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"                        |> Mina_base.Zkapp_command.Call_forest.hash )","counters":[]},{"line":"                ; data = V.map elt_ref ~f:(fun frame -> frame.data.calls)","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"                }","counters":[]},{"line":"              and caller =","counters":[]},{"line":"                exists Mina_base.Token_id.typ ~compute:(fun () ->","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                    (V.get elt_ref).data.caller )","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"              and caller_caller =","counters":[]},{"line":"                exists Mina_base.Token_id.typ ~compute:(fun () ->","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                    (V.get elt_ref).data.caller_caller )","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"              in","counters":[]},{"line":"              { caller; caller_caller; calls }","counters":[]},{"line":"            in","counters":[]},{"line":"            Stack_frame.of_frame elt","counters":[]},{"line":"","counters":[]},{"line":"          let pop_exn ({ hash = h; data = r } : t) : elt * t =","counters":[]},{"line":"            let hd_r = V.create (fun () -> (V.get r |> List.hd_exn).elt) in","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":43,"col_end":43,"count":0},{"col_start":48,"col_end":48,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"            let tl_r = V.create (fun () -> V.get r |> List.tl_exn) in","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":43,"col_end":43,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"            let elt : Stack_frame.t = exists_elt hd_r in","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"            let stack =","counters":[]},{"line":"              exists Call_stack_digest.typ ~compute:(fun () ->","counters":[]},{"line":"                  hash (V.get tl_r) )","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"            in","counters":[]},{"line":"            let h' =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Call_stack_digest.Checked.cons (Stack_frame.hash elt) stack","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"            in","counters":[]},{"line":"            with_label __LOC__ (fun () ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"                Call_stack_digest.Checked.Assert.equal h h' ) ;","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"            (elt, { hash = stack; data = tl_r })","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"","counters":[]},{"line":"          let pop ({ hash = h; data = r } as t : t) : (elt * t) Opt.t =","counters":[]},{"line":"            let input_is_empty = is_empty t in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let hd_r =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              V.create (fun () ->","counters":[]},{"line":"                  match V.get r |> List.hd with","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"                  | None ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      Elt.default ()","counters":[]},{"line":"                  | Some x ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      x.elt )","counters":[]},{"line":"            in","counters":[]},{"line":"            let tl_r =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              V.create (fun () ->","counters":[]},{"line":"                  V.get r |> List.tl |> Option.value ~default:[] )","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"            in","counters":[]},{"line":"            let elt = exists_elt hd_r in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let stack =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              exists Call_stack_digest.typ ~compute:(fun () ->","counters":[]},{"line":"                  hash (V.get tl_r) )","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"            in","counters":[]},{"line":"            let stack_frame_hash = Stack_frame.hash elt in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let h' = Call_stack_digest.Checked.cons stack_frame_hash stack in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            with_label __LOC__ (fun () ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"                Boolean.Assert.any","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  [ input_is_empty; Call_stack_digest.Checked.equal h h' ] ) ;","counters":[{"col_start":66,"col_end":66,"count":0}]},{"line":"            { is_some = Boolean.not input_is_empty","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"            ; data = (elt, { hash = stack; data = tl_r })","counters":[]},{"line":"            }","counters":[]},{"line":"","counters":[]},{"line":"          let read_elt (frame : elt) : Elt.t =","counters":[]},{"line":"            { hash =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"                As_prover.read Mina_base.Stack_frame.Digest.typ","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                  (Stack_frame.hash frame)","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"            ; data =","counters":[]},{"line":"                { calls = V.get frame.data.calls.data","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                ; caller = As_prover.read Token_id.typ frame.data.caller","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"                ; caller_caller =","counters":[]},{"line":"                    As_prover.read Token_id.typ frame.data.caller_caller","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"                }","counters":[]},{"line":"            }","counters":[]},{"line":"","counters":[]},{"line":"          let push (elt : elt) ~onto:({ hash = h_tl; data = r_tl } : t) : t =","counters":[]},{"line":"            let h =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Call_stack_digest.Checked.cons (Stack_frame.hash elt) h_tl","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"            in","counters":[]},{"line":"            let r =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              V.create","counters":[]},{"line":"                (fun () : (Elt.t, Call_stack_digest.t) With_stack_hash.t list ->","counters":[]},{"line":"                  let hd = read_elt elt in","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  let tl = V.get r_tl in","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  { With_stack_hash.stack_hash =","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                      As_prover.read Call_stack_digest.typ h","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                  ; elt = hd","counters":[]},{"line":"                  }","counters":[]},{"line":"                  :: tl )","counters":[]},{"line":"            in","counters":[]},{"line":"            { hash = h; data = r }","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"        end","counters":[]},{"line":"","counters":[]},{"line":"        module Amount = struct","counters":[]},{"line":"          type t = Amount.Checked.t","counters":[]},{"line":"","counters":[]},{"line":"          type unsigned = t","counters":[]},{"line":"","counters":[]},{"line":"          module Signed = struct","counters":[]},{"line":"            type t = Amount.Signed.Checked.t","counters":[]},{"line":"","counters":[]},{"line":"            let equal t t' = run_checked (Amount.Signed.Checked.equal t t')","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"","counters":[]},{"line":"            let if_ b ~then_ ~else_ =","counters":[]},{"line":"              run_checked (Amount.Signed.Checked.if_ b ~then_ ~else_)","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"","counters":[]},{"line":"            let is_pos (t : t) =","counters":[]},{"line":"              Sgn.Checked.is_pos","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (run_checked (Currency.Amount.Signed.Checked.sgn t))","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"","counters":[]},{"line":"            let negate = Amount.Signed.Checked.negate","counters":[]},{"line":"","counters":[]},{"line":"            let of_unsigned = Amount.Signed.Checked.of_unsigned","counters":[]},{"line":"","counters":[]},{"line":"            let add_flagged x y =","counters":[]},{"line":"              run_checked (Amount.Signed.Checked.add_flagged x y)","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"          end","counters":[]},{"line":"","counters":[]},{"line":"          let if_ b ~then_ ~else_ =","counters":[]},{"line":"            run_checked (Amount.Checked.if_ b ~then_ ~else_)","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"","counters":[]},{"line":"          let equal t t' = run_checked (Amount.Checked.equal t t')","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"","counters":[]},{"line":"          let zero = Amount.(var_of_t zero)","counters":[{"col_start":36,"col_end":36,"count":1}]},{"line":"","counters":[]},{"line":"          let add_flagged x y = run_checked (Amount.Checked.add_flagged x y)","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":70,"col_end":70,"count":0}]},{"line":"","counters":[]},{"line":"          let add_signed_flagged (x : t) (y : Signed.t) =","counters":[]},{"line":"            run_checked (Amount.Checked.add_signed_flagged x y)","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"","counters":[]},{"line":"          let of_constant_fee fee = Amount.var_of_t (Amount.of_fee fee)","counters":[{"col_start":36,"col_end":36,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"        end","counters":[]},{"line":"","counters":[]},{"line":"        module Token_id = struct","counters":[]},{"line":"          type t = Token_id.Checked.t","counters":[]},{"line":"","counters":[]},{"line":"          let if_ = Token_id.Checked.if_","counters":[]},{"line":"","counters":[]},{"line":"          let equal x y = Token_id.Checked.equal x y","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"","counters":[]},{"line":"          let default = Token_id.(Checked.constant default)","counters":[{"col_start":49,"col_end":49,"count":1}]},{"line":"        end","counters":[]},{"line":"","counters":[]},{"line":"        module Public_key = struct","counters":[]},{"line":"          type t = Public_key.Compressed.var","counters":[]},{"line":"","counters":[]},{"line":"          let if_ b ~then_ ~else_ =","counters":[]},{"line":"            run_checked (Public_key.Compressed.Checked.if_ b ~then_ ~else_)","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"        end","counters":[]},{"line":"","counters":[]},{"line":"        module Protocol_state_precondition = struct","counters":[]},{"line":"          type t = Zkapp_precondition.Protocol_state.Checked.t","counters":[]},{"line":"        end","counters":[]},{"line":"","counters":[]},{"line":"        module Field = Impl.Field","counters":[]},{"line":"","counters":[]},{"line":"        module Local_state = struct","counters":[]},{"line":"          type t =","counters":[]},{"line":"            ( Stack_frame.t","counters":[]},{"line":"            , Call_stack.t","counters":[]},{"line":"            , Token_id.t","counters":[]},{"line":"            , Amount.Signed.t","counters":[]},{"line":"            , Ledger_hash.var * Sparse_ledger.t V.t","counters":[]},{"line":"            , Bool.t","counters":[]},{"line":"            , Transaction_commitment.t","counters":[]},{"line":"            , Index.t","counters":[]},{"line":"            , Bool.failure_status_tbl )","counters":[]},{"line":"            Mina_transaction_logic.Zkapp_command_logic.Local_state.t","counters":[]},{"line":"","counters":[]},{"line":"          let add_check (t : t) _failure b =","counters":[]},{"line":"            { t with success = Bool.(t.success &&& b) }","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"","counters":[]},{"line":"          let update_failure_status_tbl (t : t) _failure_status b =","counters":[]},{"line":"            add_check","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (t : t)","counters":[]},{"line":"              Transaction_status.Failure.Update_not_permitted_voting_for b","counters":[]},{"line":"","counters":[]},{"line":"          let add_new_failure_status_bucket t = t","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"        end","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      type _ Snarky_backendless.Request.t +=","counters":[]},{"line":"        | Zkapp_proof :","counters":[]},{"line":"            (Nat.N2.n, Nat.N2.n) Pickles.Proof.t Snarky_backendless.Request.t","counters":[]},{"line":"","counters":[]},{"line":"      let handle_zkapp_proof (proof : _ Pickles.Proof.t)","counters":[]},{"line":"          (Snarky_backendless.Request.With { request; respond }) =","counters":[]},{"line":"        match request with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | Zkapp_proof ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            respond (Provide proof)","counters":[]},{"line":"        | _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            respond Unhandled","counters":[]},{"line":"","counters":[]},{"line":"      module Single (I : Single_inputs) = struct","counters":[]},{"line":"        open I","counters":[]},{"line":"","counters":[]},{"line":"        let { auth_type; is_start = _ } = spec","counters":[]},{"line":"","counters":[]},{"line":"        module V = Prover_value","counters":[]},{"line":"        open Impl","counters":[]},{"line":"","counters":[]},{"line":"        module Inputs = struct","counters":[]},{"line":"          include Inputs","counters":[]},{"line":"","counters":[]},{"line":"          module Account = struct","counters":[]},{"line":"            include Account","counters":[]},{"line":"","counters":[]},{"line":"            let register_verification_key ({ data = a; _ } : t) =","counters":[]},{"line":"              match spec.auth_type with","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              | Proof ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  let vk =","counters":[]},{"line":"                    exists Side_loaded_verification_key.typ ~compute:(fun () ->","counters":[]},{"line":"                        Option.value_exn","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          (As_prover.Ref.get","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"                             (Data_as_hash.ref a.zkapp.verification_key.data) )","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"                            .data )","counters":[]},{"line":"                  in","counters":[]},{"line":"                  let expected_hash =","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    Data_as_hash.hash a.zkapp.verification_key.data","counters":[]},{"line":"                  in","counters":[]},{"line":"                  let actual_hash = Zkapp_account.Checked.digest_vk vk in","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  Field.Assert.equal expected_hash actual_hash ;","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  Pickles.Side_loaded.in_circuit (side_loaded 0) vk","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"              | Signature | None_given ->","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"                  ()","counters":[]},{"line":"          end","counters":[]},{"line":"","counters":[]},{"line":"          module Controller = struct","counters":[]},{"line":"            type t = Permissions.Auth_required.Checked.t","counters":[]},{"line":"","counters":[]},{"line":"            let if_ = Permissions.Auth_required.Checked.if_","counters":[]},{"line":"","counters":[]},{"line":"            let check =","counters":[]},{"line":"              match auth_type with","counters":[]},{"line":"              | Proof ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  fun ~proof_verifies:_ ~signature_verifies:_ perm ->","counters":[]},{"line":"                    Permissions.Auth_required.Checked.eval_proof perm","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"              | Signature | None_given ->","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"                  fun ~proof_verifies:_ ~signature_verifies perm ->","counters":[]},{"line":"                    Permissions.Auth_required.Checked.eval_no_proof","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      ~signature_verifies perm","counters":[]},{"line":"          end","counters":[]},{"line":"","counters":[]},{"line":"          module Ledger = struct","counters":[]},{"line":"            type t = Ledger_hash.var * Sparse_ledger.t V.t","counters":[]},{"line":"","counters":[]},{"line":"            type inclusion_proof = (Boolean.var * Field.t) list","counters":[]},{"line":"","counters":[]},{"line":"            let if_ b ~then_:((xt, rt) : t) ~else_:((xe, re) : t) =","counters":[]},{"line":"              ( run_checked (Ledger_hash.if_ b ~then_:xt ~else_:xe)","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"              , V.if_ b ~then_:rt ~else_:re )","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"","counters":[]},{"line":"            let empty ~depth () : t =","counters":[]},{"line":"              let t = Sparse_ledger.empty ~depth () in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              ( Ledger_hash.var_of_t (Sparse_ledger.merkle_root t)","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"              , V.create (fun () -> t) )","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"","counters":[]},{"line":"            let idx ledger id = Sparse_ledger.find_index_exn ledger id","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"","counters":[]},{"line":"            let body_id (body : Account_update.Body.Checked.t) =","counters":[]},{"line":"              let open As_prover in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              Mina_base.Account_id.create","counters":[]},{"line":"                (read Signature_lib.Public_key.Compressed.typ body.public_key)","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                (read Mina_base.Token_id.typ body.token_id)","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"","counters":[]},{"line":"            let get_account { account_update; _ } ((_root, ledger) : t) =","counters":[]},{"line":"              let idx =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                V.map ledger ~f:(fun l -> idx l (body_id account_update.data))","counters":[{"col_start":42,"col_end":42,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"              in","counters":[]},{"line":"              let account =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                exists Mina_base.Account.Checked.Unhashed.typ","counters":[]},{"line":"                  ~compute:(fun () ->","counters":[]},{"line":"                    Sparse_ledger.get_exn (V.get ledger) (V.get idx) )","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":47,"col_end":47,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"              in","counters":[]},{"line":"              let account = Account.account_with_hash account in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              let incl =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                exists","counters":[]},{"line":"                  Typ.(","counters":[]},{"line":"                    list ~length:constraint_constants.ledger_depth","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                      (Boolean.typ * field))","counters":[]},{"line":"                  ~compute:(fun () ->","counters":[]},{"line":"                    List.map","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      (Sparse_ledger.path_exn (V.get ledger) (V.get idx))","counters":[{"col_start":44,"col_end":44,"count":0},{"col_start":51,"col_end":51,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"                      ~f:(fun x ->","counters":[]},{"line":"                        match x with","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                        | `Left h ->","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            (false, h)","counters":[]},{"line":"                        | `Right h ->","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            (true, h) ) )","counters":[]},{"line":"              in","counters":[]},{"line":"              (account, incl)","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"","counters":[]},{"line":"            let set_account ((_root, ledger) : t) ((a, incl) : Account.t * _) :","counters":[]},{"line":"                t =","counters":[]},{"line":"              ( implied_root a incl |> Ledger_hash.var_of_hash_packed","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"              , V.map ledger","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                  ~f:","counters":[]},{"line":"                    As_prover.(","counters":[]},{"line":"                      fun ledger ->","counters":[]},{"line":"                        let a : Mina_base.Account.t =","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          read Mina_base.Account.Checked.Unhashed.typ a.data","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                        in","counters":[]},{"line":"                        let idx = idx ledger (Mina_base.Account.identifier a) in","counters":[{"col_start":73,"col_end":73,"count":0}]},{"line":"                        Sparse_ledger.set_exn ledger idx a) )","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"","counters":[]},{"line":"            let check_inclusion ((root, _) : t) (account, incl) =","counters":[]},{"line":"              with_label __LOC__ (fun () ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                  Field.Assert.equal","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    (implied_root account incl)","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                    (Ledger_hash.var_to_hash_packed root) )","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"","counters":[]},{"line":"            let check_account public_key token_id","counters":[]},{"line":"                (({ data = account; _ }, _) : Account.t * _) =","counters":[]},{"line":"              let is_new =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                run_checked","counters":[]},{"line":"                  (Signature_lib.Public_key.Compressed.Checked.equal","counters":[{"col_start":67,"col_end":67,"count":0}]},{"line":"                     account.public_key","counters":[]},{"line":"                     Signature_lib.Public_key.Compressed.(var_of_t empty) )","counters":[{"col_start":65,"col_end":65,"count":0}]},{"line":"              in","counters":[]},{"line":"              with_label __LOC__ (fun () ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                  Boolean.Assert.any","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    [ is_new","counters":[]},{"line":"                    ; run_checked","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                        (Signature_lib.Public_key.Compressed.Checked.equal","counters":[{"col_start":73,"col_end":73,"count":0}]},{"line":"                           public_key account.public_key )","counters":[]},{"line":"                    ] ) ;","counters":[]},{"line":"              with_label __LOC__ (fun () ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                  Boolean.Assert.any","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    [ is_new; Token_id.equal token_id account.token_id ] ) ;","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"              `Is_new is_new","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"          end","counters":[]},{"line":"","counters":[]},{"line":"          module Account_update = struct","counters":[]},{"line":"            type t = account_update","counters":[]},{"line":"","counters":[]},{"line":"            type call_forest = Call_forest.t","counters":[]},{"line":"","counters":[]},{"line":"            type 'a or_ignore = 'a Zkapp_basic.Or_ignore.Checked.t","counters":[]},{"line":"","counters":[]},{"line":"            type transaction_commitment = Transaction_commitment.t","counters":[]},{"line":"","counters":[]},{"line":"            let balance_change (t : t) = t.account_update.data.balance_change","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"","counters":[]},{"line":"            let protocol_state_precondition (t : t) =","counters":[]},{"line":"              t.account_update.data.preconditions.network","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"","counters":[]},{"line":"            let token_id (t : t) = t.account_update.data.token_id","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"            let public_key (t : t) = t.account_update.data.public_key","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"            let caller (t : t) = t.account_update.data.caller","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"","counters":[]},{"line":"            let account_id (t : t) =","counters":[]},{"line":"              Account_id.create (public_key t) (token_id t)","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":42,"col_end":42,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"","counters":[]},{"line":"            let use_full_commitment (t : t) =","counters":[]},{"line":"              t.account_update.data.use_full_commitment","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"","counters":[]},{"line":"            let increment_nonce (t : t) = t.account_update.data.increment_nonce","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"","counters":[]},{"line":"            let check_authorization ~commitment","counters":[]},{"line":"                ~calls:({ hash = calls; _ } : Call_forest.t)","counters":[]},{"line":"                ({ account_update; control; _ } : t) =","counters":[]},{"line":"              let proof_verifies =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                match auth_type with","counters":[]},{"line":"                | Proof ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    set_zkapp_input","counters":[]},{"line":"                      { account_update = (account_update.hash :> Field.t)","counters":[]},{"line":"                      ; calls = (calls :> Field.t)","counters":[]},{"line":"                      } ;","counters":[]},{"line":"                    Boolean.true_","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                | Signature | None_given ->","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"                    Boolean.false_","counters":[]},{"line":"              in","counters":[]},{"line":"              let signature_verifies =","counters":[]},{"line":"                match auth_type with","counters":[]},{"line":"                | None_given | Proof ->","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"                    Boolean.false_","counters":[]},{"line":"                | Signature ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    let signature =","counters":[]},{"line":"                      exists Signature_lib.Schnorr.Chunked.Signature.typ","counters":[]},{"line":"                        ~compute:(fun () ->","counters":[]},{"line":"                          match V.get control with","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                          | Signature s ->","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                              s","counters":[]},{"line":"                          | None_given ->","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                              Signature.dummy","counters":[]},{"line":"                          | Proof _ ->","counters":[]},{"line":"                              assert false )","counters":[]},{"line":"                    in","counters":[]},{"line":"                    run_checked","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"                      (let%bind (module S) =","counters":[]},{"line":"                         Tick.Inner_curve.Checked.Shifted.create ()","counters":[{"col_start":63,"col_end":63,"count":0}]},{"line":"                       in","counters":[]},{"line":"                       signature_verifies","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                         ~shifted:(module S)","counters":[]},{"line":"                         ~payload_digest:commitment signature","counters":[]},{"line":"                         account_update.data.public_key )","counters":[]},{"line":"              in","counters":[]},{"line":"              ( `Proof_verifies proof_verifies","counters":[]},{"line":"              , `Signature_verifies signature_verifies )","counters":[]},{"line":"","counters":[]},{"line":"            let is_proved ({ account_update; _ } : t) =","counters":[]},{"line":"              account_update.data.authorization_kind.is_proved","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"","counters":[]},{"line":"            let is_signed ({ account_update; _ } : t) =","counters":[]},{"line":"              account_update.data.authorization_kind.is_signed","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"","counters":[]},{"line":"            module Update = struct","counters":[]},{"line":"              open Zkapp_basic","counters":[]},{"line":"","counters":[]},{"line":"              type 'a set_or_keep = 'a Set_or_keep.Checked.t","counters":[]},{"line":"","counters":[]},{"line":"              let timing ({ account_update; _ } : t) :","counters":[]},{"line":"                  Account.timing set_or_keep =","counters":[]},{"line":"                Set_or_keep.Checked.map","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  ~f:Account_update.Update.Timing_info.Checked.to_account_timing","counters":[]},{"line":"                  account_update.data.update.timing","counters":[]},{"line":"","counters":[]},{"line":"              let app_state ({ account_update; _ } : t) =","counters":[]},{"line":"                account_update.data.update.app_state","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"","counters":[]},{"line":"              let verification_key ({ account_update; _ } : t) =","counters":[]},{"line":"                account_update.data.update.verification_key","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"","counters":[]},{"line":"              let sequence_events ({ account_update; _ } : t) =","counters":[]},{"line":"                account_update.data.sequence_events","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"","counters":[]},{"line":"              let zkapp_uri ({ account_update; _ } : t) =","counters":[]},{"line":"                account_update.data.update.zkapp_uri","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"","counters":[]},{"line":"              let token_symbol ({ account_update; _ } : t) =","counters":[]},{"line":"                account_update.data.update.token_symbol","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"","counters":[]},{"line":"              let delegate ({ account_update; _ } : t) =","counters":[]},{"line":"                account_update.data.update.delegate","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"","counters":[]},{"line":"              let voting_for ({ account_update; _ } : t) =","counters":[]},{"line":"                account_update.data.update.voting_for","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"","counters":[]},{"line":"              let permissions ({ account_update; _ } : t) =","counters":[]},{"line":"                account_update.data.update.permissions","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"            end","counters":[]},{"line":"","counters":[]},{"line":"            module Account_precondition = struct","counters":[]},{"line":"              let nonce ({ account_update; _ } : t) =","counters":[]},{"line":"                account_update.data.preconditions.account.nonce","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"            end","counters":[]},{"line":"          end","counters":[]},{"line":"","counters":[]},{"line":"          module Set_or_keep = struct","counters":[]},{"line":"            include Zkapp_basic.Set_or_keep.Checked","counters":[]},{"line":"          end","counters":[]},{"line":"","counters":[]},{"line":"          module Global_state = struct","counters":[]},{"line":"            include Global_state","counters":[]},{"line":"","counters":[]},{"line":"            let fee_excess { fee_excess; _ } = fee_excess","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"","counters":[]},{"line":"            let set_fee_excess t fee_excess = { t with fee_excess }","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"","counters":[]},{"line":"            let supply_increase { supply_increase; _ } = supply_increase","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"","counters":[]},{"line":"            let set_supply_increase t supply_increase =","counters":[]},{"line":"              { t with supply_increase }","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"","counters":[]},{"line":"            let ledger { ledger; _ } = ledger","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"            let set_ledger ~should_update t ledger =","counters":[]},{"line":"              { t with","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ledger = Ledger.if_ should_update ~then_:ledger ~else_:t.ledger","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"              }","counters":[]},{"line":"","counters":[]},{"line":"            let global_slot_since_genesis { protocol_state; _ } =","counters":[]},{"line":"              protocol_state.global_slot_since_genesis","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"          end","counters":[]},{"line":"","counters":[]},{"line":"          module Nonce_precondition = struct","counters":[]},{"line":"            let is_constant =","counters":[]},{"line":"              Zkapp_precondition.Numeric.Checked.is_constant","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"                Zkapp_precondition.Numeric.Tc.nonce","counters":[]},{"line":"          end","counters":[]},{"line":"","counters":[]},{"line":"          let with_label ~label f = with_label label f","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"        end","counters":[]},{"line":"","counters":[]},{"line":"        module Env = struct","counters":[]},{"line":"          open Inputs","counters":[]},{"line":"","counters":[]},{"line":"          type t =","counters":[]},{"line":"            < account_update : Account_update.t","counters":[]},{"line":"            ; account : Account.t","counters":[]},{"line":"            ; ledger : Ledger.t","counters":[]},{"line":"            ; amount : Amount.t","counters":[]},{"line":"            ; signed_amount : Amount.Signed.t","counters":[]},{"line":"            ; bool : Bool.t","counters":[]},{"line":"            ; token_id : Token_id.t","counters":[]},{"line":"            ; global_state : Global_state.t","counters":[]},{"line":"            ; inclusion_proof : (Bool.t * Field.t) list","counters":[]},{"line":"            ; zkapp_command : Zkapp_command.t","counters":[]},{"line":"            ; local_state :","counters":[]},{"line":"                ( Stack_frame.t","counters":[]},{"line":"                , Call_stack.t","counters":[]},{"line":"                , Token_id.t","counters":[]},{"line":"                , Amount.Signed.t","counters":[]},{"line":"                , Ledger.t","counters":[]},{"line":"                , Bool.t","counters":[]},{"line":"                , Transaction_commitment.t","counters":[]},{"line":"                , Index.t","counters":[]},{"line":"                , unit )","counters":[]},{"line":"                Mina_transaction_logic.Zkapp_command_logic.Local_state.t","counters":[]},{"line":"            ; protocol_state_precondition :","counters":[]},{"line":"                Zkapp_precondition.Protocol_state.Checked.t","counters":[]},{"line":"            ; transaction_commitment : Transaction_commitment.t","counters":[]},{"line":"            ; full_transaction_commitment : Transaction_commitment.t","counters":[]},{"line":"            ; field : Field.t","counters":[]},{"line":"            ; failure : unit >","counters":[]},{"line":"        end","counters":[]},{"line":"","counters":[]},{"line":"        include Mina_transaction_logic.Zkapp_command_logic.Make (Inputs)","counters":[]},{"line":"","counters":[]},{"line":"        let perform (type r)","counters":[]},{"line":"            (eff : (r, Env.t) Mina_transaction_logic.Zkapp_command_logic.Eff.t)","counters":[]},{"line":"            : r =","counters":[]},{"line":"          match eff with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | Check_protocol_state_precondition","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (protocol_state_predicate, global_state) ->","counters":[]},{"line":"              Zkapp_precondition.Protocol_state.Checked.check","counters":[]},{"line":"                protocol_state_predicate global_state.protocol_state","counters":[]},{"line":"          | Check_account_precondition","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              ({ account_update; _ }, account, new_account, local_state) ->","counters":[]},{"line":"              let local_state = ref local_state in","counters":[]},{"line":"              let check failure b =","counters":[]},{"line":"                local_state :=","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Inputs.Local_state.add_check !local_state failure b","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"              in","counters":[]},{"line":"              Zkapp_precondition.Account.Checked.check ~new_account ~check","counters":[]},{"line":"                account_update.data.preconditions.account account.data ;","counters":[]},{"line":"              !local_state","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"          | Init_account { account_update = { account_update; _ }; account } ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let account' : Account.Checked.Unhashed.t =","counters":[]},{"line":"                { account.data with","counters":[]},{"line":"                  public_key = account_update.data.public_key","counters":[]},{"line":"                ; token_id = account_update.data.token_id","counters":[]},{"line":"                }","counters":[]},{"line":"              in","counters":[]},{"line":"              Inputs.Account.account_with_hash account'","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      let check_protocol_state ~pending_coinbase_stack_init","counters":[]},{"line":"          ~pending_coinbase_stack_before ~pending_coinbase_stack_after","counters":[]},{"line":"          state_body =","counters":[]},{"line":"        [%with_label_ \"Compute pending coinbase stack\"] (fun () ->","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":53,"col_end":53,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"            let%bind state_body_hash =","counters":[]},{"line":"              Mina_state.Protocol_state.Body.hash_checked state_body","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"            in","counters":[]},{"line":"            let%bind computed_pending_coinbase_stack_after =","counters":[]},{"line":"              Pending_coinbase.Stack.Checked.push_state state_body_hash","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"                pending_coinbase_stack_init","counters":[]},{"line":"            in","counters":[]},{"line":"            [%with_label_ \"Check pending coinbase stack\"] (fun () ->","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":55,"col_end":55,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"                let%bind correct_coinbase_target_stack =","counters":[]},{"line":"                  Pending_coinbase.Stack.equal_var","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"                    computed_pending_coinbase_stack_after","counters":[]},{"line":"                    pending_coinbase_stack_after","counters":[]},{"line":"                in","counters":[]},{"line":"                let%bind valid_init_state =","counters":[]},{"line":"                  (* Stack update is performed once per scan state tree and the","counters":[]},{"line":"                     following is true only for the first transaction per block per","counters":[]},{"line":"                     tree*)","counters":[]},{"line":"                  let%bind equal_source =","counters":[]},{"line":"                    Pending_coinbase.Stack.equal_var pending_coinbase_stack_init","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                      pending_coinbase_stack_before","counters":[]},{"line":"                  in","counters":[]},{"line":"                  (*for the rest, both source and target are the same*)","counters":[]},{"line":"                  let%bind equal_source_with_state =","counters":[]},{"line":"                    Pending_coinbase.Stack.equal_var","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                      computed_pending_coinbase_stack_after","counters":[]},{"line":"                      pending_coinbase_stack_before","counters":[]},{"line":"                  in","counters":[]},{"line":"                  Boolean.(equal_source ||| equal_source_with_state)","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                in","counters":[]},{"line":"                Boolean.Assert.all","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  [ correct_coinbase_target_stack; valid_init_state ] ) )","counters":[]},{"line":"","counters":[]},{"line":"      let main ?(witness : Witness.t option) (spec : Spec.t)","counters":[]},{"line":"          ~constraint_constants (statement : Statement.With_sok.Checked.t) =","counters":[]},{"line":"        let open Impl in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        run_checked (dummy_constraints ()) ;","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"        let ( ! ) x = Option.value_exn x in","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"        let state_body =","counters":[]},{"line":"          exists (Mina_state.Protocol_state.Body.typ ~constraint_constants)","counters":[]},{"line":"            ~compute:(fun () -> !witness.state_body)","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"        in","counters":[]},{"line":"        let pending_coinbase_stack_init =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          exists Pending_coinbase.Stack.typ ~compute:(fun () ->","counters":[]},{"line":"              !witness.init_stack )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"        in","counters":[]},{"line":"        let module V = Prover_value in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        run_checked","counters":[]},{"line":"          (check_protocol_state ~pending_coinbase_stack_init","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"             ~pending_coinbase_stack_before:","counters":[]},{"line":"               statement.source.pending_coinbase_stack","counters":[]},{"line":"             ~pending_coinbase_stack_after:","counters":[]},{"line":"               statement.target.pending_coinbase_stack state_body ) ;","counters":[]},{"line":"        let init :","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            Global_state.t","counters":[]},{"line":"            * _ Mina_transaction_logic.Zkapp_command_logic.Local_state.t =","counters":[]},{"line":"          let g : Global_state.t =","counters":[]},{"line":"            { ledger =","counters":[]},{"line":"                ( statement.source.ledger","counters":[]},{"line":"                , V.create (fun () -> !witness.global_ledger) )","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"            ; fee_excess = Amount.Signed.(Checked.constant zero)","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"            ; supply_increase = Amount.Signed.(Checked.constant zero)","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"            ; protocol_state =","counters":[]},{"line":"                Mina_state.Protocol_state.Body.view_checked state_body","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"            }","counters":[]},{"line":"          in","counters":[]},{"line":"          let l : _ Mina_transaction_logic.Zkapp_command_logic.Local_state.t =","counters":[]},{"line":"            { stack_frame =","counters":[]},{"line":"                Inputs.Stack_frame.unhash","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"                  statement.source.local_state.stack_frame","counters":[]},{"line":"                  (V.create (fun () -> !witness.local_state_init.stack_frame))","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"            ; call_stack =","counters":[]},{"line":"                { With_hash.hash = statement.source.local_state.call_stack","counters":[]},{"line":"                ; data =","counters":[]},{"line":"                    V.create (fun () -> !witness.local_state_init.call_stack)","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"                }","counters":[]},{"line":"            ; transaction_commitment =","counters":[]},{"line":"                statement.source.local_state.transaction_commitment","counters":[]},{"line":"            ; full_transaction_commitment =","counters":[]},{"line":"                statement.source.local_state.full_transaction_commitment","counters":[]},{"line":"            ; token_id = statement.source.local_state.token_id","counters":[]},{"line":"            ; excess = statement.source.local_state.excess","counters":[]},{"line":"            ; supply_increase = statement.source.local_state.supply_increase","counters":[]},{"line":"            ; ledger =","counters":[]},{"line":"                ( statement.source.local_state.ledger","counters":[]},{"line":"                , V.create (fun () -> !witness.local_state_init.ledger) )","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"            ; success = statement.source.local_state.success","counters":[]},{"line":"            ; account_update_index =","counters":[]},{"line":"                statement.source.local_state.account_update_index","counters":[]},{"line":"            ; failure_status_tbl = ()","counters":[]},{"line":"            }","counters":[]},{"line":"          in","counters":[]},{"line":"          (g, l)","counters":[]},{"line":"        in","counters":[]},{"line":"        let start_zkapp_command =","counters":[]},{"line":"          As_prover.Ref.create (fun () -> !witness.start_zkapp_command)","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"        in","counters":[]},{"line":"        let zkapp_input = ref None in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let global, local =","counters":[]},{"line":"          List.fold_left spec ~init","counters":[]},{"line":"            ~f:(fun ((_, local) as acc) account_update_spec ->","counters":[]},{"line":"              let module S = Single (struct","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                let constraint_constants = constraint_constants","counters":[]},{"line":"","counters":[]},{"line":"                let spec = account_update_spec","counters":[]},{"line":"","counters":[]},{"line":"                let set_zkapp_input x = zkapp_input := Some x","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"              end) in","counters":[]},{"line":"              let finish v =","counters":[]},{"line":"                let open Mina_transaction_logic.Zkapp_command_logic.Start_data in","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                let ps =","counters":[]},{"line":"                  V.map v ~f:(function","counters":[]},{"line":"                    | `Skip ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        []","counters":[]},{"line":"                    | `Start p ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        Zkapp_command.zkapp_command p.zkapp_command )","counters":[]},{"line":"                in","counters":[]},{"line":"                let h =","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  exists Zkapp_command.Digest.Forest.typ ~compute:(fun () ->","counters":[]},{"line":"                      Zkapp_command.Call_forest.hash (V.get ps) )","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"                in","counters":[]},{"line":"                let start_data =","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  { Mina_transaction_logic.Zkapp_command_logic.Start_data","counters":[]},{"line":"                    .zkapp_command = { With_hash.hash = h; data = ps }","counters":[]},{"line":"                  ; memo_hash =","counters":[]},{"line":"                      exists Field.typ ~compute:(fun () ->","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                          match V.get v with","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                          | `Skip ->","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                              Field.Constant.zero","counters":[]},{"line":"                          | `Start p ->","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                              p.memo_hash )","counters":[]},{"line":"                  }","counters":[]},{"line":"                in","counters":[]},{"line":"                let global_state, local_state =","counters":[]},{"line":"                  with_label \"apply\" (fun () ->","counters":[]},{"line":"                      S.apply ~constraint_constants","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        ~is_start:","counters":[]},{"line":"                          ( match account_update_spec.is_start with","counters":[]},{"line":"                          | `No ->","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                              `No","counters":[]},{"line":"                          | `Yes ->","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                              `Yes start_data","counters":[]},{"line":"                          | `Compute_in_circuit ->","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                              `Compute start_data )","counters":[]},{"line":"                        S.{ perform }","counters":[]},{"line":"                        acc )","counters":[]},{"line":"                in","counters":[]},{"line":"                (global_state, local_state)","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"              in","counters":[]},{"line":"              let acc' =","counters":[]},{"line":"                match account_update_spec.is_start with","counters":[]},{"line":"                | `No ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    let global_state, local_state =","counters":[]},{"line":"                      S.apply ~constraint_constants ~is_start:`No","counters":[]},{"line":"                        S.{ perform }","counters":[]},{"line":"                        acc","counters":[]},{"line":"                    in","counters":[]},{"line":"                    (global_state, local_state)","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                | `Compute_in_circuit ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    V.create (fun () ->","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                        match As_prover.Ref.get start_zkapp_command with","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                        | [] ->","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            `Skip","counters":[]},{"line":"                        | p :: ps ->","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            let should_pop =","counters":[]},{"line":"                              Mina_base.Zkapp_command.Call_forest.is_empty","counters":[]},{"line":"                                (V.get local.stack_frame.data.calls.data)","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                            in","counters":[]},{"line":"                            if should_pop then (","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"                              As_prover.Ref.set start_zkapp_command ps ;","counters":[]},{"line":"                              `Start p )","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                            else `Skip )","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"                    |> finish","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                | `Yes ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    as_prover (fun () ->","counters":[]},{"line":"                        assert (","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                          Mina_base.Zkapp_command.Call_forest.is_empty","counters":[{"col_start":69,"col_end":69,"count":0}]},{"line":"                            (V.get local.stack_frame.data.calls.data) ) ) ;","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"                    V.create (fun () ->","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                        match As_prover.Ref.get start_zkapp_command with","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                        | [] ->","counters":[]},{"line":"                            assert false","counters":[]},{"line":"                        | p :: ps ->","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            As_prover.Ref.set start_zkapp_command ps ;","counters":[]},{"line":"                            `Start p )","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                    |> finish","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"              in","counters":[]},{"line":"              acc' )","counters":[]},{"line":"        in","counters":[]},{"line":"        let local_state_ledger =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (* The actual output ledger may differ from the one generated by","counters":[]},{"line":"             transaction logic, because we handle failures differently between","counters":[]},{"line":"             the two. However, in the case of failure, we never use this ledger:","counters":[]},{"line":"             it will never be upgraded to the global ledger. If we have such a","counters":[]},{"line":"             failure, we just pretend we achieved the target hash.","counters":[]},{"line":"          *)","counters":[]},{"line":"          Stack_frame.Digest.Checked.if_ local.success","counters":[]},{"line":"            ~then_:(Inputs.Stack_frame.hash local.stack_frame)","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"            ~else_:statement.target.local_state.stack_frame","counters":[]},{"line":"        in","counters":[]},{"line":"        with_label __LOC__ (fun () ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            Local_state.Checked.assert_equal statement.target.local_state","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              { local with","counters":[]},{"line":"                stack_frame = local_state_ledger","counters":[]},{"line":"              ; call_stack = local.call_stack.hash","counters":[]},{"line":"              ; ledger = fst local.ledger","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"              } ) ;","counters":[]},{"line":"        with_label __LOC__ (fun () ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            run_checked","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (Frozen_ledger_hash.assert_equal (fst global.ledger)","counters":[{"col_start":45,"col_end":45,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"                 statement.target.ledger ) ) ;","counters":[]},{"line":"        with_label __LOC__ (fun () ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            run_checked","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (Amount.Signed.Checked.assert_equal statement.supply_increase","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"                 global.supply_increase ) ) ;","counters":[]},{"line":"        with_label __LOC__ (fun () ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            run_checked","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (let expected = statement.fee_excess in","counters":[]},{"line":"               let got : Fee_excess.var =","counters":[]},{"line":"                 { fee_token_l = Token_id.(Checked.constant default)","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"                 ; fee_excess_l = Amount.Signed.Checked.to_fee global.fee_excess","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"                 ; fee_token_r = Token_id.(Checked.constant default)","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"                 ; fee_excess_r =","counters":[]},{"line":"                     Amount.Signed.Checked.to_fee (fst init).fee_excess","counters":[{"col_start":48,"col_end":48,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"                 }","counters":[]},{"line":"               in","counters":[]},{"line":"               Fee_excess.assert_equal_checked expected got ) ) ;","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"        Stdlib.( ! ) zkapp_input","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      (* Horrible hack :( *)","counters":[]},{"line":"      let witness : Witness.t option ref = ref None","counters":[]},{"line":"","counters":[]},{"line":"      let rule (type a b c d) ~constraint_constants ~proof_level","counters":[]},{"line":"          (t : (a, b, c, d) Basic.t_typed) :","counters":[]},{"line":"          ( a","counters":[]},{"line":"          , b","counters":[]},{"line":"          , c","counters":[]},{"line":"          , d","counters":[]},{"line":"          , Statement.With_sok.var","counters":[]},{"line":"          , Statement.With_sok.t","counters":[]},{"line":"          , unit","counters":[]},{"line":"          , unit","counters":[]},{"line":"          , unit","counters":[]},{"line":"          , unit )","counters":[]},{"line":"          Pickles.Inductive_rule.t =","counters":[]},{"line":"        let open Hlist in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let open Basic in","counters":[]},{"line":"        let module M = H4.T (Pickles.Tag) in","counters":[]},{"line":"        let s = Basic.spec t in","counters":[]},{"line":"        let prev_should_verify =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          match proof_level with","counters":[]},{"line":"          | Genesis_constants.Proof_level.Full ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              true","counters":[]},{"line":"          | _ ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              false","counters":[]},{"line":"        in","counters":[]},{"line":"        let b = Boolean.var_of_value prev_should_verify in","counters":[]},{"line":"        match t with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | Proved ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            { identifier = \"proved\"","counters":[]},{"line":"            ; prevs = M.[ side_loaded 0 ]","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"            ; main =","counters":[]},{"line":"                (fun { public_input = stmt } ->","counters":[]},{"line":"                  let zkapp_input =","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    main ?witness:!witness s ~constraint_constants stmt","counters":[]},{"line":"                  in","counters":[]},{"line":"                  let proof =","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    Run.exists (Typ.Internal.ref ()) ~request:(fun () ->","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"                        Zkapp_proof )","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                  in","counters":[]},{"line":"                  { previous_proof_statements =","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                      [ { public_input = Option.value_exn zkapp_input","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"                        ; proof","counters":[]},{"line":"                        ; proof_must_verify = b","counters":[]},{"line":"                        }","counters":[]},{"line":"                      ]","counters":[]},{"line":"                  ; public_output = ()","counters":[]},{"line":"                  ; auxiliary_output = ()","counters":[]},{"line":"                  } )","counters":[]},{"line":"            ; uses_lookup = false","counters":[]},{"line":"            }","counters":[]},{"line":"        | Opt_signed_opt_signed ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            { identifier = \"opt_signed-opt_signed\"","counters":[]},{"line":"            ; prevs = M.[]","counters":[]},{"line":"            ; main =","counters":[]},{"line":"                (fun { public_input = stmt } ->","counters":[]},{"line":"                  let zkapp_input_opt =","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    main ?witness:!witness s ~constraint_constants stmt","counters":[]},{"line":"                  in","counters":[]},{"line":"                  assert (Option.is_none zkapp_input_opt) ;","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"                  { previous_proof_statements = []","counters":[]},{"line":"                  ; public_output = ()","counters":[]},{"line":"                  ; auxiliary_output = ()","counters":[]},{"line":"                  } )","counters":[]},{"line":"            ; uses_lookup = false","counters":[]},{"line":"            }","counters":[]},{"line":"        | Opt_signed ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            { identifier = \"opt_signed\"","counters":[]},{"line":"            ; prevs = M.[]","counters":[]},{"line":"            ; main =","counters":[]},{"line":"                (fun { public_input = stmt } ->","counters":[]},{"line":"                  let zkapp_input_opt =","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    main ?witness:!witness s ~constraint_constants stmt","counters":[]},{"line":"                  in","counters":[]},{"line":"                  assert (Option.is_none zkapp_input_opt) ;","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"                  { previous_proof_statements = []","counters":[]},{"line":"                  ; public_output = ()","counters":[]},{"line":"                  ; auxiliary_output = ()","counters":[]},{"line":"                  } )","counters":[]},{"line":"            ; uses_lookup = false","counters":[]},{"line":"            }","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    type _ Snarky_backendless.Request.t +=","counters":[]},{"line":"      | Transaction : Transaction_union.t Snarky_backendless.Request.t","counters":[]},{"line":"      | State_body :","counters":[]},{"line":"          Mina_state.Protocol_state.Body.Value.t Snarky_backendless.Request.t","counters":[]},{"line":"      | Init_stack : Pending_coinbase.Stack.t Snarky_backendless.Request.t","counters":[]},{"line":"","counters":[]},{"line":"    let%snarkydef_ add_burned_tokens acc_burned_tokens amount","counters":[]},{"line":"        ~is_coinbase_or_fee_transfer ~update_account =","counters":[]},{"line":"      let%bind accumulate_burned_tokens =","counters":[]},{"line":"        Boolean.all [ is_coinbase_or_fee_transfer; Boolean.not update_account ]","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"      in","counters":[]},{"line":"      let%bind amt, `Overflow overflow =","counters":[]},{"line":"        Amount.Checked.add_flagged acc_burned_tokens amount","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"      in","counters":[]},{"line":"      let%bind () =","counters":[]},{"line":"        Boolean.(Assert.any [ not accumulate_burned_tokens; not overflow ])","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"      in","counters":[]},{"line":"      Amount.Checked.if_ accumulate_burned_tokens ~then_:amt","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ~else_:acc_burned_tokens","counters":[]},{"line":"","counters":[]},{"line":"    let%snarkydef_ apply_tagged_transaction","counters":[]},{"line":"        ~(constraint_constants : Genesis_constants.Constraint_constants.t)","counters":[]},{"line":"        (type shifted)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        (shifted : (module Inner_curve.Checked.Shifted.S with type t = shifted))","counters":[]},{"line":"        root pending_coinbase_stack_init pending_coinbase_stack_before","counters":[]},{"line":"        pending_coinbase_after state_body","counters":[]},{"line":"        ({ signer; signature; payload } as txn : Transaction_union.var) =","counters":[]},{"line":"      let tag = payload.body.tag in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let is_user_command =","counters":[]},{"line":"        Transaction_union.Tag.Unpacked.is_user_command tag","counters":[]},{"line":"      in","counters":[]},{"line":"      let%bind () =","counters":[]},{"line":"        [%with_label_ \"Check transaction signature\"] (fun () ->","counters":[{"col_start":50,"col_end":50,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"            check_signature shifted ~payload ~is_user_command ~signer ~signature )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"      in","counters":[]},{"line":"      let%bind signer_pk = Public_key.compress_var signer in","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"      let%bind () =","counters":[]},{"line":"        [%with_label_ \"Fee-payer must sign the transaction\"] (fun () ->","counters":[{"col_start":58,"col_end":58,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"            (* TODO: Enable multi-sig. *)","counters":[]},{"line":"            Public_key.Compressed.Checked.Assert.equal signer_pk","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              payload.common.fee_payer_pk )","counters":[]},{"line":"      in","counters":[]},{"line":"      (* Compute transaction kind. *)","counters":[]},{"line":"      let is_payment = Transaction_union.Tag.Unpacked.is_payment tag in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let is_mint_tokens = Transaction_union.Tag.Unpacked.is_mint_tokens tag in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let is_stake_delegation =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Transaction_union.Tag.Unpacked.is_stake_delegation tag","counters":[]},{"line":"      in","counters":[]},{"line":"      let is_create_account =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Transaction_union.Tag.Unpacked.is_create_account tag","counters":[]},{"line":"      in","counters":[]},{"line":"      let is_fee_transfer =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Transaction_union.Tag.Unpacked.is_fee_transfer tag","counters":[]},{"line":"      in","counters":[]},{"line":"      let is_coinbase = Transaction_union.Tag.Unpacked.is_coinbase tag in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let fee_token = payload.common.fee_token in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%bind fee_token_default =","counters":[]},{"line":"        make_checked (fun () ->","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"            Token_id.(Checked.equal fee_token (Checked.constant default)) )","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"      in","counters":[]},{"line":"      let token = payload.body.token_id in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%bind token_default =","counters":[]},{"line":"        make_checked (fun () ->","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"            Token_id.(Checked.equal token (Checked.constant default)) )","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"      in","counters":[]},{"line":"      let%bind () =","counters":[]},{"line":"        Checked.all_unit","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"          [ [%with_label_","counters":[]},{"line":"              \"Token_locked value is compatible with the transaction kind\"]","counters":[{"col_start":73,"col_end":73,"count":0},{"col_start":74,"col_end":74,"count":0}]},{"line":"              (fun () ->","counters":[]},{"line":"                Boolean.Assert.any","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  [ Boolean.not payload.body.token_locked; is_create_account ] )","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"          ; [%with_label_ \"Token_locked cannot be used with the default token\"]","counters":[{"col_start":77,"col_end":77,"count":0},{"col_start":78,"col_end":78,"count":0}]},{"line":"              (fun () ->","counters":[]},{"line":"                Boolean.Assert.any","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  [ Boolean.not payload.body.token_locked","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                  ; Boolean.not token_default","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                  ] )","counters":[]},{"line":"          ]","counters":[]},{"line":"      in","counters":[]},{"line":"      let%bind () = Boolean.Assert.is_true token_default in","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"      let%bind () =","counters":[]},{"line":"        [%with_label_ \"Validate tokens\"] (fun () ->","counters":[{"col_start":38,"col_end":38,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"            Checked.all_unit","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              [ [%with_label_","counters":[]},{"line":"                  \"Fee token is default or command allows non-default fee\"]","counters":[{"col_start":73,"col_end":73,"count":0},{"col_start":74,"col_end":74,"count":0}]},{"line":"                  (fun () ->","counters":[]},{"line":"                    Boolean.Assert.any","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      [ fee_token_default","counters":[]},{"line":"                      ; is_payment","counters":[]},{"line":"                      ; is_stake_delegation","counters":[]},{"line":"                      ; is_fee_transfer","counters":[]},{"line":"                      ] )","counters":[]},{"line":"              ; (* TODO: Remove this check and update the transaction snark once we","counters":[]},{"line":"                   have an exchange rate mechanism. See issue #4447.","counters":[]},{"line":"                *)","counters":[]},{"line":"                [%with_label_ \"Fees in tokens disabled\"] (fun () ->","counters":[{"col_start":54,"col_end":54,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"                    Boolean.Assert.is_true fee_token_default )","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"              ; [%with_label_ \"Command allows default token\"]","counters":[{"col_start":59,"col_end":59,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"                  Boolean.(","counters":[]},{"line":"                    fun () ->","counters":[]},{"line":"                      Assert.any","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        [ is_payment","counters":[]},{"line":"                        ; is_stake_delegation","counters":[]},{"line":"                        ; is_create_account","counters":[]},{"line":"                        ; is_fee_transfer","counters":[]},{"line":"                        ; is_coinbase","counters":[]},{"line":"                        ])","counters":[]},{"line":"              ] )","counters":[]},{"line":"      in","counters":[]},{"line":"      let current_global_slot =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Mina_state.Protocol_state.Body.consensus_state state_body","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"        |> Consensus.Data.Consensus_state.global_slot_since_genesis_var","counters":[]},{"line":"      in","counters":[]},{"line":"      (* Query predicted failure/success. *)","counters":[]},{"line":"      let%bind user_command_failure =","counters":[]},{"line":"        User_command_failure.compute_as_prover ~constraint_constants","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"          ~txn_global_slot:current_global_slot txn","counters":[]},{"line":"      in","counters":[]},{"line":"      let%bind user_command_fails =","counters":[]},{"line":"        User_command_failure.any user_command_failure","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"      in","counters":[]},{"line":"      let fee = payload.common.fee in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let receiver = Account_id.Checked.create payload.body.receiver_pk token in","counters":[]},{"line":"      let source = Account_id.Checked.create payload.body.source_pk token in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      (* Information for the fee-payer. *)","counters":[]},{"line":"      let nonce = payload.common.nonce in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let fee_payer =","counters":[]},{"line":"        Account_id.Checked.create payload.common.fee_payer_pk fee_token","counters":[]},{"line":"      in","counters":[]},{"line":"      let%bind () =","counters":[]},{"line":"        [%with_label_ \"Check slot validity\"] (fun () ->","counters":[{"col_start":42,"col_end":42,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"            Global_slot.Checked.(","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              current_global_slot <= payload.common.valid_until)","counters":[]},{"line":"            >>= Boolean.Assert.is_true )","counters":[]},{"line":"      in","counters":[]},{"line":"","counters":[]},{"line":"      (* Check coinbase stack. Protocol state body is pushed into the Pending","counters":[]},{"line":"         coinbase stack once per block. For example, consider any two","counters":[]},{"line":"         transactions in a block. Their pending coinbase stacks would be:","counters":[]},{"line":"","counters":[]},{"line":"         transaction1: s1 -> t1 = s1+ protocol_state_body + maybe_coinbase","counters":[]},{"line":"         transaction2: t1 -> t1 + maybe_another_coinbase","counters":[]},{"line":"           (Note: protocol_state_body is not pushed again)","counters":[]},{"line":"","counters":[]},{"line":"         However, for each transaction, we need to constrain the protocol state","counters":[]},{"line":"         body. This is done is by using the stack ([init_stack]) without the","counters":[]},{"line":"         current protocol state body, pushing the state body to it in every","counters":[]},{"line":"         transaction snark and checking if it matches the target.","counters":[]},{"line":"         We also need to constrain the source for the merges to work correctly.","counters":[]},{"line":"         Basically,","counters":[]},{"line":"","counters":[]},{"line":"         init_stack + protocol_state_body + maybe_coinbase = target","counters":[]},{"line":"         AND","counters":[]},{"line":"         init_stack = source || init_stack + protocol_state_body = source *)","counters":[]},{"line":"","counters":[]},{"line":"      (* These are all the possible cases:","counters":[]},{"line":"","counters":[]},{"line":"          Init_stack     Source                 Target","counters":[]},{"line":"         --------------------------------------------------------------","counters":[]},{"line":"           i               i                       i + state","counters":[]},{"line":"           i               i                       i + state + coinbase","counters":[]},{"line":"           i               i + state               i + state","counters":[]},{"line":"           i               i + state               i + state + coinbase","counters":[]},{"line":"           i + coinbase    i + state + coinbase    i + state + coinbase","counters":[]},{"line":"      *)","counters":[]},{"line":"      let%bind () =","counters":[]},{"line":"        [%with_label_ \"Compute coinbase stack\"] (fun () ->","counters":[{"col_start":45,"col_end":45,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"            let%bind state_body_hash =","counters":[]},{"line":"              Mina_state.Protocol_state.Body.hash_checked state_body","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"            in","counters":[]},{"line":"            let%bind pending_coinbase_stack_with_state =","counters":[]},{"line":"              Pending_coinbase.Stack.Checked.push_state state_body_hash","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"                pending_coinbase_stack_init","counters":[]},{"line":"            in","counters":[]},{"line":"            let%bind computed_pending_coinbase_stack_after =","counters":[]},{"line":"              let coinbase =","counters":[]},{"line":"                (Account_id.Checked.public_key receiver, payload.body.amount)","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"              in","counters":[]},{"line":"              let%bind stack' =","counters":[]},{"line":"                Pending_coinbase.Stack.Checked.push_coinbase coinbase","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"                  pending_coinbase_stack_with_state","counters":[]},{"line":"              in","counters":[]},{"line":"              Pending_coinbase.Stack.Checked.if_ is_coinbase ~then_:stack'","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ~else_:pending_coinbase_stack_with_state","counters":[]},{"line":"            in","counters":[]},{"line":"            [%with_label_ \"Check coinbase stack\"] (fun () ->","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":47,"col_end":47,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"                let%bind correct_coinbase_target_stack =","counters":[]},{"line":"                  Pending_coinbase.Stack.equal_var","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"                    computed_pending_coinbase_stack_after pending_coinbase_after","counters":[]},{"line":"                in","counters":[]},{"line":"                let%bind valid_init_state =","counters":[]},{"line":"                  let%bind equal_source =","counters":[]},{"line":"                    Pending_coinbase.Stack.equal_var pending_coinbase_stack_init","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                      pending_coinbase_stack_before","counters":[]},{"line":"                  in","counters":[]},{"line":"                  let%bind equal_source_with_state =","counters":[]},{"line":"                    Pending_coinbase.Stack.equal_var","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                      pending_coinbase_stack_with_state","counters":[]},{"line":"                      pending_coinbase_stack_before","counters":[]},{"line":"                  in","counters":[]},{"line":"                  Boolean.(equal_source ||| equal_source_with_state)","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                in","counters":[]},{"line":"                [%with_label_ \"target stack and valid init state\"] (fun () ->","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":64,"col_end":64,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"                    Boolean.Assert.all","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      [ correct_coinbase_target_stack; valid_init_state ] ) ) )","counters":[]},{"line":"      in","counters":[]},{"line":"      (* Interrogate failure cases. This value is created without constraints;","counters":[]},{"line":"         the failures should be checked against potential failures to ensure","counters":[]},{"line":"         consistency.","counters":[]},{"line":"      *)","counters":[]},{"line":"      let%bind () =","counters":[]},{"line":"        [%with_label_ \"A failing user command is a user command\"]","counters":[{"col_start":63,"col_end":63,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"          Boolean.(","counters":[]},{"line":"            fun () -> Assert.any [ is_user_command; not user_command_fails ])","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"      in","counters":[]},{"line":"      let predicate_deferred =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (* Account_precondition check is to be performed later if this is true. *)","counters":[]},{"line":"        is_create_account","counters":[]},{"line":"      in","counters":[]},{"line":"      let%bind predicate_result =","counters":[]},{"line":"        let%bind is_own_account =","counters":[]},{"line":"          Public_key.Compressed.Checked.equal payload.common.fee_payer_pk","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"            payload.body.source_pk","counters":[]},{"line":"        in","counters":[]},{"line":"        let predicate_result =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (* TODO: Predicates. *)","counters":[]},{"line":"          Boolean.false_","counters":[]},{"line":"        in","counters":[]},{"line":"        Boolean.(is_own_account ||| predicate_result)","counters":[]},{"line":"      in","counters":[]},{"line":"      let%bind () =","counters":[]},{"line":"        [%with_label_ \"Check account_precondition failure against predicted\"]","counters":[{"col_start":75,"col_end":75,"count":0},{"col_start":76,"col_end":76,"count":0}]},{"line":"          (fun () ->","counters":[]},{"line":"            let%bind predicate_failed =","counters":[]},{"line":"              Boolean.((not predicate_result) &&& not predicate_deferred)","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"            in","counters":[]},{"line":"            assert_r1cs","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (predicate_failed :> Field.Var.t)","counters":[]},{"line":"              (is_user_command :> Field.Var.t)","counters":[]},{"line":"              (user_command_failure.predicate_failed :> Field.Var.t) )","counters":[]},{"line":"      in","counters":[]},{"line":"      let account_creation_amount =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Amount.Checked.of_fee","counters":[]},{"line":"          Fee.(var_of_t constraint_constants.account_creation_fee)","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"      in","counters":[]},{"line":"      let%bind is_zero_fee = Fee.(equal_var fee (var_of_t zero)) in","counters":[{"col_start":42,"col_end":42,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"      let is_coinbase_or_fee_transfer = Boolean.not is_user_command in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%bind can_create_fee_payer_account =","counters":[]},{"line":"        (* Fee transfers and coinbases may create an account. We check the normal","counters":[]},{"line":"           invariants to ensure that the account creation fee is paid.","counters":[]},{"line":"        *)","counters":[]},{"line":"        let%bind fee_may_be_charged =","counters":[]},{"line":"          (* If the fee is zero, we do not create the account at all, so we allow","counters":[]},{"line":"             this through. Otherwise, the fee must be the default.","counters":[]},{"line":"          *)","counters":[]},{"line":"          Boolean.(token_default ||| is_zero_fee)","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"        in","counters":[]},{"line":"        Boolean.(is_coinbase_or_fee_transfer &&& fee_may_be_charged)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      in","counters":[]},{"line":"      (* a couple of references, hard to thread the values *)","counters":[]},{"line":"      let burned_tokens = ref Currency.Amount.(var_of_t zero) in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"      let zero_fee =","counters":[]},{"line":"        Currency.Amount.(Signed.create_var ~magnitude:(var_of_t zero))","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"          ~sgn:Sgn.Checked.pos","counters":[]},{"line":"      in","counters":[]},{"line":"      (* new account fees added for coinbases/fee transfers, when calculating receiver amounts *)","counters":[]},{"line":"      let new_account_fees = ref zero_fee in","counters":[]},{"line":"      let%bind root_after_fee_payer_update =","counters":[]},{"line":"        [%with_label_ \"Update fee payer\"] (fun () ->","counters":[{"col_start":39,"col_end":39,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"            Frozen_ledger_hash.modify_account_send","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              ~depth:constraint_constants.ledger_depth root","counters":[]},{"line":"              ~is_writeable:can_create_fee_payer_account fee_payer","counters":[]},{"line":"              ~f:(fun ~is_empty_and_writeable account ->","counters":[]},{"line":"                (* this account is:","counters":[]},{"line":"                   - the fee-payer for payments","counters":[]},{"line":"                   - the fee-payer for stake delegation","counters":[]},{"line":"                   - the fee-payer for account creation","counters":[]},{"line":"                   - the fee-payer for token minting","counters":[]},{"line":"                   - the fee-receiver for a coinbase","counters":[]},{"line":"                   - the second receiver for a fee transfer","counters":[]},{"line":"                *)","counters":[]},{"line":"                let%bind next_nonce =","counters":[]},{"line":"                  Account.Nonce.Checked.succ_if account.nonce is_user_command","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"                in","counters":[]},{"line":"                let%bind () =","counters":[]},{"line":"                  [%with_label_ \"Check fee nonce\"] (fun () ->","counters":[{"col_start":48,"col_end":48,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"                      let%bind nonce_matches =","counters":[]},{"line":"                        Account.Nonce.Checked.equal nonce account.nonce","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                      in","counters":[]},{"line":"                      Boolean.Assert.any","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        [ Boolean.not is_user_command; nonce_matches ] )","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"                in","counters":[]},{"line":"                let%bind receipt_chain_hash =","counters":[]},{"line":"                  let current = account.receipt_chain_hash in","counters":[]},{"line":"                  let%bind r =","counters":[]},{"line":"                    Receipt.Chain_hash.Checked.cons_signed_command_payload","counters":[{"col_start":73,"col_end":73,"count":0}]},{"line":"                      (Signed_command_payload payload) current","counters":[]},{"line":"                  in","counters":[]},{"line":"                  Receipt.Chain_hash.Checked.if_ is_user_command ~then_:r","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    ~else_:current","counters":[]},{"line":"                in","counters":[]},{"line":"                let permitted_to_send =","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Account.Checked.has_permission ~to_:`Send account","counters":[]},{"line":"                in","counters":[]},{"line":"                let permitted_to_receive =","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Account.Checked.has_permission ~to_:`Receive account","counters":[]},{"line":"                in","counters":[]},{"line":"                let%bind () =","counters":[]},{"line":"                  [%with_label_","counters":[]},{"line":"                    \"Fee payer balance update should be permitted for all \\","counters":[]},{"line":"                     commands\"] (fun () ->","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"                      Boolean.Assert.any","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        [ Boolean.not is_user_command; permitted_to_send ] )","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"                in","counters":[]},{"line":"                (*second fee receiver of a fee transfer and fee receiver of a coinbase transaction remain unchanged if","counters":[]},{"line":"                   1. These accounts are not permitted to receive tokens and,","counters":[]},{"line":"                   2. Receiver account that corresponds to first fee receiver of a fee transfer or coinbase receiver of a coinbase transaction, doesn't allow receiving tokens*)","counters":[]},{"line":"                let%bind update_account =","counters":[]},{"line":"                  let%bind receiving_allowed =","counters":[]},{"line":"                    Boolean.all","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                      [ is_coinbase_or_fee_transfer; permitted_to_receive ]","counters":[]},{"line":"                  in","counters":[]},{"line":"                  Boolean.any [ is_user_command; receiving_allowed ]","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                in","counters":[]},{"line":"                let%bind is_empty_and_writeable =","counters":[]},{"line":"                  (* If this is a coinbase with zero fee, do not create the","counters":[]},{"line":"                     account, since the fee amount won't be enough to pay for it.","counters":[]},{"line":"                  *)","counters":[]},{"line":"                  Boolean.(all [ is_empty_and_writeable; not is_zero_fee ])","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                in","counters":[]},{"line":"                let%bind should_pay_to_create =","counters":[]},{"line":"                  (* Coinbases and fee transfers may create, or we may be creating","counters":[]},{"line":"                     a new token account. These are mutually exclusive, so we can","counters":[]},{"line":"                     encode this as a boolean.","counters":[]},{"line":"                  *)","counters":[]},{"line":"                  let%bind is_create_account =","counters":[]},{"line":"                    Boolean.(is_create_account &&& not user_command_fails)","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"                  in","counters":[]},{"line":"                  Boolean.(is_empty_and_writeable ||| is_create_account)","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                in","counters":[]},{"line":"                let%bind amount =","counters":[]},{"line":"                  [%with_label_ \"Compute fee payer amount\"] (fun () ->","counters":[{"col_start":57,"col_end":57,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"                      let fee_payer_amount =","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        let sgn = Sgn.Checked.neg_if_true is_user_command in","counters":[]},{"line":"                        Amount.Signed.create_var","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          ~magnitude:(Amount.Checked.of_fee fee)","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"                          ~sgn","counters":[]},{"line":"                      in","counters":[]},{"line":"                      (* Account creation fee for fee transfers/coinbases. *)","counters":[]},{"line":"                      let%bind account_creation_fee =","counters":[]},{"line":"                        let%map magnitude =","counters":[]},{"line":"                          Amount.Checked.if_ should_pay_to_create","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"                            ~then_:account_creation_amount","counters":[]},{"line":"                            ~else_:Amount.(var_of_t zero)","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                        in","counters":[]},{"line":"                        Amount.Signed.create_var ~magnitude ~sgn:Sgn.Checked.neg","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                      in","counters":[]},{"line":"                      new_account_fees := account_creation_fee ;","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                      Amount.Signed.Checked.(","counters":[]},{"line":"                        add fee_payer_amount account_creation_fee) )","counters":[]},{"line":"                in","counters":[]},{"line":"                let%bind () =","counters":[]},{"line":"                  [%with_label_ \"Burned tokens in fee payer\"] (fun () ->","counters":[{"col_start":59,"col_end":59,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"                      let%map amt =","counters":[]},{"line":"                        add_burned_tokens !burned_tokens","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"                          (Amount.Checked.of_fee fee)","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"                          ~is_coinbase_or_fee_transfer ~update_account","counters":[]},{"line":"                      in","counters":[]},{"line":"                      burned_tokens := amt )","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                in","counters":[]},{"line":"                let txn_global_slot = current_global_slot in","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                let%bind timing =","counters":[]},{"line":"                  [%with_label_ \"Check fee payer timing\"] (fun () ->","counters":[{"col_start":55,"col_end":55,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"                      let%bind txn_amount =","counters":[]},{"line":"                        let%bind sgn = Amount.Signed.Checked.sgn amount in","counters":[{"col_start":63,"col_end":63,"count":0}]},{"line":"                        let%bind magnitude =","counters":[]},{"line":"                          Amount.Signed.Checked.magnitude amount","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"                        in","counters":[]},{"line":"                        Amount.Checked.if_ (Sgn.Checked.is_neg sgn)","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"                          ~then_:magnitude","counters":[]},{"line":"                          ~else_:Amount.(var_of_t zero)","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"                      in","counters":[]},{"line":"                      let balance_check ok =","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        [%with_label_ \"Check fee payer balance\"] (fun () ->","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":62,"col_end":62,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"                            Boolean.Assert.is_true ok )","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                      in","counters":[]},{"line":"                      let timed_balance_check ok =","counters":[]},{"line":"                        [%with_label_ \"Check fee payer timed balance\"]","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":68,"col_end":68,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"                          (fun () -> Boolean.Assert.is_true ok)","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                      in","counters":[]},{"line":"                      let%bind `Min_balance _, timing =","counters":[]},{"line":"                        check_timing ~balance_check ~timed_balance_check","counters":[]},{"line":"                          ~account ~txn_amount:(Some txn_amount)","counters":[]},{"line":"                          ~txn_global_slot","counters":[]},{"line":"                      in","counters":[]},{"line":"                      Account_timing.if_ update_account ~then_:timing","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        ~else_:account.timing )","counters":[]},{"line":"                in","counters":[]},{"line":"                let%bind balance =","counters":[]},{"line":"                  [%with_label_ \"Check payer balance\"] (fun () ->","counters":[{"col_start":52,"col_end":52,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"                      let%bind updated_balance =","counters":[]},{"line":"                        Balance.Checked.add_signed_amount account.balance amount","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"                      in","counters":[]},{"line":"                      Balance.Checked.if_ update_account ~then_:updated_balance","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        ~else_:account.balance )","counters":[]},{"line":"                in","counters":[]},{"line":"                let%map public_key =","counters":[]},{"line":"                  Public_key.Compressed.Checked.if_ is_empty_and_writeable","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                    ~then_:(Account_id.Checked.public_key fee_payer)","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"                    ~else_:account.public_key","counters":[]},{"line":"                and token_id =","counters":[]},{"line":"                  make_checked (fun () ->","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                      Token_id.Checked.if_ is_empty_and_writeable","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        ~then_:(Account_id.Checked.token_id fee_payer)","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"                        ~else_:account.token_id )","counters":[]},{"line":"                and delegate =","counters":[]},{"line":"                  Public_key.Compressed.Checked.if_ is_empty_and_writeable","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                    ~then_:(Account_id.Checked.public_key fee_payer)","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"                    ~else_:account.delegate","counters":[]},{"line":"                in","counters":[]},{"line":"                { Account.Poly.balance","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                ; public_key","counters":[]},{"line":"                ; token_id","counters":[]},{"line":"                ; token_permissions = account.token_permissions","counters":[]},{"line":"                ; token_symbol = account.token_symbol","counters":[]},{"line":"                ; nonce = next_nonce","counters":[]},{"line":"                ; receipt_chain_hash","counters":[]},{"line":"                ; delegate","counters":[]},{"line":"                ; voting_for = account.voting_for","counters":[]},{"line":"                ; timing","counters":[]},{"line":"                ; permissions = account.permissions","counters":[]},{"line":"                ; zkapp = account.zkapp","counters":[]},{"line":"                } ) )","counters":[]},{"line":"      in","counters":[]},{"line":"      let%bind receiver_increase =","counters":[]},{"line":"        (* - payments:         payload.body.amount","counters":[]},{"line":"           - stake delegation: 0","counters":[]},{"line":"           - account creation: 0","counters":[]},{"line":"           - token minting:    payload.body.amount","counters":[]},{"line":"           - coinbase:         payload.body.amount - payload.common.fee","counters":[]},{"line":"           - fee transfer:     payload.body.amount","counters":[]},{"line":"        *)","counters":[]},{"line":"        [%with_label_ \"Compute receiver increase\"] (fun () ->","counters":[{"col_start":48,"col_end":48,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"            let%bind base_amount =","counters":[]},{"line":"              let%bind zero_transfer =","counters":[]},{"line":"                Boolean.any [ is_stake_delegation; is_create_account ]","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"              in","counters":[]},{"line":"              Amount.Checked.if_ zero_transfer","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ~then_:(Amount.var_of_t Amount.zero)","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"                ~else_:payload.body.amount","counters":[]},{"line":"            in","counters":[]},{"line":"            (* The fee for entering the coinbase transaction is paid up front. *)","counters":[]},{"line":"            let%bind coinbase_receiver_fee =","counters":[]},{"line":"              Amount.Checked.if_ is_coinbase","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                ~then_:(Amount.Checked.of_fee fee)","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"                ~else_:(Amount.var_of_t Amount.zero)","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"            in","counters":[]},{"line":"            Amount.Checked.sub base_amount coinbase_receiver_fee )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"      in","counters":[]},{"line":"      let receiver_overflow = ref Boolean.false_ in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let receiver_balance_update_permitted = ref Boolean.true_ in","counters":[]},{"line":"      let%bind root_after_receiver_update =","counters":[]},{"line":"        [%with_label_ \"Update receiver\"] (fun () ->","counters":[{"col_start":38,"col_end":38,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"            Frozen_ledger_hash.modify_account_recv","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              ~depth:constraint_constants.ledger_depth","counters":[]},{"line":"              root_after_fee_payer_update receiver","counters":[]},{"line":"              ~f:(fun ~is_empty_and_writeable account ->","counters":[]},{"line":"                (* this account is:","counters":[]},{"line":"                   - the receiver for payments","counters":[]},{"line":"                   - the delegated-to account for stake delegation","counters":[]},{"line":"                   - the created account for an account creation","counters":[]},{"line":"                   - the receiver for minted tokens","counters":[]},{"line":"                   - the receiver for a coinbase","counters":[]},{"line":"                   - the first receiver for a fee transfer","counters":[]},{"line":"                *)","counters":[]},{"line":"                let permitted_to_receive =","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Account.Checked.has_permission ~to_:`Receive account","counters":[]},{"line":"                in","counters":[]},{"line":"                (*Account remains unchanged if balance update is not permitted for payments, fee_transfers and coinbase transactions*)","counters":[]},{"line":"                let%bind payment_or_internal_command =","counters":[]},{"line":"                  Boolean.any [ is_payment; is_coinbase_or_fee_transfer ]","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                in","counters":[]},{"line":"                let%bind update_account =","counters":[]},{"line":"                  Boolean.any","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                    [ Boolean.not payment_or_internal_command","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                    ; permitted_to_receive","counters":[]},{"line":"                    ]","counters":[]},{"line":"                in","counters":[]},{"line":"                receiver_balance_update_permitted := permitted_to_receive ;","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                let%bind is_empty_failure =","counters":[]},{"line":"                  let%bind must_not_be_empty =","counters":[]},{"line":"                    Boolean.(is_stake_delegation ||| is_mint_tokens)","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                  in","counters":[]},{"line":"                  Boolean.(is_empty_and_writeable &&& must_not_be_empty)","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                in","counters":[]},{"line":"                let%bind () =","counters":[]},{"line":"                  [%with_label_ \"Receiver existence failure matches predicted\"]","counters":[{"col_start":77,"col_end":77,"count":0},{"col_start":78,"col_end":78,"count":0}]},{"line":"                    (fun () ->","counters":[]},{"line":"                      Boolean.Assert.( = ) is_empty_failure","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        user_command_failure.receiver_not_present )","counters":[]},{"line":"                in","counters":[]},{"line":"                let%bind is_empty_and_writeable =","counters":[]},{"line":"                  Boolean.(all [ is_empty_and_writeable; not is_empty_failure ])","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                in","counters":[]},{"line":"                let%bind should_pay_to_create =","counters":[]},{"line":"                  Boolean.(is_empty_and_writeable &&& not is_create_account)","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"                in","counters":[]},{"line":"                let%bind () =","counters":[]},{"line":"                  [%with_label_","counters":[]},{"line":"                    \"Check whether creation fails due to a non-default token\"]","counters":[{"col_start":76,"col_end":76,"count":0},{"col_start":77,"col_end":77,"count":0}]},{"line":"                    (fun () ->","counters":[]},{"line":"                      let%bind token_should_not_create =","counters":[]},{"line":"                        Boolean.(","counters":[]},{"line":"                          should_pay_to_create &&& Boolean.not token_default)","counters":[{"col_start":49,"col_end":49,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"                      in","counters":[]},{"line":"                      let%bind token_cannot_create =","counters":[]},{"line":"                        Boolean.(token_should_not_create &&& is_user_command)","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"                      in","counters":[]},{"line":"                      let%bind () =","counters":[]},{"line":"                        [%with_label_","counters":[]},{"line":"                          \"Check that account creation is paid in the default \\","counters":[]},{"line":"                           token for non-user-commands\"] (fun () ->","counters":[{"col_start":54,"col_end":54,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"                            (* This expands to","counters":[]},{"line":"                               [token_should_not_create =","counters":[]},{"line":"                                 token_should_not_create && is_user_command]","counters":[]},{"line":"                               which is","counters":[]},{"line":"                               - [token_should_not_create = token_should_not_create]","counters":[]},{"line":"                                 (ie. always satisfied) for user commands","counters":[]},{"line":"                               - [token_should_not_create = false] for coinbases/fee","counters":[]},{"line":"                                 transfers.","counters":[]},{"line":"                            *)","counters":[]},{"line":"                            Boolean.Assert.( = ) token_should_not_create","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                              token_cannot_create )","counters":[]},{"line":"                      in","counters":[]},{"line":"                      [%with_label_ \"equal token_cannot_create\"] (fun () ->","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":62,"col_end":62,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"                          Boolean.Assert.( = ) token_cannot_create","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            user_command_failure.token_cannot_create ) )","counters":[]},{"line":"                in","counters":[]},{"line":"                let%bind balance =","counters":[]},{"line":"                  (* [receiver_increase] will be zero in the stake delegation","counters":[]},{"line":"                     case.","counters":[]},{"line":"                  *)","counters":[]},{"line":"                  let%bind receiver_amount =","counters":[]},{"line":"                    let%bind account_creation_fee =","counters":[]},{"line":"                      Amount.Checked.if_ should_pay_to_create","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"                        ~then_:account_creation_amount","counters":[]},{"line":"                        ~else_:Amount.(var_of_t zero)","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"                    in","counters":[]},{"line":"                    let%bind new_account_fees_total =","counters":[]},{"line":"                      Amount.Signed.Checked.(","counters":[]},{"line":"                        add @@ negate @@ of_unsigned account_creation_fee)","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":51,"col_end":51,"count":0},{"col_start":73,"col_end":73,"count":0}]},{"line":"                        !new_account_fees","counters":[]},{"line":"                    in","counters":[]},{"line":"                    new_account_fees := new_account_fees_total ;","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                    let%bind amount_for_new_account, `Underflow underflow =","counters":[]},{"line":"                      Amount.Checked.sub_flagged receiver_increase","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"                        account_creation_fee","counters":[]},{"line":"                    in","counters":[]},{"line":"                    let%bind () =","counters":[]},{"line":"                      [%with_label_","counters":[]},{"line":"                        \"Receiver creation fee failure matches predicted\"]","counters":[{"col_start":72,"col_end":72,"count":0},{"col_start":73,"col_end":73,"count":0}]},{"line":"                        (fun () ->","counters":[]},{"line":"                          Boolean.Assert.( = ) underflow","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            user_command_failure.amount_insufficient_to_create )","counters":[]},{"line":"                    in","counters":[]},{"line":"                    Currency.Amount.Checked.if_ user_command_fails","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      ~then_:Amount.(var_of_t zero)","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"                      ~else_:amount_for_new_account","counters":[]},{"line":"                  in","counters":[]},{"line":"","counters":[]},{"line":"                  (* NOTE: Instead of capturing this as part of the user command","counters":[]},{"line":"                     failures, we capture it inline here and bubble it out to a","counters":[]},{"line":"                     reference. This behavior is still in line with the","counters":[]},{"line":"                     out-of-snark transaction logic.","counters":[]},{"line":"","counters":[]},{"line":"                     Updating [user_command_fails] to include this value from here","counters":[]},{"line":"                     onwards will ensure that we do not update the source or","counters":[]},{"line":"                     receiver accounts. The only places where [user_command_fails]","counters":[]},{"line":"                     may have already affected behaviour are","counters":[]},{"line":"                     * when the fee-payer is paying the account creation fee, and","counters":[]},{"line":"                     * when a new token is created.","counters":[]},{"line":"                     In both of these, this account is new, and will have a","counters":[]},{"line":"                     balance of 0, so we can guarantee that there is no overflow.","counters":[]},{"line":"                  *)","counters":[]},{"line":"                  let%bind balance, `Overflow overflow =","counters":[]},{"line":"                    Balance.Checked.add_amount_flagged account.balance","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"                      receiver_amount","counters":[]},{"line":"                  in","counters":[]},{"line":"                  let%bind () =","counters":[]},{"line":"                    [%with_label_ \"Overflow error only occurs in user commands\"]","counters":[{"col_start":78,"col_end":78,"count":0},{"col_start":79,"col_end":79,"count":0}]},{"line":"                      Boolean.(","counters":[]},{"line":"                        fun () -> Assert.any [ is_user_command; not overflow ])","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"                  in","counters":[]},{"line":"                  receiver_overflow := overflow ;","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  Balance.Checked.if_ overflow ~then_:account.balance","counters":[]},{"line":"                    ~else_:balance","counters":[]},{"line":"                in","counters":[]},{"line":"                let%bind () =","counters":[]},{"line":"                  [%with_label_ \"Burned tokens in receiver\"] (fun () ->","counters":[{"col_start":58,"col_end":58,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"                      let%map amt =","counters":[]},{"line":"                        add_burned_tokens !burned_tokens receiver_increase","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"                          ~is_coinbase_or_fee_transfer","counters":[]},{"line":"                          ~update_account:permitted_to_receive","counters":[]},{"line":"                      in","counters":[]},{"line":"                      burned_tokens := amt )","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                in","counters":[]},{"line":"                let%bind user_command_fails =","counters":[]},{"line":"                  Boolean.(!receiver_overflow ||| user_command_fails)","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"                in","counters":[]},{"line":"                let%bind is_empty_and_writeable =","counters":[]},{"line":"                  (* Do not create a new account if the user command will fail or if receiving is not permitted *)","counters":[]},{"line":"                  Boolean.all","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                    [ is_empty_and_writeable","counters":[]},{"line":"                    ; Boolean.not user_command_fails","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                    ; update_account","counters":[]},{"line":"                    ]","counters":[]},{"line":"                in","counters":[]},{"line":"                let%bind balance =","counters":[]},{"line":"                  Balance.Checked.if_ update_account ~then_:balance","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"                    ~else_:account.balance","counters":[]},{"line":"                in","counters":[]},{"line":"                let%bind may_delegate =","counters":[]},{"line":"                  (* Only default tokens may participate in delegation. *)","counters":[]},{"line":"                  Boolean.(is_empty_and_writeable &&& token_default)","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"                in","counters":[]},{"line":"                let%map delegate =","counters":[]},{"line":"                  Public_key.Compressed.Checked.if_ may_delegate","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                    ~then_:(Account_id.Checked.public_key receiver)","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"                    ~else_:account.delegate","counters":[]},{"line":"                and public_key =","counters":[]},{"line":"                  Public_key.Compressed.Checked.if_ is_empty_and_writeable","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                    ~then_:(Account_id.Checked.public_key receiver)","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"                    ~else_:account.public_key","counters":[]},{"line":"                and token_id =","counters":[]},{"line":"                  make_checked (fun () ->","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                      Token_id.Checked.if_ is_empty_and_writeable ~then_:token","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        ~else_:account.token_id )","counters":[]},{"line":"                and token_owner =","counters":[]},{"line":"                  (* TODO: Delete token permissions *)","counters":[]},{"line":"                  Boolean.if_ is_empty_and_writeable ~then_:Boolean.false_","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                    ~else_:account.token_permissions.token_owner","counters":[]},{"line":"                and token_locked =","counters":[]},{"line":"                  Boolean.if_ is_empty_and_writeable","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                    ~then_:payload.body.token_locked","counters":[]},{"line":"                    ~else_:account.token_permissions.token_locked","counters":[]},{"line":"                in","counters":[]},{"line":"                { Account.Poly.balance","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                ; public_key","counters":[]},{"line":"                ; token_id","counters":[]},{"line":"                ; token_permissions =","counters":[]},{"line":"                    { Token_permissions.token_owner; token_locked }","counters":[]},{"line":"                ; token_symbol = account.token_symbol","counters":[]},{"line":"                ; nonce = account.nonce","counters":[]},{"line":"                ; receipt_chain_hash = account.receipt_chain_hash","counters":[]},{"line":"                ; delegate","counters":[]},{"line":"                ; voting_for = account.voting_for","counters":[]},{"line":"                ; timing = account.timing","counters":[]},{"line":"                ; permissions = account.permissions","counters":[]},{"line":"                ; zkapp = account.zkapp","counters":[]},{"line":"                } ) )","counters":[]},{"line":"      in","counters":[]},{"line":"      let%bind user_command_fails =","counters":[]},{"line":"        Boolean.(!receiver_overflow ||| user_command_fails)","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"      in","counters":[]},{"line":"      let%bind fee_payer_is_source =","counters":[]},{"line":"        Account_id.Checked.equal fee_payer source","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"      in","counters":[]},{"line":"      let%bind root_after_source_update =","counters":[]},{"line":"        [%with_label_ \"Update source\"] (fun () ->","counters":[{"col_start":36,"col_end":36,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"            Frozen_ledger_hash.modify_account_send","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              ~depth:constraint_constants.ledger_depth","counters":[]},{"line":"              ~is_writeable:","counters":[]},{"line":"                (* [modify_account_send] does this failure check for us. *)","counters":[]},{"line":"                user_command_failure.source_not_present","counters":[]},{"line":"              root_after_receiver_update source","counters":[]},{"line":"              ~f:(fun ~is_empty_and_writeable account ->","counters":[]},{"line":"                (* this account is:","counters":[]},{"line":"                   - the source for payments","counters":[]},{"line":"                   - the delegator for stake delegation","counters":[]},{"line":"                   - the token owner for account creation","counters":[]},{"line":"                   - the token owner for token minting","counters":[]},{"line":"                   - the fee-receiver for a coinbase","counters":[]},{"line":"                   - the second receiver for a fee transfer","counters":[]},{"line":"                *)","counters":[]},{"line":"                let%bind () =","counters":[]},{"line":"                  [%with_label_","counters":[]},{"line":"                    \"Check source presence failure matches predicted\"]","counters":[{"col_start":68,"col_end":68,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"                    (fun () ->","counters":[]},{"line":"                      Boolean.Assert.( = ) is_empty_and_writeable","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        user_command_failure.source_not_present )","counters":[]},{"line":"                in","counters":[]},{"line":"                let%bind () =","counters":[]},{"line":"                  [%with_label_","counters":[]},{"line":"                    \"Check source failure cases do not apply when fee-payer is \\","counters":[]},{"line":"                     source\"] (fun () ->","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"                      let num_failures =","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        let open Field.Var in","counters":[]},{"line":"                        add","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                          (user_command_failure.source_insufficient_balance :> t)","counters":[]},{"line":"                          (user_command_failure.source_bad_timing :> t)","counters":[]},{"line":"                      in","counters":[]},{"line":"                      let not_fee_payer_is_source =","counters":[]},{"line":"                        (Boolean.not fee_payer_is_source :> Field.Var.t)","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                      in","counters":[]},{"line":"                      (* Equivalent to:","counters":[]},{"line":"                         if fee_payer_is_source then","counters":[]},{"line":"                           num_failures = 0","counters":[]},{"line":"                         else","counters":[]},{"line":"                           num_failures = num_failures","counters":[]},{"line":"                      *)","counters":[]},{"line":"                      [%with_label_ \"Check num_failures\"] (fun () ->","counters":[{"col_start":55,"col_end":55,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"                          assert_r1cs not_fee_payer_is_source num_failures","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            num_failures ) )","counters":[]},{"line":"                in","counters":[]},{"line":"                let permitted_to_update_delegate =","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Account.Checked.has_permission ~to_:`Set_delegate account","counters":[]},{"line":"                in","counters":[]},{"line":"                let permitted_to_send =","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Account.Checked.has_permission ~to_:`Send account","counters":[]},{"line":"                in","counters":[]},{"line":"                let permitted_to_receive =","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Account.Checked.has_permission ~to_:`Receive account","counters":[]},{"line":"                in","counters":[]},{"line":"                (*Account remains unchanged if not permitted to send, receive, or set delegate*)","counters":[]},{"line":"                let%bind payment_permitted =","counters":[]},{"line":"                  Boolean.all","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                    [ is_payment","counters":[]},{"line":"                    ; permitted_to_send","counters":[]},{"line":"                    ; !receiver_balance_update_permitted","counters":[]},{"line":"                    ]","counters":[]},{"line":"                in","counters":[]},{"line":"                let%bind update_account =","counters":[]},{"line":"                  let%bind delegation_permitted =","counters":[]},{"line":"                    Boolean.all","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                      [ is_stake_delegation; permitted_to_update_delegate ]","counters":[]},{"line":"                  in","counters":[]},{"line":"                  let%bind fee_receiver_update_permitted =","counters":[]},{"line":"                    Boolean.all","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                      [ is_coinbase_or_fee_transfer; permitted_to_receive ]","counters":[]},{"line":"                  in","counters":[]},{"line":"                  Boolean.any","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    [ payment_permitted","counters":[]},{"line":"                    ; delegation_permitted","counters":[]},{"line":"                    ; fee_receiver_update_permitted","counters":[]},{"line":"                    ]","counters":[]},{"line":"                in","counters":[]},{"line":"                let%bind amount =","counters":[]},{"line":"                  (* Only payments should affect the balance at this stage. *)","counters":[]},{"line":"                  if_ payment_permitted ~typ:Amount.typ","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                    ~then_:payload.body.amount","counters":[]},{"line":"                    ~else_:Amount.(var_of_t zero)","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"                in","counters":[]},{"line":"                let txn_global_slot = current_global_slot in","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                let%bind timing =","counters":[]},{"line":"                  [%with_label_ \"Check source timing\"] (fun () ->","counters":[{"col_start":52,"col_end":52,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"                      let balance_check ok =","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        [%with_label_","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          \"Check source balance failure matches predicted\"]","counters":[{"col_start":73,"col_end":73,"count":0},{"col_start":74,"col_end":74,"count":0}]},{"line":"                          (fun () ->","counters":[]},{"line":"                            Boolean.Assert.( = ) ok","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                              (Boolean.not","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"                                 user_command_failure","counters":[]},{"line":"                                   .source_insufficient_balance ) )","counters":[]},{"line":"                      in","counters":[]},{"line":"                      let timed_balance_check ok =","counters":[]},{"line":"                        [%with_label_","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          \"Check source timed balance failure matches predicted\"]","counters":[{"col_start":79,"col_end":79,"count":0},{"col_start":80,"col_end":80,"count":0}]},{"line":"                          (fun () ->","counters":[]},{"line":"                            let%bind not_ok =","counters":[]},{"line":"                              Boolean.(","counters":[]},{"line":"                                (not ok)","counters":[]},{"line":"                                &&& not","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"                                      user_command_failure","counters":[]},{"line":"                                        .source_insufficient_balance)","counters":[]},{"line":"                            in","counters":[]},{"line":"                            Boolean.Assert.( = ) not_ok","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                              user_command_failure.source_bad_timing )","counters":[]},{"line":"                      in","counters":[]},{"line":"                      let%bind `Min_balance _, timing =","counters":[]},{"line":"                        check_timing ~balance_check ~timed_balance_check","counters":[]},{"line":"                          ~account ~txn_amount:(Some amount) ~txn_global_slot","counters":[]},{"line":"                      in","counters":[]},{"line":"                      Account_timing.if_ update_account ~then_:timing","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        ~else_:account.timing )","counters":[]},{"line":"                in","counters":[]},{"line":"                let%bind balance, `Underflow underflow =","counters":[]},{"line":"                  Balance.Checked.sub_amount_flagged account.balance amount","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                in","counters":[]},{"line":"                let%bind () =","counters":[]},{"line":"                  (* TODO: Remove the redundancy in balance calculation between","counters":[]},{"line":"                     here and [check_timing].","counters":[]},{"line":"                  *)","counters":[]},{"line":"                  [%with_label_","counters":[]},{"line":"                    \"Check source balance failure matches predicted\"] (fun () ->","counters":[{"col_start":67,"col_end":67,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"                      Boolean.Assert.( = ) underflow","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        user_command_failure.source_insufficient_balance )","counters":[]},{"line":"                in","counters":[]},{"line":"                let%map delegate =","counters":[]},{"line":"                  let%bind may_delegate =","counters":[]},{"line":"                    Boolean.all [ is_stake_delegation; update_account ]","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                  in","counters":[]},{"line":"                  Public_key.Compressed.Checked.if_ may_delegate","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    ~then_:(Account_id.Checked.public_key receiver)","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"                    ~else_:account.delegate","counters":[]},{"line":"                in","counters":[]},{"line":"                (* NOTE: Technically we update the account here even in the case","counters":[]},{"line":"                   of [user_command_fails], but we throw the resulting hash away","counters":[]},{"line":"                   in [final_root] below, so it shouldn't matter.","counters":[]},{"line":"                *)","counters":[]},{"line":"                { Account.Poly.balance","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                ; public_key = account.public_key","counters":[]},{"line":"                ; token_id = account.token_id","counters":[]},{"line":"                ; token_permissions = account.token_permissions","counters":[]},{"line":"                ; token_symbol = account.token_symbol","counters":[]},{"line":"                ; nonce = account.nonce","counters":[]},{"line":"                ; receipt_chain_hash = account.receipt_chain_hash","counters":[]},{"line":"                ; delegate","counters":[]},{"line":"                ; voting_for = account.voting_for","counters":[]},{"line":"                ; timing","counters":[]},{"line":"                ; permissions = account.permissions","counters":[]},{"line":"                ; zkapp = account.zkapp","counters":[]},{"line":"                } ) )","counters":[]},{"line":"      in","counters":[]},{"line":"      let%bind fee_excess =","counters":[]},{"line":"        (* - payments:         payload.common.fee","counters":[]},{"line":"           - stake delegation: payload.common.fee","counters":[]},{"line":"           - account creation: payload.common.fee","counters":[]},{"line":"           - token minting:    payload.common.fee","counters":[]},{"line":"           - coinbase:         0 (fee already paid above)","counters":[]},{"line":"           - fee transfer:     - payload.body.amount - payload.common.fee","counters":[]},{"line":"        *)","counters":[]},{"line":"        let open Amount in","counters":[]},{"line":"        chain Signed.Checked.if_ is_coinbase","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          ~then_:(return (Signed.Checked.of_unsigned (var_of_t zero)))","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":51,"col_end":51,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"          ~else_:","counters":[]},{"line":"            (let user_command_excess =","counters":[]},{"line":"               Signed.Checked.of_unsigned (Checked.of_fee payload.common.fee)","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"             in","counters":[]},{"line":"             let%bind fee_transfer_excess, fee_transfer_excess_overflowed =","counters":[]},{"line":"               let%map magnitude, `Overflow overflowed =","counters":[]},{"line":"                 Checked.(","counters":[]},{"line":"                   add_flagged payload.body.amount (of_fee payload.common.fee))","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"               in","counters":[]},{"line":"               (Signed.create_var ~magnitude ~sgn:Sgn.Checked.neg, overflowed)","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"             in","counters":[]},{"line":"             let%bind () =","counters":[]},{"line":"               (* TODO: Reject this in txn pool before fees-in-tokens. *)","counters":[]},{"line":"               [%with_label_ \"Fee excess does not overflow\"]","counters":[{"col_start":58,"col_end":58,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"                 Boolean.(","counters":[]},{"line":"                   fun () ->","counters":[]},{"line":"                     Assert.any","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                       [ not is_fee_transfer","counters":[]},{"line":"                       ; not fee_transfer_excess_overflowed","counters":[]},{"line":"                       ])","counters":[]},{"line":"             in","counters":[]},{"line":"             Signed.Checked.if_ is_fee_transfer ~then_:fee_transfer_excess","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"               ~else_:user_command_excess )","counters":[]},{"line":"      in","counters":[]},{"line":"      let%bind supply_increase =","counters":[]},{"line":"        [%with_label_ \"Calculate supply increase\"] (fun () ->","counters":[{"col_start":48,"col_end":48,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"            let%bind expected_supply_increase =","counters":[]},{"line":"              Amount.Signed.Checked.if_ is_coinbase","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"                ~then_:(Amount.Signed.Checked.of_unsigned payload.body.amount)","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"                ~else_:Amount.(Signed.Checked.of_unsigned (var_of_t zero))","counters":[{"col_start":56,"col_end":56,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"            in","counters":[]},{"line":"            let%bind amt0, `Overflow overflow0 =","counters":[]},{"line":"              Amount.Signed.Checked.(","counters":[]},{"line":"                add_flagged expected_supply_increase","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                  (negate (of_unsigned !burned_tokens)))","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"            in","counters":[]},{"line":"            let%bind () = Boolean.Assert.is_true (Boolean.not overflow0) in","counters":[{"col_start":47,"col_end":47,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"            let%bind new_account_fees_total =","counters":[]},{"line":"              Amount.Signed.Checked.if_ user_command_fails ~then_:zero_fee","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"                ~else_:!new_account_fees","counters":[]},{"line":"            in","counters":[]},{"line":"            let%bind amt, `Overflow overflow =","counters":[]},{"line":"              (* new_account_fees_total is negative if nonzero *)","counters":[]},{"line":"              Amount.Signed.Checked.(add_flagged amt0 new_account_fees_total)","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"            in","counters":[]},{"line":"            let%map () = Boolean.Assert.is_true (Boolean.not overflow) in","counters":[{"col_start":46,"col_end":46,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"            amt )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"      in","counters":[]},{"line":"      let%map final_root =","counters":[]},{"line":"        (* Ensure that only the fee-payer was charged if this was an invalid user","counters":[]},{"line":"           command.","counters":[]},{"line":"        *)","counters":[]},{"line":"        Frozen_ledger_hash.if_ user_command_fails","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"          ~then_:root_after_fee_payer_update ~else_:root_after_source_update","counters":[]},{"line":"      in","counters":[]},{"line":"      (final_root, fee_excess, supply_increase)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    (* Someday:","counters":[]},{"line":"       write the following soundness tests:","counters":[]},{"line":"       - apply a transaction where the signature is incorrect","counters":[]},{"line":"       - apply a transaction where the sender does not have enough money in their account","counters":[]},{"line":"       - apply a transaction and stuff in the wrong target hash","counters":[]},{"line":"    *)","counters":[]},{"line":"","counters":[]},{"line":"    (* spec for [main statement]:","counters":[]},{"line":"       constraints pass iff there exists","counters":[]},{"line":"          t : Tagged_transaction.t","counters":[]},{"line":"       such that","counters":[]},{"line":"       - applying [t] to ledger with merkle hash [l1] results in ledger with merkle hash [l2].","counters":[]},{"line":"       - applying [t] to [pc.source] with results in pending coinbase stack [pc.target]","counters":[]},{"line":"       - t has fee excess equal to [fee_excess]","counters":[]},{"line":"       - t has supply increase equal to [supply_increase]","counters":[]},{"line":"         where statement includes","counters":[]},{"line":"          l1 : Frozen_ledger_hash.t,","counters":[]},{"line":"          l2 : Frozen_ledger_hash.t,","counters":[]},{"line":"          fee_excess : Amount.Signed.t,","counters":[]},{"line":"          supply_increase : Amount.Signed.t","counters":[]},{"line":"          pc: Pending_coinbase_stack_state.t","counters":[]},{"line":"    *)","counters":[]},{"line":"    let%snarkydef_ main ~constraint_constants","counters":[]},{"line":"        (statement : Statement.With_sok.Checked.t) =","counters":[]},{"line":"      let%bind () = dummy_constraints () in","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"      let%bind (module Shifted) = Tick.Inner_curve.Checked.Shifted.create () in","counters":[{"col_start":72,"col_end":72,"count":0}]},{"line":"      let%bind t =","counters":[]},{"line":"        with_label __LOC__ (fun () ->","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"            exists Transaction_union.typ ~request:(As_prover.return Transaction) )","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"      in","counters":[]},{"line":"      let%bind pending_coinbase_init =","counters":[]},{"line":"        exists Pending_coinbase.Stack.typ ~request:(As_prover.return Init_stack)","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"      in","counters":[]},{"line":"      let%bind state_body =","counters":[]},{"line":"        exists","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"          (Mina_state.Protocol_state.Body.typ ~constraint_constants)","counters":[]},{"line":"          ~request:(As_prover.return State_body)","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"      in","counters":[]},{"line":"      let%bind root_after, fee_excess, supply_increase =","counters":[]},{"line":"        apply_tagged_transaction ~constraint_constants","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"          (module Shifted)","counters":[]},{"line":"          statement.source.ledger pending_coinbase_init","counters":[]},{"line":"          statement.source.pending_coinbase_stack","counters":[]},{"line":"          statement.target.pending_coinbase_stack state_body t","counters":[]},{"line":"      in","counters":[]},{"line":"      let%bind fee_excess =","counters":[]},{"line":"        (* Use the default token for the fee excess if it is zero.","counters":[]},{"line":"           This matches the behaviour of [Fee_excess.rebalance], which allows","counters":[]},{"line":"           [verify_complete_merge] to verify a proof without knowledge of the","counters":[]},{"line":"           particular fee tokens used.","counters":[]},{"line":"        *)","counters":[]},{"line":"        let%bind fee_excess_zero =","counters":[]},{"line":"          Amount.Signed.Checked.equal fee_excess","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"            Amount.Signed.(Checked.constant zero)","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"        in","counters":[]},{"line":"        let%map fee_token_l =","counters":[]},{"line":"          make_checked (fun () ->","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"              Token_id.Checked.if_ fee_excess_zero","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ~then_:Token_id.(Checked.constant default)","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"                ~else_:t.payload.common.fee_token )","counters":[]},{"line":"        in","counters":[]},{"line":"        { Fee_excess.fee_token_l","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        ; fee_excess_l = Amount.Signed.Checked.to_fee fee_excess","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"        ; fee_token_r = Token_id.(Checked.constant default)","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"        ; fee_excess_r = Fee.Signed.(Checked.constant zero)","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"        }","counters":[]},{"line":"      in","counters":[]},{"line":"      let%bind () =","counters":[]},{"line":"        [%with_label_ \"local state check\"] (fun () ->","counters":[{"col_start":40,"col_end":40,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"            make_checked (fun () ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"                Local_state.Checked.assert_equal statement.source.local_state","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  statement.target.local_state ) )","counters":[]},{"line":"      in","counters":[]},{"line":"      Checked.all_unit","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [ [%with_label_ \"equal roots\"] (fun () ->","counters":[{"col_start":36,"col_end":36,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"              Frozen_ledger_hash.assert_equal root_after statement.target.ledger )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"        ; [%with_label_ \"equal supply_increases\"] (fun () ->","counters":[{"col_start":47,"col_end":47,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"              Currency.Amount.Signed.Checked.assert_equal supply_increase","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                statement.supply_increase )","counters":[]},{"line":"        ; [%with_label_ \"equal fee excesses\"] (fun () ->","counters":[{"col_start":43,"col_end":43,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"              Fee_excess.assert_equal_checked fee_excess statement.fee_excess )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"        ]","counters":[]},{"line":"","counters":[]},{"line":"    let rule ~constraint_constants : _ Pickles.Inductive_rule.t =","counters":[]},{"line":"      { identifier = \"transaction\"","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      ; prevs = []","counters":[]},{"line":"      ; main =","counters":[]},{"line":"          (fun { public_input = x } ->","counters":[]},{"line":"            Run.run_checked (main ~constraint_constants x) ;","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"            { previous_proof_statements = []","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            ; public_output = ()","counters":[]},{"line":"            ; auxiliary_output = ()","counters":[]},{"line":"            } )","counters":[]},{"line":"      ; uses_lookup = false","counters":[]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    let transaction_union_handler handler (transaction : Transaction_union.t)","counters":[]},{"line":"        (state_body : Mina_state.Protocol_state.Body.Value.t)","counters":[]},{"line":"        (init_stack : Pending_coinbase.Stack.t) :","counters":[]},{"line":"        Snarky_backendless.Request.request -> _ =","counters":[]},{"line":"     fun (With { request; respond } as r) ->","counters":[{"col_start":5,"col_end":5,"count":0}]},{"line":"      match request with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Transaction ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          respond (Provide transaction)","counters":[]},{"line":"      | State_body ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          respond (Provide state_body)","counters":[]},{"line":"      | Init_stack ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          respond (Provide init_stack)","counters":[]},{"line":"      | _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          handler r","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Transition_data = struct","counters":[]},{"line":"    type t =","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":9,"col_end":9,"count":0}]},{"line":"      { proof : Proof_type.t","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      ; supply_increase : (Amount.t, Sgn.t) Signed_poly.t","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      ; fee_excess : Fee_excess.t","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      ; sok_digest : Sok_message.Digest.t","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      ; pending_coinbase_stack_state : Pending_coinbase_stack_state.t","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      }","counters":[]},{"line":"    [@@deriving fields]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Merge = struct","counters":[]},{"line":"    open Tick","counters":[]},{"line":"","counters":[]},{"line":"    type _ Snarky_backendless.Request.t +=","counters":[]},{"line":"      | Statements_to_merge :","counters":[]},{"line":"          (Statement.With_sok.t * Statement.With_sok.t)","counters":[]},{"line":"          Snarky_backendless.Request.t","counters":[]},{"line":"      | Proofs_to_merge :","counters":[]},{"line":"          ( (Nat.N2.n, Nat.N2.n) Pickles.Proof.t","counters":[]},{"line":"          * (Nat.N2.n, Nat.N2.n) Pickles.Proof.t )","counters":[]},{"line":"          Snarky_backendless.Request.t","counters":[]},{"line":"","counters":[]},{"line":"    let handle","counters":[]},{"line":"        ((left_stmt, right_stmt) : Statement.With_sok.t * Statement.With_sok.t)","counters":[]},{"line":"        ((left_proof, right_proof) : _ Pickles.Proof.t * _ Pickles.Proof.t)","counters":[]},{"line":"        (Snarky_backendless.Request.With { request; respond }) =","counters":[]},{"line":"      match request with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Statements_to_merge ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          respond (Provide (left_stmt, right_stmt))","counters":[]},{"line":"      | Proofs_to_merge ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          respond (Provide (left_proof, right_proof))","counters":[]},{"line":"      | _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          respond Unhandled","counters":[]},{"line":"","counters":[]},{"line":"    (* spec for [main top_hash]:","counters":[]},{"line":"       constraints pass iff","counters":[]},{"line":"       there exist digest, s1, s3, fee_excess, supply_increase pending_coinbase_stack12.source, pending_coinbase_stack23.target, tock_vk such that","counters":[]},{"line":"       H(digest,s1, s3, pending_coinbase_stack12.source, pending_coinbase_stack23.target, fee_excess, supply_increase, tock_vk) = top_hash,","counters":[]},{"line":"       verify_transition tock_vk _ s1 s2 pending_coinbase_stack12.source, pending_coinbase_stack12.target is true","counters":[]},{"line":"       verify_transition tock_vk _ s2 s3 pending_coinbase_stack23.source, pending_coinbase_stack23.target is true","counters":[]},{"line":"    *)","counters":[]},{"line":"    let%snarkydef_ main (s : Statement.With_sok.Checked.t) =","counters":[]},{"line":"      let%bind s1, s2 =","counters":[]},{"line":"        exists","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"          Typ.(Statement.With_sok.typ * Statement.With_sok.typ)","counters":[]},{"line":"          ~request:(As_prover.return Statements_to_merge)","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"      in","counters":[]},{"line":"      let%bind fee_excess =","counters":[]},{"line":"        Fee_excess.combine_checked s1.Statement.fee_excess","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"          s2.Statement.fee_excess","counters":[]},{"line":"      in","counters":[]},{"line":"      let%bind () =","counters":[]},{"line":"        with_label __LOC__ (fun () ->","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"            let%bind valid_pending_coinbase_stack_transition =","counters":[]},{"line":"              Pending_coinbase.Stack.Checked.check_merge","counters":[]},{"line":"                ~transition1:","counters":[]},{"line":"                  ( s1.source.pending_coinbase_stack","counters":[]},{"line":"                  , s1.target.pending_coinbase_stack )","counters":[]},{"line":"                ~transition2:","counters":[]},{"line":"                  ( s2.source.pending_coinbase_stack","counters":[]},{"line":"                  , s2.target.pending_coinbase_stack )","counters":[]},{"line":"            in","counters":[]},{"line":"            Boolean.Assert.is_true valid_pending_coinbase_stack_transition )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"      in","counters":[]},{"line":"      let%bind supply_increase =","counters":[]},{"line":"        Amount.Signed.Checked.add s1.supply_increase s2.supply_increase","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"      in","counters":[]},{"line":"      let%bind () =","counters":[]},{"line":"        make_checked (fun () ->","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"            Local_state.Checked.assert_equal s.source.local_state","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              s1.source.local_state ;","counters":[]},{"line":"            Local_state.Checked.assert_equal s.target.local_state","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              s2.target.local_state )","counters":[]},{"line":"      in","counters":[]},{"line":"      let%map () =","counters":[]},{"line":"        Checked.all_unit","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"          [ [%with_label_ \"equal fee excesses\"] (fun () ->","counters":[{"col_start":45,"col_end":45,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"                Fee_excess.assert_equal_checked fee_excess s.fee_excess )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"          ; [%with_label_ \"equal supply increases\"] (fun () ->","counters":[{"col_start":49,"col_end":49,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"                Amount.Signed.Checked.assert_equal supply_increase","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  s.supply_increase )","counters":[]},{"line":"          ; [%with_label_ \"equal source ledger hashes\"] (fun () ->","counters":[{"col_start":53,"col_end":53,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"                Frozen_ledger_hash.assert_equal s.source.ledger s1.source.ledger )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"          ; [%with_label_ \"equal target, source ledger hashes\"] (fun () ->","counters":[{"col_start":61,"col_end":61,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"                Frozen_ledger_hash.assert_equal s1.target.ledger","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  s2.source.ledger )","counters":[]},{"line":"          ; [%with_label_ \"equal target ledger hashes\"] (fun () ->","counters":[{"col_start":53,"col_end":53,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"                Frozen_ledger_hash.assert_equal s2.target.ledger s.target.ledger )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"          ]","counters":[]},{"line":"      in","counters":[]},{"line":"      (s1, s2)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let rule ~proof_level self : _ Pickles.Inductive_rule.t =","counters":[]},{"line":"      let prev_should_verify =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        match proof_level with","counters":[]},{"line":"        | Genesis_constants.Proof_level.Full ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            true","counters":[]},{"line":"        | _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            false","counters":[]},{"line":"      in","counters":[]},{"line":"      let b = Boolean.var_of_value prev_should_verify in","counters":[]},{"line":"      { identifier = \"merge\"","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      ; prevs = [ self; self ]","counters":[]},{"line":"      ; main =","counters":[]},{"line":"          (fun { public_input = x } ->","counters":[]},{"line":"            let s1, s2 = Run.run_checked (main x) in","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"            let p1, p2 =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Run.exists","counters":[]},{"line":"                Typ.(Internal.ref () * Internal.ref ())","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"                ~request:(fun () -> Proofs_to_merge)","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"            in","counters":[]},{"line":"            { previous_proof_statements =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"                [ { public_input = s1; proof = p1; proof_must_verify = b }","counters":[]},{"line":"                ; { public_input = s2; proof = p2; proof_must_verify = b }","counters":[]},{"line":"                ]","counters":[]},{"line":"            ; public_output = ()","counters":[]},{"line":"            ; auxiliary_output = ()","counters":[]},{"line":"            } )","counters":[]},{"line":"      ; uses_lookup = false","counters":[]},{"line":"      }","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  open Pickles_types","counters":[]},{"line":"","counters":[]},{"line":"  type tag =","counters":[]},{"line":"    ( Statement.With_sok.Checked.t","counters":[]},{"line":"    , Statement.With_sok.t","counters":[]},{"line":"    , Nat.N2.n","counters":[]},{"line":"    , Nat.N5.n )","counters":[]},{"line":"    Pickles.Tag.t","counters":[]},{"line":"","counters":[]},{"line":"  let time lab f =","counters":[]},{"line":"    let start = Time.now () in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let x = f () in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let stop = Time.now () in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    printf \"%s: %s\\n%!\" lab (Time.Span.to_string_hum (Time.diff stop start)) ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":51,"col_end":51,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"    x","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let system ~proof_level ~constraint_constants =","counters":[]},{"line":"    time \"Transaction_snark.system\" (fun () ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        Pickles.compile () ~cache:Cache_dir.cache","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ~public_input:(Input Statement.With_sok.typ) ~auxiliary_typ:Typ.unit","counters":[]},{"line":"          ~branches:(module Nat.N5)","counters":[]},{"line":"          ~max_proofs_verified:(module Nat.N2)","counters":[]},{"line":"          ~name:\"transaction-snark\"","counters":[]},{"line":"          ~constraint_constants:","counters":[]},{"line":"            (Genesis_constants.Constraint_constants.to_snark_keys_header","counters":[{"col_start":71,"col_end":71,"count":0}]},{"line":"               constraint_constants )","counters":[]},{"line":"          ~choices:(fun ~self ->","counters":[]},{"line":"            let zkapp_command x =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Base.Zkapp_command_snark.rule ~constraint_constants ~proof_level x","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"            in","counters":[]},{"line":"            [ Base.rule ~constraint_constants","counters":[]},{"line":"            ; Merge.rule ~proof_level self","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"            ; zkapp_command Opt_signed_opt_signed","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"            ; zkapp_command Opt_signed","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"            ; zkapp_command Proved","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"            ] ) )","counters":[]},{"line":"","counters":[]},{"line":"  module Verification = struct","counters":[]},{"line":"    module type S = sig","counters":[]},{"line":"      val tag : tag","counters":[]},{"line":"","counters":[]},{"line":"      val verify : (t * Sok_message.t) list -> bool Async.Deferred.t","counters":[]},{"line":"","counters":[]},{"line":"      val id : Pickles.Verification_key.Id.t Lazy.t","counters":[]},{"line":"","counters":[]},{"line":"      val verification_key : Pickles.Verification_key.t Lazy.t","counters":[]},{"line":"","counters":[]},{"line":"      val verify_against_digest : t -> bool Async.Deferred.t","counters":[]},{"line":"","counters":[]},{"line":"      val constraint_system_digests : (string * Md5_lib.t) list Lazy.t","counters":[]},{"line":"    end","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module type S = sig","counters":[]},{"line":"    include Verification.S","counters":[]},{"line":"","counters":[]},{"line":"    val constraint_constants : Genesis_constants.Constraint_constants.t","counters":[]},{"line":"","counters":[]},{"line":"    val cache_handle : Pickles.Cache_handle.t","counters":[]},{"line":"","counters":[]},{"line":"    val of_non_zkapp_command_transaction :","counters":[]},{"line":"         statement:Statement.With_sok.t","counters":[]},{"line":"      -> init_stack:Pending_coinbase.Stack.t","counters":[]},{"line":"      -> Transaction.Valid.t Transaction_protocol_state.t","counters":[]},{"line":"      -> Tick.Handler.t","counters":[]},{"line":"      -> t Async.Deferred.t","counters":[]},{"line":"","counters":[]},{"line":"    val of_user_command :","counters":[]},{"line":"         statement:Statement.With_sok.t","counters":[]},{"line":"      -> init_stack:Pending_coinbase.Stack.t","counters":[]},{"line":"      -> Signed_command.With_valid_signature.t Transaction_protocol_state.t","counters":[]},{"line":"      -> Tick.Handler.t","counters":[]},{"line":"      -> t Async.Deferred.t","counters":[]},{"line":"","counters":[]},{"line":"    val of_fee_transfer :","counters":[]},{"line":"         statement:Statement.With_sok.t","counters":[]},{"line":"      -> init_stack:Pending_coinbase.Stack.t","counters":[]},{"line":"      -> Fee_transfer.t Transaction_protocol_state.t","counters":[]},{"line":"      -> Tick.Handler.t","counters":[]},{"line":"      -> t Async.Deferred.t","counters":[]},{"line":"","counters":[]},{"line":"    val of_zkapp_command_segment_exn :","counters":[]},{"line":"         statement:Statement.With_sok.t","counters":[]},{"line":"      -> witness:Zkapp_command_segment.Witness.t","counters":[]},{"line":"      -> spec:Zkapp_command_segment.Basic.t","counters":[]},{"line":"      -> t Async.Deferred.t","counters":[]},{"line":"","counters":[]},{"line":"    val merge :","counters":[]},{"line":"      t -> t -> sok_digest:Sok_message.Digest.t -> t Async.Deferred.Or_error.t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let check_transaction_union ?(preeval = false) ~constraint_constants","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"      ~supply_increase sok_message source target init_stack","counters":[]},{"line":"      pending_coinbase_stack_state transaction state_body handler =","counters":[]},{"line":"    if preeval then failwith \"preeval currently disabled\" ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":20,"col_end":20,"count":0}]},{"line":"    let sok_digest = Sok_message.digest sok_message in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let handler =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Base.transaction_union_handler handler transaction state_body init_stack","counters":[]},{"line":"    in","counters":[]},{"line":"    let statement : Statement.With_sok.t =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Statement.Poly.with_empty_local_state ~source ~target ~supply_increase","counters":[]},{"line":"        ~pending_coinbase_stack_state","counters":[]},{"line":"        ~fee_excess:(Transaction_union.fee_excess transaction)","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"        ~sok_digest","counters":[]},{"line":"    in","counters":[]},{"line":"    let open Tick in","counters":[]},{"line":"    ignore","counters":[]},{"line":"      ( Or_error.ok_exn","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"          (run_and_check","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"             (handle","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"                (fun () ->","counters":[]},{"line":"                  Checked.map ~f:As_prover.return","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    (let open Checked in","counters":[]},{"line":"                    exists Statement.With_sok.typ","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                      ~compute:(As_prover.return statement)","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"                    >>= Base.main ~constraint_constants) )","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                handler ) )","counters":[]},{"line":"        : unit )","counters":[]},{"line":"","counters":[]},{"line":"  let check_transaction ?preeval ~constraint_constants ~sok_message ~source","counters":[]},{"line":"      ~target ~init_stack ~pending_coinbase_stack_state ~zkapp_account1:_","counters":[]},{"line":"      ~zkapp_account2:_ ~supply_increase","counters":[]},{"line":"      (transaction_in_block : Transaction.Valid.t Transaction_protocol_state.t)","counters":[]},{"line":"      handler =","counters":[]},{"line":"    let transaction =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Transaction_protocol_state.transaction transaction_in_block","counters":[]},{"line":"    in","counters":[]},{"line":"    let state_body =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Transaction_protocol_state.block_data transaction_in_block","counters":[]},{"line":"    in","counters":[]},{"line":"    match to_preunion (Transaction.forget transaction) with","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"    | `Zkapp_command _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        failwith","counters":[]},{"line":"          \"Called non-account_update transaction with zkapp_command transaction\"","counters":[]},{"line":"    | `Transaction t ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        check_transaction_union ?preeval ~constraint_constants ~supply_increase","counters":[]},{"line":"          sok_message source target init_stack pending_coinbase_stack_state","counters":[]},{"line":"          (Transaction_union.of_transaction t)","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"          state_body handler","counters":[]},{"line":"","counters":[]},{"line":"  let check_user_command ~constraint_constants ~sok_message ~source ~target","counters":[]},{"line":"      ~init_stack ~pending_coinbase_stack_state ~supply_increase t_in_block","counters":[]},{"line":"      handler =","counters":[]},{"line":"    let user_command = Transaction_protocol_state.transaction t_in_block in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    check_transaction ~constraint_constants ~sok_message ~source ~target","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ~init_stack ~pending_coinbase_stack_state ~zkapp_account1:None","counters":[]},{"line":"      ~zkapp_account2:None ~supply_increase","counters":[]},{"line":"      { t_in_block with transaction = Command (Signed_command user_command) }","counters":[]},{"line":"      handler","counters":[]},{"line":"","counters":[]},{"line":"  let generate_transaction_union_witness ?(preeval = false)","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"      ~constraint_constants ~supply_increase sok_message source target","counters":[]},{"line":"      transaction_in_block init_stack pending_coinbase_stack_state handler =","counters":[]},{"line":"    if preeval then failwith \"preeval currently disabled\" ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":20,"col_end":20,"count":0}]},{"line":"    let transaction =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Transaction_protocol_state.transaction transaction_in_block","counters":[]},{"line":"    in","counters":[]},{"line":"    let state_body =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Transaction_protocol_state.block_data transaction_in_block","counters":[]},{"line":"    in","counters":[]},{"line":"    let sok_digest = Sok_message.digest sok_message in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let handler =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Base.transaction_union_handler handler transaction state_body init_stack","counters":[]},{"line":"    in","counters":[]},{"line":"    let statement : Statement.With_sok.t =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Statement.Poly.with_empty_local_state ~source ~target ~supply_increase","counters":[]},{"line":"        ~pending_coinbase_stack_state","counters":[]},{"line":"        ~fee_excess:(Transaction_union.fee_excess transaction)","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"        ~sok_digest","counters":[]},{"line":"    in","counters":[]},{"line":"    let open Tick in","counters":[]},{"line":"    let main x = handle (fun () -> Base.main ~constraint_constants x) handler in","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"    generate_auxiliary_input ~input_typ:Statement.With_sok.typ","counters":[]},{"line":"      ~return_typ:(Snarky_backendless.Typ.unit ())","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"      main statement","counters":[]},{"line":"","counters":[]},{"line":"  let generate_transaction_witness ?preeval ~constraint_constants ~sok_message","counters":[]},{"line":"      ~source ~target ~init_stack ~pending_coinbase_stack_state","counters":[]},{"line":"      ~zkapp_account1:_ ~zkapp_account2:_ ~supply_increase","counters":[]},{"line":"      (transaction_in_block : Transaction.Valid.t Transaction_protocol_state.t)","counters":[]},{"line":"      handler =","counters":[]},{"line":"    match","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      to_preunion","counters":[]},{"line":"        (Transaction.forget","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"           (Transaction_protocol_state.transaction transaction_in_block) )","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"    with","counters":[]},{"line":"    | `Zkapp_command _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        failwith","counters":[]},{"line":"          \"Called non-account_update transaction with zkapp_command transaction\"","counters":[]},{"line":"    | `Transaction t ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        generate_transaction_union_witness ?preeval ~constraint_constants","counters":[]},{"line":"          ~supply_increase sok_message source target","counters":[]},{"line":"          { transaction_in_block with","counters":[]},{"line":"            transaction = Transaction_union.of_transaction t","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"          }","counters":[]},{"line":"          init_stack pending_coinbase_stack_state handler","counters":[]},{"line":"","counters":[]},{"line":"  let verify (ts : (t * _) list) ~key =","counters":[]},{"line":"    if","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      List.for_all ts ~f:(fun ({ statement; _ }, message) ->","counters":[]},{"line":"          Sok_message.Digest.equal","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (Sok_message.digest message)","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"            statement.sok_digest )","counters":[]},{"line":"    then","counters":[]},{"line":"      Pickles.verify","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (module Nat.N2)","counters":[]},{"line":"        (module Statement.With_sok)","counters":[]},{"line":"        key","counters":[]},{"line":"        (List.map ts ~f:(fun ({ statement; proof }, _) -> (statement, proof)))","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"    else Async.return false","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"  let constraint_system_digests ~constraint_constants () =","counters":[]},{"line":"    let digest = Tick.R1CS_constraint_system.digest in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    [ ( \"transaction-merge\"","counters":[]},{"line":"      , digest","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"          Merge.(","counters":[]},{"line":"            Tick.constraint_system ~input_typ:Statement.With_sok.typ","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"              ~return_typ:(Snarky_backendless.Typ.unit ()) (fun x ->","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"                let open Tick in","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                Checked.map ~f:ignore @@ main x )) )","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"    ; ( \"transaction-base\"","counters":[]},{"line":"      , digest","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"          Base.(","counters":[]},{"line":"            Tick.constraint_system ~input_typ:Statement.With_sok.typ","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"              ~return_typ:(Snarky_backendless.Typ.unit ())","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"              (main ~constraint_constants)) )","counters":[]},{"line":"    ]","counters":[]},{"line":"","counters":[]},{"line":"  module Account_update_group = Zkapp_command.Make_update_group (struct","counters":[]},{"line":"    type local_state =","counters":[]},{"line":"      ( Stack_frame.value","counters":[]},{"line":"      , Stack_frame.value list","counters":[]},{"line":"      , Token_id.t","counters":[]},{"line":"      , Currency.Amount.Signed.t","counters":[]},{"line":"      , Sparse_ledger.t","counters":[]},{"line":"      , bool","counters":[]},{"line":"      , Zkapp_command.Transaction_commitment.t","counters":[]},{"line":"      , Mina_numbers.Index.t","counters":[]},{"line":"      , Transaction_status.Failure.Collection.t )","counters":[]},{"line":"      Mina_transaction_logic.Zkapp_command_logic.Local_state.t","counters":[]},{"line":"","counters":[]},{"line":"    type global_state = Sparse_ledger.Global_state.t","counters":[]},{"line":"","counters":[]},{"line":"    type spec = Zkapp_command_segment.Basic.t","counters":[]},{"line":"","counters":[]},{"line":"    let zkapp_segment_of_controls = Zkapp_command_segment.Basic.of_controls","counters":[]},{"line":"  end)","counters":[]},{"line":"","counters":[]},{"line":"  let rec accumulate_call_stack_hashes","counters":[]},{"line":"      ~(hash_frame : 'frame -> Stack_frame.Digest.t) (frames : 'frame list) :","counters":[]},{"line":"      ('frame, Call_stack_digest.t) With_stack_hash.t list =","counters":[]},{"line":"    match frames with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | [] ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        []","counters":[]},{"line":"    | f :: fs ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let h_f = hash_frame f in","counters":[]},{"line":"        let tl = accumulate_call_stack_hashes ~hash_frame fs in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let h_tl =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          match tl with [] -> Call_stack_digest.empty | t :: _ -> t.stack_hash","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"        in","counters":[]},{"line":"        { stack_hash = Call_stack_digest.cons h_f h_tl; elt = f } :: tl","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"  let zkapp_command_witnesses_exn ~constraint_constants ~state_body ~fee_excess","counters":[]},{"line":"      ledger","counters":[]},{"line":"      (zkapp_commands :","counters":[]},{"line":"        ( [ `Pending_coinbase_init_stack of Pending_coinbase.Stack.t ]","counters":[]},{"line":"        * [ `Pending_coinbase_of_statement of Pending_coinbase_stack_state.t ]","counters":[]},{"line":"        * Zkapp_command.t )","counters":[]},{"line":"        list ) =","counters":[]},{"line":"    let sparse_ledger =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      match ledger with","counters":[]},{"line":"      | `Ledger ledger ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Sparse_ledger.of_ledger_subset_exn ledger","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"            (List.concat_map","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"               ~f:(fun (_, _, zkapp_command) ->","counters":[]},{"line":"                 Zkapp_command.accounts_referenced zkapp_command )","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"               zkapp_commands )","counters":[]},{"line":"      | `Sparse_ledger sparse_ledger ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          sparse_ledger","counters":[]},{"line":"    in","counters":[]},{"line":"    let supply_increase = Amount.(Signed.of_unsigned zero) in","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"    let state_view = Mina_state.Protocol_state.Body.view state_body in","counters":[]},{"line":"    let _, _, _, states_rev =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      List.fold_left ~init:(fee_excess, supply_increase, sparse_ledger, [])","counters":[]},{"line":"        zkapp_commands","counters":[]},{"line":"        ~f:(fun","counters":[]},{"line":"             (fee_excess, supply_increase, sparse_ledger, statess_rev)","counters":[]},{"line":"             (_, _, zkapp_command)","counters":[]},{"line":"           ->","counters":[]},{"line":"          let _, states =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Sparse_ledger.apply_zkapp_command_unchecked_with_states","counters":[{"col_start":66,"col_end":66,"count":0}]},{"line":"              sparse_ledger ~constraint_constants ~state_view ~fee_excess","counters":[]},{"line":"              ~supply_increase zkapp_command","counters":[]},{"line":"            |> Or_error.ok_exn","counters":[]},{"line":"          in","counters":[]},{"line":"          let final_state =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let global_state, _local_state = List.last_exn states in","counters":[]},{"line":"            global_state","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          in","counters":[]},{"line":"          ( final_state.fee_excess","counters":[]},{"line":"          , final_state.supply_increase","counters":[]},{"line":"          , final_state.ledger","counters":[]},{"line":"          , states :: statess_rev ) )","counters":[]},{"line":"    in","counters":[]},{"line":"    let states = List.rev states_rev in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let states_rev =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Account_update_group.group_by_zkapp_command_rev","counters":[]},{"line":"        ( []","counters":[]},{"line":"        :: List.map","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"             ~f:(fun (_, _, zkapp_command) ->","counters":[]},{"line":"               Zkapp_command.zkapp_command_list zkapp_command )","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"             zkapp_commands )","counters":[]},{"line":"        ([ List.hd_exn (List.hd_exn states) ] :: states)","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"    in","counters":[]},{"line":"    let commitment = ref (Local_state.dummy ()).transaction_commitment in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"    let full_commitment =","counters":[]},{"line":"      ref (Local_state.dummy ()).full_transaction_commitment","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"    in","counters":[]},{"line":"    let remaining_zkapp_command =","counters":[]},{"line":"      let zkapp_commands =","counters":[]},{"line":"        List.map zkapp_commands","counters":[]},{"line":"          ~f:(fun","counters":[]},{"line":"               ( pending_coinbase_init_stack","counters":[]},{"line":"               , pending_coinbase_stack_state","counters":[]},{"line":"               , zkapp_command )","counters":[]},{"line":"             ->","counters":[]},{"line":"            ( pending_coinbase_init_stack","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            , pending_coinbase_stack_state","counters":[]},{"line":"            , { Mina_transaction_logic.Zkapp_command_logic.Start_data","counters":[]},{"line":"                .zkapp_command","counters":[]},{"line":"              ; memo_hash = Signed_command_memo.hash zkapp_command.memo","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"              } ) )","counters":[]},{"line":"      in","counters":[]},{"line":"      ref zkapp_commands","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    in","counters":[]},{"line":"    let pending_coinbase_init_stack = ref Pending_coinbase.Stack.empty in","counters":[]},{"line":"    let pending_coinbase_stack_state =","counters":[]},{"line":"      ref","counters":[]},{"line":"        { Pending_coinbase_stack_state.source = Pending_coinbase.Stack.empty","counters":[]},{"line":"        ; target = Pending_coinbase.Stack.empty","counters":[]},{"line":"        }","counters":[]},{"line":"    in","counters":[]},{"line":"    let final_ledger =","counters":[]},{"line":"      match states_rev with","counters":[]},{"line":"      | [] ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          sparse_ledger","counters":[]},{"line":"      | { Account_update_group.Zkapp_command_intermediate_state.state_after =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            { global = { ledger; _ }; _ }","counters":[]},{"line":"        ; _","counters":[]},{"line":"        }","counters":[]},{"line":"        :: _ ->","counters":[]},{"line":"          ledger","counters":[]},{"line":"    in","counters":[]},{"line":"    ( List.fold_right states_rev ~init:[]","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"        ~f:(fun","counters":[]},{"line":"             ({ kind","counters":[]},{"line":"              ; spec","counters":[]},{"line":"              ; state_before = { global = source_global; local = source_local }","counters":[]},{"line":"              ; state_after = { global = target_global; local = target_local }","counters":[]},{"line":"              } :","counters":[]},{"line":"               Account_update_group.Zkapp_command_intermediate_state.t )","counters":[]},{"line":"             witnesses","counters":[]},{"line":"           ->","counters":[]},{"line":"          (*Transaction snark says nothing about failure status*)","counters":[]},{"line":"          let source_local = { source_local with failure_status_tbl = [] } in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let target_local = { target_local with failure_status_tbl = [] } in","counters":[]},{"line":"          let current_commitment = !commitment in","counters":[]},{"line":"          let current_full_commitment = !full_commitment in","counters":[]},{"line":"          let ( start_zkapp_command","counters":[]},{"line":"              , next_commitment","counters":[]},{"line":"              , next_full_commitment","counters":[]},{"line":"              , pending_coinbase_init_stack","counters":[]},{"line":"              , pending_coinbase_stack_state ) =","counters":[]},{"line":"            let empty_if_last (mk : unit -> field * field) : field * field =","counters":[]},{"line":"              match","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (target_local.stack_frame.calls, target_local.call_stack)","counters":[]},{"line":"              with","counters":[]},{"line":"              | [], [] ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  (* The commitment will be cleared, because this is the last","counters":[]},{"line":"                     account_update.","counters":[]},{"line":"                  *)","counters":[]},{"line":"                  Zkapp_command.Transaction_commitment.(empty, empty)","counters":[]},{"line":"              | _ ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  mk ()","counters":[]},{"line":"            in","counters":[]},{"line":"            let mk_next_commitments (zkapp_command : Zkapp_command.t) =","counters":[]},{"line":"              empty_if_last (fun () ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                  let next_commitment =","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    Zkapp_command.commitment zkapp_command","counters":[]},{"line":"                  in","counters":[]},{"line":"                  let memo_hash = Signed_command_memo.hash zkapp_command.memo in","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  let fee_payer_hash =","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    Zkapp_command.Digest.Account_update.create","counters":[]},{"line":"                      (Account_update.of_fee_payer zkapp_command.fee_payer)","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"                  in","counters":[]},{"line":"                  let next_full_commitment =","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    Zkapp_command.Transaction_commitment.create_complete","counters":[]},{"line":"                      next_commitment ~memo_hash ~fee_payer_hash","counters":[]},{"line":"                  in","counters":[]},{"line":"                  (next_commitment, next_full_commitment) )","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"            in","counters":[]},{"line":"            match kind with","counters":[]},{"line":"            | `Same ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                let next_commitment, next_full_commitment =","counters":[]},{"line":"                  empty_if_last (fun () ->","counters":[]},{"line":"                      (current_commitment, current_full_commitment) )","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                in","counters":[]},{"line":"                ( []","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                , next_commitment","counters":[]},{"line":"                , next_full_commitment","counters":[]},{"line":"                , !pending_coinbase_init_stack","counters":[]},{"line":"                , !pending_coinbase_stack_state )","counters":[]},{"line":"            | `New -> (","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                match !remaining_zkapp_command with","counters":[]},{"line":"                | ( `Pending_coinbase_init_stack pending_coinbase_init_stack1","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  , `Pending_coinbase_of_statement pending_coinbase_stack_state1","counters":[]},{"line":"                  , zkapp_command )","counters":[]},{"line":"                  :: rest ->","counters":[]},{"line":"                    let commitment', full_commitment' =","counters":[]},{"line":"                      mk_next_commitments zkapp_command.zkapp_command","counters":[]},{"line":"                    in","counters":[]},{"line":"                    remaining_zkapp_command := rest ;","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                    commitment := commitment' ;","counters":[]},{"line":"                    full_commitment := full_commitment' ;","counters":[]},{"line":"                    pending_coinbase_init_stack := pending_coinbase_init_stack1 ;","counters":[]},{"line":"                    pending_coinbase_stack_state :=","counters":[]},{"line":"                      pending_coinbase_stack_state1 ;","counters":[]},{"line":"                    ( [ zkapp_command ]","counters":[]},{"line":"                    , commitment'","counters":[]},{"line":"                    , full_commitment'","counters":[]},{"line":"                    , !pending_coinbase_init_stack","counters":[]},{"line":"                    , !pending_coinbase_stack_state )","counters":[]},{"line":"                | _ ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    failwith \"Not enough remaining zkapp_command\" )","counters":[]},{"line":"            | `Two_new -> (","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                match !remaining_zkapp_command with","counters":[]},{"line":"                | ( `Pending_coinbase_init_stack pending_coinbase_init_stack1","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  , `Pending_coinbase_of_statement pending_coinbase_stack_state1","counters":[]},{"line":"                  , zkapp_command1 )","counters":[]},{"line":"                  :: ( `Pending_coinbase_init_stack _pending_coinbase_init_stack2","counters":[]},{"line":"                     , `Pending_coinbase_of_statement","counters":[]},{"line":"                         pending_coinbase_stack_state2","counters":[]},{"line":"                     , zkapp_command2 )","counters":[]},{"line":"                     :: rest ->","counters":[]},{"line":"                    let commitment', full_commitment' =","counters":[]},{"line":"                      mk_next_commitments zkapp_command2.zkapp_command","counters":[]},{"line":"                    in","counters":[]},{"line":"                    remaining_zkapp_command := rest ;","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                    commitment := commitment' ;","counters":[]},{"line":"                    full_commitment := full_commitment' ;","counters":[]},{"line":"                    (*TODO: Remove `Two_new case because the resulting pending_coinbase_init_stack will not be correct for zkapp_command2 if it is in a different scan state tree*)","counters":[]},{"line":"                    pending_coinbase_init_stack := pending_coinbase_init_stack1 ;","counters":[]},{"line":"                    pending_coinbase_stack_state :=","counters":[]},{"line":"                      { pending_coinbase_stack_state1 with","counters":[]},{"line":"                        Pending_coinbase_stack_state.target =","counters":[]},{"line":"                          pending_coinbase_stack_state2","counters":[]},{"line":"                            .Pending_coinbase_stack_state.target","counters":[]},{"line":"                      } ;","counters":[]},{"line":"                    ( [ zkapp_command1; zkapp_command2 ]","counters":[]},{"line":"                    , commitment'","counters":[]},{"line":"                    , full_commitment'","counters":[]},{"line":"                    , !pending_coinbase_init_stack","counters":[]},{"line":"                    , !pending_coinbase_stack_state )","counters":[]},{"line":"                | _ ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    failwith \"Not enough remaining zkapp_command\" )","counters":[]},{"line":"          in","counters":[]},{"line":"          let hash_local_state","counters":[]},{"line":"              (local :","counters":[]},{"line":"                ( Stack_frame.value","counters":[]},{"line":"                , Stack_frame.value list","counters":[]},{"line":"                , _","counters":[]},{"line":"                , _","counters":[]},{"line":"                , _","counters":[]},{"line":"                , _","counters":[]},{"line":"                , _","counters":[]},{"line":"                , _","counters":[]},{"line":"                , _ )","counters":[]},{"line":"                Mina_transaction_logic.Zkapp_command_logic.Local_state.t ) =","counters":[]},{"line":"            { local with","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              stack_frame = local.stack_frame","counters":[]},{"line":"            ; call_stack =","counters":[]},{"line":"                List.map local.call_stack","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                  ~f:(With_hash.of_data ~hash_data:Stack_frame.Digest.create)","counters":[]},{"line":"                |> accumulate_call_stack_hashes ~hash_frame:(fun x ->","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"                       x.With_hash.hash )","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"            }","counters":[]},{"line":"          in","counters":[]},{"line":"          let source_local =","counters":[]},{"line":"            { (hash_local_state source_local) with","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"              transaction_commitment = current_commitment","counters":[]},{"line":"            ; full_transaction_commitment = current_full_commitment","counters":[]},{"line":"            }","counters":[]},{"line":"          in","counters":[]},{"line":"          let target_local =","counters":[]},{"line":"            { (hash_local_state target_local) with","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"              transaction_commitment = next_commitment","counters":[]},{"line":"            ; full_transaction_commitment = next_full_commitment","counters":[]},{"line":"            }","counters":[]},{"line":"          in","counters":[]},{"line":"          let w : Zkapp_command_segment.Witness.t =","counters":[]},{"line":"            { global_ledger = source_global.ledger","counters":[]},{"line":"            ; local_state_init = source_local","counters":[]},{"line":"            ; start_zkapp_command","counters":[]},{"line":"            ; state_body","counters":[]},{"line":"            ; init_stack = pending_coinbase_init_stack","counters":[]},{"line":"            }","counters":[]},{"line":"          in","counters":[]},{"line":"          let fee_excess =","counters":[]},{"line":"            (* capture only the difference in the fee excess *)","counters":[]},{"line":"            let fee_excess =","counters":[]},{"line":"              match","counters":[]},{"line":"                Amount.Signed.(","counters":[]},{"line":"                  add target_global.fee_excess (negate source_global.fee_excess))","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"              with","counters":[]},{"line":"              | None ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  failwith","counters":[]},{"line":"                    (sprintf","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                       !\"unexpected fee excess. source %{sexp: \\","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                         Amount.Signed.t} target %{sexp: Amount.Signed.t}\"","counters":[]},{"line":"                       target_global.fee_excess source_global.fee_excess )","counters":[]},{"line":"              | Some balance_change ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  balance_change","counters":[]},{"line":"            in","counters":[]},{"line":"            { fee_token_l = Token_id.default","counters":[]},{"line":"            ; fee_excess_l = Amount.Signed.to_fee fee_excess","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"            ; Mina_base.Fee_excess.fee_token_r = Token_id.default","counters":[]},{"line":"            ; fee_excess_r = Fee.Signed.zero","counters":[]},{"line":"            }","counters":[]},{"line":"          in","counters":[]},{"line":"          let supply_increase =","counters":[]},{"line":"            (* capture only the difference in supply increase *)","counters":[]},{"line":"            match","counters":[]},{"line":"              Amount.Signed.(","counters":[]},{"line":"                add target_global.supply_increase","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  (negate source_global.supply_increase))","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"            with","counters":[]},{"line":"            | None ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                failwith","counters":[]},{"line":"                  (sprintf","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                     !\"unexpected supply increase. source %{sexp: \\","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                       Amount.Signed.t} target %{sexp: Amount.Signed.t}\"","counters":[]},{"line":"                     target_global.supply_increase source_global.supply_increase )","counters":[]},{"line":"            | Some supply_increase ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                supply_increase","counters":[]},{"line":"          in","counters":[]},{"line":"          let call_stack_hash s =","counters":[]},{"line":"            List.hd s","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"            |> Option.value_map ~default:Call_stack_digest.empty","counters":[]},{"line":"                 ~f:With_stack_hash.stack_hash","counters":[]},{"line":"          in","counters":[]},{"line":"          let statement : Statement.With_sok.t =","counters":[]},{"line":"            (* empty ledger hash in the local state at the beginning of each","counters":[]},{"line":"               transaction","counters":[]},{"line":"               `zkapp_command` in local state is empty for the first segment*)","counters":[]},{"line":"            let source_local_ledger =","counters":[]},{"line":"              if","counters":[]},{"line":"                Zkapp_command.Call_forest.is_empty","counters":[]},{"line":"                  source_local.stack_frame.calls","counters":[]},{"line":"              then Frozen_ledger_hash.empty_hash","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"              else Sparse_ledger.merkle_root source_local.ledger","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"            in","counters":[]},{"line":"            { source =","counters":[]},{"line":"                { ledger = Sparse_ledger.merkle_root source_global.ledger","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                ; pending_coinbase_stack = pending_coinbase_stack_state.source","counters":[]},{"line":"                ; local_state =","counters":[]},{"line":"                    { source_local with","counters":[]},{"line":"                      stack_frame =","counters":[]},{"line":"                        Stack_frame.Digest.create source_local.stack_frame","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"                    ; call_stack = call_stack_hash source_local.call_stack","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"                    ; ledger = source_local_ledger","counters":[]},{"line":"                    }","counters":[]},{"line":"                }","counters":[]},{"line":"            ; target =","counters":[]},{"line":"                { ledger = Sparse_ledger.merkle_root target_global.ledger","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                ; pending_coinbase_stack = pending_coinbase_stack_state.target","counters":[]},{"line":"                ; local_state =","counters":[]},{"line":"                    { target_local with","counters":[]},{"line":"                      stack_frame =","counters":[]},{"line":"                        Stack_frame.Digest.create target_local.stack_frame","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"                    ; call_stack = call_stack_hash target_local.call_stack","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"                    ; ledger = Sparse_ledger.merkle_root target_local.ledger","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"                    }","counters":[]},{"line":"                }","counters":[]},{"line":"            ; supply_increase","counters":[]},{"line":"            ; fee_excess","counters":[]},{"line":"            ; sok_digest = Sok_message.Digest.default","counters":[]},{"line":"            }","counters":[]},{"line":"          in","counters":[]},{"line":"          (w, spec, statement) :: witnesses )","counters":[]},{"line":"    , final_ledger )","counters":[]},{"line":"","counters":[]},{"line":"  module Make (Inputs : sig","counters":[]},{"line":"    val constraint_constants : Genesis_constants.Constraint_constants.t","counters":[]},{"line":"","counters":[]},{"line":"    val proof_level : Genesis_constants.Proof_level.t","counters":[]},{"line":"  end) =","counters":[]},{"line":"  struct","counters":[]},{"line":"    open Inputs","counters":[]},{"line":"","counters":[]},{"line":"    let constraint_constants = constraint_constants","counters":[]},{"line":"","counters":[]},{"line":"    let ( tag","counters":[]},{"line":"        , cache_handle","counters":[]},{"line":"        , p","counters":[]},{"line":"        , Pickles.Provers.","counters":[]},{"line":"            [ base; merge; opt_signed_opt_signed; opt_signed; proved ] ) =","counters":[]},{"line":"      system ~proof_level ~constraint_constants","counters":[]},{"line":"","counters":[]},{"line":"    module Proof = (val p)","counters":[]},{"line":"","counters":[]},{"line":"    let id = Proof.id","counters":[]},{"line":"","counters":[]},{"line":"    let verification_key = Proof.verification_key","counters":[]},{"line":"","counters":[]},{"line":"    let verify_against_digest { statement; proof } =","counters":[]},{"line":"      Proof.verify [ (statement, proof) ]","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let verify ts =","counters":[]},{"line":"      if","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        List.for_all ts ~f:(fun (p, m) ->","counters":[]},{"line":"            Sok_message.Digest.equal (Sok_message.digest m)","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"              p.statement.sok_digest )","counters":[]},{"line":"      then","counters":[]},{"line":"        Proof.verify","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (List.map ts ~f:(fun ({ statement; proof }, _) -> (statement, proof)))","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"      else Async.return false","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"","counters":[]},{"line":"    let first_account_update","counters":[]},{"line":"        (witness : Transaction_witness.Zkapp_command_segment_witness.t) =","counters":[]},{"line":"      match witness.local_state_init.stack_frame.calls with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | [] ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          with_return (fun { return } ->","counters":[]},{"line":"              List.iter witness.start_zkapp_command ~f:(fun s ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                  Zkapp_command.Call_forest.iteri","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    ~f:(fun _i x -> return (Some x))","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"                    s.zkapp_command.account_updates ) ;","counters":[]},{"line":"              None )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"      | xs ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Zkapp_command.Call_forest.hd_account_update xs","counters":[]},{"line":"","counters":[]},{"line":"    let account_update_proof (p : Account_update.t) =","counters":[]},{"line":"      match p.authorization with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Proof p ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Some p","counters":[]},{"line":"      | Signature _ | None_given ->","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"          None","counters":[]},{"line":"","counters":[]},{"line":"    let snapp_proof_data","counters":[]},{"line":"        ~(witness : Transaction_witness.Zkapp_command_segment_witness.t) =","counters":[]},{"line":"      let open Option.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%bind p = first_account_update witness in","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"      let%map pi = account_update_proof p in","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"      let vk =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let account_id = Account_id.create p.body.public_key p.body.token_id in","counters":[]},{"line":"        let account : Account.t =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Sparse_ledger.(","counters":[]},{"line":"            get_exn witness.local_state_init.ledger","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"              (find_index_exn witness.local_state_init.ledger account_id))","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"        in","counters":[]},{"line":"        match","counters":[]},{"line":"          Option.value_map ~default:None account.zkapp ~f:(fun s ->","counters":[]},{"line":"              s.verification_key )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"        with","counters":[]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            failwith \"No verification key found in the account\"","counters":[]},{"line":"        | Some s ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            s","counters":[]},{"line":"      in","counters":[]},{"line":"      (pi, vk)","counters":[]},{"line":"","counters":[]},{"line":"    let of_zkapp_command_segment_exn ~(statement : Proof.statement) ~witness","counters":[]},{"line":"        ~(spec : Zkapp_command_segment.Basic.t) : t Async.Deferred.t =","counters":[]},{"line":"      Base.Zkapp_command_snark.witness := Some witness ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let res =","counters":[]},{"line":"        match spec with","counters":[]},{"line":"        | Opt_signed ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            opt_signed statement","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"        | Opt_signed_opt_signed ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            opt_signed_opt_signed statement","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"        | Proved -> (","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            match snapp_proof_data ~witness with","counters":[]},{"line":"            | None ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                failwith \"of_zkapp_command_segment: Expected exactly one proof\"","counters":[]},{"line":"            | Some (p, v) ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Pickles.Side_loaded.in_prover (Base.side_loaded 0) v.data ;","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"                proved","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"                  ~handler:(Base.Zkapp_command_snark.handle_zkapp_proof p)","counters":[{"col_start":70,"col_end":70,"count":0}]},{"line":"                  statement )","counters":[]},{"line":"      in","counters":[]},{"line":"      let open Async in","counters":[]},{"line":"      let%map (), (), proof = res in","counters":[]},{"line":"      Base.Zkapp_command_snark.witness := None ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      { proof; statement }","counters":[]},{"line":"","counters":[]},{"line":"    let of_transaction_union ~statement ~init_stack transaction state_body","counters":[]},{"line":"        handler =","counters":[]},{"line":"      let open Async in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%map (), (), proof =","counters":[]},{"line":"        base","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"          ~handler:","counters":[]},{"line":"            (Base.transaction_union_handler handler transaction state_body","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"               init_stack )","counters":[]},{"line":"          statement","counters":[]},{"line":"      in","counters":[]},{"line":"      { statement; proof }","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let of_non_zkapp_command_transaction ~statement ~init_stack","counters":[]},{"line":"        transaction_in_block handler =","counters":[]},{"line":"      let transaction : Transaction.t =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Transaction.forget","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"          (Transaction_protocol_state.transaction transaction_in_block)","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"      in","counters":[]},{"line":"      let state_body =","counters":[]},{"line":"        Transaction_protocol_state.block_data transaction_in_block","counters":[]},{"line":"      in","counters":[]},{"line":"      match to_preunion transaction with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | `Zkapp_command _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          failwith","counters":[]},{"line":"            \"Called Non-zkapp_command transaction with zkapp_command \\","counters":[]},{"line":"             transaction\"","counters":[]},{"line":"      | `Transaction t ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          of_transaction_union ~statement ~init_stack","counters":[]},{"line":"            (Transaction_union.of_transaction t)","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"            state_body handler","counters":[]},{"line":"","counters":[]},{"line":"    let of_user_command ~statement ~init_stack user_command_in_block handler =","counters":[]},{"line":"      of_non_zkapp_command_transaction ~statement ~init_stack","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { user_command_in_block with","counters":[]},{"line":"          transaction =","counters":[]},{"line":"            Command","counters":[]},{"line":"              (Signed_command","counters":[]},{"line":"                 (Transaction_protocol_state.transaction user_command_in_block)","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"              )","counters":[]},{"line":"        }","counters":[]},{"line":"        handler","counters":[]},{"line":"","counters":[]},{"line":"    let of_fee_transfer ~statement ~init_stack transfer_in_block handler =","counters":[]},{"line":"      of_non_zkapp_command_transaction ~statement ~init_stack","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { transfer_in_block with","counters":[]},{"line":"          transaction =","counters":[]},{"line":"            Fee_transfer","counters":[]},{"line":"              (Transaction_protocol_state.transaction transfer_in_block)","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"        }","counters":[]},{"line":"        handler","counters":[]},{"line":"","counters":[]},{"line":"    let merge ({ statement = t12; _ } as x12) ({ statement = t23; _ } as x23)","counters":[]},{"line":"        ~sok_digest =","counters":[]},{"line":"      let open Async.Deferred.Or_error.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%bind s = Async.return (Statement.merge t12 t23) in","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"      let s = { s with sok_digest } in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let open Async in","counters":[]},{"line":"      let%map (), (), proof =","counters":[]},{"line":"        merge","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          ~handler:","counters":[]},{"line":"            (Merge.handle (x12.statement, x23.statement) (x12.proof, x23.proof))","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"          s","counters":[]},{"line":"      in","counters":[]},{"line":"      Ok { statement = s; proof }","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let constraint_system_digests =","counters":[]},{"line":"      lazy (constraint_system_digests ~constraint_constants ())","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module For_tests = struct","counters":[]},{"line":"    module Spec = struct","counters":[]},{"line":"      type t =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { fee : Currency.Fee.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":12,"col_end":12,"count":0}]},{"line":"        ; sender : Signature_lib.Keypair.t * Mina_base.Account.Nonce.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"        ; fee_payer :","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"            (Signature_lib.Keypair.t * Mina_base.Account.Nonce.t) option","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"        ; receivers :","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"            (Signature_lib.Public_key.Compressed.t * Currency.Amount.t) list","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"        ; amount : Currency.Amount.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"        ; zkapp_account_keypairs : Signature_lib.Keypair.t list","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"        ; memo : Signed_command_memo.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":13,"col_end":13,"count":0}]},{"line":"        ; new_zkapp_account : bool","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"        ; sequence_events : Tick.Field.t array list","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"        ; events : Tick.Field.t array list","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"        ; call_data : Tick.Field.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"        ; preconditions : Account_update.Preconditions.t option","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"        ; authorization_kind : Account_update.Authorization_kind.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"        }","counters":[]},{"line":"      [@@deriving sexp]","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    let create_trivial_snapp ~constraint_constants () =","counters":[]},{"line":"      let tag, _, (module P), Pickles.Provers.[ trivial_prover; _ ] =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let trivial_rule : _ Pickles.Inductive_rule.t =","counters":[]},{"line":"          let trivial_main (tx_commitment : Zkapp_statement.Checked.t) :","counters":[]},{"line":"              unit Checked.t =","counters":[]},{"line":"            Impl.run_checked (dummy_constraints ())","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"            |> fun () ->","counters":[]},{"line":"            Zkapp_statement.Checked.Assert.equal tx_commitment tx_commitment","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"            |> return","counters":[]},{"line":"          in","counters":[]},{"line":"          { identifier = \"trivial-rule\"","counters":[]},{"line":"          ; prevs = []","counters":[]},{"line":"          ; main =","counters":[]},{"line":"              (fun { public_input = x } ->","counters":[]},{"line":"                let () = Impl.run_checked (trivial_main x) in","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"                { previous_proof_statements = []","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                ; public_output = ()","counters":[]},{"line":"                ; auxiliary_output = ()","counters":[]},{"line":"                } )","counters":[]},{"line":"          ; uses_lookup = false","counters":[]},{"line":"          }","counters":[]},{"line":"        in","counters":[]},{"line":"        Pickles.compile () ~cache:Cache_dir.cache","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"          ~public_input:(Input Zkapp_statement.typ) ~auxiliary_typ:Typ.unit","counters":[]},{"line":"          ~branches:(module Nat.N2)","counters":[]},{"line":"          ~max_proofs_verified:(module Nat.N2) (* You have to put 2 here... *)","counters":[]},{"line":"          ~name:\"trivial\"","counters":[]},{"line":"          ~constraint_constants:","counters":[]},{"line":"            (Genesis_constants.Constraint_constants.to_snark_keys_header","counters":[{"col_start":71,"col_end":71,"count":0}]},{"line":"               constraint_constants )","counters":[]},{"line":"          ~choices:(fun ~self ->","counters":[]},{"line":"            [ trivial_rule","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            ; { identifier = \"dummy\"","counters":[]},{"line":"              ; prevs = [ self; self ]","counters":[]},{"line":"              ; main =","counters":[]},{"line":"                  (fun { public_input = _ } ->","counters":[]},{"line":"                    let s =","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      Run.exists Field.typ ~compute:(fun () ->","counters":[]},{"line":"                          Run.Field.Constant.zero )","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                    in","counters":[]},{"line":"                    let public_input =","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      Run.exists Zkapp_statement.typ ~compute:(fun () ->","counters":[]},{"line":"                          assert false )","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                    in","counters":[]},{"line":"                    let proof =","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      Run.exists (Typ.Internal.ref ()) ~compute:(fun () ->","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"                          assert false )","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                    in","counters":[]},{"line":"                    Impl.run_checked (dummy_constraints ()) ;","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"                    (* Unsatisfiable. *)","counters":[]},{"line":"                    Run.Field.(Assert.equal s (s + one)) ;","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"                    { previous_proof_statements =","counters":[]},{"line":"                        [ { public_input","counters":[]},{"line":"                          ; proof","counters":[]},{"line":"                          ; proof_must_verify = Boolean.true_","counters":[]},{"line":"                          }","counters":[]},{"line":"                        ; { public_input","counters":[]},{"line":"                          ; proof","counters":[]},{"line":"                          ; proof_must_verify = Boolean.true_","counters":[]},{"line":"                          }","counters":[]},{"line":"                        ]","counters":[]},{"line":"                    ; public_output = ()","counters":[]},{"line":"                    ; auxiliary_output = ()","counters":[]},{"line":"                    } )","counters":[]},{"line":"              ; uses_lookup = false","counters":[]},{"line":"              }","counters":[]},{"line":"            ] )","counters":[]},{"line":"      in","counters":[]},{"line":"      let vk = Pickles.Side_loaded.Verification_key.of_compiled tag in","counters":[]},{"line":"      ( `VK (With_hash.of_data ~hash_data:Zkapp_account.digest_vk vk)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"      , `Prover trivial_prover )","counters":[]},{"line":"","counters":[]},{"line":"    let create_zkapp_command","counters":[]},{"line":"        ~(constraint_constants : Genesis_constants.Constraint_constants.t) spec","counters":[]},{"line":"        ~update =","counters":[]},{"line":"      let { Spec.fee","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          ; sender = sender, sender_nonce","counters":[]},{"line":"          ; fee_payer = fee_payer_opt","counters":[]},{"line":"          ; receivers","counters":[]},{"line":"          ; amount","counters":[]},{"line":"          ; new_zkapp_account","counters":[]},{"line":"          ; zkapp_account_keypairs","counters":[]},{"line":"          ; memo","counters":[]},{"line":"          ; sequence_events","counters":[]},{"line":"          ; events","counters":[]},{"line":"          ; call_data","counters":[]},{"line":"          ; preconditions","counters":[]},{"line":"          ; authorization_kind","counters":[]},{"line":"          } =","counters":[]},{"line":"        spec","counters":[]},{"line":"      in","counters":[]},{"line":"      let sender_pk = sender.public_key |> Public_key.compress in","counters":[]},{"line":"      let fee_payer : Account_update.Fee_payer.t =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let public_key, nonce =","counters":[]},{"line":"          match fee_payer_opt with","counters":[]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (sender_pk, sender_nonce)","counters":[]},{"line":"          | Some (fee_payer_kp, fee_payer_nonce) ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (fee_payer_kp.public_key |> Public_key.compress, fee_payer_nonce)","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"        in","counters":[]},{"line":"        { body =","counters":[]},{"line":"            { public_key","counters":[]},{"line":"            ; fee","counters":[]},{"line":"            ; valid_until =","counters":[]},{"line":"                Option.bind preconditions ~f:(fun { network; _ } ->","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                    match network.global_slot_since_genesis with","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                    | Ignore ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        None","counters":[]},{"line":"                    | Check { upper; _ } ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        Some upper )","counters":[]},{"line":"            ; nonce","counters":[]},{"line":"            }","counters":[]},{"line":"        ; authorization = Signature.dummy","counters":[]},{"line":"        }","counters":[]},{"line":"      in","counters":[]},{"line":"      let preconditions' =","counters":[]},{"line":"        Option.value preconditions","counters":[]},{"line":"          ~default:","counters":[]},{"line":"            { Account_update.Preconditions.network =","counters":[]},{"line":"                Option.value_map preconditions","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                  ~f:(fun { network; _ } -> network)","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"                  ~default:Zkapp_precondition.Protocol_state.accept","counters":[]},{"line":"            ; account =","counters":[]},{"line":"                ( if Option.is_none fee_payer_opt then","counters":[]},{"line":"                  Nonce (Account.Nonce.succ sender_nonce)","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"                else Nonce sender_nonce )","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"            }","counters":[]},{"line":"      in","counters":[]},{"line":"","counters":[]},{"line":"      let sender_account_update : Account_update.Simple.t option =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let sender_account_update_body : Account_update.Body.Simple.t =","counters":[]},{"line":"          { public_key = sender_pk","counters":[]},{"line":"          ; update = Account_update.Update.noop","counters":[]},{"line":"          ; token_id = Token_id.default","counters":[]},{"line":"          ; balance_change = Amount.(Signed.(negate (of_unsigned amount)))","counters":[{"col_start":50,"col_end":50,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"          ; increment_nonce = true","counters":[]},{"line":"          ; events = []","counters":[]},{"line":"          ; sequence_events = []","counters":[]},{"line":"          ; call_data = Field.zero","counters":[]},{"line":"          ; call_depth = 0","counters":[]},{"line":"          ; preconditions = preconditions'","counters":[]},{"line":"          ; use_full_commitment = false","counters":[]},{"line":"          ; caller = Call","counters":[]},{"line":"          ; authorization_kind = Signature","counters":[]},{"line":"          }","counters":[]},{"line":"        in","counters":[]},{"line":"        Option.some_if","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"          ((not (List.is_empty receivers)) || new_zkapp_account)","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"          ( { body = sender_account_update_body","counters":[]},{"line":"            ; authorization =","counters":[]},{"line":"                Control.Signature Signature.dummy (*To be updated later*)","counters":[]},{"line":"            }","counters":[]},{"line":"            : Account_update.Simple.t )","counters":[]},{"line":"      in","counters":[]},{"line":"      let snapp_zkapp_command : Account_update.Simple.t list =","counters":[]},{"line":"        let num_keypairs = List.length zkapp_account_keypairs in","counters":[]},{"line":"        let account_creation_fee =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Amount.of_fee constraint_constants.account_creation_fee","counters":[]},{"line":"        in","counters":[]},{"line":"        (* if creating new snapp accounts, amount must be enough for account creation fees for each *)","counters":[]},{"line":"        assert (","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"          (not new_zkapp_account) || num_keypairs = 0","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"          ||","counters":[]},{"line":"          match Currency.Amount.scale account_creation_fee num_keypairs with","counters":[]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              false","counters":[]},{"line":"          | Some product ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Currency.Amount.( >= ) amount product ) ;","counters":[{"col_start":35,"col_end":35,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"        (* \"fudge factor\" so that balances sum to zero *)","counters":[]},{"line":"        let zeroing_allotment =","counters":[]},{"line":"          if new_zkapp_account then","counters":[]},{"line":"            (* value doesn't matter when num_keypairs = 0 *)","counters":[]},{"line":"            if num_keypairs = 0 then amount","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"            else","counters":[]},{"line":"              let otherwise_allotted =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Option.value_exn","counters":[]},{"line":"                  (Currency.Amount.scale account_creation_fee num_keypairs)","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"              in","counters":[]},{"line":"              Option.value_exn (Currency.Amount.sub amount otherwise_allotted)","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"          else Currency.Amount.zero","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"        in","counters":[]},{"line":"        List.mapi zkapp_account_keypairs ~f:(fun ndx zkapp_account_keypair ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"            let public_key =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Signature_lib.Public_key.compress zkapp_account_keypair.public_key","counters":[]},{"line":"            in","counters":[]},{"line":"            let delta =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              if new_zkapp_account && ndx = 0 then","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"                Amount.Signed.(of_unsigned zeroing_allotment)","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"              else Amount.Signed.zero","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"            in","counters":[]},{"line":"            ( { body =","counters":[]},{"line":"                  { public_key","counters":[]},{"line":"                  ; update","counters":[]},{"line":"                  ; token_id = Token_id.default","counters":[]},{"line":"                  ; balance_change = delta","counters":[]},{"line":"                  ; increment_nonce = false","counters":[]},{"line":"                  ; events","counters":[]},{"line":"                  ; sequence_events","counters":[]},{"line":"                  ; call_data","counters":[]},{"line":"                  ; call_depth = 0","counters":[]},{"line":"                  ; preconditions =","counters":[]},{"line":"                      { preconditions' with","counters":[]},{"line":"                        account =","counters":[]},{"line":"                          Option.map preconditions ~f:(fun { account; _ } ->","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                              account )","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                          |> Option.value ~default:Accept","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"                      }","counters":[]},{"line":"                  ; use_full_commitment = true","counters":[]},{"line":"                  ; caller = Call","counters":[]},{"line":"                  ; authorization_kind","counters":[]},{"line":"                  }","counters":[]},{"line":"              ; authorization =","counters":[]},{"line":"                  Control.Signature Signature.dummy (*To be updated later*)","counters":[]},{"line":"              }","counters":[]},{"line":"              : Account_update.Simple.t ) )","counters":[]},{"line":"      in","counters":[]},{"line":"      let other_receivers =","counters":[]},{"line":"        List.map receivers ~f:(fun (receiver, amt) : Account_update.Simple.t ->","counters":[]},{"line":"            { body =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"                { public_key = receiver","counters":[]},{"line":"                ; update","counters":[]},{"line":"                ; token_id = Token_id.default","counters":[]},{"line":"                ; balance_change = Amount.Signed.of_unsigned amt","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"                ; increment_nonce = false","counters":[]},{"line":"                ; events = []","counters":[]},{"line":"                ; sequence_events = []","counters":[]},{"line":"                ; call_data = Field.zero","counters":[]},{"line":"                ; call_depth = 0","counters":[]},{"line":"                ; preconditions = { preconditions' with account = Accept }","counters":[]},{"line":"                ; use_full_commitment = false","counters":[]},{"line":"                ; caller = Call","counters":[]},{"line":"                ; authorization_kind = None_given","counters":[]},{"line":"                }","counters":[]},{"line":"            ; authorization = Control.None_given","counters":[]},{"line":"            } )","counters":[]},{"line":"      in","counters":[]},{"line":"      let account_updates_data =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Option.value_map ~default:[] sender_account_update ~f:(fun p -> [ p ])","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":72,"col_end":72,"count":0}]},{"line":"        @ snapp_zkapp_command @ other_receivers","counters":[]},{"line":"      in","counters":[]},{"line":"      let ps =","counters":[]},{"line":"        Zkapp_command.Call_forest.With_hashes.of_zkapp_command_simple_list","counters":[]},{"line":"          account_updates_data","counters":[]},{"line":"      in","counters":[]},{"line":"      let account_updates_hash = Zkapp_command.Call_forest.hash ps in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let commitment : Zkapp_command.Transaction_commitment.t =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Zkapp_command.Transaction_commitment.create ~account_updates_hash","counters":[]},{"line":"      in","counters":[]},{"line":"      let full_commitment =","counters":[]},{"line":"        Zkapp_command.Transaction_commitment.create_complete commitment","counters":[]},{"line":"          ~memo_hash:(Signed_command_memo.hash memo)","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"          ~fee_payer_hash:","counters":[]},{"line":"            (Zkapp_command.Digest.Account_update.create","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"               (Account_update.of_fee_payer fee_payer) )","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"      in","counters":[]},{"line":"      let fee_payer =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let fee_payer_signature_auth =","counters":[]},{"line":"          match fee_payer_opt with","counters":[]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Signature_lib.Schnorr.Chunked.sign sender.private_key","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"                (Random_oracle.Input.Chunked.field full_commitment)","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"          | Some (fee_payer_kp, _) ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Signature_lib.Schnorr.Chunked.sign fee_payer_kp.private_key","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"                (Random_oracle.Input.Chunked.field full_commitment)","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"        in","counters":[]},{"line":"        { fee_payer with authorization = fee_payer_signature_auth }","counters":[]},{"line":"      in","counters":[]},{"line":"      let sender_account_update =","counters":[]},{"line":"        Option.map sender_account_update ~f:(fun s : Account_update.Simple.t ->","counters":[]},{"line":"            let commitment =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              if s.body.use_full_commitment then full_commitment else commitment","counters":[{"col_start":49,"col_end":49,"count":0},{"col_start":70,"col_end":70,"count":0}]},{"line":"            in","counters":[]},{"line":"            let sender_signature_auth =","counters":[]},{"line":"              Signature_lib.Schnorr.Chunked.sign sender.private_key","counters":[]},{"line":"                (Random_oracle.Input.Chunked.field commitment)","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"            in","counters":[]},{"line":"            { body = s.body; authorization = Signature sender_signature_auth } )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"      in","counters":[]},{"line":"      ( `Zkapp_command","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          (Zkapp_command.of_simple","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"             { fee_payer; account_updates = other_receivers; memo } )","counters":[]},{"line":"      , `Sender_account_update sender_account_update","counters":[]},{"line":"      , `Proof_zkapp_command snapp_zkapp_command","counters":[]},{"line":"      , `Txn_commitment commitment","counters":[]},{"line":"      , `Full_txn_commitment full_commitment )","counters":[]},{"line":"","counters":[]},{"line":"    module Deploy_snapp_spec = struct","counters":[]},{"line":"      type t =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { fee : Currency.Fee.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":12,"col_end":12,"count":0}]},{"line":"        ; sender : Signature_lib.Keypair.t * Mina_base.Account.Nonce.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"        ; fee_payer :","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"            (Signature_lib.Keypair.t * Mina_base.Account.Nonce.t) option","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"        ; amount : Currency.Amount.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"        ; zkapp_account_keypairs : Signature_lib.Keypair.t list","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"        ; memo : Signed_command_memo.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":13,"col_end":13,"count":0}]},{"line":"        ; new_zkapp_account : bool","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"        ; snapp_update : Account_update.Update.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"              (* Authorization for the update being performed *)","counters":[]},{"line":"        ; preconditions : Account_update.Preconditions.t option","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"        ; authorization_kind : Account_update.Authorization_kind.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"        }","counters":[]},{"line":"      [@@deriving sexp]","counters":[]},{"line":"","counters":[]},{"line":"      let spec_of_t","counters":[]},{"line":"          { fee","counters":[]},{"line":"          ; sender","counters":[]},{"line":"          ; fee_payer","counters":[]},{"line":"          ; amount","counters":[]},{"line":"          ; zkapp_account_keypairs","counters":[]},{"line":"          ; memo","counters":[]},{"line":"          ; new_zkapp_account","counters":[]},{"line":"          ; snapp_update = _","counters":[]},{"line":"          ; preconditions","counters":[]},{"line":"          ; authorization_kind","counters":[]},{"line":"          } : Spec.t =","counters":[]},{"line":"        { fee","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        ; sender","counters":[]},{"line":"        ; fee_payer","counters":[]},{"line":"        ; receivers = []","counters":[]},{"line":"        ; amount","counters":[]},{"line":"        ; zkapp_account_keypairs","counters":[]},{"line":"        ; memo","counters":[]},{"line":"        ; new_zkapp_account","counters":[]},{"line":"        ; sequence_events = []","counters":[]},{"line":"        ; events = []","counters":[]},{"line":"        ; call_data = Tick.Field.zero","counters":[]},{"line":"        ; preconditions","counters":[]},{"line":"        ; authorization_kind","counters":[]},{"line":"        }","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    let deploy_snapp ?(no_auth = false) ~constraint_constants","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"        (spec : Deploy_snapp_spec.t) =","counters":[]},{"line":"      let `VK vk, `Prover _trivial_prover =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        create_trivial_snapp ~constraint_constants ()","counters":[]},{"line":"      in","counters":[]},{"line":"      (* only allow timing on a single new snapp account","counters":[]},{"line":"         balance changes for other new snapp accounts are just the account creation fee","counters":[]},{"line":"      *)","counters":[]},{"line":"      assert (","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":13,"col_end":13,"count":0}]},{"line":"        Zkapp_basic.Set_or_keep.is_keep spec.snapp_update.timing","counters":[{"col_start":38,"col_end":38,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"        || spec.new_zkapp_account","counters":[]},{"line":"           && List.length spec.zkapp_account_keypairs = 1 ) ;","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"      let update_vk =","counters":[]},{"line":"        let update = spec.snapp_update in","counters":[]},{"line":"        if no_auth then update","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"        else","counters":[]},{"line":"          { update with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            verification_key = Zkapp_basic.Set_or_keep.Set vk","counters":[]},{"line":"          ; permissions =","counters":[]},{"line":"              Zkapp_basic.Set_or_keep.Set","counters":[]},{"line":"                { Permissions.user_default with","counters":[]},{"line":"                  edit_state = Permissions.Auth_required.Proof","counters":[]},{"line":"                ; edit_sequence_state = Proof","counters":[]},{"line":"                }","counters":[]},{"line":"          }","counters":[]},{"line":"      in","counters":[]},{"line":"      let ( `Zkapp_command { Zkapp_command.fee_payer; account_updates; memo }","counters":[]},{"line":"          , `Sender_account_update sender_account_update","counters":[]},{"line":"          , `Proof_zkapp_command snapp_zkapp_command","counters":[]},{"line":"          , `Txn_commitment commitment","counters":[]},{"line":"          , `Full_txn_commitment full_commitment ) =","counters":[]},{"line":"        create_zkapp_command ~constraint_constants","counters":[]},{"line":"          (Deploy_snapp_spec.spec_of_t spec)","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"          ~update:update_vk","counters":[]},{"line":"      in","counters":[]},{"line":"      assert (List.is_empty account_updates) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"      (* invariant: same number of keypairs, snapp_zkapp_command *)","counters":[]},{"line":"      let snapp_zkapp_command_keypairs =","counters":[]},{"line":"        List.zip_exn snapp_zkapp_command spec.zkapp_account_keypairs","counters":[]},{"line":"      in","counters":[]},{"line":"      let snapp_zkapp_command =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        List.map snapp_zkapp_command_keypairs","counters":[]},{"line":"          ~f:(fun (snapp_account_update, keypair) ->","counters":[]},{"line":"            if no_auth then","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              ( { body = snapp_account_update.body; authorization = None_given }","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                : Account_update.Simple.t )","counters":[]},{"line":"            else","counters":[]},{"line":"              let commitment =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                if snapp_account_update.body.use_full_commitment then","counters":[]},{"line":"                  full_commitment","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                else commitment","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"              in","counters":[]},{"line":"              let signature =","counters":[]},{"line":"                Signature_lib.Schnorr.Chunked.sign keypair.private_key","counters":[]},{"line":"                  (Random_oracle.Input.Chunked.field commitment)","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"              in","counters":[]},{"line":"              ( { body = snapp_account_update.body","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ; authorization = Signature signature","counters":[]},{"line":"                }","counters":[]},{"line":"                : Account_update.Simple.t ) )","counters":[]},{"line":"      in","counters":[]},{"line":"      let account_updates =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Option.to_list sender_account_update @ snapp_zkapp_command","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"      in","counters":[]},{"line":"      let zkapp_command : Zkapp_command.t =","counters":[]},{"line":"        { fee_payer","counters":[]},{"line":"        ; memo","counters":[]},{"line":"        ; account_updates =","counters":[]},{"line":"            Zkapp_command.Call_forest.of_account_updates account_updates","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"              ~account_update_depth:(fun (p : Account_update.Simple.t) ->","counters":[]},{"line":"                p.body.call_depth )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"            |> Zkapp_command.Call_forest.add_callers","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                 ~call_type:(fun (p : Account_update.Simple.t) -> p.body.caller)","counters":[{"col_start":66,"col_end":66,"count":0}]},{"line":"                 ~add_caller:Zkapp_command.add_caller_simple","counters":[]},{"line":"                 ~null_id:Token_id.default","counters":[]},{"line":"                 ~account_update_id:(fun (p : Account_update.Simple.t) ->","counters":[]},{"line":"                   Account_id.(","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"                     derive_token_id","counters":[]},{"line":"                       ~owner:(create p.body.public_key p.body.token_id)) )","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"            |> Zkapp_command.Call_forest.accumulate_hashes","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"                 ~hash_account_update:(fun (p : Account_update.t) ->","counters":[]},{"line":"                   Zkapp_command.Digest.Account_update.create p )","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"        }","counters":[]},{"line":"      in","counters":[]},{"line":"      zkapp_command","counters":[]},{"line":"","counters":[]},{"line":"    module Update_states_spec = struct","counters":[]},{"line":"      type t =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { fee : Currency.Fee.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":12,"col_end":12,"count":0}]},{"line":"        ; sender : Signature_lib.Keypair.t * Mina_base.Account.Nonce.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"        ; fee_payer :","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"            (Signature_lib.Keypair.t * Mina_base.Account.Nonce.t) option","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"        ; receivers :","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"            (Signature_lib.Public_key.Compressed.t * Currency.Amount.t) list","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"        ; amount : Currency.Amount.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"        ; zkapp_account_keypairs : Signature_lib.Keypair.t list","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"        ; memo : Signed_command_memo.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":13,"col_end":13,"count":0}]},{"line":"        ; new_zkapp_account : bool","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"        ; snapp_update : Account_update.Update.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"              (* Authorization for the update being performed *)","counters":[]},{"line":"        ; current_auth : Permissions.Auth_required.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"        ; sequence_events : Tick.Field.t array list","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"        ; events : Tick.Field.t array list","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"        ; call_data : Tick.Field.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"        ; preconditions : Account_update.Preconditions.t option","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"        }","counters":[]},{"line":"      [@@deriving sexp]","counters":[]},{"line":"","counters":[]},{"line":"      let spec_of_t","counters":[]},{"line":"          { fee","counters":[]},{"line":"          ; sender","counters":[]},{"line":"          ; fee_payer","counters":[]},{"line":"          ; receivers","counters":[]},{"line":"          ; amount","counters":[]},{"line":"          ; zkapp_account_keypairs","counters":[]},{"line":"          ; memo","counters":[]},{"line":"          ; new_zkapp_account","counters":[]},{"line":"          ; snapp_update = _","counters":[]},{"line":"          ; current_auth","counters":[]},{"line":"          ; sequence_events","counters":[]},{"line":"          ; events","counters":[]},{"line":"          ; call_data","counters":[]},{"line":"          ; preconditions","counters":[]},{"line":"          } : Spec.t =","counters":[]},{"line":"        { fee","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        ; sender","counters":[]},{"line":"        ; fee_payer","counters":[]},{"line":"        ; receivers","counters":[]},{"line":"        ; amount","counters":[]},{"line":"        ; zkapp_account_keypairs","counters":[]},{"line":"        ; memo","counters":[]},{"line":"        ; new_zkapp_account","counters":[]},{"line":"        ; sequence_events","counters":[]},{"line":"        ; events","counters":[]},{"line":"        ; call_data","counters":[]},{"line":"        ; preconditions","counters":[]},{"line":"        ; authorization_kind =","counters":[]},{"line":"            ( match current_auth with","counters":[]},{"line":"            | None ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                None_given","counters":[]},{"line":"            | Signature ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Signature","counters":[]},{"line":"            | Proof ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Proof","counters":[]},{"line":"            | _ ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Signature )","counters":[]},{"line":"        }","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    let update_states ?zkapp_prover ~constraint_constants","counters":[]},{"line":"        (spec : Update_states_spec.t) =","counters":[]},{"line":"      let ( `Zkapp_command { Zkapp_command.fee_payer; account_updates; memo }","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          , `Sender_account_update sender_account_update","counters":[]},{"line":"          , `Proof_zkapp_command snapp_zkapp_command","counters":[]},{"line":"          , `Txn_commitment commitment","counters":[]},{"line":"          , `Full_txn_commitment full_commitment ) =","counters":[]},{"line":"        create_zkapp_command ~constraint_constants","counters":[]},{"line":"          (Update_states_spec.spec_of_t spec)","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"          ~update:spec.snapp_update","counters":[]},{"line":"      in","counters":[]},{"line":"      assert (List.is_empty account_updates) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"      assert (Option.is_none sender_account_update) ;","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"      assert (not @@ List.is_empty snapp_zkapp_command) ;","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"      let snapp_zkapp_command =","counters":[]},{"line":"        snapp_zkapp_command","counters":[]},{"line":"        |> List.map ~f:(fun p -> (p, p))","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"        |> Zkapp_command.Call_forest.With_hashes_and_data","counters":[]},{"line":"           .of_zkapp_command_simple_list","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"        |> Zkapp_statement.zkapp_statements_of_forest","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"        |> Zkapp_command.Call_forest.to_account_updates","counters":[]},{"line":"      in","counters":[]},{"line":"      let snapp_zkapp_command_keypairs =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        List.zip_exn snapp_zkapp_command spec.zkapp_account_keypairs","counters":[]},{"line":"      in","counters":[]},{"line":"      let%map.Async.Deferred snapp_zkapp_command =","counters":[]},{"line":"        Async.Deferred.List.map snapp_zkapp_command_keypairs","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"          ~f:(fun","counters":[]},{"line":"               ( ( (snapp_account_update, simple_snapp_account_update)","counters":[]},{"line":"                 , tx_statement )","counters":[]},{"line":"               , snapp_keypair )","counters":[]},{"line":"             ->","counters":[]},{"line":"            match spec.current_auth with","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            | Permissions.Auth_required.Proof ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                let handler","counters":[]},{"line":"                    (Snarky_backendless.Request.With { request; respond }) =","counters":[]},{"line":"                  match request with _ -> respond Unhandled","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"                in","counters":[]},{"line":"                let prover =","counters":[]},{"line":"                  match zkapp_prover with","counters":[]},{"line":"                  | Some prover ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      prover","counters":[]},{"line":"                  | None ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      let _, `Prover p =","counters":[]},{"line":"                        create_trivial_snapp ~constraint_constants ()","counters":[]},{"line":"                      in","counters":[]},{"line":"                      p","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                in","counters":[]},{"line":"                let%map.Async.Deferred (), (), (pi : Pickles.Side_loaded.Proof.t)","counters":[]},{"line":"                    =","counters":[]},{"line":"                  prover ~handler tx_statement","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                in","counters":[]},{"line":"                ( { body = simple_snapp_account_update.body","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  ; authorization = Proof pi","counters":[]},{"line":"                  }","counters":[]},{"line":"                  : Account_update.Simple.t )","counters":[]},{"line":"            | Signature ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                let commitment =","counters":[]},{"line":"                  if snapp_account_update.body.use_full_commitment then","counters":[]},{"line":"                    full_commitment","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                  else commitment","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                in","counters":[]},{"line":"                let signature =","counters":[]},{"line":"                  Signature_lib.Schnorr.Chunked.sign snapp_keypair.private_key","counters":[]},{"line":"                    (Random_oracle.Input.Chunked.field commitment)","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"                in","counters":[]},{"line":"                Async.Deferred.return","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  ( { body = simple_snapp_account_update.body","counters":[]},{"line":"                    ; authorization = Signature signature","counters":[]},{"line":"                    }","counters":[]},{"line":"                    : Account_update.Simple.t )","counters":[]},{"line":"            | None ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Async.Deferred.return","counters":[]},{"line":"                  ( { body = simple_snapp_account_update.body","counters":[]},{"line":"                    ; authorization = None_given","counters":[]},{"line":"                    }","counters":[]},{"line":"                    : Account_update.Simple.t )","counters":[]},{"line":"            | _ ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                failwith","counters":[]},{"line":"                  \"Current authorization not Proof or Signature or None_given\" )","counters":[]},{"line":"      in","counters":[]},{"line":"      let account_updates = snapp_zkapp_command in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let zkapp_command : Zkapp_command.t =","counters":[]},{"line":"        Zkapp_command.of_simple { fee_payer; account_updates; memo }","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"      in","counters":[]},{"line":"      zkapp_command","counters":[]},{"line":"","counters":[]},{"line":"    module Multiple_transfers_spec = struct","counters":[]},{"line":"      type t =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { fee : Currency.Fee.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":12,"col_end":12,"count":0}]},{"line":"        ; sender : Signature_lib.Keypair.t * Mina_base.Account.Nonce.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"        ; fee_payer :","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"            (Signature_lib.Keypair.t * Mina_base.Account.Nonce.t) option","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"        ; receivers :","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"            (Signature_lib.Public_key.Compressed.t * Currency.Amount.t) list","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"        ; amount : Currency.Amount.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"        ; zkapp_account_keypairs : Signature_lib.Keypair.t list","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"        ; memo : Signed_command_memo.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":13,"col_end":13,"count":0}]},{"line":"        ; new_zkapp_account : bool","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"        ; snapp_update : Account_update.Update.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"              (* Authorization for the update being performed *)","counters":[]},{"line":"        ; sequence_events : Tick.Field.t array list","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"        ; events : Tick.Field.t array list","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"        ; call_data : Tick.Field.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"        ; preconditions : Account_update.Preconditions.t option","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"        }","counters":[]},{"line":"      [@@deriving sexp]","counters":[]},{"line":"","counters":[]},{"line":"      let spec_of_t","counters":[]},{"line":"          { fee","counters":[]},{"line":"          ; sender","counters":[]},{"line":"          ; fee_payer","counters":[]},{"line":"          ; receivers","counters":[]},{"line":"          ; amount","counters":[]},{"line":"          ; zkapp_account_keypairs","counters":[]},{"line":"          ; memo","counters":[]},{"line":"          ; new_zkapp_account","counters":[]},{"line":"          ; snapp_update = _","counters":[]},{"line":"          ; sequence_events","counters":[]},{"line":"          ; events","counters":[]},{"line":"          ; call_data","counters":[]},{"line":"          ; preconditions","counters":[]},{"line":"          } : Spec.t =","counters":[]},{"line":"        { fee","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        ; sender","counters":[]},{"line":"        ; fee_payer","counters":[]},{"line":"        ; receivers","counters":[]},{"line":"        ; amount","counters":[]},{"line":"        ; zkapp_account_keypairs","counters":[]},{"line":"        ; memo","counters":[]},{"line":"        ; new_zkapp_account","counters":[]},{"line":"        ; sequence_events","counters":[]},{"line":"        ; events","counters":[]},{"line":"        ; call_data","counters":[]},{"line":"        ; preconditions","counters":[]},{"line":"        ; authorization_kind = Signature","counters":[]},{"line":"        }","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    let multiple_transfers (spec : Multiple_transfers_spec.t) =","counters":[]},{"line":"      let ( `Zkapp_command zkapp_command","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          , `Sender_account_update sender_account_update","counters":[]},{"line":"          , `Proof_zkapp_command snapp_zkapp_command","counters":[]},{"line":"          , `Txn_commitment _commitment","counters":[]},{"line":"          , `Full_txn_commitment _full_commitment ) =","counters":[]},{"line":"        create_zkapp_command","counters":[]},{"line":"          ~constraint_constants:Genesis_constants.Constraint_constants.compiled","counters":[]},{"line":"          (Multiple_transfers_spec.spec_of_t spec)","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"          ~update:spec.snapp_update","counters":[]},{"line":"      in","counters":[]},{"line":"      assert (Option.is_some sender_account_update) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"      assert (List.is_empty snapp_zkapp_command) ;","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"      let account_updates =","counters":[]},{"line":"        let sender_account_update = Option.value_exn sender_account_update in","counters":[]},{"line":"        Zkapp_command.Call_forest.cons","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"          (Zkapp_command.add_caller_simple sender_account_update","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"             Token_id.default )","counters":[]},{"line":"          zkapp_command.account_updates","counters":[]},{"line":"      in","counters":[]},{"line":"      { zkapp_command with account_updates }","counters":[]},{"line":"","counters":[]},{"line":"    let trivial_zkapp_account ?(permissions = Permissions.user_default) ~vk pk =","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"      let id = Account_id.create pk Token_id.default in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      { (Account.create id Balance.(of_int 1_000_000_000_000_000)) with","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"        permissions","counters":[]},{"line":"      ; zkapp = Some { Zkapp_account.default with verification_key = Some vk }","counters":[]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    let create_trivial_zkapp_account ?(permissions = Permissions.user_default)","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"        ~vk ~ledger pk =","counters":[]},{"line":"      let create ledger id account =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        match Ledger.location_of_account ledger id with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | Some _loc ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            failwith \"Account already present\"","counters":[]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let _loc, _new =","counters":[]},{"line":"              Ledger.get_or_create_account ledger id account |> Or_error.ok_exn","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"            in","counters":[]},{"line":"            ()","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"      in","counters":[]},{"line":"      let id = Account_id.create pk Token_id.default in","counters":[]},{"line":"      let account : Account.t = trivial_zkapp_account ~permissions ~vk pk in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"      create ledger id account","counters":[]},{"line":"","counters":[]},{"line":"    let create_trivial_predicate_snapp ~constraint_constants","counters":[]},{"line":"        ?(protocol_state_predicate = Zkapp_precondition.Protocol_state.accept)","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"        ~(snapp_kp : Signature_lib.Keypair.t) spec ledger =","counters":[]},{"line":"      let { Mina_transaction_logic.For_tests.Transaction_spec.fee","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          ; sender = sender, sender_nonce","counters":[]},{"line":"          ; receiver = _","counters":[]},{"line":"          ; receiver_is_new = _","counters":[]},{"line":"          ; amount","counters":[]},{"line":"          } =","counters":[]},{"line":"        spec","counters":[]},{"line":"      in","counters":[]},{"line":"      let trivial_account_pk =","counters":[]},{"line":"        Signature_lib.Public_key.compress snapp_kp.public_key","counters":[]},{"line":"      in","counters":[]},{"line":"      let `VK vk, `Prover trivial_prover =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        create_trivial_snapp ~constraint_constants ()","counters":[]},{"line":"      in","counters":[]},{"line":"      let _v =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let id =","counters":[]},{"line":"          Public_key.compress sender.public_key","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"          |> fun pk -> Account_id.create pk Token_id.default","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"        in","counters":[]},{"line":"        Ledger.get_or_create_account ledger id","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"          (Account.create id Balance.(of_int 888_888))","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"        |> Or_error.ok_exn","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"      in","counters":[]},{"line":"      let () =","counters":[]},{"line":"        create_trivial_zkapp_account trivial_account_pk ~ledger ~vk","counters":[]},{"line":"          ~permissions:{ Permissions.user_default with set_permissions = Proof }","counters":[]},{"line":"      in","counters":[]},{"line":"      let update_empty_permissions =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let permissions =","counters":[]},{"line":"          { Permissions.user_default with","counters":[]},{"line":"            send = Permissions.Auth_required.Proof","counters":[]},{"line":"          }","counters":[]},{"line":"          |> Zkapp_basic.Set_or_keep.Set","counters":[]},{"line":"        in","counters":[]},{"line":"        { Account_update.Update.dummy with permissions }","counters":[]},{"line":"      in","counters":[]},{"line":"      let sender_pk = sender.public_key |> Public_key.compress in","counters":[]},{"line":"      let fee_payer : Account_update.Fee_payer.t =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { body =","counters":[]},{"line":"            { public_key = sender_pk","counters":[]},{"line":"            ; fee","counters":[]},{"line":"            ; valid_until = None","counters":[]},{"line":"            ; nonce = sender_nonce","counters":[]},{"line":"            }","counters":[]},{"line":"            (* Real signature added in below *)","counters":[]},{"line":"        ; authorization = Signature.dummy","counters":[]},{"line":"        }","counters":[]},{"line":"      in","counters":[]},{"line":"      let sender_account_update_data : Account_update.Simple.t =","counters":[]},{"line":"        { body =","counters":[]},{"line":"            { public_key = sender_pk","counters":[]},{"line":"            ; update = Account_update.Update.noop","counters":[]},{"line":"            ; token_id = Token_id.default","counters":[]},{"line":"            ; balance_change = Amount.(Signed.(negate (of_unsigned amount)))","counters":[{"col_start":52,"col_end":52,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"            ; increment_nonce = true","counters":[]},{"line":"            ; events = []","counters":[]},{"line":"            ; sequence_events = []","counters":[]},{"line":"            ; call_data = Field.zero","counters":[]},{"line":"            ; call_depth = 0","counters":[]},{"line":"            ; preconditions =","counters":[]},{"line":"                { network = protocol_state_predicate","counters":[]},{"line":"                ; account = Nonce (Account.Nonce.succ sender_nonce)","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"                }","counters":[]},{"line":"            ; use_full_commitment = false","counters":[]},{"line":"            ; caller = Call","counters":[]},{"line":"            ; authorization_kind = Signature","counters":[]},{"line":"            }","counters":[]},{"line":"        ; authorization = Signature Signature.dummy","counters":[]},{"line":"        }","counters":[]},{"line":"      in","counters":[]},{"line":"      let snapp_account_update_data : Account_update.Simple.t =","counters":[]},{"line":"        { body =","counters":[]},{"line":"            { public_key = trivial_account_pk","counters":[]},{"line":"            ; update = update_empty_permissions","counters":[]},{"line":"            ; token_id = Token_id.default","counters":[]},{"line":"            ; balance_change = Amount.Signed.(of_unsigned amount)","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"            ; increment_nonce = false","counters":[]},{"line":"            ; events = []","counters":[]},{"line":"            ; sequence_events = []","counters":[]},{"line":"            ; call_data = Field.zero","counters":[]},{"line":"            ; call_depth = 0","counters":[]},{"line":"            ; preconditions =","counters":[]},{"line":"                { network = protocol_state_predicate","counters":[]},{"line":"                ; account = Full Zkapp_precondition.Account.accept","counters":[]},{"line":"                }","counters":[]},{"line":"            ; use_full_commitment = false","counters":[]},{"line":"            ; caller = Call","counters":[]},{"line":"            ; authorization_kind = Proof","counters":[]},{"line":"            }","counters":[]},{"line":"        ; authorization = Proof Mina_base.Proof.blockchain_dummy","counters":[]},{"line":"        }","counters":[]},{"line":"      in","counters":[]},{"line":"      let memo = Signed_command_memo.empty in","counters":[]},{"line":"      let ps =","counters":[]},{"line":"        Zkapp_command.Call_forest.With_hashes.of_zkapp_command_simple_list","counters":[]},{"line":"          [ sender_account_update_data; snapp_account_update_data ]","counters":[]},{"line":"      in","counters":[]},{"line":"      let account_updates_hash = Zkapp_command.Call_forest.hash ps in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let transaction : Zkapp_command.Transaction_commitment.t =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (*FIXME: is this correct? *)","counters":[]},{"line":"        Zkapp_command.Transaction_commitment.create ~account_updates_hash","counters":[]},{"line":"      in","counters":[]},{"line":"      let proof_account_update =","counters":[]},{"line":"        let tree =","counters":[]},{"line":"          Zkapp_command.Call_forest.With_hashes.of_zkapp_command_simple_list","counters":[{"col_start":75,"col_end":75,"count":0}]},{"line":"            [ snapp_account_update_data ]","counters":[]},{"line":"          |> List.hd_exn","counters":[]},{"line":"        in","counters":[]},{"line":"        tree.elt.account_update_digest","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      in","counters":[]},{"line":"      let tx_statement : Zkapp_statement.t =","counters":[]},{"line":"        { account_update = (proof_account_update :> Field.t)","counters":[]},{"line":"        ; calls = (Zkapp_command.Digest.Forest.empty :> Field.t)","counters":[]},{"line":"        }","counters":[]},{"line":"      in","counters":[]},{"line":"      let handler (Snarky_backendless.Request.With { request; respond }) =","counters":[]},{"line":"        match request with _ -> respond Unhandled","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"      in","counters":[]},{"line":"      let%map.Async.Deferred (), (), (pi : Pickles.Side_loaded.Proof.t) =","counters":[]},{"line":"        trivial_prover ~handler tx_statement","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"      in","counters":[]},{"line":"      let fee_payer_signature_auth =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let txn_comm =","counters":[]},{"line":"          Zkapp_command.Transaction_commitment.create_complete transaction","counters":[]},{"line":"            ~memo_hash:(Signed_command_memo.hash memo)","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"            ~fee_payer_hash:","counters":[]},{"line":"              (Zkapp_command.Digest.Account_update.create","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"                 (Account_update.of_fee_payer fee_payer) )","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"        in","counters":[]},{"line":"        Signature_lib.Schnorr.Chunked.sign sender.private_key","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"          (Random_oracle.Input.Chunked.field txn_comm)","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"      in","counters":[]},{"line":"      let fee_payer =","counters":[]},{"line":"        { fee_payer with authorization = fee_payer_signature_auth }","counters":[]},{"line":"      in","counters":[]},{"line":"      let sender_signature_auth =","counters":[]},{"line":"        Signature_lib.Schnorr.Chunked.sign sender.private_key","counters":[]},{"line":"          (Random_oracle.Input.Chunked.field transaction)","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"      in","counters":[]},{"line":"      let sender : Account_update.Simple.t =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { sender_account_update_data with","counters":[]},{"line":"          authorization = Signature sender_signature_auth","counters":[]},{"line":"        }","counters":[]},{"line":"      in","counters":[]},{"line":"      let account_updates =","counters":[]},{"line":"        [ sender","counters":[]},{"line":"        ; { body = snapp_account_update_data.body; authorization = Proof pi }","counters":[]},{"line":"        ]","counters":[]},{"line":"      in","counters":[]},{"line":"      let zkapp_command : Zkapp_command.t =","counters":[]},{"line":"        Zkapp_command.of_simple { fee_payer; account_updates; memo }","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"      in","counters":[]},{"line":"      zkapp_command","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"include Wire_types.Make (Make_sig) (Make_str)","counters":[{"col_start":44,"col_end":44,"count":2}]}]}