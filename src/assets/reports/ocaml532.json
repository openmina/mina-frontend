{"filename":"src/lib/crypto/kimchi_backend/common/plonk_constraint_system.ml","lines":[{"line":"(* TODO: remove these openings *)","counters":[{"col_start":32,"col_end":32,"count":1}]},{"line":"open Sponge","counters":[]},{"line":"open Unsigned.Size_t","counters":[]},{"line":"","counters":[]},{"line":"(* TODO: open Core here instead of opening it multiple times below *)","counters":[]},{"line":"","counters":[]},{"line":"(** A gate interface, parameterized by a field. *)","counters":[]},{"line":"module type Gate_vector_intf = sig","counters":[]},{"line":"  open Unsigned","counters":[]},{"line":"","counters":[]},{"line":"  type field","counters":[]},{"line":"","counters":[]},{"line":"  type t","counters":[]},{"line":"","counters":[]},{"line":"  val create : unit -> t","counters":[]},{"line":"","counters":[]},{"line":"  val add : t -> field Kimchi_types.circuit_gate -> unit","counters":[]},{"line":"","counters":[]},{"line":"  val get : t -> int -> field Kimchi_types.circuit_gate","counters":[]},{"line":"","counters":[]},{"line":"  val digest : t -> bytes","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(** A row indexing in a constraint system. *)","counters":[]},{"line":"module Row = struct","counters":[]},{"line":"  open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"  (** Either a public input row, ","counters":[]},{"line":"      or a non-public input row that starts at index 0. ","counters":[]},{"line":"    *)","counters":[]},{"line":"  type t = Public_input of int | After_public_input of int","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":11,"col_end":11,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"  [@@deriving hash, sexp, compare]","counters":[]},{"line":"","counters":[]},{"line":"  let to_absolute ~public_input_size = function","counters":[]},{"line":"    | Public_input i ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        i","counters":[]},{"line":"    | After_public_input i ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (* the first i rows are public-input rows *)","counters":[]},{"line":"        i + public_input_size","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(* TODO: rename module Position to Permutation/Wiring? *)","counters":[]},{"line":"","counters":[]},{"line":"(** A position represents the position of a cell in the constraint system. *)","counters":[]},{"line":"module Position = struct","counters":[]},{"line":"  open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"  (** A position is a row and a column. *)","counters":[]},{"line":"  type 'row t = { row : 'row; col : int } [@@deriving hash, sexp, compare]","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"","counters":[]},{"line":"  (** Generates a full row of positions that each points to itself. *)","counters":[]},{"line":"  let create_cols (row : 'row) : _ t array =","counters":[]},{"line":"    Array.init Constants.permutation_cols ~f:(fun i -> { row; col = i })","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"","counters":[]},{"line":"  (** Given a number of columns, ","counters":[]},{"line":"      append enough column wires to get an entire row.","counters":[]},{"line":"      The wire appended will simply point to themselves,","counters":[]},{"line":"      so as to not take part in the permutation argument. ","counters":[]},{"line":"    *)","counters":[]},{"line":"  let append_cols (row : 'row) (cols : _ t array) : _ t array =","counters":[]},{"line":"    let padding_offset = Array.length cols in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    assert (padding_offset <= Constants.permutation_cols) ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":11,"col_end":11,"count":0}]},{"line":"    let padding_len = Constants.permutation_cols - padding_offset in","counters":[]},{"line":"    let padding =","counters":[]},{"line":"      Array.init padding_len ~f:(fun i -> { row; col = i + padding_offset })","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"    in","counters":[]},{"line":"    Array.append cols padding","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  (** Converts an array of [Constants.columns] to [Constants.permutation_cols]. ","counters":[]},{"line":"    This is useful to truncate arrays of cells to the ones that only matter for the permutation argument. ","counters":[]},{"line":"    *)","counters":[]},{"line":"  let cols_to_perms cols = Array.slice cols 0 Constants.permutation_cols","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"","counters":[]},{"line":"  (** Converts a [Position.t] into the Rust-compatible type [Kimchi_types.wire]. ","counters":[]},{"line":"    *)","counters":[]},{"line":"  let to_rust_wire { row; col } : Kimchi_types.wire = { row; col }","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(** A gate. *)","counters":[]},{"line":"module Gate_spec = struct","counters":[]},{"line":"  open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"  (* TODO: split kind/coeffs from row/wired_to *)","counters":[]},{"line":"","counters":[]},{"line":"  (** A gate/row/constraint consists of a type (kind), a row, the other cells its columns/cells are connected to (wired_to), and the selector polynomial associated with the gate. *)","counters":[]},{"line":"  type ('row, 'f) t =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    { kind : (Kimchi_types.gate_type[@sexp.opaque])","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    ; wired_to : 'row Position.t array","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    ; coeffs : 'f array","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    }","counters":[]},{"line":"  [@@deriving sexp_of]","counters":[]},{"line":"","counters":[]},{"line":"  (** Applies a function [f] to the [row] of [t] and all the rows of its [wired_to]. *)","counters":[]},{"line":"  let map_rows (t : (_, _) t) ~f : (_, _) t =","counters":[]},{"line":"    (* { wire with row = f row } *)","counters":[]},{"line":"    let wired_to =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Array.map","counters":[]},{"line":"        ~f:(fun (pos : _ Position.t) -> { pos with row = f pos.row })","counters":[{"col_start":40,"col_end":40,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"        t.wired_to","counters":[]},{"line":"    in","counters":[]},{"line":"    { t with wired_to }","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  (* TODO: just send the array to Rust directly *)","counters":[]},{"line":"  let to_rust_gate { kind; wired_to; coeffs } : _ Kimchi_types.circuit_gate =","counters":[]},{"line":"    let typ = kind in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let wired_to = Array.map ~f:Position.to_rust_wire wired_to in","counters":[]},{"line":"    let wires =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ( wired_to.(0)","counters":[]},{"line":"      , wired_to.(1)","counters":[]},{"line":"      , wired_to.(2)","counters":[]},{"line":"      , wired_to.(3)","counters":[]},{"line":"      , wired_to.(4)","counters":[]},{"line":"      , wired_to.(5)","counters":[]},{"line":"      , wired_to.(6) )","counters":[]},{"line":"    in","counters":[]},{"line":"    { typ; wires; coeffs }","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(** The PLONK constraints. *)","counters":[]},{"line":"module Plonk_constraint = struct","counters":[]},{"line":"  open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"  (** A PLONK constraint (or gate) can be [Basic], [Poseidon], [EC_add_complete], [EC_scale], [EC_endoscale], or [EC_endoscalar]. *)","counters":[]},{"line":"  module T = struct","counters":[]},{"line":"    type ('v, 'f) t =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      | Basic of { l : 'f * 'v; r : 'f * 'v; o : 'f * 'v; m : 'f; c : 'f }","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":42,"col_end":42,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":49,"col_end":49,"count":0},{"col_start":50,"col_end":50,"count":0},{"col_start":55,"col_end":55,"count":0},{"col_start":58,"col_end":58,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"          (** the Poseidon state is an array of states (and states are arrays of size 3). *)","counters":[]},{"line":"      | Poseidon of { state : 'v array array }","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"      | EC_add_complete of","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          { p1 : 'v * 'v","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"          ; p2 : 'v * 'v","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"          ; p3 : 'v * 'v","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"          ; inf : 'v","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":14,"col_end":14,"count":0}]},{"line":"          ; same_x : 'v","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"          ; slope : 'v","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":16,"col_end":16,"count":0}]},{"line":"          ; inf_z : 'v","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":16,"col_end":16,"count":0}]},{"line":"          ; x21_inv : 'v","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"          }","counters":[]},{"line":"      | EC_scale of { state : 'v Scale_round.t array }","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"      | EC_endoscale of","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          { state : 'v Endoscale_round.t array; xs : 'v; ys : 'v; n_acc : 'v }","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":48,"col_end":48,"count":0},{"col_start":49,"col_end":49,"count":0},{"col_start":57,"col_end":57,"count":0},{"col_start":58,"col_end":58,"count":0},{"col_start":66,"col_end":66,"count":0},{"col_start":70,"col_end":70,"count":0}]},{"line":"      | EC_endoscalar of { state : 'v Endoscale_scalar_round.t array }","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"    [@@deriving sexp]","counters":[]},{"line":"","counters":[]},{"line":"    (** map t *)","counters":[]},{"line":"    let map (type a b f) (t : (a, f) t) ~(f : a -> b) =","counters":[]},{"line":"      let fp (x, y) = (f x, f y) in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"      match t with","counters":[]},{"line":"      | Basic { l; r; o; m; c } ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let p (x, y) = (x, f y) in","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"          Basic { l = p l; r = p r; o = p o; m; c }","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"      | Poseidon { state } ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Poseidon { state = Array.map ~f:(fun x -> Array.map ~f x) state }","counters":[{"col_start":37,"col_end":37,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"      | EC_add_complete { p1; p2; p3; inf; same_x; slope; inf_z; x21_inv } ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          EC_add_complete","counters":[]},{"line":"            { p1 = fp p1","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"            ; p2 = fp p2","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"            ; p3 = fp p3","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"            ; inf = f inf","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"            ; same_x = f same_x","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"            ; slope = f slope","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"            ; inf_z = f inf_z","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"            ; x21_inv = f x21_inv","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"            }","counters":[]},{"line":"      | EC_scale { state } ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          EC_scale","counters":[]},{"line":"            { state = Array.map ~f:(fun x -> Scale_round.map ~f x) state }","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"      | EC_endoscale { state; xs; ys; n_acc } ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          EC_endoscale","counters":[]},{"line":"            { state = Array.map ~f:(fun x -> Endoscale_round.map ~f x) state","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"            ; xs = f xs","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"            ; ys = f ys","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"            ; n_acc = f n_acc","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"            }","counters":[]},{"line":"      | EC_endoscalar { state } ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          EC_endoscalar","counters":[]},{"line":"            { state =","counters":[]},{"line":"                Array.map ~f:(fun x -> Endoscale_scalar_round.map ~f x) state","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"            }","counters":[]},{"line":"","counters":[]},{"line":"    (** [eval (module F) get_variable gate] checks that [gate]'s polynomial is","counters":[]},{"line":"        satisfied by the assignments given by [get_variable].","counters":[]},{"line":"        Warning: currently only implemented for the [Basic] gate.","counters":[]},{"line":"    *)","counters":[]},{"line":"    let eval (type v f)","counters":[]},{"line":"        (module F : Snarky_backendless.Field_intf.S with type t = f)","counters":[]},{"line":"        (eval_one : v -> f) (t : (v, f) t) =","counters":[]},{"line":"      match t with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      (* cl * vl + cr * vr + co * vo + m * vl*vr + c = 0 *)","counters":[]},{"line":"      | Basic { l = cl, vl; r = cr, vr; o = co, vo; m; c } ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let vl = eval_one vl in","counters":[]},{"line":"          let vr = eval_one vr in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let vo = eval_one vo in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let open F in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let res =","counters":[]},{"line":"            List.reduce_exn ~f:add","counters":[]},{"line":"              [ mul cl vl; mul cr vr; mul co vo; mul m (mul vl vr); c ]","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":51,"col_end":51,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"          in","counters":[]},{"line":"          if not (equal zero res) then (","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"            eprintf","counters":[]},{"line":"              !\"%{sexp:t} * %{sexp:t}\\n\\","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                + %{sexp:t} * %{sexp:t}\\n\\","counters":[]},{"line":"                + %{sexp:t} * %{sexp:t}\\n\\","counters":[]},{"line":"                + %{sexp:t} * %{sexp:t}\\n\\","counters":[]},{"line":"                + %{sexp:t}\\n\\","counters":[]},{"line":"                = %{sexp:t}%!\"","counters":[]},{"line":"              cl vl cr vr co vo m (mul vl vr) c res ;","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"            false )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          else true","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"      | _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          true","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  include T","counters":[]},{"line":"","counters":[]},{"line":"  (* Adds our constraint enum to the list of constraints handled by Snarky. *)","counters":[]},{"line":"  include Snarky_backendless.Constraint.Add_kind (T)","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Internal_var = Core_kernel.Unique_id.Int ()","counters":[]},{"line":"","counters":[]},{"line":"module V = struct","counters":[]},{"line":"  open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"  module T = struct","counters":[]},{"line":"    (** Variables linking uses of the same data between different gates.","counters":[]},{"line":"","counters":[]},{"line":"        Every internal variable is computable from a finite list of external","counters":[]},{"line":"        variables and internal variables.","counters":[]},{"line":"        Currently, in fact, every internal variable is a linear combination of","counters":[]},{"line":"        external variables and previously generated internal variables.","counters":[]},{"line":"    *)","counters":[]},{"line":"    type t =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      | External of int","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          (** An external variable (generated by snarky, via [exists]). *)","counters":[]},{"line":"      | Internal of Internal_var.t","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          (** An internal variable is generated to hold an intermediate value","counters":[]},{"line":"              (e.g., in reducing linear combinations to single PLONK positions).","counters":[]},{"line":"          *)","counters":[]},{"line":"    [@@deriving compare, hash, sexp]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  include T","counters":[]},{"line":"  include Comparable.Make (T)","counters":[]},{"line":"  include Hashable.Make (T)","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(** Keeps track of a circuit (which is a list of gates)","counters":[]},{"line":"    while it is being written.","counters":[]},{"line":"  *)","counters":[]},{"line":"type ('f, 'rust_gates) circuit =","counters":[]},{"line":"  | Unfinalized_rev of (unit, 'f) Gate_spec.t list","counters":[]},{"line":"      (** A circuit still being written. *)","counters":[]},{"line":"  | Compiled of Core_kernel.Md5.t * 'rust_gates","counters":[]},{"line":"      (** Once finalized, a circuit is represented as a digest ","counters":[]},{"line":"    and a list of gates that corresponds to the circuit. ","counters":[]},{"line":"  *)","counters":[]},{"line":"","counters":[]},{"line":"(** The constraint system. *)","counters":[]},{"line":"type ('f, 'rust_gates) t =","counters":[]},{"line":"  { (* Map of cells that share the same value (enforced by to the permutation). *)","counters":[]},{"line":"    equivalence_classes : Row.t Position.t list V.Table.t","counters":[]},{"line":"  ; (* How to compute each internal variable (as a linear combination of other variables). *)","counters":[]},{"line":"    internal_vars : (('f * V.t) list * 'f option) Internal_var.Table.t","counters":[]},{"line":"  ; (* The variables that hold each witness value for each row, in reverse order. *)","counters":[]},{"line":"    mutable rows_rev : V.t option array list","counters":[]},{"line":"  ; (* A circuit is described by a series of gates.","counters":[]},{"line":"       A gate is finalized once [finalize_and_get_gates] is called.","counters":[]},{"line":"       The finalized tag contains the digest of the circuit.","counters":[]},{"line":"    *)","counters":[]},{"line":"    mutable gates : ('f, 'rust_gates) circuit","counters":[]},{"line":"  ; (* The row to use the next time we add a constraint. *)","counters":[]},{"line":"    mutable next_row : int","counters":[]},{"line":"  ; (* The size of the public input (which fills the first rows of our constraint system. *)","counters":[]},{"line":"    public_input_size : int Core_kernel.Set_once.t","counters":[]},{"line":"  ; (* The number of previous recursion challenges. *)","counters":[]},{"line":"    prev_challenges : int Core_kernel.Set_once.t","counters":[]},{"line":"  ; (* Whatever is not public input. *)","counters":[]},{"line":"    mutable auxiliary_input_size : int","counters":[]},{"line":"  ; (* Queue (of size 1) of generic gate. *)","counters":[]},{"line":"    mutable pending_generic_gate :","counters":[]},{"line":"      (V.t option * V.t option * V.t option * 'f array) option","counters":[]},{"line":"  ; (* V.t's corresponding to constant values. We reuse them so we don't need to","counters":[]},{"line":"       use a fresh generic constraint each time to create a constant.","counters":[]},{"line":"    *)","counters":[]},{"line":"    cached_constants : ('f, V.t) Core_kernel.Hashtbl.t","counters":[]},{"line":"        (* The [equivalence_classes] field keeps track of the positions which must be","counters":[]},{"line":"             enforced to be equivalent due to the fact that they correspond to the same V.t value.","counters":[]},{"line":"             I.e., positions that are different usages of the same [V.t].","counters":[]},{"line":"","counters":[]},{"line":"             We use a union-find data structure to track equalities that a constraint system wants","counters":[]},{"line":"             enforced *between* [V.t] values. Then, at the end, for all [V.t]s that have been unioned","counters":[]},{"line":"             together, we combine their equivalence classes in the [equivalence_classes] table into","counters":[]},{"line":"             a single equivalence class, so that the permutation argument enforces these desired equalities","counters":[]},{"line":"             as well.","counters":[]},{"line":"        *)","counters":[]},{"line":"  ; union_finds : V.t Core_kernel.Union_find.t V.Table.t","counters":[]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"let get_public_input_size sys = sys.public_input_size","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"","counters":[]},{"line":"let get_rows_len sys = List.length sys.rows_rev","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"let get_prev_challenges sys = sys.prev_challenges","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"","counters":[]},{"line":"let set_prev_challenges sys challenges =","counters":[]},{"line":"  Core_kernel.Set_once.set_exn sys.prev_challenges [%here] challenges","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"(* TODO: shouldn't that Make create something bounded by a signature? As we know what a back end should be? Check where this is used *)","counters":[]},{"line":"","counters":[]},{"line":"(* TODO: glossary of terms in this file (terms, reducing, feeding) + module doc *)","counters":[]},{"line":"","counters":[]},{"line":"(* TODO: rename Fp to F or Field *)","counters":[]},{"line":"","counters":[]},{"line":"(** ? *)","counters":[]},{"line":"module Make","counters":[]},{"line":"    (Fp : Field.S)","counters":[]},{"line":"    (* We create a type for gate vector, instead of using `Gate.t list`. If we did, we would have to convert it to a `Gate.t array` to pass it across the FFI boundary, where then it gets converted to a `Vec<Gate>`; it's more efficient to just create the `Vec<Gate>` directly. ","counters":[]},{"line":"    *)","counters":[]},{"line":"    (Gates : Gate_vector_intf with type field := Fp.t)","counters":[]},{"line":"    (Params : sig","counters":[]},{"line":"      val params : Fp.t Params.t","counters":[]},{"line":"    end) : sig","counters":[]},{"line":"  open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"  type nonrec t = (Fp.t, Gates.t) t","counters":[]},{"line":"","counters":[]},{"line":"  val create : unit -> t","counters":[]},{"line":"","counters":[]},{"line":"  val get_public_input_size : t -> int Set_once.t","counters":[]},{"line":"","counters":[]},{"line":"  val get_primary_input_size : t -> int","counters":[]},{"line":"","counters":[]},{"line":"  val set_primary_input_size : t -> int -> unit","counters":[]},{"line":"","counters":[]},{"line":"  val get_auxiliary_input_size : t -> int","counters":[]},{"line":"","counters":[]},{"line":"  val set_auxiliary_input_size : t -> int -> unit","counters":[]},{"line":"","counters":[]},{"line":"  val get_prev_challenges : t -> int option","counters":[]},{"line":"","counters":[]},{"line":"  val set_prev_challenges : t -> int -> unit","counters":[]},{"line":"","counters":[]},{"line":"  val get_rows_len : t -> int","counters":[]},{"line":"","counters":[]},{"line":"  val next_row : t -> int","counters":[]},{"line":"","counters":[]},{"line":"  val add_constraint :","counters":[]},{"line":"       ?label:string","counters":[]},{"line":"    -> t","counters":[]},{"line":"    -> ( Fp.t Snarky_backendless.Cvar.t","counters":[]},{"line":"       , Fp.t )","counters":[]},{"line":"       Snarky_backendless.Constraint.basic","counters":[]},{"line":"    -> unit","counters":[]},{"line":"","counters":[]},{"line":"  val compute_witness : t -> (int -> Fp.t) -> Fp.t array array","counters":[]},{"line":"","counters":[]},{"line":"  val finalize : t -> unit","counters":[]},{"line":"","counters":[]},{"line":"  val finalize_and_get_gates : t -> Gates.t","counters":[]},{"line":"","counters":[]},{"line":"  val digest : t -> Md5.t","counters":[]},{"line":"","counters":[]},{"line":"  val to_json :","counters":[]},{"line":"       t","counters":[]},{"line":"    -> ([ `Null","counters":[]},{"line":"        | `Bool of bool","counters":[]},{"line":"        | `Int of int","counters":[]},{"line":"        | `Intlit of string","counters":[]},{"line":"        | `Float of float","counters":[]},{"line":"        | `String of string","counters":[]},{"line":"        | `Assoc of (string * 'json) list","counters":[]},{"line":"        | `List of 'json list","counters":[]},{"line":"        | `Tuple of 'json list","counters":[]},{"line":"        | `Variant of string * 'json option ]","counters":[]},{"line":"        as","counters":[]},{"line":"        'json )","counters":[]},{"line":"end = struct","counters":[]},{"line":"  open Core_kernel","counters":[]},{"line":"  open Pickles_types","counters":[]},{"line":"","counters":[]},{"line":"  type nonrec t = (Fp.t, Gates.t) t","counters":[]},{"line":"","counters":[]},{"line":"  (** Converts the set of permutations (equivalence_classes) to","counters":[]},{"line":"      a hash table that maps each position to the next one.","counters":[]},{"line":"      For example, if one of the equivalence class is [pos1, pos3, pos7],","counters":[]},{"line":"      the function will return a hashtable that maps pos1 to pos3,","counters":[]},{"line":"      pos3 to pos7, and pos7 to pos1. ","counters":[]},{"line":"    *)","counters":[]},{"line":"  let equivalence_classes_to_hashtbl sys =","counters":[]},{"line":"    let module Relative_position = struct","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      module T = struct","counters":[]},{"line":"        type t = Row.t Position.t [@@deriving hash, sexp, compare]","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      include T","counters":[]},{"line":"      include Core_kernel.Hashable.Make (T)","counters":[]},{"line":"    end in","counters":[]},{"line":"    let equivalence_classes = V.Table.create () in","counters":[]},{"line":"    Hashtbl.iteri sys.equivalence_classes ~f:(fun ~key ~data ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        let u = Hashtbl.find_exn sys.union_finds key in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Hashtbl.update equivalence_classes (Union_find.get u) ~f:(function","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Relative_position.Hash_set.of_list data","counters":[]},{"line":"          | Some ps ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              List.iter ~f:(Hash_set.add ps) data ;","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"              ps ) ) ;","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"    let res = Relative_position.Table.create () in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Hashtbl.iter equivalence_classes ~f:(fun ps ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        let rotate_left = function [] -> [] | x :: xs -> xs @ [ x ] in","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"        let ps = Hash_set.to_list ps in","counters":[]},{"line":"        List.iter2_exn ps (rotate_left ps) ~f:(fun input output ->","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"            Hashtbl.add_exn res ~key:input ~data:output ) ) ;","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"    res","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  (** Compute the witness, given the constraint system `sys` ","counters":[]},{"line":"      and a function that converts the indexed secret inputs to their concrete values.","counters":[]},{"line":"   *)","counters":[]},{"line":"  let compute_witness (sys : t) (external_values : int -> Fp.t) :","counters":[]},{"line":"      Fp.t array array =","counters":[]},{"line":"    let internal_values : Fp.t Internal_var.Table.t =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Internal_var.Table.create ()","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"    in","counters":[]},{"line":"    let public_input_size = Set_once.get_exn sys.public_input_size [%here] in","counters":[]},{"line":"    let num_rows = public_input_size + sys.next_row in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let res =","counters":[]},{"line":"      Array.init Constants.columns ~f:(fun _ ->","counters":[]},{"line":"          Array.create ~len:num_rows Fp.zero )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    in","counters":[]},{"line":"    (* Public input *)","counters":[]},{"line":"    for i = 0 to public_input_size - 1 do","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      res.(0).(i) <- external_values (i + 1)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"    done ;","counters":[]},{"line":"    let find t k =","counters":[]},{"line":"      match Hashtbl.find t k with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          failwithf !\"Could not find %{sexp:Internal_var.t}\\n%!\" k ()","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"      | Some x ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          x","counters":[]},{"line":"    in","counters":[]},{"line":"    (* Compute an internal variable associated value. *)","counters":[]},{"line":"    let compute ((lc, c) : (Fp.t * V.t) list * Fp.t option) =","counters":[]},{"line":"      List.fold lc ~init:(Option.value c ~default:Fp.zero) ~f:(fun acc (s, x) ->","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"          let x =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            match x with","counters":[]},{"line":"            | External x ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                external_values x","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"            | Internal x ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                find internal_values x","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"          in","counters":[]},{"line":"          Fp.(acc + (s * x)) )","counters":[]},{"line":"    in","counters":[]},{"line":"    (* Update the witness table with the value of the variables from each row. *)","counters":[]},{"line":"    List.iteri (List.rev sys.rows_rev) ~f:(fun i_after_input cols ->","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"        let row_idx = i_after_input + public_input_size in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Array.iteri cols ~f:(fun col_idx var ->","counters":[]},{"line":"            match var with","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            | None ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ()","counters":[]},{"line":"            | Some (External var) ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                res.(col_idx).(row_idx) <- external_values var","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"            | Some (Internal var) ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                let lc = find sys.internal_vars var in","counters":[]},{"line":"                let value = compute lc in","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                res.(col_idx).(row_idx) <- value ;","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                Hashtbl.set internal_values ~key:var ~data:value ) ) ;","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"    (* Return the witness. *)","counters":[]},{"line":"    res","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let union_find sys v =","counters":[]},{"line":"    Hashtbl.find_or_add sys.union_finds v ~default:(fun () ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        Union_find.create v )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"  (** Creates an internal variable and assigns it the value lc and constant. *)","counters":[]},{"line":"  let create_internal ?constant sys lc : V.t =","counters":[]},{"line":"    let v = Internal_var.create () in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    ignore (union_find sys (Internal v) : _ Union_find.t) ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"    Hashtbl.add_exn sys.internal_vars ~key:v ~data:(lc, constant) ;","counters":[]},{"line":"    V.Internal v","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  (* Initializes a constraint system. *)","counters":[]},{"line":"  let create () : t =","counters":[]},{"line":"    { public_input_size = Set_once.create ()","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"    ; prev_challenges = Set_once.create ()","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"    ; internal_vars = Internal_var.Table.create ()","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"    ; gates = Unfinalized_rev [] (* Gates.create () *)","counters":[]},{"line":"    ; rows_rev = []","counters":[]},{"line":"    ; next_row = 0","counters":[]},{"line":"    ; equivalence_classes = V.Table.create ()","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"    ; auxiliary_input_size = 0","counters":[]},{"line":"    ; pending_generic_gate = None","counters":[]},{"line":"    ; cached_constants = Hashtbl.create (module Fp)","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"    ; union_finds = V.Table.create ()","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  (* TODO *)","counters":[]},{"line":"  let to_json _ = `List []","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"","counters":[]},{"line":"  (** Returns the number of auxiliary inputs. *)","counters":[]},{"line":"  let get_auxiliary_input_size t = t.auxiliary_input_size","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"  (** Returns the number of public inputs. *)","counters":[]},{"line":"  let get_primary_input_size t = Set_once.get_exn t.public_input_size [%here]","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"","counters":[]},{"line":"  (** Returns the number of previous challenges. *)","counters":[]},{"line":"  let get_prev_challenges t = Set_once.get t.prev_challenges","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"","counters":[]},{"line":"  (* Non-public part of the witness. *)","counters":[]},{"line":"  let set_auxiliary_input_size t x = t.auxiliary_input_size <- x","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"  (** Sets the number of public-input. It must and can only be called once. *)","counters":[]},{"line":"  let set_primary_input_size (sys : t) num_pub_inputs =","counters":[]},{"line":"    Set_once.set_exn sys.public_input_size [%here] num_pub_inputs","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  (** Sets the number of previous challenges. It must and can only be called once. *)","counters":[]},{"line":"  let set_prev_challenges (sys : t) num_prev_challenges =","counters":[]},{"line":"    Set_once.set_exn sys.prev_challenges [%here] num_prev_challenges","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let get_public_input_size (sys : t) = get_public_input_size sys","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"  let get_rows_len (sys : t) = get_rows_len sys","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"","counters":[]},{"line":"  let next_row (sys : t) = sys.next_row","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"","counters":[]},{"line":"  (** Adds {row; col} to the system's wiring under a specific key.","counters":[]},{"line":"      A key is an external or internal variable.","counters":[]},{"line":"      The row must be given relative to the start of the circuit ","counters":[]},{"line":"      (so at the start of the public-input rows). *)","counters":[]},{"line":"  let wire' sys key row (col : int) =","counters":[]},{"line":"    ignore (union_find sys key : V.t Union_find.t) ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"    V.Table.add_multi sys.equivalence_classes ~key ~data:{ row; col }","counters":[]},{"line":"","counters":[]},{"line":"  (* TODO: rename to wire_abs and wire_rel? or wire_public and wire_after_public? or force a single use function that takes a Row.t? *)","counters":[]},{"line":"","counters":[]},{"line":"  (** Same as wire', except that the row must be given relatively to the end of the public-input rows. *)","counters":[]},{"line":"  let wire sys key row col = wire' sys key (Row.After_public_input row) col","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"  (** Adds a row/gate/constraint to a constraint system `sys`. *)","counters":[]},{"line":"  let add_row sys (vars : V.t option array) kind coeffs =","counters":[]},{"line":"    match sys.gates with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Compiled _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        failwith \"add_row called on finalized constraint system\"","counters":[]},{"line":"    | Unfinalized_rev gates ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (* As we're adding a row, we're adding new cells.","counters":[]},{"line":"           If these cells (the first 7) contain variables,","counters":[]},{"line":"           make sure that they are wired","counters":[]},{"line":"        *)","counters":[]},{"line":"        let num_vars = min Constants.permutation_cols (Array.length vars) in","counters":[{"col_start":66,"col_end":66,"count":0}]},{"line":"        let vars_for_perm = Array.slice vars 0 num_vars in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Array.iteri vars_for_perm ~f:(fun col x ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            Option.iter x ~f:(fun x -> wire sys x sys.next_row col) ) ;","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"        (* Add to gates. *)","counters":[]},{"line":"        let open Position in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        sys.gates <- Unfinalized_rev ({ kind; wired_to = [||]; coeffs } :: gates) ;","counters":[]},{"line":"        (* Increment row. *)","counters":[]},{"line":"        sys.next_row <- sys.next_row + 1 ;","counters":[]},{"line":"        (* Add to row. *)","counters":[]},{"line":"        sys.rows_rev <- vars :: sys.rows_rev","counters":[]},{"line":"","counters":[]},{"line":"  (** Adds zero-knowledgeness to the gates/rows, ","counters":[]},{"line":"      and convert into Rust type [Gates.t].","counters":[]},{"line":"      This can only be called once.","counters":[]},{"line":"    *)","counters":[]},{"line":"  let rec finalize_and_get_gates sys =","counters":[]},{"line":"    match sys with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | { gates = Compiled (_, gates); _ } ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        gates","counters":[]},{"line":"    | { pending_generic_gate = Some (l, r, o, coeffs); _ } ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (* Finalize any pending generic constraint first. *)","counters":[]},{"line":"        add_row sys [| l; r; o |] Generic coeffs ;","counters":[]},{"line":"        sys.pending_generic_gate <- None ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        finalize_and_get_gates sys","counters":[]},{"line":"    | { gates = Unfinalized_rev gates_rev; _ } ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let rust_gates = Gates.create () in","counters":[]},{"line":"","counters":[]},{"line":"        (* Create rows for public input. *)","counters":[]},{"line":"        let public_input_size =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Set_once.get_exn sys.public_input_size [%here]","counters":[]},{"line":"        in","counters":[]},{"line":"        let pub_selectors = [| Fp.one; Fp.zero; Fp.zero; Fp.zero; Fp.zero |] in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let pub_input_gate_specs_rev = ref [] in","counters":[]},{"line":"        for row = 0 to public_input_size - 1 do","counters":[]},{"line":"          let public_var = V.External (row + 1) in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          wire' sys public_var (Row.Public_input row) 0 ;","counters":[]},{"line":"          pub_input_gate_specs_rev :=","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            { Gate_spec.kind = Generic","counters":[]},{"line":"            ; wired_to = [||]","counters":[]},{"line":"            ; coeffs = pub_selectors","counters":[]},{"line":"            }","counters":[]},{"line":"            :: !pub_input_gate_specs_rev","counters":[]},{"line":"        done ;","counters":[]},{"line":"","counters":[]},{"line":"        (* Construct permutation hashmap. *)","counters":[]},{"line":"        let pos_map = equivalence_classes_to_hashtbl sys in","counters":[]},{"line":"        let permutation (pos : Row.t Position.t) : Row.t Position.t =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Option.value (Hashtbl.find pos_map pos) ~default:pos","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"        in","counters":[]},{"line":"","counters":[]},{"line":"        let update_gate_with_permutation_info (row : Row.t)","counters":[]},{"line":"            (gate : (unit, _) Gate_spec.t) : (Row.t, _) Gate_spec.t =","counters":[]},{"line":"          { gate with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            wired_to =","counters":[]},{"line":"              Array.init Constants.permutation_cols ~f:(fun col ->","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                  permutation { row; col } )","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"          }","counters":[]},{"line":"        in","counters":[]},{"line":"","counters":[]},{"line":"        (* Process public gates. *)","counters":[]},{"line":"        let public_gates = List.rev !pub_input_gate_specs_rev in","counters":[]},{"line":"        let public_gates =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          List.mapi public_gates ~f:(fun absolute_row gate ->","counters":[]},{"line":"              update_gate_with_permutation_info (Row.Public_input absolute_row)","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                gate )","counters":[]},{"line":"        in","counters":[]},{"line":"","counters":[]},{"line":"        (* construct all the other gates (except zero-knowledge rows) *)","counters":[]},{"line":"        let gates = List.rev gates_rev in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let gates =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          List.mapi gates ~f:(fun relative_row gate ->","counters":[]},{"line":"              update_gate_with_permutation_info","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (Row.After_public_input relative_row) gate )","counters":[]},{"line":"        in","counters":[]},{"line":"","counters":[]},{"line":"        (* concatenate and convert to absolute rows *)","counters":[]},{"line":"        let to_absolute_row =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Gate_spec.map_rows ~f:(Row.to_absolute ~public_input_size)","counters":[]},{"line":"        in","counters":[]},{"line":"","counters":[]},{"line":"        (* convert all the gates into our Gates.t Rust vector type *)","counters":[]},{"line":"        let add_gates gates =","counters":[]},{"line":"          List.iter gates ~f:(fun g ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              let g = to_absolute_row g in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              Gates.add rust_gates (Gate_spec.to_rust_gate g) )","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"        in","counters":[]},{"line":"        add_gates public_gates ;","counters":[]},{"line":"        add_gates gates ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"        (* compute the circuit's digest *)","counters":[]},{"line":"        let digest = Gates.digest rust_gates in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let md5_digest = Md5.digest_bytes digest in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"        (* drop the gates, we don't need them anymore *)","counters":[]},{"line":"        sys.gates <- Compiled (md5_digest, rust_gates) ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"        (* return the gates *)","counters":[]},{"line":"        rust_gates","counters":[]},{"line":"","counters":[]},{"line":"  (** Calls [finalize_and_get_gates] and ignores the result. *)","counters":[]},{"line":"  let finalize t = ignore (finalize_and_get_gates t : Gates.t)","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"","counters":[]},{"line":"  (* Returns a hash of the circuit. *)","counters":[]},{"line":"  let rec digest (sys : t) =","counters":[]},{"line":"    match sys.gates with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Unfinalized_rev _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        finalize sys ; digest sys","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"    | Compiled (digest, _) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        digest","counters":[]},{"line":"","counters":[]},{"line":"  (** Regroup terms that share the same variable. ","counters":[]},{"line":"      For example, (3, i2) ; (2, i2) can be simplified to (5, i2).","counters":[]},{"line":"      It assumes that the list of given terms is sorted, ","counters":[]},{"line":"      and that i0 is the smallest one.","counters":[]},{"line":"      For example, `i0 = 1` and `terms = [(_, 2); (_, 2); (_; 4); ...]`","counters":[]},{"line":"","counters":[]},{"line":"      Returns `(last_scalar, last_variable, terms, terms_length)`","counters":[]},{"line":"      where terms does not contain the last scalar and last variable observed.","counters":[]},{"line":"  *)","counters":[]},{"line":"  let accumulate_terms terms =","counters":[]},{"line":"    List.fold terms ~init:Int.Map.empty ~f:(fun acc (x, i) ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        Map.change acc i ~f:(fun y ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            let res = match y with None -> x | Some y -> Fp.add x y in","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":47,"col_end":47,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"            if Fp.(equal zero res) then None else Some res ) )","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"","counters":[]},{"line":"  (** Converts a [Cvar.t] to a `(terms, terms_length, has_constant)`.","counters":[]},{"line":"      if `has_constant` is set, then terms start with a constant term in the form of (c, 0).","counters":[]},{"line":"    *)","counters":[]},{"line":"  let canonicalize x =","counters":[]},{"line":"    let c, terms =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Fp.(","counters":[]},{"line":"        Snarky_backendless.Cvar.to_constant_and_terms ~add ~mul ~zero:(of_int 0)","counters":[{"col_start":76,"col_end":76,"count":0}]},{"line":"          ~equal ~one:(of_int 1))","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"        x","counters":[]},{"line":"    in","counters":[]},{"line":"    (* Note: [(c, 0)] represents the field element [c] multiplied by the 0th","counters":[]},{"line":"       variable, which is held constant as [Field.one].","counters":[]},{"line":"    *)","counters":[]},{"line":"    let terms = match c with None -> terms | Some c -> (c, 0) :: terms in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"    let has_constant_term = Option.is_some c in","counters":[]},{"line":"    let terms = accumulate_terms terms in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let terms_list =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Map.fold_right ~init:[] terms ~f:(fun ~key ~data acc ->","counters":[]},{"line":"          (data, key) :: acc )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    in","counters":[]},{"line":"    Some (terms_list, Map.length terms, has_constant_term)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"","counters":[]},{"line":"  (** Adds a generic constraint to the constraint system. ","counters":[]},{"line":"      As there are two generic gates per row, we queue","counters":[]},{"line":"      every other generic gate.","counters":[]},{"line":"      *)","counters":[]},{"line":"  let add_generic_constraint ?l ?r ?o coeffs sys : unit =","counters":[]},{"line":"    match sys.pending_generic_gate with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    (* if the queue of generic gate is empty, queue this *)","counters":[]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        sys.pending_generic_gate <- Some (l, r, o, coeffs)","counters":[]},{"line":"    (* otherwise empty the queue and create the row  *)","counters":[]},{"line":"    | Some (l2, r2, o2, coeffs2) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let coeffs = Array.append coeffs coeffs2 in","counters":[]},{"line":"        add_row sys [| l; r; o; l2; r2; o2 |] Generic coeffs ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        sys.pending_generic_gate <- None","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"  (** Converts a number of scaled additions \\sum s_i * x_i ","counters":[]},{"line":"      to as many constraints as needed, ","counters":[]},{"line":"      creating temporary variables for each new row/constraint,","counters":[]},{"line":"      and returning the output variable.","counters":[]},{"line":"","counters":[]},{"line":"      For example, [(s1, x1), (s2, x2)] is transformed into:","counters":[]},{"line":"      - internal_var_1 = s1 * x1 + s2 * x2","counters":[]},{"line":"      - return (1, internal_var_1)","counters":[]},{"line":"","counters":[]},{"line":"      and [(s1, x1), (s2, x2), (s3, x3)] is transformed into:","counters":[]},{"line":"      - internal_var_1 = s1 * x1 + s2 * x2","counters":[]},{"line":"      - internal_var_2 = 1 * internal_var_1 + s3 * x3","counters":[]},{"line":"      - return (1, internal_var_2)","counters":[]},{"line":"      ","counters":[]},{"line":"      It assumes that the list of terms is not empty. *)","counters":[]},{"line":"  let completely_reduce sys (terms : (Fp.t * int) list) =","counters":[]},{"line":"    (* just adding constrained variables without values *)","counters":[]},{"line":"    let rec go = function","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      | [] ->","counters":[]},{"line":"          assert false","counters":[]},{"line":"      | [ (s, x) ] ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (s, V.External x)","counters":[]},{"line":"      | (ls, lx) :: t ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let lx = V.External lx in","counters":[]},{"line":"          (* TODO: this should be rewritten to be tail-optimized *)","counters":[]},{"line":"          let rs, rx = go t in","counters":[]},{"line":"          let s1x1_plus_s2x2 = create_internal sys [ (ls, lx); (rs, rx) ] in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          add_generic_constraint ~l:lx ~r:rx ~o:s1x1_plus_s2x2","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            [| ls; rs; Fp.(negate one); Fp.zero; Fp.zero |]","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"            sys ;","counters":[]},{"line":"          (Fp.one, s1x1_plus_s2x2)","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    in","counters":[]},{"line":"    go terms","counters":[]},{"line":"","counters":[]},{"line":"  (** Converts a linear combination of variables into a set of constraints.","counters":[]},{"line":"      It returns the output variable as (1, `Var res), ","counters":[]},{"line":"      unless the output is a constant, in which case it returns (c, `Constant). ","counters":[]},{"line":"    *)","counters":[]},{"line":"  let reduce_lincom sys (x : Fp.t Snarky_backendless.Cvar.t) =","counters":[]},{"line":"    let constant, terms =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Fp.(","counters":[]},{"line":"        Snarky_backendless.Cvar.to_constant_and_terms ~add ~mul ~zero:(of_int 0)","counters":[{"col_start":76,"col_end":76,"count":0}]},{"line":"          ~equal ~one:(of_int 1))","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"        x","counters":[]},{"line":"    in","counters":[]},{"line":"    let terms = accumulate_terms terms in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let terms_list =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Map.fold_right ~init:[] terms ~f:(fun ~key ~data acc ->","counters":[]},{"line":"          (data, key) :: acc )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    in","counters":[]},{"line":"    match (constant, Map.is_empty terms) with","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"    | Some c, true ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (c, `Constant)","counters":[]},{"line":"    | None, true ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (Fp.zero, `Constant)","counters":[]},{"line":"    | _ -> (","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        match terms_list with","counters":[]},{"line":"        | [] ->","counters":[]},{"line":"            assert false","counters":[]},{"line":"        | [ (ls, lx) ] -> (","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            match constant with","counters":[]},{"line":"            | None ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (ls, `Var (V.External lx))","counters":[]},{"line":"            | Some c ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (* res = ls * lx + c *)","counters":[]},{"line":"                let res =","counters":[]},{"line":"                  create_internal ~constant:c sys [ (ls, External lx) ]","counters":[]},{"line":"                in","counters":[]},{"line":"                add_generic_constraint ~l:(External lx) ~o:res","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  [| ls; Fp.zero; Fp.(negate one); Fp.zero; c |]","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"                  (* Could be here *)","counters":[]},{"line":"                  sys ;","counters":[]},{"line":"                (Fp.one, `Var res) )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"        | (ls, lx) :: tl ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (* reduce the terms, then add the constant *)","counters":[]},{"line":"            let rs, rx = completely_reduce sys tl in","counters":[]},{"line":"            let res =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              create_internal ?constant sys [ (ls, External lx); (rs, rx) ]","counters":[]},{"line":"            in","counters":[]},{"line":"            (* res = ls * lx + rs * rx + c *)","counters":[]},{"line":"            add_generic_constraint ~l:(External lx) ~r:rx ~o:res","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              [| ls","counters":[]},{"line":"               ; rs","counters":[]},{"line":"               ; Fp.(negate one)","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"               ; Fp.zero","counters":[]},{"line":"               ; (match constant with Some x -> x | None -> Fp.zero)","counters":[{"col_start":38,"col_end":38,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"              |]","counters":[]},{"line":"              (* Could be here *)","counters":[]},{"line":"              sys ;","counters":[]},{"line":"            (Fp.one, `Var res) )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"","counters":[]},{"line":"  (** Adds a constraint to the constraint system. *)","counters":[]},{"line":"  let add_constraint ?label:_ sys","counters":[]},{"line":"      (constr :","counters":[]},{"line":"        ( Fp.t Snarky_backendless.Cvar.t","counters":[]},{"line":"        , Fp.t )","counters":[]},{"line":"        Snarky_backendless.Constraint.basic ) =","counters":[]},{"line":"    let red = reduce_lincom sys in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    (* reduce any [Cvar.t] to a single internal variable *)","counters":[]},{"line":"    let reduce_to_v (x : Fp.t Snarky_backendless.Cvar.t) : V.t =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      match red x with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | s, `Var x ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          if Fp.equal s Fp.one then x","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"          else","counters":[]},{"line":"            let sx = create_internal sys [ (s, x) ] in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            (* s * x - sx = 0 *)","counters":[]},{"line":"            add_generic_constraint ~l:x ~o:sx","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              [| s; Fp.zero; Fp.(negate one); Fp.zero; Fp.zero |]","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"              sys ;","counters":[]},{"line":"            sx","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"      | s, `Constant -> (","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          match Hashtbl.find sys.cached_constants s with","counters":[]},{"line":"          | Some x ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              x","counters":[]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let x = create_internal sys ~constant:s [] in","counters":[]},{"line":"              add_generic_constraint ~l:x","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                [| Fp.one; Fp.zero; Fp.zero; Fp.zero; Fp.negate s |]","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"                sys ;","counters":[]},{"line":"              Hashtbl.set sys.cached_constants ~key:s ~data:x ;","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              x )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"    in","counters":[]},{"line":"    match constr with","counters":[]},{"line":"    | Snarky_backendless.Constraint.Square (v1, v2) -> (","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        match (red v1, red v2) with","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"        | (sl, `Var xl), (so, `Var xo) ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (* (sl * xl)^2 = so * xo","counters":[]},{"line":"               sl^2 * xl * xl - so * xo = 0","counters":[]},{"line":"            *)","counters":[]},{"line":"            add_generic_constraint ~l:xl ~r:xl ~o:xo","counters":[]},{"line":"              [| Fp.zero; Fp.zero; Fp.negate so; Fp.(sl * sl); Fp.zero |]","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"              sys","counters":[]},{"line":"        | (sl, `Var xl), (so, `Constant) ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (* TODO: it's hard to read the array of selector values, name them! *)","counters":[]},{"line":"            add_generic_constraint ~l:xl ~r:xl","counters":[]},{"line":"              [| Fp.zero; Fp.zero; Fp.zero; Fp.(sl * sl); Fp.negate so |]","counters":[{"col_start":66,"col_end":66,"count":0}]},{"line":"              sys","counters":[]},{"line":"        | (sl, `Constant), (so, `Var xo) ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (* sl^2 = so * xo *)","counters":[]},{"line":"            add_generic_constraint ~o:xo","counters":[]},{"line":"              [| Fp.zero; Fp.zero; so; Fp.zero; Fp.negate (Fp.square sl) |]","counters":[{"col_start":56,"col_end":56,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"              sys","counters":[]},{"line":"        | (sl, `Constant), (so, `Constant) ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            assert (Fp.(equal (square sl) so)) )","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"    | Snarky_backendless.Constraint.R1CS (v1, v2, v3) -> (","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        match (red v1, red v2, red v3) with","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"        | (s1, `Var x1), (s2, `Var x2), (s3, `Var x3) ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (* s1 x1 * s2 x2 = s3 x3","counters":[]},{"line":"               - s1 s2 (x1 x2) + s3 x3 = 0","counters":[]},{"line":"            *)","counters":[]},{"line":"            add_generic_constraint ~l:x1 ~r:x2 ~o:x3","counters":[]},{"line":"              [| Fp.zero; Fp.zero; s3; Fp.(negate s1 * s2); Fp.zero |]","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"              sys","counters":[]},{"line":"        | (s1, `Var x1), (s2, `Var x2), (s3, `Constant) ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            add_generic_constraint ~l:x1 ~r:x2","counters":[]},{"line":"              [| Fp.zero; Fp.zero; Fp.zero; Fp.(s1 * s2); Fp.negate s3 |]","counters":[{"col_start":66,"col_end":66,"count":0}]},{"line":"              sys","counters":[]},{"line":"        | (s1, `Var x1), (s2, `Constant), (s3, `Var x3) ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (* s1 x1 * s2 = s3 x3","counters":[]},{"line":"            *)","counters":[]},{"line":"            add_generic_constraint ~l:x1 ~o:x3","counters":[]},{"line":"              [| Fp.(s1 * s2); Fp.zero; Fp.negate s3; Fp.zero; Fp.zero |]","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"              sys","counters":[]},{"line":"        | (s1, `Constant), (s2, `Var x2), (s3, `Var x3) ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            add_generic_constraint ~r:x2 ~o:x3","counters":[]},{"line":"              [| Fp.zero; Fp.(s1 * s2); Fp.negate s3; Fp.zero; Fp.zero |]","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"              sys","counters":[]},{"line":"        | (s1, `Var x1), (s2, `Constant), (s3, `Constant) ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            add_generic_constraint ~l:x1","counters":[]},{"line":"              [| Fp.(s1 * s2); Fp.zero; Fp.zero; Fp.zero; Fp.negate s3 |]","counters":[{"col_start":66,"col_end":66,"count":0}]},{"line":"              sys","counters":[]},{"line":"        | (s1, `Constant), (s2, `Var x2), (s3, `Constant) ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            add_generic_constraint ~r:x2","counters":[]},{"line":"              [| Fp.zero; Fp.(s1 * s2); Fp.zero; Fp.zero; Fp.negate s3 |]","counters":[{"col_start":66,"col_end":66,"count":0}]},{"line":"              sys","counters":[]},{"line":"        | (s1, `Constant), (s2, `Constant), (s3, `Var x3) ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            add_generic_constraint ~o:x3","counters":[]},{"line":"              [| Fp.zero; Fp.zero; s3; Fp.zero; Fp.(negate s1 * s2) |]","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"              sys","counters":[]},{"line":"        | (s1, `Constant), (s2, `Constant), (s3, `Constant) ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            assert (Fp.(equal s3 Fp.(s1 * s2))) )","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"    | Snarky_backendless.Constraint.Boolean v -> (","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let s, x = red v in","counters":[]},{"line":"        match x with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | `Var x ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (* -x + x * x = 0  *)","counters":[]},{"line":"            add_generic_constraint ~l:x ~r:x","counters":[]},{"line":"              [| Fp.(negate one); Fp.zero; Fp.zero; Fp.one; Fp.zero |]","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"              sys","counters":[]},{"line":"        | `Constant ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            assert (Fp.(equal s (s * s))) )","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"    | Snarky_backendless.Constraint.Equal (v1, v2) -> (","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let (s1, x1), (s2, x2) = (red v1, red v2) in","counters":[{"col_start":36,"col_end":36,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"        match (x1, x2) with","counters":[]},{"line":"        | `Var x1, `Var x2 ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            if Fp.equal s1 s2 then (","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"              if not (Fp.equal s1 Fp.zero) then","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                Union_find.union (union_find sys x1) (union_find sys x2) )","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":43,"col_end":43,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"            else if (* s1 x1 - s2 x2 = 0","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"          *)","counters":[]},{"line":"                    not (Fp.equal s1 s2) then","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"              add_generic_constraint ~l:x1 ~r:x2","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                [| s1; Fp.(negate s2); Fp.zero; Fp.zero; Fp.zero |]","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                sys","counters":[]},{"line":"            else","counters":[]},{"line":"              add_generic_constraint ~l:x1 ~r:x2","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                [| s1; Fp.(negate s2); Fp.zero; Fp.zero; Fp.zero |]","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                sys","counters":[]},{"line":"        | `Var x1, `Constant -> (","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (* s1 * x1 = s2","counters":[]},{"line":"               x1 = s2 / s1","counters":[]},{"line":"            *)","counters":[]},{"line":"            let ratio = Fp.(s2 / s1) in","counters":[]},{"line":"            match Hashtbl.find sys.cached_constants ratio with","counters":[]},{"line":"            | Some x2 ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Union_find.union (union_find sys x1) (union_find sys x2)","counters":[{"col_start":43,"col_end":43,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"            | None ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                add_generic_constraint ~l:x1","counters":[]},{"line":"                  [| s1; Fp.zero; Fp.zero; Fp.zero; Fp.negate s2 |]","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"                  sys ;","counters":[]},{"line":"                Hashtbl.set sys.cached_constants ~key:ratio ~data:x1 )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"        | `Constant, `Var x2 -> (","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (* s1 = s2 * x2","counters":[]},{"line":"               x2 = s1 / s2","counters":[]},{"line":"            *)","counters":[]},{"line":"            let ratio = Fp.(s1 / s2) in","counters":[]},{"line":"            match Hashtbl.find sys.cached_constants ratio with","counters":[]},{"line":"            | Some x1 ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Union_find.union (union_find sys x1) (union_find sys x2)","counters":[{"col_start":43,"col_end":43,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"            | None ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                add_generic_constraint ~r:x2","counters":[]},{"line":"                  [| Fp.zero; s2; Fp.zero; Fp.zero; Fp.negate s1 |]","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"                  sys ;","counters":[]},{"line":"                Hashtbl.set sys.cached_constants ~key:ratio ~data:x2 )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"        | `Constant, `Constant ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            assert (Fp.(equal s1 s2)) )","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"    | Plonk_constraint.T (Basic { l; r; o; m; c }) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (* 0","counters":[]},{"line":"           = l.s * l.x","counters":[]},{"line":"           + r.s * r.x","counters":[]},{"line":"           + o.s * o.x","counters":[]},{"line":"           + m * (l.x * r.x)","counters":[]},{"line":"           + c","counters":[]},{"line":"           =","counters":[]},{"line":"             l.s * l.s' * l.x'","counters":[]},{"line":"           + r.s * r.s' * r.x'","counters":[]},{"line":"           + o.s * o.s' * o.x'","counters":[]},{"line":"           + m * (l.s' * l.x' * r.s' * r.x')","counters":[]},{"line":"           + c","counters":[]},{"line":"           =","counters":[]},{"line":"             (l.s * l.s') * l.x'","counters":[]},{"line":"           + (r.s * r.s') * r.x'","counters":[]},{"line":"           + (o.s * o.s') * o.x'","counters":[]},{"line":"           + (m * l.s' * r.s') * l.x' r.x'","counters":[]},{"line":"           + c","counters":[]},{"line":"        *)","counters":[]},{"line":"        (* TODO: This is sub-optimal *)","counters":[]},{"line":"        let c = ref c in","counters":[]},{"line":"        let red_pr (s, x) =","counters":[]},{"line":"          match red x with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | s', `Constant ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              c := Fp.add !c Fp.(s * s') ;","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"              (* No need to have a real term. *)","counters":[]},{"line":"              (s', None)","counters":[]},{"line":"          | s', `Var x ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (s', Some (Fp.(s * s'), x))","counters":[]},{"line":"        in","counters":[]},{"line":"        (* l.s * l.x","counters":[]},{"line":"           + r.s * r.x","counters":[]},{"line":"           + o.s * o.x","counters":[]},{"line":"           + m * (l.x * r.x)","counters":[]},{"line":"           + c","counters":[]},{"line":"           =","counters":[]},{"line":"             l.s * l.s' * l.x'","counters":[]},{"line":"           + r.s * r.x","counters":[]},{"line":"           + o.s * o.x","counters":[]},{"line":"           + m * (l.x * r.x)","counters":[]},{"line":"           + c","counters":[]},{"line":"           =","counters":[]},{"line":"        *)","counters":[]},{"line":"        let l_s', l = red_pr l in","counters":[]},{"line":"        let r_s', r = red_pr r in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let _, o = red_pr o in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let var = Option.map ~f:snd in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let coeff = Option.value_map ~default:Fp.zero ~f:fst in","counters":[]},{"line":"        let m =","counters":[]},{"line":"          match (l, r) with","counters":[]},{"line":"          | Some _, Some _ ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Fp.(l_s' * r_s' * m)","counters":[]},{"line":"          | _ ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (* TODO: Figure this out later. *)","counters":[]},{"line":"              failwith \"Must use non-constant cvar in plonk constraints\"","counters":[]},{"line":"        in","counters":[]},{"line":"        add_generic_constraint ?l:(var l) ?r:(var r) ?o:(var o)","counters":[{"col_start":37,"col_end":37,"count":0},{"col_start":48,"col_end":48,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"          [| coeff l; coeff r; coeff o; m; !c |]","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"          sys","counters":[]},{"line":"    (* | w0 | w1 | w2 | w3 | w4 | w5","counters":[]},{"line":"       state = [ x , x  , x ], [ y, y, y ], ... ]","counters":[]},{"line":"                 i=0, perm^   i=1, perm^","counters":[]},{"line":"    *)","counters":[]},{"line":"    | Plonk_constraint.T (Poseidon { state }) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (* reduce the state *)","counters":[]},{"line":"        let reduce_state sys (s : Fp.t Snarky_backendless.Cvar.t array array) :","counters":[]},{"line":"            V.t array array =","counters":[]},{"line":"          Array.map ~f:(Array.map ~f:reduce_to_v) s","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        in","counters":[]},{"line":"        let state = reduce_state sys state in","counters":[]},{"line":"        (* add_round_state adds a row that contains 5 rounds of permutation *)","counters":[]},{"line":"        let add_round_state ~round (s1, s2, s3, s4, s5) =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let vars =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            [| Some s1.(0)","counters":[]},{"line":"             ; Some s1.(1)","counters":[]},{"line":"             ; Some s1.(2)","counters":[]},{"line":"             ; Some s5.(0) (* the last state is in 2nd position *)","counters":[]},{"line":"             ; Some s5.(1)","counters":[]},{"line":"             ; Some s5.(2)","counters":[]},{"line":"             ; Some s2.(0)","counters":[]},{"line":"             ; Some s2.(1)","counters":[]},{"line":"             ; Some s2.(2)","counters":[]},{"line":"             ; Some s3.(0)","counters":[]},{"line":"             ; Some s3.(1)","counters":[]},{"line":"             ; Some s3.(2)","counters":[]},{"line":"             ; Some s4.(0)","counters":[]},{"line":"             ; Some s4.(1)","counters":[]},{"line":"             ; Some s4.(2)","counters":[]},{"line":"            |]","counters":[]},{"line":"          in","counters":[]},{"line":"          let coeffs =","counters":[]},{"line":"            [| Params.params.round_constants.(round).(0)","counters":[]},{"line":"             ; Params.params.round_constants.(round).(1)","counters":[]},{"line":"             ; Params.params.round_constants.(round).(2)","counters":[]},{"line":"             ; Params.params.round_constants.(round + 1).(0)","counters":[]},{"line":"             ; Params.params.round_constants.(round + 1).(1)","counters":[]},{"line":"             ; Params.params.round_constants.(round + 1).(2)","counters":[]},{"line":"             ; Params.params.round_constants.(round + 2).(0)","counters":[]},{"line":"             ; Params.params.round_constants.(round + 2).(1)","counters":[]},{"line":"             ; Params.params.round_constants.(round + 2).(2)","counters":[]},{"line":"             ; Params.params.round_constants.(round + 3).(0)","counters":[]},{"line":"             ; Params.params.round_constants.(round + 3).(1)","counters":[]},{"line":"             ; Params.params.round_constants.(round + 3).(2)","counters":[]},{"line":"             ; Params.params.round_constants.(round + 4).(0)","counters":[]},{"line":"             ; Params.params.round_constants.(round + 4).(1)","counters":[]},{"line":"             ; Params.params.round_constants.(round + 4).(2)","counters":[]},{"line":"            |]","counters":[]},{"line":"          in","counters":[]},{"line":"          add_row sys vars Poseidon coeffs","counters":[]},{"line":"        in","counters":[]},{"line":"        (* add_last_row adds the last row containing the output *)","counters":[]},{"line":"        let add_last_row state =","counters":[]},{"line":"          let vars =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            [| Some state.(0)","counters":[]},{"line":"             ; Some state.(1)","counters":[]},{"line":"             ; Some state.(2)","counters":[]},{"line":"             ; None","counters":[]},{"line":"             ; None","counters":[]},{"line":"             ; None","counters":[]},{"line":"             ; None","counters":[]},{"line":"             ; None","counters":[]},{"line":"             ; None","counters":[]},{"line":"             ; None","counters":[]},{"line":"             ; None","counters":[]},{"line":"             ; None","counters":[]},{"line":"             ; None","counters":[]},{"line":"             ; None","counters":[]},{"line":"            |]","counters":[]},{"line":"          in","counters":[]},{"line":"          add_row sys vars Zero [||]","counters":[]},{"line":"        in","counters":[]},{"line":"        (* go through the states row by row (a row contains 5 states) *)","counters":[]},{"line":"        let rec process_5_states_at_a_time ~round = function","counters":[]},{"line":"          | [ s1; s2; s3; s4; s5; last ] ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              add_round_state ~round (s1, s2, s3, s4, s5) ;","counters":[]},{"line":"              add_last_row last","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"          | s1 :: s2 :: s3 :: s4 :: s5 :: tl ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              add_round_state ~round (s1, s2, s3, s4, s5) ;","counters":[]},{"line":"              process_5_states_at_a_time ~round:(round + 5) tl","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"          | _ ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              failwith \"incorrect number of states given\"","counters":[]},{"line":"        in","counters":[]},{"line":"        process_5_states_at_a_time ~round:0 (Array.to_list state)","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"    | Plonk_constraint.T","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (EC_add_complete { p1; p2; p3; inf; same_x; slope; inf_z; x21_inv }) ->","counters":[]},{"line":"        let reduce_curve_point (x, y) = (reduce_to_v x, reduce_to_v y) in","counters":[{"col_start":40,"col_end":40,"count":0},{"col_start":51,"col_end":51,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"","counters":[]},{"line":"        (*","counters":[]},{"line":"        //! 0   1   2   3   4   5   6   7      8   9      10      11   12   13   14","counters":[]},{"line":"        //! x1  y1  x2  y2  x3  y3  inf same_x s   inf_z  x21_inv","counters":[]},{"line":"","counters":[]},{"line":"        *)","counters":[]},{"line":"        let x1, y1 = reduce_curve_point p1 in","counters":[]},{"line":"        let x2, y2 = reduce_curve_point p2 in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let x3, y3 = reduce_curve_point p3 in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let vars =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          [| Some x1","counters":[]},{"line":"           ; Some y1","counters":[]},{"line":"           ; Some x2","counters":[]},{"line":"           ; Some y2","counters":[]},{"line":"           ; Some x3","counters":[]},{"line":"           ; Some y3","counters":[]},{"line":"           ; Some (reduce_to_v inf)","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"           ; Some (reduce_to_v same_x)","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"           ; Some (reduce_to_v slope)","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"           ; Some (reduce_to_v inf_z)","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"           ; Some (reduce_to_v x21_inv)","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"           ; None","counters":[]},{"line":"           ; None","counters":[]},{"line":"           ; None","counters":[]},{"line":"           ; None","counters":[]},{"line":"          |]","counters":[]},{"line":"        in","counters":[]},{"line":"        add_row sys vars CompleteAdd [||]","counters":[]},{"line":"    | Plonk_constraint.T (EC_scale { state }) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let i = ref 0 in","counters":[]},{"line":"        (*","counters":[]},{"line":" 0   1   2   3   4   5   6   7   8   9   10  11  12  13  14","counters":[]},{"line":" xT  yT  x0  y0  n   n'      x1  y1  x2  y2  x3  y3  x4  y4","counters":[]},{"line":" x5  y5  b0  b1  b2  b3  b4  s0  s1  s2  s3  s4","counters":[]},{"line":"        *)","counters":[]},{"line":"        let add_ecscale_round","counters":[]},{"line":"            Scale_round.{ accs; bits; ss; base = xt, yt; n_prev; n_next } =","counters":[]},{"line":"          let curr_row =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            [| Some xt","counters":[]},{"line":"             ; Some yt","counters":[]},{"line":"             ; Some (fst accs.(0))","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"             ; Some (snd accs.(0))","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"             ; Some n_prev","counters":[]},{"line":"             ; Some n_next","counters":[]},{"line":"             ; None","counters":[]},{"line":"             ; Some (fst accs.(1))","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"             ; Some (snd accs.(1))","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"             ; Some (fst accs.(2))","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"             ; Some (snd accs.(2))","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"             ; Some (fst accs.(3))","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"             ; Some (snd accs.(3))","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"             ; Some (fst accs.(4))","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"             ; Some (snd accs.(4))","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"            |]","counters":[]},{"line":"          in","counters":[]},{"line":"          let next_row =","counters":[]},{"line":"            [| Some (fst accs.(5))","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"             ; Some (snd accs.(5))","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"             ; Some bits.(0)","counters":[]},{"line":"             ; Some bits.(1)","counters":[]},{"line":"             ; Some bits.(2)","counters":[]},{"line":"             ; Some bits.(3)","counters":[]},{"line":"             ; Some bits.(4)","counters":[]},{"line":"             ; Some ss.(0)","counters":[]},{"line":"             ; Some ss.(1)","counters":[]},{"line":"             ; Some ss.(2)","counters":[]},{"line":"             ; Some ss.(3)","counters":[]},{"line":"             ; Some ss.(4)","counters":[]},{"line":"             ; None","counters":[]},{"line":"             ; None","counters":[]},{"line":"             ; None","counters":[]},{"line":"            |]","counters":[]},{"line":"          in","counters":[]},{"line":"          add_row sys curr_row VarBaseMul [||] ;","counters":[]},{"line":"          add_row sys next_row Zero [||]","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        in","counters":[]},{"line":"","counters":[]},{"line":"        Array.iter","counters":[]},{"line":"          ~f:(fun round -> add_ecscale_round round ; incr i)","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"          (Array.map state ~f:(Scale_round.map ~f:reduce_to_v)) ;","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"        ()","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    | Plonk_constraint.T (EC_endoscale { state; xs; ys; n_acc }) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (* Reduce state. *)","counters":[]},{"line":"        let state = Array.map state ~f:(Endoscale_round.map ~f:reduce_to_v) in","counters":[]},{"line":"        (* Add round function. *)","counters":[]},{"line":"        let add_endoscale_round (round : V.t Endoscale_round.t) =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let row =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            [| Some round.xt","counters":[]},{"line":"             ; Some round.yt","counters":[]},{"line":"             ; None","counters":[]},{"line":"             ; None","counters":[]},{"line":"             ; Some round.xp","counters":[]},{"line":"             ; Some round.yp","counters":[]},{"line":"             ; Some round.n_acc","counters":[]},{"line":"             ; Some round.xr","counters":[]},{"line":"             ; Some round.yr","counters":[]},{"line":"             ; Some round.s1","counters":[]},{"line":"             ; Some round.s3","counters":[]},{"line":"             ; Some round.b1","counters":[]},{"line":"             ; Some round.b2","counters":[]},{"line":"             ; Some round.b3","counters":[]},{"line":"             ; Some round.b4","counters":[]},{"line":"            |]","counters":[]},{"line":"          in","counters":[]},{"line":"          add_row sys row Kimchi_types.EndoMul [||]","counters":[]},{"line":"        in","counters":[]},{"line":"        Array.iter state ~f:add_endoscale_round ;","counters":[]},{"line":"        (* Last row. *)","counters":[]},{"line":"        let vars =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          [| None","counters":[]},{"line":"           ; None","counters":[]},{"line":"           ; None","counters":[]},{"line":"           ; None","counters":[]},{"line":"           ; Some (reduce_to_v xs)","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"           ; Some (reduce_to_v ys)","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"           ; Some (reduce_to_v n_acc)","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"           ; None","counters":[]},{"line":"           ; None","counters":[]},{"line":"           ; None","counters":[]},{"line":"           ; None","counters":[]},{"line":"           ; None","counters":[]},{"line":"           ; None","counters":[]},{"line":"           ; None","counters":[]},{"line":"          |]","counters":[]},{"line":"        in","counters":[]},{"line":"        add_row sys vars Zero [||]","counters":[]},{"line":"    | Plonk_constraint.T","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (EC_endoscalar { state : 'v Endoscale_scalar_round.t array }) ->","counters":[]},{"line":"        (* Add round function. *)","counters":[]},{"line":"        let add_endoscale_scalar_round (round : V.t Endoscale_scalar_round.t) =","counters":[]},{"line":"          let row =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            [| Some round.n0","counters":[]},{"line":"             ; Some round.n8","counters":[]},{"line":"             ; Some round.a0","counters":[]},{"line":"             ; Some round.b0","counters":[]},{"line":"             ; Some round.a8","counters":[]},{"line":"             ; Some round.b8","counters":[]},{"line":"             ; Some round.x0","counters":[]},{"line":"             ; Some round.x1","counters":[]},{"line":"             ; Some round.x2","counters":[]},{"line":"             ; Some round.x3","counters":[]},{"line":"             ; Some round.x4","counters":[]},{"line":"             ; Some round.x5","counters":[]},{"line":"             ; Some round.x6","counters":[]},{"line":"             ; Some round.x7","counters":[]},{"line":"             ; None","counters":[]},{"line":"            |]","counters":[]},{"line":"          in","counters":[]},{"line":"          add_row sys row Kimchi_types.EndoMulScalar [||]","counters":[]},{"line":"        in","counters":[]},{"line":"        Array.iter state","counters":[]},{"line":"          ~f:","counters":[]},{"line":"            (Fn.compose add_endoscale_scalar_round","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"               (Endoscale_scalar_round.map ~f:reduce_to_v) )","counters":[]},{"line":"    | constr ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        failwithf \"Unhandled constraint %s\"","counters":[]},{"line":"          Obj.(Extension_constructor.name (Extension_constructor.of_val constr))","counters":[{"col_start":40,"col_end":40,"count":0},{"col_start":70,"col_end":70,"count":0}]},{"line":"          ()","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}