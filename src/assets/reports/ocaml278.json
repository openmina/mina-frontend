{"filename":"src/lib/mina_metrics/prometheus_metrics/metric_generators.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Async_kernel","counters":[]},{"line":"open Prometheus","counters":[]},{"line":"open Namespace","counters":[]},{"line":"","counters":[]},{"line":"module type Metric_spec_intf = sig","counters":[]},{"line":"  val subsystem : string","counters":[]},{"line":"","counters":[]},{"line":"  val name : string","counters":[]},{"line":"","counters":[]},{"line":"  val help : string","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type Bucketed_average_spec_intf = sig","counters":[]},{"line":"  include Metric_spec_intf","counters":[]},{"line":"","counters":[]},{"line":"  val bucket_interval : Core.Time.Span.t","counters":[]},{"line":"","counters":[]},{"line":"  val num_buckets : int","counters":[]},{"line":"","counters":[]},{"line":"  val render_average : (float * int) list -> float","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type Time_average_spec_intf = sig","counters":[]},{"line":"  include Metric_spec_intf","counters":[]},{"line":"","counters":[]},{"line":"  val tick_interval : Core.Time.Span.t","counters":[]},{"line":"","counters":[]},{"line":"  val rolling_interval : Core.Time.Span.t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type Moving_average_metric_intf = sig","counters":[]},{"line":"  type datum","counters":[]},{"line":"","counters":[]},{"line":"  val v : Gauge.t","counters":[]},{"line":"","counters":[]},{"line":"  val update : datum -> unit","counters":[]},{"line":"","counters":[]},{"line":"  val clear : unit -> unit","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Moving_bucketed_average (Spec : Bucketed_average_spec_intf) () :","counters":[]},{"line":"  Moving_average_metric_intf with type datum := float = struct","counters":[]},{"line":"  open Spec","counters":[]},{"line":"","counters":[]},{"line":"  let v = Gauge.v name ~subsystem ~namespace ~help","counters":[{"col_start":16,"col_end":16,"count":14}]},{"line":"","counters":[]},{"line":"  let empty_bucket_entry = (0.0, 0)","counters":[]},{"line":"","counters":[]},{"line":"  let empty_buckets () = List.init num_buckets ~f:(Fn.const empty_bucket_entry)","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"","counters":[]},{"line":"  let buckets = ref None","counters":[]},{"line":"","counters":[]},{"line":"  let clear () = buckets := Some (empty_buckets ())","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"","counters":[]},{"line":"  let update datum =","counters":[]},{"line":"    if Option.is_none !buckets then buckets := Some (empty_buckets ()) ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"    match Option.value_exn !buckets with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | [] ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        failwith \"Moving_bucketed_average buckets are malformed\"","counters":[]},{"line":"    | (value, num_entries) :: t ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        buckets := Some ((value +. datum, num_entries + 1) :: t)","counters":[]},{"line":"","counters":[]},{"line":"  let () =","counters":[]},{"line":"    let rec tick () =","counters":[]},{"line":"      upon","counters":[{"col_start":6,"col_end":6,"count":14}]},{"line":"        (after (Time_ns.Span.of_ns @@ Time.Span.to_ns bucket_interval))","counters":[{"col_start":13,"col_end":13,"count":14},{"col_start":33,"col_end":33,"count":14},{"col_start":52,"col_end":52,"count":14}]},{"line":"        (fun () ->","counters":[]},{"line":"          if Option.is_none !buckets then buckets := Some (empty_buckets ()) ;","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":42,"col_end":42,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"          let buckets_val = Option.value_exn !buckets in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          Gauge.set v (render_average buckets_val) ;","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"          buckets :=","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Some (empty_bucket_entry :: List.take buckets_val (num_buckets - 1)) ;","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"          tick () )","counters":[]},{"line":"    in","counters":[]},{"line":"    tick ()","counters":[{"col_start":7,"col_end":7,"count":14}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Moving_time_average (Spec : Time_average_spec_intf) () :","counters":[]},{"line":"  Moving_average_metric_intf with type datum := Core.Time.Span.t = struct","counters":[]},{"line":"  open Spec","counters":[]},{"line":"","counters":[]},{"line":"  let () =","counters":[]},{"line":"    let open Time.Span in","counters":[]},{"line":"    let ( = ) = Float.equal in","counters":[]},{"line":"    let ( mod ) = Float.mod_float in","counters":[]},{"line":"    if not (to_ns rolling_interval mod to_ns tick_interval = 0.0) then","counters":[{"col_start":16,"col_end":16,"count":12},{"col_start":43,"col_end":43,"count":12}]},{"line":"      failwith","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        \"invalid intervals provided to Moving_time_average -- the \\","counters":[]},{"line":"         tick_interval does not evenly divide the rolling_interval\"","counters":[]},{"line":"","counters":[]},{"line":"  include","counters":[]},{"line":"    Moving_bucketed_average","counters":[]},{"line":"      (struct","counters":[]},{"line":"        include Spec","counters":[]},{"line":"","counters":[]},{"line":"        let bucket_interval = tick_interval","counters":[]},{"line":"","counters":[]},{"line":"        let num_buckets =","counters":[]},{"line":"          Float.to_int","counters":[{"col_start":21,"col_end":21,"count":12}]},{"line":"            (Time.Span.to_ns rolling_interval /. Time.Span.to_ns tick_interval)","counters":[{"col_start":27,"col_end":27,"count":12},{"col_start":63,"col_end":63,"count":12}]},{"line":"","counters":[]},{"line":"        let render_average buckets =","counters":[]},{"line":"          let total_sum, count_sum =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            List.fold buckets ~init:(0.0, 0)","counters":[]},{"line":"              ~f:(fun (total_sum, count_sum) (total, count) ->","counters":[]},{"line":"                (total_sum +. total, count_sum + count) )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"          in","counters":[]},{"line":"          total_sum /. Float.of_int count_sum","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"      end)","counters":[]},{"line":"      ()","counters":[]},{"line":"","counters":[]},{"line":"  let update span = update (Core.Time.Span.to_sec span)","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"end","counters":[]}]}