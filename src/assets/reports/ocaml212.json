{"filename":"src/lib/crypto/kimchi_backend/common/curve.ml","lines":[{"line":"open Intf","counters":[]},{"line":"open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"module type Input_intf = sig","counters":[]},{"line":"  module BaseField : sig","counters":[]},{"line":"    type t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module ScalarField : sig","counters":[]},{"line":"    type t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Affine : sig","counters":[]},{"line":"    type t = BaseField.t Kimchi_types.or_infinity","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  type t","counters":[]},{"line":"","counters":[]},{"line":"  val to_affine : t -> Affine.t","counters":[]},{"line":"","counters":[]},{"line":"  val of_affine_coordinates : BaseField.t -> BaseField.t -> t","counters":[]},{"line":"","counters":[]},{"line":"  val add : t -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"  val double : t -> t","counters":[]},{"line":"","counters":[]},{"line":"  val scale : t -> ScalarField.t -> t","counters":[]},{"line":"","counters":[]},{"line":"  val sub : t -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"  val negate : t -> t","counters":[]},{"line":"","counters":[]},{"line":"  val random : unit -> t","counters":[]},{"line":"","counters":[]},{"line":"  val one : unit -> t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type Field_intf = sig","counters":[]},{"line":"  module Stable : sig","counters":[]},{"line":"    module Latest : sig","counters":[]},{"line":"      type t [@@deriving bin_io, equal, sexp, compare, yojson, hash]","counters":[]},{"line":"    end","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  type t = Stable.Latest.t","counters":[]},{"line":"","counters":[]},{"line":"  val ( + ) : t -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"  val ( * ) : t -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"  val one : t","counters":[]},{"line":"","counters":[]},{"line":"  val square : t -> t","counters":[]},{"line":"","counters":[]},{"line":"  val is_square : t -> bool","counters":[]},{"line":"","counters":[]},{"line":"  val sqrt : t -> t","counters":[]},{"line":"","counters":[]},{"line":"  val random : unit -> t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make","counters":[]},{"line":"    (BaseField : Field_intf) (ScalarField : sig","counters":[]},{"line":"      type t","counters":[]},{"line":"    end) (Params : sig","counters":[]},{"line":"      val a : BaseField.t","counters":[]},{"line":"","counters":[]},{"line":"      val b : BaseField.t","counters":[]},{"line":"    end)","counters":[]},{"line":"    (C : Input_intf","counters":[]},{"line":"           with module BaseField := BaseField","counters":[]},{"line":"            and module ScalarField := ScalarField) =","counters":[]},{"line":"struct","counters":[]},{"line":"  include (C : module type of C with type t = C.t with module Affine := C.Affine)","counters":[]},{"line":"","counters":[]},{"line":"  module Base_field = BaseField","counters":[]},{"line":"","counters":[]},{"line":"  let one = one ()","counters":[{"col_start":14,"col_end":14,"count":2}]},{"line":"","counters":[]},{"line":"  (* TODO: wouldn't be easier if Input_intf exposed a `zero`? *)","counters":[]},{"line":"  let zero = sub one one","counters":[{"col_start":15,"col_end":15,"count":2}]},{"line":"","counters":[]},{"line":"  let y_squared x =","counters":[]},{"line":"    let open BaseField in","counters":[{"col_start":4,"col_end":4,"count":114}]},{"line":"    Params.b + (x * (Params.a + square x))","counters":[{"col_start":37,"col_end":37,"count":114}]},{"line":"","counters":[]},{"line":"  module Affine = struct","counters":[]},{"line":"    module Backend = struct","counters":[]},{"line":"      include C.Affine","counters":[]},{"line":"","counters":[]},{"line":"      let zero () = Kimchi_types.Infinity","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"","counters":[]},{"line":"      let create x y = Kimchi_types.Finite (x, y)","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        module T = struct","counters":[]},{"line":"          type t = BaseField.Stable.Latest.t * BaseField.Stable.Latest.t","counters":[{"col_start":10,"col_end":10,"count":2},{"col_start":15,"col_end":15,"count":2},{"col_start":19,"col_end":19,"count":0},{"col_start":43,"col_end":43,"count":0},{"col_start":47,"col_end":47,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"          [@@deriving equal, bin_io, sexp, compare, yojson, hash]","counters":[{"col_start":64,"col_end":64,"count":8}]},{"line":"        end","counters":[]},{"line":"","counters":[]},{"line":"        (* asserts the versioned-ness of V1","counters":[]},{"line":"           to do this properly, we'd move the Stable module outside the functor","counters":[]},{"line":"        *)","counters":[]},{"line":"        let __versioned__ = ()","counters":[]},{"line":"","counters":[]},{"line":"        include T","counters":[]},{"line":"","counters":[]},{"line":"        exception Invalid_curve_point of t","counters":[]},{"line":"","counters":[]},{"line":"        include","counters":[]},{"line":"          Binable.Of_binable","counters":[]},{"line":"            (T)","counters":[]},{"line":"            (struct","counters":[]},{"line":"              let on_curve (x, y) =","counters":[]},{"line":"                BaseField.Stable.Latest.equal (y_squared x) (BaseField.square y)","counters":[{"col_start":16,"col_end":16,"count":114},{"col_start":55,"col_end":55,"count":114},{"col_start":76,"col_end":76,"count":114}]},{"line":"","counters":[]},{"line":"              type t = T.t","counters":[]},{"line":"","counters":[]},{"line":"              let to_binable = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"              let of_binable t =","counters":[]},{"line":"                if not (on_curve t) then raise (Invalid_curve_point t) ;","counters":[{"col_start":16,"col_end":16,"count":114},{"col_start":31,"col_end":31,"count":114},{"col_start":41,"col_end":41,"count":0}]},{"line":"                t","counters":[{"col_start":16,"col_end":16,"count":114}]},{"line":"            end)","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      module Latest = V1","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    let%test \"cannot deserialize invalid points\" =","counters":[]},{"line":"      (* y^2 = x^3 + a x + b","counters":[]},{"line":"","counters":[]},{"line":"         pick c at random","counters":[]},{"line":"         let (x, y) = (c^2, c^3)","counters":[]},{"line":"","counters":[]},{"line":"         Then the above equation becomes","counters":[]},{"line":"         c^6 = c^6 + (a c^2 + b)","counters":[]},{"line":"","counters":[]},{"line":"         a c^3 + b is almost certainly nonzero (and for our curves, with a = 0, it always is)","counters":[]},{"line":"         so this point is almost certainly (and for our curves, always) invalid","counters":[]},{"line":"      *)","counters":[]},{"line":"      let invalid =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let open BaseField in","counters":[]},{"line":"        let c = random () in","counters":[]},{"line":"        let c2 = square c in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        (c2, c2 * c)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      in","counters":[]},{"line":"      match","counters":[]},{"line":"        Binable.to_string (module Stable.Latest) invalid","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"        |> Binable.of_string (module Stable.Latest)","counters":[]},{"line":"      with","counters":[]},{"line":"      | exception Stable.V1.Invalid_curve_point _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          true","counters":[]},{"line":"      | _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          false","counters":[]},{"line":"","counters":[]},{"line":"    include Stable.Latest","counters":[]},{"line":"","counters":[]},{"line":"    let to_backend :","counters":[]},{"line":"        (Base_field.t * Base_field.t) Pickles_types.Or_infinity.t -> Backend.t =","counters":[]},{"line":"      function","counters":[]},{"line":"      | Infinity ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Infinity","counters":[]},{"line":"      | Finite (x, y) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Finite (x, y)","counters":[]},{"line":"","counters":[]},{"line":"    let of_backend :","counters":[]},{"line":"        Backend.t -> (Base_field.t * Base_field.t) Pickles_types.Or_infinity.t =","counters":[]},{"line":"      function","counters":[]},{"line":"      | Infinity ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Infinity","counters":[]},{"line":"      | Finite (x, y) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Finite (x, y)","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let to_affine_or_infinity = C.to_affine","counters":[]},{"line":"","counters":[]},{"line":"  let to_affine_exn t =","counters":[]},{"line":"    match C.to_affine t with","counters":[{"col_start":4,"col_end":4,"count":5}]},{"line":"    | Infinity ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        failwith \"to_affine_exn: Got identity\"","counters":[]},{"line":"    | Finite (x, y) ->","counters":[{"col_start":6,"col_end":6,"count":5}]},{"line":"        (x, y)","counters":[]},{"line":"","counters":[]},{"line":"  let of_affine (x, y) = C.of_affine_coordinates x y","counters":[{"col_start":25,"col_end":25,"count":2}]},{"line":"","counters":[]},{"line":"  include","counters":[]},{"line":"    Binable.Of_binable","counters":[]},{"line":"      (Affine)","counters":[]},{"line":"      (struct","counters":[]},{"line":"        type nonrec t = t","counters":[]},{"line":"","counters":[]},{"line":"        let to_binable = to_affine_exn","counters":[]},{"line":"","counters":[]},{"line":"        let of_binable = of_affine","counters":[]},{"line":"      end)","counters":[]},{"line":"","counters":[]},{"line":"  let ( + ) = add","counters":[]},{"line":"","counters":[]},{"line":"  let ( * ) s t = scale t s","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"","counters":[]},{"line":"  let find_y x =","counters":[]},{"line":"    let open BaseField in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let y2 = y_squared x in","counters":[]},{"line":"    if is_square y2 then Some (sqrt y2) else None","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"","counters":[]},{"line":"  let point_near_x (x : BaseField.t) =","counters":[]},{"line":"    let rec go x = function","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      | Some y ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          of_affine (x, y)","counters":[]},{"line":"      | None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let x' = BaseField.(one + x) in","counters":[]},{"line":"          go x' (find_y x')","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"    in","counters":[]},{"line":"    go x (find_y x)","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}