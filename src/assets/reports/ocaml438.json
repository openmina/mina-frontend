{"filename":"src/lib/crypto/kimchi_backend/common/scale_round.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"[%%versioned","counters":[]},{"line":"module Stable = struct","counters":[]},{"line":"  module V2 = struct","counters":[]},{"line":"    type 'a t =","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":12,"col_end":12,"count":4}]},{"line":"      { accs : ('a * 'a) array","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":11,"col_end":11,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"      ; bits : 'a array","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":11,"col_end":11,"count":0}]},{"line":"      ; ss : 'a array","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":9,"col_end":9,"count":0}]},{"line":"      ; base : 'a * 'a","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":11,"col_end":11,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"      ; n_prev : 'a","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":13,"col_end":13,"count":0}]},{"line":"      ; n_next : 'a","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":13,"col_end":13,"count":0}]},{"line":"      }","counters":[]},{"line":"    [@@deriving sexp, fields, hlist]","counters":[{"col_start":35,"col_end":35,"count":1}]},{"line":"  end","counters":[]},{"line":"end]","counters":[]},{"line":"","counters":[]},{"line":"let map { accs; bits; ss; base; n_prev; n_next } ~f =","counters":[]},{"line":"  { accs = Array.map accs ~f:(fun (x, y) -> (f x, f y))","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"  ; bits = Array.map bits ~f","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"  ; ss = Array.map ss ~f","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"  ; base = (f (fst base), f (snd base))","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"  ; n_prev = f n_prev","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"  ; n_next = f n_next","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"let map2 t1 t2 ~f =","counters":[]},{"line":"  { accs =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      Array.map (Array.zip_exn t1.accs t2.accs) ~f:(fun ((x1, y1), (x2, y2)) ->","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"          (f x1 x2, f y1 y2) )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":11,"col_end":11,"count":0},{"col_start":20,"col_end":20,"count":0}]},{"line":"  ; bits =","counters":[]},{"line":"      Array.map (Array.zip_exn t1.bits t2.bits) ~f:(fun (x1, x2) -> f x1 x2)","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"  ; ss = Array.map (Array.zip_exn t1.ss t2.ss) ~f:(fun (x1, x2) -> f x1 x2)","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"  ; base = (f (fst t1.base) (fst t2.base), f (snd t1.base) (snd t2.base))","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":43,"col_end":43,"count":0},{"col_start":48,"col_end":48,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"  ; n_prev = f t1.n_prev t2.n_prev","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"  ; n_next = f t1.n_next t2.n_next","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"let fold { accs; bits; ss; base; n_prev; n_next } ~f ~init =","counters":[]},{"line":"  let t = Array.fold accs ~init ~f:(fun acc (x, y) -> f [ x; y ] acc) in","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"  let t = Array.fold bits ~init:t ~f:(fun acc x -> f [ x ] acc) in","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"  let t = Array.fold ss ~init:t ~f:(fun acc x -> f [ x ] acc) in","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"  let t = f [ fst base; snd base ] t in","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"  let t = f [ n_prev ] t in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let t = f [ n_next ] t in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  t","counters":[{"col_start":2,"col_end":2,"count":2}]}]}