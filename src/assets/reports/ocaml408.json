{"filename":"src/lib/pickles_types/plonk_types.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"let padded_array_typ ~length ~dummy elt =","counters":[]},{"line":"  Snarky_backendless.Typ.array ~length elt","counters":[{"col_start":2,"col_end":2,"count":4},{"col_start":29,"col_end":29,"count":4}]},{"line":"  |> Snarky_backendless.Typ.transport","counters":[]},{"line":"       ~there:(fun a ->","counters":[]},{"line":"         let n = Array.length a in","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"         if n > length then failwithf \"Expected %d <= %d\" n length () ;","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"         Array.append a (Array.create ~len:(length - n) dummy) )","counters":[{"col_start":9,"col_end":9,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"       ~back:Fn.id","counters":[]},{"line":"","counters":[]},{"line":"let hash_fold_array f s x = hash_fold_list f s (Array.to_list x)","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"","counters":[]},{"line":"module Columns = Nat.N15","counters":[]},{"line":"module Columns_vec = Vector.Vector_15","counters":[]},{"line":"module Permuts_minus_1 = Nat.N6","counters":[]},{"line":"module Permuts_minus_1_vec = Vector.Vector_6","counters":[]},{"line":"module Permuts = Nat.N7","counters":[]},{"line":"module Permuts_vec = Vector.Vector_7","counters":[]},{"line":"","counters":[]},{"line":"module Opt = struct","counters":[]},{"line":"  [@@@warning \"-4\"]","counters":[]},{"line":"","counters":[]},{"line":"  type ('a, 'bool) t = Some of 'a | None | Maybe of 'bool * 'a","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":52,"col_end":52,"count":0},{"col_start":56,"col_end":56,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"  [@@deriving sexp, compare, yojson, hash, equal]","counters":[]},{"line":"","counters":[]},{"line":"  let to_option : ('a, _) t -> 'a option = function","counters":[]},{"line":"    | Some x ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Some x","counters":[]},{"line":"    | Maybe (_, x) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Some x","counters":[]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        None","counters":[]},{"line":"","counters":[]},{"line":"  let value_exn = function","counters":[]},{"line":"    | Some x ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        x","counters":[]},{"line":"    | Maybe (_, x) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        x","counters":[]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        invalid_arg \"Opt.value_exn\"","counters":[]},{"line":"","counters":[]},{"line":"  let of_option (t : 'a option) : ('a, 'bool) t =","counters":[]},{"line":"    match t with None -> None | Some x -> Some x","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"","counters":[]},{"line":"  module Flag = struct","counters":[]},{"line":"    type t = Yes | No | Maybe [@@deriving sexp, compare, yojson, hash, equal]","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let map t ~f =","counters":[]},{"line":"    match t with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        None","counters":[]},{"line":"    | Some x ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Some (f x)","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"    | Maybe (b, x) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Maybe (b, f x)","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"","counters":[]},{"line":"  open Snarky_backendless","counters":[]},{"line":"","counters":[]},{"line":"  let some_typ (type a a_var f bool_var) (t : (a_var, a, f) Typ.t) :","counters":[]},{"line":"      ((a_var, bool_var) t, a option, f) Typ.t =","counters":[]},{"line":"    Typ.transport t ~there:(fun x -> Option.value_exn x) ~back:Option.return","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"    |> Typ.transport_var","counters":[]},{"line":"         ~there:(function","counters":[]},{"line":"           | Some x ->","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"               x","counters":[]},{"line":"           | Maybe _ | None ->","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"               failwith \"Opt.some_typ: expected Some\" )","counters":[]},{"line":"         ~back:(fun x -> Some x)","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"  let none_typ (type a a_var f bool) () : ((a_var, bool) t, a option, f) Typ.t =","counters":[]},{"line":"    Typ.transport (Typ.unit ())","counters":[{"col_start":4,"col_end":4,"count":2},{"col_start":16,"col_end":16,"count":2},{"col_start":26,"col_end":26,"count":2}]},{"line":"      ~there:(fun _ -> ())","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"      ~back:(fun () : _ Option.t -> None)","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"    |> Typ.transport_var","counters":[]},{"line":"         ~there:(function","counters":[]},{"line":"           | None ->","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"               ()","counters":[]},{"line":"           | Maybe _ | Some _ ->","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"               failwith \"Opt.none_typ: expected None\" )","counters":[]},{"line":"         ~back:(fun () : _ t -> None)","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"","counters":[]},{"line":"  let maybe_typ (type a a_var bool_var f)","counters":[]},{"line":"      (bool_typ : (bool_var, bool, f) Snarky_backendless.Typ.t) ~(dummy : a)","counters":[]},{"line":"      (a_typ : (a_var, a, f) Typ.t) : ((a_var, bool_var) t, a option, f) Typ.t =","counters":[]},{"line":"    Typ.transport","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":16,"col_end":16,"count":0}]},{"line":"      (Typ.tuple2 bool_typ a_typ)","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"      ~there:(fun (t : a option) ->","counters":[]},{"line":"        match t with None -> (false, dummy) | Some x -> (true, x) )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"      ~back:(fun (b, x) -> if b then Some x else None)","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"    |> Typ.transport_var","counters":[]},{"line":"         ~there:(fun (t : (a_var, _) t) ->","counters":[]},{"line":"           match t with","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"           | Maybe (b, x) ->","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"               (b, x)","counters":[]},{"line":"           | None | Some _ ->","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":20,"col_end":20,"count":0}]},{"line":"               failwith \"Opt.maybe_typ: expected Maybe\" )","counters":[]},{"line":"         ~back:(fun (b, x) -> Maybe (b, x))","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"","counters":[]},{"line":"  let constant_layout_typ (type a a_var f) (bool_typ : _ Typ.t) ~true_ ~false_","counters":[]},{"line":"      (flag : Flag.t) (a_typ : (a_var, a, f) Typ.t) ~(dummy : a)","counters":[]},{"line":"      ~(dummy_var : a_var) =","counters":[]},{"line":"    let (Typ bool_typ) = bool_typ in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let bool_typ : _ Typ.t =","counters":[]},{"line":"      let check =","counters":[]},{"line":"        (* No need to boolean constrain in the No or Yes case *)","counters":[]},{"line":"        match flag with","counters":[]},{"line":"        | No | Yes ->","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"            fun _ -> Checked_ast.return ()","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"        | Maybe ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            bool_typ.check","counters":[]},{"line":"      in","counters":[]},{"line":"      Typ { bool_typ with check }","counters":[]},{"line":"    in","counters":[]},{"line":"    Typ.transport","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"      (Typ.tuple2 bool_typ a_typ)","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"      ~there:(fun (t : a option) ->","counters":[]},{"line":"        match t with None -> (false, dummy) | Some x -> (true, x) )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"      ~back:(fun (b, x) -> if b then Some x else None)","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"    |> Typ.transport_var","counters":[]},{"line":"         ~there:(fun (t : (a_var, _) t) ->","counters":[]},{"line":"           match t with","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"           | Maybe (b, x) ->","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"               (b, x)","counters":[]},{"line":"           | None ->","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"               (false_, dummy_var)","counters":[]},{"line":"           | Some x ->","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"               (true_, x) )","counters":[]},{"line":"         ~back:(fun (b, x) ->","counters":[]},{"line":"           match flag with No -> None | Yes -> Some x | Maybe -> Maybe (b, x) )","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"","counters":[]},{"line":"  let typ (type a a_var f) bool_typ (flag : Flag.t)","counters":[]},{"line":"      (a_typ : (a_var, a, f) Typ.t) ~(dummy : a) =","counters":[]},{"line":"    match flag with","counters":[{"col_start":4,"col_end":4,"count":2}]},{"line":"    | Yes ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        some_typ a_typ","counters":[]},{"line":"    | No ->","counters":[{"col_start":6,"col_end":6,"count":2}]},{"line":"        none_typ ()","counters":[]},{"line":"    | Maybe ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        maybe_typ bool_typ ~dummy a_typ","counters":[]},{"line":"","counters":[]},{"line":"  module Early_stop_sequence = struct","counters":[]},{"line":"    (* A sequence that should be considered to have stopped at","counters":[]},{"line":"       the first No flag *)","counters":[]},{"line":"    (* TODO: The documentation above makes it sound like the type below is too","counters":[]},{"line":"       generic: we're not guaranteed to have flags in there *)","counters":[]},{"line":"    type nonrec ('a, 'bool) t = ('a, 'bool) t list","counters":[]},{"line":"","counters":[]},{"line":"    let fold (type a bool acc res)","counters":[]},{"line":"        (if_res : bool -> then_:res -> else_:res -> res) (t : (a, bool) t)","counters":[]},{"line":"        ~(init : acc) ~(f : acc -> a -> acc) ~(finish : acc -> res) =","counters":[]},{"line":"      let rec go acc = function","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        | [] ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            finish acc","counters":[]},{"line":"        | None :: xs ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            go acc xs","counters":[]},{"line":"        | Some x :: xs ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            go (f acc x) xs","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"        | Maybe (b, x) :: xs ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (* Computing this first makes mutation in f OK. *)","counters":[]},{"line":"            let stop_res = finish acc in","counters":[]},{"line":"            let continue_res = go (f acc x) xs in","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"            if_res b ~then_:continue_res ~else_:stop_res","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"      in","counters":[]},{"line":"      go init t","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Lookup_config = struct","counters":[]},{"line":"  type t = { lookup : Opt.Flag.t; runtime : Opt.Flag.t }","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Evals = struct","counters":[]},{"line":"  module Lookup = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type 'f t =","counters":[{"col_start":8,"col_end":8,"count":1},{"col_start":16,"col_end":16,"count":4}]},{"line":"          { sorted : 'f array; aggreg : 'f; table : 'f; runtime : 'f option }","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":48,"col_end":48,"count":0},{"col_start":52,"col_end":52,"count":0},{"col_start":53,"col_end":53,"count":0},{"col_start":56,"col_end":56,"count":0},{"col_start":62,"col_end":62,"count":0},{"col_start":66,"col_end":66,"count":0},{"col_start":67,"col_end":67,"count":0},{"col_start":74,"col_end":74,"count":0}]},{"line":"        [@@deriving fields, sexp, compare, yojson, hash, equal, hlist]","counters":[{"col_start":69,"col_end":69,"count":3}]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    let sorted_length = 5","counters":[]},{"line":"","counters":[]},{"line":"    let dummy ~runtime z =","counters":[]},{"line":"      { aggreg = z","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      ; table = z","counters":[]},{"line":"      ; sorted = Array.create ~len:sorted_length z","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"      ; runtime = Option.some_if runtime z","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    let map { sorted; aggreg; table; runtime } ~f =","counters":[]},{"line":"      { sorted = Array.map ~f sorted","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"      ; aggreg = f aggreg","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"      ; table = f table","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"      ; runtime = Option.map ~f runtime","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    let map2 t1 t2 ~f =","counters":[]},{"line":"      { sorted = Array.map2_exn ~f t1.sorted t2.sorted","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"      ; aggreg = f t1.aggreg t2.aggreg","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"      ; table = f t1.table t2.table","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"      ; runtime = Option.map2 ~f t1.runtime t2.runtime","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    module In_circuit = struct","counters":[]},{"line":"      type ('f, 'bool) t =","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"        { sorted : 'f array","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        ; aggreg : 'f","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        ; table : 'f","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        ; runtime : ('f, 'bool) Opt.t","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        }","counters":[]},{"line":"      [@@deriving hlist, fields]","counters":[]},{"line":"","counters":[]},{"line":"      let map { sorted; aggreg; table; runtime } ~f =","counters":[]},{"line":"        { sorted = Array.map ~f sorted","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"        ; aggreg = f aggreg","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"        ; table = f table","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"        ; runtime = Opt.map ~f runtime","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"        }","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    let to_in_circuit (type f bool) ({ sorted; aggreg; table; runtime } : f t) :","counters":[]},{"line":"        (f, bool) In_circuit.t =","counters":[]},{"line":"      { sorted; aggreg; table; runtime = Opt.of_option runtime }","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"","counters":[]},{"line":"    let typ impl e ~runtime ~dummy =","counters":[]},{"line":"      Snarky_backendless.Typ.of_hlistable","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [ Snarky_backendless.Typ.array ~length:sorted_length e","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"        ; e","counters":[]},{"line":"        ; e","counters":[]},{"line":"        ; Opt.typ impl runtime e ~dummy","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"        ]","counters":[]},{"line":"        ~value_to_hlist:to_hlist ~value_of_hlist:of_hlist","counters":[]},{"line":"        ~var_to_hlist:In_circuit.to_hlist ~var_of_hlist:In_circuit.of_hlist","counters":[]},{"line":"","counters":[]},{"line":"    let opt_typ impl ({ lookup; runtime } : Lookup_config.t) ~dummy:z elt =","counters":[]},{"line":"      Opt.typ impl lookup","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ~dummy:(dummy z ~runtime:(Opt.Flag.equal runtime Yes))","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"        (typ impl ~runtime ~dummy:z elt)","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V2 = struct","counters":[]},{"line":"      type 'a t =","counters":[{"col_start":6,"col_end":6,"count":30},{"col_start":14,"col_end":14,"count":4}]},{"line":"        { w : 'a Columns_vec.Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":14,"col_end":14,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"        ; z : 'a","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":14,"col_end":14,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"        ; s : 'a Permuts_minus_1_vec.Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":14,"col_end":14,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"        ; generic_selector : 'a","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"        ; poseidon_selector : 'a","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"        ; lookup : 'a Lookup.Stable.V1.t option","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"        }","counters":[]},{"line":"      [@@deriving fields, sexp, compare, yojson, hash, equal, hlist]","counters":[{"col_start":67,"col_end":67,"count":5}]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  let to_absorption_sequence","counters":[]},{"line":"      { w; z; s; generic_selector; poseidon_selector; lookup } : _ list =","counters":[]},{"line":"    let always_present =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      [ z; generic_selector; poseidon_selector ]","counters":[]},{"line":"      @ Vector.to_list w @ Vector.to_list s","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"    in","counters":[]},{"line":"    let lookup =","counters":[]},{"line":"      match lookup with","counters":[]},{"line":"      | None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          []","counters":[]},{"line":"      | Some { Lookup.runtime; table; aggreg; sorted } ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          [ aggreg; table ] @ Array.to_list sorted @ Option.to_list runtime","counters":[{"col_start":42,"col_end":42,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"    in","counters":[]},{"line":"    always_present @ lookup","counters":[]},{"line":"","counters":[]},{"line":"  module In_circuit = struct","counters":[]},{"line":"    type ('f, 'bool) t =","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"      { w : 'f Columns_vec.t","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      ; z : 'f","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      ; s : 'f Permuts_minus_1_vec.t","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      ; generic_selector : 'f","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      ; poseidon_selector : 'f","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      ; lookup : (('f, 'bool) Lookup.In_circuit.t, 'bool) Opt.t","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      }","counters":[]},{"line":"    [@@deriving hlist, fields]","counters":[]},{"line":"","counters":[]},{"line":"    let map (type bool a b)","counters":[]},{"line":"        ({ w; z; s; generic_selector; poseidon_selector; lookup } : (a, bool) t)","counters":[]},{"line":"        ~(f : a -> b) : (b, bool) t =","counters":[]},{"line":"      { w = Vector.map w ~f","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"      ; z = f z","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"      ; s = Vector.map s ~f","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"      ; generic_selector = f generic_selector","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"      ; poseidon_selector = f poseidon_selector","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"      ; lookup = Opt.map ~f:(Lookup.In_circuit.map ~f) lookup","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    let to_list { w; z; s; generic_selector; poseidon_selector; lookup } =","counters":[]},{"line":"      let some x = Opt.Some x in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"      let always_present =","counters":[]},{"line":"        List.map ~f:some","counters":[]},{"line":"          ( [ z; generic_selector; poseidon_selector ]","counters":[]},{"line":"          @ Vector.to_list w @ Vector.to_list s )","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"      in","counters":[]},{"line":"      let with_lookup ~f (lookup : _ Lookup.In_circuit.t) =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        always_present","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        @ List.map ~f","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"            (Array.to_list lookup.sorted @ [ lookup.aggreg; lookup.table ])","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"        @","counters":[]},{"line":"        match lookup.runtime with","counters":[]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            []","counters":[]},{"line":"        | Some _ | Maybe _ ->","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"            [ lookup.runtime ]","counters":[]},{"line":"      in","counters":[]},{"line":"      match lookup with","counters":[]},{"line":"      | None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          always_present","counters":[]},{"line":"      | Some lookup ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          with_lookup ~f:some lookup","counters":[]},{"line":"      | Maybe (b, lookup) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          with_lookup ~f:(fun x -> Maybe (b, x)) lookup","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"    let to_absorption_sequence","counters":[]},{"line":"        { w; z; s; generic_selector; poseidon_selector; lookup } :","counters":[]},{"line":"        _ Opt.Early_stop_sequence.t =","counters":[]},{"line":"      let always_present =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [ z; generic_selector; poseidon_selector ]","counters":[]},{"line":"        @ Vector.to_list w @ Vector.to_list s","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"      in","counters":[]},{"line":"      let some x = Opt.Some x in","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"      let lookup =","counters":[]},{"line":"        match lookup with","counters":[]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            []","counters":[]},{"line":"        | Some { Lookup.In_circuit.runtime; table; aggreg; sorted } ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            List.map ~f:some ([ aggreg; table ] @ Array.to_list sorted)","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"            @ [ runtime ]","counters":[]},{"line":"        | Maybe (b, { Lookup.In_circuit.runtime; table; aggreg; sorted }) ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            List.map","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"              ~f:(fun x -> Opt.Maybe (b, x))","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"              ([ aggreg; table ] @ Array.to_list sorted)","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"            @ [ runtime ]","counters":[]},{"line":"      in","counters":[]},{"line":"      List.map ~f:some always_present @ lookup","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let to_in_circuit (type bool a)","counters":[]},{"line":"      ({ w; z; s; generic_selector; poseidon_selector; lookup } : a t) :","counters":[]},{"line":"      (a, bool) In_circuit.t =","counters":[]},{"line":"    { w","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    ; z","counters":[]},{"line":"    ; s","counters":[]},{"line":"    ; generic_selector","counters":[]},{"line":"    ; poseidon_selector","counters":[]},{"line":"    ; lookup = Opt.of_option (Option.map ~f:Lookup.to_in_circuit lookup)","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let map (type a b)","counters":[]},{"line":"      ({ w; z; s; generic_selector; poseidon_selector; lookup } : a t)","counters":[]},{"line":"      ~(f : a -> b) : b t =","counters":[]},{"line":"    { w = Vector.map w ~f","counters":[{"col_start":4,"col_end":4,"count":2},{"col_start":19,"col_end":19,"count":2}]},{"line":"    ; z = f z","counters":[{"col_start":10,"col_end":10,"count":2}]},{"line":"    ; s = Vector.map s ~f","counters":[{"col_start":19,"col_end":19,"count":2}]},{"line":"    ; generic_selector = f generic_selector","counters":[{"col_start":25,"col_end":25,"count":2}]},{"line":"    ; poseidon_selector = f poseidon_selector","counters":[{"col_start":26,"col_end":26,"count":2}]},{"line":"    ; lookup = Option.map ~f:(Lookup.map ~f) lookup","counters":[{"col_start":24,"col_end":24,"count":2}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let map2 (type a b c) (t1 : a t) (t2 : b t) ~(f : a -> b -> c) : c t =","counters":[]},{"line":"    { w = Vector.map2 t1.w t2.w ~f","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":20,"col_end":20,"count":0}]},{"line":"    ; z = f t1.z t2.z","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    ; s = Vector.map2 t1.s t2.s ~f","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"    ; generic_selector = f t1.generic_selector t2.generic_selector","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"    ; poseidon_selector = f t1.poseidon_selector t2.poseidon_selector","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"    ; lookup = Option.map2 t1.lookup t2.lookup ~f:(Lookup.map2 ~f)","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  (*","counters":[]},{"line":"      This is in the same order as the evaluations in the opening proof:","counters":[]},{"line":"     added later:","counters":[]},{"line":"     - old sg polynomials","counters":[]},{"line":"     - public input polynomial","counters":[]},{"line":"     - ft","counters":[]},{"line":"     here:","counters":[]},{"line":"     - z","counters":[]},{"line":"     - generic selector","counters":[]},{"line":"     - poseidon selector","counters":[]},{"line":"     - w (witness columns)","counters":[]},{"line":"     - s (sigma columns)","counters":[]},{"line":"","counters":[]},{"line":"     then optionally:","counters":[]},{"line":"     - lookup sorted","counters":[]},{"line":"     - lookup aggreg","counters":[]},{"line":"     - lookup table","counters":[]},{"line":"     - lookup runtime","counters":[]},{"line":"  *)","counters":[]},{"line":"","counters":[]},{"line":"  let to_list { w; z; s; generic_selector; poseidon_selector; lookup } =","counters":[]},{"line":"    let always_present =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      [ z; generic_selector; poseidon_selector ]","counters":[]},{"line":"      @ Vector.to_list w @ Vector.to_list s","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"    in","counters":[]},{"line":"    match lookup with","counters":[]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        always_present","counters":[]},{"line":"    | Some lookup ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        always_present","counters":[]},{"line":"        @ Array.to_list lookup.sorted","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"        @ [ lookup.aggreg; lookup.table ]","counters":[]},{"line":"        @ Option.to_list lookup.runtime","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"  let typ (type f a_var a)","counters":[]},{"line":"      (module Impl : Snarky_backendless.Snark_intf.Run with type field = f)","counters":[]},{"line":"      ~dummy e lookup_config :","counters":[]},{"line":"      ((a_var, Impl.Boolean.var) In_circuit.t, a t, f) Snarky_backendless.Typ.t","counters":[]},{"line":"      =","counters":[]},{"line":"    let open Impl in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let lookup_typ = Lookup.opt_typ Impl.Boolean.typ lookup_config e ~dummy in","counters":[]},{"line":"    Typ.of_hlistable","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      [ Vector.typ e Columns.n","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"      ; e","counters":[]},{"line":"      ; Vector.typ e Permuts_minus_1.n","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"      ; e","counters":[]},{"line":"      ; e","counters":[]},{"line":"      ; lookup_typ","counters":[]},{"line":"      ]","counters":[]},{"line":"      ~var_to_hlist:In_circuit.to_hlist ~var_of_hlist:In_circuit.of_hlist","counters":[]},{"line":"      ~value_to_hlist:to_hlist ~value_of_hlist:of_hlist","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module All_evals = struct","counters":[]},{"line":"  module With_public_input = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type ('f, 'f_multi) t =","counters":[{"col_start":8,"col_end":8,"count":7},{"col_start":28,"col_end":28,"count":5}]},{"line":"          { public_input : 'f; evals : 'f_multi Evals.Stable.V2.t }","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"        [@@deriving sexp, compare, yojson, hash, equal, hlist]","counters":[{"col_start":61,"col_end":61,"count":3}]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    module In_circuit = struct","counters":[]},{"line":"      type ('f, 'f_multi, 'bool) t =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { public_input : 'f; evals : ('f_multi, 'bool) Evals.In_circuit.t }","counters":[]},{"line":"      [@@deriving hlist]","counters":[]},{"line":"","counters":[]},{"line":"      let factor (type f f_multi bool)","counters":[]},{"line":"          ({ public_input = p1, p2; evals } : (f * f, f_multi * f_multi, bool) t)","counters":[]},{"line":"          : (f, f_multi, bool) t Tuple_lib.Double.t =","counters":[]},{"line":"        ( { evals = Evals.In_circuit.map ~f:fst evals; public_input = p1 }","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"        , { evals = Evals.In_circuit.map ~f:snd evals; public_input = p2 } )","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    let map (type a1 a2 b1 b2) (t : (a1, a2) t) ~(f1 : a1 -> b1) ~(f2 : a2 -> b2)","counters":[]},{"line":"        : (b1, b2) t =","counters":[]},{"line":"      { public_input = f1 t.public_input; evals = Evals.map ~f:f2 t.evals }","counters":[{"col_start":6,"col_end":6,"count":1},{"col_start":24,"col_end":24,"count":1},{"col_start":58,"col_end":58,"count":1}]},{"line":"","counters":[]},{"line":"    let typ impl lookup_config f f_multi ~dummy =","counters":[]},{"line":"      let evals = Evals.typ impl f_multi lookup_config ~dummy in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let open Snarky_backendless.Typ in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      of_hlistable [ f; evals ] ~var_to_hlist:In_circuit.to_hlist","counters":[]},{"line":"        ~var_of_hlist:In_circuit.of_hlist ~value_to_hlist:to_hlist","counters":[]},{"line":"        ~value_of_hlist:of_hlist","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  [@@@warning \"-4\"]","counters":[]},{"line":"","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type ('f, 'f_multi) t =","counters":[{"col_start":6,"col_end":6,"count":7},{"col_start":26,"col_end":26,"count":5}]},{"line":"        { evals : ('f * 'f, 'f_multi * 'f_multi) With_public_input.Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":14,"col_end":14,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":46,"col_end":46,"count":0},{"col_start":49,"col_end":49,"count":0},{"col_start":77,"col_end":77,"count":0}]},{"line":"        ; ft_eval1 : 'f","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"        }","counters":[]},{"line":"      [@@deriving sexp, compare, yojson, hash, equal, hlist]","counters":[{"col_start":59,"col_end":59,"count":3}]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  module In_circuit = struct","counters":[]},{"line":"    type ('f, 'f_multi, 'bool) t =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      { evals :","counters":[]},{"line":"          ('f * 'f, 'f_multi * 'f_multi, 'bool) With_public_input.In_circuit.t","counters":[]},{"line":"      ; ft_eval1 : 'f","counters":[]},{"line":"      }","counters":[]},{"line":"    [@@deriving hlist]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let map (type a1 a2 b1 b2) (t : (a1, a2) t) ~(f1 : a1 -> b1) ~(f2 : a2 -> b2)","counters":[]},{"line":"      : (b1, b2) t =","counters":[]},{"line":"    { evals =","counters":[{"col_start":4,"col_end":4,"count":1}]},{"line":"        With_public_input.map t.evals","counters":[{"col_start":28,"col_end":28,"count":1}]},{"line":"          ~f1:(Tuple_lib.Double.map ~f:f1)","counters":[]},{"line":"          ~f2:(Tuple_lib.Double.map ~f:f2)","counters":[]},{"line":"    ; ft_eval1 = f1 t.ft_eval1","counters":[{"col_start":18,"col_end":18,"count":1}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let typ (type f)","counters":[]},{"line":"      (module Impl : Snarky_backendless.Snark_intf.Run with type field = f)","counters":[]},{"line":"      lookup_config =","counters":[]},{"line":"    let open Impl.Typ in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let single = array ~length:1 field in","counters":[]},{"line":"    let evals =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      With_public_input.typ","counters":[]},{"line":"        (module Impl)","counters":[]},{"line":"        lookup_config (tuple2 field field) (tuple2 single single)","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"        ~dummy:Impl.Field.Constant.([| zero |], [| zero |])","counters":[]},{"line":"    in","counters":[]},{"line":"    of_hlistable [ evals; Impl.Field.typ ] ~var_to_hlist:In_circuit.to_hlist","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ~var_of_hlist:In_circuit.of_hlist ~value_to_hlist:to_hlist","counters":[]},{"line":"      ~value_of_hlist:of_hlist","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Openings = struct","counters":[]},{"line":"  [@@@warning \"-4\"] (* Deals with the 2 sexp-deriving types below *)","counters":[]},{"line":"","counters":[]},{"line":"  module Bulletproof = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type ('g, 'fq) t =","counters":[{"col_start":8,"col_end":8,"count":13},{"col_start":23,"col_end":23,"count":5}]},{"line":"          { lr : ('g * 'g) array","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"          ; z_1 : 'fq","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":14,"col_end":14,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":20,"col_end":20,"count":0}]},{"line":"          ; z_2 : 'fq","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":14,"col_end":14,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":20,"col_end":20,"count":0}]},{"line":"          ; delta : 'g","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"          ; challenge_polynomial_commitment : 'g","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":42,"col_end":42,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"          }","counters":[]},{"line":"        [@@deriving sexp, compare, yojson, hash, equal, hlist]","counters":[{"col_start":61,"col_end":61,"count":3}]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    let typ fq g ~length =","counters":[]},{"line":"      let open Snarky_backendless.Typ in","counters":[{"col_start":6,"col_end":6,"count":1}]},{"line":"      of_hlistable","counters":[]},{"line":"        [ array ~length (g * g); fq; fq; g; g ]","counters":[{"col_start":14,"col_end":14,"count":1}]},{"line":"        ~var_to_hlist:to_hlist ~var_of_hlist:of_hlist ~value_to_hlist:to_hlist","counters":[]},{"line":"        ~value_of_hlist:of_hlist","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V2 = struct","counters":[]},{"line":"      type ('g, 'fq, 'fqv) t =","counters":[{"col_start":6,"col_end":6,"count":9},{"col_start":27,"col_end":27,"count":6}]},{"line":"        { proof : ('g, 'fq) Bulletproof.Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":14,"col_end":14,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"        ; evals : ('fqv * 'fqv) Evals.Stable.V2.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":14,"col_end":14,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"        ; ft_eval1 : 'fq","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"        }","counters":[]},{"line":"      [@@deriving sexp, compare, yojson, hash, equal, hlist]","counters":[{"col_start":59,"col_end":59,"count":3}]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Poly_comm = struct","counters":[]},{"line":"  module With_degree_bound = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type 'g_opt t = { unshifted : 'g_opt array; shifted : 'g_opt }","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":20,"col_end":20,"count":4},{"col_start":26,"col_end":26,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":49,"col_end":49,"count":0},{"col_start":52,"col_end":52,"count":0},{"col_start":58,"col_end":58,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"        [@@deriving sexp, compare, yojson, hlist, hash, equal]","counters":[{"col_start":61,"col_end":61,"count":1}]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    let padded_array_typ0 = padded_array_typ","counters":[]},{"line":"","counters":[]},{"line":"    let typ (type f g g_var bool_var)","counters":[]},{"line":"        (g : (g_var, g, f) Snarky_backendless.Typ.t) ~length","counters":[]},{"line":"        ~dummy_group_element","counters":[]},{"line":"        ~(bool : (bool_var, bool, f) Snarky_backendless.Typ.t) :","counters":[]},{"line":"        ((bool_var * g_var) t, g Or_infinity.t t, f) Snarky_backendless.Typ.t =","counters":[]},{"line":"      let open Snarky_backendless.Typ in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let g_inf =","counters":[]},{"line":"        transport (tuple2 bool g)","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"          ~there:(function","counters":[]},{"line":"            | Or_infinity.Infinity ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (false, dummy_group_element)","counters":[]},{"line":"            | Finite x ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (true, x) )","counters":[]},{"line":"          ~back:(fun (b, x) -> if b then Infinity else Finite x)","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"      in","counters":[]},{"line":"      let arr = padded_array_typ0 ~length ~dummy:Or_infinity.Infinity g_inf in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      of_hlistable [ arr; g_inf ] ~var_to_hlist:to_hlist ~var_of_hlist:of_hlist","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ~value_to_hlist:to_hlist ~value_of_hlist:of_hlist","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Without_degree_bound = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type 'g t = 'g array [@@deriving sexp, compare, yojson, hash, equal]","counters":[{"col_start":8,"col_end":8,"count":38},{"col_start":13,"col_end":13,"count":0},{"col_start":16,"col_end":16,"count":3},{"col_start":20,"col_end":20,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":75,"col_end":75,"count":9}]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Messages = struct","counters":[]},{"line":"  open Poly_comm","counters":[]},{"line":"","counters":[]},{"line":"  module Poly = struct","counters":[]},{"line":"    type ('w, 'z, 't) t = { w : 'w; z : 'z; t : 't }","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"    [@@deriving sexp, compare, yojson, fields, hash, equal, hlist]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Lookup = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type 'g t = { sorted : 'g array; aggreg : 'g; runtime : 'g option }","counters":[{"col_start":8,"col_end":8,"count":1},{"col_start":16,"col_end":16,"count":4},{"col_start":22,"col_end":22,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":46,"col_end":46,"count":0},{"col_start":50,"col_end":50,"count":0},{"col_start":51,"col_end":51,"count":0},{"col_start":54,"col_end":54,"count":0},{"col_start":60,"col_end":60,"count":0},{"col_start":64,"col_end":64,"count":0},{"col_start":65,"col_end":65,"count":0},{"col_start":72,"col_end":72,"count":0}]},{"line":"        [@@deriving fields, sexp, compare, yojson, hash, equal, hlist]","counters":[{"col_start":69,"col_end":69,"count":3}]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    module In_circuit = struct","counters":[]},{"line":"      type ('g, 'bool) t =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { sorted : 'g array; aggreg : 'g; runtime : ('g, 'bool) Opt.t }","counters":[]},{"line":"      [@@deriving hlist]","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    let sorted_length = 5","counters":[]},{"line":"","counters":[]},{"line":"    let dummy ~runtime z =","counters":[]},{"line":"      { aggreg = z","counters":[{"col_start":6,"col_end":6,"count":1}]},{"line":"      ; sorted = Array.create ~len:sorted_length z","counters":[{"col_start":28,"col_end":28,"count":1}]},{"line":"      ; runtime = Option.some_if runtime z","counters":[{"col_start":31,"col_end":31,"count":1}]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    let typ bool_typ e ~runtime ~dummy =","counters":[]},{"line":"      Snarky_backendless.Typ.of_hlistable","counters":[{"col_start":6,"col_end":6,"count":1}]},{"line":"        [ Snarky_backendless.Typ.array ~length:sorted_length e","counters":[{"col_start":37,"col_end":37,"count":1}]},{"line":"        ; e","counters":[]},{"line":"        ; Opt.typ bool_typ runtime e ~dummy","counters":[{"col_start":16,"col_end":16,"count":1}]},{"line":"        ]","counters":[]},{"line":"        ~value_to_hlist:to_hlist ~value_of_hlist:of_hlist","counters":[]},{"line":"        ~var_to_hlist:In_circuit.to_hlist ~var_of_hlist:In_circuit.of_hlist","counters":[]},{"line":"","counters":[]},{"line":"    let opt_typ bool_typ ~(lookup : Opt.Flag.t) ~(runtime : Opt.Flag.t) ~dummy:z","counters":[]},{"line":"        elt =","counters":[]},{"line":"      Opt.typ bool_typ lookup","counters":[{"col_start":6,"col_end":6,"count":1}]},{"line":"        ~dummy:(dummy z ~runtime:Opt.Flag.(equal runtime Yes))","counters":[{"col_start":20,"col_end":20,"count":1},{"col_start":47,"col_end":47,"count":1}]},{"line":"        (typ bool_typ ~runtime ~dummy:z elt)","counters":[{"col_start":11,"col_end":11,"count":1}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V2 = struct","counters":[]},{"line":"      type 'g t =","counters":[{"col_start":6,"col_end":6,"count":11},{"col_start":14,"col_end":14,"count":4}]},{"line":"        { w_comm : 'g Without_degree_bound.Stable.V1.t Columns_vec.Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":55,"col_end":55,"count":0},{"col_start":77,"col_end":77,"count":0}]},{"line":"        ; z_comm : 'g Without_degree_bound.Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"        ; t_comm : 'g Without_degree_bound.Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"        ; lookup : 'g Without_degree_bound.Stable.V1.t Lookup.Stable.V1.t option","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":55,"col_end":55,"count":0},{"col_start":72,"col_end":72,"count":0},{"col_start":79,"col_end":79,"count":0}]},{"line":"        }","counters":[]},{"line":"      [@@deriving sexp, compare, yojson, fields, hash, equal, hlist]","counters":[{"col_start":67,"col_end":67,"count":3}]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  module In_circuit = struct","counters":[]},{"line":"    type ('g, 'bool) t =","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"      { w_comm : 'g Without_degree_bound.t Columns_vec.t","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      ; z_comm : 'g Without_degree_bound.t","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      ; t_comm : 'g Without_degree_bound.t","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      ; lookup :","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (('g Without_degree_bound.t, 'bool) Lookup.In_circuit.t, 'bool) Opt.t","counters":[]},{"line":"      }","counters":[]},{"line":"    [@@deriving hlist, fields]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let typ (type n f)","counters":[]},{"line":"      (module Impl : Snarky_backendless.Snark_intf.Run with type field = f) g","counters":[]},{"line":"      ({ lookup; runtime } : Lookup_config.t) ~dummy","counters":[]},{"line":"      ~(commitment_lengths : (((int, n) Vector.t as 'v), int, int) Poly.t) ~bool","counters":[]},{"line":"      =","counters":[]},{"line":"    let open Snarky_backendless.Typ in","counters":[{"col_start":4,"col_end":4,"count":1}]},{"line":"    let { Poly.w = w_lens; z; t } = commitment_lengths in","counters":[]},{"line":"    let array ~length elt = padded_array_typ ~dummy ~length elt in","counters":[{"col_start":28,"col_end":28,"count":4}]},{"line":"    let wo n = array ~length:(Vector.reduce_exn n ~f:Int.max) g in","counters":[{"col_start":15,"col_end":15,"count":4},{"col_start":46,"col_end":46,"count":4}]},{"line":"    let _w n =","counters":[]},{"line":"      With_degree_bound.typ g","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ~length:(Vector.reduce_exn n ~f:Int.max)","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"        ~dummy_group_element:dummy ~bool","counters":[]},{"line":"    in","counters":[]},{"line":"    let lookup =","counters":[]},{"line":"      Lookup.opt_typ Impl.Boolean.typ ~lookup ~runtime ~dummy:[| dummy |]","counters":[]},{"line":"        (wo [ 1 ])","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"    in","counters":[]},{"line":"    of_hlistable","counters":[{"col_start":4,"col_end":4,"count":1}]},{"line":"      [ Vector.typ (wo w_lens) Columns.n; wo [ z ]; wo [ t ]; lookup ]","counters":[{"col_start":17,"col_end":17,"count":1},{"col_start":21,"col_end":21,"count":1},{"col_start":43,"col_end":43,"count":1},{"col_start":53,"col_end":53,"count":1}]},{"line":"      ~var_to_hlist:In_circuit.to_hlist ~var_of_hlist:In_circuit.of_hlist","counters":[]},{"line":"      ~value_to_hlist:to_hlist ~value_of_hlist:of_hlist","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Proof = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V2 = struct","counters":[]},{"line":"      type ('g, 'fq, 'fqv) t =","counters":[{"col_start":6,"col_end":6,"count":8},{"col_start":27,"col_end":27,"count":6}]},{"line":"        { messages : 'g Messages.Stable.V2.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"        ; openings : ('g, 'fq, 'fqv) Openings.Stable.V2.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"        }","counters":[]},{"line":"      [@@deriving sexp, compare, yojson, hash, equal]","counters":[{"col_start":52,"col_end":52,"count":5}]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Shifts = struct","counters":[]},{"line":"  open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V2 = struct","counters":[]},{"line":"      type 'field t = 'field array [@@deriving sexp, compare, yojson, equal]","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":11,"col_end":11,"count":0},{"col_start":18,"col_end":18,"count":3},{"col_start":22,"col_end":22,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":75,"col_end":75,"count":1}]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}