{"filename":"src/lib/mina_base/signed_command.ml","lines":[{"line":"[%%import \"/src/config.mlh\"]","counters":[]},{"line":"","counters":[{"col_start":0,"col_end":0,"count":1}]},{"line":"open Core_kernel","counters":[]},{"line":"open Mina_base_import","counters":[]},{"line":"open Mina_numbers","counters":[]},{"line":"","counters":[]},{"line":"(** See documentation of the {!Mina_wire_types} library *)","counters":[]},{"line":"module Wire_types = Mina_wire_types.Mina_base.Signed_command","counters":[]},{"line":"","counters":[]},{"line":"module Make_sig (A : Wire_types.Types.S) = struct","counters":[]},{"line":"  module type S =","counters":[]},{"line":"    Signed_command_intf.Full","counters":[]},{"line":"      with type With_valid_signature.Stable.Latest.t =","counters":[]},{"line":"        A.With_valid_signature.V2.t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make_str (_ : Wire_types.Concrete) = struct","counters":[]},{"line":"  module Fee = Currency.Fee","counters":[]},{"line":"  module Payload = Signed_command_payload","counters":[]},{"line":"","counters":[]},{"line":"  module Poly = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        [@@@with_all_version_tags]","counters":[]},{"line":"","counters":[]},{"line":"        type ('payload, 'pk, 'signature) t =","counters":[{"col_start":8,"col_end":8,"count":6},{"col_start":41,"col_end":41,"count":12}]},{"line":"              ( 'payload","counters":[]},{"line":"              , 'pk","counters":[]},{"line":"              , 'signature )","counters":[]},{"line":"              Mina_wire_types.Mina_base.Signed_command.Poly.V1.t =","counters":[]},{"line":"          { payload : 'payload; signer : 'pk; signature : 'signature }","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":43,"col_end":43,"count":0},{"col_start":46,"col_end":46,"count":0},{"col_start":54,"col_end":54,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"        [@@deriving compare, sexp, hash, yojson, equal]","counters":[{"col_start":54,"col_end":54,"count":18}]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"    [@@@with_top_version_tag]","counters":[]},{"line":"","counters":[]},{"line":"    (* DO NOT DELETE VERSIONS!","counters":[]},{"line":"       so we can always get transaction hashes from old transaction ids","counters":[]},{"line":"       the version linter should be checking this","counters":[]},{"line":"","counters":[]},{"line":"       IF YOU CREATE A NEW VERSION:","counters":[]},{"line":"       update Transaction_hash.hash_of_transaction_id to handle it","counters":[]},{"line":"       add hash_signed_command_vn for that version","counters":[]},{"line":"    *)","counters":[]},{"line":"","counters":[]},{"line":"    module V2 = struct","counters":[]},{"line":"      type t =","counters":[{"col_start":6,"col_end":6,"count":4},{"col_start":11,"col_end":11,"count":1}]},{"line":"        ( Payload.Stable.V2.t","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":10,"col_end":10,"count":0}]},{"line":"        , Public_key.Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        , Signature.Stable.V1.t )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        Poly.Stable.V1.t","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      [@@deriving compare, sexp, hash, yojson]","counters":[{"col_start":45,"col_end":45,"count":16}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"      module T = struct","counters":[]},{"line":"        (* can't use nonrec + deriving *)","counters":[]},{"line":"        type typ = t [@@deriving compare, sexp, hash]","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"        type t = typ [@@deriving compare, sexp, hash]","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      include Comparable.Make (T)","counters":[]},{"line":"      include Hashable.Make (T)","counters":[]},{"line":"","counters":[]},{"line":"      let accounts_accessed ({ payload; _ } : t) status =","counters":[]},{"line":"        Payload.accounts_accessed payload status","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      let accounts_referenced (t : t) = accounts_accessed t Applied","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      [@@@with_all_version_tags]","counters":[]},{"line":"","counters":[]},{"line":"      type t =","counters":[{"col_start":6,"col_end":6,"count":6},{"col_start":11,"col_end":11,"count":2}]},{"line":"        ( Payload.Stable.V1.t","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":10,"col_end":10,"count":0}]},{"line":"        , Public_key.Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        , Signature.Stable.V1.t )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        Poly.Stable.V1.t","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      [@@deriving compare, sexp, hash, yojson]","counters":[{"col_start":45,"col_end":45,"count":26}]},{"line":"","counters":[]},{"line":"      (* don't need to coerce old commands to new ones *)","counters":[]},{"line":"      let to_latest _ = failwith \"Not implemented\"","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"    end","counters":[]},{"line":"  end]","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  (* type of signed commands, pre-Berkeley hard fork *)","counters":[]},{"line":"  type t_v1 = Stable.V1.t","counters":[]},{"line":"","counters":[]},{"line":"  type _unused = unit","counters":[]},{"line":"    constraint (Payload.t, Public_key.t, Signature.t) Poly.t = t","counters":[]},{"line":"","counters":[]},{"line":"  include (Stable.Latest : module type of Stable.Latest with type t := t)","counters":[]},{"line":"","counters":[]},{"line":"  let payload Poly.{ payload; _ } = payload","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"","counters":[]},{"line":"  let fee = Fn.compose Payload.fee payload","counters":[{"col_start":21,"col_end":21,"count":1}]},{"line":"","counters":[]},{"line":"  let nonce = Fn.compose Payload.nonce payload","counters":[{"col_start":23,"col_end":23,"count":1}]},{"line":"","counters":[]},{"line":"  (* for filtering *)","counters":[]},{"line":"  let minimum_fee = Mina_compile_config.minimum_user_command_fee","counters":[]},{"line":"","counters":[]},{"line":"  let has_insufficient_fee t = Currency.Fee.(fee t < minimum_fee)","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"","counters":[]},{"line":"  let signer { Poly.signer; _ } = signer","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"","counters":[]},{"line":"  let fee_token (_ : t) = Token_id.default","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"","counters":[]},{"line":"  let fee_payer_pk ({ payload; _ } : t) = Payload.fee_payer_pk payload","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"","counters":[]},{"line":"  let fee_payer ({ payload; _ } : t) = Payload.fee_payer payload","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"  let fee_excess ({ payload; _ } : t) = Payload.fee_excess payload","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"  let token ({ payload; _ } : t) = Payload.token payload","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"  let source_pk ({ payload; _ } : t) = Payload.source_pk payload","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"  let source ({ payload; _ } : t) = Payload.source payload","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"","counters":[]},{"line":"  let receiver_pk ({ payload; _ } : t) = Payload.receiver_pk payload","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"","counters":[]},{"line":"  let receiver ({ payload; _ } : t) = Payload.receiver payload","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"","counters":[]},{"line":"  let amount = Fn.compose Payload.amount payload","counters":[{"col_start":24,"col_end":24,"count":1}]},{"line":"","counters":[]},{"line":"  let memo = Fn.compose Payload.memo payload","counters":[{"col_start":22,"col_end":22,"count":1}]},{"line":"","counters":[]},{"line":"  let valid_until = Fn.compose Payload.valid_until payload","counters":[{"col_start":29,"col_end":29,"count":1}]},{"line":"","counters":[]},{"line":"  let tag ({ payload; _ } : t) = Payload.tag payload","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"","counters":[]},{"line":"  let tag_string (t : t) =","counters":[]},{"line":"    match t.payload.body with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Payment _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        \"payment\"","counters":[]},{"line":"    | Stake_delegation _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        \"delegation\"","counters":[]},{"line":"","counters":[]},{"line":"  let to_input_legacy (payload : Payload.t) =","counters":[]},{"line":"    Transaction_union_payload.(","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      to_input_legacy (of_user_command_payload payload))","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"","counters":[]},{"line":"  let sign_payload ?signature_kind (private_key : Signature_lib.Private_key.t)","counters":[]},{"line":"      (payload : Payload.t) : Signature.t =","counters":[]},{"line":"    Signature_lib.Schnorr.Legacy.sign ?signature_kind private_key","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (to_input_legacy payload)","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"","counters":[]},{"line":"  let sign ?signature_kind (kp : Signature_keypair.t) (payload : Payload.t) : t","counters":[]},{"line":"      =","counters":[]},{"line":"    { payload","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    ; signer = kp.public_key","counters":[]},{"line":"    ; signature = sign_payload ?signature_kind kp.private_key payload","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  module For_tests = struct","counters":[]},{"line":"    (* Pretend to sign a command. Much faster than actually signing. *)","counters":[]},{"line":"    let fake_sign ?signature_kind:_ (kp : Signature_keypair.t)","counters":[]},{"line":"        (payload : Payload.t) : t =","counters":[]},{"line":"      { payload; signer = kp.public_key; signature = Signature.dummy }","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Gen = struct","counters":[]},{"line":"    let gen_inner (sign' : Signature_lib.Keypair.t -> Payload.t -> t) ~key_gen","counters":[]},{"line":"        ?(nonce = Account_nonce.zero) ~fee_range create_body =","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"      let open Quickcheck.Generator.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let min_fee = Fee.to_int Mina_compile_config.minimum_user_command_fee in","counters":[]},{"line":"      let max_fee = min_fee + fee_range in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%bind (signer : Signature_keypair.t), (receiver : Signature_keypair.t)","counters":[]},{"line":"          =","counters":[]},{"line":"        key_gen","counters":[]},{"line":"      and fee = Int.gen_incl min_fee max_fee >>| Currency.Fee.of_int","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"      and memo = String.quickcheck_generator in","counters":[]},{"line":"      let%map body = create_body signer receiver in","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"      let payload : Payload.t =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Payload.create ~fee","counters":[]},{"line":"          ~fee_payer_pk:(Public_key.compress signer.public_key)","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"          ~nonce ~valid_until:None","counters":[]},{"line":"          ~memo:(Signed_command_memo.create_by_digesting_string_exn memo)","counters":[{"col_start":66,"col_end":66,"count":0}]},{"line":"          ~body","counters":[]},{"line":"      in","counters":[]},{"line":"      sign' signer payload","counters":[]},{"line":"","counters":[]},{"line":"    let with_random_participants ~keys ~gen =","counters":[]},{"line":"      let key_gen = Quickcheck_lib.gen_pair @@ Quickcheck_lib.of_array keys in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"      gen ~key_gen","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    module Payment = struct","counters":[]},{"line":"      let gen_inner (sign' : Signature_lib.Keypair.t -> Payload.t -> t) ~key_gen","counters":[]},{"line":"          ?nonce ?(min_amount = 1) ~max_amount ~fee_range () =","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"        gen_inner sign' ~key_gen ?nonce ~fee_range","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        @@ fun { public_key = signer; _ } { public_key = receiver; _ } ->","counters":[]},{"line":"        let open Quickcheck.Generator.Let_syntax in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let%map amount =","counters":[]},{"line":"          Int.gen_incl min_amount max_amount >>| Currency.Amount.of_int","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"        in","counters":[]},{"line":"        Signed_command_payload.Body.Payment","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          { receiver_pk = Public_key.compress receiver","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"          ; source_pk = Public_key.compress signer","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"          ; amount","counters":[]},{"line":"          }","counters":[]},{"line":"","counters":[]},{"line":"      let gen ?(sign_type = `Fake) =","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"        match sign_type with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | `Fake ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            gen_inner For_tests.fake_sign","counters":[]},{"line":"        | `Real ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            gen_inner sign","counters":[]},{"line":"","counters":[]},{"line":"      let gen_with_random_participants ?sign_type ~keys ?nonce ?min_amount","counters":[]},{"line":"          ~max_amount ~fee_range =","counters":[]},{"line":"        with_random_participants ~keys ~gen:(fun ~key_gen ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            gen ?sign_type ~key_gen ?nonce ?min_amount ~max_amount ~fee_range )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Stake_delegation = struct","counters":[]},{"line":"      let gen ~key_gen ?nonce ~fee_range () =","counters":[]},{"line":"        gen_inner For_tests.fake_sign ~key_gen ?nonce ~fee_range","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (fun { public_key = signer; _ } { public_key = new_delegate; _ } ->","counters":[]},{"line":"            Quickcheck.Generator.return","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            @@ Signed_command_payload.Body.Stake_delegation","counters":[]},{"line":"                 (Set_delegate","counters":[]},{"line":"                    { delegator = Public_key.compress signer","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"                    ; new_delegate = Public_key.compress new_delegate","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"                    } ) )","counters":[]},{"line":"","counters":[]},{"line":"      let gen_with_random_participants ~keys ?nonce ~fee_range =","counters":[]},{"line":"        with_random_participants ~keys ~gen:(gen ?nonce ~fee_range)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    let payment = Payment.gen","counters":[]},{"line":"","counters":[]},{"line":"    let payment_with_random_participants = Payment.gen_with_random_participants","counters":[]},{"line":"","counters":[]},{"line":"    let stake_delegation = Stake_delegation.gen","counters":[]},{"line":"","counters":[]},{"line":"    let stake_delegation_with_random_participants =","counters":[]},{"line":"      Stake_delegation.gen_with_random_participants","counters":[]},{"line":"","counters":[]},{"line":"    let sequence :","counters":[]},{"line":"           ?length:int","counters":[]},{"line":"        -> ?sign_type:[ `Fake | `Real ]","counters":[]},{"line":"        -> ( Signature_lib.Keypair.t","counters":[]},{"line":"           * Currency.Amount.t","counters":[]},{"line":"           * Mina_numbers.Account_nonce.t","counters":[]},{"line":"           * Account_timing.t )","counters":[]},{"line":"           array","counters":[]},{"line":"        -> t list Quickcheck.Generator.t =","counters":[]},{"line":"     fun ?length ?(sign_type = `Fake) account_info ->","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"      let open Quickcheck.Generator in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"      let%bind n_commands =","counters":[]},{"line":"        Option.value_map length ~default:small_non_negative_int ~f:return","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"      in","counters":[]},{"line":"      if Int.(n_commands = 0) then return []","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"      else","counters":[]},{"line":"        let n_accounts = Array.length account_info in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let%bind command_senders, currency_splits =","counters":[]},{"line":"          (* How many commands will be issued from each account? *)","counters":[]},{"line":"          (let%bind command_splits =","counters":[]},{"line":"             Quickcheck_lib.gen_division n_commands n_accounts","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"           in","counters":[]},{"line":"           let command_splits' = Array.of_list command_splits in","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"           (* List of payment senders in the final order. *)","counters":[]},{"line":"           let%bind command_senders =","counters":[]},{"line":"             Quickcheck_lib.shuffle","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"             @@ List.concat_mapi command_splits ~f:(fun idx cmds ->","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                    List.init cmds ~f:(Fn.const idx) )","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"           in","counters":[]},{"line":"           (* within the accounts, how will the currency be split into separate","counters":[]},{"line":"              payments? *)","counters":[]},{"line":"           let%bind currency_splits =","counters":[]},{"line":"             Quickcheck_lib.init_gen_array","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"               ~f:(fun i ->","counters":[]},{"line":"                 let%bind spend_all = bool in","counters":[]},{"line":"                 let _, balance, _, _ = account_info.(i) in","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                 let amount_to_spend =","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                   if spend_all then balance","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                   else","counters":[]},{"line":"                     Currency.Amount.of_int (Currency.Amount.to_int balance / 2)","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":42,"col_end":42,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"                 in","counters":[]},{"line":"                 Quickcheck_lib.gen_division_currency amount_to_spend","counters":[]},{"line":"                   command_splits'.(i) )","counters":[]},{"line":"               n_accounts","counters":[]},{"line":"           in","counters":[]},{"line":"           return (command_senders, currency_splits) )","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"          |> (* We need to ensure each command has enough currency for a fee of 2","counters":[]},{"line":"                or more, so it'll be enough to buy the requisite transaction","counters":[]},{"line":"                snarks. It's important that the backtracking from filter goes and","counters":[]},{"line":"                redraws command_splits as well as currency_splits, so we don't get","counters":[]},{"line":"                stuck in a situation where it's very unlikely for the predicate to","counters":[]},{"line":"                pass. *)","counters":[]},{"line":"          Quickcheck.Generator.filter ~f:(fun (_, splits) ->","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"              Array.for_all splits ~f:(fun split ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                  List.for_all split ~f:(fun amt ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                      Currency.Amount.(amt >= of_int 2_000_000_000) ) ) )","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"        in","counters":[]},{"line":"        let account_nonces =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Array.map ~f:(fun (_, _, nonce, _) -> nonce) account_info","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"        in","counters":[]},{"line":"        let uncons_exn = function","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          | [] ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              failwith \"uncons_exn\"","counters":[]},{"line":"          | x :: xs ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (x, xs)","counters":[]},{"line":"        in","counters":[]},{"line":"        Quickcheck_lib.map_gens command_senders ~f:(fun sender ->","counters":[]},{"line":"            let this_split, rest_splits = uncons_exn currency_splits.(sender) in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let sender_pk, _, _, _ = account_info.(sender) in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            currency_splits.(sender) <- rest_splits ;","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let nonce = account_nonces.(sender) in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            account_nonces.(sender) <- Account_nonce.succ nonce ;","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"            let%bind fee =","counters":[]},{"line":"              (* use of_string here because json_of_ocaml won't handle","counters":[]},{"line":"                 equivalent integer constants","counters":[]},{"line":"              *)","counters":[]},{"line":"              Currency.Fee.(","counters":[]},{"line":"                gen_incl (of_string \"6000000000\")","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"                  (min (of_string \"10000000000\")","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"                     (Currency.Amount.to_fee this_split) ))","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"            in","counters":[]},{"line":"            let amount =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Option.value_exn Currency.Amount.(this_split - of_fee fee)","counters":[{"col_start":66,"col_end":66,"count":0}]},{"line":"            in","counters":[]},{"line":"            let%bind receiver =","counters":[]},{"line":"              map ~f:(fun idx ->","counters":[]},{"line":"                  let kp, _, _, _ = account_info.(idx) in","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  Public_key.compress kp.public_key )","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"              @@ Int.gen_uniform_incl 0 (n_accounts - 1)","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"            in","counters":[]},{"line":"            let memo = Signed_command_memo.dummy in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let payload =","counters":[]},{"line":"              let sender_pk = Public_key.compress sender_pk.public_key in","counters":[]},{"line":"              Payload.create ~fee ~fee_payer_pk:sender_pk ~valid_until:None","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ~nonce ~memo","counters":[]},{"line":"                ~body:","counters":[]},{"line":"                  (Payment","counters":[]},{"line":"                     { source_pk = sender_pk; receiver_pk = receiver; amount }","counters":[]},{"line":"                  )","counters":[]},{"line":"            in","counters":[]},{"line":"            let sign' =","counters":[]},{"line":"              match sign_type with","counters":[]},{"line":"              | `Fake ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  For_tests.fake_sign","counters":[]},{"line":"              | `Real ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  sign","counters":[]},{"line":"            in","counters":[]},{"line":"            return @@ sign' sender_pk payload )","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module With_valid_signature = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V2 = struct","counters":[]},{"line":"        type t = Stable.V2.t [@@deriving sexp, equal, yojson, hash]","counters":[{"col_start":8,"col_end":8,"count":2},{"col_start":13,"col_end":13,"count":1},{"col_start":17,"col_end":17,"count":0},{"col_start":66,"col_end":66,"count":5}]},{"line":"","counters":[]},{"line":"        let to_latest = Stable.V2.to_latest","counters":[]},{"line":"","counters":[]},{"line":"        let compare = Stable.V2.compare","counters":[]},{"line":"","counters":[]},{"line":"        let equal = Stable.V2.equal","counters":[]},{"line":"","counters":[]},{"line":"        module Gen = Gen","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    module Gen = Stable.Latest.Gen","counters":[]},{"line":"    include Comparable.Make (Stable.Latest)","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let to_valid_unsafe t =","counters":[]},{"line":"    `If_this_is_used_it_should_have_a_comment_justifying_it t","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  (* so we can deserialize Base58Check transaction ids created before Berkeley hard fork *)","counters":[]},{"line":"  module V1_all_tagged = struct","counters":[]},{"line":"    include Stable.V1.With_all_version_tags","counters":[]},{"line":"","counters":[]},{"line":"    let description = \"Signed command\"","counters":[]},{"line":"","counters":[]},{"line":"    let version_byte = Base58_check.Version_bytes.signed_command_v1","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Base58_check_v1 = Codable.Make_base58_check (V1_all_tagged)","counters":[]},{"line":"","counters":[]},{"line":"  let of_base58_check_exn_v1 = Base58_check_v1.of_base58_check","counters":[]},{"line":"","counters":[]},{"line":"  (* give transaction ids have version tag *)","counters":[]},{"line":"  include Codable.Make_base64 (Stable.Latest.With_top_version_tag)","counters":[]},{"line":"","counters":[]},{"line":"  let check_signature ?signature_kind ({ payload; signer; signature } : t) =","counters":[]},{"line":"    Signature_lib.Schnorr.Legacy.verify ?signature_kind signature","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (Snark_params.Tick.Inner_curve.of_affine signer)","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"      (to_input_legacy payload)","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"","counters":[]},{"line":"  let public_keys t =","counters":[]},{"line":"    let fee_payer = fee_payer_pk t in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let source = source_pk t in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let receiver = receiver_pk t in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    [ fee_payer; source; receiver ]","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let check_valid_keys t =","counters":[]},{"line":"    List.for_all (public_keys t) ~f:(fun pk ->","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"        Option.is_some (Public_key.decompress pk) )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"  let create_with_signature_checked ?signature_kind signature signer payload =","counters":[]},{"line":"    let open Option.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let%bind signer = Public_key.decompress signer in","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"    let t = Poly.{ payload; signature; signer } in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Option.some_if (check_signature ?signature_kind t && check_valid_keys t) t","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":57,"col_end":57,"count":0},{"col_start":72,"col_end":72,"count":0}]},{"line":"","counters":[]},{"line":"  let gen_test =","counters":[]},{"line":"    let open Quickcheck.Let_syntax in","counters":[]},{"line":"    let%bind keys =","counters":[]},{"line":"      Quickcheck.Generator.list_with_length 2 Signature_keypair.gen","counters":[{"col_start":42,"col_end":42,"count":1}]},{"line":"    in","counters":[]},{"line":"    Gen.payment_with_random_participants ~sign_type:`Real","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ~keys:(Array.of_list keys) ~max_amount:10000 ~fee_range:1000 ()","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"  let%test_unit \"completeness\" =","counters":[]},{"line":"    Quickcheck.test ~trials:20 gen_test ~f:(fun t -> assert (check_signature t))","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":60,"col_end":60,"count":0},{"col_start":75,"col_end":75,"count":0}]},{"line":"","counters":[]},{"line":"  let%test_unit \"json\" =","counters":[]},{"line":"    Quickcheck.test ~trials:20 ~sexp_of:sexp_of_t gen_test ~f:(fun t ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        assert (Codable.For_tests.check_encoding (module Stable.Latest) ~equal t) )","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"","counters":[]},{"line":"  (* return type is `t option` here, interface coerces that to `With_valid_signature.t option` *)","counters":[]},{"line":"  let check t = Option.some_if (check_signature t && check_valid_keys t) t","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":46,"col_end":46,"count":0},{"col_start":53,"col_end":53,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"","counters":[]},{"line":"  (* return type is `t option` here, interface coerces that to `With_valid_signature.t option` *)","counters":[]},{"line":"  let check_only_for_signature t = Option.some_if (check_signature t) t","counters":[{"col_start":35,"col_end":35,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"","counters":[]},{"line":"  let forget_check t = t","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"  let filter_by_participant user_commands public_key =","counters":[]},{"line":"    List.filter user_commands ~f:(fun user_command ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        Core_kernel.List.exists","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (accounts_referenced user_command)","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"          ~f:","counters":[]},{"line":"            (Fn.compose","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"               (Public_key.Compressed.equal public_key)","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"               Account_id.public_key ) )","counters":[]},{"line":"","counters":[]},{"line":"  let%test \"latest signed command version\" =","counters":[]},{"line":"    (* if this test fails, update `Transaction_hash.hash_of_transaction_id`","counters":[]},{"line":"       for latest version, then update this test","counters":[]},{"line":"    *)","counters":[]},{"line":"    Int.equal Stable.Latest.version 2","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"include Wire_types.Make (Make_sig) (Make_str)","counters":[{"col_start":44,"col_end":44,"count":1}]}]}