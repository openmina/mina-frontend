{"filename":"src/lib/logproc_lib/interpolator.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"type mode = Hidden | Inline | After","counters":[]},{"line":"","counters":[]},{"line":"type config =","counters":[]},{"line":"  { mode : mode; max_interpolation_length : int; pretty_print : bool }","counters":[]},{"line":"","counters":[]},{"line":"let rec result_fold_left ls ~init ~f =","counters":[]},{"line":"  match ls with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | [] ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Ok init","counters":[]},{"line":"  | h :: t -> (","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      match f init h with","counters":[]},{"line":"      | Ok init' ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          result_fold_left t ~init:init' ~f","counters":[]},{"line":"      | Error err ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Error err )","counters":[]},{"line":"","counters":[]},{"line":"let parser =","counters":[]},{"line":"  let open Angstrom in","counters":[]},{"line":"  let not_f f x = not (f x) in","counters":[{"col_start":18,"col_end":18,"count":34},{"col_start":23,"col_end":23,"count":34}]},{"line":"  let or_f f g x = f x || g x in","counters":[{"col_start":19,"col_end":19,"count":48},{"col_start":21,"col_end":21,"count":22}]},{"line":"  let is_alpha = function","counters":[]},{"line":"    | 'a' .. 'z' | 'A' .. 'Z' | '_' ->","counters":[{"col_start":6,"col_end":6,"count":24},{"col_start":19,"col_end":19,"count":0},{"col_start":32,"col_end":32,"count":1}]},{"line":"        true","counters":[]},{"line":"    | _ ->","counters":[{"col_start":6,"col_end":6,"count":2}]},{"line":"        false","counters":[]},{"line":"  in","counters":[]},{"line":"  let is_numeric = function '0' .. '9' -> true | _ -> false in","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":49,"col_end":49,"count":2}]},{"line":"  let interpolation =","counters":[]},{"line":"    lift2","counters":[]},{"line":"      (fun c s -> String.of_char c ^ s)","counters":[{"col_start":18,"col_end":18,"count":3},{"col_start":31,"col_end":31,"count":3}]},{"line":"      (char '$' *> commit *> satisfy is_alpha)","counters":[{"col_start":10,"col_end":10,"count":1},{"col_start":17,"col_end":17,"count":1},{"col_start":27,"col_end":27,"count":1},{"col_start":35,"col_end":35,"count":1}]},{"line":"      (take_while (or_f is_alpha is_numeric))","counters":[{"col_start":16,"col_end":16,"count":1},{"col_start":22,"col_end":22,"count":1}]},{"line":"  in","counters":[]},{"line":"  let message =","counters":[{"col_start":2,"col_end":2,"count":1}]},{"line":"    many1","counters":[]},{"line":"      (choice","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"         [ (take_while1 (not_f (Char.equal '$')) >>| fun x -> `Raw x)","counters":[{"col_start":22,"col_end":22,"count":1},{"col_start":29,"col_end":29,"count":1},{"col_start":41,"col_end":41,"count":1},{"col_start":51,"col_end":51,"count":1},{"col_start":62,"col_end":62,"count":3}]},{"line":"         ; (interpolation >>| fun x -> `Interpolate x)","counters":[{"col_start":28,"col_end":28,"count":1},{"col_start":39,"col_end":39,"count":3}]},{"line":"         ] )","counters":[]},{"line":"  in","counters":[]},{"line":"  message <* end_of_input","counters":[{"col_start":2,"col_end":2,"count":1},{"col_start":11,"col_end":11,"count":1}]},{"line":"","counters":[]},{"line":"let parse = Angstrom.parse_string ~consume:All parser","counters":[{"col_start":32,"col_end":32,"count":1}]},{"line":"","counters":[]},{"line":"(* map and concat vs. fold: which is better for strings? *)","counters":[]},{"line":"let render ~max_interpolation_length ~format_json metadata items =","counters":[]},{"line":"  let open Result.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%map msg, extra =","counters":[]},{"line":"    result_fold_left items ~init:(\"\", []) ~f:(fun (msg_acc, extra_acc) el ->","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"        match el with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | `Raw str ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Ok (msg_acc ^ str, extra_acc)","counters":[]},{"line":"        | `Interpolate id ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let%map json =","counters":[]},{"line":"              String.Map.find metadata id","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"              |> Result.of_option ~error:(sprintf \"bad interpolation for %s\" id)","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"            in","counters":[]},{"line":"            let str = format_json json in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            if String.length str > max_interpolation_length then","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"              (msg_acc ^ \"$\" ^ id, (id, str) :: extra_acc)","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"            else (msg_acc ^ str, extra_acc) )","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"  in","counters":[]},{"line":"  (msg, List.rev extra)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"","counters":[]},{"line":"let interpolate { mode; max_interpolation_length; pretty_print } msg metadata =","counters":[]},{"line":"  let open Result.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let format_json =","counters":[]},{"line":"    if pretty_print then Yojson.Safe.pretty_to_string","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"    else Yojson.Safe.to_string ?buf:None ?len:None","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"  in","counters":[]},{"line":"  match mode with","counters":[]},{"line":"  | Hidden ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Ok (msg, [])","counters":[]},{"line":"  | Inline ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let%bind items = parse msg in","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"      render ~max_interpolation_length ~format_json metadata items","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  | After ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Ok","counters":[]},{"line":"        ( msg","counters":[]},{"line":"        , List.map (String.Map.to_alist metadata) ~f:(fun (k, v) ->","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"              (k, format_json v) ) )","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":35,"col_end":35,"count":2}]}]}