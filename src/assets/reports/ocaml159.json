{"filename":"src/lib/random_oracle/random_oracle.ml","lines":[{"line":"[%%import \"/src/config.mlh\"]","counters":[]},{"line":"","counters":[{"col_start":0,"col_end":0,"count":1}]},{"line":"open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"[%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"open Pickles.Impls.Step.Internal_Basic","counters":[]},{"line":"","counters":[]},{"line":"[%%else]","counters":[]},{"line":"","counters":[]},{"line":"open Snark_params.Tick","counters":[]},{"line":"","counters":[]},{"line":"[%%endif]","counters":[]},{"line":"","counters":[]},{"line":"module State = struct","counters":[]},{"line":"  include Array","counters":[]},{"line":"","counters":[]},{"line":"  let map2 = map2_exn","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Input = Random_oracle_input","counters":[]},{"line":"","counters":[]},{"line":"let params : Field.t Sponge.Params.t =","counters":[]},{"line":"  Sponge.Params.(map pasta_p_kimchi ~f:Field.of_string)","counters":[{"col_start":19,"col_end":19,"count":1}]},{"line":"","counters":[]},{"line":"module Operations = struct","counters":[]},{"line":"  let add_assign ~state i x = Field.(state.(i) <- state.(i) + x)","counters":[{"col_start":30,"col_end":30,"count":15}]},{"line":"","counters":[]},{"line":"  let apply_affine_map (matrix, constants) v =","counters":[]},{"line":"    let dotv row =","counters":[{"col_start":4,"col_end":4,"count":189}]},{"line":"      Array.reduce_exn (Array.map2_exn row v ~f:Field.( * )) ~f:Field.( + )","counters":[{"col_start":6,"col_end":6,"count":567},{"col_start":37,"col_end":37,"count":567}]},{"line":"    in","counters":[]},{"line":"    let res = Array.map matrix ~f:dotv in","counters":[]},{"line":"    Array.map2_exn res constants ~f:Field.( + )","counters":[{"col_start":4,"col_end":4,"count":189}]},{"line":"","counters":[]},{"line":"  let copy a = Array.map a ~f:Fn.id","counters":[{"col_start":15,"col_end":15,"count":3}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Digest = struct","counters":[]},{"line":"  open Field","counters":[]},{"line":"","counters":[]},{"line":"  type nonrec t = t","counters":[]},{"line":"","counters":[]},{"line":"  let to_bits ?length x =","counters":[]},{"line":"    match length with","counters":[{"col_start":4,"col_end":4,"count":2}]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        unpack x","counters":[]},{"line":"    | Some length ->","counters":[{"col_start":6,"col_end":6,"count":2}]},{"line":"        List.take (unpack x) length","counters":[{"col_start":24,"col_end":24,"count":2}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"include Sponge.Make_hash (Random_oracle_permutation)","counters":[]},{"line":"","counters":[]},{"line":"let update ~state = update ~state params","counters":[{"col_start":20,"col_end":20,"count":50}]},{"line":"","counters":[]},{"line":"let hash ?init = hash ?init params","counters":[{"col_start":17,"col_end":17,"count":185}]},{"line":"","counters":[]},{"line":"let pow2 =","counters":[]},{"line":"  let rec pow2 acc n = if n = 0 then acc else pow2 Field.(acc + acc) (n - 1) in","counters":[{"col_start":23,"col_end":23,"count":152},{"col_start":37,"col_end":37,"count":5},{"col_start":46,"col_end":46,"count":147}]},{"line":"  Memo.general ~hashable:Int.hashable (fun n -> pow2 Field.one n)","counters":[{"col_start":13,"col_end":13,"count":1},{"col_start":48,"col_end":48,"count":5}]},{"line":"","counters":[]},{"line":"[%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"module Checked = struct","counters":[]},{"line":"  module Inputs = Pickles.Step_main_inputs.Sponge.Permutation","counters":[]},{"line":"","counters":[]},{"line":"  module Digest = struct","counters":[]},{"line":"    open Pickles.Impls.Step.Field","counters":[]},{"line":"","counters":[]},{"line":"    type nonrec t = t","counters":[]},{"line":"","counters":[]},{"line":"    let to_bits ?(length = Field.size_in_bits) (x : t) =","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"      List.take (choose_preimage_var ~length:Field.size_in_bits x) length","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  include Sponge.Make_hash (Inputs)","counters":[]},{"line":"","counters":[]},{"line":"  let params = Sponge.Params.map ~f:Inputs.Field.constant params","counters":[{"col_start":31,"col_end":31,"count":1}]},{"line":"","counters":[]},{"line":"  open Inputs.Field","counters":[]},{"line":"","counters":[]},{"line":"  let update ~state xs = update params ~state xs","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"  let hash ?init xs =","counters":[]},{"line":"    hash ?init:(Option.map init ~f:(State.map ~f:constant)) params xs","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"  let pack_input =","counters":[]},{"line":"    Input.Chunked.pack_to_fields","counters":[{"col_start":31,"col_end":31,"count":1}]},{"line":"      ~pow2:(Fn.compose Field.Var.constant pow2)","counters":[{"col_start":22,"col_end":22,"count":1}]},{"line":"      (module Pickles.Impls.Step.Field)","counters":[]},{"line":"","counters":[]},{"line":"  let digest xs = xs.(0)","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let read_typ ({ field_elements; packeds } : _ Input.Chunked.t) =","counters":[]},{"line":"  let open Pickles.Impls.Step in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let open As_prover in","counters":[]},{"line":"  { Input.Chunked.field_elements = Array.map ~f:(read Field.typ) field_elements","counters":[{"col_start":43,"col_end":43,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"  ; packeds = Array.map packeds ~f:(fun (x, i) -> (read Field.typ x, i))","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":50,"col_end":50,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"let read_typ' input : _ Pickles.Impls.Step.Internal_Basic.As_prover.t =","counters":[]},{"line":" fun _ -> read_typ input","counters":[{"col_start":1,"col_end":1,"count":0},{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"[%%endif]","counters":[]},{"line":"","counters":[]},{"line":"let pack_input = Input.Chunked.pack_to_fields ~pow2 (module Field)","counters":[{"col_start":44,"col_end":44,"count":1}]},{"line":"","counters":[]},{"line":"let prefix_to_field (s : string) =","counters":[]},{"line":"  let bits_per_character = 8 in","counters":[{"col_start":2,"col_end":2,"count":53}]},{"line":"  assert (bits_per_character * String.length s < Field.size_in_bits) ;","counters":[{"col_start":9,"col_end":9,"count":53},{"col_start":43,"col_end":43,"count":53}]},{"line":"  Field.project Fold_lib.Fold.(to_list (string_bits (s :> string)))","counters":[{"col_start":37,"col_end":37,"count":53},{"col_start":50,"col_end":50,"count":53}]},{"line":"","counters":[]},{"line":"let salt (s : string) = update ~state:initial_state [| prefix_to_field s |]","counters":[{"col_start":24,"col_end":24,"count":50},{"col_start":69,"col_end":69,"count":50}]},{"line":"","counters":[]},{"line":"let%test_unit \"iterativeness\" =","counters":[]},{"line":"  let x1 = Field.random () in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let x2 = Field.random () in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let x3 = Field.random () in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let x4 = Field.random () in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let s_full = update ~state:initial_state [| x1; x2; x3; x4 |] in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let s_it =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    update ~state:(update ~state:initial_state [| x1; x2 |]) [| x3; x4 |]","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"  in","counters":[]},{"line":"  [%test_eq: Field.t array] s_full s_it","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"","counters":[]},{"line":"[%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"let%test_unit \"sponge checked-unchecked\" =","counters":[]},{"line":"  let open Pickles.Impls.Step in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let module T = Internal_Basic in","counters":[]},{"line":"  let x = T.Field.random () in","counters":[]},{"line":"  let y = T.Field.random () in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  T.Test.test_equal ~equal:T.Field.equal ~sexp_of_t:T.Field.sexp_of_t","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    T.Typ.(field * field)","counters":[]},{"line":"    T.Typ.field","counters":[]},{"line":"    (fun (x, y) -> make_checked (fun () -> Checked.hash [| x; y |]))","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"    (fun (x, y) -> hash [| x; y |])","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"    (x, y)","counters":[]},{"line":"","counters":[]},{"line":"[%%endif]","counters":[]},{"line":"","counters":[]},{"line":"module Legacy = struct","counters":[]},{"line":"  module Input = Random_oracle_input.Legacy","counters":[]},{"line":"  module State = State","counters":[]},{"line":"","counters":[]},{"line":"  let params : Field.t Sponge.Params.t =","counters":[]},{"line":"    Sponge.Params.(map pasta_p_legacy ~f:Field.of_string)","counters":[{"col_start":21,"col_end":21,"count":1}]},{"line":"","counters":[]},{"line":"  module Rounds = struct","counters":[]},{"line":"    let rounds_full = 63","counters":[]},{"line":"","counters":[]},{"line":"    let initial_ark = true","counters":[]},{"line":"","counters":[]},{"line":"    let rounds_partial = 0","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Inputs = struct","counters":[]},{"line":"    module Field = Field","counters":[]},{"line":"    include Rounds","counters":[]},{"line":"","counters":[]},{"line":"    let alpha = 5","counters":[]},{"line":"","counters":[]},{"line":"    (* Computes x^5 *)","counters":[]},{"line":"    let to_the_alpha x =","counters":[]},{"line":"      let open Field in","counters":[{"col_start":6,"col_end":6,"count":567}]},{"line":"      let res = x in","counters":[]},{"line":"      let res = res * res in","counters":[]},{"line":"      (* x^2 *)","counters":[]},{"line":"      let res = res * res in","counters":[]},{"line":"      (* x^4 *)","counters":[]},{"line":"      res * x","counters":[]},{"line":"","counters":[]},{"line":"    module Operations = Operations","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  include Sponge.Make_hash (Sponge.Poseidon (Inputs))","counters":[]},{"line":"","counters":[]},{"line":"  let hash ?init = hash ?init params","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"","counters":[]},{"line":"  let update ~state = update ~state params","counters":[{"col_start":22,"col_end":22,"count":3}]},{"line":"","counters":[]},{"line":"  let salt (s : string) = update ~state:initial_state [| prefix_to_field s |]","counters":[{"col_start":26,"col_end":26,"count":3},{"col_start":71,"col_end":71,"count":3}]},{"line":"","counters":[]},{"line":"  let pack_input =","counters":[]},{"line":"    Input.pack_to_fields ~size_in_bits:Field.size_in_bits ~pack:Field.project","counters":[]},{"line":"","counters":[]},{"line":"  module Digest = Digest","counters":[]},{"line":"","counters":[]},{"line":"  [%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"  module Checked = struct","counters":[]},{"line":"    let pack_input =","counters":[]},{"line":"      Input.pack_to_fields ~size_in_bits:Field.size_in_bits ~pack:Field.Var.pack","counters":[]},{"line":"","counters":[]},{"line":"    module Digest = Checked.Digest","counters":[]},{"line":"","counters":[]},{"line":"    module Inputs = struct","counters":[]},{"line":"      include Rounds","counters":[]},{"line":"      module Impl = Pickles.Impls.Step","counters":[]},{"line":"      open Impl","counters":[]},{"line":"      module Field = Field","counters":[]},{"line":"","counters":[]},{"line":"      let alpha = 5","counters":[]},{"line":"","counters":[]},{"line":"      (* Computes x^5 *)","counters":[]},{"line":"      let to_the_alpha x =","counters":[]},{"line":"        let open Field in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let res = x in","counters":[]},{"line":"        let res = res * res in","counters":[]},{"line":"        (* x^2 *)","counters":[]},{"line":"        let res = res * res in","counters":[]},{"line":"        (* x^4 *)","counters":[]},{"line":"        res * x","counters":[]},{"line":"","counters":[]},{"line":"      module Operations = struct","counters":[]},{"line":"        open Field","counters":[]},{"line":"","counters":[]},{"line":"        let seal = Pickles.Util.seal (module Impl)","counters":[{"col_start":35,"col_end":35,"count":1}]},{"line":"","counters":[]},{"line":"        let add_assign ~state i x = state.(i) <- seal (state.(i) + x)","counters":[{"col_start":36,"col_end":36,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"","counters":[]},{"line":"        let apply_affine_map (matrix, constants) v =","counters":[]},{"line":"          let dotv row =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Array.reduce_exn (Array.map2_exn row v ~f:( * )) ~f:( + )","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"          in","counters":[]},{"line":"          let res = Array.map matrix ~f:dotv in","counters":[]},{"line":"          Array.map2_exn res constants ~f:(fun x c -> seal (x + c))","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"","counters":[]},{"line":"        let copy a = Array.map a ~f:Fn.id","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"      end","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    include Sponge.Make_hash (Sponge.Poseidon (Inputs))","counters":[]},{"line":"","counters":[]},{"line":"    let params = Sponge.Params.map ~f:Inputs.Field.constant params","counters":[{"col_start":33,"col_end":33,"count":1}]},{"line":"","counters":[]},{"line":"    open Inputs.Field","counters":[]},{"line":"","counters":[]},{"line":"    let update ~state xs = update params ~state xs","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"","counters":[]},{"line":"    let hash ?init xs =","counters":[]},{"line":"      hash ?init:(Option.map init ~f:(State.map ~f:constant)) params xs","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  [%%endif]","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":1}]}]}