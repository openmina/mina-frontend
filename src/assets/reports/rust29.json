{"filename":"src/ffi/util.rs","lines":[{"line":"use std::{collections::HashSet, hash::Hash, io::Cursor};","counters":[]},{"line":"","counters":[]},{"line":"use binprot::{BinProtRead, BinProtWrite};","counters":[]},{"line":"use mina_hasher::Fp;","counters":[]},{"line":"use mina_p2p_messages::bigint::BigInt;","counters":[]},{"line":"use ocaml_interop::*;","counters":[]},{"line":"","counters":[]},{"line":"use crate::{Account, AccountIndex, Address};","counters":[]},{"line":"","counters":[]},{"line":"pub fn deserialize<T: BinProtRead>(bytes: &[u8]) -> T {","counters":[{"col_start":0,"col_end":55,"count":0}]},{"line":"    let mut cursor = Cursor::new(bytes);","counters":[{"col_start":0,"col_end":40,"count":0}]},{"line":"    T::binprot_read(&mut cursor).unwrap()","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"pub fn serialize<T: BinProtWrite>(obj: &T) -> Vec<u8> {","counters":[{"col_start":0,"col_end":55,"count":1}]},{"line":"    let mut bytes = Vec::with_capacity(10000); // TODO: fix this","counters":[{"col_start":0,"col_end":64,"count":1}]},{"line":"    obj.binprot_write(&mut bytes).unwrap();","counters":[{"col_start":0,"col_end":43,"count":1}]},{"line":"    bytes","counters":[{"col_start":0,"col_end":9,"count":1}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":1}]},{"line":"","counters":[]},{"line":"pub fn get_list_of<'a, T>(","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"    rt: &'a mut &mut OCamlRuntime,","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"    list: OCamlRef<OCamlList<OCamlBytes>>,","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":") -> Vec<T>","counters":[{"col_start":0,"col_end":11,"count":0}]},{"line":"where","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"    T: BinProtRead,","counters":[{"col_start":0,"col_end":19,"count":0}]},{"line":"{","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"    let mut list_ref = rt.get(list);","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"    let mut list = Vec::with_capacity(2048);","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"","counters":[]},{"line":"    while let Some((head, tail)) = list_ref.uncons() {","counters":[{"col_start":20,"col_end":30,"count":0},{"col_start":35,"col_end":52,"count":0},{"col_start":53,"col_end":54,"count":0}]},{"line":"        let object: T = deserialize(head.as_bytes());","counters":[{"col_start":0,"col_end":53,"count":0}]},{"line":"        list.push(object);","counters":[{"col_start":0,"col_end":26,"count":0}]},{"line":"        list_ref = tail;","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    list","counters":[{"col_start":4,"col_end":8,"count":0}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"pub fn get_set_of<'a, T>(","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"    rt: &'a mut &mut OCamlRuntime,","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"    list: OCamlRef<OCamlList<OCamlBytes>>,","counters":[{"col_start":0,"col_end":42,"count":0}]},{"line":") -> HashSet<T>","counters":[{"col_start":0,"col_end":15,"count":0}]},{"line":"where","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"    T: BinProtRead + Hash + Eq,","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"{","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"    let mut list_ref = rt.get(list);","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"    let mut set = HashSet::with_capacity(2048);","counters":[{"col_start":0,"col_end":46,"count":0}]},{"line":"","counters":[]},{"line":"    while let Some((head, tail)) = list_ref.uncons() {","counters":[{"col_start":20,"col_end":30,"count":0},{"col_start":35,"col_end":52,"count":0},{"col_start":53,"col_end":54,"count":0}]},{"line":"        let object: T = deserialize(head.as_bytes());","counters":[{"col_start":0,"col_end":53,"count":0}]},{"line":"        set.insert(object);","counters":[{"col_start":0,"col_end":27,"count":0}]},{"line":"        list_ref = tail;","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    set","counters":[{"col_start":4,"col_end":7,"count":0}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"pub fn get_list_addr_account<'a>(","counters":[{"col_start":0,"col_end":33,"count":0}]},{"line":"    rt: &'a mut &mut OCamlRuntime,","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"    list: OCamlRef<OCamlList<(String, OCamlBytes)>>,","counters":[{"col_start":0,"col_end":52,"count":0}]},{"line":") -> Vec<(Address, Account)> {","counters":[{"col_start":0,"col_end":30,"count":0}]},{"line":"    let mut list_ref = rt.get(list);","counters":[{"col_start":0,"col_end":36,"count":0}]},{"line":"    let mut list = Vec::with_capacity(2048);","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"","counters":[]},{"line":"    while let Some((head, tail)) = list_ref.uncons() {","counters":[{"col_start":20,"col_end":30,"count":0},{"col_start":35,"col_end":52,"count":0},{"col_start":53,"col_end":54,"count":0}]},{"line":"        let addr = head.fst().as_str();","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"        let account = head.snd().as_bytes();","counters":[{"col_start":0,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"        let addr = Address::try_from(addr).unwrap();","counters":[{"col_start":0,"col_end":52,"count":0}]},{"line":"        let object: Account = deserialize(account);","counters":[{"col_start":0,"col_end":51,"count":0}]},{"line":"        list.push((addr, object));","counters":[{"col_start":0,"col_end":34,"count":0}]},{"line":"","counters":[]},{"line":"        list_ref = tail;","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    list","counters":[{"col_start":4,"col_end":8,"count":0}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"pub fn get_addr(rt: &mut &mut OCamlRuntime, addr: OCamlRef<String>) -> Address {","counters":[{"col_start":0,"col_end":80,"count":1}]},{"line":"    let addr_ref = rt.get(addr);","counters":[{"col_start":0,"col_end":32,"count":1}]},{"line":"    Address::try_from(addr_ref.as_str()).unwrap()","counters":[{"col_start":0,"col_end":49,"count":1}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":1}]},{"line":"","counters":[]},{"line":"pub fn get<'a, T>(rt: &'a mut &mut OCamlRuntime, object: OCamlRef<OCamlBytes>) -> T","counters":[{"col_start":0,"col_end":83,"count":1}]},{"line":"where","counters":[{"col_start":0,"col_end":5,"count":1}]},{"line":"    T: BinProtRead,","counters":[{"col_start":0,"col_end":19,"count":1}]},{"line":"{","counters":[{"col_start":0,"col_end":1,"count":1}]},{"line":"    let object_ref = rt.get(object);","counters":[{"col_start":0,"col_end":36,"count":1}]},{"line":"    deserialize(object_ref.as_bytes())","counters":[{"col_start":0,"col_end":38,"count":1}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":1}]},{"line":"","counters":[]},{"line":"pub fn get_index(rt: &mut &mut OCamlRuntime, index: OCamlRef<OCamlInt>) -> AccountIndex {","counters":[{"col_start":0,"col_end":89,"count":0}]},{"line":"    let index: i64 = index.to_rust(rt);","counters":[{"col_start":0,"col_end":39,"count":0}]},{"line":"    let index: u64 = index.try_into().unwrap();","counters":[{"col_start":0,"col_end":47,"count":0}]},{"line":"    AccountIndex(index)","counters":[{"col_start":0,"col_end":23,"count":0}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]},{"line":"","counters":[]},{"line":"pub fn hash_to_ocaml(hash: Fp) -> Vec<u8> {","counters":[{"col_start":0,"col_end":43,"count":0}]},{"line":"    let hash: BigInt = hash.into();","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"    serialize(&hash)","counters":[{"col_start":0,"col_end":20,"count":0}]},{"line":"}","counters":[{"col_start":0,"col_end":1,"count":0}]}]}