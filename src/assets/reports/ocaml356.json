{"filename":"src/lib/snark_worker/prod.ml","lines":[{"line":"open Core","counters":[]},{"line":"open Async","counters":[]},{"line":"open Mina_base","counters":[]},{"line":"open Mina_transaction","counters":[]},{"line":"","counters":[]},{"line":"module Cache = struct","counters":[]},{"line":"  module T = Hash_heap.Make (Transaction_snark.Statement)","counters":[]},{"line":"","counters":[]},{"line":"  type t = (Time.t * Transaction_snark.t) T.t","counters":[]},{"line":"","counters":[]},{"line":"  let max_size = 100","counters":[]},{"line":"","counters":[]},{"line":"  let create () : t = T.create (fun (t1, _) (t2, _) -> Time.compare t1 t2)","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"","counters":[]},{"line":"  let add t ~statement ~proof =","counters":[]},{"line":"    T.push_exn t ~key:statement ~data:(Time.now (), proof) ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"    if Int.( > ) (T.length t) max_size then ignore (T.pop_exn t)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"","counters":[]},{"line":"  let find (t : t) statement = Option.map ~f:snd (T.find t statement)","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Inputs = struct","counters":[]},{"line":"  module Ledger_proof = Ledger_proof.Prod","counters":[]},{"line":"","counters":[]},{"line":"  module Worker_state = struct","counters":[]},{"line":"    module type S = Transaction_snark.S","counters":[]},{"line":"","counters":[]},{"line":"    type t =","counters":[]},{"line":"      { m : (module S) option","counters":[]},{"line":"      ; cache : Cache.t","counters":[]},{"line":"      ; proof_level : Genesis_constants.Proof_level.t","counters":[]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    let create ~constraint_constants ~proof_level () =","counters":[]},{"line":"      let m =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        match proof_level with","counters":[]},{"line":"        | Genesis_constants.Proof_level.Full ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Some","counters":[]},{"line":"              ( module Transaction_snark.Make (struct","counters":[]},{"line":"                let constraint_constants = constraint_constants","counters":[]},{"line":"","counters":[]},{"line":"                let proof_level = proof_level","counters":[]},{"line":"              end) : S )","counters":[]},{"line":"        | Check | None ->","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"            None","counters":[]},{"line":"      in","counters":[]},{"line":"      Deferred.return { m; cache = Cache.create (); proof_level }","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"","counters":[]},{"line":"    let worker_wait_time = 5.","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  (* bin_io is for uptime service SNARK worker *)","counters":[]},{"line":"  type single_spec =","counters":[{"col_start":2,"col_end":2,"count":1},{"col_start":17,"col_end":17,"count":1}]},{"line":"    ( Transaction_witness.Stable.Latest.t","counters":[]},{"line":"    , Transaction_snark.Stable.Latest.t )","counters":[]},{"line":"    Snark_work_lib.Work.Single.Spec.Stable.Latest.t","counters":[]},{"line":"  [@@deriving bin_io_unversioned, sexp]","counters":[{"col_start":38,"col_end":38,"count":4}]},{"line":"","counters":[]},{"line":"  type zkapp_command_inputs =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    ( Transaction_witness.Zkapp_command_segment_witness.t","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":6,"col_end":6,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"    * Transaction_snark.Zkapp_command_segment.Basic.t","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"    * Transaction_snark.Statement.With_sok.t )","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"    list","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"  [@@deriving sexp, to_yojson]","counters":[]},{"line":"","counters":[]},{"line":"  let perform_single ({ m; cache; proof_level } : Worker_state.t) ~message =","counters":[]},{"line":"    let open Deferred.Or_error.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let open Snark_work_lib in","counters":[]},{"line":"    let sok_digest = Mina_base.Sok_message.digest message in","counters":[]},{"line":"    let logger = Logger.create () in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    fun (single : single_spec) ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      match proof_level with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Genesis_constants.Proof_level.Full -> (","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let (module M) = Option.value_exn m in","counters":[]},{"line":"          let statement = Work.Single.Spec.statement single in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let process k =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let start = Time.now () in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            match%map.Async.Deferred k () with","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"            | Error e ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                [%log error] \"SNARK worker failed: $error\"","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                  ~metadata:","counters":[]},{"line":"                    [ (\"error\", Error_json.error_to_yojson e)","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"                    ; ( \"spec\"","counters":[]},{"line":"                        (* the [@sexp.opaque] in Work.Single.Spec.t means we can't derive yojson,","counters":[]},{"line":"                           so we use the less-desirable sexp here","counters":[]},{"line":"                        *)","counters":[]},{"line":"                      , `String (Sexp.to_string (sexp_of_single_spec single)) )","counters":[{"col_start":46,"col_end":46,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"                    ] ;","counters":[]},{"line":"                Error e","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"            | Ok res ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Cache.add cache ~statement ~proof:res ;","counters":[]},{"line":"                let total = Time.abs_diff (Time.now ()) start in","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"                Ok (res, total)","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"          in","counters":[]},{"line":"          match Cache.find cache statement with","counters":[]},{"line":"          | Some proof ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Deferred.Or_error.return (proof, Time.Span.zero)","counters":[]},{"line":"          | None -> (","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              match single with","counters":[]},{"line":"              | Work.Single.Spec.Transition (input, (w : Transaction_witness.t))","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                ->","counters":[]},{"line":"                  process (fun () ->","counters":[]},{"line":"                      match w.transaction with","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                      | Command (Zkapp_command zkapp_command) -> (","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          let%bind witnesses_specs_stmts =","counters":[]},{"line":"                            Or_error.try_with (fun () ->","counters":[]},{"line":"                                Transaction_snark.zkapp_command_witnesses_exn","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                                  ~constraint_constants:M.constraint_constants","counters":[]},{"line":"                                  ~state_body:w.protocol_state_body","counters":[]},{"line":"                                  ~fee_excess:Currency.Amount.Signed.zero","counters":[]},{"line":"                                  (`Sparse_ledger w.ledger)","counters":[]},{"line":"                                  [ ( `Pending_coinbase_init_stack w.init_stack","counters":[]},{"line":"                                    , `Pending_coinbase_of_statement","counters":[]},{"line":"                                        { Transaction_snark","counters":[]},{"line":"                                          .Pending_coinbase_stack_state","counters":[]},{"line":"                                          .source =","counters":[]},{"line":"                                            input.source.pending_coinbase_stack","counters":[]},{"line":"                                        ; target =","counters":[]},{"line":"                                            input.target.pending_coinbase_stack","counters":[]},{"line":"                                        }","counters":[]},{"line":"                                    , zkapp_command )","counters":[]},{"line":"                                  ]","counters":[]},{"line":"                                |> fst |> List.rev )","counters":[{"col_start":35,"col_end":35,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"                            |> Result.map_error ~f:(fun e ->","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                                   Error.createf","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                                     !\"Failed to generate inputs for \\","counters":[]},{"line":"                                       zkapp_command : %s: %s\"","counters":[]},{"line":"                                     ( Zkapp_command.to_yojson zkapp_command","counters":[]},{"line":"                                     |> Yojson.Safe.to_string )","counters":[{"col_start":40,"col_end":40,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"                                     (Error.to_string_hum e) )","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"                            |> Deferred.return","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"                          in","counters":[]},{"line":"                          let log_base_snark f ~statement ~spec ~all_inputs =","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            match%map.Deferred","counters":[]},{"line":"                              Deferred.Or_error.try_with (fun () ->","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"                                  f ~statement ~spec )","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"                            with","counters":[]},{"line":"                            | Ok p ->","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                                Ok p","counters":[]},{"line":"                            | Error e ->","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                                [%log fatal]","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"                                  \"Transaction snark failed for input $spec \\","counters":[]},{"line":"                                   $statement. All inputs: $inputs. Error:  \\","counters":[]},{"line":"                                   $error\"","counters":[]},{"line":"                                  ~metadata:","counters":[]},{"line":"                                    [ ( \"spec\"","counters":[]},{"line":"                                      , Transaction_snark.Zkapp_command_segment","counters":[]},{"line":"                                        .Basic","counters":[]},{"line":"                                        .to_yojson spec )","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"                                    ; ( \"statement\"","counters":[]},{"line":"                                      , Transaction_snark.Statement.With_sok","counters":[]},{"line":"                                        .to_yojson statement )","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"                                    ; (\"error\", `String (Error.to_string_hum e))","counters":[{"col_start":75,"col_end":75,"count":0}]},{"line":"                                    ; ( \"inputs\"","counters":[]},{"line":"                                      , zkapp_command_inputs_to_yojson","counters":[{"col_start":69,"col_end":69,"count":0}]},{"line":"                                          all_inputs )","counters":[]},{"line":"                                    ] ;","counters":[]},{"line":"                                Error e","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                          in","counters":[]},{"line":"                          let log_merge_snark ~sok_digest prev curr ~all_inputs","counters":[]},{"line":"                              =","counters":[]},{"line":"                            match%map.Deferred","counters":[]},{"line":"                              M.merge ~sok_digest prev curr","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"                            with","counters":[]},{"line":"                            | Ok p ->","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                                Ok p","counters":[]},{"line":"                            | Error e ->","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                                [%log fatal]","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"                                  \"Merge snark failed for $stmt1 $stmt2. All \\","counters":[]},{"line":"                                   inputs: $inputs. Error:  $error\"","counters":[]},{"line":"                                  ~metadata:","counters":[]},{"line":"                                    [ ( \"stmt1\"","counters":[]},{"line":"                                      , Transaction_snark.Statement.to_yojson","counters":[{"col_start":76,"col_end":76,"count":0}]},{"line":"                                          (Ledger_proof.statement prev) )","counters":[{"col_start":64,"col_end":64,"count":0}]},{"line":"                                    ; ( \"stmt2\"","counters":[]},{"line":"                                      , Transaction_snark.Statement.to_yojson","counters":[{"col_start":76,"col_end":76,"count":0}]},{"line":"                                          (Ledger_proof.statement curr) )","counters":[{"col_start":64,"col_end":64,"count":0}]},{"line":"                                    ; (\"error\", `String (Error.to_string_hum e))","counters":[{"col_start":75,"col_end":75,"count":0}]},{"line":"                                    ; ( \"inputs\"","counters":[]},{"line":"                                      , zkapp_command_inputs_to_yojson","counters":[{"col_start":69,"col_end":69,"count":0}]},{"line":"                                          all_inputs )","counters":[]},{"line":"                                    ] ;","counters":[]},{"line":"                                Error e","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                          in","counters":[]},{"line":"                          match witnesses_specs_stmts with","counters":[]},{"line":"                          | [] ->","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                              Deferred.Or_error.error_string","counters":[]},{"line":"                                \"no witnesses generated\"","counters":[]},{"line":"                          | (witness, spec, stmt) :: rest as inputs ->","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                              let%bind (p1 : Ledger_proof.t) =","counters":[]},{"line":"                                log_base_snark","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"                                  ~statement:{ stmt with sok_digest } ~spec","counters":[]},{"line":"                                  ~all_inputs:inputs","counters":[]},{"line":"                                  (M.of_zkapp_command_segment_exn ~witness)","counters":[]},{"line":"                              in","counters":[]},{"line":"","counters":[]},{"line":"                              let%bind (p : Ledger_proof.t) =","counters":[]},{"line":"                                Deferred.List.fold ~init:(Ok p1) rest","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"                                  ~f:(fun acc (witness, spec, stmt) ->","counters":[]},{"line":"                                    let%bind (prev : Ledger_proof.t) =","counters":[]},{"line":"                                      Deferred.return acc","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"                                    in","counters":[]},{"line":"                                    let%bind (curr : Ledger_proof.t) =","counters":[]},{"line":"                                      log_base_snark","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                                        ~statement:{ stmt with sok_digest }","counters":[]},{"line":"                                        ~spec ~all_inputs:inputs","counters":[]},{"line":"                                        (M.of_zkapp_command_segment_exn ~witness)","counters":[]},{"line":"                                    in","counters":[]},{"line":"                                    log_merge_snark ~sok_digest prev curr","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"                                      ~all_inputs:inputs )","counters":[]},{"line":"                              in","counters":[]},{"line":"                              if","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                                Transaction_snark.Statement.equal","counters":[]},{"line":"                                  (Ledger_proof.statement p) input","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"                              then Deferred.return (Ok p)","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                              else (","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                                [%log fatal]","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"                                  \"Zkapp_command transaction final statement \\","counters":[]},{"line":"                                   mismatch Expected $expected Got $got. All \\","counters":[]},{"line":"                                   inputs: $inputs\"","counters":[]},{"line":"                                  ~metadata:","counters":[]},{"line":"                                    [ ( \"got\"","counters":[]},{"line":"                                      , Transaction_snark.Statement.to_yojson","counters":[{"col_start":76,"col_end":76,"count":0}]},{"line":"                                          (Ledger_proof.statement p) )","counters":[{"col_start":64,"col_end":64,"count":0}]},{"line":"                                    ; ( \"expected\"","counters":[]},{"line":"                                      , Transaction_snark.Statement.to_yojson","counters":[{"col_start":76,"col_end":76,"count":0}]},{"line":"                                          input )","counters":[]},{"line":"                                    ; ( \"inputs\"","counters":[]},{"line":"                                      , zkapp_command_inputs_to_yojson inputs )","counters":[{"col_start":69,"col_end":69,"count":0}]},{"line":"                                    ] ;","counters":[]},{"line":"                                Deferred.return","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                                  (Or_error.error_string","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"                                     \"Zkapp_command transaction final \\","counters":[]},{"line":"                                      statement mismatch\" ) ) )","counters":[]},{"line":"                      | _ ->","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          let%bind t =","counters":[]},{"line":"                            Deferred.return","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"                            @@","counters":[]},{"line":"                            (* Validate the received transaction *)","counters":[]},{"line":"                            match w.transaction with","counters":[]},{"line":"                            | Command (Signed_command cmd) -> (","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                                match Signed_command.check cmd with","counters":[]},{"line":"                                | Some cmd ->","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"                                    ( Ok (Command (Signed_command cmd))","counters":[]},{"line":"                                      : Transaction.Valid.t Or_error.t )","counters":[]},{"line":"                                | None ->","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"                                    Or_error.errorf","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                                      \"Command has an invalid signature\" )","counters":[]},{"line":"                            | Command (Zkapp_command _) ->","counters":[]},{"line":"                                assert false","counters":[]},{"line":"                            | Fee_transfer ft ->","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                                Ok (Fee_transfer ft)","counters":[]},{"line":"                            | Coinbase cb ->","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                                Ok (Coinbase cb)","counters":[]},{"line":"                          in","counters":[]},{"line":"                          Deferred.Or_error.try_with ~here:[%here] (fun () ->","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                              M.of_non_zkapp_command_transaction","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                                ~statement:{ input with sok_digest }","counters":[]},{"line":"                                { Transaction_protocol_state.Poly.transaction =","counters":[]},{"line":"                                    t","counters":[]},{"line":"                                ; block_data = w.protocol_state_body","counters":[]},{"line":"                                }","counters":[]},{"line":"                                ~init_stack:w.init_stack","counters":[]},{"line":"                                (unstage","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"                                   (Mina_ledger.Sparse_ledger.handler w.ledger) ) ) )","counters":[{"col_start":68,"col_end":68,"count":0}]},{"line":"              | Merge (_, proof1, proof2) ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  process (fun () -> M.merge ~sok_digest proof1 proof2) ) )","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"      | Check | None ->","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":16,"col_end":16,"count":0}]},{"line":"          (* Use a dummy proof. *)","counters":[]},{"line":"          let stmt =","counters":[]},{"line":"            match single with","counters":[]},{"line":"            | Work.Single.Spec.Transition (stmt, _) ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                stmt","counters":[]},{"line":"            | Merge (stmt, _, _) ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                stmt","counters":[]},{"line":"          in","counters":[]},{"line":"          Deferred.Or_error.return","counters":[]},{"line":"          @@ ( Transaction_snark.create ~statement:{ stmt with sok_digest }","counters":[]},{"line":"                 ~proof:Proof.transaction_dummy","counters":[]},{"line":"             , Time.Span.zero )","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":1}]}]}