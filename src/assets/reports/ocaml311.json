{"filename":"src/lib/work_selector/test.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Async","counters":[]},{"line":"open Currency","counters":[]},{"line":"open Pipe_lib","counters":[]},{"line":"","counters":[]},{"line":"module Make_test (Make_selection_method : Intf.Make_selection_method_intf) =","counters":[]},{"line":"struct","counters":[]},{"line":"  module T = Inputs.Test_inputs","counters":[]},{"line":"","counters":[]},{"line":"  let reassignment_wait = 2000","counters":[]},{"line":"","counters":[]},{"line":"  module Lib = Work_lib.Make (T)","counters":[]},{"line":"  module Selection_method = Make_selection_method (T) (Lib)","counters":[]},{"line":"","counters":[]},{"line":"  let gen_staged_ledger =","counters":[]},{"line":"    (*Staged_ledger for tests is a list of work specs*)","counters":[]},{"line":"    Quickcheck.Generator.list","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"    @@ Snark_work_lib.Work.Single.Spec.gen Int.quickcheck_generator Fee.gen","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"","counters":[]},{"line":"  let precomputed_values = Precomputed_values.for_unit_tests","counters":[]},{"line":"","counters":[]},{"line":"  let init_state sl reassignment_wait logger =","counters":[]},{"line":"    let tf_reader, tf_writer = Broadcast_pipe.create None in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let work_state =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Lib.State.init ~reassignment_wait ~frontier_broadcast_pipe:tf_reader","counters":[]},{"line":"        ~logger","counters":[]},{"line":"    in","counters":[]},{"line":"    let%map () = Broadcast_pipe.Writer.write tf_writer (Some sl) in","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"    work_state","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let%test_unit \"Workspec chunk doesn't send same things again\" =","counters":[]},{"line":"    Backtrace.elide := false ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let p = 50 in","counters":[]},{"line":"    let snark_pool = T.Snark_pool.create () in","counters":[]},{"line":"    let fee = Currency.Fee.zero in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let logger = Logger.null () in","counters":[]},{"line":"    Quickcheck.test gen_staged_ledger ~trials:100 ~f:(fun sl ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        Async.Thread_safe.block_on_async_exn (fun () ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            let open Deferred.Let_syntax in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let%bind work_state = init_state sl reassignment_wait logger in","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"            let rec go i =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              [%test_result: Bool.t]","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"                ~message:\"Exceeded time expected to exhaust work\" ~expect:true","counters":[]},{"line":"                (i <= p) ;","counters":[]},{"line":"              let stuff =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Selection_method.work ~snark_pool ~fee ~logger work_state","counters":[]},{"line":"              in","counters":[]},{"line":"              match stuff with None -> return () | _ -> go (i + 1)","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"            in","counters":[]},{"line":"            go 0 ) )","counters":[]},{"line":"","counters":[]},{"line":"  let%test_unit \"Reassign work after the wait time\" =","counters":[]},{"line":"    Backtrace.elide := false ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let snark_pool = T.Snark_pool.create () in","counters":[]},{"line":"    let fee = Currency.Fee.zero in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let logger = Logger.null () in","counters":[]},{"line":"    let send_work work_state =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let rec go all_work =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let stuff = Selection_method.work ~snark_pool ~fee ~logger work_state in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        match stuff with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            all_work","counters":[]},{"line":"        | Some work ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            go (One_or_two.to_list work @ all_work)","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"      in","counters":[]},{"line":"      go []","counters":[]},{"line":"    in","counters":[]},{"line":"    Quickcheck.test gen_staged_ledger ~trials:10 ~f:(fun sl ->","counters":[]},{"line":"        Async.Thread_safe.block_on_async_exn (fun () ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            let open Deferred.Let_syntax in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let%bind work_state = init_state sl reassignment_wait logger in","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"            let work_sent = send_work work_state in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            (*wait for wait_time after which all the work will be reassigned*)","counters":[]},{"line":"            let%map () =","counters":[]},{"line":"              Async.after (Time.Span.of_ms (Float.of_int reassignment_wait))","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"            in","counters":[]},{"line":"            let work_sent_again = send_work work_state in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            assert (List.length work_sent = List.length work_sent_again) ) )","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"","counters":[]},{"line":"  let gen_snark_pool (works : ('a, 'b) Lib.Work_spec.t One_or_two.t list) fee =","counters":[]},{"line":"    let open Quickcheck.Generator.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let cheap_work_fee = Option.value_exn Fee.(sub fee one) in","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"    let expensive_work_fee = Option.value_exn Fee.(add fee one) in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"    let snark_pool = T.Snark_pool.create () in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let rec add_works = function","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      | [] ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          return ()","counters":[]},{"line":"      | work :: rest ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let%bind fee =","counters":[]},{"line":"            Quickcheck.Generator.of_list [ cheap_work_fee; expensive_work_fee ]","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"          in","counters":[]},{"line":"          T.Snark_pool.add_snark snark_pool ~work ~fee ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          add_works rest","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    in","counters":[]},{"line":"    let%map () =","counters":[]},{"line":"      add_works (List.map ~f:(One_or_two.map ~f:Lib.Work_spec.statement) works)","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"    in","counters":[]},{"line":"    snark_pool","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let%test_unit \"selector shouldn't get work that it cannot outbid\" =","counters":[]},{"line":"    Backtrace.elide := false ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let my_fee = Currency.Fee.of_int 2 in","counters":[]},{"line":"    let p = 50 in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let logger = Logger.null () in","counters":[]},{"line":"    let g =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"      let%bind sl = gen_staged_ledger in","counters":[]},{"line":"      let%map pool =","counters":[]},{"line":"        gen_snark_pool","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"          ( T.Staged_ledger.all_work_pairs sl ~get_state:(fun _ ->","counters":[]},{"line":"                Ok","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  (Lazy.force precomputed_values).protocol_state_with_hashes","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                    .data )","counters":[]},{"line":"          |> Or_error.ok_exn )","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"          (Currency.Fee.of_int 2)","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"      in","counters":[]},{"line":"      (sl, pool)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    in","counters":[]},{"line":"    Quickcheck.test g","counters":[]},{"line":"      ~sexp_of:","counters":[]},{"line":"        [%sexp_of:","counters":[]},{"line":"          (int, Fee.t) Lib.Work_spec.t list * Fee.t T.Snark_pool.Work.Table.t]","counters":[]},{"line":"      ~trials:100 ~f:(fun (sl, snark_pool) ->","counters":[]},{"line":"        Async.Thread_safe.block_on_async_exn (fun () ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            let open Deferred.Let_syntax in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let%bind work_state = init_state sl reassignment_wait logger in","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"            let rec go i =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              [%test_result: Bool.t]","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"                ~message:\"Exceeded time expected to exhaust work\" ~expect:true","counters":[]},{"line":"                (i <= p) ;","counters":[]},{"line":"              let work =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Selection_method.work ~snark_pool ~fee:my_fee work_state ~logger","counters":[]},{"line":"              in","counters":[]},{"line":"              match work with","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              | None ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  return ()","counters":[]},{"line":"              | Some job ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  [%test_result: Bool.t]","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"                    ~message:\"Should not get any cheap jobs\" ~expect:true","counters":[]},{"line":"                    (Lib.For_tests.does_not_have_better_fee ~snark_pool","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"                       ~fee:my_fee","counters":[]},{"line":"                       (One_or_two.map job ~f:Lib.Work_spec.statement) ) ;","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                  go (i + 1)","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"            in","counters":[]},{"line":"            go 0 ) )","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":1}]}]}