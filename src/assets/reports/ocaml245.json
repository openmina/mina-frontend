{"filename":"src/lib/pickles/wrap_verifier.ml","lines":[{"line":"module type Inputs = Intf.Wrap_main_inputs.S","counters":[]},{"line":"","counters":[]},{"line":"module S = Sponge","counters":[]},{"line":"open Backend","counters":[]},{"line":"open Core_kernel","counters":[]},{"line":"open Util","counters":[]},{"line":"module SC = Scalar_challenge","counters":[]},{"line":"open Pickles_types","counters":[]},{"line":"open Plonk_types","counters":[]},{"line":"open Tuple_lib","counters":[]},{"line":"open Import","counters":[]},{"line":"","counters":[]},{"line":"let lookup_verification_enabled = false","counters":[]},{"line":"","counters":[]},{"line":"(* given [chals], compute","counters":[]},{"line":"   \\prod_i (1 + chals.(i) * x^{2^{k - 1 - i}}) *)","counters":[]},{"line":"let challenge_polynomial ~one ~add ~mul chals =","counters":[]},{"line":"  let ( + ) = add and ( * ) = mul in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  stage (fun pt ->","counters":[]},{"line":"      let k = Array.length chals in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let pow_two_pows =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let res = Array.init k ~f:(fun _ -> pt) in","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"        for i = 1 to k - 1 do","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let y = res.(i - 1) in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          res.(i) <- y * y","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        done ;","counters":[]},{"line":"        res","counters":[]},{"line":"      in","counters":[]},{"line":"      let prod f =","counters":[]},{"line":"        let r = ref (f 0) in","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"        for i = 1 to k - 1 do","counters":[]},{"line":"          r := f i * !r","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"        done ;","counters":[]},{"line":"        !r","counters":[]},{"line":"      in","counters":[]},{"line":"      prod (fun i -> one + (chals.(i) * pow_two_pows.(k - 1 - i))) )","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"","counters":[]},{"line":"let num_possible_domains = Nat.S Wrap_hack.Padded_length.n","counters":[]},{"line":"","counters":[]},{"line":"let all_possible_domains =","counters":[]},{"line":"  Memo.unit (fun () ->","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"      Vector.init num_possible_domains ~f:(fun proofs_verified ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          (Common.wrap_domains ~proofs_verified).h ) )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"module Make","counters":[]},{"line":"    (Inputs : Inputs","counters":[]},{"line":"                with type Impl.field = Tock.Field.t","counters":[]},{"line":"                 and type Impl.Bigint.t = Tock.Bigint.t","counters":[]},{"line":"                 and type Inner_curve.Constant.Scalar.t = Tick.Field.t) =","counters":[]},{"line":"struct","counters":[]},{"line":"  open Inputs","counters":[]},{"line":"  open Impl","counters":[]},{"line":"","counters":[]},{"line":"  module Other_field = struct","counters":[]},{"line":"    module Packed = struct","counters":[]},{"line":"      module Constant = Other_field","counters":[]},{"line":"","counters":[]},{"line":"      type t = Impls.Wrap.Other_field.t","counters":[]},{"line":"","counters":[]},{"line":"      let typ = Impls.Wrap.Other_field.typ","counters":[]},{"line":"","counters":[]},{"line":"      let to_bits_unsafe (x : t) = Wrap_main_inputs.Unsafe.unpack_unboolean x","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"      let absorb_shifted sponge (x : t Shifted_value.Type1.t) =","counters":[]},{"line":"        match x with Shifted_value x -> Sponge.absorb sponge x","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module With_top_bit0 = struct","counters":[]},{"line":"      (* When the top bit is 0, there is no need to check that this is not","counters":[]},{"line":"         equal to one of the forbidden values. The scaling is safe. *)","counters":[]},{"line":"      module Constant = Other_field","counters":[]},{"line":"","counters":[]},{"line":"      type t = Impls.Wrap.Other_field.t","counters":[]},{"line":"","counters":[]},{"line":"      let typ = Impls.Wrap.Other_field.typ_unchecked","counters":[]},{"line":"","counters":[]},{"line":"      let absorb_shifted sponge (x : t Shifted_value.Type1.t) =","counters":[]},{"line":"        match x with Shifted_value x -> Sponge.absorb sponge x","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"    end","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let num_possible_domains = num_possible_domains","counters":[]},{"line":"","counters":[]},{"line":"  let all_possible_domains = all_possible_domains","counters":[]},{"line":"","counters":[]},{"line":"  let print_g lab (x, y) =","counters":[]},{"line":"    if debug then","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      as_prover","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        As_prover.(","counters":[]},{"line":"          fun () ->","counters":[]},{"line":"            printf","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              !\"%s: %{sexp:Backend.Tock.Field.t}, %{sexp:Backend.Tock.Field.t}\\n\\","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                %!\"","counters":[]},{"line":"              lab (read_var x) (read_var y))","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"  let print_w lab gs =","counters":[]},{"line":"    if debug then","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Array.iteri gs ~f:(fun i (fin, g) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          as_prover","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            As_prover.(fun () -> printf \"fin=%b %!\" (read Boolean.typ fin)) ;","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"          ksprintf print_g \"%s[%d]\" lab i g )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"  let print_chal lab x =","counters":[]},{"line":"    if debug then","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      as_prover","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        As_prover.(","counters":[]},{"line":"          fun () ->","counters":[]},{"line":"            printf \"in-snark %s:%!\" lab ;","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            Field.Constant.print","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (Field.Constant.project (List.map ~f:(read Boolean.typ) x)) ;","counters":[{"col_start":36,"col_end":36,"count":0},{"col_start":46,"col_end":46,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"            printf \"\\n%!\")","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"","counters":[]},{"line":"  let print_bool lab x =","counters":[]},{"line":"    if debug then","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      as_prover (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          printf \"%s: %b\\n%!\" lab (As_prover.read Boolean.typ x) )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"","counters":[]},{"line":"  module Challenge = Challenge.Make (Impl)","counters":[]},{"line":"  module Digest = Digest.Make (Impl)","counters":[]},{"line":"  module Scalar_challenge =","counters":[]},{"line":"    SC.Make (Impl) (Inner_curve) (Challenge) (Endo.Wrap_inner_curve)","counters":[]},{"line":"  module Ops = Plonk_curve_ops.Make (Impl) (Inner_curve)","counters":[]},{"line":"","counters":[]},{"line":"  let product m f = List.reduce_exn (List.init m ~f) ~f:Field.( * )","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"","counters":[]},{"line":"  let absorb sponge ty t =","counters":[]},{"line":"    absorb","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ~mask_g1_opt:(fun () -> assert false)","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"      ~absorb_field:(Sponge.absorb sponge)","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"      ~g1_to_field_elements:Inner_curve.to_field_elements","counters":[]},{"line":"      ~absorb_scalar:(Sponge.absorb sponge) ty t","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"","counters":[]},{"line":"  let scalar_to_field s =","counters":[]},{"line":"    SC.to_field_checked (module Impl) s ~endo:Endo.Step_inner_curve.scalar","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let assert_n_bits ~n a =","counters":[]},{"line":"    (* Scalar_challenge.to_field_checked has the side effect of","counters":[]},{"line":"        checking that the input fits in n bits. *)","counters":[]},{"line":"    ignore","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ( SC.to_field_checked","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"          (module Impl)","counters":[]},{"line":"          (SC.SC.create a) ~endo:Endo.Step_inner_curve.scalar ~num_bits:n","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"        : Field.t )","counters":[]},{"line":"","counters":[]},{"line":"  let lowest_128_bits ~constrain_low_bits x =","counters":[]},{"line":"    let assert_128_bits = assert_n_bits ~n:128 in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Util.lowest_128_bits ~constrain_low_bits ~assert_128_bits (module Impl) x","counters":[]},{"line":"","counters":[]},{"line":"  let squeeze_challenge sponge : Field.t =","counters":[]},{"line":"    lowest_128_bits (* I think you may not have to constrain these actually *)","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ~constrain_low_bits:true (Sponge.squeeze sponge)","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"","counters":[]},{"line":"  let squeeze_scalar sponge : Field.t SC.SC.t =","counters":[]},{"line":"    (* No need to boolean constrain scalar challenges. *)","counters":[]},{"line":"    SC.SC.create","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (lowest_128_bits ~constrain_low_bits:false (Sponge.squeeze sponge))","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"","counters":[]},{"line":"  let bullet_reduce sponge gammas =","counters":[]},{"line":"    let absorb t = absorb sponge t in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"    let prechallenges =","counters":[]},{"line":"      Array.map gammas ~f:(fun gammas_i ->","counters":[]},{"line":"          absorb (PC :: PC) gammas_i ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          squeeze_scalar sponge )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    in","counters":[]},{"line":"    let term_and_challenge (l, r) pre =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let left_term = Scalar_challenge.endo_inv l pre in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let right_term = Scalar_challenge.endo r pre in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      ( Ops.add_fast left_term right_term","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"      , { Bulletproof_challenge.prechallenge = pre } )","counters":[]},{"line":"    in","counters":[]},{"line":"    let terms, challenges =","counters":[]},{"line":"      Array.map2_exn gammas prechallenges ~f:term_and_challenge |> Array.unzip","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"    in","counters":[]},{"line":"    (Array.reduce_exn terms ~f:Ops.add_fast, challenges)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":20,"col_end":20,"count":0}]},{"line":"","counters":[]},{"line":"  let equal_g g1 g2 =","counters":[]},{"line":"    List.map2_exn ~f:Field.equal","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":16,"col_end":16,"count":0}]},{"line":"      (Inner_curve.to_field_elements g1)","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"      (Inner_curve.to_field_elements g2)","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"    |> Boolean.all","counters":[]},{"line":"","counters":[]},{"line":"  module One_hot_vector = One_hot_vector.Make (Impl)","counters":[]},{"line":"","counters":[]},{"line":"  type 'a index' = 'a Plonk_verification_key_evals.t","counters":[]},{"line":"","counters":[]},{"line":"  type 'a index = 'a Plonk_verification_key_evals.t","counters":[]},{"line":"","counters":[]},{"line":"  (* Mask out the given vector of indices with the given one-hot vector *)","counters":[]},{"line":"  let choose_key :","counters":[]},{"line":"      type n.","counters":[]},{"line":"         n One_hot_vector.t","counters":[]},{"line":"      -> (Inner_curve.t index', n) Vector.t","counters":[]},{"line":"      -> Inner_curve.t index' =","counters":[]},{"line":"    let open Tuple_lib in","counters":[]},{"line":"    let map = Plonk_verification_key_evals.map in","counters":[]},{"line":"    let map2 = Plonk_verification_key_evals.map2 in","counters":[]},{"line":"    fun bs keys ->","counters":[]},{"line":"      let open Field in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Vector.map2","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"        (bs :> (Boolean.var, n) Vector.t)","counters":[]},{"line":"        keys","counters":[]},{"line":"        ~f:(fun b key -> map key ~f:(fun g -> Double.map g ~f:(( * ) (b :> t))))","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"      |> Vector.reduce_exn ~f:(map2 ~f:(Double.map2 ~f:( + )))","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"      |> map ~f:(fun g -> Double.map ~f:(Util.seal (module Impl)) g)","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"","counters":[]},{"line":"  (* TODO: Unify with the code in step_verifier *)","counters":[]},{"line":"  let lagrange (type n)","counters":[]},{"line":"      ~domain:","counters":[]},{"line":"        ( (which_branch : n One_hot_vector.t)","counters":[]},{"line":"        , (domains : (Domains.t, n) Vector.t) ) i =","counters":[]},{"line":"    Vector.map domains ~f:(fun d ->","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":13,"col_end":13,"count":0}]},{"line":"        let d =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Precomputed.Lagrange_precomputations.index_of_domain_log2","counters":[]},{"line":"            (Domain.log2_size d.h)","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"        in","counters":[]},{"line":"        match Precomputed.Lagrange_precomputations.vesta.(d).(i) with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | [| g |] ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let g = Inner_curve.Constant.of_affine g in","counters":[]},{"line":"            Inner_curve.constant g","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"        | _ ->","counters":[]},{"line":"            assert false )","counters":[]},{"line":"    |> Vector.map2","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"         (which_branch :> (Boolean.var, n) Vector.t)","counters":[]},{"line":"         ~f:(fun b (x, y) -> Field.((b :> t) * x, (b :> t) * y))","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"    |> Vector.reduce_exn ~f:(Double.map2 ~f:Field.( + ))","counters":[]},{"line":"","counters":[]},{"line":"  let scaled_lagrange (type n) c","counters":[]},{"line":"      ~domain:","counters":[]},{"line":"        ( (which_branch : n One_hot_vector.t)","counters":[]},{"line":"        , (domains : (Domains.t, n) Vector.t) ) i =","counters":[]},{"line":"    Vector.map domains ~f:(fun d ->","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":13,"col_end":13,"count":0}]},{"line":"        let d =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Precomputed.Lagrange_precomputations.index_of_domain_log2","counters":[]},{"line":"            (Domain.log2_size d.h)","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"        in","counters":[]},{"line":"        match Precomputed.Lagrange_precomputations.vesta.(d).(i) with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | [| g |] ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let g = Inner_curve.Constant.of_affine g in","counters":[]},{"line":"            Inner_curve.Constant.scale g c |> Inner_curve.constant","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"        | _ ->","counters":[]},{"line":"            assert false )","counters":[]},{"line":"    |> Vector.map2","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"         (which_branch :> (Boolean.var, n) Vector.t)","counters":[]},{"line":"         ~f:(fun b (x, y) -> Field.((b :> t) * x, (b :> t) * y))","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"    |> Vector.reduce_exn ~f:(Double.map2 ~f:Field.( + ))","counters":[]},{"line":"","counters":[]},{"line":"  let lagrange_with_correction (type n) ~input_length","counters":[]},{"line":"      ~domain:","counters":[]},{"line":"        ( (which_branch : n One_hot_vector.t)","counters":[]},{"line":"        , (domains : (Domains.t, n) Vector.t) ) i : Inner_curve.t Double.t =","counters":[]},{"line":"    with_label __LOC__ (fun () ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        let actual_shift =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (* TODO: num_bits should maybe be input_length - 1. *)","counters":[]},{"line":"          Ops.bits_per_chunk * Ops.chunks_needed ~num_bits:input_length","counters":[]},{"line":"        in","counters":[]},{"line":"        let rec pow2pow x i =","counters":[]},{"line":"          if i = 0 then x else pow2pow Inner_curve.Constant.(x + x) (i - 1)","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"        in","counters":[]},{"line":"        let base_and_correction (h : Domain.t) =","counters":[]},{"line":"          let d =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Precomputed.Lagrange_precomputations.index_of_domain_log2","counters":[]},{"line":"              (Domain.log2_size h)","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"          in","counters":[]},{"line":"          match Precomputed.Lagrange_precomputations.vesta.(d).(i) with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | [| g |] ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let open Inner_curve.Constant in","counters":[]},{"line":"              let g = of_affine g in","counters":[]},{"line":"              ( Inner_curve.constant g","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"              , Inner_curve.constant (negate (pow2pow g actual_shift)) )","counters":[{"col_start":35,"col_end":35,"count":0},{"col_start":43,"col_end":43,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"          | xs ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              failwithf \"expected commitment to have length 1. got %d\"","counters":[]},{"line":"                (Array.length xs) ()","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"        in","counters":[]},{"line":"        match domains with","counters":[]},{"line":"        | [] ->","counters":[]},{"line":"            assert false","counters":[]},{"line":"        | d :: ds ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            if Vector.for_all ds ~f:(fun d' -> Domain.equal d.h d'.h) then","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"              base_and_correction d.h","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"            else","counters":[]},{"line":"              Vector.map domains ~f:(fun (ds : Domains.t) ->","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"                  base_and_correction ds.h )","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"              |> Vector.map2","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                   (which_branch :> (Boolean.var, n) Vector.t)","counters":[]},{"line":"                   ~f:(fun b pr ->","counters":[]},{"line":"                     Double.map pr ~f:(fun (x, y) ->","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                         Field.((b :> t) * x, (b :> t) * y) ) )","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"              |> Vector.reduce_exn","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"                   ~f:(Double.map2 ~f:(Double.map2 ~f:Field.( + )))","counters":[]},{"line":"              |> Double.map ~f:(Double.map ~f:(Util.seal (module Impl))) )","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"","counters":[]},{"line":"  let h_precomp =","counters":[]},{"line":"    Lazy.map ~f:Inner_curve.Scaling_precomputation.create Generators.h","counters":[{"col_start":11,"col_end":11,"count":1}]},{"line":"","counters":[]},{"line":"  let group_map =","counters":[]},{"line":"    let f =","counters":[]},{"line":"      lazy","counters":[]},{"line":"        (let module M =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"           Group_map.Bw19.Make (Field.Constant) (Field)","counters":[]},{"line":"             (struct","counters":[]},{"line":"               let params =","counters":[]},{"line":"                 Group_map.Bw19.Params.create","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"                   (module Field.Constant)","counters":[]},{"line":"                   { b = Inner_curve.Params.b }","counters":[]},{"line":"             end)","counters":[]},{"line":"         in","counters":[]},{"line":"        let open M in","counters":[]},{"line":"        Snarky_group_map.Checked.wrap","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"          (module Impl)","counters":[]},{"line":"          ~potential_xs","counters":[]},{"line":"          ~y_squared:(fun ~x ->","counters":[]},{"line":"            Field.(","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (x * x * x)","counters":[]},{"line":"              + (constant Inner_curve.Params.a * x)","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"              + constant Inner_curve.Params.b) )","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"        |> unstage )","counters":[]},{"line":"    in","counters":[]},{"line":"    fun x -> Lazy.force f x","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"  module Split_commitments = struct","counters":[]},{"line":"    module Point = struct","counters":[]},{"line":"      type t =","counters":[]},{"line":"        [ `Finite of Inner_curve.t","counters":[]},{"line":"        | `Maybe_finite of Boolean.var * Inner_curve.t ]","counters":[]},{"line":"","counters":[]},{"line":"      let finite : t -> Boolean.var = function","counters":[]},{"line":"        | `Finite _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Boolean.true_","counters":[]},{"line":"        | `Maybe_finite (b, _) ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            b","counters":[]},{"line":"","counters":[]},{"line":"      let add (p : t) (q : Inner_curve.t) =","counters":[]},{"line":"        match p with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | `Finite p ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Ops.add_fast p q","counters":[]},{"line":"        | `Maybe_finite (finite, p) ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Inner_curve.if_ finite ~then_:(Ops.add_fast p q) ~else_:q","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"","counters":[]},{"line":"      let underlying = function `Finite p -> p | `Maybe_finite (_, p) -> p","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Curve_opt = struct","counters":[]},{"line":"      type t = { point : Inner_curve.t; non_zero : Boolean.var }","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    let combine batch ~xi without_bound with_bound =","counters":[]},{"line":"      let { Curve_opt.non_zero; point } =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Pcs_batch.combine_split_commitments batch","counters":[]},{"line":"          ~scale_and_add:(fun ~(acc : Curve_opt.t) ~xi (keep, (p : Point.t)) ->","counters":[]},{"line":"            (* match acc.non_zero, keep with","counters":[]},{"line":"               | false, false -> acc","counters":[]},{"line":"               | true, false -> acc","counters":[]},{"line":"               | false, true -> { point= p; non_zero= true }","counters":[]},{"line":"               | true, true -> { point= p + xi * acc; non_zero= true }","counters":[]},{"line":"            *)","counters":[]},{"line":"            let point =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Inner_curve.(","counters":[]},{"line":"                if_ keep","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  ~then_:","counters":[]},{"line":"                    (if_ acc.non_zero","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                       ~then_:(Point.add p (Scalar_challenge.endo acc.point xi))","counters":[{"col_start":39,"col_end":39,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"                       ~else_:","counters":[]},{"line":"                         ((* In this branch, the accumulator was zero, so there is no harm in","counters":[]},{"line":"                             putting the potentially junk underlying point here. *)","counters":[]},{"line":"                          Point.underlying p ) )","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"                  ~else_:acc.point)","counters":[]},{"line":"            in","counters":[]},{"line":"            let non_zero = Boolean.(keep &&& Point.finite p ||| acc.non_zero) in","counters":[{"col_start":43,"col_end":43,"count":0},{"col_start":56,"col_end":56,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"            { Curve_opt.non_zero; point } )","counters":[]},{"line":"          ~xi","counters":[]},{"line":"          ~init:(fun (keep, p) ->","counters":[]},{"line":"            { non_zero = Boolean.(keep &&& Point.finite p)","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"            ; point = Point.underlying p","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"            } )","counters":[]},{"line":"          without_bound with_bound","counters":[]},{"line":"      in","counters":[]},{"line":"      Boolean.Assert.is_true non_zero ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      point","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let scale_fast = Ops.scale_fast","counters":[]},{"line":"","counters":[]},{"line":"  let check_bulletproof ~pcs_batch ~(sponge : Sponge.t)","counters":[]},{"line":"      ~(xi : Scalar_challenge.t)","counters":[]},{"line":"      ~(advice :","counters":[]},{"line":"         Other_field.Packed.t Shifted_value.Type1.t","counters":[]},{"line":"         Types.Step.Bulletproof.Advice.t )","counters":[]},{"line":"      ~polynomials:(without_degree_bound, with_degree_bound)","counters":[]},{"line":"      ~openings_proof:","counters":[]},{"line":"        ({ lr; delta; z_1; z_2; challenge_polynomial_commitment } :","counters":[]},{"line":"          ( Inner_curve.t","counters":[]},{"line":"          , Other_field.Packed.t Shifted_value.Type1.t )","counters":[]},{"line":"          Openings.Bulletproof.t ) =","counters":[]},{"line":"    with_label __LOC__ (fun () ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        Other_field.Packed.absorb_shifted sponge advice.combined_inner_product ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        (* combined_inner_product should be equal to","counters":[]},{"line":"           sum_i < t, r^i pows(beta_i) >","counters":[]},{"line":"           = sum_i r^i < t, pows(beta_i) >","counters":[]},{"line":"","counters":[]},{"line":"           That is checked later.","counters":[]},{"line":"        *)","counters":[]},{"line":"        let u =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let t = Sponge.squeeze_field sponge in","counters":[]},{"line":"          group_map t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"        in","counters":[]},{"line":"        let open Inner_curve in","counters":[]},{"line":"        let combined_polynomial (* Corresponds to xi in figure 7 of WTS *) =","counters":[]},{"line":"          Split_commitments.combine pcs_batch ~xi without_degree_bound","counters":[]},{"line":"            with_degree_bound","counters":[]},{"line":"        in","counters":[]},{"line":"        let scale_fast =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          scale_fast ~num_bits:Other_field.Packed.Constant.size_in_bits","counters":[]},{"line":"        in","counters":[]},{"line":"        let lr_prod, challenges = bullet_reduce sponge lr in","counters":[]},{"line":"        let p_prime =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let uc = scale_fast u advice.combined_inner_product in","counters":[]},{"line":"          combined_polynomial + uc","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        in","counters":[]},{"line":"        let q = p_prime + lr_prod in","counters":[]},{"line":"        absorb sponge PC delta ;","counters":[]},{"line":"        let c = squeeze_scalar sponge in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        (* c Q + delta = z1 (G + b U) + z2 H *)","counters":[]},{"line":"        let lhs =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let cq = Scalar_challenge.endo q c in","counters":[]},{"line":"          cq + delta","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        in","counters":[]},{"line":"        let rhs =","counters":[]},{"line":"          let b_u = scale_fast u advice.b in","counters":[]},{"line":"          let z_1_g_plus_b_u =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            scale_fast (challenge_polynomial_commitment + b_u) z_1","counters":[]},{"line":"          in","counters":[]},{"line":"          let z2_h =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            scale_fast (Inner_curve.constant (Lazy.force Generators.h)) z_2","counters":[{"col_start":43,"col_end":43,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"          in","counters":[]},{"line":"          z_1_g_plus_b_u + z2_h","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        in","counters":[]},{"line":"        (`Success (equal_g lhs rhs), challenges) )","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"  module Opt = struct","counters":[]},{"line":"    include Opt_sponge.Make (Impl) (Wrap_main_inputs.Sponge.Permutation)","counters":[]},{"line":"","counters":[]},{"line":"    let challenge (s : t) : Field.t =","counters":[]},{"line":"      lowest_128_bits (squeeze s) ~constrain_low_bits:true","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"    (* No need to boolean constrain scalar challenges. *)","counters":[]},{"line":"    let scalar_challenge (s : t) : Scalar_challenge.t =","counters":[]},{"line":"      SC.SC.create (lowest_128_bits (squeeze s) ~constrain_low_bits:false)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  (* TODO: This doesn't need to be an opt sponge *)","counters":[]},{"line":"  let absorb sponge ty t =","counters":[]},{"line":"    Util.absorb ~absorb_field:(Opt.absorb sponge)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"      ~g1_to_field_elements:(fun (b, (x, y)) -> [ (b, x); (b, y) ])","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"      ~absorb_scalar:(fun x -> Opt.absorb sponge (Boolean.true_, x))","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"      ~mask_g1_opt:(fun ((finite : Boolean.var), (x, y)) ->","counters":[]},{"line":"        (Boolean.true_, Field.((finite :> t) * x, (finite :> t) * y)) )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      ty t","counters":[]},{"line":"","counters":[]},{"line":"  module Pseudo = Pseudo.Make (Impl)","counters":[]},{"line":"","counters":[]},{"line":"  let mask (type n) (lengths : (int, n) Vector.t) (choice : n One_hot_vector.t)","counters":[]},{"line":"      : Boolean.var array =","counters":[]},{"line":"    let max =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Option.value_exn","counters":[]},{"line":"        (List.max_elt ~compare:Int.compare (Vector.to_list lengths))","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"    in","counters":[]},{"line":"    let length = Pseudo.choose (choice, lengths) ~f:Field.of_int in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let (T max) = Nat.of_int max in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Vector.to_array (ones_vector (module Impl) ~first_zero:length max)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"","counters":[]},{"line":"  module Plonk = Types.Wrap.Proof_state.Deferred_values.Plonk","counters":[]},{"line":"","counters":[]},{"line":"  (* Just for exhaustiveness over fields *)","counters":[]},{"line":"  let iter2 ~chal ~scalar_chal","counters":[]},{"line":"      { Plonk.Minimal.alpha = alpha_0","counters":[]},{"line":"      ; beta = beta_0","counters":[]},{"line":"      ; gamma = gamma_0","counters":[]},{"line":"      ; zeta = zeta_0","counters":[]},{"line":"      }","counters":[]},{"line":"      { Plonk.Minimal.alpha = alpha_1","counters":[]},{"line":"      ; beta = beta_1","counters":[]},{"line":"      ; gamma = gamma_1","counters":[]},{"line":"      ; zeta = zeta_1","counters":[]},{"line":"      } =","counters":[]},{"line":"    if lookup_verification_enabled then failwith \"TODO\" else () ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"    chal beta_0 beta_1 ;","counters":[]},{"line":"    chal gamma_0 gamma_1 ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    scalar_chal alpha_0 alpha_1 ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    scalar_chal zeta_0 zeta_1","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let assert_eq_marlin","counters":[]},{"line":"      (m1 : (_, Field.t Import.Scalar_challenge.t) Plonk.Minimal.t)","counters":[]},{"line":"      (m2 : (_, Scalar_challenge.t) Plonk.Minimal.t) =","counters":[]},{"line":"    iter2 m1 m2","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ~chal:(fun c1 c2 -> Field.Assert.equal c1 c2)","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"      ~scalar_chal:(fun ({ inner = t1 } : _ Import.Scalar_challenge.t)","counters":[]},{"line":"                        ({ inner = t2 } : Scalar_challenge.t) ->","counters":[]},{"line":"        Field.Assert.equal t1 t2 )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"  let incrementally_verify_proof (type b)","counters":[]},{"line":"      (module Max_proofs_verified : Nat.Add.Intf with type n = b)","counters":[]},{"line":"      ~actual_proofs_verified_mask ~step_domains","counters":[]},{"line":"      ~verification_key:(m : _ Plonk_verification_key_evals.t) ~xi ~sponge","counters":[]},{"line":"      ~(public_input :","counters":[]},{"line":"         [ `Field of Field.t * Boolean.var | `Packed_bits of Field.t * int ]","counters":[]},{"line":"         array ) ~(sg_old : (_, Max_proofs_verified.n) Vector.t) ~advice","counters":[]},{"line":"      ~(messages : _ Messages.In_circuit.t) ~which_branch ~openings_proof","counters":[]},{"line":"      ~(plonk : _ Types.Wrap.Proof_state.Deferred_values.Plonk.In_circuit.t) =","counters":[]},{"line":"    let T = Max_proofs_verified.eq in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let sg_old =","counters":[]},{"line":"      with_label __LOC__ (fun () ->","counters":[]},{"line":"          Vector.map2 actual_proofs_verified_mask sg_old ~f:(fun keep sg ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              [| (keep, sg) |] ) )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"    in","counters":[]},{"line":"    with_label __LOC__ (fun () ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        let sample () = Opt.challenge sponge in","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"        let sample_scalar () : Scalar_challenge.t =","counters":[]},{"line":"          Opt.scalar_challenge sponge","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        in","counters":[]},{"line":"        let index_digest =","counters":[]},{"line":"          with_label \"absorb verifier index\" (fun () ->","counters":[]},{"line":"              let index_sponge = Sponge.create sponge_params in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              Array.iter","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (Types.index_to_field_elements","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"                   ~g:(fun (z : Inputs.Inner_curve.t) ->","counters":[]},{"line":"                     List.to_array (Inner_curve.to_field_elements z) )","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"                   m )","counters":[]},{"line":"                ~f:(fun x -> Sponge.absorb index_sponge x) ;","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"              Sponge.squeeze_field index_sponge )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"        in","counters":[]},{"line":"        let open Plonk_types.Messages in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let without = Type.Without_degree_bound in","counters":[]},{"line":"        let absorb_g gs =","counters":[]},{"line":"          absorb sponge without (Array.map gs ~f:(fun g -> (Boolean.true_, g)))","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"        in","counters":[]},{"line":"        absorb sponge Field (Boolean.true_, index_digest) ;","counters":[]},{"line":"        Vector.iter ~f:(Array.iter ~f:(absorb sponge PC)) sg_old ;","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"        let x_hat =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let domain = (which_branch, step_domains) in","counters":[]},{"line":"          let public_input =","counters":[]},{"line":"            Array.concat_map public_input ~f:(function","counters":[]},{"line":"              | `Field (x, b) ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  [| `Field (x, Field.size_in_bits)","counters":[]},{"line":"                   ; `Field ((b :> Field.t), 1)","counters":[]},{"line":"                  |]","counters":[]},{"line":"              | `Packed_bits (x, n) ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  [| `Field (x, n) |] )","counters":[]},{"line":"          in","counters":[]},{"line":"          let constant_part, non_constant_part =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            List.partition_map","counters":[]},{"line":"              Array.(to_list (mapi public_input ~f:(fun i t -> (i, t))))","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"              ~f:(fun (i, t) ->","counters":[]},{"line":"                match t with","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                | `Field (Constant c, _) ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    First","counters":[]},{"line":"                      ( if Field.Constant.(equal zero) c then None","counters":[{"col_start":47,"col_end":47,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"                      else if Field.Constant.(equal one) c then","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"                        Some (lagrange ~domain i)","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"                      else","counters":[]},{"line":"                        Some","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          (scaled_lagrange ~domain","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"                             (Inner_curve.Constant.Scalar.project","counters":[{"col_start":64,"col_end":64,"count":0}]},{"line":"                                (Field.Constant.unpack c) )","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"                             i ) )","counters":[]},{"line":"                | `Field x ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    Second (i, x) )","counters":[]},{"line":"          in","counters":[]},{"line":"          with_label __LOC__ (fun () ->","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"              let terms =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                List.map non_constant_part ~f:(fun (i, x) ->","counters":[]},{"line":"                    match x with","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                    | b, 1 ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        assert_ (Constraint.boolean (b :> Field.t)) ;","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                        `Cond_add (Boolean.Unsafe.of_cvar b, lagrange ~domain i)","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":56,"col_end":56,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"                    | x, n ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        `Add_with_correction","counters":[]},{"line":"                          ( (x, n)","counters":[]},{"line":"                          , lagrange_with_correction ~input_length:n ~domain i","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                          ) )","counters":[]},{"line":"              in","counters":[]},{"line":"              let correction =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                with_label __LOC__ (fun () ->","counters":[]},{"line":"                    List.reduce_exn","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      (List.filter_map terms ~f:(function","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                        | `Cond_add _ ->","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            None","counters":[]},{"line":"                        | `Add_with_correction (_, (_, corr)) ->","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            Some corr ) )","counters":[]},{"line":"                      ~f:Ops.add_fast )","counters":[]},{"line":"              in","counters":[]},{"line":"              with_label __LOC__ (fun () ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                  let init =","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    List.fold","counters":[]},{"line":"                      (List.filter_map ~f:Fn.id constant_part)","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                      ~init:correction ~f:Ops.add_fast","counters":[]},{"line":"                  in","counters":[]},{"line":"                  List.foldi terms ~init ~f:(fun i acc term ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                      match term with","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                      | `Cond_add (b, g) ->","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          with_label __LOC__ (fun () ->","counters":[]},{"line":"                              Inner_curve.if_ b ~then_:(Ops.add_fast g acc)","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"                                ~else_:acc )","counters":[]},{"line":"                      | `Add_with_correction ((x, num_bits), (g, _)) ->","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          Ops.add_fast acc","counters":[]},{"line":"                            (Ops.scale_fast2'","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"                               (module Other_field.With_top_bit0)","counters":[]},{"line":"                               g x ~num_bits ) ) ) )","counters":[]},{"line":"          |> Inner_curve.negate","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"        in","counters":[]},{"line":"        let x_hat =","counters":[]},{"line":"          with_label \"x_hat blinding\" (fun () ->","counters":[]},{"line":"              Ops.add_fast x_hat","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (Inner_curve.constant (Lazy.force Generators.h)) )","counters":[{"col_start":36,"col_end":36,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"        in","counters":[]},{"line":"        absorb sponge PC (Boolean.true_, x_hat) ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let w_comm = messages.w_comm in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Vector.iter ~f:absorb_g w_comm ;","counters":[]},{"line":"        let beta = sample () in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let gamma = sample () in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let z_comm = messages.z_comm in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        absorb_g z_comm ;","counters":[]},{"line":"        let alpha = sample_scalar () in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let t_comm :","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            (Inputs.Impl.Field.t * Inputs.Impl.Field.t)","counters":[]},{"line":"            Pickles_types__Plonk_types.Poly_comm.Without_degree_bound.t =","counters":[]},{"line":"          messages.t_comm","counters":[]},{"line":"        in","counters":[]},{"line":"        absorb_g t_comm ;","counters":[]},{"line":"        let zeta = sample_scalar () in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        (* At this point, we should use the previous \"bulletproof_challenges\" to","counters":[]},{"line":"           compute to compute f(beta_1) outside the snark","counters":[]},{"line":"           where f is the polynomial corresponding to sg_old","counters":[]},{"line":"        *)","counters":[]},{"line":"        let sponge =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          match sponge with","counters":[]},{"line":"          | { state; sponge_state; params } -> (","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              match sponge_state with","counters":[]},{"line":"              | Squeezed n ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  S.make ~state ~sponge_state:(Squeezed n) ~params","counters":[]},{"line":"              | _ ->","counters":[]},{"line":"                  assert false )","counters":[]},{"line":"        in","counters":[]},{"line":"        let sponge_before_evaluations = Sponge.copy sponge in","counters":[]},{"line":"        let sponge_digest_before_evaluations = Sponge.squeeze_field sponge in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"        (* xi, r are sampled here using the other sponge. *)","counters":[]},{"line":"        (* No need to expose the polynomial evaluations as deferred values as they're","counters":[]},{"line":"           not needed here for the incremental verification. All we need is a_hat and","counters":[]},{"line":"           \"combined_inner_product\".","counters":[]},{"line":"","counters":[]},{"line":"           Then, in the other proof, we can witness the evaluations and check their correctness","counters":[]},{"line":"           against \"combined_inner_product\" *)","counters":[]},{"line":"        let sigma_comm_init, [ _ ] =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Vector.split m.sigma_comm (snd (Permuts_minus_1.add Nat.N1.n))","counters":[{"col_start":39,"col_end":39,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"        in","counters":[]},{"line":"        let scale_fast =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          scale_fast ~num_bits:Other_field.Packed.Constant.size_in_bits","counters":[]},{"line":"        in","counters":[]},{"line":"        let ft_comm =","counters":[]},{"line":"          with_label __LOC__ (fun () ->","counters":[]},{"line":"              Common.ft_comm ~add:Ops.add_fast ~scale:scale_fast","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ~negate:Inner_curve.negate ~endoscale:Scalar_challenge.endo","counters":[]},{"line":"                ~verification_key:m ~plonk ~alpha ~t_comm )","counters":[]},{"line":"        in","counters":[]},{"line":"        let bulletproof_challenges =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (* This sponge needs to be initialized with (some derivative of)","counters":[]},{"line":"             1. The polynomial commitments","counters":[]},{"line":"             2. The combined inner product","counters":[]},{"line":"             3. The challenge points.","counters":[]},{"line":"","counters":[]},{"line":"             It should be sufficient to fork the sponge after squeezing beta_3 and then to absorb","counters":[]},{"line":"             the combined inner product.","counters":[]},{"line":"          *)","counters":[]},{"line":"          let num_commitments_without_degree_bound = Nat.N26.n in","counters":[]},{"line":"          let without_degree_bound =","counters":[]},{"line":"            (* sg_old","counters":[]},{"line":"               x_hat","counters":[]},{"line":"               ft_comm","counters":[]},{"line":"               z_comm","counters":[]},{"line":"               generic selector","counters":[]},{"line":"               poseidon selector","counters":[]},{"line":"               w_comms","counters":[]},{"line":"               all but last sigma_comm","counters":[]},{"line":"            *)","counters":[]},{"line":"            Vector.append sg_old","counters":[]},{"line":"              ( [| x_hat |] :: [| ft_comm |] :: z_comm :: [| m.generic_comm |]","counters":[]},{"line":"                :: [| m.psm_comm |]","counters":[]},{"line":"                :: Vector.append w_comm","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                     (Vector.map sigma_comm_init ~f:(fun g -> [| g |]))","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"                     (snd (Columns.add Permuts_minus_1.n))","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"              |> Vector.map ~f:(Array.map ~f:(fun g -> (Boolean.true_, g))) )","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"              (snd","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                 (Max_proofs_verified.add num_commitments_without_degree_bound) )","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"          in","counters":[]},{"line":"          check_bulletproof","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ~pcs_batch:","counters":[]},{"line":"              (Common.dlog_pcs_batch","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                 (Max_proofs_verified.add num_commitments_without_degree_bound) )","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"            ~sponge:sponge_before_evaluations ~xi ~advice ~openings_proof","counters":[]},{"line":"            ~polynomials:","counters":[]},{"line":"              ( Vector.map without_degree_bound","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                  ~f:(Array.map ~f:(fun (keep, x) -> (keep, `Finite x)))","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"              , [] )","counters":[]},{"line":"        in","counters":[]},{"line":"        let joint_combiner =","counters":[]},{"line":"          if lookup_verification_enabled then failwith \"TODO\" else None","counters":[{"col_start":46,"col_end":46,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"        in","counters":[]},{"line":"        assert_eq_marlin","counters":[]},{"line":"          { alpha = plonk.alpha","counters":[]},{"line":"          ; beta = plonk.beta","counters":[]},{"line":"          ; gamma = plonk.gamma","counters":[]},{"line":"          ; zeta = plonk.zeta","counters":[]},{"line":"          ; joint_combiner","counters":[]},{"line":"          }","counters":[]},{"line":"          { alpha; beta; gamma; zeta; joint_combiner } ;","counters":[]},{"line":"        (sponge_digest_before_evaluations, bulletproof_challenges) )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"  let mask_evals (type n) ~(lengths : (int, n) Vector.t Evals.t)","counters":[]},{"line":"      (choice : n One_hot_vector.t) (e : Field.t array Evals.t) :","counters":[]},{"line":"      (Boolean.var * Field.t) array Evals.t =","counters":[]},{"line":"    Evals.map2 lengths e ~f:(fun lengths e ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        Array.zip_exn (mask lengths choice) e )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"","counters":[]},{"line":"  let compute_challenges ~scalar chals =","counters":[]},{"line":"    Vector.map chals ~f:(fun { Bulletproof_challenge.prechallenge } ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        scalar prechallenge )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"  let challenge_polynomial = Field.(challenge_polynomial ~add ~mul ~one)","counters":[]},{"line":"","counters":[]},{"line":"  let pow2pow (pt : Field.t) (n : int) : Field.t =","counters":[]},{"line":"    with_label __LOC__ (fun () ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        let rec go acc i =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          if i = 0 then acc else go (Field.square acc) (i - 1)","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"        in","counters":[]},{"line":"        go pt n )","counters":[]},{"line":"","counters":[]},{"line":"  let actual_evaluation (e : Field.t array) ~(pt_to_n : Field.t) : Field.t =","counters":[]},{"line":"    with_label __LOC__ (fun () ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        match List.rev (Array.to_list e) with","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"        | e :: es ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            List.fold ~init:e es ~f:(fun acc y ->","counters":[]},{"line":"                let acc' =","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  exists Field.typ ~compute:(fun () ->","counters":[]},{"line":"                      As_prover.read_var Field.(y + (pt_to_n * acc)) )","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                in","counters":[]},{"line":"                (* acc' = y + pt_n * acc *)","counters":[]},{"line":"                let pt_n_acc = Field.(pt_to_n * acc) in","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                let open","counters":[]},{"line":"                  Kimchi_backend_common.Plonk_constraint_system.Plonk_constraint in","counters":[]},{"line":"                (* 0 = - acc' + y + pt_n_acc *)","counters":[]},{"line":"                let open Field.Constant in","counters":[]},{"line":"                assert_","counters":[]},{"line":"                  { annotation = None","counters":[]},{"line":"                  ; basic =","counters":[]},{"line":"                      T","counters":[]},{"line":"                        (Basic","counters":[]},{"line":"                           { l = (one, y)","counters":[]},{"line":"                           ; r = (one, pt_n_acc)","counters":[]},{"line":"                           ; o = (negate one, acc')","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"                           ; m = zero","counters":[]},{"line":"                           ; c = zero","counters":[]},{"line":"                           } )","counters":[]},{"line":"                  } ;","counters":[]},{"line":"                acc' )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"        | [] ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            failwith \"empty list\" )","counters":[]},{"line":"","counters":[]},{"line":"  let shift1 =","counters":[]},{"line":"    Shifted_value.Type1.Shift.(","counters":[]},{"line":"      map ~f:Field.constant (create (module Field.Constant)))","counters":[{"col_start":8,"col_end":8,"count":1},{"col_start":34,"col_end":34,"count":1}]},{"line":"","counters":[]},{"line":"  let shift2 =","counters":[]},{"line":"    Shifted_value.Type2.Shift.(","counters":[]},{"line":"      map ~f:Field.constant (create (module Field.Constant)))","counters":[{"col_start":8,"col_end":8,"count":1},{"col_start":34,"col_end":34,"count":1}]},{"line":"","counters":[]},{"line":"  let%test_unit \"endo scalar\" =","counters":[]},{"line":"    SC.test (module Impl) ~endo:Endo.Step_inner_curve.scalar","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let map_plonk_to_field plonk =","counters":[]},{"line":"    Types.Step.Proof_state.Deferred_values.Plonk.In_circuit.map_challenges","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":73,"col_end":73,"count":0}]},{"line":"      ~f:(Util.seal (module Impl))","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"      ~scalar:scalar_to_field plonk","counters":[]},{"line":"    |> Types.Step.Proof_state.Deferred_values.Plonk.In_circuit.map_fields","counters":[]},{"line":"         ~f:(Shifted_value.Type2.map ~f:(Util.seal (module Impl)))","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"","counters":[]},{"line":"  module Plonk_checks = struct","counters":[]},{"line":"    include Plonk_checks","counters":[]},{"line":"    include Plonk_checks.Make (Shifted_value.Type2) (Plonk_checks.Scalars.Tock)","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let field_array_if b ~then_ ~else_ =","counters":[]},{"line":"    Array.map2_exn then_ else_ ~f:(fun x1 x2 -> Field.if_ b ~then_:x1 ~else_:x2)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"","counters":[]},{"line":"  (* This finalizes the \"deferred values\" coming from a previous proof over the same field.","counters":[]},{"line":"     It","counters":[]},{"line":"     1. Checks that [xi] and [r] where sampled correctly. I.e., by absorbing all the","counters":[]},{"line":"     evaluation openings and then squeezing.","counters":[]},{"line":"     2. Checks that the \"combined inner product\" value used in the elliptic curve part of","counters":[]},{"line":"     the opening proof was computed correctly, in terms of the evaluation openings and the","counters":[]},{"line":"     evaluation points.","counters":[]},{"line":"     3. Check that the \"b\" value was computed correctly.","counters":[]},{"line":"     4. Perform the arithmetic checks from marlin. *)","counters":[]},{"line":"  let finalize_other_proof (type b)","counters":[]},{"line":"      (module Proofs_verified : Nat.Add.Intf with type n = b) ~domain ~sponge","counters":[]},{"line":"      ~(old_bulletproof_challenges : (_, b) Vector.t)","counters":[]},{"line":"      ({ xi; combined_inner_product; bulletproof_challenges; b; plonk } :","counters":[]},{"line":"        ( _","counters":[]},{"line":"        , _","counters":[]},{"line":"        , _ Shifted_value.Type2.t","counters":[]},{"line":"        , _","counters":[]},{"line":"        , _ )","counters":[]},{"line":"        Types.Step.Proof_state.Deferred_values.In_circuit.t )","counters":[]},{"line":"      { Plonk_types.All_evals.In_circuit.ft_eval1; evals } =","counters":[]},{"line":"    let T = Proofs_verified.eq in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let open Vector in","counters":[]},{"line":"    (* You use the NEW bulletproof challenges to check b. Not the old ones. *)","counters":[]},{"line":"    let open Field in","counters":[]},{"line":"    let plonk = map_plonk_to_field plonk in","counters":[]},{"line":"    let zetaw = Field.mul domain#generator plonk.zeta in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"    let sg_evals1, sg_evals2 =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let sg_olds =","counters":[]},{"line":"        Vector.map old_bulletproof_challenges ~f:(fun chals ->","counters":[]},{"line":"            unstage (challenge_polynomial (Vector.to_array chals)) )","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"      in","counters":[]},{"line":"      let sg_evals pt = Vector.map sg_olds ~f:(fun f -> f pt) in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"      (sg_evals plonk.zeta, sg_evals zetaw)","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"    in","counters":[]},{"line":"    let sponge_state =","counters":[]},{"line":"      (* Absorb bulletproof challenges *)","counters":[]},{"line":"      let challenge_digest =","counters":[]},{"line":"        let sponge = Sponge.create sponge_params in","counters":[]},{"line":"        Vector.iter old_bulletproof_challenges","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ~f:(Vector.iter ~f:(Sponge.absorb sponge)) ;","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"        Sponge.squeeze sponge","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"      in","counters":[]},{"line":"      Sponge.absorb sponge challenge_digest ;","counters":[]},{"line":"      Sponge.absorb sponge ft_eval1 ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Sponge.absorb sponge (fst evals.public_input) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"      Sponge.absorb sponge (snd evals.public_input) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"      let xs = Evals.In_circuit.to_absorption_sequence evals.evals in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Plonk_types.Opt.Early_stop_sequence.fold field_array_if xs ~init:()","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"        ~f:(fun () (x1, x2) ->","counters":[]},{"line":"          let absorb = Array.iter ~f:(Sponge.absorb sponge) in","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"          absorb x1 ; absorb x2 )","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"        ~finish:(fun () -> Array.copy sponge.state)","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"    in","counters":[]},{"line":"    sponge.state <- sponge_state ;","counters":[]},{"line":"    let xi_actual = squeeze_scalar sponge in","counters":[]},{"line":"    let r_actual = squeeze_challenge sponge in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let xi_correct =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      with_label __LOC__ (fun () ->","counters":[]},{"line":"          let { SC.SC.inner = xi_actual } = xi_actual in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let { SC.SC.inner = xi } = xi in","counters":[]},{"line":"          (* Sample new sg challenge point here *)","counters":[]},{"line":"          Field.equal xi_actual xi )","counters":[]},{"line":"    in","counters":[]},{"line":"    let xi = scalar_to_field xi in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    (* TODO: r actually does not need to be a scalar challenge. *)","counters":[]},{"line":"    let r = scalar_to_field (SC.SC.create r_actual) in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"    let plonk_minimal =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Plonk.to_minimal plonk ~to_option:Plonk_types.Opt.to_option","counters":[]},{"line":"    in","counters":[]},{"line":"    let combined_evals =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let n = Common.Max_degree.wrap_log2 in","counters":[]},{"line":"      (* TODO: zeta_n is recomputed in [env] below *)","counters":[]},{"line":"      let zeta_n = pow2pow plonk.zeta n in","counters":[]},{"line":"      let zetaw_n = pow2pow zetaw n in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Evals.In_circuit.map evals.evals ~f:(fun (x0, x1) ->","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"          ( actual_evaluation ~pt_to_n:zeta_n x0","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"          , actual_evaluation ~pt_to_n:zetaw_n x1 ) )","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"    in","counters":[]},{"line":"    let env =","counters":[]},{"line":"      Plonk_checks.scalars_env","counters":[]},{"line":"        (module Field)","counters":[]},{"line":"        ~srs_length_log2:Common.Max_degree.wrap_log2","counters":[]},{"line":"        ~endo:(Impl.Field.constant Endo.Wrap_inner_curve.base)","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"        ~mds:sponge_params.mds","counters":[]},{"line":"        ~field_of_hex:(fun s ->","counters":[]},{"line":"          Kimchi_pasta.Pasta.Bigint256.of_hex_string s","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"          |> Kimchi_pasta.Pasta.Fq.of_bigint |> Field.constant )","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"        ~domain plonk_minimal combined_evals","counters":[]},{"line":"    in","counters":[]},{"line":"    let combined_inner_product_correct =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let evals1, evals2 =","counters":[]},{"line":"        All_evals.With_public_input.In_circuit.factor evals","counters":[]},{"line":"      in","counters":[]},{"line":"      with_label __LOC__ (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"          let ft_eval0 : Field.t =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            with_label __LOC__ (fun () ->","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                Plonk_checks.ft_eval0","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  (module Field)","counters":[]},{"line":"                  ~lookup_constant_term_part:None ~env ~domain plonk_minimal","counters":[]},{"line":"                  combined_evals evals1.public_input )","counters":[]},{"line":"          in","counters":[]},{"line":"          (* sum_i r^i sum_j xi^j f_j(beta_i) *)","counters":[]},{"line":"          let actual_combined_inner_product =","counters":[]},{"line":"            let combine ~ft ~sg_evals x_hat","counters":[]},{"line":"                (e : (Field.t array, _) Evals.In_circuit.t) =","counters":[]},{"line":"              let a =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Evals.In_circuit.to_list e","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"                |> List.map ~f:(function","counters":[]},{"line":"                     | None ->","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                         [||]","counters":[]},{"line":"                     | Some a ->","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                         Array.map a ~f:(fun x -> Plonk_types.Opt.Some x)","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                     | Maybe (b, a) ->","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                         Array.map a ~f:(fun x -> Plonk_types.Opt.Maybe (b, x)) )","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"              in","counters":[]},{"line":"              let sg_evals =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Vector.map sg_evals ~f:(fun x -> [| Plonk_types.Opt.Some x |])","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"                |> Vector.to_list","counters":[]},{"line":"                (* TODO: This was the code before the wrap hack was put in","counters":[]},{"line":"                   match actual_proofs_verified with","counters":[]},{"line":"                   | None ->","counters":[]},{"line":"                       Vector.map sg_olds ~f:(fun f -> [| f pt |])","counters":[]},{"line":"                   | Some proofs_verified ->","counters":[]},{"line":"                       let mask =","counters":[]},{"line":"                         ones_vector","counters":[]},{"line":"                           (module Impl)","counters":[]},{"line":"                           ~first_zero:proofs_verified (Vector.length sg_olds)","counters":[]},{"line":"                       in","counters":[]},{"line":"                       with_label __LOC__ (fun () ->","counters":[]},{"line":"                           Vector.map2 mask sg_olds ~f:(fun b f ->","counters":[]},{"line":"                               [| Field.((b :> t) * f pt) |] ) ) *)","counters":[]},{"line":"              in","counters":[]},{"line":"              let v =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                List.append sg_evals ([| Some x_hat |] :: [| Some ft |] :: a)","counters":[]},{"line":"              in","counters":[]},{"line":"              Common.combined_evaluation (module Impl) ~xi v","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"            in","counters":[]},{"line":"            combine ~ft:ft_eval0 ~sg_evals:sg_evals1 evals1.public_input","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"              evals1.evals","counters":[]},{"line":"            + r","counters":[]},{"line":"              * combine ~ft:ft_eval1 ~sg_evals:sg_evals2 evals2.public_input","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                  evals2.evals","counters":[]},{"line":"          in","counters":[]},{"line":"          with_label __LOC__ (fun () ->","counters":[]},{"line":"              equal","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (Shifted_value.Type2.to_field","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"                   (module Field)","counters":[]},{"line":"                   ~shift:shift2 combined_inner_product )","counters":[]},{"line":"                actual_combined_inner_product ) )","counters":[]},{"line":"    in","counters":[]},{"line":"    let bulletproof_challenges =","counters":[]},{"line":"      with_label __LOC__ (fun () ->","counters":[]},{"line":"          compute_challenges ~scalar:scalar_to_field bulletproof_challenges )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    in","counters":[]},{"line":"    let b_correct =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      with_label __LOC__ (fun () ->","counters":[]},{"line":"          let challenge_poly =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            unstage","counters":[]},{"line":"              (challenge_polynomial (Vector.to_array bulletproof_challenges))","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"          in","counters":[]},{"line":"          let b_actual =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            challenge_poly plonk.zeta + (r * challenge_poly zetaw)","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"          in","counters":[]},{"line":"          equal","counters":[]},{"line":"            (Shifted_value.Type2.to_field (module Field) ~shift:shift2 b)","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"            b_actual )","counters":[]},{"line":"    in","counters":[]},{"line":"    let plonk_checks_passed =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      with_label __LOC__ (fun () ->","counters":[]},{"line":"          Plonk_checks.checked","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (module Impl)","counters":[]},{"line":"            ~env ~shift:shift2 plonk combined_evals )","counters":[]},{"line":"    in","counters":[]},{"line":"    print_bool \"xi_correct\" xi_correct ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    print_bool \"combined_inner_product_correct\" combined_inner_product_correct ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    print_bool \"plonk_checks_passed\" plonk_checks_passed ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    print_bool \"b_correct\" b_correct ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    ( Boolean.all","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":16,"col_end":16,"count":0}]},{"line":"        [ xi_correct","counters":[]},{"line":"        ; b_correct","counters":[]},{"line":"        ; combined_inner_product_correct","counters":[]},{"line":"        ; plonk_checks_passed","counters":[]},{"line":"        ]","counters":[]},{"line":"    , bulletproof_challenges )","counters":[]},{"line":"","counters":[]},{"line":"  let map_challenges","counters":[]},{"line":"      { Types.Step.Proof_state.Deferred_values.plonk","counters":[]},{"line":"      ; combined_inner_product","counters":[]},{"line":"      ; xi","counters":[]},{"line":"      ; bulletproof_challenges","counters":[]},{"line":"      ; b","counters":[]},{"line":"      } ~f ~scalar =","counters":[]},{"line":"    { Types.Step.Proof_state.Deferred_values.plonk =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        Types.Step.Proof_state.Deferred_values.Plonk.In_circuit.map_challenges","counters":[{"col_start":77,"col_end":77,"count":0}]},{"line":"          plonk ~f ~scalar","counters":[]},{"line":"    ; combined_inner_product","counters":[]},{"line":"    ; bulletproof_challenges =","counters":[]},{"line":"        Vector.map bulletproof_challenges","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"          ~f:(fun (r : _ Bulletproof_challenge.t) ->","counters":[]},{"line":"            { Bulletproof_challenge.prechallenge = scalar r.prechallenge } )","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"    ; xi = scalar xi","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"    ; b","counters":[]},{"line":"    }","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}