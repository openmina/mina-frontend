{"filename":"src/lib/consensus/global_slot.ml","lines":[{"line":"open Unsigned","counters":[]},{"line":"open Core","counters":[]},{"line":"open Snark_params.Tick","counters":[]},{"line":"module Wire_types = Mina_wire_types.Consensus_global_slot","counters":[]},{"line":"","counters":[]},{"line":"module Make_sig (A : Wire_types.Types.S) = struct","counters":[]},{"line":"  module type S =","counters":[]},{"line":"    Global_slot_intf.Full","counters":[]},{"line":"      with type ('slot_number, 'slots_per_epoch) Poly.Stable.V1.t =","counters":[]},{"line":"        ('slot_number, 'slots_per_epoch) A.Poly.V1.t","counters":[]},{"line":"       and type Stable.V1.t = A.V1.t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make_str (A : Wire_types.Concrete) = struct","counters":[]},{"line":"  module T = Mina_numbers.Global_slot","counters":[]},{"line":"  module Length = Mina_numbers.Length","counters":[]},{"line":"","counters":[]},{"line":"  module Poly = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type ('slot_number, 'slots_per_epoch) t =","counters":[{"col_start":8,"col_end":8,"count":5},{"col_start":46,"col_end":46,"count":5}]},{"line":"              ('slot_number, 'slots_per_epoch) A.Poly.V1.t =","counters":[]},{"line":"          { slot_number : 'slot_number; slots_per_epoch : 'slots_per_epoch }","counters":[{"col_start":12,"col_end":12,"count":4},{"col_start":22,"col_end":22,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":40,"col_end":40,"count":4},{"col_start":54,"col_end":54,"count":0},{"col_start":73,"col_end":73,"count":0}]},{"line":"        [@@deriving sexp, equal, compare, hash, yojson, hlist]","counters":[{"col_start":61,"col_end":61,"count":3}]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type t = (T.Stable.V1.t, Length.Stable.V1.t) Poly.Stable.V1.t","counters":[{"col_start":6,"col_end":6,"count":2},{"col_start":11,"col_end":11,"count":1},{"col_start":15,"col_end":15,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"      [@@deriving sexp, equal, compare, hash, yojson]","counters":[{"col_start":52,"col_end":52,"count":5}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  type value = t [@@deriving sexp, compare, hash, yojson]","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"","counters":[]},{"line":"  type var = (T.Checked.t, Length.Checked.t) Poly.t","counters":[]},{"line":"","counters":[]},{"line":"  let typ =","counters":[]},{"line":"    Typ.of_hlistable","counters":[{"col_start":19,"col_end":19,"count":1}]},{"line":"      [ T.Checked.typ; Length.Checked.typ ]","counters":[]},{"line":"      ~var_to_hlist:Poly.to_hlist ~var_of_hlist:Poly.of_hlist","counters":[]},{"line":"      ~value_to_hlist:Poly.to_hlist ~value_of_hlist:Poly.of_hlist","counters":[]},{"line":"","counters":[]},{"line":"  let to_input (t : value) =","counters":[]},{"line":"    Array.reduce_exn ~f:Random_oracle.Input.Chunked.append","counters":[{"col_start":4,"col_end":4,"count":5}]},{"line":"      [| T.to_input t.slot_number; Length.to_input t.slots_per_epoch |]","counters":[{"col_start":18,"col_end":18,"count":5},{"col_start":49,"col_end":49,"count":5}]},{"line":"","counters":[]},{"line":"  let gen ~(constants : Constants.t) =","counters":[]},{"line":"    let open Quickcheck.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let slots_per_epoch = constants.slots_per_epoch in","counters":[]},{"line":"    let%map slot_number = T.gen in","counters":[]},{"line":"    { Poly.slot_number; slots_per_epoch }","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let create ~(constants : Constants.t) ~(epoch : Epoch.t) ~(slot : Slot.t) : t","counters":[]},{"line":"      =","counters":[]},{"line":"    { slot_number = UInt32.Infix.(slot + (constants.slots_per_epoch * epoch))","counters":[{"col_start":4,"col_end":4,"count":4}]},{"line":"    ; slots_per_epoch = constants.slots_per_epoch","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let of_epoch_and_slot ~(constants : Constants.t) (epoch, slot) =","counters":[]},{"line":"    create ~epoch ~slot ~constants","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let zero ~(constants : Constants.t) : t =","counters":[]},{"line":"    { slot_number = T.zero; slots_per_epoch = constants.slots_per_epoch }","counters":[{"col_start":4,"col_end":4,"count":4}]},{"line":"","counters":[]},{"line":"  let slot_number { Poly.slot_number; _ } = slot_number","counters":[{"col_start":44,"col_end":44,"count":9}]},{"line":"","counters":[]},{"line":"  let slots_per_epoch { Poly.slots_per_epoch; _ } = slots_per_epoch","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"","counters":[]},{"line":"  let epoch (t : t) = UInt32.Infix.(t.slot_number / t.slots_per_epoch)","counters":[{"col_start":22,"col_end":22,"count":4}]},{"line":"","counters":[]},{"line":"  let slot (t : t) = UInt32.Infix.(t.slot_number mod t.slots_per_epoch)","counters":[{"col_start":21,"col_end":21,"count":4}]},{"line":"","counters":[]},{"line":"  let to_epoch_and_slot t = (epoch t, slot t)","counters":[{"col_start":28,"col_end":28,"count":4},{"col_start":33,"col_end":33,"count":4},{"col_start":41,"col_end":41,"count":4}]},{"line":"","counters":[]},{"line":"  let ( + ) (x : t) n : t =","counters":[]},{"line":"    { x with slot_number = T.add x.slot_number (T.of_int n) }","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"","counters":[]},{"line":"  let ( < ) (t : t) (t' : t) = UInt32.compare t.slot_number t'.slot_number < 0","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"  let ( - ) (t : t) (t' : t) = T.sub t.slot_number t'.slot_number","counters":[{"col_start":31,"col_end":31,"count":2}]},{"line":"","counters":[]},{"line":"  let max (t1 : t) (t2 : t) = if t1 < t2 then t2 else t1","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":46,"col_end":46,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"","counters":[]},{"line":"  let succ (t : t) = { t with slot_number = T.succ t.slot_number }","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"","counters":[]},{"line":"  let of_slot_number ~(constants : Constants.t) slot_number =","counters":[]},{"line":"    { Poly.slot_number; slots_per_epoch = constants.slots_per_epoch }","counters":[{"col_start":4,"col_end":4,"count":2}]},{"line":"","counters":[]},{"line":"  let start_time ~(constants : Constants.t) t =","counters":[]},{"line":"    let epoch, slot = to_epoch_and_slot t in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Epoch.slot_start_time epoch slot ~constants","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let end_time ~(constants : Constants.t) t =","counters":[]},{"line":"    let epoch, slot = to_epoch_and_slot t in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Epoch.slot_end_time epoch slot ~constants","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let time_hum t =","counters":[]},{"line":"    let epoch, slot = to_epoch_and_slot t in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    sprintf \"epoch=%d, slot=%d\" (Epoch.to_int epoch) (Slot.to_int slot)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"","counters":[]},{"line":"  let of_time_exn ~(constants : Constants.t) time =","counters":[]},{"line":"    of_epoch_and_slot","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (Epoch.epoch_and_slot_of_time_exn time ~constants)","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"      ~constants","counters":[]},{"line":"","counters":[]},{"line":"  let diff ~(constants : Constants.t) (t : t) (other_epoch, other_slot) =","counters":[]},{"line":"    let open UInt32.Infix in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let epoch, slot = to_epoch_and_slot t in","counters":[]},{"line":"    let old_epoch =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      epoch - other_epoch","counters":[]},{"line":"      - UInt32.(of_int @@ if compare other_slot slot > 0 then 1 else 0)","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":62,"col_end":62,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"    in","counters":[]},{"line":"    let old_slot =","counters":[]},{"line":"      (slot - other_slot) mod Length.to_uint32 constants.slots_per_epoch","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"    in","counters":[]},{"line":"    of_epoch_and_slot (old_epoch, old_slot) ~constants","counters":[]},{"line":"","counters":[]},{"line":"  module Checked = struct","counters":[]},{"line":"    type t = var","counters":[]},{"line":"","counters":[]},{"line":"    let ( < ) (t : t) (t' : t) = T.Checked.(t.slot_number < t'.slot_number)","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"","counters":[]},{"line":"    let of_slot_number ~(constants : Constants.var) slot_number : t =","counters":[]},{"line":"      { slot_number; slots_per_epoch = constants.slots_per_epoch }","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let to_input (var : t) =","counters":[]},{"line":"      Array.reduce_exn ~f:Random_oracle.Input.Chunked.append","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [| T.Checked.to_input var.slot_number","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"         ; Length.Checked.to_input var.slots_per_epoch","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"        |]","counters":[]},{"line":"","counters":[]},{"line":"    let to_epoch_and_slot (t : t) : (Epoch.Checked.t * Slot.Checked.t) Checked.t","counters":[]},{"line":"        =","counters":[]},{"line":"      let%map epoch, slot =","counters":[]},{"line":"        T.Checked.div_mod t.slot_number","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"          (T.Checked.Unsafe.of_field","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"             (Length.Checked.to_field t.slots_per_epoch) )","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"      in","counters":[]},{"line":"      ( Epoch.Checked.Unsafe.of_field (T.Checked.to_field epoch)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"      , Slot.Checked.Unsafe.of_field (T.Checked.to_field slot) )","counters":[{"col_start":35,"col_end":35,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"","counters":[]},{"line":"    let sub (t : t) (t' : t) = T.Checked.sub t.slot_number t'.slot_number","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module For_tests = struct","counters":[]},{"line":"    let of_global_slot (t : t) slot_number : t = { t with slot_number }","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"include Wire_types.Make (Make_sig) (Make_str)","counters":[{"col_start":44,"col_end":44,"count":1}]}]}