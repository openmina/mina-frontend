{"filename":"src/lib/mina_base/permissions.ml","lines":[{"line":"[%%import \"/src/config.mlh\"]","counters":[]},{"line":"","counters":[{"col_start":0,"col_end":0,"count":1}]},{"line":"open Core_kernel","counters":[]},{"line":"open Mina_base_util","counters":[]},{"line":"","counters":[]},{"line":"[%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"open Snark_params.Tick","counters":[]},{"line":"","counters":[]},{"line":"[%%endif]","counters":[]},{"line":"","counters":[]},{"line":"module Frozen_ledger_hash = Frozen_ledger_hash0","counters":[]},{"line":"module Ledger_hash = Ledger_hash0","counters":[]},{"line":"","counters":[]},{"line":"(* Semantically this type represents a function","counters":[]},{"line":"     { has_valid_signature: bool; has_valid_proof: bool } -> bool","counters":[]},{"line":"","counters":[]},{"line":"     These are all of them:","counters":[]},{"line":"     00 01 10 11 | intuitive definition       | Make sense","counters":[]},{"line":"     0  0  0  0  | Impossible                 | yes","counters":[]},{"line":"     0  0  0  1  | Both                       | yes","counters":[]},{"line":"     0  0  1  0  | Proof and not signature    | no","counters":[]},{"line":"     0  0  1  1  | Proof                      | yes","counters":[]},{"line":"     0  1  0  0  | Signature and not proof    | no","counters":[]},{"line":"     0  1  0  1  | Signature                  | yes","counters":[]},{"line":"     0  1  1  0  | Exactly one                | no","counters":[]},{"line":"     0  1  1  1  | Either                     | yes","counters":[]},{"line":"     1  0  0  0  | Neither                    | no","counters":[]},{"line":"     1  0  0  1  | Neither or both            | no","counters":[]},{"line":"     1  0  1  0  | Neither or proof, not both | no","counters":[]},{"line":"     ...","counters":[]},{"line":"     1  1  1  1  | None                       | yes","counters":[]},{"line":"","counters":[]},{"line":"     The ones marked as \"not making sense\" don't make sense because it is pointless","counters":[]},{"line":"     to demand a signature failed to verify since you can always make a failing signature","counters":[]},{"line":"     or proof.","counters":[]},{"line":"","counters":[]},{"line":"     The ones that make sense are","counters":[]},{"line":"     0  0  0  0  | Impossible                 | yes","counters":[]},{"line":"     0  0  0  1  | Both                       | yes","counters":[]},{"line":"     0  0  1  1  | Proof                      | yes","counters":[]},{"line":"     0  1  0  1  | Signature                  | yes","counters":[]},{"line":"     0  1  1  1  | Either                     | yes","counters":[]},{"line":"     1  1  1  1  | None                       | yes","counters":[]},{"line":"","counters":[]},{"line":"     \"Making sense\" can be captured by the idea that these are the *increasing*","counters":[]},{"line":"     boolean functions on the type { has_valid_signature: bool; has_valid_proof: bool }.","counters":[]},{"line":"*)","counters":[]},{"line":"module Auth_required = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V2 = struct","counters":[]},{"line":"      type t = Mina_wire_types.Mina_base.Permissions.Auth_required.V2.t =","counters":[{"col_start":6,"col_end":6,"count":2598},{"col_start":11,"col_end":11,"count":2}]},{"line":"        | None","counters":[{"col_start":8,"col_end":8,"count":312}]},{"line":"        | Either","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | Proof","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | Signature","counters":[{"col_start":8,"col_end":8,"count":3120}]},{"line":"        | Impossible (* Both and either can both be subsumed in verification key.","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"                        It is good to have \"Either\" as a separate thing to spare the owner from","counters":[]},{"line":"                        having to make a proof instead of a signature. Both, I'm not sure if there's","counters":[]},{"line":"                        a good justification for. *)","counters":[]},{"line":"      [@@deriving sexp, equal, compare, hash, yojson, enum]","counters":[{"col_start":58,"col_end":58,"count":5}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  let from ~auth_tag : t =","counters":[]},{"line":"    match auth_tag with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Control.Tag.Proof ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Proof","counters":[]},{"line":"    | Signature ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Signature","counters":[]},{"line":"    | None_given ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        None","counters":[]},{"line":"","counters":[]},{"line":"  (* permissions such that [check permission (Proof _)] is true *)","counters":[]},{"line":"  let gen_for_proof_authorization : t Quickcheck.Generator.t =","counters":[]},{"line":"    Quickcheck.Generator.of_list [ None; Either; Proof ]","counters":[{"col_start":31,"col_end":31,"count":1}]},{"line":"","counters":[]},{"line":"  (* permissions such that [check permission (Signature _)] is true *)","counters":[]},{"line":"  let gen_for_signature_authorization : t Quickcheck.Generator.t =","counters":[]},{"line":"    Quickcheck.Generator.of_list [ None; Either; Signature ]","counters":[{"col_start":31,"col_end":31,"count":1}]},{"line":"","counters":[]},{"line":"  (* permissions such that [check permission None_given] is true *)","counters":[]},{"line":"  let gen_for_none_given_authorization : t Quickcheck.Generator.t =","counters":[]},{"line":"    Quickcheck.Generator.return None","counters":[{"col_start":30,"col_end":30,"count":1}]},{"line":"","counters":[]},{"line":"  let to_string = function","counters":[]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        \"None\"","counters":[]},{"line":"    | Either ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        \"Either\"","counters":[]},{"line":"    | Proof ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        \"Proof\"","counters":[]},{"line":"    | Signature ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        \"Signature\"","counters":[]},{"line":"    | Impossible ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        \"Impossible\"","counters":[]},{"line":"","counters":[]},{"line":"  let of_string = function","counters":[]},{"line":"    | \"None\" ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Stable.Latest.None","counters":[]},{"line":"    | \"Either\" ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Either","counters":[]},{"line":"    | \"Proof\" ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Proof","counters":[]},{"line":"    | \"Signature\" ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Signature","counters":[]},{"line":"    | \"Impossible\" ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Impossible","counters":[]},{"line":"    | _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        failwith \"auth_required_of_string: unknown variant\"","counters":[]},{"line":"","counters":[]},{"line":"  (* The encoding is chosen so that it is easy to write this function","counters":[]},{"line":"","counters":[]},{"line":"      let spec_eval t ~signature_verifies =","counters":[]},{"line":"        let impossible = (constant t && not (signature_sufficient t)) in","counters":[]},{"line":"        let result =","counters":[]},{"line":"          not impossible &&","counters":[]},{"line":"          ( (signature_verifies && signature_sufficient t)","counters":[]},{"line":"            || not (signature_necessary t) )","counters":[]},{"line":"        in","counters":[]},{"line":"        { result; proof_must_verify= not (signature_sufficient t) } *)","counters":[]},{"line":"","counters":[]},{"line":"  (* Here is the mapping between our type and the bits","counters":[]},{"line":"       { constant: bool","counters":[]},{"line":"       ; signature_necessary: bool","counters":[]},{"line":"       ; signature_sufficient: bool","counters":[]},{"line":"       }","counters":[]},{"line":"","counters":[]},{"line":"       Not constant","counters":[]},{"line":"        Signature not necessary","counters":[]},{"line":"          Signature not sufficient","counters":[]},{"line":"            Proof","counters":[]},{"line":"          Signature sufficient","counters":[]},{"line":"            Either","counters":[]},{"line":"        Signature necessary","counters":[]},{"line":"          Signature not sufficient","counters":[]},{"line":"            Both","counters":[]},{"line":"          Signature sufficient","counters":[]},{"line":"            Signature","counters":[]},{"line":"","counters":[]},{"line":"       Constant","counters":[]},{"line":"        Signature not sufficient","counters":[]},{"line":"          Impossible","counters":[]},{"line":"        Signature sufficient","counters":[]},{"line":"          None","counters":[]},{"line":"  *)","counters":[]},{"line":"  module Encoding = struct","counters":[]},{"line":"    type 'bool t =","counters":[{"col_start":4,"col_end":4,"count":22},{"col_start":15,"col_end":15,"count":0}]},{"line":"      { constant : 'bool","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      ; signature_necessary : 'bool","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      ; signature_sufficient : 'bool","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      }","counters":[]},{"line":"    [@@deriving hlist, fields]","counters":[]},{"line":"","counters":[]},{"line":"    let to_input ~field_of_bool t =","counters":[]},{"line":"      let [ x; y; z ] = to_hlist t in","counters":[{"col_start":6,"col_end":6,"count":22}]},{"line":"      let bs = [| x; y; z |] in","counters":[{"col_start":6,"col_end":6,"count":22}]},{"line":"      Random_oracle.Input.Chunked.packeds","counters":[]},{"line":"        (Array.map bs ~f:(fun b -> (field_of_bool b, 1)))","counters":[{"col_start":17,"col_end":17,"count":22},{"col_start":35,"col_end":35,"count":66},{"col_start":48,"col_end":48,"count":66}]},{"line":"","counters":[]},{"line":"    let map t ~f =","counters":[]},{"line":"      { constant = f t.constant","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"      ; signature_necessary = f t.signature_necessary","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"      ; signature_sufficient = f t.signature_sufficient","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    let _ = map","counters":[]},{"line":"","counters":[]},{"line":"    [%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"    let if_ b ~then_:t ~else_:e =","counters":[]},{"line":"      let open Pickles.Impls.Step in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      { constant = Boolean.if_ b ~then_:t.constant ~else_:e.constant","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"      ; signature_necessary =","counters":[]},{"line":"          Boolean.if_ b ~then_:t.signature_necessary","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"            ~else_:e.signature_necessary","counters":[]},{"line":"      ; signature_sufficient =","counters":[]},{"line":"          Boolean.if_ b ~then_:t.signature_sufficient","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"            ~else_:e.signature_sufficient","counters":[]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    [%%endif]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let encode : t -> bool Encoding.t = function","counters":[]},{"line":"    | Impossible ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { constant = true","counters":[]},{"line":"        ; signature_necessary = true","counters":[]},{"line":"        ; signature_sufficient = false","counters":[]},{"line":"        }","counters":[]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":2}]},{"line":"        { constant = true","counters":[]},{"line":"        ; signature_necessary = false","counters":[]},{"line":"        ; signature_sufficient = true","counters":[]},{"line":"        }","counters":[]},{"line":"    | Proof ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { constant = false","counters":[]},{"line":"        ; signature_necessary = false","counters":[]},{"line":"        ; signature_sufficient = false","counters":[]},{"line":"        }","counters":[]},{"line":"    | Signature ->","counters":[{"col_start":6,"col_end":6,"count":20}]},{"line":"        { constant = false","counters":[]},{"line":"        ; signature_necessary = true","counters":[]},{"line":"        ; signature_sufficient = true","counters":[]},{"line":"        }","counters":[]},{"line":"    | Either ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { constant = false","counters":[]},{"line":"        ; signature_necessary = false","counters":[]},{"line":"        ; signature_sufficient = true","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"  let decode : bool Encoding.t -> t = function","counters":[]},{"line":"    | { constant = true; signature_necessary = _; signature_sufficient = false }","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      ->","counters":[]},{"line":"        Impossible","counters":[]},{"line":"    | { constant = true; signature_necessary = _; signature_sufficient = true }","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      ->","counters":[]},{"line":"        None","counters":[]},{"line":"    | { constant = false","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      ; signature_necessary = false","counters":[]},{"line":"      ; signature_sufficient = false","counters":[]},{"line":"      } ->","counters":[]},{"line":"        Proof","counters":[]},{"line":"    | { constant = false","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      ; signature_necessary = true","counters":[]},{"line":"      ; signature_sufficient = true","counters":[]},{"line":"      } ->","counters":[]},{"line":"        Signature","counters":[]},{"line":"    | { constant = false","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      ; signature_necessary = false","counters":[]},{"line":"      ; signature_sufficient = true","counters":[]},{"line":"      } ->","counters":[]},{"line":"        Either","counters":[]},{"line":"    | { constant = false","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      ; signature_necessary = true","counters":[]},{"line":"      ; signature_sufficient = false","counters":[]},{"line":"      } ->","counters":[]},{"line":"        failwith","counters":[]},{"line":"          \"Permissions.decode: Found encoding of Both, but Both is not an \\","counters":[]},{"line":"           exposed option\"","counters":[]},{"line":"","counters":[]},{"line":"  let%test_unit \"decode encode\" =","counters":[]},{"line":"    List.iter [ Impossible; Proof; Signature; Either ] ~f:(fun t ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        [%test_eq: t] t (decode (encode t)) )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"","counters":[]},{"line":"  [%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"  module Checked = struct","counters":[]},{"line":"    type t = Boolean.var Encoding.t","counters":[]},{"line":"","counters":[]},{"line":"    let if_ = Encoding.if_","counters":[]},{"line":"","counters":[]},{"line":"    let to_input : t -> _ =","counters":[]},{"line":"      Encoding.to_input ~field_of_bool:(fun (b : Boolean.var) ->","counters":[]},{"line":"          (b :> Field.Var.t) )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"    let constant t = Encoding.map (encode t) ~f:Boolean.var_of_value","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"    let eval_no_proof","counters":[]},{"line":"        ({ constant; signature_necessary = _; signature_sufficient } : t)","counters":[]},{"line":"        ~signature_verifies =","counters":[]},{"line":"      (* ways authorization can succeed when no proof is present:","counters":[]},{"line":"         - None","counters":[]},{"line":"           {constant= true; signature_necessary= _; signature_sufficient= true}","counters":[]},{"line":"         - Either && signature_verifies","counters":[]},{"line":"           {constant= false; signature_necessary= false; signature_sufficient= true}","counters":[]},{"line":"         - Signature && signature_verifies","counters":[]},{"line":"           {constant= false; signature_necessary= true; signature_sufficient= true}","counters":[]},{"line":"      *)","counters":[]},{"line":"      let open Pickles.Impls.Step.Boolean in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      signature_sufficient","counters":[]},{"line":"      &&& (constant ||| ((not constant) &&& signature_verifies))","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"","counters":[]},{"line":"    let eval_proof ({ constant; signature_necessary; signature_sufficient } : t)","counters":[]},{"line":"        =","counters":[]},{"line":"      (* ways authorization can succeed if a proof is present:","counters":[]},{"line":"         - None","counters":[]},{"line":"           {constant= true; signature_necessary= _; signature_sufficient= true}","counters":[]},{"line":"         - Either","counters":[]},{"line":"           {constant= false; signature_necessary= false; signature_sufficient= true}","counters":[]},{"line":"         - Proof","counters":[]},{"line":"           {constant= false; signature_necessary= false; signature_sufficient= false}","counters":[]},{"line":"      *)","counters":[]},{"line":"      let open Pickles.Impls.Step.Boolean in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let impossible = constant &&& not signature_sufficient in","counters":[]},{"line":"      (not signature_necessary) &&& not impossible","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let spec_eval ({ constant; signature_necessary; signature_sufficient } : t)","counters":[]},{"line":"        ~signature_verifies =","counters":[]},{"line":"      let open Pickles.Impls.Step.Boolean in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let impossible = constant &&& not signature_sufficient in","counters":[]},{"line":"      let result =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (not impossible)","counters":[]},{"line":"        &&& ( signature_verifies &&& signature_sufficient","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"            ||| not signature_necessary )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"      in","counters":[]},{"line":"      let didn't_fail_yet = result in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      (* If the transaction already failed to verify, we don't need to assert","counters":[]},{"line":"         that the proof should verify. *)","counters":[]},{"line":"      (result, `proof_must_verify (didn't_fail_yet &&& not signature_sufficient))","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let typ =","counters":[]},{"line":"    let t =","counters":[]},{"line":"      let open Encoding in","counters":[]},{"line":"      Typ.of_hlistable","counters":[{"col_start":21,"col_end":21,"count":1}]},{"line":"        [ Boolean.typ; Boolean.typ; Boolean.typ ]","counters":[]},{"line":"        ~var_to_hlist:to_hlist ~var_of_hlist:of_hlist ~value_to_hlist:to_hlist","counters":[]},{"line":"        ~value_of_hlist:of_hlist","counters":[]},{"line":"    in","counters":[]},{"line":"    Typ.transport t ~there:encode ~back:decode","counters":[{"col_start":16,"col_end":16,"count":1}]},{"line":"","counters":[]},{"line":"  [%%endif]","counters":[]},{"line":"","counters":[]},{"line":"  let to_input x = Encoding.to_input (encode x) ~field_of_bool","counters":[{"col_start":19,"col_end":19,"count":22},{"col_start":43,"col_end":43,"count":22}]},{"line":"","counters":[]},{"line":"  let check (t : t) (c : Control.Tag.t) =","counters":[]},{"line":"    match (t, c) with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Impossible, _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        false","counters":[]},{"line":"    | None, _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        true","counters":[]},{"line":"    | Proof, Proof ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        true","counters":[]},{"line":"    | Signature, Signature ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        true","counters":[]},{"line":"    (* The signatures and proofs have already been checked by this point. *)","counters":[]},{"line":"    | Either, (Proof | Signature) ->","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"        true","counters":[]},{"line":"    | Signature, Proof ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        false","counters":[]},{"line":"    | Proof, Signature ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        false","counters":[]},{"line":"    | (Proof | Signature | Either), None_given ->","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":7,"col_end":7,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"        false","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Poly = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V2 = struct","counters":[]},{"line":"      type 'controller t =","counters":[{"col_start":6,"col_end":6,"count":3669},{"col_start":23,"col_end":23,"count":26}]},{"line":"            'controller Mina_wire_types.Mina_base.Permissions.Poly.V2.t =","counters":[]},{"line":"        { edit_state : 'controller","counters":[{"col_start":10,"col_end":10,"count":2},{"col_start":19,"col_end":19,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"        ; send : 'controller","counters":[{"col_start":10,"col_end":10,"count":2},{"col_start":13,"col_end":13,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"        ; receive : 'controller","counters":[{"col_start":10,"col_end":10,"count":2},{"col_start":16,"col_end":16,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"        ; set_delegate : 'controller","counters":[{"col_start":10,"col_end":10,"count":2},{"col_start":21,"col_end":21,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"        ; set_permissions : 'controller","counters":[{"col_start":10,"col_end":10,"count":2},{"col_start":24,"col_end":24,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"        ; set_verification_key : 'controller","counters":[{"col_start":10,"col_end":10,"count":2},{"col_start":29,"col_end":29,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"        ; set_zkapp_uri : 'controller","counters":[{"col_start":10,"col_end":10,"count":2},{"col_start":22,"col_end":22,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"        ; edit_sequence_state : 'controller","counters":[{"col_start":10,"col_end":10,"count":2},{"col_start":28,"col_end":28,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"        ; set_token_symbol : 'controller","counters":[{"col_start":10,"col_end":10,"count":2},{"col_start":25,"col_end":25,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"        ; increment_nonce : 'controller","counters":[{"col_start":10,"col_end":10,"count":2},{"col_start":24,"col_end":24,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"        ; set_voting_for : 'controller","counters":[{"col_start":10,"col_end":10,"count":2},{"col_start":23,"col_end":23,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"        }","counters":[]},{"line":"      [@@deriving annot, sexp, equal, compare, hash, yojson, hlist, fields]","counters":[{"col_start":74,"col_end":74,"count":3}]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  let to_input controller t =","counters":[]},{"line":"    let f mk acc field = mk (Core_kernel.Field.get field t) :: acc in","counters":[{"col_start":4,"col_end":4,"count":2},{"col_start":25,"col_end":25,"count":22},{"col_start":26,"col_end":26,"count":22},{"col_start":49,"col_end":49,"count":22}]},{"line":"    Stable.Latest.Fields.fold ~init:[] ~edit_state:(f controller)","counters":[{"col_start":52,"col_end":52,"count":2}]},{"line":"      ~send:(f controller) ~set_delegate:(f controller)","counters":[{"col_start":13,"col_end":13,"count":2},{"col_start":42,"col_end":42,"count":2}]},{"line":"      ~set_permissions:(f controller) ~set_verification_key:(f controller)","counters":[{"col_start":24,"col_end":24,"count":2},{"col_start":61,"col_end":61,"count":2}]},{"line":"      ~receive:(f controller) ~set_zkapp_uri:(f controller)","counters":[{"col_start":16,"col_end":16,"count":2},{"col_start":46,"col_end":46,"count":2}]},{"line":"      ~edit_sequence_state:(f controller) ~set_token_symbol:(f controller)","counters":[{"col_start":28,"col_end":28,"count":2},{"col_start":61,"col_end":61,"count":2}]},{"line":"      ~increment_nonce:(f controller) ~set_voting_for:(f controller)","counters":[{"col_start":24,"col_end":24,"count":2},{"col_start":55,"col_end":55,"count":2}]},{"line":"    |> List.rev","counters":[{"col_start":14,"col_end":14,"count":2}]},{"line":"    |> List.reduce_exn ~f:Random_oracle.Input.Chunked.append","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"[%%versioned","counters":[]},{"line":"module Stable = struct","counters":[]},{"line":"  module V2 = struct","counters":[]},{"line":"    type t = Auth_required.Stable.V2.t Poly.Stable.V2.t","counters":[{"col_start":4,"col_end":4,"count":276},{"col_start":9,"col_end":9,"count":1},{"col_start":13,"col_end":13,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"    [@@deriving sexp, equal, compare, hash, yojson]","counters":[{"col_start":50,"col_end":50,"count":5}]},{"line":"","counters":[]},{"line":"    let to_latest = Fn.id","counters":[]},{"line":"  end","counters":[]},{"line":"end]","counters":[]},{"line":"","counters":[]},{"line":"let gen ~auth_tag : t Quickcheck.Generator.t =","counters":[]},{"line":"  let auth_required_gen =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    (* for Auth_required permissions p, choose such that [check p authorization] is true *)","counters":[]},{"line":"    match auth_tag with","counters":[]},{"line":"    | Control.Tag.Proof ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Auth_required.gen_for_proof_authorization","counters":[]},{"line":"    | Signature ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Auth_required.gen_for_signature_authorization","counters":[]},{"line":"    | None_given ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Auth_required.gen_for_none_given_authorization","counters":[]},{"line":"  in","counters":[]},{"line":"  let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"  let%bind edit_state = auth_required_gen in","counters":[]},{"line":"  let%bind send = auth_required_gen in","counters":[]},{"line":"  let%bind receive = auth_required_gen in","counters":[]},{"line":"  let%bind set_delegate = auth_required_gen in","counters":[]},{"line":"  let%bind set_permissions = auth_required_gen in","counters":[]},{"line":"  let%bind set_verification_key = auth_required_gen in","counters":[]},{"line":"  let%bind set_zkapp_uri = auth_required_gen in","counters":[]},{"line":"  let%bind edit_sequence_state = auth_required_gen in","counters":[]},{"line":"  let%bind set_token_symbol = auth_required_gen in","counters":[]},{"line":"  let%bind increment_nonce = auth_required_gen in","counters":[]},{"line":"  let%bind set_voting_for = auth_required_gen in","counters":[]},{"line":"  return","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    { Poly.edit_state","counters":[]},{"line":"    ; send","counters":[]},{"line":"    ; receive","counters":[]},{"line":"    ; set_delegate","counters":[]},{"line":"    ; set_permissions","counters":[]},{"line":"    ; set_verification_key","counters":[]},{"line":"    ; set_zkapp_uri","counters":[]},{"line":"    ; edit_sequence_state","counters":[]},{"line":"    ; set_token_symbol","counters":[]},{"line":"    ; increment_nonce","counters":[]},{"line":"    ; set_voting_for","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"[%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"module Checked = struct","counters":[]},{"line":"  type t = Auth_required.Checked.t Poly.Stable.Latest.t","counters":[]},{"line":"","counters":[]},{"line":"  let to_input (x : t) = Poly.to_input Auth_required.Checked.to_input x","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"  let if_ b ~then_ ~else_ =","counters":[]},{"line":"    let g cond f =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      cond b","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ~then_:(Core_kernel.Field.get f then_)","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"        ~else_:(Core_kernel.Field.get f else_)","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"    in","counters":[]},{"line":"    let c = g Auth_required.Checked.if_ in","counters":[]},{"line":"    Poly.Fields.map ~edit_state:c ~send:c ~receive:c ~set_delegate:c","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ~set_permissions:c ~set_verification_key:c ~set_zkapp_uri:c","counters":[]},{"line":"      ~edit_sequence_state:c ~set_token_symbol:c ~increment_nonce:c","counters":[]},{"line":"      ~set_voting_for:c","counters":[]},{"line":"","counters":[]},{"line":"  let constant (t : Stable.Latest.t) : t =","counters":[]},{"line":"    let open Core_kernel.Field in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let a f = Auth_required.Checked.constant (get f t) in","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"    Poly.Fields.map ~edit_state:a ~send:a ~receive:a ~set_delegate:a","counters":[]},{"line":"      ~set_permissions:a ~set_verification_key:a ~set_zkapp_uri:a","counters":[]},{"line":"      ~edit_sequence_state:a ~set_token_symbol:a ~increment_nonce:a","counters":[]},{"line":"      ~set_voting_for:a","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let typ =","counters":[]},{"line":"  let open Poly.Stable.Latest in","counters":[]},{"line":"  Typ.of_hlistable","counters":[{"col_start":17,"col_end":17,"count":1}]},{"line":"    [ Auth_required.typ","counters":[]},{"line":"    ; Auth_required.typ","counters":[]},{"line":"    ; Auth_required.typ","counters":[]},{"line":"    ; Auth_required.typ","counters":[]},{"line":"    ; Auth_required.typ","counters":[]},{"line":"    ; Auth_required.typ","counters":[]},{"line":"    ; Auth_required.typ","counters":[]},{"line":"    ; Auth_required.typ","counters":[]},{"line":"    ; Auth_required.typ","counters":[]},{"line":"    ; Auth_required.typ","counters":[]},{"line":"    ; Auth_required.typ","counters":[]},{"line":"    ]","counters":[]},{"line":"    ~var_to_hlist:to_hlist ~var_of_hlist:of_hlist ~value_to_hlist:to_hlist","counters":[]},{"line":"    ~value_of_hlist:of_hlist","counters":[]},{"line":"","counters":[]},{"line":"[%%endif]","counters":[]},{"line":"","counters":[]},{"line":"let to_input (x : t) = Poly.to_input Auth_required.to_input x","counters":[{"col_start":23,"col_end":23,"count":2}]},{"line":"","counters":[]},{"line":"let user_default : t =","counters":[]},{"line":"  { edit_state = Signature","counters":[]},{"line":"  ; send = Signature","counters":[]},{"line":"  ; receive = None","counters":[]},{"line":"  ; set_delegate = Signature","counters":[]},{"line":"  ; set_permissions = Signature","counters":[]},{"line":"  ; set_verification_key = Signature","counters":[]},{"line":"  ; set_zkapp_uri = Signature","counters":[]},{"line":"  ; edit_sequence_state = Signature","counters":[]},{"line":"  ; set_token_symbol = Signature","counters":[]},{"line":"  ; increment_nonce = Signature","counters":[]},{"line":"  ; set_voting_for = Signature","counters":[]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"let empty : t =","counters":[]},{"line":"  { edit_state = None","counters":[]},{"line":"  ; send = None","counters":[]},{"line":"  ; receive = None","counters":[]},{"line":"  ; set_delegate = None","counters":[]},{"line":"  ; set_permissions = None","counters":[]},{"line":"  ; set_verification_key = None","counters":[]},{"line":"  ; set_zkapp_uri = None","counters":[]},{"line":"  ; edit_sequence_state = None","counters":[]},{"line":"  ; set_token_symbol = None","counters":[]},{"line":"  ; increment_nonce = None","counters":[]},{"line":"  ; set_voting_for = None","counters":[]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"(* deriving-fields-related stuff *)","counters":[]},{"line":"","counters":[]},{"line":"let auth_required =","counters":[]},{"line":"  Fields_derivers_zkapps.Derivers.iso_string ~name:\"AuthRequired\"","counters":[]},{"line":"    ~js_type:(Custom \"AuthRequired\") ~doc:\"Kind of authorization required\"","counters":[]},{"line":"    ~to_string:Auth_required.to_string ~of_string:Auth_required.of_string","counters":[]},{"line":"","counters":[]},{"line":"let deriver obj =","counters":[]},{"line":"  let open Fields_derivers_zkapps.Derivers in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let ( !. ) = ( !. ) ~t_fields_annots:Poly.t_fields_annots in","counters":[]},{"line":"  Poly.Fields.make_creator obj ~edit_state:!.auth_required ~send:!.auth_required","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"    ~receive:!.auth_required ~set_delegate:!.auth_required","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"    ~set_permissions:!.auth_required ~set_verification_key:!.auth_required","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"    ~set_zkapp_uri:!.auth_required ~edit_sequence_state:!.auth_required","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"    ~set_token_symbol:!.auth_required ~increment_nonce:!.auth_required","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"    ~set_voting_for:!.auth_required","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"  |> finish \"Permissions\" ~t_toplevel_annots:Poly.t_toplevel_annots","counters":[]},{"line":"","counters":[]},{"line":"let%test_unit \"json roundtrip\" =","counters":[]},{"line":"  let open Fields_derivers_zkapps.Derivers in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let full = o () in","counters":[]},{"line":"  let _a = deriver full in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  [%test_eq: t] user_default (user_default |> to_json full |> of_json full)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":52,"col_end":52,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"","counters":[]},{"line":"let%test_unit \"json value\" =","counters":[]},{"line":"  let open Fields_derivers_zkapps.Derivers in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let full = o () in","counters":[]},{"line":"  let _a = deriver full in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  [%test_eq: string]","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":13,"col_end":13,"count":0}]},{"line":"    (user_default |> to_json full |> Yojson.Safe.to_string)","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"    ( {json|{","counters":[]},{"line":"        editState: \"Signature\",","counters":[]},{"line":"        send: \"Signature\",","counters":[]},{"line":"        receive: \"None\",","counters":[]},{"line":"        setDelegate: \"Signature\",","counters":[]},{"line":"        setPermissions: \"Signature\",","counters":[]},{"line":"        setVerificationKey: \"Signature\",","counters":[]},{"line":"        setZkappUri: \"Signature\",","counters":[]},{"line":"        editSequenceState: \"Signature\",","counters":[]},{"line":"        setTokenSymbol: \"Signature\",","counters":[]},{"line":"        incrementNonce: \"Signature\",","counters":[]},{"line":"        setVotingFor: \"Signature\"","counters":[]},{"line":"      }|json}","counters":[]},{"line":"    |> Yojson.Safe.from_string |> Yojson.Safe.to_string )","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":54,"col_end":54,"count":0},{"col_start":56,"col_end":56,"count":1}]}]}