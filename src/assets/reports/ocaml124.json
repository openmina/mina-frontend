{"filename":"src/lib/mina_base/signed_command_memo_intf.ml","lines":[{"line":"[%%import \"/src/config.mlh\"]","counters":[]},{"line":"","counters":[{"col_start":0,"col_end":0,"count":1}]},{"line":"open Core_kernel","counters":[]},{"line":"open Snark_params.Tick","counters":[]},{"line":"","counters":[]},{"line":"module type S = sig","counters":[]},{"line":"  exception Too_long_user_memo_input","counters":[]},{"line":"","counters":[]},{"line":"  exception Too_long_digestible_string","counters":[]},{"line":"","counters":[]},{"line":"  type t [@@deriving sexp, equal, compare, hash, yojson]","counters":[]},{"line":"","counters":[]},{"line":"  module Stable : sig","counters":[]},{"line":"    module V1 : sig","counters":[]},{"line":"      type nonrec t = t","counters":[]},{"line":"      [@@deriving bin_io, sexp, equal, compare, hash, yojson, version]","counters":[]},{"line":"","counters":[]},{"line":"      module With_all_version_tags : Bin_prot.Binable.S with type t = t","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Latest = V1","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  [%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"  module Checked : sig","counters":[]},{"line":"    type unchecked = t","counters":[]},{"line":"","counters":[]},{"line":"    type t = private Boolean.var array","counters":[]},{"line":"","counters":[]},{"line":"    val constant : unchecked -> t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  (** typ representation *)","counters":[]},{"line":"  val typ : (Checked.t, t) Typ.t","counters":[]},{"line":"","counters":[]},{"line":"  [%%endif]","counters":[]},{"line":"","counters":[]},{"line":"  val dummy : t","counters":[]},{"line":"","counters":[]},{"line":"  val empty : t","counters":[]},{"line":"","counters":[]},{"line":"  val to_base58_check : t -> string","counters":[]},{"line":"","counters":[]},{"line":"  val of_base58_check : string -> t Or_error.t","counters":[]},{"line":"","counters":[]},{"line":"  val of_base58_check_exn : string -> t","counters":[]},{"line":"","counters":[]},{"line":"  (** for a memo of bytes, return a plaintext string","counters":[]},{"line":"      for a memo of a digest, return a hex-encoded string, prefixed by '0x'","counters":[]},{"line":"  *)","counters":[]},{"line":"  val to_string_hum : t -> string","counters":[]},{"line":"","counters":[]},{"line":"  (** is the memo a digest *)","counters":[]},{"line":"  val is_digest : t -> bool","counters":[]},{"line":"","counters":[]},{"line":"  (** is the memo well-formed *)","counters":[]},{"line":"  val is_valid : t -> bool","counters":[]},{"line":"","counters":[]},{"line":"  (** bound on length of strings to digest *)","counters":[]},{"line":"  val max_digestible_string_length : int","counters":[]},{"line":"","counters":[]},{"line":"  (** bound on length of strings or bytes in memo *)","counters":[]},{"line":"  val max_input_length : int","counters":[]},{"line":"","counters":[]},{"line":"  (** create a memo by digesting a string; raises [Too_long_digestible_string] if","counters":[]},{"line":"      length exceeds [max_digestible_string_length]","counters":[]},{"line":"  *)","counters":[]},{"line":"  val create_by_digesting_string_exn : string -> t","counters":[]},{"line":"","counters":[]},{"line":"  (** create a memo by digesting a string; returns error if","counters":[]},{"line":"      length exceeds [max_digestible_string_length]","counters":[]},{"line":"  *)","counters":[]},{"line":"  val create_by_digesting_string : string -> t Or_error.t","counters":[]},{"line":"","counters":[]},{"line":"  (** create a memo from bytes of length up to max_input_length;","counters":[]},{"line":"      raise [Too_long_user_memo_input] if length is greater","counters":[]},{"line":"  *)","counters":[]},{"line":"  val create_from_bytes_exn : bytes -> t","counters":[]},{"line":"","counters":[]},{"line":"  (** create a memo from bytes of length up to max_input_length; returns","counters":[]},{"line":"      error is length is greater","counters":[]},{"line":"  *)","counters":[]},{"line":"  val create_from_bytes : bytes -> t Or_error.t","counters":[]},{"line":"","counters":[]},{"line":"  (** create a memo from a string of length up to max_input_length;","counters":[]},{"line":"      raise [Too_long_user_memo_input] if length is greater","counters":[]},{"line":"  *)","counters":[]},{"line":"  val create_from_string_exn : string -> t","counters":[]},{"line":"","counters":[]},{"line":"  (** create a memo from a string of length up to max_input_length;","counters":[]},{"line":"      returns error if length is greater","counters":[]},{"line":"  *)","counters":[]},{"line":"  val create_from_string : string -> t Or_error.t","counters":[]},{"line":"","counters":[]},{"line":"  (** convert a memo to a list of bools","counters":[]},{"line":"  *)","counters":[]},{"line":"  val to_bits : t -> bool list","counters":[]},{"line":"","counters":[]},{"line":"  (** Quickcheck generator for memos. *)","counters":[]},{"line":"  val gen : t Quickcheck.Generator.t","counters":[]},{"line":"","counters":[]},{"line":"  (** Compute a standalone hash of the current memo. *)","counters":[]},{"line":"  val hash : t -> Field.t","counters":[]},{"line":"","counters":[]},{"line":"  (* This type definition was generated by hovering over `deriver` in signed_command_memo.ml and copying the type *)","counters":[]},{"line":"  val deriver :","counters":[]},{"line":"       (< contramap : (t -> Yojson.Safe.t) ref","counters":[]},{"line":"        ; graphql_arg :","counters":[]},{"line":"            (unit -> Yojson.Safe.t Fields_derivers_graphql.Schema.Arg.arg_typ)","counters":[]},{"line":"            ref","counters":[]},{"line":"        ; graphql_fields :","counters":[]},{"line":"            Yojson.Safe.t Fields_derivers_zkapps.Graphql.Fields.Input.T.t ref","counters":[]},{"line":"        ; graphql_query : string option ref","counters":[]},{"line":"        ; graphql_query_accumulator : (string * string option) list ref","counters":[]},{"line":"        ; map : (Yojson.Safe.t -> t) ref","counters":[]},{"line":"        ; nullable_graphql_arg :","counters":[]},{"line":"            (   unit","counters":[]},{"line":"             -> Yojson.Safe.t option Fields_derivers_graphql.Schema.Arg.arg_typ","counters":[]},{"line":"            )","counters":[]},{"line":"            ref","counters":[]},{"line":"        ; nullable_graphql_fields :","counters":[]},{"line":"            Yojson.Safe.t option Fields_derivers_zkapps.Graphql.Fields.Input.T.t","counters":[]},{"line":"            ref","counters":[]},{"line":"        ; of_json : (Yojson.Safe.t -> Yojson.Safe.t) ref","counters":[]},{"line":"        ; to_json : (Yojson.Safe.t -> Yojson.Safe.t) ref","counters":[]},{"line":"        ; js_layout : Yojson.Safe.t ref","counters":[]},{"line":"        ; .. >","counters":[]},{"line":"        as","counters":[]},{"line":"        'a )","counters":[]},{"line":"       Fields_derivers_zkapps.Unified_input.t","counters":[]},{"line":"       Fields_derivers_zkapps.Unified_input.t","counters":[]},{"line":"       Fields_derivers_zkapps.Unified_input.t","counters":[]},{"line":"    -> 'a Fields_derivers_zkapps.Unified_input.t","counters":[]},{"line":"","counters":[]},{"line":"  type raw =","counters":[]},{"line":"    | Digest of string  (** The digest of the string, encoded by base58-check *)","counters":[]},{"line":"    | Bytes of string  (** A string containing the raw bytes in the memo. *)","counters":[]},{"line":"","counters":[]},{"line":"  (** Convert into a raw representation.","counters":[]},{"line":"","counters":[]},{"line":"      Raises if the tag or length are invalid.","counters":[]},{"line":"  *)","counters":[]},{"line":"  val to_raw_exn : t -> raw","counters":[]},{"line":"","counters":[]},{"line":"  (** Convert back into the raw input bytes.","counters":[]},{"line":"","counters":[]},{"line":"      Raises if the tag or length are invalid, or if the memo was a digest.","counters":[]},{"line":"      Equivalent to [to_raw_exn] and then a match on [Bytes].","counters":[]},{"line":"  *)","counters":[]},{"line":"  val to_raw_bytes_exn : t -> string","counters":[]},{"line":"","counters":[]},{"line":"  (** Convert from a raw representation.","counters":[]},{"line":"","counters":[]},{"line":"      Raises if the digest is not a valid base58-check string, or if the bytes","counters":[]},{"line":"      string is too long.","counters":[]},{"line":"  *)","counters":[]},{"line":"  val of_raw_exn : raw -> t","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":1}]}]}