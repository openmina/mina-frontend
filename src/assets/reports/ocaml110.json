{"filename":"src/lib/uptime_service/uptime_snark_worker.ml","lines":[{"line":"(* uptime_snark_worker.ml *)","counters":[]},{"line":"","counters":[{"col_start":0,"col_end":0,"count":1}]},{"line":"open Core_kernel","counters":[]},{"line":"open Async","counters":[]},{"line":"open Mina_base","counters":[]},{"line":"module Prod = Snark_worker__Prod.Inputs","counters":[]},{"line":"","counters":[]},{"line":"module Worker_state = struct","counters":[]},{"line":"  module type S = sig","counters":[]},{"line":"    val perform_single :","counters":[]},{"line":"         Sok_message.t * Prod.single_spec","counters":[]},{"line":"      -> (Ledger_proof.t * Time.Span.t) Deferred.Or_error.t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  (* bin_io required by rpc_parallel *)","counters":[]},{"line":"  type init_arg = Logger.Stable.Latest.t [@@deriving bin_io_unversioned]","counters":[{"col_start":2,"col_end":2,"count":1},{"col_start":14,"col_end":14,"count":1},{"col_start":71,"col_end":71,"count":4}]},{"line":"","counters":[]},{"line":"  type t = (module S)","counters":[]},{"line":"","counters":[]},{"line":"  let create ~logger : t Deferred.t =","counters":[]},{"line":"    Memory_stats.log_memory_stats logger ~process:\"uptime service SNARK worker\" ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Deferred.return","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (let module M = struct","counters":[]},{"line":"         let perform_single (message, single_spec) =","counters":[]},{"line":"           let%bind (worker_state : Prod.Worker_state.t) =","counters":[]},{"line":"             Prod.Worker_state.create","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"               ~constraint_constants:","counters":[]},{"line":"                 Genesis_constants.Constraint_constants.compiled","counters":[]},{"line":"               ~proof_level:Full ()","counters":[]},{"line":"           in","counters":[]},{"line":"           Prod.perform_single worker_state ~message single_spec","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"       end in","counters":[]},{"line":"      (module M : S) )","counters":[]},{"line":"","counters":[]},{"line":"  let get = Fn.id","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Worker = struct","counters":[]},{"line":"  module T = struct","counters":[]},{"line":"    module F = Rpc_parallel.Function","counters":[]},{"line":"","counters":[]},{"line":"    type 'w functions =","counters":[]},{"line":"      { perform_single :","counters":[]},{"line":"          ( 'w","counters":[]},{"line":"          , Sok_message.t * Prod.single_spec","counters":[]},{"line":"          , (Ledger_proof.t * Time.Span.t) Or_error.t )","counters":[]},{"line":"          F.t","counters":[]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    module Worker_state = Worker_state","counters":[]},{"line":"","counters":[]},{"line":"    module Connection_state = struct","counters":[]},{"line":"      (* bin_io required by rpc_parallel *)","counters":[]},{"line":"      type init_arg = unit [@@deriving bin_io_unversioned]","counters":[{"col_start":6,"col_end":6,"count":1},{"col_start":18,"col_end":18,"count":1},{"col_start":57,"col_end":57,"count":4}]},{"line":"","counters":[]},{"line":"      type t = unit","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Functions","counters":[]},{"line":"        (C : Rpc_parallel.Creator","counters":[]},{"line":"               with type worker_state := Worker_state.t","counters":[]},{"line":"                and type connection_state := Connection_state.t) =","counters":[]},{"line":"    struct","counters":[]},{"line":"      let perform_single (w : Worker_state.t) msg_and_single_spec =","counters":[]},{"line":"        let (module M) = Worker_state.get w in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        M.perform_single msg_and_single_spec","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      let functions =","counters":[]},{"line":"        let f (i, o, f) =","counters":[]},{"line":"          C.create_rpc","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"            ~f:(fun ~worker_state ~conn_state:_ i -> f worker_state i)","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"            ~bin_input:i ~bin_output:o ()","counters":[]},{"line":"        in","counters":[]},{"line":"        { perform_single =","counters":[]},{"line":"            f","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"              ( [%bin_type_class: Sok_message.Stable.Latest.t * Prod.single_spec]","counters":[]},{"line":"              , [%bin_type_class:","counters":[]},{"line":"                  (Ledger_proof.Stable.Latest.t * Time.Span.t) Or_error.t]","counters":[]},{"line":"              , perform_single )","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"      let init_worker_state logger =","counters":[]},{"line":"        [%log info] \"Uptime SNARK worker started\" ;","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"        Worker_state.create ~logger","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      let init_connection_state ~connection:_ ~worker_state:_ () = Deferred.unit","counters":[{"col_start":67,"col_end":67,"count":0}]},{"line":"    end","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  include Rpc_parallel.Make (T)","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"type t =","counters":[]},{"line":"  { connection : Worker.Connection.t","counters":[]},{"line":"  ; process : Process.t","counters":[]},{"line":"  ; logger : Logger.Stable.Latest.t","counters":[]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"let create ~logger ~pids : t Deferred.t =","counters":[]},{"line":"  let on_failure err =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    [%log error] \"Uptime service SNARK worker process failed with error $err\"","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"      ~metadata:[ (\"err\", Error_json.error_to_yojson err) ] ;","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"    Error.raise err","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  in","counters":[]},{"line":"  [%log info] \"Starting a new uptime service SNARK worker process\" ;","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"  let%map connection, process =","counters":[]},{"line":"    Worker.spawn_in_foreground_exn ~connection_timeout:(Time.Span.of_min 1.)","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"      ~on_failure ~shutdown_on:Connection_closed ~connection_state_init_arg:()","counters":[]},{"line":"      logger","counters":[]},{"line":"  in","counters":[]},{"line":"  [%log info]","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":12,"col_end":12,"count":0}]},{"line":"    \"Daemon started process of kind $process_kind with pid \\","counters":[]},{"line":"     $uptime_snark_worker_pid\"","counters":[]},{"line":"    ~metadata:","counters":[]},{"line":"      [ (\"uptime_snark_worker_pid\", `Int (Process.pid process |> Pid.to_int))","counters":[{"col_start":52,"col_end":52,"count":0},{"col_start":74,"col_end":74,"count":0}]},{"line":"      ; ( \"process_kind\"","counters":[]},{"line":"        , `String","counters":[]},{"line":"            Child_processes.Termination.(show_process_kind Uptime_snark_worker)","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"        )","counters":[]},{"line":"      ] ;","counters":[]},{"line":"  Child_processes.Termination.register_process pids process","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Child_processes.Termination.Uptime_snark_worker ;","counters":[]},{"line":"  (* the wait loop in the daemon will terminate the daemon if this SNARK worker","counters":[]},{"line":"     process dies","counters":[]},{"line":"","counters":[]},{"line":"     when this code is migrated to `compatible`, please follow the strategy","counters":[]},{"line":"     used in prover.ml to call Async.exit when the prover terminates","counters":[]},{"line":"  *)","counters":[]},{"line":"  don't_wait_for","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  @@ Pipe.iter","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"       (Process.stdout process |> Reader.pipe)","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"       ~f:(fun stdout ->","counters":[]},{"line":"         return","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"         @@ [%log debug] \"Uptime SNARK worker stdout: $stdout\"","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"              ~metadata:[ (\"stdout\", `String stdout) ] ) ;","counters":[]},{"line":"  don't_wait_for","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  @@ Pipe.iter","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"       (Process.stderr process |> Reader.pipe)","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"       ~f:(fun stderr ->","counters":[]},{"line":"         return","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"         @@ [%log error] \"Uptime SNARK worker stderr: $stderr\"","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"              ~metadata:[ (\"stderr\", `String stderr) ] ) ;","counters":[]},{"line":"  { connection; process; logger }","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let perform_single { connection; _ } ((_message, _single_spec) as arg) =","counters":[]},{"line":"  Worker.Connection.run connection ~f:Worker.functions.perform_single ~arg","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":73,"col_end":73,"count":2}]}]}