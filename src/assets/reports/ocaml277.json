{"filename":"src/lib/uptime_service/uptime_service.ml","lines":[{"line":"(* uptime_service.ml -- proof of uptime for Mina delegation program *)","counters":[]},{"line":"","counters":[{"col_start":0,"col_end":0,"count":1}]},{"line":"open Core_kernel","counters":[]},{"line":"open Async","counters":[]},{"line":"open Mina_base","counters":[]},{"line":"open Pipe_lib","counters":[]},{"line":"open Signature_lib","counters":[]},{"line":"","counters":[]},{"line":"module Blake2 = Blake2.Make ()","counters":[]},{"line":"","counters":[]},{"line":"module Uptime_snark_worker = Uptime_snark_worker","counters":[]},{"line":"","counters":[]},{"line":"type block_data =","counters":[{"col_start":0,"col_end":0,"count":0}]},{"line":"  { block : string","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"  ; created_at : string","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"  ; peer_id : string","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"  ; snark_work : string option [@default None]","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"  }","counters":[]},{"line":"[@@deriving to_yojson]","counters":[]},{"line":"","counters":[]},{"line":"module Proof_data = struct","counters":[]},{"line":"  (* NB: this type is unversioned, so the verifier on the backend","counters":[]},{"line":"     will need to be using the same code","counters":[]},{"line":"  *)","counters":[]},{"line":"  type t =","counters":[{"col_start":2,"col_end":2,"count":1},{"col_start":7,"col_end":7,"count":2}]},{"line":"    { proof : Ledger_proof.Stable.Latest.t","counters":[]},{"line":"    ; proof_time : Core_kernel.Time.Span.t","counters":[]},{"line":"    ; snark_work_fee : Currency.Fee.Stable.Latest.t","counters":[]},{"line":"    }","counters":[]},{"line":"  [@@deriving bin_io_unversioned]","counters":[{"col_start":32,"col_end":32,"count":4}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let sign_blake2_hash ~private_key s =","counters":[]},{"line":"  let module Field = Snark_params.Tick.Field in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let blake2 = Blake2.digest_string s in","counters":[]},{"line":"  let field_elements = [||] in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let bitstrings =","counters":[]},{"line":"    [| Blake2.to_raw_string blake2 |> Blake2.string_to_bits |> Array.to_list |]","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":58,"col_end":58,"count":0},{"col_start":75,"col_end":75,"count":0}]},{"line":"  in","counters":[]},{"line":"  let input : (Field.t, bool) Random_oracle.Legacy.Input.t =","counters":[]},{"line":"    { field_elements; bitstrings }","counters":[]},{"line":"  in","counters":[]},{"line":"  Schnorr.Legacy.sign private_key input","counters":[]},{"line":"","counters":[]},{"line":"let send_uptime_data ~logger ~interruptor ~(submitter_keypair : Keypair.t) ~url","counters":[]},{"line":"    ~state_hash ~produced block_data =","counters":[]},{"line":"  let open Interruptible.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let make_interruptible f = Interruptible.lift f interruptor in","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"  let block_data_json = block_data_to_yojson block_data in","counters":[]},{"line":"  let block_data_string = Yojson.Safe.to_string block_data_json in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let signature =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    sign_blake2_hash ~private_key:submitter_keypair.private_key","counters":[]},{"line":"      block_data_string","counters":[]},{"line":"  in","counters":[]},{"line":"  let json =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    (* JSON structure in issue #9110 *)","counters":[]},{"line":"    `Assoc","counters":[]},{"line":"      [ (\"data\", block_data_json)","counters":[]},{"line":"      ; (\"signature\", Signature.to_yojson signature)","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"      ; (\"submitter\", Public_key.to_yojson submitter_keypair.public_key)","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"      ]","counters":[]},{"line":"  in","counters":[]},{"line":"  let headers =","counters":[]},{"line":"    Cohttp.Header.of_list [ (\"Content-Type\", \"application/json\") ]","counters":[]},{"line":"  in","counters":[]},{"line":"  let metadata_of_body = function","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    | `String s ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [ (\"error\", `String s) ]","counters":[]},{"line":"    | `Strings ss ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [ (\"error\", `List (List.map ss ~f:(fun s -> `String s))) ]","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"    | `Empty | `Pipe _ ->","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"        []","counters":[]},{"line":"  in","counters":[]},{"line":"  let max_attempts = 8 in","counters":[]},{"line":"  let attempt_pause_sec = 4.0 in","counters":[]},{"line":"  (* see https://github.com/MinaProtocol/mina/blob/compatible/src/app/delegation_backend/README.md","counters":[]},{"line":"     for significance of these status codes","counters":[]},{"line":"  *)","counters":[]},{"line":"  let unrecoverable_status_codes = [ 400; 401; 411; 413 ] in","counters":[]},{"line":"  let run_attempt attempt =","counters":[]},{"line":"    let interruptible =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      match%map","counters":[]},{"line":"        make_interruptible","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"          (Monitor.try_with ~here:[%here] ~extract_exn:true (fun () ->","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"               Cohttp_async.Client.post ~headers","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                 ~body:","counters":[]},{"line":"                   (Yojson.Safe.to_string json |> Cohttp_async.Body.of_string)","counters":[{"col_start":40,"col_end":40,"count":0},{"col_start":76,"col_end":76,"count":0}]},{"line":"                 url ) )","counters":[]},{"line":"      with","counters":[]},{"line":"      | Ok ({ status; _ }, body) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let status_code = Cohttp.Code.code_of_status status in","counters":[]},{"line":"          let status_string = Cohttp.Code.string_of_status status in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let unretriable =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            List.mem unrecoverable_status_codes status_code ~equal:Int.equal","counters":[]},{"line":"          in","counters":[]},{"line":"          let succeeded = status_code = 200 in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          ( if succeeded then","counters":[]},{"line":"            [%log info]","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"              \"Sent block with state hash $state_hash to uptime service at URL \\","counters":[]},{"line":"               $url\"","counters":[]},{"line":"              ~metadata:","counters":[]},{"line":"                [ (\"state_hash\", State_hash.to_yojson state_hash)","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"                ; (\"url\", `String (Uri.to_string url))","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"                ; ( \"includes_snark_work\"","counters":[]},{"line":"                  , `Bool (Option.is_some block_data.snark_work) )","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"                ; (\"is_produced_block\", `Bool produced)","counters":[]},{"line":"                ]","counters":[]},{"line":"          else if unretriable then","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"            [%log error]","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"              \"Got unrecoverable response from update service backend at URL \\","counters":[]},{"line":"               $url, not retrying to send block\"","counters":[]},{"line":"              ~metadata:","counters":[]},{"line":"                [ (\"state_hash\", State_hash.to_yojson state_hash)","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"                ; (\"url\", `String (Uri.to_string url))","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"                ; (\"http_code\", `Int status_code)","counters":[]},{"line":"                ; (\"http_error\", `String status_string)","counters":[]},{"line":"                ; (\"payload\", json)","counters":[]},{"line":"                ]","counters":[]},{"line":"          else if attempt >= max_attempts then","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"            let base_metadata =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              [ (\"state_hash\", State_hash.to_yojson state_hash)","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"              ; (\"url\", `String (Uri.to_string url))","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"              ; (\"http_code\", `Int status_code)","counters":[]},{"line":"              ; (\"http_error\", `String status_string)","counters":[]},{"line":"              ; (\"payload\", json)","counters":[]},{"line":"              ]","counters":[]},{"line":"            in","counters":[]},{"line":"            let extra_metadata = metadata_of_body body in","counters":[]},{"line":"            let metadata = base_metadata @ extra_metadata in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            [%log error]","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"              \"After %d attempts, failed to send block with state hash \\","counters":[]},{"line":"               $state_hash to uptime service at URL $url, no more retries\"","counters":[]},{"line":"              max_attempts ~metadata","counters":[]},{"line":"          else","counters":[]},{"line":"            let base_metadata =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              [ (\"state_hash\", State_hash.to_yojson state_hash)","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"              ; (\"url\", `String (Uri.to_string url))","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"              ; (\"http_code\", `Int status_code)","counters":[]},{"line":"              ; (\"http_error\", `String status_string)","counters":[]},{"line":"              ]","counters":[]},{"line":"            in","counters":[]},{"line":"            let extra_metadata = metadata_of_body body in","counters":[]},{"line":"            let metadata = base_metadata @ extra_metadata in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            [%log info]","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"              \"Failure when sending block with state hash $state_hash to \\","counters":[]},{"line":"               uptime service at URL $url, attempt %d of %d, retrying\"","counters":[]},{"line":"              attempt max_attempts ~metadata ) ;","counters":[]},{"line":"          succeeded || unretriable","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"      | Error exn ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          [%log warn]","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"            \"Error when sending block with state hash $state_hash to uptime \\","counters":[]},{"line":"             service at URL $url\"","counters":[]},{"line":"            ~metadata:","counters":[]},{"line":"              [ (\"state_hash\", State_hash.to_yojson state_hash)","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"              ; (\"url\", `String (Uri.to_string url))","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"              ; (\"payload\", json)","counters":[]},{"line":"              ; (\"error\", `String (Exn.to_string exn))","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"              ] ;","counters":[]},{"line":"          (* retry *)","counters":[]},{"line":"          false","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    in","counters":[]},{"line":"    match%map.Deferred Interruptible.force interruptible with","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"    | Ok succeeded ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        succeeded","counters":[]},{"line":"    | Error _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [%log error]","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"          \"In uptime service, POST of block with state hash $state_hash was \\","counters":[]},{"line":"           interrupted\"","counters":[]},{"line":"          ~metadata:","counters":[]},{"line":"            [ (\"state_hash\", State_hash.to_yojson state_hash)","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"            ; (\"payload\", json)","counters":[]},{"line":"            ] ;","counters":[]},{"line":"        (* interrupted, don't want to retry, claim success *)","counters":[]},{"line":"        true","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"  in","counters":[]},{"line":"  let rec go attempt =","counters":[]},{"line":"    let open Deferred.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let%bind succeeded = run_attempt attempt in","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"    if succeeded then Deferred.return ()","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"    else if attempt < max_attempts then (","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"      let%bind () = Async.after (Time.Span.of_sec attempt_pause_sec) in","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"      [%log info]","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":16,"col_end":16,"count":0}]},{"line":"        \"In uptime service, retrying to send block, attempt %d of %d attempts \\","counters":[]},{"line":"         allowed\"","counters":[]},{"line":"        attempt max_attempts ;","counters":[]},{"line":"      go (attempt + 1) )","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    else Deferred.unit","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"  in","counters":[]},{"line":"  make_interruptible (go 1)","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"let block_base64_of_breadcrumb breadcrumb =","counters":[]},{"line":"  let external_transition =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    breadcrumb |> Transition_frontier.Breadcrumb.block","counters":[]},{"line":"  in","counters":[]},{"line":"  let block_string =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Binable.to_string (module Mina_block.Stable.Latest) external_transition","counters":[]},{"line":"  in","counters":[]},{"line":"  (* raises only on errors from invalid optional arguments *)","counters":[]},{"line":"  Base64.encode_exn block_string","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let send_produced_block_at ~logger ~interruptor ~url ~peer_id","counters":[]},{"line":"    ~(submitter_keypair : Keypair.t) ~block_produced_bvar tm =","counters":[]},{"line":"  let open Interruptible.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let make_interruptible f = Interruptible.lift f interruptor in","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"  let timeout_min = 3.0 in","counters":[]},{"line":"  let%bind () = make_interruptible (at tm) in","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"  match%bind","counters":[]},{"line":"    make_interruptible","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"      (with_timeout","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"         (Time.Span.of_min timeout_min)","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"         (Bvar.wait block_produced_bvar) )","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"  with","counters":[]},{"line":"  | `Timeout ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      [%log error]","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"        \"Uptime service did not get a produced block within %0.1f minutes \\","counters":[]},{"line":"         after scheduled time\"","counters":[]},{"line":"        timeout_min ;","counters":[]},{"line":"      return ()","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  | `Result breadcrumb ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let block_base64 = block_base64_of_breadcrumb breadcrumb in","counters":[]},{"line":"      let state_hash = Transition_frontier.Breadcrumb.state_hash breadcrumb in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let block_data =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { block = block_base64","counters":[]},{"line":"        ; created_at = Rfc3339_time.get_rfc3339_time ()","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"        ; peer_id","counters":[]},{"line":"        ; snark_work = None","counters":[]},{"line":"        }","counters":[]},{"line":"      in","counters":[]},{"line":"      send_uptime_data ~logger ~interruptor ~submitter_keypair ~url ~state_hash","counters":[]},{"line":"        ~produced:true block_data","counters":[]},{"line":"","counters":[]},{"line":"let send_block_and_transaction_snark ~logger ~interruptor ~url ~snark_worker","counters":[]},{"line":"    ~transition_frontier ~peer_id ~(submitter_keypair : Keypair.t)","counters":[]},{"line":"    ~snark_work_fee =","counters":[]},{"line":"  match Broadcast_pipe.Reader.peek transition_frontier with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | None ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (* expected during daemon boot, so not logging as error *)","counters":[]},{"line":"      [%log info]","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"        \"Transition frontier not available to send a block to uptime service\" ;","counters":[]},{"line":"      Interruptible.return ()","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  | Some tf -> (","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let make_interruptible f = Interruptible.lift f interruptor in","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"      let breadcrumb = Transition_frontier.best_tip tf in","counters":[]},{"line":"      let block_base64 = block_base64_of_breadcrumb breadcrumb in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let open Interruptible.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let message =","counters":[]},{"line":"        Sok_message.create ~fee:snark_work_fee","counters":[]},{"line":"          ~prover:(Public_key.compress submitter_keypair.public_key)","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"      in","counters":[]},{"line":"      let best_tip = Transition_frontier.best_tip tf in","counters":[]},{"line":"      let best_tip_block = Transition_frontier.Breadcrumb.block best_tip in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      if","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        List.is_empty","counters":[]},{"line":"          (Mina_block.transactions","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"             ~constraint_constants:","counters":[]},{"line":"               Genesis_constants.Constraint_constants.compiled best_tip_block )","counters":[]},{"line":"      then (","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"        [%log info]","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"          \"No transactions in block, sending block without SNARK work to \\","counters":[]},{"line":"           uptime service\" ;","counters":[]},{"line":"        let state_hash = Transition_frontier.Breadcrumb.state_hash best_tip in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let block_data =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          { block = block_base64","counters":[]},{"line":"          ; created_at = Rfc3339_time.get_rfc3339_time ()","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"          ; peer_id","counters":[]},{"line":"          ; snark_work = None","counters":[]},{"line":"          }","counters":[]},{"line":"        in","counters":[]},{"line":"        send_uptime_data ~logger ~interruptor ~submitter_keypair ~url","counters":[]},{"line":"          ~state_hash ~produced:false block_data )","counters":[]},{"line":"      else","counters":[]},{"line":"        let best_tip_staged_ledger =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Transition_frontier.Breadcrumb.staged_ledger best_tip","counters":[]},{"line":"        in","counters":[]},{"line":"        match","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Staged_ledger.all_work_pairs best_tip_staged_ledger","counters":[]},{"line":"            ~get_state:(fun state_hash ->","counters":[]},{"line":"              match Transition_frontier.find_protocol_state tf state_hash with","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              | None ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Error","counters":[]},{"line":"                    (Error.createf","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"                       \"Could not find state_hash %s in transition frontier \\","counters":[]},{"line":"                        for uptime service\"","counters":[]},{"line":"                       (State_hash.to_base58_check state_hash) )","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"              | Some protocol_state ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Ok protocol_state )","counters":[]},{"line":"        with","counters":[]},{"line":"        | Error e ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            [%log error]","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"              \"Could not get SNARK work from best tip staged ledger for uptime \\","counters":[]},{"line":"               service\"","counters":[]},{"line":"              ~metadata:[ (\"error\", Error_json.error_to_yojson e) ] ;","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"            Interruptible.return ()","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"        | Ok [] ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            [%log info]","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"              \"No SNARK jobs available for uptime service, sending just the \\","counters":[]},{"line":"               block\" ;","counters":[]},{"line":"            let state_hash =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Transition_frontier.Breadcrumb.state_hash best_tip","counters":[]},{"line":"            in","counters":[]},{"line":"            let block_data =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              { block = block_base64","counters":[]},{"line":"              ; created_at = Rfc3339_time.get_rfc3339_time ()","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"              ; peer_id","counters":[]},{"line":"              ; snark_work = None","counters":[]},{"line":"              }","counters":[]},{"line":"            in","counters":[]},{"line":"            send_uptime_data ~logger ~interruptor ~submitter_keypair ~url","counters":[]},{"line":"              ~state_hash ~produced:false block_data","counters":[]},{"line":"        | Ok job_one_or_twos -> (","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let transitions =","counters":[]},{"line":"              List.concat_map job_one_or_twos ~f:One_or_two.to_list","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"              |> List.filter ~f:(function","counters":[]},{"line":"                   | Snark_work_lib.Work.Single.Spec.Transition _ ->","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                       true","counters":[]},{"line":"                   | Merge _ ->","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                       false )","counters":[]},{"line":"            in","counters":[]},{"line":"            let staged_ledger_hash =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Mina_block.header best_tip_block","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"              |> Mina_block.Header.protocol_state","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"              |> Mina_state.Protocol_state.blockchain_state","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"              |> Mina_state.Blockchain_state.staged_ledger_hash","counters":[]},{"line":"            in","counters":[]},{"line":"            match","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              List.find transitions ~f:(fun transition ->","counters":[]},{"line":"                  match transition with","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  | Snark_work_lib.Work.Single.Spec.Transition ({ target; _ }, _)","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                    ->","counters":[]},{"line":"                      Pasta_bindings.Fp.equal target.ledger","counters":[]},{"line":"                        (Staged_ledger_hash.ledger_hash staged_ledger_hash)","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"                  | Merge _ ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      (* unreachable *)","counters":[]},{"line":"                      failwith \"Expected Transition work, not Merge\" )","counters":[]},{"line":"            with","counters":[]},{"line":"            | None ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                [%log info]","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                  \"No transactions in block match staged ledger hash, sending \\","counters":[]},{"line":"                   block without SNARK work\" ;","counters":[]},{"line":"                let state_hash =","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Transition_frontier.Breadcrumb.state_hash best_tip","counters":[]},{"line":"                in","counters":[]},{"line":"                let block_data =","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  { block = block_base64","counters":[]},{"line":"                  ; created_at = Rfc3339_time.get_rfc3339_time ()","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"                  ; peer_id","counters":[]},{"line":"                  ; snark_work = None","counters":[]},{"line":"                  }","counters":[]},{"line":"                in","counters":[]},{"line":"                send_uptime_data ~logger ~interruptor ~submitter_keypair ~url","counters":[]},{"line":"                  ~state_hash ~produced:false block_data","counters":[]},{"line":"            | Some single_spec -> (","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                match%bind","counters":[]},{"line":"                  make_interruptible","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                    (Uptime_snark_worker.perform_single snark_worker","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"                       (message, single_spec) )","counters":[]},{"line":"                with","counters":[]},{"line":"                | Error e ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    (* error in submitting to process *)","counters":[]},{"line":"                    [%log error]","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                      \"Error when running uptime service SNARK worker on a \\","counters":[]},{"line":"                       transaction\"","counters":[]},{"line":"                      ~metadata:[ (\"error\", Error_json.error_to_yojson e) ] ;","counters":[{"col_start":69,"col_end":69,"count":0}]},{"line":"                    Interruptible.return ()","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                | Ok (Error e) ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    (* error in creating the SNARK work *)","counters":[]},{"line":"                    [%log error] \"Error computing SNARK work for uptime service\"","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                      ~metadata:[ (\"error\", Error_json.error_to_yojson e) ] ;","counters":[{"col_start":69,"col_end":69,"count":0}]},{"line":"                    Interruptible.return ()","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                | Ok (Ok (proof, proof_time)) ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    let proof_data : Proof_data.t =","counters":[]},{"line":"                      { proof; proof_time; snark_work_fee }","counters":[]},{"line":"                    in","counters":[]},{"line":"                    let proof_string =","counters":[]},{"line":"                      Binable.to_string (module Proof_data) proof_data","counters":[]},{"line":"                    in","counters":[]},{"line":"                    (* raises only on errors from invalid optional arguments *)","counters":[]},{"line":"                    let snark_work_base64 = Base64.encode_exn proof_string in","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                    let state_hash =","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      Transition_frontier.Breadcrumb.state_hash best_tip","counters":[]},{"line":"                    in","counters":[]},{"line":"                    let block_data =","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      { block = block_base64","counters":[]},{"line":"                      ; created_at = Rfc3339_time.get_rfc3339_time ()","counters":[{"col_start":65,"col_end":65,"count":0}]},{"line":"                      ; peer_id","counters":[]},{"line":"                      ; snark_work = Some snark_work_base64","counters":[]},{"line":"                      }","counters":[]},{"line":"                    in","counters":[]},{"line":"                    send_uptime_data ~logger ~interruptor ~submitter_keypair","counters":[]},{"line":"                      ~url ~state_hash ~produced:false block_data ) ) )","counters":[]},{"line":"","counters":[]},{"line":"let start ~logger ~uptime_url ~snark_worker_opt ~transition_frontier","counters":[]},{"line":"    ~time_controller ~block_produced_bvar ~uptime_submitter_keypair","counters":[]},{"line":"    ~get_next_producer_timing ~get_snark_work_fee ~get_peer =","counters":[]},{"line":"  match uptime_url with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | None ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      [%log info] \"Not running uptime service, no URL given\" ;","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"      ()","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  | Some url ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      [%log info] \"Starting uptime service using URL $url\"","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"        ~metadata:[ (\"url\", `String (Uri.to_string url)) ] ;","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"      let snark_worker : Uptime_snark_worker.t =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Option.value_exn snark_worker_opt","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"      in","counters":[]},{"line":"      let slot_duration_ms =","counters":[]},{"line":"        Consensus.Configuration.t","counters":[]},{"line":"          ~constraint_constants:Genesis_constants.Constraint_constants.compiled","counters":[]},{"line":"          ~protocol_constants:Genesis_constants.compiled.protocol","counters":[]},{"line":"        |> Consensus.Configuration.slot_duration |> Float.of_int","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"      in","counters":[]},{"line":"      let make_slots_span min =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Block_time.Span.of_time_span (Time.Span.of_ms (slot_duration_ms *. min))","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"      in","counters":[]},{"line":"      let five_slots_span = make_slots_span 5.0 in","counters":[]},{"line":"      let four_slots_span = make_slots_span 4.0 in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let wait_until_iteration_start block_tm =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let now = Block_time.now time_controller in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        if Block_time.( < ) now block_tm then","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          at (Block_time.to_time_exn block_tm)","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"        else (","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"          [%log warn]","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"            \"In uptime service, current block time is past desired start of \\","counters":[]},{"line":"             iteration\" ;","counters":[]},{"line":"          return () )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"      in","counters":[]},{"line":"      let register_iteration =","counters":[]},{"line":"        let interrupt_ivar = ref (Ivar.create ()) in","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"        fun () ->","counters":[]},{"line":"          (* terminate any Interruptible code from previous iteration *)","counters":[]},{"line":"          Ivar.fill_if_empty !interrupt_ivar () ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          Deferred.create (fun ivar -> interrupt_ivar := ivar)","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"      in","counters":[]},{"line":"      let run_iteration next_block_tm : Block_time.t Deferred.t =","counters":[]},{"line":"        let get_next_producer_time_opt () =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          match get_next_producer_timing () with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              [%log trace] \"Next producer timing not set for uptime service\" ;","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"              None","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"          | Some timing -> (","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let open Daemon_rpcs.Types.Status.Next_producer_timing in","counters":[]},{"line":"              match timing.timing with","counters":[]},{"line":"              | Check_again _tm ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  [%log trace]","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                    \"Next producer timing not available for uptime service\" ;","counters":[]},{"line":"                  None","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"              | Evaluating_vrf _ ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  [%log trace]","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                    \"Evaluating VRF, wait for block production status for \\","counters":[]},{"line":"                     uptime service\" ;","counters":[]},{"line":"                  None","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"              | Produce prod_tm | Produce_now prod_tm ->","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"                  Some (Block_time.to_time_exn prod_tm.time) )","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"        in","counters":[]},{"line":"        [%log trace]","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"          \"Waiting for next 5-slot boundary to start work in uptime service\"","counters":[]},{"line":"          ~metadata:","counters":[]},{"line":"            [ (\"boundary_block_time\", Block_time.to_yojson next_block_tm)","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"            ; ( \"boundary_time\"","counters":[]},{"line":"              , `String (Block_time.to_time_exn next_block_tm |> Time.to_string)","counters":[{"col_start":46,"col_end":46,"count":0},{"col_start":78,"col_end":78,"count":0}]},{"line":"              )","counters":[]},{"line":"            ] ;","counters":[]},{"line":"        (* wait in Deferred monad *)","counters":[]},{"line":"        let%bind () = wait_until_iteration_start next_block_tm in","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"        let interruptor = register_iteration () in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        (* work in Interruptible monad in \"background\" *)","counters":[]},{"line":"        let open Interruptible.Let_syntax in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Interruptible.don't_wait_for","counters":[]},{"line":"          ( [%log trace] \"Determining which action to take in uptime service\" ;","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"            match get_peer () with","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            | None ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                [%log warn]","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                  \"Daemon is not yet a peer in the gossip network, uptime \\","counters":[]},{"line":"                   service not sending a produced block\" ;","counters":[]},{"line":"                Interruptible.return ()","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"            | Some ({ peer_id; _ } : Network_peer.Peer.t) -> (","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                let submitter_keypair =","counters":[]},{"line":"                  (* daemon startup checked that a keypair was given if URL given *)","counters":[]},{"line":"                  Option.value_exn uptime_submitter_keypair","counters":[]},{"line":"                in","counters":[]},{"line":"                let send_just_block next_producer_time =","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  [%log info]","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"                    \"Uptime service will attempt to send the next produced \\","counters":[]},{"line":"                     block\" ;","counters":[]},{"line":"                  send_produced_block_at ~logger ~interruptor ~url ~peer_id","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    ~submitter_keypair ~block_produced_bvar next_producer_time","counters":[]},{"line":"                in","counters":[]},{"line":"                let send_block_and_snark_work () =","counters":[]},{"line":"                  [%log info]","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"                    \"Uptime service will attempt to send a block and SNARK work\" ;","counters":[]},{"line":"                  let snark_work_fee = get_snark_work_fee () in","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  send_block_and_transaction_snark ~logger ~interruptor ~url","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    ~snark_worker ~transition_frontier ~peer_id","counters":[]},{"line":"                    ~submitter_keypair ~snark_work_fee","counters":[]},{"line":"                in","counters":[]},{"line":"                match get_next_producer_time_opt () with","counters":[]},{"line":"                | None ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    send_block_and_snark_work ()","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"                | Some next_producer_time ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    (* we look for block production within 4 slots of the *desired*","counters":[]},{"line":"                       iteration start time, so a late iteration won't affect the","counters":[]},{"line":"                       time bound on block production","counters":[]},{"line":"                       that leaves a full slot to produce the block","counters":[]},{"line":"                    *)","counters":[]},{"line":"                    let four_slots_from_start =","counters":[]},{"line":"                      Block_time.add next_block_tm four_slots_span","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                      |> Block_time.to_time_exn","counters":[]},{"line":"                    in","counters":[]},{"line":"                    if Time.( <= ) next_producer_time four_slots_from_start then","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      (* send a block w/ SNARK work, then the produced block *)","counters":[]},{"line":"                      let%bind () = send_block_and_snark_work () in","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"                      send_just_block next_producer_time","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                    else send_block_and_snark_work () ) ) ;","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"        Deferred.return (Block_time.add next_block_tm five_slots_span)","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"      in","counters":[]},{"line":"      (* sync to slot boundary *)","counters":[]},{"line":"      let next_slot_block_time =","counters":[]},{"line":"        let block_time_ms_int64 =","counters":[]},{"line":"          Block_time.now time_controller |> Block_time.to_int64","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"        in","counters":[]},{"line":"        let slot_duration_ms_int64 = Float.to_int64 slot_duration_ms in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let next_slot_ms =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          if","counters":[]},{"line":"            Int64.equal Int64.zero","counters":[]},{"line":"              (Int64.(rem) block_time_ms_int64 slot_duration_ms_int64)","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"          then block_time_ms_int64","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"          else","counters":[]},{"line":"            let last_slot_no =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Int64.( / ) block_time_ms_int64 slot_duration_ms_int64","counters":[]},{"line":"            in","counters":[]},{"line":"            Int64.( * ) (Int64.succ last_slot_no) slot_duration_ms_int64","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"        in","counters":[]},{"line":"        Block_time.of_int64 next_slot_ms","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"      in","counters":[]},{"line":"      Async.Deferred.forever next_slot_block_time run_iteration","counters":[{"col_start":62,"col_end":62,"count":2}]}]}