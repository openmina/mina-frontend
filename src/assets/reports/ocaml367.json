{"filename":"src/lib/mina_metrics/prometheus_metrics/mina_metrics.ml","lines":[{"line":"[%%import \"/src/config.mlh\"]","counters":[]},{"line":"","counters":[]},{"line":"open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"(* We re-export a constrained subset of prometheus to keep consumers of this","counters":[]},{"line":"   module abstract over implementation.","counters":[]},{"line":"*)","counters":[]},{"line":"include Prometheus","counters":[]},{"line":"open Prometheus","counters":[]},{"line":"open Namespace","counters":[]},{"line":"open Metric_generators","counters":[]},{"line":"open Async_kernel","counters":[]},{"line":"","counters":[]},{"line":"let time_offset_sec = 1609459200.","counters":[]},{"line":"","counters":[]},{"line":"[%%inject \"block_window_duration\", block_window_duration]","counters":[]},{"line":"","counters":[]},{"line":"(* textformat serialization and runtime metrics taken from github.com/mirage/prometheus:/app/prometheus_app.ml *)","counters":[]},{"line":"module TextFormat_0_0_4 = struct","counters":[]},{"line":"  let re_unquoted_escapes = Re.compile @@ Re.set \"\\\\\\n\"","counters":[{"col_start":37,"col_end":37,"count":1},{"col_start":47,"col_end":47,"count":1}]},{"line":"","counters":[]},{"line":"  let re_quoted_escapes = Re.compile @@ Re.set \"\\\"\\\\\\n\"","counters":[{"col_start":35,"col_end":35,"count":1},{"col_start":45,"col_end":45,"count":1}]},{"line":"","counters":[]},{"line":"  let quote g =","counters":[]},{"line":"    match Re.Group.get g 0 with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | \"\\\\\" ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        \"\\\\\\\\\"","counters":[]},{"line":"    | \"\\n\" ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        \"\\\\n\"","counters":[]},{"line":"    | \"\\\"\" ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        \"\\\\\\\"\"","counters":[]},{"line":"    | x ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        failwithf \"Unexpected match %S\" x ()","counters":[]},{"line":"","counters":[]},{"line":"  let output_metric_type f = function","counters":[]},{"line":"    | Counter ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Fmt.string f \"counter\"","counters":[]},{"line":"    | Gauge ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Fmt.string f \"gauge\"","counters":[]},{"line":"    | Summary ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Fmt.string f \"summary\"","counters":[]},{"line":"    | Histogram ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Fmt.string f \"histogram\"","counters":[]},{"line":"","counters":[]},{"line":"  let output_unquoted f s =","counters":[]},{"line":"    Fmt.string f @@ Re.replace re_unquoted_escapes ~f:quote s","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"  let output_quoted f s =","counters":[]},{"line":"    Fmt.string f @@ Re.replace re_quoted_escapes ~f:quote s","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"  let output_value f v =","counters":[]},{"line":"    let open Float.Class in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    match Float.classify v with","counters":[]},{"line":"    | Normal | Subnormal | Zero ->","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"        Fmt.float f v","counters":[]},{"line":"    | Infinite when Float.(v > 0.) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Fmt.string f \"+Inf\"","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    | Infinite ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Fmt.string f \"-Inf\"","counters":[]},{"line":"    | Nan ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Fmt.string f \"Nan\"","counters":[]},{"line":"","counters":[]},{"line":"  let output_pairs f (label_names, label_values) =","counters":[]},{"line":"    let cont = ref false in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let output_pair name value =","counters":[]},{"line":"      if !cont then Fmt.string f \", \" else cont := true ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"      Fmt.pf f \"%a=\\\"%a\\\"\" LabelName.pp name output_quoted value","counters":[]},{"line":"    in","counters":[]},{"line":"    List.iter2_exn label_names label_values ~f:output_pair","counters":[]},{"line":"","counters":[]},{"line":"  let output_labels ~label_names f = function","counters":[]},{"line":"    | [] ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ()","counters":[]},{"line":"    | label_values ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Fmt.pf f \"{%a}\" output_pairs (label_names, label_values)","counters":[]},{"line":"","counters":[]},{"line":"  let output_sample ~base ~label_names ~label_values f","counters":[]},{"line":"      { Sample_set.ext; value; bucket } =","counters":[]},{"line":"    let label_names, label_values =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      match bucket with","counters":[]},{"line":"      | None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (label_names, label_values)","counters":[]},{"line":"      | Some (label_name, label_value) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let label_value_str = Fmt.strf \"%a\" output_value label_value in","counters":[]},{"line":"          (label_name :: label_names, label_value_str :: label_values)","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    in","counters":[]},{"line":"    Fmt.pf f \"%a%s%a %a@.\" MetricName.pp base ext","counters":[]},{"line":"      (output_labels ~label_names)","counters":[]},{"line":"      label_values output_value value","counters":[]},{"line":"","counters":[]},{"line":"  let output_metric ~name ~label_names f (label_values, samples) =","counters":[]},{"line":"    List.iter samples ~f:(output_sample ~base:name ~label_names ~label_values f)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"","counters":[]},{"line":"  let output f =","counters":[]},{"line":"    MetricFamilyMap.iter (fun metric samples ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        let { MetricInfo.name; metric_type; help; label_names } = metric in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Fmt.pf f \"@[<v>#HELP %a %a@,#TYPE %a %a@,%a@]\" MetricName.pp name","counters":[]},{"line":"          output_unquoted help MetricName.pp name output_metric_type metric_type","counters":[]},{"line":"          (LabelSetMap.pp ~sep:Fmt.nop (output_metric ~name ~label_names))","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"          samples )","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type Histogram = sig","counters":[]},{"line":"  type t","counters":[]},{"line":"","counters":[]},{"line":"  val observe : t -> float -> unit","counters":[]},{"line":"","counters":[]},{"line":"  val buckets : t -> int list","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Runtime = struct","counters":[]},{"line":"  let subsystem = \"Runtime\"","counters":[]},{"line":"","counters":[]},{"line":"  module Long_async_histogram = Histogram (struct","counters":[]},{"line":"    let spec = Histogram_spec.of_exponential 0.5 2. 7","counters":[{"col_start":43,"col_end":43,"count":1}]},{"line":"  end)","counters":[]},{"line":"","counters":[]},{"line":"  let long_async_cycle : Long_async_histogram.t =","counters":[]},{"line":"    let help = \"A histogram for long async cycles\" in","counters":[]},{"line":"    Long_async_histogram.v \"long_async_cycle\" ~help ~namespace ~subsystem","counters":[{"col_start":25,"col_end":25,"count":1}]},{"line":"","counters":[]},{"line":"  module Long_job_histogram = Histogram (struct","counters":[]},{"line":"    let spec = Histogram_spec.of_exponential 0.5 2. 7","counters":[{"col_start":43,"col_end":43,"count":1}]},{"line":"  end)","counters":[]},{"line":"","counters":[]},{"line":"  let long_async_job : Long_job_histogram.t =","counters":[]},{"line":"    let help = \"A histogram for long async jobs\" in","counters":[]},{"line":"    Long_job_histogram.v \"long_async_job\" ~help ~namespace ~subsystem","counters":[{"col_start":23,"col_end":23,"count":1}]},{"line":"","counters":[]},{"line":"  let start_time = Core.Time.now ()","counters":[{"col_start":31,"col_end":31,"count":1}]},{"line":"","counters":[]},{"line":"  let current_gc = ref (Gc.stat ())","counters":[{"col_start":30,"col_end":30,"count":1}]},{"line":"","counters":[]},{"line":"  let gc_stat_interval_mins = ref 15.","counters":[]},{"line":"","counters":[]},{"line":"  let gc_allocated_bytes = ref (Gc.allocated_bytes ())","counters":[{"col_start":49,"col_end":49,"count":1}]},{"line":"","counters":[]},{"line":"  let rec gc_stat () =","counters":[]},{"line":"    let%bind () = after (Time_ns.Span.of_min !gc_stat_interval_mins) in","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"    current_gc := Gc.stat () ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"    gc_allocated_bytes := Gc.allocated_bytes () ;","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"    gc_stat ()","counters":[]},{"line":"","counters":[]},{"line":"  let simple_metric ~metric_type ~help name fn =","counters":[]},{"line":"    let name = Printf.sprintf \"%s_%s_%s\" namespace subsystem name in","counters":[{"col_start":4,"col_end":4,"count":14}]},{"line":"    let info =","counters":[{"col_start":4,"col_end":4,"count":14}]},{"line":"      { MetricInfo.name = MetricName.v name","counters":[{"col_start":37,"col_end":37,"count":14}]},{"line":"      ; help","counters":[]},{"line":"      ; metric_type","counters":[]},{"line":"      ; label_names = []","counters":[]},{"line":"      }","counters":[]},{"line":"    in","counters":[]},{"line":"    let collect () = LabelSetMap.singleton [] [ Sample_set.sample (fn ()) ] in","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":64,"col_end":64,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"    (info, collect)","counters":[]},{"line":"","counters":[]},{"line":"  let ocaml_gc_allocated_bytes =","counters":[]},{"line":"    simple_metric ~metric_type:Counter \"ocaml_gc_allocated_bytes\"","counters":[{"col_start":16,"col_end":16,"count":1}]},{"line":"      (fun () -> !gc_allocated_bytes)","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"      ~help:\"Total number of bytes allocated since the program was started.\"","counters":[]},{"line":"","counters":[]},{"line":"  let ocaml_gc_major_words =","counters":[]},{"line":"    simple_metric ~metric_type:Counter \"ocaml_gc_major_words\"","counters":[{"col_start":16,"col_end":16,"count":1}]},{"line":"      (fun () -> !current_gc.Gc.Stat.major_words)","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"      ~help:","counters":[]},{"line":"        \"Number of words allocated in the major heap since the program was \\","counters":[]},{"line":"         started.\"","counters":[]},{"line":"","counters":[]},{"line":"  let ocaml_gc_minor_collections =","counters":[]},{"line":"    simple_metric ~metric_type:Counter \"ocaml_gc_minor_collections\"","counters":[{"col_start":16,"col_end":16,"count":1}]},{"line":"      (fun () -> float_of_int !current_gc.Gc.Stat.minor_collections)","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"      ~help:","counters":[]},{"line":"        \"Number of minor collection cycles completed since the program was \\","counters":[]},{"line":"         started.\"","counters":[]},{"line":"","counters":[]},{"line":"  let ocaml_gc_major_collections =","counters":[]},{"line":"    simple_metric ~metric_type:Counter \"ocaml_gc_major_collections\"","counters":[{"col_start":16,"col_end":16,"count":1}]},{"line":"      (fun () -> float_of_int !current_gc.Gc.Stat.major_collections)","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"      ~help:","counters":[]},{"line":"        \"Number of major collection cycles completed since the program was \\","counters":[]},{"line":"         started.\"","counters":[]},{"line":"","counters":[]},{"line":"  let ocaml_gc_heap_words =","counters":[]},{"line":"    simple_metric ~metric_type:Gauge \"ocaml_gc_heap_words\"","counters":[{"col_start":16,"col_end":16,"count":1}]},{"line":"      (fun () -> float_of_int !current_gc.Gc.Stat.heap_words)","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"      ~help:\"Total size of the major heap, in words.\"","counters":[]},{"line":"","counters":[]},{"line":"  let ocaml_gc_compactions =","counters":[]},{"line":"    simple_metric ~metric_type:Counter \"ocaml_gc_compactions\"","counters":[{"col_start":16,"col_end":16,"count":1}]},{"line":"      (fun () -> float_of_int !current_gc.Gc.Stat.compactions)","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"      ~help:\"Number of heap compactions since the program was started.\"","counters":[]},{"line":"","counters":[]},{"line":"  let ocaml_gc_top_heap_words =","counters":[]},{"line":"    simple_metric ~metric_type:Counter \"ocaml_gc_top_heap_words\"","counters":[{"col_start":16,"col_end":16,"count":1}]},{"line":"      (fun () -> float_of_int !current_gc.Gc.Stat.top_heap_words)","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"      ~help:\"Maximum size reached by the major heap, in words.\"","counters":[]},{"line":"","counters":[]},{"line":"  let ocaml_gc_live_words =","counters":[]},{"line":"    simple_metric ~metric_type:Counter \"ocaml_gc_live_words\"","counters":[{"col_start":16,"col_end":16,"count":1}]},{"line":"      (fun () -> float_of_int !current_gc.Gc.Stat.live_words)","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"      ~help:\"Live words allocated by the GC.\"","counters":[]},{"line":"","counters":[]},{"line":"  let ocaml_gc_free_words =","counters":[]},{"line":"    simple_metric ~metric_type:Counter \"ocaml_gc_free_words\"","counters":[{"col_start":16,"col_end":16,"count":1}]},{"line":"      (fun () -> float_of_int !current_gc.Gc.Stat.free_words)","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"      ~help:\"Words freed by the GC.\"","counters":[]},{"line":"","counters":[]},{"line":"  let ocaml_gc_largest_free =","counters":[]},{"line":"    simple_metric ~metric_type:Counter \"ocaml_gc_largest_free\"","counters":[{"col_start":16,"col_end":16,"count":1}]},{"line":"      (fun () -> float_of_int !current_gc.Gc.Stat.largest_free)","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"      ~help:\"Size of the largest block freed by the GC.\"","counters":[]},{"line":"","counters":[]},{"line":"  let ocaml_gc_fragments =","counters":[]},{"line":"    simple_metric ~metric_type:Counter \"ocaml_gc_fragments\"","counters":[{"col_start":16,"col_end":16,"count":1}]},{"line":"      (fun () -> float_of_int !current_gc.Gc.Stat.fragments)","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"      ~help:\"No. of heap fragments.\"","counters":[]},{"line":"","counters":[]},{"line":"  let ocaml_gc_stack_size =","counters":[]},{"line":"    simple_metric ~metric_type:Counter \"ocaml_gc_stack_size\"","counters":[{"col_start":16,"col_end":16,"count":1}]},{"line":"      (fun () -> float_of_int !current_gc.Gc.Stat.stack_size)","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"      ~help:\"Current stack size.\"","counters":[]},{"line":"","counters":[]},{"line":"  let process_cpu_seconds_total =","counters":[]},{"line":"    simple_metric ~metric_type:Counter \"process_cpu_seconds_total\" Sys.time","counters":[{"col_start":16,"col_end":16,"count":1}]},{"line":"      ~help:\"Total user and system CPU time spent in seconds.\"","counters":[]},{"line":"","counters":[]},{"line":"  let process_uptime_ms_total =","counters":[]},{"line":"    simple_metric ~metric_type:Counter \"process_uptime_ms_total\"","counters":[{"col_start":16,"col_end":16,"count":1}]},{"line":"      (fun () ->","counters":[]},{"line":"        Core.Time.Span.to_ms (Core.Time.diff (Core.Time.now ()) start_time) )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":43,"col_end":43,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"      ~help:\"Total time the process has been running for in milliseconds.\"","counters":[]},{"line":"","counters":[]},{"line":"  let metrics =","counters":[]},{"line":"    [ ocaml_gc_allocated_bytes","counters":[]},{"line":"    ; ocaml_gc_major_words","counters":[]},{"line":"    ; ocaml_gc_minor_collections","counters":[]},{"line":"    ; ocaml_gc_major_collections","counters":[]},{"line":"    ; ocaml_gc_heap_words","counters":[]},{"line":"    ; ocaml_gc_compactions","counters":[]},{"line":"    ; ocaml_gc_top_heap_words","counters":[]},{"line":"    ; ocaml_gc_live_words","counters":[]},{"line":"    ; ocaml_gc_free_words","counters":[]},{"line":"    ; ocaml_gc_largest_free","counters":[]},{"line":"    ; ocaml_gc_fragments","counters":[]},{"line":"    ; ocaml_gc_stack_size","counters":[]},{"line":"    ; process_cpu_seconds_total","counters":[]},{"line":"    ; process_uptime_ms_total","counters":[]},{"line":"    ]","counters":[]},{"line":"","counters":[]},{"line":"  let () =","counters":[]},{"line":"    let open CollectorRegistry in","counters":[]},{"line":"    List.iter metrics ~f:(fun (info, collector) ->","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"        register default info collector )","counters":[{"col_start":8,"col_end":8,"count":14}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Cryptography = struct","counters":[]},{"line":"  let subsystem = \"Cryptography\"","counters":[]},{"line":"","counters":[]},{"line":"  let blockchain_proving_time_ms =","counters":[]},{"line":"    let help =","counters":[]},{"line":"      \"time elapsed while proving most recently generated blockchain snark\"","counters":[]},{"line":"    in","counters":[]},{"line":"    Gauge.v \"blockchain_proving_time_ms\" ~help ~namespace ~subsystem","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"","counters":[]},{"line":"  let total_pedersen_hashes_computed =","counters":[]},{"line":"    let help = \"# of pedersen hashes computed\" in","counters":[]},{"line":"    Counter.v \"total_pedersen_hash_computed\" ~help ~namespace ~subsystem","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  module Snark_work_histogram = Histogram (struct","counters":[]},{"line":"    let spec = Histogram_spec.of_linear 60. 30. 8","counters":[{"col_start":38,"col_end":38,"count":1}]},{"line":"  end)","counters":[]},{"line":"","counters":[]},{"line":"  let snark_work_merge_time_sec =","counters":[]},{"line":"    let help = \"time elapsed while doing merge proof\" in","counters":[]},{"line":"    Snark_work_histogram.v \"snark_work_merge_time_sec\" ~help ~namespace","counters":[{"col_start":25,"col_end":25,"count":1}]},{"line":"      ~subsystem","counters":[]},{"line":"","counters":[]},{"line":"  let snark_work_zkapp_base_time_sec =","counters":[]},{"line":"    let help = \"time elapsed while doing base proof for a zkapp transaction\" in","counters":[]},{"line":"    Counter.v \"snark_work_zkapp_base_time_sec\" ~help ~namespace ~subsystem","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let snark_work_base_time_sec =","counters":[]},{"line":"    let help =","counters":[]},{"line":"      \"time elapsed while doing base proof for a non-zkapp transaction\"","counters":[]},{"line":"    in","counters":[]},{"line":"    Counter.v \"snark_work_base_time_sec\" ~help ~namespace ~subsystem","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let snark_work_zkapp_base_submissions =","counters":[]},{"line":"    let help =","counters":[]},{"line":"      \"Number of base transactions snarks for zkapp transactions submitted\"","counters":[]},{"line":"    in","counters":[]},{"line":"    Counter.v \"snark_work_zkapp_base_submissions\" ~help ~namespace ~subsystem","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let snark_work_base_submissions =","counters":[]},{"line":"    let help =","counters":[]},{"line":"      \"Number of base transactions snarks for non-zkapp transactions submitted\"","counters":[]},{"line":"    in","counters":[]},{"line":"    Counter.v \"snark_work_base_submissions\" ~help ~namespace ~subsystem","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let zkapp_transaction_length =","counters":[]},{"line":"    let help = \"Number of updates in a zkapp transaction\" in","counters":[]},{"line":"    Counter.v \"zkapp_transaction_length\" ~help ~namespace ~subsystem","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let zkapp_proof_updates =","counters":[]},{"line":"    let help =","counters":[]},{"line":"      \"Number of updates with proof authorization in a zkapp transaction\"","counters":[]},{"line":"    in","counters":[]},{"line":"    Counter.v \"zkapp_proof_updates\" ~help ~namespace ~subsystem","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  (* TODO:","counters":[]},{"line":"     let transaction_proving_time_ms =","counters":[]},{"line":"       let help = \"time elapsed while proving most recently generated transaction snark\" in","counters":[]},{"line":"       Gauge.v \"transaction_proving_time_ms\" ~help ~namespace ~subsystem","counters":[]},{"line":"  *)","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Bootstrap = struct","counters":[]},{"line":"  let subsystem = \"Bootstrap\"","counters":[]},{"line":"","counters":[]},{"line":"  let bootstrap_time_ms =","counters":[]},{"line":"    let help = \"time elapsed while bootstrapping\" in","counters":[]},{"line":"    Gauge.v \"bootstrap_time_ms\" ~help ~namespace ~subsystem","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"","counters":[]},{"line":"  let staking_epoch_ledger_sync_ms =","counters":[]},{"line":"    let help = \"time elapsed when sync staking epoch ledger in ms\" in","counters":[]},{"line":"    Counter.v \"staking_epoch_ledger_sync_ms\" ~help ~namespace ~subsystem","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let next_epoch_ledger_sync_ms =","counters":[]},{"line":"    let help = \"time elapsed when sync next epoch ledger in ms\" in","counters":[]},{"line":"    Counter.v \"next_epoch_ledger_sync_ms\" ~help ~namespace ~subsystem","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let root_snarked_ledger_sync_ms =","counters":[]},{"line":"    let help = \"time elapsed when sync root snarked ledger in ms\" in","counters":[]},{"line":"    Counter.v \"root_snarked_ledger_sync_ms\" ~help ~namespace ~subsystem","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let num_of_root_snarked_ledger_retargeted =","counters":[]},{"line":"    let help =","counters":[]},{"line":"      \"number of times root_snarked_ledger retargeted during bootstrap\"","counters":[]},{"line":"    in","counters":[]},{"line":"    Gauge.v \"num_of_root_snarked_ledger_retargeted\" ~help ~namespace ~subsystem","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Transaction_pool = struct","counters":[]},{"line":"  let subsystem = \"Transaction_pool\"","counters":[]},{"line":"","counters":[]},{"line":"  let useful_transactions_received_time_sec : Gauge.t =","counters":[]},{"line":"    let help =","counters":[]},{"line":"      \"Time at which useful transactions were seen (seconds since 1/1/1970)\"","counters":[]},{"line":"    in","counters":[]},{"line":"    Gauge.v \"useful_transactions_received_time_sec\" ~help ~namespace ~subsystem","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"","counters":[]},{"line":"  let pool_size : Gauge.t =","counters":[]},{"line":"    let help = \"Number of transactions in the pool\" in","counters":[]},{"line":"    Gauge.v \"size\" ~help ~namespace ~subsystem","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"","counters":[]},{"line":"  let transactions_added_to_pool : Counter.t =","counters":[]},{"line":"    let help =","counters":[]},{"line":"      \"Number of transactions added to the pool since the node start\"","counters":[]},{"line":"    in","counters":[]},{"line":"    Counter.v \"transactions_added_to_pool\" ~help ~namespace ~subsystem","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let zkapp_transactions_added_to_pool : Counter.t =","counters":[]},{"line":"    let help =","counters":[]},{"line":"      \"Number of zkapp transactions added to the pool since the node start\"","counters":[]},{"line":"    in","counters":[]},{"line":"    Counter.v \"zkapp_transactions_added_to_pool\" ~help ~namespace ~subsystem","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let zkapp_transaction_size : Counter.t =","counters":[]},{"line":"    let help = \"Size of valid zkapp transaction received (bin_size_t)\" in","counters":[]},{"line":"    Counter.v \"zkapp_transaction_size\" ~help ~namespace ~subsystem","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let zkapp_updates : Counter.t =","counters":[]},{"line":"    let help =","counters":[]},{"line":"      \"Number of account updates in a valid zkapp transaction received\"","counters":[]},{"line":"    in","counters":[]},{"line":"    Counter.v \"zkapp_updates\" ~help ~namespace ~subsystem","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let zkapp_proof_updates : Counter.t =","counters":[]},{"line":"    let help =","counters":[]},{"line":"      \"Number of account updates with proof authorization in a zkapp \\","counters":[]},{"line":"       transaction\"","counters":[]},{"line":"    in","counters":[]},{"line":"    Counter.v \"zkapp_proof_updates\" ~help ~namespace ~subsystem","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Metric_map (Metric : sig","counters":[]},{"line":"  type t","counters":[]},{"line":"","counters":[]},{"line":"  val subsystem : string","counters":[]},{"line":"","counters":[]},{"line":"  val v :","counters":[]},{"line":"       ?registry:CollectorRegistry.t","counters":[]},{"line":"    -> help:string","counters":[]},{"line":"    -> ?namespace:string","counters":[]},{"line":"    -> ?subsystem:string","counters":[]},{"line":"    -> string","counters":[]},{"line":"    -> t","counters":[]},{"line":"end) =","counters":[]},{"line":"struct","counters":[]},{"line":"  module Metric_name_map = Hashtbl.Make (String)","counters":[]},{"line":"  include Metric_name_map","counters":[]},{"line":"","counters":[]},{"line":"  let add t ~name ~help : Metric.t =","counters":[]},{"line":"    if Metric_name_map.mem t name then Metric_name_map.find_exn t name","counters":[{"col_start":4,"col_end":4,"count":24},{"col_start":39,"col_end":39,"count":11}]},{"line":"    else","counters":[]},{"line":"      let metric = Metric.v ~help ~namespace ~subsystem:Metric.subsystem name in","counters":[{"col_start":6,"col_end":6,"count":13}]},{"line":"      Metric_name_map.add_exn t ~key:name ~data:metric ;","counters":[{"col_start":6,"col_end":6,"count":13}]},{"line":"      metric","counters":[{"col_start":6,"col_end":6,"count":13}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Network = struct","counters":[]},{"line":"  let subsystem = \"Network\"","counters":[]},{"line":"","counters":[]},{"line":"  let peers : Gauge.t =","counters":[]},{"line":"    let help = \"# of peers seen through gossip net\" in","counters":[]},{"line":"    Gauge.v \"peers\" ~help ~namespace ~subsystem","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"","counters":[]},{"line":"  let all_peers : Gauge.t =","counters":[]},{"line":"    let help = \"# of peers ever seen through gossip net\" in","counters":[]},{"line":"    Gauge.v \"all_peers\" ~help ~namespace ~subsystem","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"","counters":[]},{"line":"  let validations_timed_out : Counter.t =","counters":[]},{"line":"    let help = \"# of received messages whose validation timed out\" in","counters":[]},{"line":"    Counter.v \"validations_timed_out\" ~help ~namespace ~subsystem","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let gossip_messages_failed_to_decode : Counter.t =","counters":[]},{"line":"    let help = \"# of received messages that could not be decoded\" in","counters":[]},{"line":"    Counter.v \"gossip_messages_failed_to_decode\" ~help ~namespace ~subsystem","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let gossip_messages_received : Counter.t =","counters":[]},{"line":"    let help = \"# of messages received\" in","counters":[]},{"line":"    Counter.v \"messages_received\" ~help ~namespace ~subsystem","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  module Delay_time_spec = struct","counters":[]},{"line":"    let tick_interval =","counters":[]},{"line":"      Core.Time.Span.of_ms (Int.to_float block_window_duration)","counters":[{"col_start":25,"col_end":25,"count":1},{"col_start":39,"col_end":39,"count":1}]},{"line":"","counters":[]},{"line":"    let rolling_interval =","counters":[]},{"line":"      Core.Time.Span.of_ms (Int.to_float (block_window_duration * 20))","counters":[{"col_start":25,"col_end":25,"count":1},{"col_start":39,"col_end":39,"count":1}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Block = struct","counters":[]},{"line":"    let subsystem = \"Block\"","counters":[]},{"line":"","counters":[]},{"line":"    let validations_timed_out : Counter.t =","counters":[]},{"line":"      let help = \"# of received blocks whose validation timed out\" in","counters":[]},{"line":"      Counter.v \"validations_timed_out\" ~help ~namespace ~subsystem","counters":[{"col_start":14,"col_end":14,"count":1}]},{"line":"","counters":[]},{"line":"    let rejected : Counter.t =","counters":[]},{"line":"      let help = \"# of received blocks failing validation\" in","counters":[]},{"line":"      Counter.v \"rejected\" ~help ~namespace ~subsystem","counters":[{"col_start":14,"col_end":14,"count":1}]},{"line":"","counters":[]},{"line":"    let ignored : Counter.t =","counters":[]},{"line":"      let help = \"# of received blocks ignored\" in","counters":[]},{"line":"      Counter.v \"ignored\" ~help ~namespace ~subsystem","counters":[{"col_start":14,"col_end":14,"count":1}]},{"line":"","counters":[]},{"line":"    let received : Counter.t =","counters":[]},{"line":"      let help = \"# of blocks received\" in","counters":[]},{"line":"      Counter.v \"received\" ~help ~namespace ~subsystem","counters":[{"col_start":14,"col_end":14,"count":1}]},{"line":"","counters":[]},{"line":"    module Validation_time =","counters":[]},{"line":"      Moving_time_average","counters":[]},{"line":"        (struct","counters":[]},{"line":"          include Delay_time_spec","counters":[]},{"line":"","counters":[]},{"line":"          let subsystem = subsystem","counters":[]},{"line":"","counters":[]},{"line":"          let name = \"validation_time\"","counters":[]},{"line":"","counters":[]},{"line":"          let help =","counters":[]},{"line":"            \"average time, in ms, for blocks to be validated and rebroadcasted\"","counters":[]},{"line":"        end)","counters":[]},{"line":"        ()","counters":[]},{"line":"","counters":[]},{"line":"    module Processing_time =","counters":[]},{"line":"      Moving_time_average","counters":[]},{"line":"        (struct","counters":[]},{"line":"          include Delay_time_spec","counters":[]},{"line":"","counters":[]},{"line":"          let subsystem = subsystem","counters":[]},{"line":"","counters":[]},{"line":"          let name = \"processing_time\"","counters":[]},{"line":"","counters":[]},{"line":"          let help =","counters":[]},{"line":"            \"average time, in ms, for blocks to be accepted after the OCaml \\","counters":[]},{"line":"             process receives it\"","counters":[]},{"line":"        end)","counters":[]},{"line":"        ()","counters":[]},{"line":"","counters":[]},{"line":"    module Rejection_time =","counters":[]},{"line":"      Moving_time_average","counters":[]},{"line":"        (struct","counters":[]},{"line":"          include Delay_time_spec","counters":[]},{"line":"","counters":[]},{"line":"          let subsystem = subsystem","counters":[]},{"line":"","counters":[]},{"line":"          let name = \"rejection_time\"","counters":[]},{"line":"","counters":[]},{"line":"          let help =","counters":[]},{"line":"            \"average time, in ms, for blocks to be rejected after the OCaml \\","counters":[]},{"line":"             process receives it\"","counters":[]},{"line":"        end)","counters":[]},{"line":"        ()","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Snark_work = struct","counters":[]},{"line":"    let subsystem = \"Snark_work\"","counters":[]},{"line":"","counters":[]},{"line":"    let validations_timed_out : Counter.t =","counters":[]},{"line":"      let help = \"# of received snark work whose validation timed out\" in","counters":[]},{"line":"      Counter.v \"validations_timed_out\" ~help ~namespace ~subsystem","counters":[{"col_start":14,"col_end":14,"count":1}]},{"line":"","counters":[]},{"line":"    let rejected : Counter.t =","counters":[]},{"line":"      let help = \"# of received snark work failing validation\" in","counters":[]},{"line":"      Counter.v \"rejected\" ~help ~namespace ~subsystem","counters":[{"col_start":14,"col_end":14,"count":1}]},{"line":"","counters":[]},{"line":"    let ignored : Counter.t =","counters":[]},{"line":"      let help = \"# of received snark work ignored\" in","counters":[]},{"line":"      Counter.v \"ignored\" ~help ~namespace ~subsystem","counters":[{"col_start":14,"col_end":14,"count":1}]},{"line":"","counters":[]},{"line":"    let received : Counter.t =","counters":[]},{"line":"      let help = \"# of snark work received\" in","counters":[]},{"line":"      Counter.v \"received\" ~help ~namespace ~subsystem","counters":[{"col_start":14,"col_end":14,"count":1}]},{"line":"","counters":[]},{"line":"    module Validation_time =","counters":[]},{"line":"      Moving_time_average","counters":[]},{"line":"        (struct","counters":[]},{"line":"          include Delay_time_spec","counters":[]},{"line":"","counters":[]},{"line":"          let subsystem = subsystem","counters":[]},{"line":"","counters":[]},{"line":"          let name = \"validation_time\"","counters":[]},{"line":"","counters":[]},{"line":"          let help =","counters":[]},{"line":"            \"average delay, in ms, for snark work to be validated and \\","counters":[]},{"line":"             rebroadcasted\"","counters":[]},{"line":"        end)","counters":[]},{"line":"        ()","counters":[]},{"line":"","counters":[]},{"line":"    module Processing_time =","counters":[]},{"line":"      Moving_time_average","counters":[]},{"line":"        (struct","counters":[]},{"line":"          include Delay_time_spec","counters":[]},{"line":"","counters":[]},{"line":"          let subsystem = subsystem","counters":[]},{"line":"","counters":[]},{"line":"          let name = \"processing_time\"","counters":[]},{"line":"","counters":[]},{"line":"          let help =","counters":[]},{"line":"            \"average delay, in ms, for snark work to be accepted after the \\","counters":[]},{"line":"             OCaml process receives it\"","counters":[]},{"line":"        end)","counters":[]},{"line":"        ()","counters":[]},{"line":"","counters":[]},{"line":"    module Rejection_time =","counters":[]},{"line":"      Moving_time_average","counters":[]},{"line":"        (struct","counters":[]},{"line":"          include Delay_time_spec","counters":[]},{"line":"","counters":[]},{"line":"          let subsystem = subsystem","counters":[]},{"line":"","counters":[]},{"line":"          let name = \"rejection_time\"","counters":[]},{"line":"","counters":[]},{"line":"          let help =","counters":[]},{"line":"            \"average time, in ms, for snark work to be rejected after the \\","counters":[]},{"line":"             OCaml process receives it\"","counters":[]},{"line":"        end)","counters":[]},{"line":"        ()","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Transaction = struct","counters":[]},{"line":"    let subsystem = \"Transaction\"","counters":[]},{"line":"","counters":[]},{"line":"    let validations_timed_out : Counter.t =","counters":[]},{"line":"      let help = \"# of received transactions whose validation timed out\" in","counters":[]},{"line":"      Counter.v \"validations_timed_out\" ~help ~namespace ~subsystem","counters":[{"col_start":14,"col_end":14,"count":1}]},{"line":"","counters":[]},{"line":"    let rejected : Counter.t =","counters":[]},{"line":"      let help = \"# of received transactions failing validation\" in","counters":[]},{"line":"      Counter.v \"rejected\" ~help ~namespace ~subsystem","counters":[{"col_start":14,"col_end":14,"count":1}]},{"line":"","counters":[]},{"line":"    let ignored : Counter.t =","counters":[]},{"line":"      let help = \"# of received transactions ignored\" in","counters":[]},{"line":"      Counter.v \"ignored\" ~help ~namespace ~subsystem","counters":[{"col_start":14,"col_end":14,"count":1}]},{"line":"","counters":[]},{"line":"    let received : Counter.t =","counters":[]},{"line":"      let help = \"# of transactions received\" in","counters":[]},{"line":"      Counter.v \"received\" ~help ~namespace ~subsystem","counters":[{"col_start":14,"col_end":14,"count":1}]},{"line":"","counters":[]},{"line":"    module Validation_time =","counters":[]},{"line":"      Moving_time_average","counters":[]},{"line":"        (struct","counters":[]},{"line":"          include Delay_time_spec","counters":[]},{"line":"","counters":[]},{"line":"          let subsystem = subsystem","counters":[]},{"line":"","counters":[]},{"line":"          let name = \"validation_time\"","counters":[]},{"line":"","counters":[]},{"line":"          let help =","counters":[]},{"line":"            \"average delay, in ms, for transactions to be validated and \\","counters":[]},{"line":"             rebroadcasted\"","counters":[]},{"line":"        end)","counters":[]},{"line":"        ()","counters":[]},{"line":"","counters":[]},{"line":"    module Processing_time =","counters":[]},{"line":"      Moving_time_average","counters":[]},{"line":"        (struct","counters":[]},{"line":"          include Delay_time_spec","counters":[]},{"line":"","counters":[]},{"line":"          let subsystem = subsystem","counters":[]},{"line":"","counters":[]},{"line":"          let name = \"processing_time\"","counters":[]},{"line":"","counters":[]},{"line":"          let help =","counters":[]},{"line":"            \"average delay, in ms, for transactions to be accepted after the \\","counters":[]},{"line":"             OCaml process receives it\"","counters":[]},{"line":"        end)","counters":[]},{"line":"        ()","counters":[]},{"line":"","counters":[]},{"line":"    module Rejection_time =","counters":[]},{"line":"      Moving_time_average","counters":[]},{"line":"        (struct","counters":[]},{"line":"          include Delay_time_spec","counters":[]},{"line":"","counters":[]},{"line":"          let subsystem = subsystem","counters":[]},{"line":"","counters":[]},{"line":"          let name = \"rejection_time\"","counters":[]},{"line":"","counters":[]},{"line":"          let help =","counters":[]},{"line":"            \"average time, in ms, for transactions to be rejected after the \\","counters":[]},{"line":"             OCaml process receives it\"","counters":[]},{"line":"        end)","counters":[]},{"line":"        ()","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let rpc_requests_received : Counter.t =","counters":[]},{"line":"    let help = \"# of rpc requests received\" in","counters":[]},{"line":"    Counter.v \"rpc_requests_received\" ~help ~namespace ~subsystem","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let rpc_requests_sent : Counter.t =","counters":[]},{"line":"    let help = \"# of rpc requests sent\" in","counters":[]},{"line":"    Counter.v \"rpc_requests_sent\" ~help ~namespace ~subsystem","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let surfix = \"_five_slots\"","counters":[]},{"line":"","counters":[]},{"line":"  let get_some_initial_peers_rpcs_sent =","counters":[]},{"line":"    let help = \"# of Get_some_initial_peers rpc requests sent\" in","counters":[]},{"line":"    let name = \"get_some_initial_peers_rpcs_sent\" in","counters":[]},{"line":"    ( Counter.v name ~help ~namespace ~subsystem","counters":[{"col_start":14,"col_end":14,"count":1}]},{"line":"    , Gauge.v (name ^ surfix) ~help ~namespace ~subsystem )","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let get_some_initial_peers_rpcs_received =","counters":[]},{"line":"    let help = \"# of Get_some_initial_peers rpc requests received\" in","counters":[]},{"line":"    let name = \"get_some_initial_peers_rpcs_received\" in","counters":[]},{"line":"    ( Counter.v name ~help ~namespace ~subsystem","counters":[{"col_start":14,"col_end":14,"count":1}]},{"line":"    , Gauge.v (name ^ surfix) ~help ~namespace ~subsystem )","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let get_some_initial_peers_rpc_requests_failed : Counter.t =","counters":[]},{"line":"    let help = \"# of Get_some_initial_peers rpc requests failed\" in","counters":[]},{"line":"    Counter.v \"get_some_initial_peers_rpc_requests_failed\" ~help ~namespace","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"      ~subsystem","counters":[]},{"line":"","counters":[]},{"line":"  let get_some_initial_peers_rpc_responses_failed : Counter.t =","counters":[]},{"line":"    let help = \"# of Get_some_initial_peers rpc requests failed to respond\" in","counters":[]},{"line":"    Counter.v \"get_some_initial_peers_rpc_responses_failed\" ~help ~namespace","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"      ~subsystem","counters":[]},{"line":"","counters":[]},{"line":"  let get_staged_ledger_aux_and_pending_coinbases_at_hash_rpcs_sent =","counters":[]},{"line":"    let help =","counters":[]},{"line":"      \"# of Get_staged_ledger_aux_and_pending_coinbases_at_hash rpc requests \\","counters":[]},{"line":"       sent\"","counters":[]},{"line":"    in","counters":[]},{"line":"    let name =","counters":[]},{"line":"      \"get_staged_ledger_aux_and_pending_coinbases_at_hash_rpcs_sent\"","counters":[]},{"line":"    in","counters":[]},{"line":"    ( Counter.v name ~help ~namespace ~subsystem","counters":[{"col_start":14,"col_end":14,"count":1}]},{"line":"    , Gauge.v (name ^ surfix) ~help ~namespace ~subsystem )","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let get_staged_ledger_aux_and_pending_coinbases_at_hash_rpcs_received =","counters":[]},{"line":"    let help =","counters":[]},{"line":"      \"# of Get_staged_ledger_aux_and_pending_coinbases_at_hash rpc requests \\","counters":[]},{"line":"       received\"","counters":[]},{"line":"    in","counters":[]},{"line":"    let name =","counters":[]},{"line":"      \"get_staged_ledger_aux_and_pending_coinbases_at_hash_rpcs_received\"","counters":[]},{"line":"    in","counters":[]},{"line":"    ( Counter.v name ~help ~namespace ~subsystem","counters":[{"col_start":14,"col_end":14,"count":1}]},{"line":"    , Gauge.v (name ^ surfix) ~help ~namespace ~subsystem )","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let get_staged_ledger_aux_and_pending_coinbases_at_hash_rpc_requests_failed :","counters":[]},{"line":"      Counter.t =","counters":[]},{"line":"    let help =","counters":[]},{"line":"      \"# of Get_staged_ledger_aux_and_pending_coinbases_at_hash rpc requests \\","counters":[]},{"line":"       failed\"","counters":[]},{"line":"    in","counters":[]},{"line":"    Counter.v","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"      \"get_staged_ledger_aux_and_pending_coinbases_at_hash_rpc_requests_failed\"","counters":[]},{"line":"      ~help ~namespace ~subsystem","counters":[]},{"line":"","counters":[]},{"line":"  let get_staged_ledger_aux_and_pending_coinbases_at_hash_rpc_responses_failed :","counters":[]},{"line":"      Counter.t =","counters":[]},{"line":"    let help =","counters":[]},{"line":"      \"# of Get_staged_ledger_aux_and_pending_coinbases_at_hash rpc requests \\","counters":[]},{"line":"       failed to respond\"","counters":[]},{"line":"    in","counters":[]},{"line":"    Counter.v","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"      \"get_staged_ledger_aux_and_pending_coinbases_at_hash_rpc_responses_failed\"","counters":[]},{"line":"      ~help ~namespace ~subsystem","counters":[]},{"line":"","counters":[]},{"line":"  let answer_sync_ledger_query_rpcs_sent =","counters":[]},{"line":"    let help = \"# of Answer_sync_ledger_query rpc requests sent\" in","counters":[]},{"line":"    let name = \"answer_sync_ledger_query_rpcs_sent\" in","counters":[]},{"line":"    ( Counter.v name ~help ~namespace ~subsystem","counters":[{"col_start":14,"col_end":14,"count":1}]},{"line":"    , Gauge.v (name ^ surfix) ~help ~namespace ~subsystem )","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let answer_sync_ledger_query_rpcs_received =","counters":[]},{"line":"    let help = \"# of Answer_synce_ledger_query rpc requests received\" in","counters":[]},{"line":"    let name = \"answer_sync_ledger_query_rpcs_received\" in","counters":[]},{"line":"    ( Counter.v name ~help ~namespace ~subsystem","counters":[{"col_start":14,"col_end":14,"count":1}]},{"line":"    , Gauge.v (name ^ surfix) ~help ~namespace ~subsystem )","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let answer_sync_ledger_query_rpc_requests_failed : Counter.t =","counters":[]},{"line":"    let help = \"# of Answer_sync_ledger_query rpc requests failed\" in","counters":[]},{"line":"    Counter.v \"answer_sync_ledger_query_rpc_requests_failed\" ~help ~namespace","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"      ~subsystem","counters":[]},{"line":"","counters":[]},{"line":"  let answer_sync_ledger_query_rpc_responses_failed : Counter.t =","counters":[]},{"line":"    let help = \"# of Answer_sync_ledger_query rpc requests failed to respond\" in","counters":[]},{"line":"    Counter.v \"answer_sync_ledger_query_rpc_responses_failed\" ~help ~namespace","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"      ~subsystem","counters":[]},{"line":"","counters":[]},{"line":"  let get_transition_chain_rpcs_sent =","counters":[]},{"line":"    let help = \"# of Get_transition_chain rpc requests sent\" in","counters":[]},{"line":"    let name = \"get_transition_chain_rpcs_sent\" in","counters":[]},{"line":"    ( Counter.v name ~help ~namespace ~subsystem","counters":[{"col_start":14,"col_end":14,"count":1}]},{"line":"    , Gauge.v (name ^ surfix) ~help ~namespace ~subsystem )","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let get_transition_chain_rpcs_received =","counters":[]},{"line":"    let help = \"# of Get_transition_chain rpc requests received\" in","counters":[]},{"line":"    let name = \"get_transition_chain_rpcs_received\" in","counters":[]},{"line":"    ( Counter.v name ~help ~namespace ~subsystem","counters":[{"col_start":14,"col_end":14,"count":1}]},{"line":"    , Gauge.v (name ^ surfix) ~help ~namespace ~subsystem )","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let get_transition_chain_rpc_requests_failed : Counter.t =","counters":[]},{"line":"    let help = \"# of Get_some_initial_peers rpc requests failed\" in","counters":[]},{"line":"    Counter.v \"get_transition_chain_rpc_requests_failed\" ~help ~namespace","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"      ~subsystem","counters":[]},{"line":"","counters":[]},{"line":"  let get_transition_chain_rpc_responses_failed : Counter.t =","counters":[]},{"line":"    let help = \"# of Get_transition_chain rpc requests failed to respond\" in","counters":[]},{"line":"    Counter.v \"get_transition_chain_rpc_responses_failed\" ~help ~namespace","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"      ~subsystem","counters":[]},{"line":"","counters":[]},{"line":"  let get_transition_knowledge_rpcs_sent =","counters":[]},{"line":"    let help = \"# of Get_transition_knowledge rpc requests sent\" in","counters":[]},{"line":"    let name = \"get_transition_knowledge_rpcs_sent\" in","counters":[]},{"line":"    ( Counter.v name ~help ~namespace ~subsystem","counters":[{"col_start":14,"col_end":14,"count":1}]},{"line":"    , Gauge.v (name ^ surfix) ~help ~namespace ~subsystem )","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let get_transition_knowledge_rpcs_received =","counters":[]},{"line":"    let help = \"# of Get_transition_knowledge rpc requests received\" in","counters":[]},{"line":"    let name = \"get_transition_knowledge_rpcs_received\" in","counters":[]},{"line":"    ( Counter.v name ~help ~namespace ~subsystem","counters":[{"col_start":14,"col_end":14,"count":1}]},{"line":"    , Gauge.v (name ^ surfix) ~help ~namespace ~subsystem )","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let get_transition_knowledge_rpc_requests_failed : Counter.t =","counters":[]},{"line":"    let help = \"# of Get_transition_knowledge rpc requests failed\" in","counters":[]},{"line":"    Counter.v \"get_transition_knowledge_rpc_requests_failed\" ~help ~namespace","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"      ~subsystem","counters":[]},{"line":"","counters":[]},{"line":"  let get_transition_knowledge_rpc_responses_failed : Counter.t =","counters":[]},{"line":"    let help = \"# of Get_transition_knowledge rpc requests failed to respond\" in","counters":[]},{"line":"    Counter.v \"get_transition_knowledge_rpc_responses_failed\" ~help ~namespace","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"      ~subsystem","counters":[]},{"line":"","counters":[]},{"line":"  let get_transition_chain_proof_rpcs_sent =","counters":[]},{"line":"    let help = \"# of Get_transition_chain_proof rpc requests sent\" in","counters":[]},{"line":"    let name = \"get_transition_chain_proof_rpcs_sent\" in","counters":[]},{"line":"    ( Counter.v name ~help ~namespace ~subsystem","counters":[{"col_start":14,"col_end":14,"count":1}]},{"line":"    , Gauge.v (name ^ surfix) ~help ~namespace ~subsystem )","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let get_transition_chain_proof_rpcs_received =","counters":[]},{"line":"    let help = \"# of Get_transition_chain_proof rpc requests received\" in","counters":[]},{"line":"    let name = \"get_transition_chain_proof_rpcs_received\" in","counters":[]},{"line":"    ( Counter.v name ~help ~namespace ~subsystem","counters":[{"col_start":14,"col_end":14,"count":1}]},{"line":"    , Gauge.v (name ^ surfix) ~help ~namespace ~subsystem )","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let get_transition_chain_proof_rpc_requests_failed : Counter.t =","counters":[]},{"line":"    let help = \"# of Get_transition_chain_proof rpc requests failed\" in","counters":[]},{"line":"    Counter.v \"get_transition_chain_proof_rpc_requests_failed\" ~help ~namespace","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"      ~subsystem","counters":[]},{"line":"","counters":[]},{"line":"  let get_transition_chain_proof_rpc_responses_failed : Counter.t =","counters":[]},{"line":"    let help =","counters":[]},{"line":"      \"# of Get_transition_chain_proof rpc requests failed to respond\"","counters":[]},{"line":"    in","counters":[]},{"line":"    Counter.v \"get_transition_chain_proof_rpc_responses_failed\" ~help ~namespace","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"      ~subsystem","counters":[]},{"line":"","counters":[]},{"line":"  let get_node_status_rpcs_sent =","counters":[]},{"line":"    let help = \"# of Get_node_status rpc requests sent\" in","counters":[]},{"line":"    let name = \"get_node_status_rpcs_sent\" in","counters":[]},{"line":"    ( Counter.v name ~help ~namespace ~subsystem","counters":[{"col_start":14,"col_end":14,"count":1}]},{"line":"    , Gauge.v (name ^ surfix) ~help ~namespace ~subsystem )","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let get_node_status_rpcs_received =","counters":[]},{"line":"    let help = \"# of Get_node_status rpc requests received\" in","counters":[]},{"line":"    let name = \"get_node_status_rpcs_received\" in","counters":[]},{"line":"    ( Counter.v name ~help ~namespace ~subsystem","counters":[{"col_start":14,"col_end":14,"count":1}]},{"line":"    , Gauge.v (name ^ surfix) ~help ~namespace ~subsystem )","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let get_node_status_rpc_requests_failed : Counter.t =","counters":[]},{"line":"    let help = \"# of Get_node_status rpc requests failed\" in","counters":[]},{"line":"    Counter.v \"get_node_status_rpc_requests_failed\" ~help ~namespace ~subsystem","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let get_node_status_rpc_responses_failed : Counter.t =","counters":[]},{"line":"    let help = \"# of Get_node_status rpc requests failed to respond\" in","counters":[]},{"line":"    Counter.v \"get_node_status_rpc_responses_failed\" ~help ~namespace ~subsystem","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let get_ancestry_rpcs_sent =","counters":[]},{"line":"    let help = \"# of Get_ancestry rpc requests sent\" in","counters":[]},{"line":"    let name = \"get_ancestry_rpcs_sent\" in","counters":[]},{"line":"    ( Counter.v name ~help ~namespace ~subsystem","counters":[{"col_start":14,"col_end":14,"count":1}]},{"line":"    , Gauge.v (name ^ surfix) ~help ~namespace ~subsystem )","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let get_ancestry_rpcs_received =","counters":[]},{"line":"    let help = \"# of Get_ancestry rpc requests received\" in","counters":[]},{"line":"    let name = \"get_ancestry_rpcs_received\" in","counters":[]},{"line":"    ( Counter.v name ~help ~namespace ~subsystem","counters":[{"col_start":14,"col_end":14,"count":1}]},{"line":"    , Gauge.v (name ^ surfix) ~help ~namespace ~subsystem )","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let get_ancestry_rpc_requests_failed : Counter.t =","counters":[]},{"line":"    let help = \"# of Get_ancestry rpc requests failed\" in","counters":[]},{"line":"    Counter.v \"get_ancestry_rpc_requests_failed\" ~help ~namespace ~subsystem","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let get_ancestry_rpc_responses_failed : Counter.t =","counters":[]},{"line":"    let help = \"# of Get_ancestry rpc requests failed to respond\" in","counters":[]},{"line":"    Counter.v \"get_ancestry_rpc_responses_failed\" ~help ~namespace ~subsystem","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let ban_notify_rpcs_sent =","counters":[]},{"line":"    let help = \"# of Ban_notify rpc requests sent\" in","counters":[]},{"line":"    let name = \"ban_notify_rpcs_sent\" in","counters":[]},{"line":"    ( Counter.v name ~help ~namespace ~subsystem","counters":[{"col_start":14,"col_end":14,"count":1}]},{"line":"    , Gauge.v (name ^ surfix) ~help ~namespace ~subsystem )","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let ban_notify_rpcs_received =","counters":[]},{"line":"    let help = \"# of Ban_notify rpc requests received\" in","counters":[]},{"line":"    let name = \"ban_notify_rpcs_received\" in","counters":[]},{"line":"    ( Counter.v name ~help ~namespace ~subsystem","counters":[{"col_start":14,"col_end":14,"count":1}]},{"line":"    , Gauge.v (name ^ surfix) ~help ~namespace ~subsystem )","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let ban_notify_rpc_requests_failed : Counter.t =","counters":[]},{"line":"    let help = \"# of Ban_notify rpc requests failed\" in","counters":[]},{"line":"    Counter.v \"ban_notify_rpc_requests_failed\" ~help ~namespace ~subsystem","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let ban_notify_rpc_responses_failed : Counter.t =","counters":[]},{"line":"    let help = \"# of Ban_notify rpc requests failed to respond\" in","counters":[]},{"line":"    Counter.v \"ban_notify_rpc_responses_failed\" ~help ~namespace ~subsystem","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let get_best_tip_rpcs_sent =","counters":[]},{"line":"    let help = \"# of Get_best_tip rpc requests sent\" in","counters":[]},{"line":"    let name = \"get_best_tip_rpcs_sent\" in","counters":[]},{"line":"    ( Counter.v name ~help ~namespace ~subsystem","counters":[{"col_start":14,"col_end":14,"count":1}]},{"line":"    , Gauge.v (name ^ surfix) ~help ~namespace ~subsystem )","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let get_best_tip_rpcs_received =","counters":[]},{"line":"    let help = \"# of Get_best_tip rpc requests received\" in","counters":[]},{"line":"    let name = \"get_best_tip_rpcs_received\" in","counters":[]},{"line":"    ( Counter.v name ~help ~namespace ~subsystem","counters":[{"col_start":14,"col_end":14,"count":1}]},{"line":"    , Gauge.v (name ^ surfix) ~help ~namespace ~subsystem )","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let get_best_tip_rpc_requests_failed : Counter.t =","counters":[]},{"line":"    let help = \"# of Get_best_tip rpc requests failed\" in","counters":[]},{"line":"    Counter.v \"get_best_tip_rpc_requests_failed\" ~help ~namespace ~subsystem","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let get_best_tip_rpc_responses_failed : Counter.t =","counters":[]},{"line":"    let help = \"# of Get_best_tip rpc requests failed to respond\" in","counters":[]},{"line":"    Counter.v \"get_best_tip_rpc_responses_failed\" ~help ~namespace ~subsystem","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let get_epoch_ledger_rpcs_sent =","counters":[]},{"line":"    let help = \"# of Get_epoch_ledger rpc requests sent\" in","counters":[]},{"line":"    let name = \"get_epoch_ledger_rpcs_sent\" in","counters":[]},{"line":"    ( Counter.v name ~help ~namespace ~subsystem","counters":[{"col_start":14,"col_end":14,"count":1}]},{"line":"    , Gauge.v (name ^ surfix) ~help ~namespace ~subsystem )","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let get_epoch_ledger_rpcs_received =","counters":[]},{"line":"    let help = \"# of Get_epoch_ledger rpc requests received\" in","counters":[]},{"line":"    let name = \"get_epoch_ledger_rpcs_received\" in","counters":[]},{"line":"    ( Counter.v name ~help ~namespace ~subsystem","counters":[{"col_start":14,"col_end":14,"count":1}]},{"line":"    , Gauge.v (name ^ surfix) ~help ~namespace ~subsystem )","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let new_state_received =","counters":[]},{"line":"    let help = \"# of blocks received\" in","counters":[]},{"line":"    Gauge.v \"new_state_received\" ~help ~namespace ~subsystem","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"","counters":[]},{"line":"  let new_state_broadcasted =","counters":[]},{"line":"    let help = \"# of block broadcasted\" in","counters":[]},{"line":"    Gauge.v \"new_state_broadcasted\" ~help ~namespace ~subsystem","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"","counters":[]},{"line":"  let snark_pool_diff_received =","counters":[]},{"line":"    let help = \"# of snark_pool_diff received\" in","counters":[]},{"line":"    Gauge.v \"snark_pool_diff_received\" ~help ~namespace ~subsystem","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"","counters":[]},{"line":"  let snark_pool_diff_broadcasted =","counters":[]},{"line":"    let help = \"# of snark_pool_diff broadcasted\" in","counters":[]},{"line":"    Gauge.v \"snark_pool_diff_broadcasted\" ~help ~namespace ~subsystem","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"","counters":[]},{"line":"  let transaction_pool_diff_received =","counters":[]},{"line":"    let help = \"# of txn_pool_diff received\" in","counters":[]},{"line":"    Gauge.v \"transaction_pool_diff_received\" ~help ~namespace ~subsystem","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"","counters":[]},{"line":"  let transaction_pool_diff_broadcasted =","counters":[]},{"line":"    let help = \"# of txn_pool_diff broadcasted\" in","counters":[]},{"line":"    Gauge.v \"transaction_pool_diff_broadcasted\" ~help ~namespace ~subsystem","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"","counters":[]},{"line":"  let get_epoch_ledger_rpc_requests_failed : Counter.t =","counters":[]},{"line":"    let help = \"# of Get_epoch_ledger rpc requests failed\" in","counters":[]},{"line":"    Counter.v \"get_epoch_ledger_rpc_requests_failed\" ~help ~namespace ~subsystem","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let get_epoch_ledger_rpc_responses_failed : Counter.t =","counters":[]},{"line":"    let help = \"# of Get_epoch_ledger rpc requests failed to respond\" in","counters":[]},{"line":"    Counter.v \"get_epoch_ledger_rpc_responses_failed\" ~help ~namespace","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"      ~subsystem","counters":[]},{"line":"","counters":[]},{"line":"  let rpc_connections_failed : Counter.t =","counters":[]},{"line":"    let help = \"# of failed connections for rpc requests\" in","counters":[]},{"line":"    Counter.v \"rpc_connections_failed\" ~help ~namespace ~subsystem","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  module Gauge_map = Metric_map (struct","counters":[]},{"line":"    type t = Gauge.t","counters":[]},{"line":"","counters":[]},{"line":"    let subsystem = subsystem","counters":[]},{"line":"","counters":[]},{"line":"    let v = Gauge.v","counters":[]},{"line":"  end)","counters":[]},{"line":"","counters":[]},{"line":"  module Ipc_latency_histogram = Histogram (struct","counters":[]},{"line":"    let spec = Histogram_spec.of_exponential 1000. 10. 5","counters":[{"col_start":43,"col_end":43,"count":1}]},{"line":"  end)","counters":[]},{"line":"","counters":[]},{"line":"  module Rpc_latency_histogram = Histogram (struct","counters":[]},{"line":"    let spec = Histogram_spec.of_exponential 1000. 10. 5","counters":[{"col_start":43,"col_end":43,"count":1}]},{"line":"  end)","counters":[]},{"line":"","counters":[]},{"line":"  module Rpc_size_histogram = Histogram (struct","counters":[]},{"line":"    let spec = Histogram_spec.of_exponential 500. 2. 7","counters":[{"col_start":43,"col_end":43,"count":1}]},{"line":"  end)","counters":[]},{"line":"","counters":[]},{"line":"  module Histogram_map = Metric_map (struct","counters":[]},{"line":"    type t = Rpc_size_histogram.t","counters":[]},{"line":"","counters":[]},{"line":"    let subsystem = subsystem","counters":[]},{"line":"","counters":[]},{"line":"    let v = Rpc_size_histogram.v","counters":[]},{"line":"  end)","counters":[]},{"line":"","counters":[]},{"line":"  let rpc_latency_table = Gauge_map.of_alist_exn []","counters":[{"col_start":47,"col_end":47,"count":1}]},{"line":"","counters":[]},{"line":"  let rpc_size_table = Histogram_map.of_alist_exn []","counters":[{"col_start":48,"col_end":48,"count":1}]},{"line":"","counters":[]},{"line":"  let rpc_latency_ms ~name : Gauge.t =","counters":[]},{"line":"    let help = \"time elapsed while doing RPC calls in ms\" in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let name = name ^ \"_latency\" in","counters":[]},{"line":"    Gauge_map.add rpc_latency_table ~name ~help","counters":[]},{"line":"","counters":[]},{"line":"  let rpc_size_bytes ~name : Rpc_size_histogram.t =","counters":[]},{"line":"    let help = \"size for RPC response in bytes\" in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let name = name ^ \"_size\" in","counters":[]},{"line":"    Histogram_map.add rpc_size_table ~name ~help","counters":[]},{"line":"","counters":[]},{"line":"  let rpc_max_bytes ~name : Rpc_size_histogram.t =","counters":[]},{"line":"    let help = \"maximum size for RPC response in bytes\" in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let name = name ^ \"_max_size\" in","counters":[]},{"line":"    Histogram_map.add rpc_size_table ~name ~help","counters":[]},{"line":"","counters":[]},{"line":"  let rpc_avg_bytes ~name : Rpc_size_histogram.t =","counters":[]},{"line":"    let help = \"average size for RPC response in bytes\" in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let name = name ^ \"_avg_size\" in","counters":[]},{"line":"    Histogram_map.add rpc_size_table ~name ~help","counters":[]},{"line":"","counters":[]},{"line":"  let rpc_latency_ms_summary : Rpc_latency_histogram.t =","counters":[]},{"line":"    let help = \"A histogram for all RPC call latencies\" in","counters":[]},{"line":"    Rpc_latency_histogram.v \"rpc_latency_ms_summary\" ~help ~namespace ~subsystem","counters":[{"col_start":26,"col_end":26,"count":1}]},{"line":"","counters":[]},{"line":"  let ipc_latency_ns_summary : Ipc_latency_histogram.t =","counters":[]},{"line":"    let help = \"A histogram for all IPC message latencies\" in","counters":[]},{"line":"    Ipc_latency_histogram.v \"ipc_latency_ns_summary\" ~help ~namespace ~subsystem","counters":[{"col_start":26,"col_end":26,"count":1}]},{"line":"","counters":[]},{"line":"  let ipc_logs_received_total : Counter.t =","counters":[]},{"line":"    let help = \"Total number of logs received from libp2p helper subprocess\" in","counters":[]},{"line":"    Counter.v \"ipc_logs_received_total\" ~help ~namespace ~subsystem","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Pipe = struct","counters":[]},{"line":"  let subsystem = \"Pipe\"","counters":[]},{"line":"","counters":[]},{"line":"  module Drop_on_overflow = struct","counters":[]},{"line":"    let subsystem = subsystem ^ \"_overflow\"","counters":[]},{"line":"","counters":[]},{"line":"    let bootstrap_sync_ledger : Counter.t =","counters":[]},{"line":"      let help = \"Overflow in sync ledger pipe when bootstrapping\" in","counters":[]},{"line":"      Counter.v \"bootstrap_sync_ledger_pipe\" ~help ~namespace ~subsystem","counters":[{"col_start":14,"col_end":14,"count":1}]},{"line":"","counters":[]},{"line":"    let verified_network_pool_diffs : Counter.t =","counters":[]},{"line":"      let help =","counters":[]},{"line":"        \"Overflow in verified network pool diffs pipe (transactions or snark \\","counters":[]},{"line":"         work)\"","counters":[]},{"line":"      in","counters":[]},{"line":"      Counter.v \"verified_network_pool_diffs\" ~help ~namespace ~subsystem","counters":[{"col_start":14,"col_end":14,"count":1}]},{"line":"","counters":[]},{"line":"    let transition_frontier_valid_transitions : Counter.t =","counters":[]},{"line":"      let help =","counters":[]},{"line":"        \"Overflow in valid transitions pipe that has validated network \\","counters":[]},{"line":"         transitions\"","counters":[]},{"line":"      in","counters":[]},{"line":"      Counter.v \"transition_frontier_valid_transitions\" ~help ~namespace","counters":[{"col_start":14,"col_end":14,"count":1}]},{"line":"        ~subsystem","counters":[]},{"line":"","counters":[]},{"line":"    let transition_frontier_primary_transitions : Counter.t =","counters":[]},{"line":"      let help = \"Overflow in primary transitions pipe\" in","counters":[]},{"line":"      Counter.v \"transition_frontier_primary_transitions\" ~help ~namespace","counters":[{"col_start":14,"col_end":14,"count":1}]},{"line":"        ~subsystem","counters":[]},{"line":"","counters":[]},{"line":"    let router_transition_frontier_controller : Counter.t =","counters":[]},{"line":"      let help =","counters":[]},{"line":"        \"Overflow in transition frontier controller pipe in Transition_router\"","counters":[]},{"line":"      in","counters":[]},{"line":"      Counter.v \"router_transition_frontier_controller\" ~help ~namespace","counters":[{"col_start":14,"col_end":14,"count":1}]},{"line":"        ~subsystem","counters":[]},{"line":"","counters":[]},{"line":"    let router_bootstrap_controller : Counter.t =","counters":[]},{"line":"      let help = \"Overflow in bootstrap controller pipe in Transition_router\" in","counters":[]},{"line":"      Counter.v \"router_bootstrap_controller_pipe\" ~help ~namespace ~subsystem","counters":[{"col_start":14,"col_end":14,"count":1}]},{"line":"","counters":[]},{"line":"    let router_verified_transitions : Counter.t =","counters":[]},{"line":"      let help = \"Overflow in verified transitions pipe in Transition_router\" in","counters":[]},{"line":"      Counter.v \"router_verified_transitions\" ~help ~namespace ~subsystem","counters":[{"col_start":14,"col_end":14,"count":1}]},{"line":"","counters":[]},{"line":"    let router_transitions : Counter.t =","counters":[]},{"line":"      let help = \"Overflow in transitions pipe in Transition_router\" in","counters":[]},{"line":"      Counter.v \"router_transitions\" ~help ~namespace ~subsystem","counters":[{"col_start":14,"col_end":14,"count":1}]},{"line":"","counters":[]},{"line":"    let router_valid_transitions : Counter.t =","counters":[]},{"line":"      let help = \"Overflow in valid transitions pipe in Transition_router\" in","counters":[]},{"line":"      Counter.v \"router_valid_transitions\" ~help ~namespace ~subsystem","counters":[{"col_start":14,"col_end":14,"count":1}]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Snark_work = struct","counters":[]},{"line":"  let subsystem = \"Snark_work\"","counters":[]},{"line":"","counters":[]},{"line":"  let useful_snark_work_received_time_sec : Gauge.t =","counters":[]},{"line":"    let help =","counters":[]},{"line":"      \"Time at which useful snark work was seen (seconds since 1/1/1970)\"","counters":[]},{"line":"    in","counters":[]},{"line":"    Gauge.v \"useful_snark_work_received_time_sec\" ~help ~namespace ~subsystem","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"","counters":[]},{"line":"  let completed_snark_work_received_rpc : Counter.t =","counters":[]},{"line":"    let help = \"# of completed snark work bundles received via rpc\" in","counters":[]},{"line":"    Counter.v \"completed_snark_work_received_rpc\" ~help ~namespace ~subsystem","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let snark_work_assigned_rpc : Counter.t =","counters":[]},{"line":"    let help = \"# of snark work bundles assigned via rpc\" in","counters":[]},{"line":"    Counter.v \"snark_work_assigned_rpc\" ~help ~namespace ~subsystem","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let snark_work_timed_out_rpc : Counter.t =","counters":[]},{"line":"    let help =","counters":[]},{"line":"      \"# of snark work bundles sent via rpc that did not complete within the \\","counters":[]},{"line":"       value of the daemon flag work-reassignment-wait\"","counters":[]},{"line":"    in","counters":[]},{"line":"    Counter.v \"snark_work_timed_out_rpc\" ~help ~namespace ~subsystem","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let snark_work_failed_rpc : Counter.t =","counters":[]},{"line":"    let help = \"# of snark work failures reported by snark workers\" in","counters":[]},{"line":"    Counter.v \"snark_work_failed_rpc\" ~help ~namespace ~subsystem","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let snark_pool_size : Gauge.t =","counters":[]},{"line":"    let help = \"# of completed snark work bundles in the snark pool\" in","counters":[]},{"line":"    Gauge.v \"snark_pool_size\" ~help ~namespace ~subsystem","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"","counters":[]},{"line":"  let pending_snark_work : Gauge.t =","counters":[]},{"line":"    let help = \"total # of snark work bundles that are yet to be generated\" in","counters":[]},{"line":"    Gauge.v \"pending_snark_work\" ~help ~namespace ~subsystem","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"","counters":[]},{"line":"  module Snark_pool_serialization_ms_histogram = Histogram (struct","counters":[]},{"line":"    let spec = Histogram_spec.of_linear 0. 2000. 20","counters":[{"col_start":38,"col_end":38,"count":1}]},{"line":"  end)","counters":[]},{"line":"","counters":[]},{"line":"  let snark_pool_serialization_ms =","counters":[]},{"line":"    let help = \"A histogram for snark pool serialization time\" in","counters":[]},{"line":"    Snark_pool_serialization_ms_histogram.v \"snark_pool_serialization_ms\" ~help","counters":[{"col_start":42,"col_end":42,"count":1}]},{"line":"      ~namespace ~subsystem","counters":[]},{"line":"","counters":[]},{"line":"  module Snark_fee_histogram = Histogram (struct","counters":[]},{"line":"    let spec = Histogram_spec.of_linear 0. 1. 10","counters":[{"col_start":38,"col_end":38,"count":1}]},{"line":"  end)","counters":[]},{"line":"","counters":[]},{"line":"  let snark_fee =","counters":[]},{"line":"    let help = \"A histogram for snark fees\" in","counters":[]},{"line":"    Snark_fee_histogram.v \"snark_fee\" ~help ~namespace ~subsystem","counters":[{"col_start":24,"col_end":24,"count":1}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Scan_state_metrics = struct","counters":[]},{"line":"  let subsystem = \"Scan_state\"","counters":[]},{"line":"","counters":[]},{"line":"  module Metric = struct","counters":[]},{"line":"    type t = Gauge.t","counters":[]},{"line":"","counters":[]},{"line":"    let subsystem = subsystem","counters":[]},{"line":"","counters":[]},{"line":"    let v = Gauge.v","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Gauge_metric_map = Metric_map (Metric)","counters":[]},{"line":"","counters":[]},{"line":"  let base_snark_required_map = Gauge_metric_map.of_alist_exn []","counters":[{"col_start":60,"col_end":60,"count":1}]},{"line":"","counters":[]},{"line":"  let slots_available_map = Gauge_metric_map.of_alist_exn []","counters":[{"col_start":56,"col_end":56,"count":1}]},{"line":"","counters":[]},{"line":"  let merge_snark_required_map = Gauge_metric_map.of_alist_exn []","counters":[{"col_start":61,"col_end":61,"count":1}]},{"line":"","counters":[]},{"line":"  let scan_state_available_space ~name : Gauge.t =","counters":[]},{"line":"    let help = \"# of slots available\" in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let name = \"slots_available_\" ^ name in","counters":[]},{"line":"    Gauge_metric_map.add slots_available_map ~help ~name","counters":[]},{"line":"","counters":[]},{"line":"  let scan_state_base_snarks ~name : Gauge.t =","counters":[]},{"line":"    let help = \"# of base snarks required\" in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let name = \"base_snarks_required_\" ^ name in","counters":[]},{"line":"    Gauge_metric_map.add base_snark_required_map ~help ~name","counters":[]},{"line":"","counters":[]},{"line":"  let scan_state_merge_snarks ~name : Gauge.t =","counters":[]},{"line":"    let help = \"# of merge snarks required\" in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let name = \"merge_snarks_required_\" ^ name in","counters":[]},{"line":"    Gauge_metric_map.add merge_snark_required_map ~help ~name","counters":[]},{"line":"","counters":[]},{"line":"  let snark_fee_per_block : Gauge.t =","counters":[]},{"line":"    let help = \"Total snark fee per block\" in","counters":[]},{"line":"    Gauge.v \"snark_fees_per_block\" ~help ~namespace ~subsystem","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"","counters":[]},{"line":"  let transaction_fees_per_block : Gauge.t =","counters":[]},{"line":"    let help = \"Total transaction fee per block\" in","counters":[]},{"line":"    Gauge.v \"transaction_fees_per_block\" ~help ~namespace ~subsystem","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"","counters":[]},{"line":"  let purchased_snark_work_per_block : Gauge.t =","counters":[]},{"line":"    let help = \"# of snark work bundles purchased per block\" in","counters":[]},{"line":"    Gauge.v \"purchased_snark_work_per_block\" ~help ~namespace ~subsystem","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"","counters":[]},{"line":"  let snark_work_required : Gauge.t =","counters":[]},{"line":"    let help =","counters":[]},{"line":"      \"# of snark work bundles in the scan state that are yet to be \\","counters":[]},{"line":"       done/purchased\"","counters":[]},{"line":"    in","counters":[]},{"line":"    Gauge.v \"snark_work_required\" ~help ~namespace ~subsystem","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Trust_system = struct","counters":[]},{"line":"  let subsystem = \"Trust_system\"","counters":[]},{"line":"","counters":[]},{"line":"  let banned_peers : Gauge.t =","counters":[]},{"line":"    let help = \"# of banned ip addresses\" in","counters":[]},{"line":"    Gauge.v \"banned_peers\" ~help ~namespace ~subsystem","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Consensus = struct","counters":[]},{"line":"  let subsystem = \"Consensus\"","counters":[]},{"line":"","counters":[]},{"line":"  (* TODO:","counters":[]},{"line":"     let vrf_threshold =","counters":[]},{"line":"       let help = \"vrf threshold expressed as % to win (in range 0..1)\" in","counters":[]},{"line":"       Gauge.v \"vrf_threshold\" ~help ~namespace ~subsystem","counters":[]},{"line":"  *)","counters":[]},{"line":"","counters":[]},{"line":"  let vrf_evaluations : Counter.t =","counters":[]},{"line":"    let help = \"vrf evaluations performed\" in","counters":[]},{"line":"    Counter.v \"vrf_evaluations\" ~help ~namespace ~subsystem","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let staking_keypairs : Gauge.t =","counters":[]},{"line":"    let help = \"# of actively staking keypairs\" in","counters":[]},{"line":"    Gauge.v \"staking_keypairs\" ~help ~namespace ~subsystem","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"","counters":[]},{"line":"  let stake_delegators : Gauge.t =","counters":[]},{"line":"    let help =","counters":[]},{"line":"      \"# of delegators the node is evaluating vrfs for (in addition to \\","counters":[]},{"line":"       evaluations for staking keypairs)\"","counters":[]},{"line":"    in","counters":[]},{"line":"    Gauge.v \"stake_delegators\" ~help ~namespace ~subsystem","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Block_producer = struct","counters":[]},{"line":"  let subsystem = \"Block_producer\"","counters":[]},{"line":"","counters":[]},{"line":"  let slots_won : Counter.t =","counters":[]},{"line":"    let help =","counters":[]},{"line":"      \"slots which the loaded block production keys have won (does not \\","counters":[]},{"line":"       represent that a block was actually produced)\"","counters":[]},{"line":"    in","counters":[]},{"line":"    Counter.v \"slots_won\" ~help ~namespace ~subsystem","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let blocks_produced : Counter.t =","counters":[]},{"line":"    let help = \"blocks produced and submitted by the daemon\" in","counters":[]},{"line":"    Counter.v \"blocks_produced\" ~help ~namespace ~subsystem","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  module Block_production_delay_histogram = Histogram (struct","counters":[]},{"line":"    (* First bucket: 60s, buckets with linear increase up to 3m30s *)","counters":[]},{"line":"    let spec = Histogram_spec.of_linear 60000. 30000. 6","counters":[{"col_start":38,"col_end":38,"count":1}]},{"line":"  end)","counters":[]},{"line":"","counters":[]},{"line":"  let block_production_delay =","counters":[]},{"line":"    let help =","counters":[]},{"line":"      \"A histogram for delay between start of slot and time of block production\"","counters":[]},{"line":"    in","counters":[]},{"line":"    Block_production_delay_histogram.v \"block_production_delay\" ~help ~namespace","counters":[{"col_start":37,"col_end":37,"count":1}]},{"line":"      ~subsystem","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Transition_frontier = struct","counters":[]},{"line":"  let subsystem = \"Transition_frontier\"","counters":[]},{"line":"","counters":[]},{"line":"  let max_blocklength_observed = ref 0","counters":[]},{"line":"","counters":[]},{"line":"  let max_blocklength_observed_metrics : Gauge.t =","counters":[]},{"line":"    let help = \"max blocklength observed by the system\" in","counters":[]},{"line":"    Gauge.v \"max_blocklength_observed\" ~help ~namespace ~subsystem","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"","counters":[]},{"line":"  let update_max_blocklength_observed : int -> unit =","counters":[]},{"line":"   fun blockchain_length ->","counters":[]},{"line":"    if blockchain_length > !max_blocklength_observed then (","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"      Gauge.set max_blocklength_observed_metrics","counters":[]},{"line":"      @@ Int.to_float blockchain_length ;","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"      max_blocklength_observed := blockchain_length )","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"  let max_unvalidated_blocklength_observed = ref 0","counters":[]},{"line":"","counters":[]},{"line":"  let max_unvalidated_blocklength_observed_metrics : Gauge.t =","counters":[]},{"line":"    let help = \"max unvalidated blocklength observed by the system\" in","counters":[]},{"line":"    Gauge.v \"max_unvalidated_blocklength_observed\" ~help ~namespace ~subsystem","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"","counters":[]},{"line":"  let update_max_unvalidated_blocklength_observed : int -> unit =","counters":[]},{"line":"   fun blockchain_length ->","counters":[]},{"line":"    if blockchain_length > !max_unvalidated_blocklength_observed then (","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":70,"col_end":70,"count":0}]},{"line":"      Gauge.set max_unvalidated_blocklength_observed_metrics","counters":[]},{"line":"      @@ Int.to_float blockchain_length ;","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"      max_unvalidated_blocklength_observed := blockchain_length )","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"  let slot_fill_rate : Gauge.t =","counters":[]},{"line":"    let help =","counters":[]},{"line":"      \"fill rate for the last k slots (or fewer if there have not been k slots \\","counters":[]},{"line":"       between the best tip and the frontier root)\"","counters":[]},{"line":"    in","counters":[]},{"line":"    Gauge.v \"slot_fill_rate\" ~help ~namespace ~subsystem","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"","counters":[]},{"line":"  let min_window_density : Gauge.t =","counters":[]},{"line":"    let help = \"min window density for the best tip\" in","counters":[]},{"line":"    Gauge.v \"min_window_density\" ~help ~namespace ~subsystem","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"","counters":[]},{"line":"  let active_breadcrumbs : Gauge.t =","counters":[]},{"line":"    let help = \"current # of breadcrumbs in the transition frontier\" in","counters":[]},{"line":"    Gauge.v \"active_breadcrumbs\" ~help ~namespace ~subsystem","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"","counters":[]},{"line":"  let total_breadcrumbs : Counter.t =","counters":[]},{"line":"    let help =","counters":[]},{"line":"      \"monotonically increasing # of breadcrumbs added to transition frontier\"","counters":[]},{"line":"    in","counters":[]},{"line":"    Counter.v \"total_breadcrumbs\" ~help ~namespace ~subsystem","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let root_transitions : Counter.t =","counters":[]},{"line":"    let help =","counters":[]},{"line":"      \"# of root transitions (finalizations) performed in transition frontier\"","counters":[]},{"line":"    in","counters":[]},{"line":"    Counter.v \"root_transitions\" ~help ~namespace ~subsystem","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let finalized_staged_txns : Counter.t =","counters":[]},{"line":"    let help = \"total # of staged txns that have been finalized\" in","counters":[]},{"line":"    Counter.v \"finalized_staged_txns\" ~help ~namespace ~subsystem","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  module TPS_30min =","counters":[]},{"line":"    Moving_bucketed_average","counters":[]},{"line":"      (struct","counters":[]},{"line":"        let bucket_interval = Core.Time.Span.of_min 3.0","counters":[{"col_start":50,"col_end":50,"count":1}]},{"line":"","counters":[]},{"line":"        let num_buckets = 10","counters":[]},{"line":"","counters":[]},{"line":"        let render_average buckets =","counters":[]},{"line":"          let total =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            List.fold buckets ~init:0.0 ~f:(fun acc (n, _) -> acc +. n)","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"          in","counters":[]},{"line":"          total /. Core.Time.Span.(of_min 30.0 |> to_sec)","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"","counters":[]},{"line":"        let subsystem = subsystem","counters":[]},{"line":"","counters":[]},{"line":"        let name = \"tps_30min\"","counters":[]},{"line":"","counters":[]},{"line":"        let help =","counters":[]},{"line":"          \"moving average for transaction per second, the rolling interval is \\","counters":[]},{"line":"           set to 30 min\"","counters":[]},{"line":"      end)","counters":[]},{"line":"      ()","counters":[]},{"line":"","counters":[]},{"line":"  let recently_finalized_staged_txns : Gauge.t =","counters":[]},{"line":"    let help =","counters":[]},{"line":"      \"# of staged txns that were finalized during the last transition \\","counters":[]},{"line":"       frontier root transition\"","counters":[]},{"line":"    in","counters":[]},{"line":"    Gauge.v \"recently_finalized_staged_txns\" ~help ~namespace ~subsystem","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"","counters":[]},{"line":"  let best_tip_user_txns : Gauge.t =","counters":[]},{"line":"    let help = \"# of transactions in the current best tip\" in","counters":[]},{"line":"    Gauge.v \"best_tip_user_txns\" ~help ~namespace ~subsystem","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"","counters":[]},{"line":"  let best_tip_zkapp_txns : Gauge.t =","counters":[]},{"line":"    let help = \"# of transactions in the current best tip\" in","counters":[]},{"line":"    Gauge.v \"best_tip_zkapp_txns\" ~help ~namespace ~subsystem","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"","counters":[]},{"line":"  let best_tip_coinbase : Gauge.t =","counters":[]},{"line":"    let help =","counters":[]},{"line":"      \"0 if there is no coinbase in the current best tip, 1 otherwise\"","counters":[]},{"line":"    in","counters":[]},{"line":"    let t = Gauge.v \"best_tip_coinbase\" ~help ~namespace ~subsystem in","counters":[]},{"line":"    Gauge.set t 1. ; t","counters":[{"col_start":4,"col_end":4,"count":1},{"col_start":21,"col_end":21,"count":1}]},{"line":"","counters":[]},{"line":"  let longest_fork : Gauge.t =","counters":[]},{"line":"    let help = \"Length of the longest path in the frontier\" in","counters":[]},{"line":"    Gauge.v \"longest_fork\" ~help ~namespace ~subsystem","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"","counters":[]},{"line":"  let empty_blocks_at_best_tip : Gauge.t =","counters":[]},{"line":"    let help =","counters":[]},{"line":"      \"Number of blocks at the best tip that have no user-commands in them\"","counters":[]},{"line":"    in","counters":[]},{"line":"    Gauge.v \"empty_blocks_at_best_tip\" ~help ~namespace ~subsystem","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"","counters":[]},{"line":"  let accepted_block_slot_time_sec : Gauge.t =","counters":[]},{"line":"    let help =","counters":[]},{"line":"      \"Slot time (seconds since 1/1/1970) corresponding to the most recently \\","counters":[]},{"line":"       accepted block\"","counters":[]},{"line":"    in","counters":[]},{"line":"    Gauge.v \"accepted_block_slot_time_sec\" ~help ~namespace ~subsystem","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"","counters":[]},{"line":"  let best_tip_slot_time_sec : Gauge.t =","counters":[]},{"line":"    let help =","counters":[]},{"line":"      \"Slot time (seconds since 1/1/1970) corresponding to the most recent \\","counters":[]},{"line":"       best tip\"","counters":[]},{"line":"    in","counters":[]},{"line":"    Gauge.v \"best_tip_slot_time_sec\" ~help ~namespace ~subsystem","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"","counters":[]},{"line":"  let best_tip_block_height : Gauge.t =","counters":[]},{"line":"    let help = \"Height of most recent best tip\" in","counters":[]},{"line":"    Gauge.v \"best_tip_block_height\" ~help ~namespace ~subsystem","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"","counters":[]},{"line":"  (* TODO:","counters":[]},{"line":"     let recently_finalized_snarked_txns : Gauge.t =","counters":[]},{"line":"       let help = \"toal # of snarked txns that have been finalized\" in","counters":[]},{"line":"       Gauge.v \"finalized_snarked_txns\" ~help ~namespace ~subsystem","counters":[]},{"line":"","counters":[]},{"line":"     let recently_finalized_snarked_txns : Gauge.t =","counters":[]},{"line":"       let help = \"# of snarked txns that were finalized during the last transition frontier root transition\" in","counters":[]},{"line":"       Gauge.v \"recently_finalized_snarked_txns\" ~help ~namespace ~subsystem","counters":[]},{"line":"  *)","counters":[]},{"line":"","counters":[]},{"line":"  let root_snarked_ledger_accounts : Gauge.t =","counters":[]},{"line":"    let help = \"# of accounts in transition frontier root snarked ledger\" in","counters":[]},{"line":"    Gauge.v \"root_snarked_ledger_accounts\" ~help ~namespace ~subsystem","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"","counters":[]},{"line":"  let root_snarked_ledger_total_currency : Gauge.t =","counters":[]},{"line":"    let help = \"total amount of currency in root snarked ledger\" in","counters":[]},{"line":"    Gauge.v \"root_snarked_ledger_total_currency\" ~help ~namespace ~subsystem","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"","counters":[]},{"line":"  (* TODO:","counters":[]},{"line":"     let root_staged_ledger_accounts : Gauge.t =","counters":[]},{"line":"       let help = \"# of accounts in transition frontier root staged ledger\" in","counters":[]},{"line":"       Gauge.v \"root_staged_ledger_accounts\" ~help ~namespace ~subsystem","counters":[]},{"line":"","counters":[]},{"line":"     let root_staged_ledger_total_currency : Gauge.t =","counters":[]},{"line":"       let help = \"total amount of currency in root staged ledger\" in","counters":[]},{"line":"       Gauge.v \"root_staged_ledger_total_currency\" ~help ~namespace ~subsystem","counters":[]},{"line":"  *)","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Catchup = struct","counters":[]},{"line":"  let subsystem = \"Catchup\"","counters":[]},{"line":"","counters":[]},{"line":"  let download_time : Gauge.t =","counters":[]},{"line":"    let help = \"time to download 1 transition in ms\" in","counters":[]},{"line":"    Gauge.v \"download_time\" ~help ~namespace ~subsystem","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"","counters":[]},{"line":"  let initial_validation_time : Gauge.t =","counters":[]},{"line":"    let help = \"time to do initial validation in ms\" in","counters":[]},{"line":"    Gauge.v \"initial_validation_time\" ~help ~namespace ~subsystem","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"","counters":[]},{"line":"  let verification_time : Gauge.t =","counters":[]},{"line":"    let help = \"time to do verificatin in ms\" in","counters":[]},{"line":"    Gauge.v \"verification_time\" ~help ~namespace ~subsystem","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"","counters":[]},{"line":"  let build_breadcrumb_time : Gauge.t =","counters":[]},{"line":"    let help = \"time to build breadcrumb in ms\" in","counters":[]},{"line":"    Gauge.v \"build_breadcrumb_time\" ~help ~namespace ~subsystem","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"","counters":[]},{"line":"  let initial_catchup_time : Gauge.t =","counters":[]},{"line":"    let help = \"time for initial catchup in min\" in","counters":[]},{"line":"    Gauge.v \"initial_catchup_time\" ~help ~namespace ~subsystem","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Transition_frontier_controller = struct","counters":[]},{"line":"  let subsystem = \"Transition_frontier_controller\"","counters":[]},{"line":"","counters":[]},{"line":"  let transitions_being_processed : Gauge.t =","counters":[]},{"line":"    let help =","counters":[]},{"line":"      \"transitions currently being processed by the transition frontier \\","counters":[]},{"line":"       controller\"","counters":[]},{"line":"    in","counters":[]},{"line":"    Gauge.v \"transitions_being_processed\" ~help ~namespace ~subsystem","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"","counters":[]},{"line":"  let transitions_in_catchup_scheduler =","counters":[]},{"line":"    let help = \"transitions stored inside catchup scheduler\" in","counters":[]},{"line":"    Gauge.v \"transitions_in_catchup_scheduler\" ~help ~namespace ~subsystem","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"","counters":[]},{"line":"  let catchup_time_ms =","counters":[]},{"line":"    let help = \"time elapsed while doing catchup\" in","counters":[]},{"line":"    Gauge.v \"catchup_time_ms\" ~help ~namespace ~subsystem","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"","counters":[]},{"line":"  let transitions_downloaded_from_catchup =","counters":[]},{"line":"    let help = \"# of transitions downloaded by ledger_catchup\" in","counters":[]},{"line":"    Gauge.v \"transitions_downloaded_from_catchup\" ~help ~namespace ~subsystem","counters":[{"col_start":10,"col_end":10,"count":1}]},{"line":"","counters":[]},{"line":"  let breadcrumbs_built_by_processor : Counter.t =","counters":[]},{"line":"    let help = \"breadcrumbs built by the processor\" in","counters":[]},{"line":"    Counter.v \"breadcrumbs_built_by_processor\" ~help ~namespace ~subsystem","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let breadcrumbs_built_by_builder : Counter.t =","counters":[]},{"line":"    let help = \"breadcrumbs built by the breadcrumb builder\" in","counters":[]},{"line":"    Counter.v \"breadcrumbs_built_by_builder\" ~help ~namespace ~subsystem","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(* these block latency metrics are recomputed every half a slot, and the averages span 20 slots *)","counters":[]},{"line":"module Block_latency = struct","counters":[]},{"line":"  let subsystem = \"Block_latency\"","counters":[]},{"line":"","counters":[]},{"line":"  module Upload_to_gcloud = struct","counters":[]},{"line":"    let upload_to_gcloud_blocks : Gauge.t =","counters":[]},{"line":"      let help = \"Number of pending `gsutil cp` jobs for block dumping\" in","counters":[]},{"line":"      Gauge.v \"upload_to_gcloud_blocks\" ~help ~namespace ~subsystem","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Latency_time_spec = struct","counters":[]},{"line":"    let tick_interval =","counters":[]},{"line":"      Core.Time.Span.of_ms (Int.to_float (block_window_duration / 2))","counters":[{"col_start":25,"col_end":25,"count":1},{"col_start":39,"col_end":39,"count":1}]},{"line":"","counters":[]},{"line":"    let rolling_interval =","counters":[]},{"line":"      Core.Time.Span.of_ms (Int.to_float (block_window_duration * 20))","counters":[{"col_start":25,"col_end":25,"count":1},{"col_start":39,"col_end":39,"count":1}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Gossip_slots =","counters":[]},{"line":"    Moving_bucketed_average","counters":[]},{"line":"      (struct","counters":[]},{"line":"        let bucket_interval =","counters":[]},{"line":"          Core.Time.Span.of_ms (Int.to_float (block_window_duration / 2))","counters":[{"col_start":29,"col_end":29,"count":1},{"col_start":43,"col_end":43,"count":1}]},{"line":"","counters":[]},{"line":"        let num_buckets = 40","counters":[]},{"line":"","counters":[]},{"line":"        let subsystem = subsystem","counters":[]},{"line":"","counters":[]},{"line":"        let name = \"gossip_slots\"","counters":[]},{"line":"","counters":[]},{"line":"        let help =","counters":[]},{"line":"          \"average delay, in slots, after which produced blocks are received\"","counters":[]},{"line":"","counters":[]},{"line":"        let render_average buckets =","counters":[]},{"line":"          let total_sum, count_sum =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            List.fold buckets ~init:(0.0, 0)","counters":[]},{"line":"              ~f:(fun (total_sum, count_sum) (total, count) ->","counters":[]},{"line":"                (total_sum +. total, count_sum + count) )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"          in","counters":[]},{"line":"          total_sum /. Float.of_int count_sum","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"      end)","counters":[]},{"line":"      ()","counters":[]},{"line":"","counters":[]},{"line":"  module Gossip_time =","counters":[]},{"line":"    Moving_time_average","counters":[]},{"line":"      (struct","counters":[]},{"line":"        include Latency_time_spec","counters":[]},{"line":"","counters":[]},{"line":"        let subsystem = subsystem","counters":[]},{"line":"","counters":[]},{"line":"        let name = \"gossip_time\"","counters":[]},{"line":"","counters":[]},{"line":"        let help =","counters":[]},{"line":"          \"average delay, in seconds, after which produced blocks are received\"","counters":[]},{"line":"      end)","counters":[]},{"line":"      ()","counters":[]},{"line":"","counters":[]},{"line":"  module Inclusion_time =","counters":[]},{"line":"    Moving_time_average","counters":[]},{"line":"      (struct","counters":[]},{"line":"        include Latency_time_spec","counters":[]},{"line":"","counters":[]},{"line":"        let subsystem = subsystem","counters":[]},{"line":"","counters":[]},{"line":"        let name = \"inclusion_time\"","counters":[]},{"line":"","counters":[]},{"line":"        let help =","counters":[]},{"line":"          \"average delay, in seconds, after which produced blocks are included \\","counters":[]},{"line":"           into our frontier\"","counters":[]},{"line":"      end)","counters":[]},{"line":"      ()","counters":[]},{"line":"","counters":[]},{"line":"  module Validation_acceptance_time =","counters":[]},{"line":"    Moving_time_average","counters":[]},{"line":"      (struct","counters":[]},{"line":"        include Latency_time_spec","counters":[]},{"line":"","counters":[]},{"line":"        let subsystem = subsystem","counters":[]},{"line":"","counters":[]},{"line":"        let name = \"validation_acceptance_time\"","counters":[]},{"line":"","counters":[]},{"line":"        let help =","counters":[]},{"line":"          \"average delay, in seconds, between the time blocks are initially \\","counters":[]},{"line":"           received from the libp2p_helper, and when they are accepted as \\","counters":[]},{"line":"           valid\"","counters":[]},{"line":"      end)","counters":[]},{"line":"      ()","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Rejected_blocks = struct","counters":[]},{"line":"  let subsystem = \"Rejected_blocks\"","counters":[]},{"line":"","counters":[]},{"line":"  let worse_than_root =","counters":[]},{"line":"    let help =","counters":[]},{"line":"      \"The number of blocks rejected due to the blocks are not selected over \\","counters":[]},{"line":"       our root\"","counters":[]},{"line":"    in","counters":[]},{"line":"    Counter.v \"worse_than_root\" ~help ~namespace ~subsystem","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let no_common_ancestor =","counters":[]},{"line":"    let help =","counters":[]},{"line":"      \"The number of blocks rejected due to the blocks do not share a common \\","counters":[]},{"line":"       ancestor with our root\"","counters":[]},{"line":"    in","counters":[]},{"line":"    Counter.v \"no_common_ancestor\" ~help ~namespace ~subsystem","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let invalid_proof =","counters":[]},{"line":"    let help = \"The number of blocks rejected due to invalid proof\" in","counters":[]},{"line":"    Counter.v \"invalid_proof\" ~help ~namespace ~subsystem","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let received_late =","counters":[]},{"line":"    let help =","counters":[]},{"line":"      \"The number of blocks rejected due to blocks being received too late\"","counters":[]},{"line":"    in","counters":[]},{"line":"    Counter.v \"received_late\" ~help ~namespace ~subsystem","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"","counters":[]},{"line":"  let received_early =","counters":[]},{"line":"    let help =","counters":[]},{"line":"      \"The number of blocks rejected due to blocks being received too early\"","counters":[]},{"line":"    in","counters":[]},{"line":"    Counter.v \"received_early\" ~help ~namespace ~subsystem","counters":[{"col_start":12,"col_end":12,"count":1}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Object_lifetime_statistics = struct","counters":[]},{"line":"  let subsystem = \"Object_lifetime_statistics\"","counters":[]},{"line":"","counters":[]},{"line":"  module Counter_map = Metric_map (struct","counters":[]},{"line":"    type t = Counter.t","counters":[]},{"line":"","counters":[]},{"line":"    let subsystem = subsystem","counters":[]},{"line":"","counters":[]},{"line":"    let v = Counter.v","counters":[]},{"line":"  end)","counters":[]},{"line":"","counters":[]},{"line":"  module Gauge_map = Metric_map (struct","counters":[]},{"line":"    type t = Gauge.t","counters":[]},{"line":"","counters":[]},{"line":"    let subsystem = subsystem","counters":[]},{"line":"","counters":[]},{"line":"    let v = Gauge.v","counters":[]},{"line":"  end)","counters":[]},{"line":"","counters":[]},{"line":"  let allocated_count_table = Counter_map.of_alist_exn []","counters":[{"col_start":53,"col_end":53,"count":1}]},{"line":"","counters":[]},{"line":"  let allocated_count ~name : Counter.t =","counters":[]},{"line":"    let help =","counters":[{"col_start":4,"col_end":4,"count":3}]},{"line":"      \"total number of objects allocated (including previously collected \\","counters":[]},{"line":"       objects)\"","counters":[]},{"line":"    in","counters":[]},{"line":"    let name = \"allocated_count_\" ^ name in","counters":[]},{"line":"    Counter_map.add allocated_count_table ~name ~help","counters":[]},{"line":"","counters":[]},{"line":"  let collected_count_table = Counter_map.of_alist_exn []","counters":[{"col_start":53,"col_end":53,"count":1}]},{"line":"","counters":[]},{"line":"  let collected_count ~name : Counter.t =","counters":[]},{"line":"    let help = \"total number of objects collected\" in","counters":[{"col_start":4,"col_end":4,"count":1}]},{"line":"    let name = \"collected_count_\" ^ name in","counters":[]},{"line":"    Counter_map.add collected_count_table ~name ~help","counters":[]},{"line":"","counters":[]},{"line":"  let lifetime_quartile_ms_table = Gauge_map.of_alist_exn []","counters":[{"col_start":56,"col_end":56,"count":1}]},{"line":"","counters":[]},{"line":"  let live_count_table = Gauge_map.of_alist_exn []","counters":[{"col_start":46,"col_end":46,"count":1}]},{"line":"","counters":[]},{"line":"  let live_count ~name : Gauge.t =","counters":[]},{"line":"    let help = \"total number of objects currently allocated\" in","counters":[{"col_start":4,"col_end":4,"count":4}]},{"line":"    let name = \"live_count_\" ^ name in","counters":[]},{"line":"    Gauge_map.add live_count_table ~name ~help","counters":[]},{"line":"","counters":[]},{"line":"  let lifetime_quartile_ms ~name ~quartile : Gauge.t =","counters":[]},{"line":"    let q =","counters":[{"col_start":4,"col_end":4,"count":16}]},{"line":"      match quartile with","counters":[]},{"line":"      | `Q1 ->","counters":[{"col_start":8,"col_end":8,"count":4}]},{"line":"          \"q1\"","counters":[]},{"line":"      | `Q2 ->","counters":[{"col_start":8,"col_end":8,"count":4}]},{"line":"          \"q2\"","counters":[]},{"line":"      | `Q3 ->","counters":[{"col_start":8,"col_end":8,"count":4}]},{"line":"          \"q3\"","counters":[]},{"line":"      | `Q4 ->","counters":[{"col_start":8,"col_end":8,"count":4}]},{"line":"          \"q4\"","counters":[]},{"line":"    in","counters":[]},{"line":"    let help =","counters":[]},{"line":"      \"quartile of active object lifetimes, expressed in milliseconds\"","counters":[]},{"line":"    in","counters":[]},{"line":"    let name = \"lifetime_\" ^ name ^ \"_\" ^ q ^ \"_ms\" in","counters":[]},{"line":"    Gauge_map.add lifetime_quartile_ms_table ~name ~help","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Execution_times = struct","counters":[]},{"line":"  let tracked_metrics = String.Table.create ()","counters":[{"col_start":42,"col_end":42,"count":1}]},{"line":"","counters":[]},{"line":"  let create_metric thread =","counters":[]},{"line":"    let name = O1trace.Thread.name thread in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let info : MetricInfo.t =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      { name =","counters":[]},{"line":"          MetricName.v","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"            (Printf.sprintf \"Mina_Daemon_time_spent_in_thread_%s_ms\" name)","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"      ; help = Printf.sprintf \"Total number of ms spent on '%s'\" name","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"      ; metric_type = Counter","counters":[]},{"line":"      ; label_names = []","counters":[]},{"line":"      }","counters":[]},{"line":"    in","counters":[]},{"line":"    let collect () =","counters":[]},{"line":"      let elapsed = O1trace.Execution_timer.elapsed_time_of_thread thread in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      LabelSetMap.singleton []","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [ Sample_set.sample (Time_ns.Span.to_ms elapsed) ]","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"    in","counters":[]},{"line":"    CollectorRegistry.register CollectorRegistry.default info collect","counters":[]},{"line":"","counters":[]},{"line":"  let sync_metrics () =","counters":[]},{"line":"    O1trace.Thread.iter_threads ~f:(fun thread ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        let name = O1trace.Thread.name thread in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        if not (Hashtbl.mem tracked_metrics name) then","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"          Hashtbl.add_exn tracked_metrics ~key:name ~data:(create_metric thread) )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"","counters":[]},{"line":"  let () = CollectorRegistry.(register_pre_collect default sync_metrics)","counters":[{"col_start":49,"col_end":49,"count":1}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let generic_server ?forward_uri ~port ~logger ~registry () =","counters":[]},{"line":"  let open Cohttp in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let open Cohttp_async in","counters":[]},{"line":"  let handle_error _ exn =","counters":[]},{"line":"    [%log error]","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"      ~metadata:[ (\"error\", `String (Exn.to_string exn)) ]","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"      \"Encountered error while handling request to prometheus server: $error\"","counters":[]},{"line":"  in","counters":[]},{"line":"  let callback ~body:_ _ req =","counters":[]},{"line":"    let uri = Request.uri req in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    match (Request.meth req, Uri.path uri) with","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"    | `GET, \"/metrics\" ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let%bind other_data =","counters":[]},{"line":"          match forward_uri with","counters":[]},{"line":"          | Some uri ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let%bind resp, body = Client.get uri in","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"              let status = Response.status resp in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              if Code.is_success (Code.code_of_status status) then","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"                let%map body = Body.to_string body in","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"                Some body","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"              else (","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"                [%log error] \"Could not forward request to $url, got: $status\"","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                  ~metadata:","counters":[]},{"line":"                    [ (\"url\", `String (Uri.to_string uri))","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                    ; (\"status_code\", `Int (Code.code_of_status status))","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"                    ; (\"status\", `String (Code.string_of_status status))","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"                    ] ;","counters":[]},{"line":"                return None )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              return None","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"        in","counters":[]},{"line":"        let data = CollectorRegistry.(collect registry) in","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"        let body = Fmt.to_to_string TextFormat_0_0_4.output data in","counters":[]},{"line":"        let body =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          match other_data with","counters":[]},{"line":"          | Some other_data ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              body ^ \"\\n\" ^ other_data","counters":[]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              body","counters":[]},{"line":"        in","counters":[]},{"line":"        let headers =","counters":[]},{"line":"          Header.init_with \"Content-Type\" \"text/plain; version=0.0.4\"","counters":[]},{"line":"        in","counters":[]},{"line":"        Server.respond_string ~status:`OK ~headers body","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    | _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Server.respond_string ~status:`Bad_request \"Bad request\"","counters":[]},{"line":"  in","counters":[]},{"line":"  Server.create ~mode:`TCP ~on_handler_error:(`Call handle_error)","counters":[]},{"line":"    (Async.Tcp.Where_to_listen.of_port port)","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"    callback","counters":[]},{"line":"","counters":[]},{"line":"type t = (Async.Socket.Address.Inet.t, int) Cohttp_async.Server.t","counters":[]},{"line":"","counters":[]},{"line":"let server ?forward_uri ~port ~logger () =","counters":[]},{"line":"  O1trace.background_thread \"collect_gc_metrics\" Runtime.gc_stat ;","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  O1trace.thread \"serve_metrics\"","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    (generic_server ?forward_uri ~port ~logger","counters":[]},{"line":"       ~registry:CollectorRegistry.default )","counters":[]},{"line":"","counters":[]},{"line":"module Archive = struct","counters":[]},{"line":"  type t =","counters":[]},{"line":"    { registry : CollectorRegistry.t","counters":[]},{"line":"    ; gauge_metrics : (string, Gauge.t) Hashtbl.t","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let subsystem = \"Archive\"","counters":[]},{"line":"","counters":[]},{"line":"  let find_or_add t ~name ~help ~subsystem =","counters":[]},{"line":"    match Hashtbl.find t.gauge_metrics name with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let g = Gauge.v name ~help ~namespace ~subsystem ~registry:t.registry in","counters":[]},{"line":"        Hashtbl.add_exn t.gauge_metrics ~key:name ~data:g ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        g","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    | Some m ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        m","counters":[]},{"line":"","counters":[]},{"line":"  let unparented_blocks t : Gauge.t =","counters":[]},{"line":"    let help = \"Number of blocks without a parent\" in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let name = \"unparented_blocks\" in","counters":[]},{"line":"    find_or_add t ~name ~help ~subsystem","counters":[]},{"line":"","counters":[]},{"line":"  let max_block_height t : Gauge.t =","counters":[]},{"line":"    let help = \"Max block height recorded in the archive database\" in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let name = \"max_block_height\" in","counters":[]},{"line":"    find_or_add t ~name ~help ~subsystem","counters":[]},{"line":"","counters":[]},{"line":"  let missing_blocks t : Gauge.t =","counters":[]},{"line":"    let help =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      \"Number of missing blocks in the last n (n = 2000 by default) blocks. A \\","counters":[]},{"line":"       block for a specific height is missing if there is no entry in the \\","counters":[]},{"line":"       blocks table for that height\"","counters":[]},{"line":"    in","counters":[]},{"line":"    let name = \"missing_blocks\" in","counters":[]},{"line":"    find_or_add t ~name ~help ~subsystem","counters":[]},{"line":"","counters":[]},{"line":"  let create_archive_server ?forward_uri ~port ~logger () =","counters":[]},{"line":"    let open Async_kernel.Deferred.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let archive_registry = CollectorRegistry.create () in","counters":[]},{"line":"    let%map _ =","counters":[]},{"line":"      generic_server ?forward_uri ~port ~logger ~registry:archive_registry ()","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"    in","counters":[]},{"line":"    { registry = archive_registry","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    ; gauge_metrics = Hashtbl.create (module String)","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"    }","counters":[]},{"line":"end","counters":[]}]}