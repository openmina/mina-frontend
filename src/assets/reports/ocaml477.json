{"filename":"src/lib/verifier/common.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Mina_base","counters":[]},{"line":"","counters":[]},{"line":"type invalid =","counters":[{"col_start":0,"col_end":0,"count":1},{"col_start":11,"col_end":11,"count":1}]},{"line":"  [ `Invalid_keys of Signature_lib.Public_key.Compressed.Stable.Latest.t list","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":76,"col_end":76,"count":0}]},{"line":"  | `Invalid_signature of","counters":[]},{"line":"    Signature_lib.Public_key.Compressed.Stable.Latest.t list","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"  | `Invalid_proof","counters":[]},{"line":"  | `Missing_verification_key of","counters":[]},{"line":"    Signature_lib.Public_key.Compressed.Stable.Latest.t list ]","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"[@@deriving bin_io_unversioned, to_yojson]","counters":[{"col_start":41,"col_end":41,"count":4}]},{"line":"","counters":[]},{"line":"let invalid_to_string (invalid : invalid) =","counters":[]},{"line":"  let keys_to_string keys =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    List.map keys ~f:(fun key ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        Signature_lib.Public_key.Compressed.to_base58_check key )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    |> String.concat ~sep:\";\"","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"  in","counters":[]},{"line":"  match invalid with","counters":[]},{"line":"  | `Invalid_keys keys ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      sprintf \"Invalid_keys: [%s]\" (keys_to_string keys)","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"  | `Invalid_signature keys ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      sprintf \"Invalid_signature: [%s]\" (keys_to_string keys)","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"  | `Missing_verification_key keys ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      sprintf \"Missing_verification_key: [%s]\" (keys_to_string keys)","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"  | `Invalid_proof ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      \"Invalid_proof\"","counters":[]},{"line":"","counters":[]},{"line":"let check :","counters":[]},{"line":"       User_command.Verifiable.t","counters":[]},{"line":"    -> [ `Valid of User_command.Valid.t","counters":[]},{"line":"       | `Valid_assuming of User_command.Valid.t * _ list","counters":[]},{"line":"       | invalid ] = function","counters":[]},{"line":"  | User_command.Signed_command c -> (","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      if not (Signed_command.check_valid_keys c) then","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"        `Invalid_keys (Signed_command.public_keys c)","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"      else","counters":[]},{"line":"        match Signed_command.check_only_for_signature c with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | Some c ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            `Valid (User_command.Signed_command c)","counters":[]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            `Invalid_signature (Signed_command.public_keys c) )","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"  | Zkapp_command ({ fee_payer; account_updates; memo } as zkapp_command_with_vk)","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    ->","counters":[]},{"line":"      with_return (fun { return } ->","counters":[]},{"line":"          let account_updates_hash =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Zkapp_command.Call_forest.hash account_updates","counters":[]},{"line":"          in","counters":[]},{"line":"          let tx_commitment =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Zkapp_command.Transaction_commitment.create ~account_updates_hash","counters":[]},{"line":"          in","counters":[]},{"line":"          let full_tx_commitment =","counters":[]},{"line":"            Zkapp_command.Transaction_commitment.create_complete tx_commitment","counters":[]},{"line":"              ~memo_hash:(Signed_command_memo.hash memo)","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"              ~fee_payer_hash:","counters":[]},{"line":"                (Zkapp_command.Digest.Account_update.create","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"                   (Account_update.of_fee_payer fee_payer) )","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"          in","counters":[]},{"line":"          let check_signature s pk msg =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            match Signature_lib.Public_key.decompress pk with","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            | None ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                return (`Invalid_keys [ pk ])","counters":[]},{"line":"            | Some pk ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                if","counters":[]},{"line":"                  not","counters":[]},{"line":"                    (Signature_lib.Schnorr.Chunked.verify s","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"                       (Backend.Tick.Inner_curve.of_affine pk)","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"                       (Random_oracle_input.Chunked.field msg) )","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"                then","counters":[]},{"line":"                  return","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    (`Invalid_signature [ Signature_lib.Public_key.compress pk ])","counters":[{"col_start":74,"col_end":74,"count":0}]},{"line":"                else ()","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"          in","counters":[]},{"line":"          check_signature fee_payer.authorization fee_payer.body.public_key","counters":[]},{"line":"            full_tx_commitment ;","counters":[]},{"line":"          let zkapp_command_with_hashes_list =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            account_updates |> Zkapp_statement.zkapp_statements_of_forest'","counters":[]},{"line":"            |> Zkapp_command.Call_forest.With_hashes_and_data","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"               .to_zkapp_command_with_hashes_list","counters":[]},{"line":"          in","counters":[]},{"line":"          let valid_assuming =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            List.filter_map zkapp_command_with_hashes_list","counters":[]},{"line":"              ~f:(fun ((p, (vk_opt, stmt)), _at_account_update) ->","counters":[]},{"line":"                let commitment =","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  if p.body.use_full_commitment then full_tx_commitment","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"                  else tx_commitment","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                in","counters":[]},{"line":"                match p.authorization with","counters":[]},{"line":"                | Signature s ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    check_signature s p.body.public_key commitment ;","counters":[]},{"line":"                    None","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                | None_given ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    None","counters":[]},{"line":"                | Proof pi -> (","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    match vk_opt with","counters":[]},{"line":"                    | None ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        return","counters":[]},{"line":"                          (`Missing_verification_key","counters":[]},{"line":"                            [ Account_id.public_key","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                              @@ Account_update.account_id p","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"                            ] )","counters":[]},{"line":"                    | Some (vk : _ With_hash.t) ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        Some (vk.data, stmt, pi) ) )","counters":[]},{"line":"          in","counters":[]},{"line":"          let v : User_command.Valid.t =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (*Verification keys should be present if it reaches here*)","counters":[]},{"line":"            let zkapp_command =","counters":[]},{"line":"              Option.value_exn","counters":[]},{"line":"                (Zkapp_command.Valid.of_verifiable zkapp_command_with_vk)","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"            in","counters":[]},{"line":"            User_command.Poly.Zkapp_command zkapp_command","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          in","counters":[]},{"line":"          match valid_assuming with","counters":[]},{"line":"          | [] ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              `Valid v","counters":[]},{"line":"          | _ :: _ ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              `Valid_assuming (v, valid_assuming) )","counters":[]}]}