{"filename":"src/lib/pickles/composition_types/composition_types.ml","lines":[{"line":"open Pickles_types","counters":[]},{"line":"module Scalar_challenge = Kimchi_backend_common.Scalar_challenge","counters":[]},{"line":"module Bulletproof_challenge = Bulletproof_challenge","counters":[]},{"line":"module Branch_data = Branch_data","counters":[]},{"line":"module Digest = Digest","counters":[]},{"line":"module Spec = Spec","counters":[]},{"line":"module Opt = Plonk_types.Opt","counters":[]},{"line":"open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"type 'f impl = 'f Spec.impl","counters":[]},{"line":"","counters":[]},{"line":"let index_to_field_elements =","counters":[]},{"line":"  Pickles_base.Side_loaded_verification_key.index_to_field_elements","counters":[]},{"line":"","counters":[]},{"line":"module Zero_values = struct","counters":[]},{"line":"  type ('chal, 'fp) single = { challenge : 'chal; scalar : 'fp }","counters":[]},{"line":"","counters":[]},{"line":"  type ('chal, 'chal_var, 'fp, 'fp_var) t =","counters":[]},{"line":"    { value : ('chal, 'fp) single; var : ('chal_var, 'fp_var) single }","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Wrap = struct","counters":[]},{"line":"  module Proof_state = struct","counters":[]},{"line":"    (** This module contains structures which contain the scalar-field elements that","counters":[]},{"line":"        are required to finalize the verification of a proof that is partially verified inside","counters":[]},{"line":"        a circuit.","counters":[]},{"line":"","counters":[]},{"line":"        Each verifier circuit starts by verifying the parts of a proof involving group operations.","counters":[]},{"line":"        At the end, there is a sequence of scalar-field computations it must perform. Instead of","counters":[]},{"line":"        performing them directly, it exposes the values needed for those computations as a part of","counters":[]},{"line":"        its own public-input, so that the next circuit can do them (since it will use the other curve on the cycle,","counters":[]},{"line":"        and hence can efficiently perform computations in that scalar field). *)","counters":[]},{"line":"    module Deferred_values = struct","counters":[]},{"line":"      module Plonk = struct","counters":[]},{"line":"        module Minimal = struct","counters":[]},{"line":"          [%%versioned","counters":[]},{"line":"          module Stable = struct","counters":[]},{"line":"            module V1 = struct","counters":[]},{"line":"              (** Challenges from the PLONK IOP. These, plus the evaluations that are already in the proof, are","counters":[]},{"line":"                  all that's needed to derive all the values in the [In_circuit] version below.","counters":[]},{"line":"","counters":[]},{"line":"                  See src/lib/pickles/plonk_checks/plonk_checks.ml for the computation of the [In_circuit] value","counters":[]},{"line":"                  from the [Minimal] value.","counters":[]},{"line":"              *)","counters":[]},{"line":"              type ('challenge, 'scalar_challenge) t =","counters":[{"col_start":14,"col_end":14,"count":13},{"col_start":51,"col_end":51,"count":5}]},{"line":"                    ( 'challenge","counters":[]},{"line":"                    , 'scalar_challenge )","counters":[]},{"line":"                    Mina_wire_types.Pickles_composition_types.Wrap.Proof_state","counters":[]},{"line":"                    .Deferred_values","counters":[]},{"line":"                    .Plonk","counters":[]},{"line":"                    .Minimal","counters":[]},{"line":"                    .V1","counters":[]},{"line":"                    .t =","counters":[]},{"line":"                { alpha : 'scalar_challenge","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"                ; beta : 'challenge","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"                ; gamma : 'challenge","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"                ; zeta : 'scalar_challenge","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"                ; joint_combiner : 'scalar_challenge option","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":51,"col_end":51,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"                }","counters":[]},{"line":"              [@@deriving sexp, compare, yojson, hlist, hash, equal]","counters":[{"col_start":67,"col_end":67,"count":3}]},{"line":"","counters":[]},{"line":"              let to_latest = Fn.id","counters":[]},{"line":"            end","counters":[]},{"line":"          end]","counters":[]},{"line":"        end","counters":[]},{"line":"","counters":[]},{"line":"        open Pickles_types","counters":[]},{"line":"        module Generic_coeffs_vec = Vector.With_length (Nat.N9)","counters":[]},{"line":"","counters":[]},{"line":"        module In_circuit = struct","counters":[]},{"line":"          module Lookup = struct","counters":[]},{"line":"            type ('scalar_challenge, 'fp) t =","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"              { joint_combiner : 'scalar_challenge","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"              ; lookup_gate : 'fp","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"                    (** scalar used on the lookup gate selector. *)","counters":[]},{"line":"              }","counters":[]},{"line":"            [@@deriving sexp, compare, yojson, hlist, hash, equal, fields]","counters":[]},{"line":"","counters":[]},{"line":"            let to_struct l = Hlist.HlistId.[ l.joint_combiner; l.lookup_gate ]","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"","counters":[]},{"line":"            let of_struct Hlist.HlistId.[ joint_combiner; lookup_gate ] =","counters":[]},{"line":"              { joint_combiner; lookup_gate }","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"","counters":[]},{"line":"            let typ (type f fp) scalar_challenge","counters":[]},{"line":"                (scalar : (fp, _, f) Snarky_backendless.Typ.t) =","counters":[]},{"line":"              Snarky_backendless.Typ.of_hlistable ~var_to_hlist:to_hlist","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ~var_of_hlist:of_hlist ~value_to_hlist:to_hlist","counters":[]},{"line":"                ~value_of_hlist:of_hlist","counters":[]},{"line":"                [ scalar_challenge; scalar ]","counters":[]},{"line":"          end","counters":[]},{"line":"","counters":[]},{"line":"          (** All scalar values deferred by a verifier circuit.","counters":[]},{"line":"              The values in [poseidon_selector], [vbmul], [complete_add], [endomul], [endomul_scalar], [perm], and [generic]","counters":[]},{"line":"              are all scalars which will have been used to scale selector polynomials during the","counters":[]},{"line":"              computation of the linearized polynomial commitment.","counters":[]},{"line":"","counters":[]},{"line":"              Then, we expose them so the next guy (who can do scalar arithmetic) can check that they","counters":[]},{"line":"              were computed correctly from the evaluations in the proof and the challenges.","counters":[]},{"line":"          *)","counters":[]},{"line":"          type ('challenge, 'scalar_challenge, 'fp, 'lookup_opt) t =","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"            { alpha : 'scalar_challenge","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"            ; beta : 'challenge","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"            ; gamma : 'challenge","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"            ; zeta : 'scalar_challenge","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"                  (* TODO: zeta_to_srs_length is kind of unnecessary.","counters":[]},{"line":"                     Try to get rid of it when you can.","counters":[]},{"line":"                  *)","counters":[]},{"line":"            ; zeta_to_srs_length : 'fp","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"            ; zeta_to_domain_size : 'fp","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"            ; poseidon_selector : 'fp","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"                  (** scalar used on the poseidon selector *)","counters":[]},{"line":"            ; vbmul : 'fp  (** scalar used on the vbmul selector *)","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"            ; complete_add : 'fp","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"                  (** scalar used on the complete_add selector *)","counters":[]},{"line":"            ; endomul : 'fp  (** scalar used on the endomul selector *)","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"            ; endomul_scalar : 'fp","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"                  (** scalar used on the endomul_scalar selector *)","counters":[]},{"line":"            ; perm : 'fp","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"                  (** scalar used on one of the permutation polynomial commitments. *)","counters":[]},{"line":"            ; generic : 'fp Generic_coeffs_vec.t","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"                  (** scalars used on the coefficient column commitments. *)","counters":[]},{"line":"            ; lookup : 'lookup_opt","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"            }","counters":[]},{"line":"          [@@deriving sexp, compare, yojson, hlist, hash, equal, fields]","counters":[{"col_start":71,"col_end":71,"count":0}]},{"line":"","counters":[]},{"line":"          let map_challenges t ~f ~scalar =","counters":[]},{"line":"            { t with","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              alpha = scalar t.alpha","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"            ; beta = f t.beta","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"            ; gamma = f t.gamma","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"            ; zeta = scalar t.zeta","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"            ; lookup =","counters":[]},{"line":"                Opt.map t.lookup ~f:(fun (l : _ Lookup.t) ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                    { l with joint_combiner = scalar l.joint_combiner } )","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"            }","counters":[]},{"line":"","counters":[]},{"line":"          let map_fields t ~f =","counters":[]},{"line":"            { t with","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              poseidon_selector = f t.poseidon_selector","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"            ; zeta_to_srs_length = f t.zeta_to_srs_length","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"            ; zeta_to_domain_size = f t.zeta_to_domain_size","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"            ; vbmul = f t.vbmul","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"            ; complete_add = f t.complete_add","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"            ; endomul = f t.endomul","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"            ; endomul_scalar = f t.endomul_scalar","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"            ; perm = f t.perm","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"            ; generic = Vector.map ~f t.generic","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"            ; lookup =","counters":[]},{"line":"                Opt.map t.lookup ~f:(fun (l : _ Lookup.t) ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                    { l with lookup_gate = f l.lookup_gate } )","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"            }","counters":[]},{"line":"","counters":[]},{"line":"          let typ (type f fp)","counters":[]},{"line":"              (module Impl : Snarky_backendless.Snark_intf.Run","counters":[]},{"line":"                with type field = f ) ~(lookup : Plonk_types.Opt.Flag.t)","counters":[]},{"line":"              ~dummy_scalar ~dummy_scalar_challenge ~challenge ~scalar_challenge","counters":[]},{"line":"              (fp : (fp, _, f) Snarky_backendless.Typ.t) =","counters":[]},{"line":"            Snarky_backendless.Typ.of_hlistable","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              [ Scalar_challenge.typ scalar_challenge","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"              ; challenge","counters":[]},{"line":"              ; challenge","counters":[]},{"line":"              ; Scalar_challenge.typ scalar_challenge","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"              ; fp","counters":[]},{"line":"              ; fp","counters":[]},{"line":"              ; fp","counters":[]},{"line":"              ; fp","counters":[]},{"line":"              ; fp","counters":[]},{"line":"              ; fp","counters":[]},{"line":"              ; fp","counters":[]},{"line":"              ; fp","counters":[]},{"line":"              ; Vector.typ fp Nat.N9.n","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"              ; Plonk_types.Opt.typ Impl.Boolean.typ lookup","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"                  ~dummy:","counters":[]},{"line":"                    { joint_combiner = dummy_scalar_challenge","counters":[]},{"line":"                    ; lookup_gate = dummy_scalar","counters":[]},{"line":"                    }","counters":[]},{"line":"                  (Lookup.typ (Scalar_challenge.typ scalar_challenge) fp)","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"              ]","counters":[]},{"line":"              ~var_to_hlist:to_hlist ~var_of_hlist:of_hlist","counters":[]},{"line":"              ~value_to_hlist:to_hlist ~value_of_hlist:of_hlist","counters":[]},{"line":"        end","counters":[]},{"line":"","counters":[]},{"line":"        let to_minimal (type challenge scalar_challenge fp lookup_opt)","counters":[]},{"line":"            (t : (challenge, scalar_challenge, fp, lookup_opt) In_circuit.t)","counters":[]},{"line":"            ~(to_option :","counters":[]},{"line":"               lookup_opt -> (scalar_challenge, fp) In_circuit.Lookup.t option","counters":[]},{"line":"               ) : (challenge, scalar_challenge) Minimal.t =","counters":[]},{"line":"          { alpha = t.alpha","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          ; beta = t.beta","counters":[]},{"line":"          ; zeta = t.zeta","counters":[]},{"line":"          ; gamma = t.gamma","counters":[]},{"line":"          ; joint_combiner =","counters":[]},{"line":"              Option.map (to_option t.lookup) ~f:(fun l ->","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"                  l.In_circuit.Lookup.joint_combiner )","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"          }","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      [%%versioned","counters":[]},{"line":"      module Stable = struct","counters":[]},{"line":"        [@@@no_toplevel_latest_type]","counters":[]},{"line":"","counters":[]},{"line":"        module V1 = struct","counters":[]},{"line":"          (** All the deferred values needed, comprising values from the PLONK IOP verification,","counters":[]},{"line":"    values from the inner-product argument, and [which_branch] which is needed to know","counters":[]},{"line":"    the proper domain to use. *)","counters":[]},{"line":"          type ( 'plonk","counters":[{"col_start":10,"col_end":10,"count":15}]},{"line":"               , 'scalar_challenge","counters":[]},{"line":"               , 'fp","counters":[]},{"line":"               , 'bulletproof_challenges","counters":[]},{"line":"               , 'branch_data )","counters":[]},{"line":"               t =","counters":[{"col_start":15,"col_end":15,"count":8}]},{"line":"                ( 'plonk","counters":[]},{"line":"                , 'scalar_challenge","counters":[]},{"line":"                , 'fp","counters":[]},{"line":"                , 'bulletproof_challenges","counters":[]},{"line":"                , 'branch_data )","counters":[]},{"line":"                Mina_wire_types.Pickles_composition_types.Wrap.Proof_state","counters":[]},{"line":"                .Deferred_values","counters":[]},{"line":"                .V1","counters":[]},{"line":"                .t =","counters":[]},{"line":"            { plonk : 'plonk","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"            ; combined_inner_product : 'fp","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"                  (** combined_inner_product = sum_{i < num_evaluation_points} sum_{j < num_polys} r^i xi^j f_j(pt_i) *)","counters":[]},{"line":"            ; b : 'fp","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":20,"col_end":20,"count":0}]},{"line":"                  (** b = challenge_poly plonk.zeta + r * challenge_poly (domain_generrator * plonk.zeta)","counters":[]},{"line":"                where challenge_poly(x) = \\prod_i (1 + bulletproof_challenges.(i) * x^{2^{k - 1 - i}})","counters":[]},{"line":"            *)","counters":[]},{"line":"            ; xi : 'scalar_challenge","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"                  (** The challenge used for combining polynomials *)","counters":[]},{"line":"            ; bulletproof_challenges : 'bulletproof_challenges","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"                  (** The challenges from the inner-product argument that was partially verified. *)","counters":[]},{"line":"            ; branch_data : 'branch_data","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"                  (** Data specific to which step branch of the proof-system was verified *)","counters":[]},{"line":"            }","counters":[]},{"line":"          [@@deriving sexp, compare, yojson, hlist, hash, equal]","counters":[{"col_start":63,"col_end":63,"count":3}]},{"line":"","counters":[]},{"line":"          let to_latest = Fn.id","counters":[]},{"line":"        end","counters":[]},{"line":"      end]","counters":[]},{"line":"","counters":[]},{"line":"      type ( 'plonk","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"           , 'scalar_challenge","counters":[]},{"line":"           , 'fp","counters":[]},{"line":"           , 'bulletproof_challenges","counters":[]},{"line":"           , 'branch_data )","counters":[]},{"line":"           t =","counters":[]},{"line":"            ( 'plonk","counters":[]},{"line":"            , 'scalar_challenge","counters":[]},{"line":"            , 'fp","counters":[]},{"line":"            , 'bulletproof_challenges","counters":[]},{"line":"            , 'branch_data )","counters":[]},{"line":"            Stable.Latest.t =","counters":[]},{"line":"        { plonk : 'plonk","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":14,"col_end":14,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"        ; combined_inner_product : 'fp","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"        ; b : 'fp","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":14,"col_end":14,"count":0},{"col_start":16,"col_end":16,"count":0}]},{"line":"        ; xi : 'scalar_challenge","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":11,"col_end":11,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"        ; bulletproof_challenges : 'bulletproof_challenges","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"        ; branch_data : 'branch_data","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"        }","counters":[]},{"line":"      [@@deriving sexp, compare, yojson, hlist, hash, equal]","counters":[]},{"line":"","counters":[]},{"line":"      module Minimal = struct","counters":[]},{"line":"        type ( 'challenge","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"             , 'scalar_challenge","counters":[]},{"line":"             , 'fp","counters":[]},{"line":"             , 'bulletproof_challenges","counters":[]},{"line":"             , 'index )","counters":[]},{"line":"             t =","counters":[]},{"line":"          ( ('challenge, 'scalar_challenge) Plonk.Minimal.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":12,"col_end":12,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"          , 'scalar_challenge","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          , 'fp","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          , 'bulletproof_challenges","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          , 'index )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          Stable.Latest.t","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        [@@deriving sexp, compare, yojson, hash, equal]","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      let map_challenges","counters":[]},{"line":"          { plonk","counters":[]},{"line":"          ; combined_inner_product","counters":[]},{"line":"          ; b : 'fp","counters":[]},{"line":"          ; xi","counters":[]},{"line":"          ; bulletproof_challenges","counters":[]},{"line":"          ; branch_data","counters":[]},{"line":"          } ~f ~scalar =","counters":[]},{"line":"        { xi = scalar xi","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":20,"col_end":20,"count":0}]},{"line":"        ; combined_inner_product","counters":[]},{"line":"        ; b","counters":[]},{"line":"        ; plonk","counters":[]},{"line":"        ; bulletproof_challenges","counters":[]},{"line":"        ; branch_data","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"      module In_circuit = struct","counters":[]},{"line":"        type ( 'challenge","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"             , 'scalar_challenge","counters":[]},{"line":"             , 'fp","counters":[]},{"line":"             , 'lookup_opt","counters":[]},{"line":"             , 'bulletproof_challenges","counters":[]},{"line":"             , 'branch_data )","counters":[]},{"line":"             t =","counters":[]},{"line":"          ( ('challenge, 'scalar_challenge, 'fp, 'lookup_opt) Plonk.In_circuit.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":12,"col_end":12,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":49,"col_end":49,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"          , 'scalar_challenge","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          , 'fp","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          , 'bulletproof_challenges","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          , 'branch_data )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          Stable.Latest.t","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        [@@deriving sexp, compare, yojson, hash, equal]","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"","counters":[]},{"line":"        let to_hlist, of_hlist = (to_hlist, of_hlist)","counters":[]},{"line":"","counters":[]},{"line":"        let typ (type f fp)","counters":[]},{"line":"            (impl :","counters":[]},{"line":"              (module Snarky_backendless.Snark_intf.Run with type field = f) )","counters":[]},{"line":"            ~lookup ~dummy_scalar ~dummy_scalar_challenge ~challenge","counters":[]},{"line":"            ~scalar_challenge (fp : (fp, _, f) Snarky_backendless.Typ.t) index =","counters":[]},{"line":"          Snarky_backendless.Typ.of_hlistable","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            [ Plonk.In_circuit.typ impl ~lookup ~dummy_scalar","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"                ~dummy_scalar_challenge ~challenge ~scalar_challenge fp","counters":[]},{"line":"            ; fp","counters":[]},{"line":"            ; fp","counters":[]},{"line":"            ; Scalar_challenge.typ scalar_challenge","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"            ; Vector.typ","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                (Bulletproof_challenge.typ scalar_challenge)","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"                Backend.Tick.Rounds.n","counters":[]},{"line":"            ; index","counters":[]},{"line":"            ]","counters":[]},{"line":"            ~var_to_hlist:to_hlist ~var_of_hlist:of_hlist","counters":[]},{"line":"            ~value_to_hlist:to_hlist ~value_of_hlist:of_hlist","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      let to_minimal (t : _ In_circuit.t) ~to_option : _ Minimal.t =","counters":[]},{"line":"        { t with plonk = Plonk.to_minimal ~to_option t.plonk }","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    (** The component of the proof accumulation state that is only computed on by the","counters":[]},{"line":"        \"wrapping\" proof system, and that can be handled opaquely by any \"step\" circuits. *)","counters":[]},{"line":"    module Messages_for_next_wrap_proof = struct","counters":[]},{"line":"      [%%versioned","counters":[]},{"line":"      module Stable = struct","counters":[]},{"line":"        module V1 = struct","counters":[]},{"line":"          type ('g1, 'bulletproof_challenges) t =","counters":[{"col_start":10,"col_end":10,"count":8},{"col_start":46,"col_end":46,"count":5}]},{"line":"                ( 'g1","counters":[]},{"line":"                , 'bulletproof_challenges )","counters":[]},{"line":"                Mina_wire_types.Pickles_composition_types.Wrap.Proof_state","counters":[]},{"line":"                .Messages_for_next_wrap_proof","counters":[]},{"line":"                .V1","counters":[]},{"line":"                .t =","counters":[]},{"line":"            { challenge_polynomial_commitment : 'g1","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":48,"col_end":48,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"            ; old_bulletproof_challenges : 'bulletproof_challenges","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"            }","counters":[]},{"line":"          [@@deriving sexp, compare, yojson, hlist, hash, equal]","counters":[{"col_start":63,"col_end":63,"count":5}]},{"line":"        end","counters":[]},{"line":"      end]","counters":[]},{"line":"","counters":[]},{"line":"      let to_field_elements (type g f)","counters":[]},{"line":"          { challenge_polynomial_commitment; old_bulletproof_challenges }","counters":[]},{"line":"          ~g1:(g1_to_field_elements : g -> f list) =","counters":[]},{"line":"        Array.concat","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          [ Vector.to_array old_bulletproof_challenges","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"            |> Array.concat_map ~f:Vector.to_array","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"          ; Array.of_list (g1_to_field_elements challenge_polynomial_commitment)","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"          ]","counters":[]},{"line":"","counters":[]},{"line":"      let typ g1 chal ~length =","counters":[]},{"line":"        Snarky_backendless.Typ.of_hlistable","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          [ g1; Vector.typ chal length ]","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"          ~var_to_hlist:to_hlist ~var_of_hlist:of_hlist ~value_to_hlist:to_hlist","counters":[]},{"line":"          ~value_of_hlist:of_hlist","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type ( 'plonk","counters":[{"col_start":8,"col_end":8,"count":9}]},{"line":"             , 'scalar_challenge","counters":[]},{"line":"             , 'fp","counters":[]},{"line":"             , 'messages_for_next_wrap_proof","counters":[]},{"line":"             , 'digest","counters":[]},{"line":"             , 'bp_chals","counters":[]},{"line":"             , 'index )","counters":[]},{"line":"             t =","counters":[{"col_start":13,"col_end":13,"count":10}]},{"line":"              ( 'plonk","counters":[]},{"line":"              , 'scalar_challenge","counters":[]},{"line":"              , 'fp","counters":[]},{"line":"              , 'messages_for_next_wrap_proof","counters":[]},{"line":"              , 'digest","counters":[]},{"line":"              , 'bp_chals","counters":[]},{"line":"              , 'index )","counters":[]},{"line":"              Mina_wire_types.Pickles_composition_types.Wrap.Proof_state.V1.t =","counters":[]},{"line":"          { deferred_values :","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"              ( 'plonk","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":16,"col_end":16,"count":0}]},{"line":"              , 'scalar_challenge","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"              , 'fp","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"              , 'bp_chals","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"              , 'index )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"              Deferred_values.Stable.V1.t","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"          ; sponge_digest_before_evaluations : 'digest","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":43,"col_end":43,"count":0},{"col_start":47,"col_end":47,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"          ; messages_for_next_wrap_proof : 'messages_for_next_wrap_proof","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"                (** Parts of the statement not needed by the other circuit. Represented as a hash inside the","counters":[]},{"line":"              circuit which is then \"unhashed\". *)","counters":[]},{"line":"          }","counters":[]},{"line":"        [@@deriving sexp, compare, yojson, hlist, hash, equal]","counters":[{"col_start":61,"col_end":61,"count":3}]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    module Minimal = struct","counters":[]},{"line":"      type ( 'challenge","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"           , 'scalar_challenge","counters":[]},{"line":"           , 'scalar_challenge_opt","counters":[]},{"line":"           , 'fp","counters":[]},{"line":"           , 'messages_for_next_wrap_proof","counters":[]},{"line":"           , 'digest","counters":[]},{"line":"           , 'bp_chals","counters":[]},{"line":"           , 'index )","counters":[]},{"line":"           t =","counters":[]},{"line":"        ( ('challenge, 'scalar_challenge) Deferred_values.Plonk.Minimal.t","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":10,"col_end":10,"count":0},{"col_start":11,"col_end":11,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"        , 'scalar_challenge","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        , 'fp","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        , 'messages_for_next_wrap_proof","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        , 'digest","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        , 'bp_chals","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        , 'index )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        Stable.Latest.t","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      [@@deriving sexp, compare, yojson, hash, equal]","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module In_circuit = struct","counters":[]},{"line":"      type ( 'challenge","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"           , 'scalar_challenge","counters":[]},{"line":"           , 'fp","counters":[]},{"line":"           , 'lookup_opt","counters":[]},{"line":"           , 'messages_for_next_wrap_proof","counters":[]},{"line":"           , 'digest","counters":[]},{"line":"           , 'bp_chals","counters":[]},{"line":"           , 'index )","counters":[]},{"line":"           t =","counters":[]},{"line":"        ( ( 'challenge","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":10,"col_end":10,"count":0},{"col_start":12,"col_end":12,"count":0}]},{"line":"          , 'scalar_challenge","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          , 'fp","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          , 'lookup_opt )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          Deferred_values.Plonk.In_circuit.t","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        , 'scalar_challenge","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        , 'fp","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        , 'messages_for_next_wrap_proof","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        , 'digest","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        , 'bp_chals","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        , 'index )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        Stable.Latest.t","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      [@@deriving sexp, compare, yojson, hash, equal]","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"","counters":[]},{"line":"      let to_hlist, of_hlist = (to_hlist, of_hlist)","counters":[]},{"line":"","counters":[]},{"line":"      let typ (type f fp)","counters":[]},{"line":"          (impl : (module Snarky_backendless.Snark_intf.Run with type field = f))","counters":[]},{"line":"          ~lookup ~dummy_scalar ~dummy_scalar_challenge ~challenge","counters":[]},{"line":"          ~scalar_challenge (fp : (fp, _, f) Snarky_backendless.Typ.t)","counters":[]},{"line":"          messages_for_next_wrap_proof digest index =","counters":[]},{"line":"        Snarky_backendless.Typ.of_hlistable","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          [ Deferred_values.In_circuit.typ impl ~lookup ~dummy_scalar","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"              ~dummy_scalar_challenge ~challenge ~scalar_challenge fp index","counters":[]},{"line":"          ; digest","counters":[]},{"line":"          ; messages_for_next_wrap_proof","counters":[]},{"line":"          ]","counters":[]},{"line":"          ~var_to_hlist:to_hlist ~var_of_hlist:of_hlist ~value_to_hlist:to_hlist","counters":[]},{"line":"          ~value_of_hlist:of_hlist","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    let to_minimal (t : _ In_circuit.t) ~to_option : _ Minimal.t =","counters":[]},{"line":"      { t with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        deferred_values =","counters":[]},{"line":"          Deferred_values.to_minimal ~to_option t.deferred_values","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"      }","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  (** The component of the proof accumulation state that is only computed on by the","counters":[]},{"line":"      \"stepping\" proof system, and that can be handled opaquely by any \"wrap\" circuits. *)","counters":[]},{"line":"  module Messages_for_next_step_proof = struct","counters":[]},{"line":"    type ('g, 's, 'challenge_polynomial_commitments, 'bulletproof_challenges) t =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      { app_state : 's","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":16,"col_end":16,"count":0}]},{"line":"            (** The actual application-level state (e.g., for Mina, this is the protocol state which contains the","counters":[]},{"line":"    merkle root of the ledger, state related to consensus, etc.) *)","counters":[]},{"line":"      ; dlog_plonk_index : 'g Plonk_verification_key_evals.t","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"            (** The verification key corresponding to the wrap-circuit for this recursive proof system.","counters":[]},{"line":"          It gets threaded through all the circuits so that the step circuits can verify proofs against","counters":[]},{"line":"          it.","counters":[]},{"line":"      *)","counters":[]},{"line":"      ; challenge_polynomial_commitments : 'challenge_polynomial_commitments","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"      ; old_bulletproof_challenges : 'bulletproof_challenges","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"      }","counters":[]},{"line":"    [@@deriving sexp]","counters":[]},{"line":"","counters":[]},{"line":"    let to_field_elements (type g f)","counters":[]},{"line":"        { app_state","counters":[]},{"line":"        ; dlog_plonk_index","counters":[]},{"line":"        ; challenge_polynomial_commitments","counters":[]},{"line":"        ; old_bulletproof_challenges","counters":[]},{"line":"        } ~app_state:app_state_to_field_elements ~comm ~(g : g -> f list) =","counters":[]},{"line":"      Array.concat","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [ index_to_field_elements ~g:comm dlog_plonk_index","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"        ; app_state_to_field_elements app_state","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"        ; Vector.map2 challenge_polynomial_commitments","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"            old_bulletproof_challenges ~f:(fun comm chals ->","counters":[]},{"line":"              Array.append (Array.of_list (g comm)) (Vector.to_array chals) )","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":43,"col_end":43,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"          |> Vector.to_list |> Array.concat","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"        ]","counters":[]},{"line":"","counters":[]},{"line":"    let to_field_elements_without_index (type g f)","counters":[]},{"line":"        { app_state","counters":[]},{"line":"        ; dlog_plonk_index = _","counters":[]},{"line":"        ; challenge_polynomial_commitments","counters":[]},{"line":"        ; old_bulletproof_challenges","counters":[]},{"line":"        } ~app_state:app_state_to_field_elements ~(g : g -> f list) =","counters":[]},{"line":"      Array.concat","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [ app_state_to_field_elements app_state","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"        ; Vector.map2 challenge_polynomial_commitments","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"            old_bulletproof_challenges ~f:(fun comm chals ->","counters":[]},{"line":"              Array.append (Array.of_list (g comm)) (Vector.to_array chals) )","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":43,"col_end":43,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"          |> Vector.to_list |> Array.concat","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"        ]","counters":[]},{"line":"","counters":[]},{"line":"    open Snarky_backendless.H_list","counters":[]},{"line":"","counters":[]},{"line":"    let to_hlist","counters":[]},{"line":"        { app_state","counters":[]},{"line":"        ; dlog_plonk_index","counters":[]},{"line":"        ; challenge_polynomial_commitments","counters":[]},{"line":"        ; old_bulletproof_challenges","counters":[]},{"line":"        } =","counters":[]},{"line":"      [ app_state","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      ; dlog_plonk_index","counters":[]},{"line":"      ; challenge_polynomial_commitments","counters":[]},{"line":"      ; old_bulletproof_challenges","counters":[]},{"line":"      ]","counters":[]},{"line":"","counters":[]},{"line":"    let of_hlist","counters":[]},{"line":"        ([ app_state","counters":[]},{"line":"         ; dlog_plonk_index","counters":[]},{"line":"         ; challenge_polynomial_commitments","counters":[]},{"line":"         ; old_bulletproof_challenges","counters":[]},{"line":"         ] :","counters":[]},{"line":"          (unit, _) t ) =","counters":[]},{"line":"      { app_state","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      ; dlog_plonk_index","counters":[]},{"line":"      ; challenge_polynomial_commitments","counters":[]},{"line":"      ; old_bulletproof_challenges","counters":[]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    let typ comm g s chal proofs_verified =","counters":[]},{"line":"      Snarky_backendless.Typ.of_hlistable","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [ s","counters":[]},{"line":"        ; Plonk_verification_key_evals.typ comm","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"        ; Vector.typ g proofs_verified","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"        ; chal","counters":[]},{"line":"        ]","counters":[]},{"line":"        (* TODO: Should this really just be a vector typ of length Rounds.n ?*)","counters":[]},{"line":"        ~var_to_hlist:to_hlist ~var_of_hlist:of_hlist ~value_to_hlist:to_hlist","counters":[]},{"line":"        ~value_of_hlist:of_hlist","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Lookup_parameters = struct","counters":[]},{"line":"    (* Values needed for computing lookup parts of the verifier circuit. *)","counters":[]},{"line":"    type ('chal, 'chal_var, 'fp, 'fp_var) t =","counters":[]},{"line":"      { zero : ('chal, 'chal_var, 'fp, 'fp_var) Zero_values.t","counters":[]},{"line":"      ; use : Opt.Flag.t","counters":[]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    let opt_spec (type f) ((module Impl) : f impl)","counters":[]},{"line":"        { zero = { value; var }; use } =","counters":[]},{"line":"      Spec.Opt","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { inner = Struct [ Scalar Challenge; B Field ]","counters":[]},{"line":"        ; flag = use","counters":[]},{"line":"        ; dummy1 = [ Spec.Sc.create value.challenge; value.scalar ]","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"        ; dummy2 = [ Spec.Sc.create var.challenge; var.scalar ]","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"        ; bool = (module Impl.Boolean)","counters":[]},{"line":"        }","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  (** This is the full statement for \"wrap\" proofs which contains","counters":[]},{"line":"      - the application-level statement (app_state)","counters":[]},{"line":"      - data needed to perform the final verification of the proof, which correspond","counters":[]},{"line":"        to parts of incompletely verified proofs.","counters":[]},{"line":"  *)","counters":[]},{"line":"  module Statement = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type ( 'plonk","counters":[{"col_start":8,"col_end":8,"count":7}]},{"line":"             , 'scalar_challenge","counters":[]},{"line":"             , 'fp","counters":[]},{"line":"             , 'messages_for_next_wrap_proof","counters":[]},{"line":"             , 'digest","counters":[]},{"line":"             , 'messages_for_next_step_proof","counters":[]},{"line":"             , 'bp_chals","counters":[]},{"line":"             , 'index )","counters":[]},{"line":"             t =","counters":[{"col_start":13,"col_end":13,"count":11}]},{"line":"              ( 'plonk","counters":[]},{"line":"              , 'scalar_challenge","counters":[]},{"line":"              , 'fp","counters":[]},{"line":"              , 'messages_for_next_wrap_proof","counters":[]},{"line":"              , 'digest","counters":[]},{"line":"              , 'messages_for_next_step_proof","counters":[]},{"line":"              , 'bp_chals","counters":[]},{"line":"              , 'index )","counters":[]},{"line":"              Mina_wire_types.Pickles_composition_types.Wrap.Statement.V1.t =","counters":[]},{"line":"          { proof_state :","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"              ( 'plonk","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":16,"col_end":16,"count":0}]},{"line":"              , 'scalar_challenge","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"              , 'fp","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"              , 'messages_for_next_wrap_proof","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"              , 'digest","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"              , 'bp_chals","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"              , 'index )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"              Proof_state.Stable.V1.t","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"          ; messages_for_next_step_proof : 'messages_for_next_step_proof","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"          }","counters":[]},{"line":"        [@@deriving compare, yojson, sexp, hash, equal]","counters":[{"col_start":54,"col_end":54,"count":3}]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    module Minimal = struct","counters":[]},{"line":"      [%%versioned","counters":[]},{"line":"      module Stable = struct","counters":[]},{"line":"        module V1 = struct","counters":[]},{"line":"          type ( 'challenge","counters":[{"col_start":10,"col_end":10,"count":3},{"col_start":17,"col_end":17,"count":0}]},{"line":"               , 'scalar_challenge","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"               , 'fp","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"               , 'messages_for_next_wrap_proof","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"               , 'digest","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"               , 'messages_for_next_step_proof","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"               , 'bp_chals","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"               , 'index )","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"               t =","counters":[{"col_start":15,"col_end":15,"count":10}]},{"line":"            ( ( 'challenge","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":14,"col_end":14,"count":0},{"col_start":16,"col_end":16,"count":0}]},{"line":"              , 'scalar_challenge )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"              Proof_state.Deferred_values.Plonk.Minimal.Stable.V1.t","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"            , 'scalar_challenge","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"            , 'fp","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"            , 'messages_for_next_wrap_proof","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"            , 'digest","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"            , 'messages_for_next_step_proof","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"            , 'bp_chals","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"            , 'index )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"            Stable.V1.t","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          [@@deriving compare, yojson, sexp, hash, equal]","counters":[{"col_start":56,"col_end":56,"count":3}]},{"line":"        end","counters":[]},{"line":"      end]","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module In_circuit = struct","counters":[]},{"line":"      type ( 'challenge","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"           , 'scalar_challenge","counters":[]},{"line":"           , 'fp","counters":[]},{"line":"           , 'lookup_opt","counters":[]},{"line":"           , 'messages_for_next_wrap_proof","counters":[]},{"line":"           , 'digest","counters":[]},{"line":"           , 'messages_for_next_step_proof","counters":[]},{"line":"           , 'bp_chals","counters":[]},{"line":"           , 'index )","counters":[]},{"line":"           t =","counters":[]},{"line":"        ( ( 'challenge","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":10,"col_end":10,"count":0},{"col_start":12,"col_end":12,"count":0}]},{"line":"          , 'scalar_challenge","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          , 'fp","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          , 'lookup_opt )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          Proof_state.Deferred_values.Plonk.In_circuit.t","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        , 'scalar_challenge","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        , 'fp","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        , 'messages_for_next_wrap_proof","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        , 'digest","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        , 'messages_for_next_step_proof","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        , 'bp_chals","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        , 'index )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        Stable.Latest.t","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      [@@deriving compare, yojson, sexp, hash, equal]","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"","counters":[]},{"line":"      (** A layout of the raw data in a statement, which is needed for","counters":[]},{"line":"          representing it inside the circuit. *)","counters":[]},{"line":"      let spec impl lookup =","counters":[]},{"line":"        let open Spec in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Struct","counters":[]},{"line":"          [ Vector (B Field, Nat.N19.n)","counters":[]},{"line":"          ; Vector (B Challenge, Nat.N2.n)","counters":[]},{"line":"          ; Vector (Scalar Challenge, Nat.N3.n)","counters":[]},{"line":"          ; Vector (B Digest, Nat.N3.n)","counters":[]},{"line":"          ; Vector (B Bulletproof_challenge, Backend.Tick.Rounds.n)","counters":[]},{"line":"          ; Vector (B Branch_data, Nat.N1.n)","counters":[]},{"line":"          ; Lookup_parameters.opt_spec impl lookup","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"          ]","counters":[]},{"line":"","counters":[]},{"line":"      (** Convert a statement (as structured data) into the flat data-based representation. *)","counters":[]},{"line":"      let to_data","counters":[]},{"line":"          ({ proof_state =","counters":[]},{"line":"               { deferred_values =","counters":[]},{"line":"                   { xi","counters":[]},{"line":"                   ; combined_inner_product","counters":[]},{"line":"                   ; b","counters":[]},{"line":"                   ; branch_data","counters":[]},{"line":"                   ; bulletproof_challenges","counters":[]},{"line":"                   ; plonk =","counters":[]},{"line":"                       { alpha","counters":[]},{"line":"                       ; beta","counters":[]},{"line":"                       ; gamma","counters":[]},{"line":"                       ; zeta","counters":[]},{"line":"                       ; zeta_to_srs_length","counters":[]},{"line":"                       ; zeta_to_domain_size","counters":[]},{"line":"                       ; poseidon_selector","counters":[]},{"line":"                       ; vbmul","counters":[]},{"line":"                       ; complete_add","counters":[]},{"line":"                       ; endomul","counters":[]},{"line":"                       ; endomul_scalar","counters":[]},{"line":"                       ; perm","counters":[]},{"line":"                       ; generic","counters":[]},{"line":"                       ; lookup","counters":[]},{"line":"                       }","counters":[]},{"line":"                   }","counters":[]},{"line":"               ; sponge_digest_before_evaluations","counters":[]},{"line":"               ; messages_for_next_wrap_proof","counters":[]},{"line":"                 (* messages_for_next_wrap_proof is represented as a digest (and then unhashed) inside the circuit *)","counters":[]},{"line":"               }","counters":[]},{"line":"           ; messages_for_next_step_proof","counters":[]},{"line":"             (* messages_for_next_step_proof is represented as a digest inside the circuit *)","counters":[]},{"line":"           } :","counters":[]},{"line":"            _ t ) ~option_map =","counters":[]},{"line":"        let open Vector in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let fp =","counters":[]},{"line":"          combined_inner_product :: b :: zeta_to_srs_length","counters":[]},{"line":"          :: zeta_to_domain_size :: poseidon_selector :: vbmul :: complete_add","counters":[]},{"line":"          :: endomul :: endomul_scalar :: perm :: generic","counters":[]},{"line":"        in","counters":[]},{"line":"        let challenge = [ beta; gamma ] in","counters":[]},{"line":"        let scalar_challenge = [ alpha; zeta; xi ] in","counters":[]},{"line":"        let digest =","counters":[]},{"line":"          [ sponge_digest_before_evaluations","counters":[]},{"line":"          ; messages_for_next_wrap_proof","counters":[]},{"line":"          ; messages_for_next_step_proof","counters":[]},{"line":"          ]","counters":[]},{"line":"        in","counters":[]},{"line":"        let index = [ branch_data ] in","counters":[]},{"line":"        Hlist.HlistId.","counters":[]},{"line":"          [ fp","counters":[]},{"line":"          ; challenge","counters":[]},{"line":"          ; scalar_challenge","counters":[]},{"line":"          ; digest","counters":[]},{"line":"          ; bulletproof_challenges","counters":[]},{"line":"          ; index","counters":[]},{"line":"          ; option_map lookup","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"              ~f:Proof_state.Deferred_values.Plonk.In_circuit.Lookup.to_struct","counters":[]},{"line":"          ]","counters":[]},{"line":"","counters":[]},{"line":"      (** Construct a statement (as structured data) from the flat data-based representation. *)","counters":[]},{"line":"      let of_data","counters":[]},{"line":"          Hlist.HlistId.","counters":[]},{"line":"            [ fp","counters":[]},{"line":"            ; challenge","counters":[]},{"line":"            ; scalar_challenge","counters":[]},{"line":"            ; digest","counters":[]},{"line":"            ; bulletproof_challenges","counters":[]},{"line":"            ; index","counters":[]},{"line":"            ; lookup","counters":[]},{"line":"            ] ~option_map : _ t =","counters":[]},{"line":"        let open Vector in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let (combined_inner_product","counters":[]},{"line":"            :: b","counters":[]},{"line":"               :: zeta_to_srs_length","counters":[]},{"line":"                  :: zeta_to_domain_size","counters":[]},{"line":"                     :: poseidon_selector","counters":[]},{"line":"                        :: vbmul","counters":[]},{"line":"                           :: complete_add","counters":[]},{"line":"                              :: endomul :: endomul_scalar :: perm :: generic )","counters":[]},{"line":"            =","counters":[]},{"line":"          fp","counters":[]},{"line":"        in","counters":[]},{"line":"        let [ beta; gamma ] = challenge in","counters":[]},{"line":"        let [ alpha; zeta; xi ] = scalar_challenge in","counters":[]},{"line":"        let [ sponge_digest_before_evaluations","counters":[]},{"line":"            ; messages_for_next_wrap_proof","counters":[]},{"line":"            ; messages_for_next_step_proof","counters":[]},{"line":"            ] =","counters":[]},{"line":"          digest","counters":[]},{"line":"        in","counters":[]},{"line":"        let [ branch_data ] = index in","counters":[]},{"line":"        { proof_state =","counters":[]},{"line":"            { deferred_values =","counters":[]},{"line":"                { xi","counters":[]},{"line":"                ; combined_inner_product","counters":[]},{"line":"                ; b","counters":[]},{"line":"                ; branch_data","counters":[]},{"line":"                ; bulletproof_challenges","counters":[]},{"line":"                ; plonk =","counters":[]},{"line":"                    { alpha","counters":[]},{"line":"                    ; beta","counters":[]},{"line":"                    ; gamma","counters":[]},{"line":"                    ; zeta","counters":[]},{"line":"                    ; zeta_to_srs_length","counters":[]},{"line":"                    ; zeta_to_domain_size","counters":[]},{"line":"                    ; poseidon_selector","counters":[]},{"line":"                    ; vbmul","counters":[]},{"line":"                    ; complete_add","counters":[]},{"line":"                    ; endomul","counters":[]},{"line":"                    ; endomul_scalar","counters":[]},{"line":"                    ; perm","counters":[]},{"line":"                    ; generic","counters":[]},{"line":"                    ; lookup =","counters":[]},{"line":"                        option_map lookup","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"                          ~f:","counters":[]},{"line":"                            Proof_state.Deferred_values.Plonk.In_circuit.Lookup","counters":[]},{"line":"                            .of_struct","counters":[]},{"line":"                    }","counters":[]},{"line":"                }","counters":[]},{"line":"            ; sponge_digest_before_evaluations","counters":[]},{"line":"            ; messages_for_next_wrap_proof","counters":[]},{"line":"            }","counters":[]},{"line":"        ; messages_for_next_step_proof","counters":[]},{"line":"        }","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    let to_minimal (t : _ In_circuit.t) ~to_option : _ Minimal.t =","counters":[]},{"line":"      { t with proof_state = Proof_state.to_minimal ~to_option t.proof_state }","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Step = struct","counters":[]},{"line":"  module Plonk_polys = Nat.N10","counters":[]},{"line":"","counters":[]},{"line":"  module Bulletproof = struct","counters":[]},{"line":"    include Plonk_types.Openings.Bulletproof","counters":[]},{"line":"","counters":[]},{"line":"    module Advice = struct","counters":[]},{"line":"      (** This is data that can be computed in linear time from the proof + statement.","counters":[]},{"line":"","counters":[]},{"line":"          It doesn't need to be sent on the wire, but it does need to be provided to the verifier","counters":[]},{"line":"      *)","counters":[]},{"line":"      type 'fq t =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { b : 'fq","counters":[]},{"line":"        ; combined_inner_product : 'fq (* sum_i r^i sum_j xi^j f_j(pt_i) *)","counters":[]},{"line":"        }","counters":[]},{"line":"      [@@deriving hlist]","counters":[]},{"line":"    end","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Proof_state = struct","counters":[]},{"line":"    module Deferred_values = struct","counters":[]},{"line":"      module Plonk = Wrap.Proof_state.Deferred_values.Plonk","counters":[]},{"line":"","counters":[]},{"line":"      (** All the scalar-field values needed to finalize the verification of a proof","counters":[]},{"line":"    by checking that the correct values were used in the \"group operations\" part of the","counters":[]},{"line":"    verifier.","counters":[]},{"line":"","counters":[]},{"line":"    Consists of some evaluations of PLONK polynomials (columns, permutation aggregation, etc.)","counters":[]},{"line":"    and the remainder are things related to the inner product argument.","counters":[]},{"line":"*)","counters":[]},{"line":"      type ('plonk, 'scalar_challenge, 'fq, 'bulletproof_challenges) t_ =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { plonk : 'plonk","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":14,"col_end":14,"count":0},{"col_start":18,"col_end":18,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"        ; combined_inner_product : 'fq","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"              (** combined_inner_product = sum_{i < num_evaluation_points} sum_{j < num_polys} r^i xi^j f_j(pt_i) *)","counters":[]},{"line":"        ; xi : 'scalar_challenge","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":11,"col_end":11,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"              (** The challenge used for combining polynomials *)","counters":[]},{"line":"        ; bulletproof_challenges : 'bulletproof_challenges","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"              (** The challenges from the inner-product argument that was partially verified. *)","counters":[]},{"line":"        ; b : 'fq","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":16,"col_end":16,"count":0}]},{"line":"              (** b = challenge_poly plonk.zeta + r * challenge_poly (domain_generrator * plonk.zeta)","counters":[]},{"line":"                where challenge_poly(x) = \\prod_i (1 + bulletproof_challenges.(i) * x^{2^{k - 1 - i}})","counters":[]},{"line":"            *)","counters":[]},{"line":"        }","counters":[]},{"line":"      [@@deriving sexp, compare, yojson]","counters":[]},{"line":"","counters":[]},{"line":"      module Minimal = struct","counters":[]},{"line":"        type ('challenge, 'scalar_challenge, 'fq, 'bulletproof_challenges) t =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ( ('challenge, 'scalar_challenge) Plonk.Minimal.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":12,"col_end":12,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"          , 'scalar_challenge","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          , 'fq","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          , 'bulletproof_challenges )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          t_","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        [@@deriving sexp, compare, yojson]","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      module In_circuit = struct","counters":[]},{"line":"        type ( 'challenge","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"             , 'scalar_challenge","counters":[]},{"line":"             , 'fq","counters":[]},{"line":"             , 'bool","counters":[]},{"line":"             , 'bulletproof_challenges )","counters":[]},{"line":"             t =","counters":[]},{"line":"          ( ( 'challenge","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":12,"col_end":12,"count":0},{"col_start":14,"col_end":14,"count":0}]},{"line":"            , 'scalar_challenge","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"            , 'fq","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"            , (('scalar_challenge, 'fq) Plonk.In_circuit.Lookup.t, 'bool) Opt.t","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":67,"col_end":67,"count":0},{"col_start":74,"col_end":74,"count":0}]},{"line":"            )","counters":[]},{"line":"            Plonk.In_circuit.t","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          , 'scalar_challenge","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          , 'fq","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          , 'bulletproof_challenges )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          t_","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        [@@deriving sexp, compare, yojson]","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"      end","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Messages_for_next_wrap_proof =","counters":[]},{"line":"      Wrap.Proof_state.Messages_for_next_wrap_proof","counters":[]},{"line":"    module Messages_for_next_step_proof = Wrap.Messages_for_next_step_proof","counters":[]},{"line":"","counters":[]},{"line":"    module Per_proof = struct","counters":[]},{"line":"      (** For each proof that a step circuit verifies, we do not verify the whole proof.","counters":[]},{"line":"          Specifically,","counters":[]},{"line":"          - we defer calculations involving the \"other field\" (i.e., the scalar-field of the group","counters":[]},{"line":"            elements involved in the proof.","counters":[]},{"line":"          - we do not fully verify the inner-product argument as that would be O(n) and instead","counters":[]},{"line":"            do the accumulator trick.","counters":[]},{"line":"","counters":[]},{"line":"          As a result, for each proof that a step circuit verifies, we must expose some data","counters":[]},{"line":"          related to it as part of the step circuit's statement, in order to allow those proofs","counters":[]},{"line":"          to be fully verified eventually.","counters":[]},{"line":"","counters":[]},{"line":"          This is that data. *)","counters":[]},{"line":"      type ( 'plonk","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"           , 'scalar_challenge","counters":[]},{"line":"           , 'fq","counters":[]},{"line":"           , 'bulletproof_challenges","counters":[]},{"line":"           , 'digest","counters":[]},{"line":"           , 'bool )","counters":[]},{"line":"           t_ =","counters":[]},{"line":"        { deferred_values :","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"            ( 'plonk","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":14,"col_end":14,"count":0}]},{"line":"            , 'scalar_challenge","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"            , 'fq","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"            , 'bulletproof_challenges )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"            Deferred_values.t_","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"              (** Scalar values related to the proof *)","counters":[]},{"line":"        ; should_finalize : 'bool","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"              (** We allow circuits in pickles proof systems to decide if it's OK that a proof did","counters":[]},{"line":"    not recursively verify. In that case, when we expose the unfinalized bits, we need","counters":[]},{"line":"    to communicate that it's OK if those bits do not \"finalize\". That's what this boolean","counters":[]},{"line":"    is for. *)","counters":[]},{"line":"        ; sponge_digest_before_evaluations : 'digest","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"        }","counters":[]},{"line":"      [@@deriving sexp, compare, yojson]","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"      module Minimal = struct","counters":[]},{"line":"        type ( 'challenge","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"             , 'scalar_challenge","counters":[]},{"line":"             , 'fq","counters":[]},{"line":"             , 'bulletproof_challenges","counters":[]},{"line":"             , 'digest","counters":[]},{"line":"             , 'bool )","counters":[]},{"line":"             t =","counters":[]},{"line":"          ( ('challenge, 'scalar_challenge) Deferred_values.Plonk.Minimal.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":12,"col_end":12,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"          , 'scalar_challenge","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          , 'fq","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          , 'bulletproof_challenges","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          , 'digest","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          , 'bool )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          t_","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        [@@deriving sexp, compare, yojson]","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      module In_circuit = struct","counters":[]},{"line":"        type ( 'challenge","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"             , 'scalar_challenge","counters":[]},{"line":"             , 'fq","counters":[]},{"line":"             , 'lookup_opt","counters":[]},{"line":"             , 'bulletproof_challenges","counters":[]},{"line":"             , 'digest","counters":[]},{"line":"             , 'bool )","counters":[]},{"line":"             t =","counters":[]},{"line":"          ( ( 'challenge","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":12,"col_end":12,"count":0},{"col_start":14,"col_end":14,"count":0}]},{"line":"            , 'scalar_challenge","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"            , 'fq","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"            , 'lookup_opt )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"            Deferred_values.Plonk.In_circuit.t","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          , 'scalar_challenge","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          , 'fq","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          , 'bulletproof_challenges","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          , 'digest","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          , 'bool )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          t_","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        [@@deriving sexp, compare, yojson]","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"","counters":[]},{"line":"        (** A layout of the raw data in this value, which is needed for","counters":[]},{"line":"          representing it inside the circuit. *)","counters":[]},{"line":"        let spec impl bp_log2 lookup =","counters":[]},{"line":"          let open Spec in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          Struct","counters":[]},{"line":"            [ Vector (B Field, Nat.N19.n)","counters":[]},{"line":"            ; Vector (B Digest, Nat.N1.n)","counters":[]},{"line":"            ; Vector (B Challenge, Nat.N2.n)","counters":[]},{"line":"            ; Vector (Scalar Challenge, Nat.N3.n)","counters":[]},{"line":"            ; Vector (B Bulletproof_challenge, bp_log2)","counters":[]},{"line":"            ; Vector (B Bool, Nat.N1.n)","counters":[]},{"line":"            ; Wrap.Lookup_parameters.opt_spec impl lookup","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"            ]","counters":[]},{"line":"","counters":[]},{"line":"        let to_data","counters":[]},{"line":"            ({ deferred_values =","counters":[]},{"line":"                 { xi","counters":[]},{"line":"                 ; bulletproof_challenges","counters":[]},{"line":"                 ; b","counters":[]},{"line":"                 ; combined_inner_product","counters":[]},{"line":"                 ; plonk =","counters":[]},{"line":"                     { alpha","counters":[]},{"line":"                     ; beta","counters":[]},{"line":"                     ; gamma","counters":[]},{"line":"                     ; zeta","counters":[]},{"line":"                     ; zeta_to_srs_length","counters":[]},{"line":"                     ; zeta_to_domain_size","counters":[]},{"line":"                     ; poseidon_selector","counters":[]},{"line":"                     ; vbmul","counters":[]},{"line":"                     ; complete_add","counters":[]},{"line":"                     ; endomul","counters":[]},{"line":"                     ; endomul_scalar","counters":[]},{"line":"                     ; perm","counters":[]},{"line":"                     ; generic","counters":[]},{"line":"                     ; lookup","counters":[]},{"line":"                     }","counters":[]},{"line":"                 }","counters":[]},{"line":"             ; should_finalize","counters":[]},{"line":"             ; sponge_digest_before_evaluations","counters":[]},{"line":"             } :","counters":[]},{"line":"              _ t ) ~option_map =","counters":[]},{"line":"          let open Vector in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let fq =","counters":[]},{"line":"            combined_inner_product :: b :: zeta_to_srs_length","counters":[]},{"line":"            :: zeta_to_domain_size :: poseidon_selector :: vbmul :: complete_add","counters":[]},{"line":"            :: endomul :: endomul_scalar :: perm :: generic","counters":[]},{"line":"          in","counters":[]},{"line":"          let challenge = [ beta; gamma ] in","counters":[]},{"line":"          let scalar_challenge = [ alpha; zeta; xi ] in","counters":[]},{"line":"          let digest = [ sponge_digest_before_evaluations ] in","counters":[]},{"line":"          let bool = [ should_finalize ] in","counters":[]},{"line":"          let open Hlist.HlistId in","counters":[]},{"line":"          [ fq","counters":[]},{"line":"          ; digest","counters":[]},{"line":"          ; challenge","counters":[]},{"line":"          ; scalar_challenge","counters":[]},{"line":"          ; bulletproof_challenges","counters":[]},{"line":"          ; bool","counters":[]},{"line":"          ; option_map lookup","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"              ~f:Deferred_values.Plonk.In_circuit.Lookup.to_struct","counters":[]},{"line":"          ]","counters":[]},{"line":"","counters":[]},{"line":"        let of_data","counters":[]},{"line":"            Hlist.HlistId.","counters":[]},{"line":"              [ Vector.(","counters":[]},{"line":"                  combined_inner_product","counters":[]},{"line":"                  :: b","counters":[]},{"line":"                     :: zeta_to_srs_length","counters":[]},{"line":"                        :: zeta_to_domain_size","counters":[]},{"line":"                           :: poseidon_selector","counters":[]},{"line":"                              :: vbmul","counters":[]},{"line":"                                 :: complete_add","counters":[]},{"line":"                                    :: endomul","counters":[]},{"line":"                                       :: endomul_scalar :: perm :: generic)","counters":[]},{"line":"              ; Vector.[ sponge_digest_before_evaluations ]","counters":[]},{"line":"              ; Vector.[ beta; gamma ]","counters":[]},{"line":"              ; Vector.[ alpha; zeta; xi ]","counters":[]},{"line":"              ; bulletproof_challenges","counters":[]},{"line":"              ; Vector.[ should_finalize ]","counters":[]},{"line":"              ; lookup","counters":[]},{"line":"              ] ~option_map : _ t =","counters":[]},{"line":"          { deferred_values =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              { xi","counters":[]},{"line":"              ; bulletproof_challenges","counters":[]},{"line":"              ; b","counters":[]},{"line":"              ; combined_inner_product","counters":[]},{"line":"              ; plonk =","counters":[]},{"line":"                  { alpha","counters":[]},{"line":"                  ; beta","counters":[]},{"line":"                  ; gamma","counters":[]},{"line":"                  ; zeta","counters":[]},{"line":"                  ; zeta_to_srs_length","counters":[]},{"line":"                  ; zeta_to_domain_size","counters":[]},{"line":"                  ; poseidon_selector","counters":[]},{"line":"                  ; vbmul","counters":[]},{"line":"                  ; complete_add","counters":[]},{"line":"                  ; endomul","counters":[]},{"line":"                  ; endomul_scalar","counters":[]},{"line":"                  ; perm","counters":[]},{"line":"                  ; generic","counters":[]},{"line":"                  ; lookup =","counters":[]},{"line":"                      option_map lookup","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                        ~f:Deferred_values.Plonk.In_circuit.Lookup.of_struct","counters":[]},{"line":"                  }","counters":[]},{"line":"              }","counters":[]},{"line":"          ; should_finalize","counters":[]},{"line":"          ; sponge_digest_before_evaluations","counters":[]},{"line":"          }","counters":[]},{"line":"","counters":[]},{"line":"        let map_lookup (t : _ t) ~f =","counters":[]},{"line":"          { t with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            deferred_values =","counters":[]},{"line":"              { t.deferred_values with","counters":[]},{"line":"                plonk =","counters":[]},{"line":"                  { t.deferred_values.plonk with","counters":[]},{"line":"                    lookup = f t.deferred_values.plonk.lookup","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                  }","counters":[]},{"line":"              }","counters":[]},{"line":"          }","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      let typ impl fq ~assert_16_bits ~zero ~uses_lookup =","counters":[]},{"line":"        let open Deferred_values.Plonk.In_circuit.Lookup in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let lookup_config =","counters":[]},{"line":"          { Wrap.Lookup_parameters.use = uses_lookup; zero }","counters":[]},{"line":"        in","counters":[]},{"line":"        let open In_circuit in","counters":[]},{"line":"        Spec.typ impl fq ~assert_16_bits","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"          (spec impl Backend.Tock.Rounds.n lookup_config)","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"        |> Snarky_backendless.Typ.transport","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"             ~there:(to_data ~option_map:Option.map)","counters":[]},{"line":"             ~back:(of_data ~option_map:Option.map)","counters":[]},{"line":"        |> Snarky_backendless.Typ.transport_var","counters":[]},{"line":"             ~there:(to_data ~option_map:Opt.map)","counters":[]},{"line":"             ~back:(of_data ~option_map:Opt.map)","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    type ('unfinalized_proofs, 'messages_for_next_step_proof) t =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      { unfinalized_proofs : 'unfinalized_proofs","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"            (** A vector of the \"per-proof\" structures defined above, one for each proof","counters":[]},{"line":"    that the step-circuit partially verifies. *)","counters":[]},{"line":"      ; messages_for_next_step_proof : 'messages_for_next_step_proof","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"            (** The component of the proof accumulation state that is only computed on by the","counters":[]},{"line":"          \"stepping\" proof system, and that can be handled opaquely by any \"wrap\" circuits. *)","counters":[]},{"line":"      }","counters":[]},{"line":"    [@@deriving sexp, compare, yojson, hlist]","counters":[]},{"line":"","counters":[]},{"line":"    let spec unfinalized_proofs messages_for_next_step_proof =","counters":[]},{"line":"      let open Spec in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Struct [ unfinalized_proofs; messages_for_next_step_proof ]","counters":[]},{"line":"","counters":[]},{"line":"    include struct","counters":[]},{"line":"      open Hlist.HlistId","counters":[]},{"line":"","counters":[]},{"line":"      let to_data { unfinalized_proofs; messages_for_next_step_proof } =","counters":[]},{"line":"        [ Vector.map unfinalized_proofs ~f:Per_proof.In_circuit.to_data","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"        ; messages_for_next_step_proof","counters":[]},{"line":"        ]","counters":[]},{"line":"","counters":[]},{"line":"      let of_data [ unfinalized_proofs; messages_for_next_step_proof ] =","counters":[]},{"line":"        { unfinalized_proofs =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            Vector.map unfinalized_proofs ~f:Per_proof.In_circuit.of_data","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"        ; messages_for_next_step_proof","counters":[]},{"line":"        }","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    let typ (type n f)","counters":[]},{"line":"        ( (module Impl : Snarky_backendless.Snark_intf.Run with type field = f)","counters":[]},{"line":"        as impl ) zero ~assert_16_bits","counters":[]},{"line":"        (proofs_verified : (Pickles_types.Plonk_types.Opt.Flag.t, n) Vector.t)","counters":[]},{"line":"        fq :","counters":[]},{"line":"        ( ((_, _) Vector.t, _) t","counters":[]},{"line":"        , ((_, _) Vector.t, _) t","counters":[]},{"line":"        , _ )","counters":[]},{"line":"        Snarky_backendless.Typ.t =","counters":[]},{"line":"      let per_proof uses_lookup =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Per_proof.typ impl fq ~assert_16_bits ~zero ~uses_lookup","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      in","counters":[]},{"line":"      let unfinalized_proofs =","counters":[]},{"line":"        Vector.typ' (Vector.map proofs_verified ~f:per_proof)","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"      in","counters":[]},{"line":"      let messages_for_next_step_proof =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Spec.typ impl fq ~assert_16_bits (B Spec.Digest)","counters":[]},{"line":"      in","counters":[]},{"line":"      Snarky_backendless.Typ.of_hlistable","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [ unfinalized_proofs; messages_for_next_step_proof ]","counters":[]},{"line":"        ~var_to_hlist:to_hlist ~var_of_hlist:of_hlist ~value_to_hlist:to_hlist","counters":[]},{"line":"        ~value_of_hlist:of_hlist","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Statement = struct","counters":[]},{"line":"    type ( 'unfinalized_proofs","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"         , 'messages_for_next_step_proof","counters":[]},{"line":"         , 'messages_for_next_wrap_proof )","counters":[]},{"line":"         t =","counters":[]},{"line":"      { proof_state :","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"          ('unfinalized_proofs, 'messages_for_next_step_proof) Proof_state.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":11,"col_end":11,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":63,"col_end":63,"count":0},{"col_start":75,"col_end":75,"count":0}]},{"line":"      ; messages_for_next_wrap_proof : 'messages_for_next_wrap_proof","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"            (** The component of the proof accumulation state that is only computed on by the","counters":[]},{"line":"        \"wrapping\" proof system, and that can be handled opaquely by any \"step\" circuits. *)","counters":[]},{"line":"      }","counters":[]},{"line":"    [@@deriving sexp, compare, yojson]","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"    let to_data","counters":[]},{"line":"        { proof_state = { unfinalized_proofs; messages_for_next_step_proof }","counters":[]},{"line":"        ; messages_for_next_wrap_proof","counters":[]},{"line":"        } ~option_map =","counters":[]},{"line":"      let open Hlist.HlistId in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      [ Vector.map unfinalized_proofs","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"          ~f:(Proof_state.Per_proof.In_circuit.to_data ~option_map)","counters":[]},{"line":"      ; messages_for_next_step_proof","counters":[]},{"line":"      ; messages_for_next_wrap_proof","counters":[]},{"line":"      ]","counters":[]},{"line":"","counters":[]},{"line":"    let of_data","counters":[]},{"line":"        Hlist.HlistId.","counters":[]},{"line":"          [ unfinalized_proofs","counters":[]},{"line":"          ; messages_for_next_step_proof","counters":[]},{"line":"          ; messages_for_next_wrap_proof","counters":[]},{"line":"          ] ~option_map =","counters":[]},{"line":"      { proof_state =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          { unfinalized_proofs =","counters":[]},{"line":"              Vector.map unfinalized_proofs","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                ~f:(Proof_state.Per_proof.In_circuit.of_data ~option_map)","counters":[]},{"line":"          ; messages_for_next_step_proof","counters":[]},{"line":"          }","counters":[]},{"line":"      ; messages_for_next_wrap_proof","counters":[]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    let spec impl proofs_verified bp_log2 lookup =","counters":[]},{"line":"      let open Spec in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let per_proof =","counters":[]},{"line":"        Proof_state.Per_proof.In_circuit.spec impl bp_log2 lookup","counters":[]},{"line":"      in","counters":[]},{"line":"      Struct","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        [ Vector (per_proof, proofs_verified)","counters":[]},{"line":"        ; B Digest","counters":[]},{"line":"        ; Vector (B Digest, proofs_verified)","counters":[]},{"line":"        ]","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Nvector = Vector.With_length","counters":[]},{"line":"module Wrap_bp_vec = Backend.Tock.Rounds_vector","counters":[]},{"line":"module Step_bp_vec = Backend.Tick.Rounds_vector","counters":[]},{"line":"","counters":[]},{"line":"module Challenges_vector = struct","counters":[]},{"line":"  type 'n t =","counters":[]},{"line":"    (Backend.Tock.Field.t Snarky_backendless.Cvar.t Wrap_bp_vec.t, 'n) Vector.t","counters":[]},{"line":"","counters":[]},{"line":"  module Constant = struct","counters":[]},{"line":"    type 'n t = (Backend.Tock.Field.t Wrap_bp_vec.t, 'n) Vector.t","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}