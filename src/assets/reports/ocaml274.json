{"filename":"src/lib/transition_frontier/extensions/root_history.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Mina_base","counters":[]},{"line":"open Frontier_base","counters":[]},{"line":"module Queue = Hash_queue.Make (State_hash)","counters":[]},{"line":"","counters":[]},{"line":"module T = struct","counters":[]},{"line":"  type t =","counters":[]},{"line":"    { history : Root_data.Historical.t Queue.t","counters":[]},{"line":"    ; capacity : int","counters":[]},{"line":"    ; mutable current_root : Root_data.Historical.t","counters":[]},{"line":"    ; mutable protocol_states_for_root_scan_state :","counters":[]},{"line":"        Full_frontier.Protocol_states_for_root_scan_state.t","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  type view = t","counters":[]},{"line":"","counters":[]},{"line":"  let create ~logger:_ frontier =","counters":[]},{"line":"    let capacity = 2 * Full_frontier.max_length frontier in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"    let history = Queue.create () in","counters":[]},{"line":"    let current_root =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Root_data.Historical.of_breadcrumb (Full_frontier.root frontier)","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"    in","counters":[]},{"line":"    let t =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      { history","counters":[]},{"line":"      ; capacity","counters":[]},{"line":"      ; current_root","counters":[]},{"line":"      ; protocol_states_for_root_scan_state =","counters":[]},{"line":"          Full_frontier.protocol_states_for_root_scan_state frontier","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"      }","counters":[]},{"line":"    in","counters":[]},{"line":"    (t, t)","counters":[]},{"line":"","counters":[]},{"line":"  let enqueue t new_root =","counters":[]},{"line":"    let open Root_data.Historical in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    ( if Queue.length t.history >= t.capacity then","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"      let oldest_root = Queue.dequeue_front_exn t.history in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      (*Update the protocol states required for scan state at the new root*)","counters":[]},{"line":"      let _new_oldest_hash, new_oldest_root =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Queue.first_with_key t.history |> Option.value_exn","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"      in","counters":[]},{"line":"      let new_protocol_states_map =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Full_frontier.Protocol_states_for_root_scan_state","counters":[]},{"line":"        .protocol_states_for_next_root_scan_state","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"          t.protocol_states_for_root_scan_state","counters":[]},{"line":"          ~new_scan_state:(scan_state new_oldest_root)","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"          ~old_root_state:","counters":[]},{"line":"            ( transition oldest_root |> Mina_block.Validated.forget","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"            |> With_hash.map ~f:(fun block ->","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                   block |> Mina_block.header","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"                   |> Mina_block.Header.protocol_state ) )","counters":[]},{"line":"        |> List.map ~f:(fun s -> State_hash.With_state_hashes.(state_hash s, s))","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":72,"col_end":72,"count":0}]},{"line":"        |> State_hash.Map.of_alist_exn","counters":[]},{"line":"      in","counters":[]},{"line":"      t.protocol_states_for_root_scan_state <- new_protocol_states_map ) ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    assert (","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":11,"col_end":11,"count":0}]},{"line":"      [%equal: [ `Ok | `Key_already_present ]] `Ok","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"        (Queue.enqueue_back t.history","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"           (Mina_block.Validated.state_hash @@ transition t.current_root)","counters":[{"col_start":42,"col_end":42,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"           t.current_root ) ) ;","counters":[]},{"line":"    t.current_root <- new_root","counters":[]},{"line":"","counters":[]},{"line":"  let handle_diffs root_history frontier diffs_with_mutants =","counters":[]},{"line":"    let open Diff.Full.With_mutant in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let should_produce_view =","counters":[]},{"line":"      List.exists diffs_with_mutants ~f:(function","counters":[]},{"line":"        (* TODO: send full diffs to extensions to avoid extra lookups in frontier *)","counters":[]},{"line":"        | E (Root_transitioned { new_root; _ }, _) ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Full_frontier.find_exn frontier","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"              (Root_data.Limited.hashes new_root).state_hash","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"            |> Root_data.Historical.of_breadcrumb |> enqueue root_history ;","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"            true","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"        | E _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            false )","counters":[]},{"line":"    in","counters":[]},{"line":"    Option.some_if should_produce_view root_history","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"include T","counters":[]},{"line":"module Broadcasted = Functor.Make_broadcasted (T)","counters":[]},{"line":"","counters":[]},{"line":"let lookup { history; _ } = Queue.lookup history","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"","counters":[]},{"line":"let mem { history; _ } = Queue.mem history","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"let protocol_states_for_scan_state","counters":[]},{"line":"    { history; protocol_states_for_root_scan_state; _ } state_hash =","counters":[]},{"line":"  let open Option.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let open Root_data.Historical in","counters":[]},{"line":"  let%bind data = Queue.lookup history state_hash in","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"  let required_state_hashes =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Staged_ledger.Scan_state.required_state_hashes (scan_state data)","counters":[{"col_start":49,"col_end":49,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"    |> State_hash.Set.to_list","counters":[]},{"line":"  in","counters":[]},{"line":"  List.fold_until ~init:[]","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    ~finish:(fun lst -> Some lst)","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"    required_state_hashes","counters":[]},{"line":"    ~f:(fun acc hash ->","counters":[]},{"line":"      let res =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        match Queue.lookup history hash with","counters":[]},{"line":"        | Some data ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Some","counters":[]},{"line":"              ( transition data |> Mina_block.Validated.forget |> With_hash.data","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":61,"col_end":61,"count":0},{"col_start":79,"col_end":79,"count":0}]},{"line":"              |> Mina_block.header |> Mina_block.Header.protocol_state )","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (*Not present in the history queue, check in the protocol states map that has all the protocol states required for transactions in the root*)","counters":[]},{"line":"            let%map.Option state_with_hash =","counters":[]},{"line":"              State_hash.Map.find protocol_states_for_root_scan_state hash","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"            in","counters":[]},{"line":"            With_hash.data state_with_hash","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"      in","counters":[]},{"line":"      match res with None -> Stop None | Some state -> Continue (state :: acc)","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"      )","counters":[]},{"line":"","counters":[]},{"line":"let most_recent { history; _ } =","counters":[]},{"line":"  (* unfortunately, there is not function to inspect the last element in the queue,","counters":[]},{"line":"   * so we need to remove it and reinsert it instead *)","counters":[]},{"line":"  let open Option.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%map state_hash, breadcrumb = Queue.dequeue_back_with_key history in","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"  (* should never return `Key_already_present since we just removed it *)","counters":[]},{"line":"  assert (","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":9,"col_end":9,"count":0}]},{"line":"    [%equal: [ `Ok | `Key_already_present ]] `Ok","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"      (Queue.enqueue_back history state_hash breadcrumb) ) ;","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"  breadcrumb","counters":[]},{"line":"","counters":[]},{"line":"let oldest { history; _ } = Queue.first history","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"","counters":[]},{"line":"let is_empty { history; _ } = Queue.is_empty history","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"","counters":[]},{"line":"let to_list { history; _ } = Queue.to_list history","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":49,"col_end":49,"count":2}]}]}