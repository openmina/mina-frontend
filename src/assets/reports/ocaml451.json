{"filename":"src/lib/trust_system/trust_system.ml","lines":[{"line":"(** The trust system, instantiated with Coda-specific stuff. *)","counters":[{"col_start":62,"col_end":62,"count":1}]},{"line":"open Core","counters":[]},{"line":"","counters":[]},{"line":"open Async_kernel","counters":[]},{"line":"","counters":[]},{"line":"module Actions = struct","counters":[]},{"line":"  type action =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    | Incoming_connection_error","counters":[]},{"line":"        (** Connection error while peer connected to node. *)","counters":[]},{"line":"    | Outgoing_connection_error","counters":[]},{"line":"        (** Encountered connection error while connecting to a peer. *)","counters":[]},{"line":"    | Gossiped_old_transition of int64 * int","counters":[{"col_start":37,"col_end":37,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"        (** Peer gossiped a transition which was too old. Includes time before cutoff period in which the transition was received, expressed in slots and delta. *)","counters":[]},{"line":"    | Gossiped_future_transition","counters":[]},{"line":"        (** Peer gossiped a transition before its slot. *)","counters":[]},{"line":"    | Gossiped_invalid_transition","counters":[]},{"line":"        (** Peer gossiped an invalid transition to us. *)","counters":[]},{"line":"    | Disconnected_chain","counters":[]},{"line":"        (** Peer has been determined to be on a chain that is not connected to our chain. *)","counters":[]},{"line":"    | Sent_bad_hash","counters":[]},{"line":"        (** Peer sent us some data that doesn't hash to the expected value *)","counters":[]},{"line":"    | Sent_invalid_signature","counters":[]},{"line":"        (** Peer sent us something with a signature that doesn't check *)","counters":[]},{"line":"    | Sent_invalid_transaction  (** Peer sent us an invalid transaction *)","counters":[]},{"line":"    | Sent_invalid_proof  (** Peer sent us a proof that does not verify. *)","counters":[]},{"line":"    | Sent_invalid_signature_or_proof","counters":[]},{"line":"        (** Peer either sent us a proof or a signature that does not verify. *)","counters":[]},{"line":"    | Sent_invalid_protocol_version","counters":[]},{"line":"        (** Peer sent block with invalid protocol version *)","counters":[]},{"line":"    | Sent_mismatched_protocol_version","counters":[]},{"line":"        (** Peer sent block with protocol version not matching daemon protocol version *)","counters":[]},{"line":"    | Has_invalid_genesis_protocol_state","counters":[]},{"line":"        (**Peer gossiped a transition that has a different genesis protocol state from that of mine*)","counters":[]},{"line":"    | Sent_invalid_transition_chain_merkle_proof","counters":[]},{"line":"        (** Peer sent us a transition chain witness that does not verify *)","counters":[]},{"line":"    | Violated_protocol  (** Peer violated the specification of the protocol. *)","counters":[]},{"line":"    | Made_request","counters":[]},{"line":"        (** Peer made a valid request. This causes a small decrease to mitigate","counters":[]},{"line":"            DoS. *)","counters":[]},{"line":"    | Connected","counters":[]},{"line":"        (** Peer connected to TCP server. Very small decrease to mitigate DoS *)","counters":[]},{"line":"    | Requested_unknown_item","counters":[]},{"line":"        (** Peer requested something we don't know. They might be ahead of us or","counters":[]},{"line":"          they might be malicious. *)","counters":[]},{"line":"    | Fulfilled_request  (** Peer fulfilled a request we made. *)","counters":[]},{"line":"    | Epoch_ledger_provided  (** Special case of request fulfillment *)","counters":[]},{"line":"    | Sent_useful_gossip","counters":[]},{"line":"        (** Peer sent us a gossip item that we added to our pool*)","counters":[]},{"line":"    | Sent_useless_gossip","counters":[]},{"line":"        (** Peer sent us a gossip item that we rejected from our pool for reasons","counters":[]},{"line":"          that may be innocent. e.g. too low of a fee for a user command, out of","counters":[]},{"line":"          date, etc.","counters":[]},{"line":"      *)","counters":[]},{"line":"    | Sent_old_gossip  (** Peer sent us a gossip item we already knew. *)","counters":[]},{"line":"    | No_reply_from_preferred_peer","counters":[]},{"line":"        (** A peer that should have had the response to a query did not provide it. *)","counters":[]},{"line":"    | Unknown_rpc  (** A peer made an unknown RPC. *)","counters":[]},{"line":"    | Decoding_failed  (** A gossip message could not be decoded. *)","counters":[]},{"line":"  [@@deriving show]","counters":[]},{"line":"","counters":[]},{"line":"  (** The action they took, paired with a message and associated JSON metadata","counters":[]},{"line":"      for logging. *)","counters":[]},{"line":"  type t = action * (string * (string, Yojson.Safe.t) List.Assoc.t) option","counters":[]},{"line":"","counters":[]},{"line":"  let to_trust_response (action, _) =","counters":[]},{"line":"    let open Peer_trust.Trust_response in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    (* FIXME figure out a good value for this *)","counters":[]},{"line":"    let fulfilled_increment = Peer_trust.max_rate 10. in","counters":[]},{"line":"    (* the summed decreases of a connection and request equals","counters":[]},{"line":"       the increase of a fulfilled request *)","counters":[]},{"line":"    let request_increment = 0.90 *. fulfilled_increment in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let connected_increment = 0.10 *. fulfilled_increment in","counters":[]},{"line":"    let epoch_ledger_provided_increment = 10. *. fulfilled_increment in","counters":[]},{"line":"    let old_gossip_increment = Peer_trust.max_rate 20. in","counters":[]},{"line":"    match action with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Gossiped_old_transition (slot_diff, delta) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (* NOTE: slot_diff here is [received_slot - (produced_slot + Δ)]","counters":[]},{"line":"         *","counters":[]},{"line":"         * We want to decrease the score exponentially based on how out of date the transition","counters":[]},{"line":"         * we received was. We would like the base score decrease to be some constant","counters":[]},{"line":"         * [c], and we would like to instantly ban any peers who send us transitions","counters":[]},{"line":"         * received more than [Δ] slots out of date. Therefore, we want some function","counters":[]},{"line":"         * [f] where [f(1) = c] and [f(Δ) >= 2]. We start by fitting an geometric function","counters":[]},{"line":"         * such that [f(Δ) = 2]. [(1/y)x^2] should be [2] when [x] is [Δ], so if we solve for","counters":[]},{"line":"         * [(1/y)Δ^2 = 2], we get [y = Δ^2/2]. Therefore, we can define our function","counters":[]},{"line":"         * [f(x) = (1/(Δ^2/2))x^2]. This does not satisfy [f(1) = c], but since we only constrain","counters":[]},{"line":"         * [f(Δ) >= 2], we can just offset the function by [c] in order to satisfy both constraints,","counters":[]},{"line":"         * giving us [f(x) = (1/(Δ^2/2))x^2 + c].","counters":[]},{"line":"         *)","counters":[]},{"line":"        let c = 0.1 in","counters":[]},{"line":"        (* this delta has not been updated for delta=0. Leaving since this system is off and likely to be replaced*)","counters":[]},{"line":"        let y = (Float.of_int delta ** 2.0) /. 2.0 in","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"        let f x = (1.0 /. y *. (x ** 2.0)) +. c in","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"        Trust_decrease (f (Int64.to_float slot_diff))","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"    | Gossiped_future_transition ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Insta_ban","counters":[]},{"line":"    | Gossiped_invalid_transition ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Insta_ban","counters":[]},{"line":"    | Disconnected_chain ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Insta_ban","counters":[]},{"line":"    | Sent_bad_hash ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Insta_ban","counters":[]},{"line":"    | Sent_invalid_signature ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Insta_ban","counters":[]},{"line":"    | Sent_invalid_transaction ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Insta_ban","counters":[]},{"line":"    | Sent_invalid_proof ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Insta_ban","counters":[]},{"line":"    | Sent_invalid_signature_or_proof ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Insta_ban","counters":[]},{"line":"    | Sent_invalid_protocol_version ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Insta_ban","counters":[]},{"line":"    (* allow nodes to send wrong current protocol version a small number of times *)","counters":[]},{"line":"    | Sent_mismatched_protocol_version ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Trust_decrease 0.25","counters":[]},{"line":"    (*Genesis ledger (and the genesis protocol state) is now a runtime config, so we should ban nodes that are running using a different genesis ledger*)","counters":[]},{"line":"    | Has_invalid_genesis_protocol_state ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Insta_ban","counters":[]},{"line":"    | Sent_invalid_transition_chain_merkle_proof ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Insta_ban","counters":[]},{"line":"    (* incoming and outgoing connection errors can happen due to network","counters":[]},{"line":"       failures, killing the client, or ungraceful shutdown, so we need to be","counters":[]},{"line":"       pretty lenient. *)","counters":[]},{"line":"    | Incoming_connection_error ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Trust_decrease 0.05","counters":[]},{"line":"    | Outgoing_connection_error ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Trust_decrease 0.05","counters":[]},{"line":"    | No_reply_from_preferred_peer ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Trust_decrease 0.05","counters":[]},{"line":"    | Violated_protocol ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Insta_ban","counters":[]},{"line":"    | Made_request ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Trust_decrease request_increment","counters":[]},{"line":"    | Connected ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Trust_decrease connected_increment","counters":[]},{"line":"    | Requested_unknown_item ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Trust_decrease (Peer_trust.max_rate 1.)","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"    | Fulfilled_request ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Trust_increase fulfilled_increment","counters":[]},{"line":"    | Epoch_ledger_provided ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Trust_increase epoch_ledger_provided_increment","counters":[]},{"line":"    (* Processing old gossip is fast, a single lookup in our table, while","counters":[]},{"line":"       processing useless gossip is more expensive since we have to do","counters":[]},{"line":"       validation on it. In expectation, we get every gossipped message","counters":[]},{"line":"       'replication factor' times, which is 8. That ratio applies to individual","counters":[]},{"line":"       peers too, so we give 7x credit for useful gossip than we take away for","counters":[]},{"line":"       old gossip, plus some headroom for normal variance. *)","counters":[]},{"line":"    | Sent_useful_gossip ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Trust_increase (old_gossip_increment *. 10.)","counters":[]},{"line":"    | Sent_useless_gossip ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Trust_decrease (old_gossip_increment *. 3.)","counters":[]},{"line":"    | Sent_old_gossip ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Trust_decrease old_gossip_increment","counters":[]},{"line":"    | Unknown_rpc ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (* TODO: Should do a soft ban of some kind if this happens enough. *)","counters":[]},{"line":"        Trust_decrease 0.05","counters":[]},{"line":"    | Decoding_failed ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Insta_ban","counters":[]},{"line":"","counters":[]},{"line":"  (* Disabling everything except insta-ban *)","counters":[]},{"line":"  let to_trust_response t =","counters":[]},{"line":"    match to_trust_response t with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Insta_ban ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Peer_trust.Trust_response.Insta_ban","counters":[]},{"line":"    | _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Trust_decrease 0.","counters":[]},{"line":"","counters":[]},{"line":"  let to_log : t -> string * (string, Yojson.Safe.t) List.Assoc.t =","counters":[]},{"line":"   fun (action, extra_opt) ->","counters":[]},{"line":"    match extra_opt with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (show_action action, [])","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"    | Some (fmt, metadata) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (sprintf !\"%s (%s)\" (show_action action) fmt, metadata)","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"  let is_reason_for_heartbeat (a, _) =","counters":[]},{"line":"    match a with Sent_useful_gossip | Fulfilled_request -> true | _ -> false","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Banned_status = Banned_status","counters":[]},{"line":"module Peer_status = Peer_status","counters":[]},{"line":"module Peer_trust = Peer_trust.Make (Actions)","counters":[]},{"line":"include Peer_trust","counters":[]},{"line":"","counters":[]},{"line":"let record_envelope_sender :","counters":[]},{"line":"       t","counters":[]},{"line":"    -> Logger.t","counters":[]},{"line":"    -> Network_peer.Envelope.Sender.t","counters":[]},{"line":"    -> Actions.t","counters":[]},{"line":"    -> unit Deferred.t =","counters":[]},{"line":" fun t logger sender action ->","counters":[]},{"line":"  match sender with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | Local ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let action_fmt, action_metadata = Actions.to_log action in","counters":[]},{"line":"      [%log debug]","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"        ~metadata:((\"action\", `String action_fmt) :: action_metadata)","counters":[]},{"line":"        \"Attempted to record trust action of ourselves: $action\" ;","counters":[]},{"line":"      Deferred.unit","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  | Remote peer ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      record t logger peer action","counters":[{"col_start":32,"col_end":32,"count":1}]}]}