{"filename":"src/lib/block_time/intf.ml","lines":[{"line":"module type S = sig","counters":[]},{"line":"  open Async_kernel","counters":[]},{"line":"  open Core_kernel","counters":[]},{"line":"  open Snark_params","counters":[]},{"line":"  open Snark_bits","counters":[]},{"line":"","counters":[]},{"line":"  module Time : sig","counters":[]},{"line":"    type t [@@deriving sexp, compare, yojson]","counters":[]},{"line":"","counters":[]},{"line":"    val zero : t","counters":[]},{"line":"","counters":[]},{"line":"    val max_value : t","counters":[]},{"line":"","counters":[]},{"line":"    include Comparable.S with type t := t","counters":[]},{"line":"","counters":[]},{"line":"    include Hashable.S with type t := t","counters":[]},{"line":"","counters":[]},{"line":"    module Controller : sig","counters":[]},{"line":"      type t [@@deriving sexp, equal, compare]","counters":[]},{"line":"","counters":[]},{"line":"      val create : t -> t","counters":[]},{"line":"","counters":[]},{"line":"      val basic : logger:Logger.t -> t","counters":[]},{"line":"","counters":[]},{"line":"      (** Override the time offset set by the [MINA_TIME_OFFSET] environment","counters":[]},{"line":"          variable for all block time controllers.","counters":[]},{"line":"          [enable_setting_offset] must have been called first, and","counters":[]},{"line":"          [disable_setting_offset] must not have been called, otherwise this","counters":[]},{"line":"          raises a [Failure].","counters":[]},{"line":"      *)","counters":[]},{"line":"      val set_time_offset : Time.Span.t -> unit","counters":[]},{"line":"","counters":[]},{"line":"      (** Get the current time offset, either from the [MINA_TIME_OFFSET]","counters":[]},{"line":"          environment variable, or as last set by [set_time_offset].","counters":[]},{"line":"      *)","counters":[]},{"line":"      val get_time_offset : logger:Logger.t -> Time.Span.t","counters":[]},{"line":"","counters":[]},{"line":"      (** Disallow setting the time offset. This should be run at every","counters":[]},{"line":"          entrypoint which does not explicitly need to update the time offset.","counters":[]},{"line":"      *)","counters":[]},{"line":"      val disable_setting_offset : unit -> unit","counters":[]},{"line":"","counters":[]},{"line":"      (** Allow setting the time offset. This may only be run if","counters":[]},{"line":"          [disable_setting_offset] has not already been called, otherwise it will","counters":[]},{"line":"          raise a [Failure].","counters":[]},{"line":"      *)","counters":[]},{"line":"      val enable_setting_offset : unit -> unit","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    [%%versioned:","counters":[]},{"line":"    module Stable : sig","counters":[]},{"line":"      [@@@no_toplevel_latest_type]","counters":[]},{"line":"","counters":[]},{"line":"      module V1 : sig","counters":[]},{"line":"        type nonrec t = t [@@deriving sexp, compare, equal, hash, yojson]","counters":[]},{"line":"","counters":[]},{"line":"        include Hashable.S with type t := t","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    module Bits : Bits_intf.Convertible_bits with type t := t","counters":[]},{"line":"","counters":[]},{"line":"    include","counters":[]},{"line":"      Tick.Snarkable.Bits.Faithful","counters":[]},{"line":"        with type Unpacked.value = t","counters":[]},{"line":"         and type Packed.value = t","counters":[]},{"line":"         and type Packed.var = private Tick.Field.Var.t","counters":[]},{"line":"","counters":[]},{"line":"    val to_input : t -> Tick.Field.t Random_oracle_input.Chunked.t","counters":[]},{"line":"","counters":[]},{"line":"    module Checked : sig","counters":[]},{"line":"      open Snark_params.Tick","counters":[]},{"line":"","counters":[]},{"line":"      type t","counters":[]},{"line":"","counters":[]},{"line":"      val typ : (t, Stable.Latest.t) Typ.t","counters":[]},{"line":"","counters":[]},{"line":"      val to_input : t -> Field.Var.t Random_oracle_input.Chunked.t","counters":[]},{"line":"","counters":[]},{"line":"      val ( = ) : t -> t -> Boolean.var Checked.t","counters":[]},{"line":"","counters":[]},{"line":"      val ( < ) : t -> t -> Boolean.var Checked.t","counters":[]},{"line":"","counters":[]},{"line":"      val ( > ) : t -> t -> Boolean.var Checked.t","counters":[]},{"line":"","counters":[]},{"line":"      val ( <= ) : t -> t -> Boolean.var Checked.t","counters":[]},{"line":"","counters":[]},{"line":"      val ( >= ) : t -> t -> Boolean.var Checked.t","counters":[]},{"line":"","counters":[]},{"line":"      val to_field : t -> Field.Var.t","counters":[]},{"line":"","counters":[]},{"line":"      module Unsafe : sig","counters":[]},{"line":"        val of_field : Field.Var.t -> t","counters":[]},{"line":"      end","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Span : sig","counters":[]},{"line":"      type t [@@deriving sexp, compare, equal, yojson]","counters":[]},{"line":"","counters":[]},{"line":"      module Stable : sig","counters":[]},{"line":"        module V1 : sig","counters":[]},{"line":"          type nonrec t = t","counters":[]},{"line":"          [@@deriving bin_io, equal, sexp, compare, hash, yojson, version]","counters":[]},{"line":"        end","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      val of_time_span : Time.Span.t -> t","counters":[]},{"line":"","counters":[]},{"line":"      val to_time_span : t -> Time.Span.t","counters":[]},{"line":"","counters":[]},{"line":"      module Bits : Bits_intf.Convertible_bits with type t := t","counters":[]},{"line":"","counters":[]},{"line":"      include","counters":[]},{"line":"        Tick.Snarkable.Bits.Faithful","counters":[]},{"line":"          with type Unpacked.value = t","counters":[]},{"line":"           and type Packed.value = t","counters":[]},{"line":"","counters":[]},{"line":"      val to_time_ns_span : t -> Core_kernel.Time_ns.Span.t","counters":[]},{"line":"","counters":[]},{"line":"      val of_time_ns_span : Core_kernel.Time_ns.Span.t -> t","counters":[]},{"line":"","counters":[]},{"line":"      val to_string_hum : t -> string","counters":[]},{"line":"","counters":[]},{"line":"      val to_ms : t -> Int64.t","counters":[]},{"line":"","counters":[]},{"line":"      val of_ms : Int64.t -> t","counters":[]},{"line":"","counters":[]},{"line":"      val ( + ) : t -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"      val ( - ) : t -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"      val ( * ) : t -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"      val ( < ) : t -> t -> bool","counters":[]},{"line":"","counters":[]},{"line":"      val ( > ) : t -> t -> bool","counters":[]},{"line":"","counters":[]},{"line":"      val ( = ) : t -> t -> bool","counters":[]},{"line":"","counters":[]},{"line":"      val ( <= ) : t -> t -> bool","counters":[]},{"line":"","counters":[]},{"line":"      val ( >= ) : t -> t -> bool","counters":[]},{"line":"","counters":[]},{"line":"      val min : t -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"      val zero : t","counters":[]},{"line":"","counters":[]},{"line":"      val to_input : t -> Tick.Field.t Random_oracle_input.Chunked.t","counters":[]},{"line":"","counters":[]},{"line":"      module Checked : sig","counters":[]},{"line":"        type t","counters":[]},{"line":"","counters":[]},{"line":"        val typ : (t, Stable.V1.t) Snark_params.Tick.Typ.t","counters":[]},{"line":"","counters":[]},{"line":"        open Snark_params.Tick","counters":[]},{"line":"","counters":[]},{"line":"        val to_input : t -> Tick.Field.Var.t Random_oracle_input.Chunked.t","counters":[]},{"line":"","counters":[]},{"line":"        val to_field : t -> Field.Var.t","counters":[]},{"line":"","counters":[]},{"line":"        module Unsafe : sig","counters":[]},{"line":"          val of_field : Field.Var.t -> t","counters":[]},{"line":"        end","counters":[]},{"line":"      end","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    val field_var_to_unpacked : Tick.Field.Var.t -> Unpacked.var Tick.Checked.t","counters":[]},{"line":"","counters":[]},{"line":"    val diff_checked :","counters":[]},{"line":"      Unpacked.var -> Unpacked.var -> Span.Unpacked.var Tick.Checked.t","counters":[]},{"line":"","counters":[]},{"line":"    val unpacked_to_number : Span.Unpacked.var -> Tick.Number.t","counters":[]},{"line":"","counters":[]},{"line":"    val add : t -> Span.t -> t","counters":[]},{"line":"","counters":[]},{"line":"    val diff : t -> t -> Span.t","counters":[]},{"line":"","counters":[]},{"line":"    val sub : t -> Span.t -> t","counters":[]},{"line":"","counters":[]},{"line":"    val to_span_since_epoch : t -> Span.t","counters":[]},{"line":"","counters":[]},{"line":"    val of_span_since_epoch : Span.t -> t","counters":[]},{"line":"","counters":[]},{"line":"    val modulus : t -> Span.t -> Span.t","counters":[]},{"line":"","counters":[]},{"line":"    val of_time : Time.t -> t","counters":[]},{"line":"","counters":[]},{"line":"    val to_time_exn : t -> Time.t","counters":[]},{"line":"","counters":[]},{"line":"    val now : Controller.t -> t","counters":[]},{"line":"","counters":[]},{"line":"    val to_int64 : t -> Int64.t","counters":[]},{"line":"","counters":[]},{"line":"    val of_int64 : Int64.t -> t","counters":[]},{"line":"","counters":[]},{"line":"    val of_uint64 : Unsigned.UInt64.t -> t","counters":[]},{"line":"","counters":[]},{"line":"    val to_uint64 : t -> Unsigned.UInt64.t","counters":[]},{"line":"","counters":[]},{"line":"    val of_time_ns : Time_ns.t -> t","counters":[]},{"line":"","counters":[]},{"line":"    val to_string_exn : t -> string","counters":[]},{"line":"","counters":[]},{"line":"    (** Strip time offset *)","counters":[]},{"line":"    val to_string_system_time_exn : Controller.t -> t -> string","counters":[]},{"line":"","counters":[]},{"line":"    (** Strip time offset *)","counters":[]},{"line":"    val to_system_time : Controller.t -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"    val of_string_exn : string -> t","counters":[]},{"line":"","counters":[]},{"line":"    val gen_incl : t -> t -> t Quickcheck.Generator.t","counters":[]},{"line":"","counters":[]},{"line":"    val gen : t Quickcheck.Generator.t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  include module type of Time with type t = Time.t","counters":[]},{"line":"","counters":[]},{"line":"  module Timeout : sig","counters":[]},{"line":"    type 'a t","counters":[]},{"line":"","counters":[]},{"line":"    type time","counters":[]},{"line":"","counters":[]},{"line":"    val create : Controller.t -> Span.t -> f:(time -> 'a) -> 'a t","counters":[]},{"line":"","counters":[]},{"line":"    val to_deferred : 'a t -> 'a Async_kernel.Deferred.t","counters":[]},{"line":"","counters":[]},{"line":"    val peek : 'a t -> 'a option","counters":[]},{"line":"","counters":[]},{"line":"    val cancel : Controller.t -> 'a t -> 'a -> unit","counters":[]},{"line":"","counters":[]},{"line":"    val remaining_time : 'a t -> Span.t","counters":[]},{"line":"","counters":[]},{"line":"    val await :","counters":[]},{"line":"         timeout_duration:Span.t","counters":[]},{"line":"      -> Controller.t","counters":[]},{"line":"      -> 'a Deferred.t","counters":[]},{"line":"      -> [ `Ok of 'a | `Timeout ] Deferred.t","counters":[]},{"line":"","counters":[]},{"line":"    val await_exn :","counters":[]},{"line":"      timeout_duration:Span.t -> Controller.t -> 'a Deferred.t -> 'a Deferred.t","counters":[]},{"line":"  end","counters":[]},{"line":"  with type time := t","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":1}]}]}