{"filename":"src/lib/mina_block/header.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Mina_base","counters":[]},{"line":"open Mina_state","counters":[]},{"line":"","counters":[]},{"line":"(* CHANGES:","counters":[]},{"line":"   - remove staged ledger diff","counters":[]},{"line":"   - added body reference","counters":[]},{"line":"   - removed mutable validation callback as field in header","counters":[]},{"line":"*)","counters":[]},{"line":"","counters":[]},{"line":"module Wire_types = Mina_wire_types.Mina_block.Header","counters":[]},{"line":"","counters":[]},{"line":"module Make_sig (A : Wire_types.Types.S) = struct","counters":[]},{"line":"  module type S = Header_intf.Full with type Stable.V2.t = A.V2.t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make_str (A : Wire_types.Concrete) = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V2 = struct","counters":[]},{"line":"      type t = A.V2.t =","counters":[{"col_start":6,"col_end":6,"count":2},{"col_start":11,"col_end":11,"count":2}]},{"line":"        { protocol_state : Protocol_state.Value.Stable.V2.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"        ; protocol_state_proof : Proof.Stable.V2.t [@sexp.opaque]","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"        ; delta_block_chain_proof :","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"            (* TODO: abstract *)","counters":[]},{"line":"            State_hash.Stable.V1.t * State_body_hash.Stable.V1.t list","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"        ; current_protocol_version : Protocol_version.Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"        ; proposed_protocol_version_opt : Protocol_version.Stable.V1.t option","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":42,"col_end":42,"count":0},{"col_start":76,"col_end":76,"count":0}]},{"line":"        }","counters":[]},{"line":"      [@@deriving fields, sexp, to_yojson]","counters":[{"col_start":41,"col_end":41,"count":5}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"      module Creatable = struct","counters":[]},{"line":"        let id = \"block_header\"","counters":[]},{"line":"","counters":[]},{"line":"        type nonrec t = t","counters":[]},{"line":"","counters":[]},{"line":"        let sexp_of_t = sexp_of_t","counters":[]},{"line":"","counters":[]},{"line":"        let t_of_sexp = t_of_sexp","counters":[]},{"line":"","counters":[]},{"line":"        type 'a creator =","counters":[]},{"line":"             protocol_state:Protocol_state.Value.t","counters":[]},{"line":"          -> protocol_state_proof:Proof.t","counters":[]},{"line":"          -> delta_block_chain_proof:State_hash.t * State_body_hash.t list","counters":[]},{"line":"          -> ?proposed_protocol_version_opt:Protocol_version.t","counters":[]},{"line":"          -> ?current_protocol_version:Protocol_version.t","counters":[]},{"line":"          -> unit","counters":[]},{"line":"          -> 'a","counters":[]},{"line":"","counters":[]},{"line":"        let map_creator c ~f ~protocol_state ~protocol_state_proof","counters":[]},{"line":"            ~delta_block_chain_proof ?proposed_protocol_version_opt","counters":[]},{"line":"            ?current_protocol_version () =","counters":[]},{"line":"          f","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (c ~protocol_state ~protocol_state_proof ~delta_block_chain_proof","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"               ?proposed_protocol_version_opt ?current_protocol_version () )","counters":[]},{"line":"","counters":[]},{"line":"        let create ~protocol_state ~protocol_state_proof","counters":[]},{"line":"            ~delta_block_chain_proof ?proposed_protocol_version_opt","counters":[]},{"line":"            ?current_protocol_version () =","counters":[]},{"line":"          let cur_ver_fun =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Option.(bind current_protocol_version ~f:(Fn.compose return const))","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"          in","counters":[]},{"line":"          let cur_ver_fallback () =","counters":[]},{"line":"            try Protocol_version.get_current ()","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"            with _ ->","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"              failwith","counters":[]},{"line":"                \"Cannot create block header before setting current protocol \\","counters":[]},{"line":"                 version\"","counters":[]},{"line":"          in","counters":[]},{"line":"          { protocol_state","counters":[]},{"line":"          ; protocol_state_proof","counters":[]},{"line":"          ; delta_block_chain_proof","counters":[]},{"line":"          ; current_protocol_version =","counters":[]},{"line":"              Option.value ~default:cur_ver_fallback cur_ver_fun ()","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"          ; proposed_protocol_version_opt","counters":[]},{"line":"          }","counters":[]},{"line":"      end","counters":[]},{"line":"","counters":[]},{"line":"      include (","counters":[]},{"line":"        Allocation_functor.Make.Basic","counters":[]},{"line":"          (Creatable) :","counters":[]},{"line":"            Allocation_functor.Intf.Output.Basic_intf","counters":[]},{"line":"              with type t := t","counters":[]},{"line":"               and type 'a creator := 'a Creatable.creator )","counters":[]},{"line":"","counters":[]},{"line":"      include (","counters":[]},{"line":"        Allocation_functor.Make.Sexp","counters":[]},{"line":"          (Creatable) :","counters":[]},{"line":"            Allocation_functor.Intf.Output.Sexp_intf","counters":[]},{"line":"              with type t := t","counters":[]},{"line":"               and type 'a creator := 'a Creatable.creator )","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  [%%define_locally","counters":[]},{"line":"  Stable.Latest.","counters":[]},{"line":"    ( protocol_state","counters":[]},{"line":"    , protocol_state_proof","counters":[]},{"line":"    , delta_block_chain_proof","counters":[]},{"line":"    , current_protocol_version","counters":[]},{"line":"    , proposed_protocol_version_opt","counters":[]},{"line":"    , create","counters":[]},{"line":"    , sexp_of_t","counters":[]},{"line":"    , t_of_sexp","counters":[]},{"line":"    , to_yojson )]","counters":[]},{"line":"","counters":[]},{"line":"  type protocol_version_status =","counters":[]},{"line":"    { valid_current : bool; valid_next : bool; matches_daemon : bool }","counters":[]},{"line":"","counters":[]},{"line":"  let protocol_version_status body =","counters":[]},{"line":"    let valid_current =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Protocol_version.is_valid (current_protocol_version body)","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"    in","counters":[]},{"line":"    let valid_next =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Option.for_all","counters":[]},{"line":"        (proposed_protocol_version_opt body)","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"        ~f:Protocol_version.is_valid","counters":[]},{"line":"    in","counters":[]},{"line":"    let matches_daemon =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Protocol_version.compatible_with_daemon (current_protocol_version body)","counters":[{"col_start":70,"col_end":70,"count":0}]},{"line":"    in","counters":[]},{"line":"    { valid_current; valid_next; matches_daemon }","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"include Wire_types.Make (Make_sig) (Make_str)","counters":[{"col_start":44,"col_end":44,"count":2}]}]}