{"filename":"src/staged_ledger/staged_ledger.rs","lines":[{"line":"use std::collections::{HashMap, HashSet};","counters":[]},{"line":"","counters":[]},{"line":"use mina_hasher::Fp;","counters":[]},{"line":"use mina_p2p_messages::v2::MinaStateProtocolStateValueStableV2;","counters":[]},{"line":"use mina_signer::CompressedPubKey;","counters":[]},{"line":"","counters":[]},{"line":"use crate::{","counters":[]},{"line":"    decompress_pk,","counters":[]},{"line":"    scan_state::{","counters":[]},{"line":"        self,","counters":[]},{"line":"        currency::{Amount, Magnitude, Slot},","counters":[]},{"line":"        fee_excess::FeeExcess,","counters":[]},{"line":"        pending_coinbase::{","counters":[]},{"line":"            update::{Action, StackUpdate, Update},","counters":[]},{"line":"            PendingCoinbase, Stack, StackState,","counters":[]},{"line":"        },","counters":[]},{"line":"        scan_state::{","counters":[]},{"line":"            transaction_snark::{","counters":[]},{"line":"                work, InitStack, LedgerHash, LedgerProof, LedgerProofWithSokMessage, OneOrTwo,","counters":[]},{"line":"                Registers, SokMessage, Statement, TransactionWithWitness,","counters":[]},{"line":"            },","counters":[]},{"line":"            AvailableJob, ConstraintConstants, ScanState, SpacePartition, StatementCheck,","counters":[]},{"line":"        },","counters":[]},{"line":"        snark_work::spec,","counters":[]},{"line":"        transaction_logic::{","counters":[]},{"line":"            apply_transaction,","counters":[]},{"line":"            local_state::LocalState,","counters":[]},{"line":"            protocol_state::{protocol_state_view, ProtocolStateView},","counters":[]},{"line":"            transaction_applied::TransactionApplied,","counters":[]},{"line":"            valid::{self, VerificationKeyHash},","counters":[]},{"line":"            verifiable,","counters":[]},{"line":"            zkapp_command::Control,","counters":[]},{"line":"            CoinbaseFeeTransfer, Transaction, TransactionStatus, UserCommand, WithStatus,","counters":[]},{"line":"        },","counters":[]},{"line":"    },","counters":[]},{"line":"    split_at, split_at_vec,","counters":[]},{"line":"    staged_ledger::{pre_diff_info, resources::IncreaseBy},","counters":[]},{"line":"    verifier::{Verifier, VerifierError},","counters":[]},{"line":"    Account, AccountId, BaseLedger, Mask, TokenId,","counters":[]},{"line":"};","counters":[]},{"line":"","counters":[]},{"line":"use super::{","counters":[]},{"line":"    diff::{with_valid_signatures_and_proofs, AtMostOne, AtMostTwo, Diff, PreDiffTwo},","counters":[]},{"line":"    diff_creation_log::{DiffCreationLog, Partition},","counters":[]},{"line":"    hash::StagedLedgerHash,","counters":[]},{"line":"    pre_diff_info::PreDiffError,","counters":[]},{"line":"    resources::Resources,","counters":[]},{"line":"    sparse_ledger::SparseLedger,","counters":[]},{"line":"    transaction_validator::HashlessLedger,","counters":[]},{"line":"};","counters":[]},{"line":"","counters":[]},{"line":"/// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/staged_ledger/staged_ledger.ml#470","counters":[]},{"line":"#[derive(Clone, Debug)]","counters":[{"col_start":16,"col_end":21,"count":0}]},{"line":"pub struct StackStateWithInitStack {","counters":[]},{"line":"    pub pc: StackState,","counters":[]},{"line":"    pub init_stack: Stack,","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"// pub enum PreDiffError {","counters":[]},{"line":"//     CoinbaseError(&'static str),","counters":[]},{"line":"// }","counters":[]},{"line":"","counters":[]},{"line":"/// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/staged_ledger/staged_ledger.ml#L23","counters":[]},{"line":"#[derive(Debug)]","counters":[{"col_start":9,"col_end":10,"count":0},{"col_start":13,"col_end":14,"count":0}]},{"line":"pub enum StagedLedgerError {","counters":[]},{"line":"    NonZeroFeeExcess(Vec<WithStatus<Transaction>>, SpacePartition),","counters":[]},{"line":"    InvalidProofs,","counters":[]},{"line":"    CouldntReachVerifier,","counters":[]},{"line":"    PreDiff(PreDiffError),","counters":[]},{"line":"    InsufficientWork(String),","counters":[]},{"line":"    MismatchedStatuses {","counters":[]},{"line":"        transaction: WithStatus<Transaction>,","counters":[]},{"line":"        got: TransactionStatus,","counters":[]},{"line":"    },","counters":[]},{"line":"    InvalidPublicKey(CompressedPubKey),","counters":[]},{"line":"    Unexpected(String),","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl From<String> for StagedLedgerError {","counters":[]},{"line":"    fn from(value: String) -> Self {","counters":[{"col_start":4,"col_end":36,"count":4}]},{"line":"        Self::Unexpected(value)","counters":[{"col_start":0,"col_end":31,"count":4}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":4}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl From<PreDiffError> for StagedLedgerError {","counters":[]},{"line":"    fn from(value: PreDiffError) -> Self {","counters":[{"col_start":4,"col_end":42,"count":1}]},{"line":"        Self::PreDiff(value)","counters":[{"col_start":0,"col_end":28,"count":1}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":1}]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"// module Staged_ledger_error = struct","counters":[]},{"line":"//   type t =","counters":[]},{"line":"//     | Non_zero_fee_excess of","counters":[]},{"line":"//         Scan_state.Space_partition.t * Transaction.t With_status.t list","counters":[]},{"line":"//     | Invalid_proofs of","counters":[]},{"line":"//         ( Ledger_proof.t","counters":[]},{"line":"//         * Transaction_snark.Statement.t","counters":[]},{"line":"//         * Mina_base.Sok_message.t )","counters":[]},{"line":"//         list","counters":[]},{"line":"//     | Couldn't_reach_verifier of Error.t","counters":[]},{"line":"//     | Pre_diff of Pre_diff_info.Error.t","counters":[]},{"line":"//     | Insufficient_work of string","counters":[]},{"line":"//     | Mismatched_statuses of","counters":[]},{"line":"//         Transaction.t With_status.t * Transaction_status.t","counters":[]},{"line":"//     | Invalid_public_key of Public_key.Compressed.t","counters":[]},{"line":"//     | Unexpected of Error.t","counters":[]},{"line":"//   [@@deriving sexp]","counters":[]},{"line":"","counters":[]},{"line":"#[derive(Debug)]","counters":[{"col_start":9,"col_end":14,"count":0}]},{"line":"struct DiffResult {","counters":[]},{"line":"    hash_after_applying: StagedLedgerHash,","counters":[]},{"line":"    ledger_proof: Option<(LedgerProof, Vec<(WithStatus<Transaction>, Fp)>)>,","counters":[]},{"line":"    pending_coinbase_update: (bool, Update),","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"enum SkipVerification {","counters":[]},{"line":"    All,","counters":[]},{"line":"    Proofs,","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"pub struct StagedLedger {","counters":[]},{"line":"    scan_state: ScanState,","counters":[]},{"line":"    ledger: Mask,","counters":[]},{"line":"    constraint_constants: ConstraintConstants,","counters":[]},{"line":"    pending_coinbase_collection: PendingCoinbase,","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"impl StagedLedger {","counters":[]},{"line":"    pub fn proof_txns_with_state_hashes(&self) -> Option<Vec<(WithStatus<Transaction>, Fp)>> {","counters":[{"col_start":4,"col_end":94,"count":4}]},{"line":"        self.scan_state.latest_ledger_proof().map(|(_, list)| list)","counters":[{"col_start":0,"col_end":50,"count":4},{"col_start":62,"col_end":66,"count":0},{"col_start":66,"col_end":67,"count":4}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":4}]},{"line":"","counters":[]},{"line":"    pub fn scan_state(&self) -> &ScanState {","counters":[{"col_start":4,"col_end":44,"count":0}]},{"line":"        &self.scan_state","counters":[{"col_start":0,"col_end":24,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn all_work_pairs<F>(&self, get_state: F) -> Result<Vec<OneOrTwo<spec::Work>>, String>","counters":[]},{"line":"    where","counters":[]},{"line":"        F: Fn(&Fp) -> &MinaStateProtocolStateValueStableV2,","counters":[]},{"line":"    {","counters":[]},{"line":"        self.scan_state.all_work_pairs(get_state)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn all_work_statements_exn(&self) -> Vec<work::Statement> {","counters":[]},{"line":"        self.scan_state.all_work_statements_exn()","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    pub fn pending_coinbase_collection(&self) -> &PendingCoinbase {","counters":[{"col_start":4,"col_end":67,"count":0}]},{"line":"        &self.pending_coinbase_collection","counters":[{"col_start":0,"col_end":41,"count":0}]},{"line":"    }","counters":[{"col_start":0,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    fn get_target(","counters":[]},{"line":"        (proof_with_msg, _): (","counters":[]},{"line":"            &LedgerProofWithSokMessage,","counters":[]},{"line":"            Vec<(WithStatus<Transaction>, Fp)>,","counters":[]},{"line":"        ),","counters":[]},{"line":"    ) -> &Registers {","counters":[]},{"line":"        &proof_with_msg.proof.statement_ref().target","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn verify_scan_state_after_apply(","counters":[]},{"line":"        constraint_constants: &ConstraintConstants,","counters":[]},{"line":"        pending_coinbase_stack: Stack,","counters":[]},{"line":"        ledger: LedgerHash,","counters":[]},{"line":"        scan_state: &ScanState,","counters":[]},{"line":"    ) -> Result<(), String> {","counters":[]},{"line":"        let registers_end = Registers {","counters":[]},{"line":"            ledger,","counters":[]},{"line":"            pending_coinbase_stack,","counters":[]},{"line":"            local_state: LocalState::empty(),","counters":[]},{"line":"        };","counters":[]},{"line":"        let statement_check = StatementCheck::Partial;","counters":[]},{"line":"        let registers_begin = scan_state.latest_ledger_proof().map(Self::get_target);","counters":[]},{"line":"","counters":[]},{"line":"        scan_state.check_invariants(","counters":[]},{"line":"            constraint_constants,","counters":[]},{"line":"            statement_check,","counters":[]},{"line":"            &Verifier,","counters":[]},{"line":"            \"Error verifying the parallel scan state after applying the diff.\",","counters":[]},{"line":"            registers_begin,","counters":[]},{"line":"            registers_end,","counters":[]},{"line":"        )","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn of_scan_state_and_ledger<F>(","counters":[]},{"line":"        _logger: (),","counters":[]},{"line":"        constraint_constants: &ConstraintConstants,","counters":[]},{"line":"        verifier: Verifier,","counters":[]},{"line":"        snarked_registers: Registers,","counters":[]},{"line":"        mut ledger: Mask,","counters":[]},{"line":"        scan_state: ScanState,","counters":[]},{"line":"        pending_coinbase_collection: PendingCoinbase,","counters":[]},{"line":"        get_state: F,","counters":[]},{"line":"    ) -> Result<Self, String>","counters":[]},{"line":"    where","counters":[]},{"line":"        F: Fn(&Fp) -> &MinaStateProtocolStateValueStableV2 + 'static,","counters":[]},{"line":"    {","counters":[]},{"line":"        let pending_coinbase_stack = pending_coinbase_collection.latest_stack(false);","counters":[]},{"line":"","counters":[]},{"line":"        scan_state.check_invariants(","counters":[]},{"line":"            constraint_constants,","counters":[]},{"line":"            StatementCheck::Full(Box::new(get_state)),","counters":[]},{"line":"            &verifier,","counters":[]},{"line":"            \"Staged_ledger.of_scan_state_and_ledger\",","counters":[]},{"line":"            Some(&snarked_registers),","counters":[]},{"line":"            Registers {","counters":[]},{"line":"                ledger: ledger.merkle_root(),","counters":[]},{"line":"                pending_coinbase_stack,","counters":[]},{"line":"                local_state: LocalState::empty(),","counters":[]},{"line":"            },","counters":[]},{"line":"        )?;","counters":[]},{"line":"","counters":[]},{"line":"        Ok(Self {","counters":[]},{"line":"            scan_state,","counters":[]},{"line":"            ledger,","counters":[]},{"line":"            constraint_constants: constraint_constants.clone(),","counters":[]},{"line":"            pending_coinbase_collection,","counters":[]},{"line":"        })","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/staged_ledger/staged_ledger.ml#L292","counters":[]},{"line":"    fn of_scan_state_and_ledger_unchecked(","counters":[]},{"line":"        constraint_constants: &ConstraintConstants,","counters":[]},{"line":"        snarked_registers: Registers,","counters":[]},{"line":"        mut ledger: Mask,","counters":[]},{"line":"        scan_state: ScanState,","counters":[]},{"line":"        pending_coinbase_collection: PendingCoinbase,","counters":[]},{"line":"    ) -> Result<Self, String> {","counters":[]},{"line":"        let pending_coinbase_stack = pending_coinbase_collection.latest_stack(false);","counters":[]},{"line":"","counters":[]},{"line":"        scan_state.check_invariants(","counters":[]},{"line":"            constraint_constants,","counters":[]},{"line":"            StatementCheck::Partial,","counters":[]},{"line":"            &Verifier, // null","counters":[]},{"line":"            \"Staged_ledger.of_scan_state_and_ledger\",","counters":[]},{"line":"            Some(&snarked_registers),","counters":[]},{"line":"            Registers {","counters":[]},{"line":"                ledger: ledger.merkle_root(),","counters":[]},{"line":"                pending_coinbase_stack,","counters":[]},{"line":"                local_state: LocalState::empty(),","counters":[]},{"line":"            },","counters":[]},{"line":"        )?;","counters":[]},{"line":"","counters":[]},{"line":"        Ok(Self {","counters":[]},{"line":"            scan_state,","counters":[]},{"line":"            ledger,","counters":[]},{"line":"            constraint_constants: constraint_constants.clone(),","counters":[]},{"line":"            pending_coinbase_collection,","counters":[]},{"line":"        })","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/staged_ledger/staged_ledger.ml#L318","counters":[]},{"line":"    fn of_scan_state_pending_coinbases_and_snarked_ledger_prime<F, G>(","counters":[]},{"line":"        constraint_constants: &ConstraintConstants,","counters":[]},{"line":"        pending_coinbase: PendingCoinbase,","counters":[]},{"line":"        scan_state: ScanState,","counters":[]},{"line":"        mut snarked_ledger: Mask,","counters":[]},{"line":"        snarked_local_state: LocalState,","counters":[]},{"line":"        expected_merkle_root: LedgerHash,","counters":[]},{"line":"        get_state: F,","counters":[]},{"line":"        fun: G,","counters":[]},{"line":"    ) -> Result<Self, String>","counters":[]},{"line":"    where","counters":[]},{"line":"        F: Fn(&Fp) -> &MinaStateProtocolStateValueStableV2 + 'static,","counters":[]},{"line":"        G: FnOnce(","counters":[]},{"line":"            &ConstraintConstants,","counters":[]},{"line":"            Registers,","counters":[]},{"line":"            Mask,","counters":[]},{"line":"            ScanState,","counters":[]},{"line":"            PendingCoinbase,","counters":[]},{"line":"        ) -> Result<Self, String>,","counters":[]},{"line":"    {","counters":[]},{"line":"        let snarked_ledger_hash = snarked_ledger.merkle_root();","counters":[]},{"line":"        let snarked_frozen_ledger_hash = snarked_ledger_hash;","counters":[]},{"line":"","counters":[]},{"line":"        let txs_with_protocol_state =","counters":[]},{"line":"            scan_state.staged_transactions_with_protocol_states(get_state);","counters":[]},{"line":"","counters":[]},{"line":"        for (tx, protocol_state) in txs_with_protocol_state {","counters":[]},{"line":"            let txn_with_info = apply_transaction(","counters":[]},{"line":"                constraint_constants,","counters":[]},{"line":"                &protocol_state_view(&protocol_state),","counters":[]},{"line":"                &mut snarked_ledger,","counters":[]},{"line":"                &tx.data,","counters":[]},{"line":"            )?;","counters":[]},{"line":"","counters":[]},{"line":"            let computed_status = txn_with_info.transaction_status();","counters":[]},{"line":"","counters":[]},{"line":"            if &tx.status != computed_status {","counters":[]},{"line":"                return Err(format!(","counters":[]},{"line":"                    \"Mismatched user command status. Expected: {:#?} Got: {:#?}\",","counters":[]},{"line":"                    tx.status, computed_status","counters":[]},{"line":"                ));","counters":[]},{"line":"            }","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        let staged_ledger_hash = snarked_ledger.merkle_root();","counters":[]},{"line":"        if staged_ledger_hash != expected_merkle_root {","counters":[]},{"line":"            return Err(format!(","counters":[]},{"line":"                \"Mismatching merkle root Expected:{:?} Got:{:?}\",","counters":[]},{"line":"                expected_merkle_root.to_string(),","counters":[]},{"line":"                staged_ledger_hash.to_string()","counters":[]},{"line":"            ));","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        let pending_coinbase_stack = match scan_state.latest_ledger_proof() {","counters":[]},{"line":"            Some(proof) => Self::get_target(proof).pending_coinbase_stack.clone(),","counters":[]},{"line":"            None => Stack::empty(),","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        fun(","counters":[]},{"line":"            constraint_constants,","counters":[]},{"line":"            Registers {","counters":[]},{"line":"                ledger: snarked_frozen_ledger_hash,","counters":[]},{"line":"                pending_coinbase_stack,","counters":[]},{"line":"                local_state: snarked_local_state,","counters":[]},{"line":"            },","counters":[]},{"line":"            snarked_ledger,","counters":[]},{"line":"            scan_state,","counters":[]},{"line":"            pending_coinbase,","counters":[]},{"line":"        )","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/staged_ledger/staged_ledger.ml#L378","counters":[]},{"line":"    fn of_scan_state_pending_coinbases_and_snarked_ledger<F>(","counters":[]},{"line":"        logger: (),","counters":[]},{"line":"        constraint_constants: &ConstraintConstants,","counters":[]},{"line":"        verifier: Verifier,","counters":[]},{"line":"        scan_state: ScanState,","counters":[]},{"line":"        snarked_ledger: Mask,","counters":[]},{"line":"        snarked_local_state: LocalState,","counters":[]},{"line":"        expected_merkle_root: LedgerHash,","counters":[]},{"line":"        pending_coinbase: PendingCoinbase,","counters":[]},{"line":"        get_state: F,","counters":[]},{"line":"    ) -> Result<Self, String>","counters":[]},{"line":"    where","counters":[]},{"line":"        F: Fn(&Fp) -> &MinaStateProtocolStateValueStableV2 + Copy + 'static,","counters":[]},{"line":"    {","counters":[]},{"line":"        Self::of_scan_state_pending_coinbases_and_snarked_ledger_prime(","counters":[]},{"line":"            constraint_constants,","counters":[]},{"line":"            pending_coinbase,","counters":[]},{"line":"            scan_state,","counters":[]},{"line":"            snarked_ledger,","counters":[]},{"line":"            snarked_local_state,","counters":[]},{"line":"            expected_merkle_root,","counters":[]},{"line":"            get_state,","counters":[]},{"line":"            |constraint_constants,","counters":[]},{"line":"             snarked_registers,","counters":[]},{"line":"             ledger,","counters":[]},{"line":"             scan_state,","counters":[]},{"line":"             pending_coinbase_collection| {","counters":[]},{"line":"                Self::of_scan_state_and_ledger(","counters":[]},{"line":"                    logger,","counters":[]},{"line":"                    constraint_constants,","counters":[]},{"line":"                    verifier,","counters":[]},{"line":"                    snarked_registers,","counters":[]},{"line":"                    ledger,","counters":[]},{"line":"                    scan_state,","counters":[]},{"line":"                    pending_coinbase_collection,","counters":[]},{"line":"                    get_state,","counters":[]},{"line":"                )","counters":[]},{"line":"            },","counters":[]},{"line":"        )","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/staged_ledger/staged_ledger.ml#L386","counters":[]},{"line":"    fn of_scan_state_pending_coinbases_and_snarked_ledger_unchecked<F>(","counters":[]},{"line":"        constraint_constants: &ConstraintConstants,","counters":[]},{"line":"        scan_state: ScanState,","counters":[]},{"line":"        snarked_ledger: Mask,","counters":[]},{"line":"        snarked_local_state: LocalState,","counters":[]},{"line":"        expected_merkle_root: LedgerHash,","counters":[]},{"line":"        pending_coinbase: PendingCoinbase,","counters":[]},{"line":"        get_state: F,","counters":[]},{"line":"    ) -> Result<Self, String>","counters":[]},{"line":"    where","counters":[]},{"line":"        F: Fn(&Fp) -> &MinaStateProtocolStateValueStableV2 + 'static,","counters":[]},{"line":"    {","counters":[]},{"line":"        Self::of_scan_state_pending_coinbases_and_snarked_ledger_prime(","counters":[]},{"line":"            constraint_constants,","counters":[]},{"line":"            pending_coinbase,","counters":[]},{"line":"            scan_state,","counters":[]},{"line":"            snarked_ledger,","counters":[]},{"line":"            snarked_local_state,","counters":[]},{"line":"            expected_merkle_root,","counters":[]},{"line":"            get_state,","counters":[]},{"line":"            Self::of_scan_state_and_ledger_unchecked,","counters":[]},{"line":"        )","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/staged_ledger/staged_ledger.ml#L393","counters":[]},{"line":"    fn copy(&self) -> Self {","counters":[]},{"line":"        let new_mask = self.ledger.make_child();","counters":[]},{"line":"","counters":[]},{"line":"        Self {","counters":[]},{"line":"            scan_state: self.scan_state.clone(), // TODO: Not sure if OCaml keeps the same pointer","counters":[]},{"line":"            ledger: new_mask,","counters":[]},{"line":"            constraint_constants: self.constraint_constants.clone(),","counters":[]},{"line":"            pending_coinbase_collection: self.pending_coinbase_collection.clone(), // TODO: Not sure if OCaml keeps the same pointer","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/staged_ledger/staged_ledger.ml#403","counters":[]},{"line":"    fn hash(&mut self) -> StagedLedgerHash {","counters":[]},{"line":"        StagedLedgerHash::of_aux_ledger_and_coinbase_hash(","counters":[]},{"line":"            self.scan_state.hash(),","counters":[]},{"line":"            self.ledger.merkle_root(),","counters":[]},{"line":"            &mut self.pending_coinbase_collection,","counters":[]},{"line":"        )","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/staged_ledger/staged_ledger.ml#422","counters":[]},{"line":"    fn ledger(&self) -> Mask {","counters":[]},{"line":"        self.ledger.clone()","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/staged_ledger/staged_ledger.ml#424","counters":[]},{"line":"    fn create_exn(constraint_constants: ConstraintConstants, ledger: Mask) -> Result<Self, String> {","counters":[]},{"line":"        let pending_coinbase_depth = constraint_constants.pending_coinbase_depth as usize;","counters":[]},{"line":"","counters":[]},{"line":"        Ok(Self {","counters":[]},{"line":"            scan_state: ScanState::empty(&constraint_constants),","counters":[]},{"line":"            ledger,","counters":[]},{"line":"            constraint_constants,","counters":[]},{"line":"            pending_coinbase_collection: PendingCoinbase::create(pending_coinbase_depth),","counters":[]},{"line":"        })","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/staged_ledger/staged_ledger.ml#434","counters":[]},{"line":"    fn current_ledger_proof(&self) -> Option<&LedgerProofWithSokMessage> {","counters":[]},{"line":"        self.scan_state.latest_ledger_proof().map(|(f, _)| f)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/staged_ledger/staged_ledger.ml#439","counters":[]},{"line":"    fn replace_ledger_exn(&mut self, mut ledger: Mask) {","counters":[]},{"line":"        assert_eq!(","counters":[]},{"line":"            ledger.merkle_root(),","counters":[]},{"line":"            self.ledger.merkle_root(),","counters":[]},{"line":"            \"Cannot replace ledger since merkle_root differs\"","counters":[]},{"line":"        );","counters":[]},{"line":"        self.ledger = ledger;","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/staged_ledger/staged_ledger.ml#456","counters":[]},{"line":"    fn working_stack(","counters":[]},{"line":"        pending_coinbase_collection: &PendingCoinbase,","counters":[]},{"line":"        is_new_stack: bool,","counters":[]},{"line":"    ) -> Result<Stack, String> {","counters":[]},{"line":"        Ok(pending_coinbase_collection.latest_stack(is_new_stack))","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/staged_ledger/staged_ledger.ml#460","counters":[]},{"line":"    fn push_coinbase(current_stack: Stack, transaction: &Transaction) -> Stack {","counters":[]},{"line":"        match transaction {","counters":[]},{"line":"            Transaction::Coinbase(c) => current_stack.push_coinbase(c.clone()),","counters":[]},{"line":"            _ => current_stack,","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/staged_ledger/staged_ledger.ml#467","counters":[]},{"line":"    fn push_state(current_stack: Stack, state_body_hash: Fp) -> Stack {","counters":[]},{"line":"        current_stack.push_state(state_body_hash)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/staged_ledger/staged_ledger.ml#477","counters":[]},{"line":"    pub fn coinbase_amount(","counters":[{"col_start":4,"col_end":27,"count":0}]},{"line":"        supercharge_coinbase: bool,","counters":[{"col_start":0,"col_end":35,"count":0}]},{"line":"        constraint_constants: &ConstraintConstants,","counters":[{"col_start":0,"col_end":51,"count":0}]},{"line":"    ) -> Option<Amount> {","counters":[{"col_start":0,"col_end":25,"count":0}]},{"line":"        if supercharge_coinbase {","counters":[{"col_start":0,"col_end":31,"count":0}]},{"line":"            constraint_constants","counters":[{"col_start":12,"col_end":32,"count":0}]},{"line":"                .coinbase_amount","counters":[{"col_start":0,"col_end":32,"count":0}]},{"line":"                .scale(constraint_constants.supercharged_coinbase_factor)","counters":[{"col_start":0,"col_end":73,"count":0}]},{"line":"        } else {","counters":[]},{"line":"            Some(constraint_constants.coinbase_amount)","counters":[{"col_start":12,"col_end":54,"count":0}]},{"line":"        }","counters":[]},{"line":"    }","counters":[{"col_start":4,"col_end":5,"count":0}]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/staged_ledger/staged_ledger.ml#501","counters":[]},{"line":"    fn apply_transaction_and_get_statement(","counters":[]},{"line":"        constraint_constants: &ConstraintConstants,","counters":[]},{"line":"        mut ledger: Mask,","counters":[]},{"line":"        pending_coinbase_stack_state: StackStateWithInitStack,","counters":[]},{"line":"        transaction: &Transaction,","counters":[]},{"line":"        txn_state_view: &ProtocolStateView,","counters":[]},{"line":"    ) -> Result<(TransactionApplied, Statement<()>, StackStateWithInitStack), StagedLedgerError>","counters":[]},{"line":"    {","counters":[]},{"line":"        let fee_excess = transaction.fee_excess()?;","counters":[]},{"line":"","counters":[]},{"line":"        let source_merkle_root = ledger.merkle_root();","counters":[]},{"line":"","counters":[]},{"line":"        let pending_coinbase_target =","counters":[]},{"line":"            Self::push_coinbase(pending_coinbase_stack_state.pc.target, transaction);","counters":[]},{"line":"","counters":[]},{"line":"        let new_init_stack =","counters":[]},{"line":"            Self::push_coinbase(pending_coinbase_stack_state.init_stack, transaction);","counters":[]},{"line":"","counters":[]},{"line":"        let empty_local_state = LocalState::empty();","counters":[]},{"line":"","counters":[]},{"line":"        let applied_txn = apply_transaction(","counters":[]},{"line":"            constraint_constants,","counters":[]},{"line":"            txn_state_view,","counters":[]},{"line":"            &mut ledger,","counters":[]},{"line":"            transaction,","counters":[]},{"line":"        )","counters":[]},{"line":"        .map_err(|e| format!(\"Error when applying transaction: {:?}\", e))?;","counters":[]},{"line":"","counters":[]},{"line":"        let supply_increase = applied_txn.supply_increase(constraint_constants)?;","counters":[]},{"line":"","counters":[]},{"line":"        let target_merkle_root = ledger.merkle_root();","counters":[]},{"line":"","counters":[]},{"line":"        let statement = Statement {","counters":[]},{"line":"            source: Registers {","counters":[]},{"line":"                ledger: source_merkle_root,","counters":[]},{"line":"                pending_coinbase_stack: pending_coinbase_stack_state.pc.source,","counters":[]},{"line":"                local_state: empty_local_state.clone(),","counters":[]},{"line":"            },","counters":[]},{"line":"            target: Registers {","counters":[]},{"line":"                ledger: target_merkle_root,","counters":[]},{"line":"                pending_coinbase_stack: pending_coinbase_target.clone(),","counters":[]},{"line":"                local_state: empty_local_state,","counters":[]},{"line":"            },","counters":[]},{"line":"            supply_increase,","counters":[]},{"line":"            fee_excess,","counters":[]},{"line":"            sok_digest: (),","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        let state = StackStateWithInitStack {","counters":[]},{"line":"            pc: StackState {","counters":[]},{"line":"                source: pending_coinbase_target.clone(),","counters":[]},{"line":"                target: pending_coinbase_target,","counters":[]},{"line":"            },","counters":[]},{"line":"            init_stack: new_init_stack,","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        Ok((applied_txn, statement, state))","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/staged_ledger/staged_ledger.ml#L560","counters":[]},{"line":"    fn apply_transaction_and_get_witness(","counters":[]},{"line":"        constraint_constants: &ConstraintConstants,","counters":[]},{"line":"        ledger: Mask,","counters":[]},{"line":"        pending_coinbase_stack_state: &StackStateWithInitStack,","counters":[]},{"line":"        transaction: &Transaction,","counters":[]},{"line":"        status: Option<&TransactionStatus>,","counters":[]},{"line":"        txn_state_view: &ProtocolStateView,","counters":[]},{"line":"        state_and_body_hash: (Fp, Fp),","counters":[]},{"line":"    ) -> Result<(TransactionWithWitness, StackStateWithInitStack), StagedLedgerError> {","counters":[]},{"line":"        let account_ids = |transaction: &Transaction| -> Vec<AccountId> {","counters":[]},{"line":"            match transaction {","counters":[]},{"line":"                Transaction::Command(cmd) => cmd.accounts_referenced(),","counters":[]},{"line":"                Transaction::FeeTransfer(t) => t.receivers().collect(),","counters":[]},{"line":"                Transaction::Coinbase(c) => {","counters":[]},{"line":"                    let mut ids = Vec::with_capacity(2);","counters":[]},{"line":"","counters":[]},{"line":"                    ids.push(AccountId::new(c.receiver.clone(), TokenId::default()));","counters":[]},{"line":"                    if let Some(t) = c.fee_transfer.as_ref() {","counters":[]},{"line":"                        ids.push(t.receiver());","counters":[]},{"line":"                    };","counters":[]},{"line":"","counters":[]},{"line":"                    ids","counters":[]},{"line":"                }","counters":[]},{"line":"            }","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        let ledger_witness =","counters":[]},{"line":"            SparseLedger::of_ledger_subset_exn(ledger.clone(), &account_ids(transaction));","counters":[]},{"line":"","counters":[]},{"line":"        let (applied_txn, statement, updated_pending_coinbase_stack_state) =","counters":[]},{"line":"            Self::apply_transaction_and_get_statement(","counters":[]},{"line":"                constraint_constants,","counters":[]},{"line":"                ledger,","counters":[]},{"line":"                pending_coinbase_stack_state.clone(),","counters":[]},{"line":"                transaction,","counters":[]},{"line":"                txn_state_view,","counters":[]},{"line":"            )?;","counters":[]},{"line":"","counters":[]},{"line":"        if let Some(status) = status {","counters":[]},{"line":"            let got_status = applied_txn.transaction_status();","counters":[]},{"line":"","counters":[]},{"line":"            if status != got_status {","counters":[]},{"line":"                return Err(StagedLedgerError::MismatchedStatuses {","counters":[]},{"line":"                    transaction: applied_txn.transaction(),","counters":[]},{"line":"                    got: got_status.clone(),","counters":[]},{"line":"                });","counters":[]},{"line":"            }","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        let tx_with_witness = TransactionWithWitness {","counters":[]},{"line":"            transaction_with_info: applied_txn,","counters":[]},{"line":"            state_hash: state_and_body_hash,","counters":[]},{"line":"            statement,","counters":[]},{"line":"            init_stack: InitStack::Base(pending_coinbase_stack_state.init_stack.clone()),","counters":[]},{"line":"            ledger_witness,","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        Ok((tx_with_witness, updated_pending_coinbase_stack_state))","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/staged_ledger/staged_ledger.ml#L611","counters":[]},{"line":"    fn update_ledger_and_get_statements(","counters":[]},{"line":"        constraint_constants: &ConstraintConstants,","counters":[]},{"line":"        ledger: Mask,","counters":[]},{"line":"        current_stack: Stack,","counters":[]},{"line":"        transactions: &[WithStatus<Transaction>],","counters":[]},{"line":"        current_state_view: &ProtocolStateView,","counters":[]},{"line":"        state_and_body_hash: (Fp, Fp),","counters":[]},{"line":"    ) -> Result<(Vec<TransactionWithWitness>, Stack), StagedLedgerError> {","counters":[]},{"line":"        let current_stack_with_state = current_stack.push_state(state_and_body_hash.1);","counters":[]},{"line":"","counters":[]},{"line":"        let mut pending_coinbase_stack_state = StackStateWithInitStack {","counters":[]},{"line":"            pc: StackState {","counters":[]},{"line":"                source: current_stack.clone(),","counters":[]},{"line":"                target: current_stack_with_state,","counters":[]},{"line":"            },","counters":[]},{"line":"            init_stack: current_stack,","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        let tx_with_witness = transactions","counters":[]},{"line":"            .iter()","counters":[]},{"line":"            .map(|transaction| {","counters":[]},{"line":"                let public_keys = transaction.data.public_keys();","counters":[]},{"line":"","counters":[]},{"line":"                if let Some(pk) = public_keys.iter().find(|pk| decompress_pk(pk).is_none()) {","counters":[]},{"line":"                    return Err(StagedLedgerError::InvalidPublicKey(pk.clone()));","counters":[]},{"line":"                }","counters":[]},{"line":"","counters":[]},{"line":"                let (tx_with_witness, new_stack_state) = Self::apply_transaction_and_get_witness(","counters":[]},{"line":"                    constraint_constants,","counters":[]},{"line":"                    ledger.clone(),","counters":[]},{"line":"                    &pending_coinbase_stack_state,","counters":[]},{"line":"                    &transaction.data,","counters":[]},{"line":"                    Some(&transaction.status),","counters":[]},{"line":"                    current_state_view,","counters":[]},{"line":"                    state_and_body_hash,","counters":[]},{"line":"                )?;","counters":[]},{"line":"","counters":[]},{"line":"                pending_coinbase_stack_state = new_stack_state;","counters":[]},{"line":"","counters":[]},{"line":"                Ok(tx_with_witness)","counters":[]},{"line":"            })","counters":[]},{"line":"            .collect::<Result<_, _>>()?;","counters":[]},{"line":"","counters":[]},{"line":"        Ok((tx_with_witness, pending_coinbase_stack_state.pc.target))","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/staged_ledger/staged_ledger.ml#L164","counters":[]},{"line":"    fn verify(","counters":[]},{"line":"        _logger: (),","counters":[]},{"line":"        _verifier: &Verifier,","counters":[]},{"line":"        _job_msg_proofs: Vec<(AvailableJob, SokMessage, LedgerProof)>,","counters":[]},{"line":"    ) -> Result<(), StagedLedgerError> {","counters":[]},{"line":"        // TODO","counters":[]},{"line":"        Ok(())","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/staged_ledger/staged_ledger.ml#L654","counters":[]},{"line":"    fn check_completed_works(","counters":[]},{"line":"        logger: (),","counters":[]},{"line":"        verifier: &Verifier,","counters":[]},{"line":"        scan_state: &ScanState,","counters":[]},{"line":"        completed_works: Vec<work::Work>,","counters":[]},{"line":"    ) -> Result<(), StagedLedgerError> {","counters":[]},{"line":"        let work_count = completed_works.len() as u64;","counters":[]},{"line":"        let jobs_pairs = scan_state.k_work_pairs_for_new_diff(work_count);","counters":[]},{"line":"","counters":[]},{"line":"        let job_msg_proofs: Vec<(AvailableJob, SokMessage, LedgerProof)> = jobs_pairs","counters":[]},{"line":"            .into_iter()","counters":[]},{"line":"            .zip(completed_works)","counters":[]},{"line":"            .flat_map(|(jobs, work)| {","counters":[]},{"line":"                let message = SokMessage::create(work.fee, work.prover);","counters":[]},{"line":"                OneOrTwo::zip(jobs, work.proofs)","counters":[]},{"line":"                    .into_map(|(job, proof)| (job, message.clone(), proof))","counters":[]},{"line":"                    .into_iter()","counters":[]},{"line":"            })","counters":[]},{"line":"            .collect();","counters":[]},{"line":"","counters":[]},{"line":"        Self::verify(logger, verifier, job_msg_proofs)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// The total fee excess caused by any diff should be zero. In the case where","counters":[]},{"line":"    /// the slots are split into two partitions, total fee excess of the transactions","counters":[]},{"line":"    /// to be enqueued on each of the partitions should be zero respectively","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/staged_ledger/staged_ledger.ml#L674","counters":[]},{"line":"    fn check_zero_fee_excess(","counters":[]},{"line":"        scan_state: &ScanState,","counters":[]},{"line":"        data: &[TransactionWithWitness],","counters":[]},{"line":"    ) -> Result<(), StagedLedgerError> {","counters":[]},{"line":"        let partitions = scan_state.partition_if_overflowing();","counters":[]},{"line":"","counters":[]},{"line":"        let txns_from_data = |data: &[TransactionWithWitness]| -> Vec<WithStatus<Transaction>> {","counters":[]},{"line":"            data.iter()","counters":[]},{"line":"                .map(|tx| tx.transaction_with_info.transaction())","counters":[]},{"line":"                .collect::<Vec<_>>()","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        let total_fee_excess = |txns: &[WithStatus<Transaction>]| {","counters":[]},{"line":"            txns.iter().try_fold(FeeExcess::empty(), |accum, txn| {","counters":[]},{"line":"                let fee_excess = txn.data.fee_excess()?;","counters":[]},{"line":"                FeeExcess::combine(&accum, &fee_excess)","counters":[]},{"line":"            })","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        let check = |data: &[TransactionWithWitness],","counters":[]},{"line":"                     slots: &SpacePartition|","counters":[]},{"line":"         -> Result<(), StagedLedgerError> {","counters":[]},{"line":"            let txns = txns_from_data(data);","counters":[]},{"line":"            let fee_excess = total_fee_excess(&txns)?;","counters":[]},{"line":"","counters":[]},{"line":"            if fee_excess.is_zero() {","counters":[]},{"line":"                Ok(())","counters":[]},{"line":"            } else {","counters":[]},{"line":"                Err(StagedLedgerError::NonZeroFeeExcess(txns, slots.clone()))","counters":[]},{"line":"            }","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        let (first, second) = split_at(data, partitions.first.0 as usize);","counters":[]},{"line":"","counters":[]},{"line":"        check(first, &partitions)?;","counters":[]},{"line":"","counters":[]},{"line":"        if partitions.second.is_some() {","counters":[]},{"line":"            check(second, &partitions)?;","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        Ok(())","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/staged_ledger/staged_ledger.ml#L712","counters":[]},{"line":"    fn update_coinbase_stack_and_get_data(","counters":[]},{"line":"        constraint_constants: &ConstraintConstants,","counters":[]},{"line":"        scan_state: &ScanState,","counters":[]},{"line":"        ledger: Mask,","counters":[]},{"line":"        pending_coinbase_collection: &mut PendingCoinbase,","counters":[]},{"line":"        transactions: Vec<WithStatus<Transaction>>,","counters":[]},{"line":"        current_state_view: &ProtocolStateView,","counters":[]},{"line":"        state_and_body_hash: (Fp, Fp),","counters":[]},{"line":"    ) -> Result<(bool, Vec<TransactionWithWitness>, Action, StackUpdate), StagedLedgerError> {","counters":[]},{"line":"        let coinbase_exists = |txns: &[WithStatus<Transaction>]| {","counters":[]},{"line":"            txns.iter()","counters":[]},{"line":"                .any(|tx| matches!(tx.data, Transaction::Coinbase(_)))","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        let SpacePartition {","counters":[]},{"line":"            first: (slots, _),","counters":[]},{"line":"            second,","counters":[]},{"line":"        } = scan_state.partition_if_overflowing();","counters":[]},{"line":"","counters":[]},{"line":"        if !transactions.is_empty() {","counters":[]},{"line":"            if second.is_none() {","counters":[]},{"line":"                // Single partition:","counters":[]},{"line":"                // 1.Check if a new stack is required and get a working stack [working_stack]","counters":[]},{"line":"                // 2.create data for enqueuing onto the scan state *)","counters":[]},{"line":"","counters":[]},{"line":"                let is_new_stack = scan_state.next_on_new_tree();","counters":[]},{"line":"                let working_stack = Self::working_stack(pending_coinbase_collection, is_new_stack)?;","counters":[]},{"line":"","counters":[]},{"line":"                let (data, updated_stack) = Self::update_ledger_and_get_statements(","counters":[]},{"line":"                    constraint_constants,","counters":[]},{"line":"                    ledger,","counters":[]},{"line":"                    working_stack,","counters":[]},{"line":"                    &transactions,","counters":[]},{"line":"                    current_state_view,","counters":[]},{"line":"                    state_and_body_hash,","counters":[]},{"line":"                )?;","counters":[]},{"line":"","counters":[]},{"line":"                Ok((","counters":[]},{"line":"                    is_new_stack,","counters":[]},{"line":"                    data,","counters":[]},{"line":"                    Action::One,","counters":[]},{"line":"                    StackUpdate::One(updated_stack),","counters":[]},{"line":"                ))","counters":[]},{"line":"            } else {","counters":[]},{"line":"                // Two partition:","counters":[]},{"line":"                // Assumption: Only one of the partition will have coinbase transaction(s)in it.","counters":[]},{"line":"                // 1. Get the latest stack for coinbase in the first set of transactions","counters":[]},{"line":"                // 2. get the first set of scan_state data[data1]","counters":[]},{"line":"                // 3. get a new stack for the second partion because the second set of transactions would start from the begining of the next tree in the scan_state","counters":[]},{"line":"                // 4. Initialize the new stack with the state from the first stack","counters":[]},{"line":"                // 5. get the second set of scan_state data[data2]*)","counters":[]},{"line":"","counters":[]},{"line":"                let (txns_for_partition1, txns_for_partition2) =","counters":[]},{"line":"                    split_at(transactions.as_slice(), slots as usize);","counters":[]},{"line":"","counters":[]},{"line":"                let coinbase_in_first_partition = coinbase_exists(txns_for_partition1);","counters":[]},{"line":"","counters":[]},{"line":"                let working_stack1 = Self::working_stack(pending_coinbase_collection, false)?;","counters":[]},{"line":"                // Push the new state to the state_stack from the previous block even in the second stack","counters":[]},{"line":"                let working_stack2 = Stack::create_with(&working_stack1);","counters":[]},{"line":"","counters":[]},{"line":"                let (mut data1, updated_stack1) = Self::update_ledger_and_get_statements(","counters":[]},{"line":"                    constraint_constants,","counters":[]},{"line":"                    ledger.clone(),","counters":[]},{"line":"                    working_stack1,","counters":[]},{"line":"                    txns_for_partition1,","counters":[]},{"line":"                    current_state_view,","counters":[]},{"line":"                    state_and_body_hash,","counters":[]},{"line":"                )?;","counters":[]},{"line":"","counters":[]},{"line":"                let (mut data2, updated_stack2) = Self::update_ledger_and_get_statements(","counters":[]},{"line":"                    constraint_constants,","counters":[]},{"line":"                    ledger,","counters":[]},{"line":"                    working_stack2,","counters":[]},{"line":"                    txns_for_partition2,","counters":[]},{"line":"                    current_state_view,","counters":[]},{"line":"                    state_and_body_hash,","counters":[]},{"line":"                )?;","counters":[]},{"line":"","counters":[]},{"line":"                let second_has_data = !txns_for_partition2.is_empty();","counters":[]},{"line":"","counters":[]},{"line":"                let (pending_coinbase_action, stack_update) =","counters":[]},{"line":"                    // NOTE: Only branch `(true, false)` and `(false, true)` are taken here","counters":[]},{"line":"                    match (coinbase_in_first_partition, second_has_data) {","counters":[]},{"line":"                        (true, true) => {","counters":[]},{"line":"                            (","counters":[]},{"line":"                                Action::TwoCoinbaseInFirst,","counters":[]},{"line":"                                StackUpdate::Two((updated_stack1, updated_stack2)),","counters":[]},{"line":"                            )","counters":[]},{"line":"                            // updated_stack2 does not have coinbase and but has the state from the previous stack","counters":[]},{"line":"                        }","counters":[]},{"line":"                        (true, false) => {","counters":[]},{"line":"                            // updated_stack1 has some new coinbase but parition 2 has no","counters":[]},{"line":"                            // data and so we have only one stack to update","counters":[]},{"line":"                            (Action::One, StackUpdate::One(updated_stack1))","counters":[]},{"line":"                        }","counters":[]},{"line":"                        (false, true) => {","counters":[]},{"line":"                            // updated_stack1 just has the new state. [updated stack2] might have coinbase,","counters":[]},{"line":"                            // definitely has some data and therefore will have a non-dummy state.","counters":[]},{"line":"                            (","counters":[]},{"line":"                                Action::TwoCoinbaseInSecond,","counters":[]},{"line":"                                StackUpdate::Two((updated_stack1, updated_stack2)),","counters":[]},{"line":"                            )","counters":[]},{"line":"                        }","counters":[]},{"line":"                        (false, false) => {","counters":[]},{"line":"                            // a diff consists of only non-coinbase transactions. This is","counters":[]},{"line":"                            // currently not possible because a diff will have a coinbase","counters":[]},{"line":"                            // at the very least, so don't update anything?*)","counters":[]},{"line":"                            (Action::None, StackUpdate::None)","counters":[]},{"line":"                        }","counters":[]},{"line":"                    };","counters":[]},{"line":"","counters":[]},{"line":"                data1.append(&mut data2);","counters":[]},{"line":"                let data = data1;","counters":[]},{"line":"","counters":[]},{"line":"                Ok((false, data, pending_coinbase_action, stack_update))","counters":[]},{"line":"            }","counters":[]},{"line":"        } else {","counters":[]},{"line":"            Ok((false, Vec::new(), Action::None, StackUpdate::None))","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// update the pending_coinbase tree with the updated/new stack and delete the oldest stack if a proof was emitted","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/staged_ledger/staged_ledger.ml#L806","counters":[]},{"line":"    fn update_pending_coinbase_collection(","counters":[]},{"line":"        depth: usize,","counters":[]},{"line":"        pending_coinbase: &mut PendingCoinbase,","counters":[]},{"line":"        stack_update: StackUpdate,","counters":[]},{"line":"        is_new_stack: bool,","counters":[]},{"line":"        ledger_proof: &Option<(LedgerProof, Vec<(WithStatus<Transaction>, Fp)>)>,","counters":[]},{"line":"    ) -> Result<(), StagedLedgerError> {","counters":[]},{"line":"        // Deleting oldest stack if proof emitted","counters":[]},{"line":"        if let Some((proof, _)) = ledger_proof {","counters":[]},{"line":"            let oldest_stack = pending_coinbase.remove_coinbase_stack(depth)?;","counters":[]},{"line":"            let ledger_proof_stack = &proof.statement().target.pending_coinbase_stack;","counters":[]},{"line":"","counters":[]},{"line":"            if &oldest_stack != ledger_proof_stack {","counters":[]},{"line":"                return Err(\"Pending coinbase stack of the ledger proof did not \\","counters":[]},{"line":"                     match the oldest stack in the pending coinbase tree.\"","counters":[]},{"line":"                    .to_string())?;","counters":[]},{"line":"            }","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        match stack_update {","counters":[]},{"line":"            StackUpdate::None => {}","counters":[]},{"line":"            StackUpdate::One(stack1) => {","counters":[]},{"line":"                pending_coinbase.update_coinbase_stack(depth, stack1, is_new_stack)?;","counters":[]},{"line":"            }","counters":[]},{"line":"            StackUpdate::Two((stack1, stack2)) => {","counters":[]},{"line":"                // The case when some of the transactions go into the old tree and","counters":[]},{"line":"                // remaining on to the new tree","counters":[]},{"line":"                pending_coinbase.update_coinbase_stack(depth, stack1, false)?;","counters":[]},{"line":"                pending_coinbase.update_coinbase_stack(depth, stack2, true)?;","counters":[]},{"line":"            }","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        Ok(())","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/staged_ledger/staged_ledger.ml#L855","counters":[]},{"line":"    fn coinbase_for_blockchain_snark(amounts: &[Amount]) -> Result<Amount, StagedLedgerError> {","counters":[]},{"line":"        match amounts {","counters":[]},{"line":"            [] => Ok(Amount::zero()),","counters":[]},{"line":"            [amount] => Ok(*amount),","counters":[]},{"line":"            [amount1, _amount2] => Ok(*amount1),","counters":[]},{"line":"            _ => Err(StagedLedgerError::PreDiff(PreDiffError::CoinbaseError(","counters":[]},{"line":"                \"More than two coinbase parts\".to_string(),","counters":[]},{"line":"            ))),","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/staged_ledger/staged_ledger.ml#L868","counters":[]},{"line":"    fn apply_diff(","counters":[]},{"line":"        &mut self,","counters":[]},{"line":"        _logger: (),","counters":[]},{"line":"        skip_verification: Option<bool>,","counters":[]},{"line":"        pre_diff_info: (","counters":[]},{"line":"            Vec<WithStatus<Transaction>>,","counters":[]},{"line":"            Vec<work::Work>,","counters":[]},{"line":"            usize,","counters":[]},{"line":"            Vec<Amount>,","counters":[]},{"line":"        ),","counters":[]},{"line":"        constraint_constants: &ConstraintConstants,","counters":[]},{"line":"        current_state_view: &ProtocolStateView,","counters":[]},{"line":"        state_and_body_hash: (Fp, Fp),","counters":[]},{"line":"        log_prefix: &'static str,","counters":[]},{"line":"    ) -> Result<DiffResult, StagedLedgerError> {","counters":[]},{"line":"        let skip_verification = skip_verification.unwrap_or(false);","counters":[]},{"line":"","counters":[]},{"line":"        let max_throughput = 2u64.pow(constraint_constants.transaction_capacity_log_2 as u32);","counters":[]},{"line":"","counters":[]},{"line":"        let (_spots_available, _proofs_waiting) = {","counters":[]},{"line":"            let jobs = self.scan_state.all_work_statements_exn();","counters":[]},{"line":"            let free_space = self.scan_state.free_space();","counters":[]},{"line":"            (free_space.min(max_throughput), jobs.len())","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        let mut new_ledger = self.ledger.make_child();","counters":[]},{"line":"","counters":[]},{"line":"        let (transactions, works, _commands_count, coinbases) = pre_diff_info;","counters":[]},{"line":"","counters":[]},{"line":"        let (is_new_stack, data, stack_update_in_snark, stack_update) =","counters":[]},{"line":"            Self::update_coinbase_stack_and_get_data(","counters":[]},{"line":"                constraint_constants,","counters":[]},{"line":"                &self.scan_state,","counters":[]},{"line":"                new_ledger.clone(),","counters":[]},{"line":"                &mut self.pending_coinbase_collection,","counters":[]},{"line":"                transactions,","counters":[]},{"line":"                current_state_view,","counters":[]},{"line":"                state_and_body_hash,","counters":[]},{"line":"            )?;","counters":[]},{"line":"","counters":[]},{"line":"        let slots = data.len();","counters":[]},{"line":"        let work_count = works.len();","counters":[]},{"line":"        let required_pairs = self.scan_state.work_statements_for_new_diff();","counters":[]},{"line":"","counters":[]},{"line":"        {","counters":[]},{"line":"            let required = required_pairs.len();","counters":[]},{"line":"            if work_count < required","counters":[]},{"line":"                && data.len() > (self.scan_state.free_space() as usize - required + work_count)","counters":[]},{"line":"            {","counters":[]},{"line":"                return Err(StagedLedgerError::InsufficientWork(format!(","counters":[]},{"line":"                    \"Insufficient number of transaction snark work (slots \\","counters":[]},{"line":"                     occupying: {})  required {}, got {}\",","counters":[]},{"line":"                    slots, required, work_count","counters":[]},{"line":"                )));","counters":[]},{"line":"            }","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        Self::check_zero_fee_excess(&self.scan_state, &data)?;","counters":[]},{"line":"","counters":[]},{"line":"        let res_opt = {","counters":[]},{"line":"            self.scan_state","counters":[]},{"line":"                .fill_work_and_enqueue_transactions(data, works)","counters":[]},{"line":"                .map_err(|e| {","counters":[]},{"line":"                    format!(","counters":[]},{"line":"                        \"{}: Unexpected error when applying diff data $data to \\","counters":[]},{"line":"                     the scan_state: {:?}\",","counters":[]},{"line":"                        log_prefix, e","counters":[]},{"line":"                    )","counters":[]},{"line":"                })?","counters":[]},{"line":"            // TODO: OCaml print the error in json format here","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        Self::update_pending_coinbase_collection(","counters":[]},{"line":"            constraint_constants.pending_coinbase_depth as usize,","counters":[]},{"line":"            &mut self.pending_coinbase_collection,","counters":[]},{"line":"            stack_update,","counters":[]},{"line":"            is_new_stack,","counters":[]},{"line":"            &res_opt,","counters":[]},{"line":"        )?;","counters":[]},{"line":"","counters":[]},{"line":"        let coinbase_amount = Self::coinbase_for_blockchain_snark(&coinbases)?;","counters":[]},{"line":"","counters":[]},{"line":"        let latest_pending_coinbase_stack = self.pending_coinbase_collection.latest_stack(false);","counters":[]},{"line":"","counters":[]},{"line":"        if !skip_verification {","counters":[]},{"line":"            Self::verify_scan_state_after_apply(","counters":[]},{"line":"                constraint_constants,","counters":[]},{"line":"                latest_pending_coinbase_stack,","counters":[]},{"line":"                new_ledger.merkle_root(),","counters":[]},{"line":"                &self.scan_state,","counters":[]},{"line":"            )?;","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        self.ledger = new_ledger;","counters":[]},{"line":"        self.constraint_constants = constraint_constants.clone();","counters":[]},{"line":"","counters":[]},{"line":"        Ok(DiffResult {","counters":[]},{"line":"            hash_after_applying: self.hash(),","counters":[]},{"line":"            ledger_proof: res_opt,","counters":[]},{"line":"            pending_coinbase_update: (","counters":[]},{"line":"                is_new_stack,","counters":[]},{"line":"                Update {","counters":[]},{"line":"                    action: stack_update_in_snark,","counters":[]},{"line":"                    coinbase_amount,","counters":[]},{"line":"                },","counters":[]},{"line":"            ),","counters":[]},{"line":"        })","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/staged_ledger/staged_ledger.ml#L1016","counters":[]},{"line":"    fn forget_prediff_info<B, C, D>(","counters":[]},{"line":"        (a, b, c, d): (Vec<WithStatus<valid::Transaction>>, B, C, D),","counters":[]},{"line":"    ) -> (Vec<WithStatus<Transaction>>, B, C, D) {","counters":[]},{"line":"        (","counters":[]},{"line":"            a.iter()","counters":[]},{"line":"                .map(|with_status| with_status.map(|t| t.forget()))","counters":[]},{"line":"                .collect(),","counters":[]},{"line":"            b,","counters":[]},{"line":"            c,","counters":[]},{"line":"            d,","counters":[]},{"line":"        )","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/staged_ledger/staged_ledger.ml#L1020","counters":[]},{"line":"    fn check_commands(","counters":[]},{"line":"        ledger: Mask,","counters":[]},{"line":"        verifier: &Verifier,","counters":[]},{"line":"        cs: Vec<&UserCommand>,","counters":[]},{"line":"    ) -> Result<Vec<valid::UserCommand>, VerifierError> {","counters":[]},{"line":"        let cmds: Vec<verifiable::UserCommand> =","counters":[]},{"line":"            cs.iter().map(|cmd| cmd.to_verifiable(&ledger)).collect();","counters":[]},{"line":"","counters":[]},{"line":"        let xs = verifier.verify_commands(cmds)?;","counters":[]},{"line":"","counters":[]},{"line":"        // TODO: OCaml does check the list `xs`","counters":[]},{"line":"","counters":[]},{"line":"        Ok(xs)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn apply(","counters":[]},{"line":"        &mut self,","counters":[]},{"line":"        skip_verification: Option<SkipVerification>,","counters":[]},{"line":"        constraint_constants: &ConstraintConstants,","counters":[]},{"line":"        witness: Diff,","counters":[]},{"line":"        logger: (),","counters":[]},{"line":"        verifier: &Verifier,","counters":[]},{"line":"        current_state_view: &ProtocolStateView,","counters":[]},{"line":"        state_and_body_hash: (Fp, Fp),","counters":[]},{"line":"        coinbase_receiver: CompressedPubKey,","counters":[]},{"line":"        supercharge_coinbase: bool,","counters":[]},{"line":"    ) -> Result<DiffResult, StagedLedgerError> {","counters":[]},{"line":"        let work = witness.completed_works();","counters":[]},{"line":"","counters":[]},{"line":"        if skip_verification.is_none() {","counters":[]},{"line":"            Self::check_completed_works(logger, verifier, &self.scan_state, work)?;","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        let prediff = witness.get(","counters":[]},{"line":"            |cmd| Self::check_commands(self.ledger.clone(), verifier, cmd),","counters":[]},{"line":"            constraint_constants,","counters":[]},{"line":"            coinbase_receiver,","counters":[]},{"line":"            supercharge_coinbase,","counters":[]},{"line":"        )?;","counters":[]},{"line":"","counters":[]},{"line":"        self.apply_diff(","counters":[]},{"line":"            logger,","counters":[]},{"line":"            skip_verification.map(|s| matches!(s, SkipVerification::All)),","counters":[]},{"line":"            Self::forget_prediff_info(prediff),","counters":[]},{"line":"            constraint_constants,","counters":[]},{"line":"            current_state_view,","counters":[]},{"line":"            state_and_body_hash,","counters":[]},{"line":"            \"apply_diff\",","counters":[]},{"line":"        )","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/staged_ledger/staged_ledger.ml#L1095","counters":[]},{"line":"    fn apply_diff_unchecked(","counters":[]},{"line":"        &mut self,","counters":[]},{"line":"        constraint_constants: &ConstraintConstants,","counters":[]},{"line":"        sl_diff: with_valid_signatures_and_proofs::Diff,","counters":[]},{"line":"        logger: (),","counters":[]},{"line":"        current_state_view: &ProtocolStateView,","counters":[]},{"line":"        state_and_body_hash: (Fp, Fp),","counters":[]},{"line":"        coinbase_receiver: CompressedPubKey,","counters":[]},{"line":"        supercharge_coinbase: bool,","counters":[]},{"line":"    ) -> Result<DiffResult, StagedLedgerError> {","counters":[]},{"line":"        let prediff = sl_diff.get_unchecked(","counters":[]},{"line":"            constraint_constants,","counters":[]},{"line":"            coinbase_receiver,","counters":[]},{"line":"            supercharge_coinbase,","counters":[]},{"line":"        )?;","counters":[]},{"line":"","counters":[]},{"line":"        self.apply_diff(","counters":[]},{"line":"            logger,","counters":[]},{"line":"            None,","counters":[]},{"line":"            Self::forget_prediff_info(prediff),","counters":[]},{"line":"            constraint_constants,","counters":[]},{"line":"            current_state_view,","counters":[]},{"line":"            state_and_body_hash,","counters":[]},{"line":"            \"apply_diff_unchecked\",","counters":[]},{"line":"        )","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/staged_ledger/staged_ledger.ml#L1580","counters":[]},{"line":"    fn check_constraints_and_update(","counters":[]},{"line":"        constraint_constants: &ConstraintConstants,","counters":[]},{"line":"        resources: &mut Resources,","counters":[]},{"line":"        log: &mut DiffCreationLog,","counters":[]},{"line":"    ) {","counters":[]},{"line":"        use super::diff_creation_log::Reason::*;","counters":[]},{"line":"","counters":[]},{"line":"        if resources.slots_occupied() == 0 {","counters":[]},{"line":"            // Done","counters":[]},{"line":"        } else if resources.work_constraint_satisfied() {","counters":[]},{"line":"            // There's enough work. Check if they satisfy other constraints","counters":[]},{"line":"            if resources.budget_sufficient() {","counters":[]},{"line":"                if resources.space_constraint_satisfied() {","counters":[]},{"line":"                    return;","counters":[]},{"line":"                } else if resources.worked_more(constraint_constants) {","counters":[]},{"line":"                    // There are too many fee_transfers(from the proofs)","counters":[]},{"line":"                    // occupying the slots. discard one and check","counters":[]},{"line":"                    let work_opt = resources.discard_last_work(constraint_constants);","counters":[]},{"line":"                    if let Some(work) = work_opt {","counters":[]},{"line":"                        log.discard_completed_work(ExtraWork, &work);","counters":[]},{"line":"                    };","counters":[]},{"line":"                    Self::check_constraints_and_update(constraint_constants, resources, log);","counters":[]},{"line":"                } else {","counters":[]},{"line":"                    // Well, there's no space; discard a user command","counters":[]},{"line":"                    let uc_opt = resources.discard_user_command();","counters":[]},{"line":"                    if let Some(uc) = uc_opt {","counters":[]},{"line":"                        log.discard_command(NoSpace, &uc.data);","counters":[]},{"line":"                    };","counters":[]},{"line":"                    Self::check_constraints_and_update(constraint_constants, resources, log);","counters":[]},{"line":"                }","counters":[]},{"line":"            } else {","counters":[]},{"line":"                // insufficient budget; reduce the cost","counters":[]},{"line":"                let work_opt = resources.discard_last_work(constraint_constants);","counters":[]},{"line":"                if let Some(work) = work_opt {","counters":[]},{"line":"                    log.discard_completed_work(InsufficientFees, &work);","counters":[]},{"line":"                };","counters":[]},{"line":"                Self::check_constraints_and_update(constraint_constants, resources, log);","counters":[]},{"line":"            }","counters":[]},{"line":"        } else {","counters":[]},{"line":"            // There isn't enough work for the transactions. Discard a","counters":[]},{"line":"            // transaction and check again","counters":[]},{"line":"            let uc_opt = resources.discard_user_command();","counters":[]},{"line":"            if let Some(uc) = uc_opt {","counters":[]},{"line":"                log.discard_command(NoWork, &uc.data);","counters":[]},{"line":"            };","counters":[]},{"line":"            Self::check_constraints_and_update(constraint_constants, resources, log);","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/staged_ledger/staged_ledger.ml#L1624","counters":[]},{"line":"    fn one_prediff(","counters":[]},{"line":"        constraint_constants: &ConstraintConstants,","counters":[]},{"line":"        cw_seq: Vec<work::Unchecked>,","counters":[]},{"line":"        ts_seq: Vec<WithStatus<valid::UserCommand>>,","counters":[]},{"line":"        receiver: &CompressedPubKey,","counters":[]},{"line":"        add_coinbase: bool,","counters":[]},{"line":"        slot_job_count: (u64, u64),","counters":[]},{"line":"        logger: (),","counters":[]},{"line":"        is_coinbase_receiver_new: bool,","counters":[]},{"line":"        partition: Partition,","counters":[]},{"line":"        supercharge_coinbase: bool,","counters":[]},{"line":"    ) -> (Resources, DiffCreationLog) {","counters":[]},{"line":"        let mut init_resources = Resources::init(","counters":[]},{"line":"            constraint_constants,","counters":[]},{"line":"            ts_seq,","counters":[]},{"line":"            cw_seq,","counters":[]},{"line":"            slot_job_count,","counters":[]},{"line":"            receiver.clone(),","counters":[]},{"line":"            add_coinbase,","counters":[]},{"line":"            supercharge_coinbase,","counters":[]},{"line":"            logger,","counters":[]},{"line":"            is_coinbase_receiver_new,","counters":[]},{"line":"        );","counters":[]},{"line":"","counters":[]},{"line":"        let mut log = DiffCreationLog::init(","counters":[]},{"line":"            &init_resources.completed_work_rev,","counters":[]},{"line":"            &init_resources.commands_rev,","counters":[]},{"line":"            &init_resources.coinbase,","counters":[]},{"line":"            partition,","counters":[]},{"line":"            slot_job_count.0,","counters":[]},{"line":"            slot_job_count.1,","counters":[]},{"line":"        );","counters":[]},{"line":"","counters":[]},{"line":"        Self::check_constraints_and_update(constraint_constants, &mut init_resources, &mut log);","counters":[]},{"line":"","counters":[]},{"line":"        (init_resources, log)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/staged_ledger/staged_ledger.ml#L1643","counters":[]},{"line":"    fn generate(","counters":[]},{"line":"        constraint_constants: &ConstraintConstants,","counters":[]},{"line":"        logger: (),","counters":[]},{"line":"        cw_seq: Vec<work::Unchecked>,","counters":[]},{"line":"        ts_seq: Vec<WithStatus<valid::UserCommand>>,","counters":[]},{"line":"        receiver: &CompressedPubKey,","counters":[]},{"line":"        is_coinbase_receiver_new: bool,","counters":[]},{"line":"        supercharge_coinbase: bool,","counters":[]},{"line":"        partitions: scan_state::SpacePartition,","counters":[]},{"line":"    ) -> (","counters":[]},{"line":"        (","counters":[]},{"line":"            PreDiffTwo<work::Work, WithStatus<valid::UserCommand>>,","counters":[]},{"line":"            Option<super::diff::PreDiffOne<work::Work, WithStatus<valid::UserCommand>>>,","counters":[]},{"line":"        ),","counters":[]},{"line":"        Vec<DiffCreationLog>,","counters":[]},{"line":"    ) {","counters":[]},{"line":"        let pre_diff_with_one =","counters":[]},{"line":"            |mut res: Resources| -> with_valid_signatures_and_proofs::PreDiffWithAtMostOneCoinbase {","counters":[]},{"line":"                let to_at_most_one = |two: AtMostTwo<CoinbaseFeeTransfer>| match two {","counters":[]},{"line":"                    AtMostTwo::Zero => AtMostOne::Zero,","counters":[]},{"line":"                    AtMostTwo::One(v) => AtMostOne::One(v),","counters":[]},{"line":"                    AtMostTwo::Two(_) => {","counters":[]},{"line":"                        eprintln!(","counters":[]},{"line":"                            \"Error creating staged ledger diff: Should have at most one \\","counters":[]},{"line":"                             coinbase in the second pre_diff\"","counters":[]},{"line":"                        );","counters":[]},{"line":"                        AtMostOne::Zero","counters":[]},{"line":"                    }","counters":[]},{"line":"                };","counters":[]},{"line":"","counters":[]},{"line":"                // We have to reverse here because we only know they work in THIS order","counters":[]},{"line":"                with_valid_signatures_and_proofs::PreDiffWithAtMostOneCoinbase {","counters":[]},{"line":"                    commands: {","counters":[]},{"line":"                        res.commands_rev.reverse();","counters":[]},{"line":"                        res.commands_rev","counters":[]},{"line":"                    },","counters":[]},{"line":"                    completed_works: {","counters":[]},{"line":"                        res.completed_work_rev.reverse();","counters":[]},{"line":"                        res.completed_work_rev","counters":[]},{"line":"                    },","counters":[]},{"line":"                    coinbase: to_at_most_one(res.coinbase),","counters":[]},{"line":"                    internal_command_statuses: {","counters":[]},{"line":"                        // updated later based on application result","counters":[]},{"line":"                        Vec::new()","counters":[]},{"line":"                    },","counters":[]},{"line":"                }","counters":[]},{"line":"            };","counters":[]},{"line":"","counters":[]},{"line":"        let pre_diff_with_two =","counters":[]},{"line":"            |mut res: Resources| -> with_valid_signatures_and_proofs::PreDiffWithAtMostTwoCoinbase {","counters":[]},{"line":"                with_valid_signatures_and_proofs::PreDiffWithAtMostTwoCoinbase {","counters":[]},{"line":"                    commands: {","counters":[]},{"line":"                        res.commands_rev.reverse();","counters":[]},{"line":"                        res.commands_rev","counters":[]},{"line":"                    },","counters":[]},{"line":"                    completed_works: {","counters":[]},{"line":"                        res.completed_work_rev.reverse();","counters":[]},{"line":"                        res.completed_work_rev","counters":[]},{"line":"                    },","counters":[]},{"line":"                    coinbase: res.coinbase,","counters":[]},{"line":"                    internal_command_statuses: {","counters":[]},{"line":"                        // updated later based on application result","counters":[]},{"line":"                        Vec::new()","counters":[]},{"line":"                    },","counters":[]},{"line":"                }","counters":[]},{"line":"            };","counters":[]},{"line":"","counters":[]},{"line":"        let end_log = |(res, log): &mut (Resources, DiffCreationLog)| {","counters":[]},{"line":"            log.end_log(&res.completed_work_rev, &res.commands_rev, &res.coinbase)","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        let make_diff = |mut res1: (Resources, DiffCreationLog),","counters":[]},{"line":"                         res2: Option<(Resources, DiffCreationLog)>|","counters":[]},{"line":"         -> (","counters":[]},{"line":"            (","counters":[]},{"line":"                PreDiffTwo<work::Work, WithStatus<valid::UserCommand>>,","counters":[]},{"line":"                Option<super::diff::PreDiffOne<work::Work, WithStatus<valid::UserCommand>>>,","counters":[]},{"line":"            ),","counters":[]},{"line":"            Vec<DiffCreationLog>,","counters":[]},{"line":"        ) {","counters":[]},{"line":"            match res2 {","counters":[]},{"line":"                Some(mut res2) => {","counters":[]},{"line":"                    end_log(&mut res1);","counters":[]},{"line":"                    end_log(&mut res2);","counters":[]},{"line":"","counters":[]},{"line":"                    (","counters":[]},{"line":"                        (pre_diff_with_two(res1.0), Some(pre_diff_with_one(res2.0))),","counters":[]},{"line":"                        vec![res1.1, res2.1],","counters":[]},{"line":"                    )","counters":[]},{"line":"                }","counters":[]},{"line":"                None => {","counters":[]},{"line":"                    end_log(&mut res1);","counters":[]},{"line":"                    ((pre_diff_with_two(res1.0), None), vec![res1.1])","counters":[]},{"line":"                }","counters":[]},{"line":"            }","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        let has_no_commands = |res: &Resources| -> bool { res.commands_rev.is_empty() };","counters":[]},{"line":"","counters":[]},{"line":"        let second_pre_diff = |res: Resources,","counters":[]},{"line":"                               partition: (u64, u64),","counters":[]},{"line":"                               add_coinbase: bool,","counters":[]},{"line":"                               work: Vec<work::Unchecked>|","counters":[]},{"line":"         -> (Resources, DiffCreationLog) {","counters":[]},{"line":"            Self::one_prediff(","counters":[]},{"line":"                constraint_constants,","counters":[]},{"line":"                work,","counters":[]},{"line":"                res.discarded.commands_rev,","counters":[]},{"line":"                receiver,","counters":[]},{"line":"                add_coinbase,","counters":[]},{"line":"                partition,","counters":[]},{"line":"                logger,","counters":[]},{"line":"                is_coinbase_receiver_new,","counters":[]},{"line":"                Partition::Second,","counters":[]},{"line":"                supercharge_coinbase,","counters":[]},{"line":"            )","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        let is_empty = |res: &Resources| has_no_commands(res) && res.coinbase_added() == 0;","counters":[]},{"line":"","counters":[]},{"line":"        // Partitioning explained in PR #687 (Mina repo)","counters":[]},{"line":"","counters":[]},{"line":"        match partitions.second {","counters":[]},{"line":"            None => {","counters":[]},{"line":"                let (res, log) = Self::one_prediff(","counters":[]},{"line":"                    constraint_constants,","counters":[]},{"line":"                    cw_seq,","counters":[]},{"line":"                    ts_seq,","counters":[]},{"line":"                    receiver,","counters":[]},{"line":"                    true,","counters":[]},{"line":"                    partitions.first,","counters":[]},{"line":"                    logger,","counters":[]},{"line":"                    is_coinbase_receiver_new,","counters":[]},{"line":"                    Partition::First,","counters":[]},{"line":"                    supercharge_coinbase,","counters":[]},{"line":"                );","counters":[]},{"line":"                make_diff((res, log), None)","counters":[]},{"line":"            }","counters":[]},{"line":"            Some(y) => {","counters":[]},{"line":"                assert!(cw_seq.len() as u64 <= partitions.first.1 + y.1);","counters":[]},{"line":"","counters":[]},{"line":"                let (cw_seq_1, cw_seq_2) = split_at_vec(cw_seq, partitions.first.1 as usize);","counters":[]},{"line":"","counters":[]},{"line":"                let (res, log1) = Self::one_prediff(","counters":[]},{"line":"                    constraint_constants,","counters":[]},{"line":"                    cw_seq_1.clone(),","counters":[]},{"line":"                    ts_seq.clone(),","counters":[]},{"line":"                    receiver,","counters":[]},{"line":"                    false,","counters":[]},{"line":"                    partitions.first,","counters":[]},{"line":"                    logger,","counters":[]},{"line":"                    is_coinbase_receiver_new,","counters":[]},{"line":"                    Partition::First,","counters":[]},{"line":"                    supercharge_coinbase,","counters":[]},{"line":"                );","counters":[]},{"line":"","counters":[]},{"line":"                let incr_coinbase_and_compute = |mut res: Resources,","counters":[]},{"line":"                                                 count: IncreaseBy|","counters":[]},{"line":"                 -> (","counters":[]},{"line":"                    (Resources, DiffCreationLog),","counters":[]},{"line":"                    Option<(Resources, DiffCreationLog)>,","counters":[]},{"line":"                ) {","counters":[]},{"line":"                    res.incr_coinbase_part_by(constraint_constants, count);","counters":[]},{"line":"","counters":[]},{"line":"                    if res.space_available() {","counters":[]},{"line":"                        // All slots could not be filled either because of budget","counters":[]},{"line":"                        // constraints or not enough work done. Don't create the second","counters":[]},{"line":"                        // prediff instead recompute first diff with just once coinbase","counters":[]},{"line":"                        let res = Self::one_prediff(","counters":[]},{"line":"                            constraint_constants,","counters":[]},{"line":"                            cw_seq_1.clone(),","counters":[]},{"line":"                            ts_seq.clone(),","counters":[]},{"line":"                            receiver,","counters":[]},{"line":"                            true,","counters":[]},{"line":"                            partitions.first,","counters":[]},{"line":"                            logger,","counters":[]},{"line":"                            is_coinbase_receiver_new,","counters":[]},{"line":"                            Partition::First,","counters":[]},{"line":"                            supercharge_coinbase,","counters":[]},{"line":"                        );","counters":[]},{"line":"","counters":[]},{"line":"                        (res, None)","counters":[]},{"line":"                    } else {","counters":[]},{"line":"                        let (res2, log2) = second_pre_diff(res.clone(), y, false, cw_seq_2.clone());","counters":[]},{"line":"","counters":[]},{"line":"                        if is_empty(&res2) {","counters":[]},{"line":"                            // Don't create the second prediff instead recompute first","counters":[]},{"line":"                            // diff with just once coinbase","counters":[]},{"line":"                            let res = Self::one_prediff(","counters":[]},{"line":"                                constraint_constants,","counters":[]},{"line":"                                cw_seq_1.clone(),","counters":[]},{"line":"                                ts_seq.clone(),","counters":[]},{"line":"                                receiver,","counters":[]},{"line":"                                true,","counters":[]},{"line":"                                partitions.first,","counters":[]},{"line":"                                logger,","counters":[]},{"line":"                                is_coinbase_receiver_new,","counters":[]},{"line":"                                Partition::First,","counters":[]},{"line":"                                supercharge_coinbase,","counters":[]},{"line":"                            );","counters":[]},{"line":"","counters":[]},{"line":"                            (res, None)","counters":[]},{"line":"                        } else {","counters":[]},{"line":"                            ((res, log1.clone()), Some((res2, log2)))","counters":[]},{"line":"                        }","counters":[]},{"line":"                    }","counters":[]},{"line":"                };","counters":[]},{"line":"","counters":[]},{"line":"                let try_with_coinbase = || -> (Resources, DiffCreationLog) {","counters":[]},{"line":"                    Self::one_prediff(","counters":[]},{"line":"                        constraint_constants,","counters":[]},{"line":"                        cw_seq_1.clone(),","counters":[]},{"line":"                        ts_seq.clone(),","counters":[]},{"line":"                        receiver,","counters":[]},{"line":"                        true,","counters":[]},{"line":"                        partitions.first,","counters":[]},{"line":"                        logger,","counters":[]},{"line":"                        is_coinbase_receiver_new,","counters":[]},{"line":"                        Partition::First,","counters":[]},{"line":"                        supercharge_coinbase,","counters":[]},{"line":"                    )","counters":[]},{"line":"                };","counters":[]},{"line":"","counters":[]},{"line":"                dbg!(res.available_space_dbg());","counters":[]},{"line":"","counters":[]},{"line":"                let (res1, res2) = if res.commands_rev.is_empty() {","counters":[]},{"line":"                    println!(\"edge_case: No user command added, add a coinbase only (Sequence.is_empty res.commands_rev)\");","counters":[]},{"line":"","counters":[]},{"line":"                    let res = try_with_coinbase();","counters":[]},{"line":"                    (res, None)","counters":[]},{"line":"                } else {","counters":[]},{"line":"                    match res.available_space() {","counters":[]},{"line":"                        0 => {","counters":[]},{"line":"                            println!(\"edge_case: Split commands in 2 diffs/partitions with at least 1 coinbase on next tree (Resources.available_space res = 0)\");","counters":[]},{"line":"                            // generate the next prediff with a coinbase at least","counters":[]},{"line":"                            let res2 = second_pre_diff(res.clone(), y, true, cw_seq_2);","counters":[]},{"line":"                            ((res, log1), Some(res2))","counters":[]},{"line":"                        }","counters":[]},{"line":"                        1 => {","counters":[]},{"line":"                            println!(\"edge_case: only 1 slot available, add coinbase and rest on 2nd diff/partition (Resources.available_space res = 1)\");","counters":[]},{"line":"                            // There's a slot available in the first partition, fill it","counters":[]},{"line":"                            // with coinbase and create another pre_diff for the slots","counters":[]},{"line":"                            // in the second partiton with the remaining user commands and work","counters":[]},{"line":"","counters":[]},{"line":"                            incr_coinbase_and_compute(res, IncreaseBy::One)","counters":[]},{"line":"                        }","counters":[]},{"line":"                        2 => {","counters":[]},{"line":"                            println!(\"edge_case: 2 slots available, split coinbase in 2 (Resources.available_space res = 2)\");","counters":[]},{"line":"                            // There are two slots which cannot be filled using user commands,","counters":[]},{"line":"                            // so we split the coinbase into two parts and fill those two spots","counters":[]},{"line":"","counters":[]},{"line":"                            incr_coinbase_and_compute(res, IncreaseBy::Two)","counters":[]},{"line":"                        }","counters":[]},{"line":"                        _ => {","counters":[]},{"line":"                            println!(\"edge_case: transactions fit in current tree (Resources.available_space res = _)\");","counters":[]},{"line":"                            // Too many slots left in the first partition. Either there wasn't","counters":[]},{"line":"                            // enough work to add transactions or there weren't enough","counters":[]},{"line":"                            // transactions. Create a new pre_diff for just the first partition","counters":[]},{"line":"","counters":[]},{"line":"                            let res = try_with_coinbase();","counters":[]},{"line":"                            (res, None)","counters":[]},{"line":"                        }","counters":[]},{"line":"                    }","counters":[]},{"line":"                };","counters":[]},{"line":"","counters":[]},{"line":"                let coinbase_added = res1.0.coinbase_added()","counters":[]},{"line":"                    + res2","counters":[]},{"line":"                        .as_ref()","counters":[]},{"line":"                        .map(|(res, _)| res.coinbase_added())","counters":[]},{"line":"                        .unwrap_or(0);","counters":[]},{"line":"","counters":[]},{"line":"                if coinbase_added > 0 {","counters":[]},{"line":"                    make_diff(res1, res2)","counters":[]},{"line":"                } else {","counters":[]},{"line":"                    // Coinbase takes priority over user-commands. Create a diff in","counters":[]},{"line":"                    // partitions.first with coinbase first and user commands if possible","counters":[]},{"line":"","counters":[]},{"line":"                    let res = try_with_coinbase();","counters":[]},{"line":"                    make_diff(res, None)","counters":[]},{"line":"                }","counters":[]},{"line":"            }","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/staged_ledger/staged_ledger.ml#L1781","counters":[]},{"line":"    fn can_apply_supercharged_coinbase_exn(","counters":[]},{"line":"        winner: CompressedPubKey,","counters":[]},{"line":"        epoch_ledger: &SparseLedger<AccountId, Account>,","counters":[]},{"line":"        global_slot: Slot,","counters":[]},{"line":"    ) -> bool {","counters":[]},{"line":"        !epoch_ledger.has_locked_tokens_exn(global_slot, AccountId::new(winner, TokenId::default()))","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/staged_ledger/staged_ledger.ml#L1787","counters":[]},{"line":"    fn validate_account_update_proofs(","counters":[]},{"line":"        _logger: (),","counters":[]},{"line":"        validating_ledger: &HashlessLedger,","counters":[]},{"line":"        txn: &valid::UserCommand,","counters":[]},{"line":"    ) -> bool {","counters":[]},{"line":"        use super::sparse_ledger::LedgerIntf;","counters":[]},{"line":"","counters":[]},{"line":"        let get_verification_keys = |account_ids: &HashSet<AccountId>| {","counters":[]},{"line":"            let get_vk = |account_id: &AccountId| -> Option<VerificationKeyHash> {","counters":[]},{"line":"                let addr = validating_ledger.location_of_account(account_id)?;","counters":[]},{"line":"                let account = validating_ledger.get(&addr)?;","counters":[]},{"line":"                let vk = account.zkapp.as_ref()?.verification_key.as_ref()?;","counters":[]},{"line":"                // TODO: In OCaml this is a field (using `WithHash`)","counters":[]},{"line":"                Some(VerificationKeyHash(vk.hash()))","counters":[]},{"line":"            };","counters":[]},{"line":"","counters":[]},{"line":"            let mut map = HashMap::with_capacity(128);","counters":[]},{"line":"","counters":[]},{"line":"            for id in account_ids {","counters":[]},{"line":"                match get_vk(id) {","counters":[]},{"line":"                    Some(vk) => {","counters":[]},{"line":"                        map.insert(id.clone(), vk);","counters":[]},{"line":"                    }","counters":[]},{"line":"                    None => {","counters":[]},{"line":"                        eprintln!(","counters":[]},{"line":"                            \"Staged_ledger_diff creation: Verification key not found for \\","counters":[]},{"line":"                             account_update with proof authorization and account_id \\","counters":[]},{"line":"                             {:?}\",","counters":[]},{"line":"                            id","counters":[]},{"line":"                        );","counters":[]},{"line":"                        return HashMap::new();","counters":[]},{"line":"                    }","counters":[]},{"line":"                }","counters":[]},{"line":"            }","counters":[]},{"line":"","counters":[]},{"line":"            map","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        match txn {","counters":[]},{"line":"            valid::UserCommand::ZkAppCommand(p) => {","counters":[]},{"line":"                let checked_verification_keys: HashMap<AccountId, VerificationKeyHash> =","counters":[]},{"line":"                    p.verification_keys.iter().cloned().collect();","counters":[]},{"line":"","counters":[]},{"line":"                let proof_zkapp_command = p.zkapp_command.account_updates.fold(","counters":[]},{"line":"                    HashSet::with_capacity(128),","counters":[]},{"line":"                    |mut accum, update| {","counters":[]},{"line":"                        if let Control::Proof(_) = &update.authorization {","counters":[]},{"line":"                            accum.insert(update.account_id());","counters":[]},{"line":"                        }","counters":[]},{"line":"                        accum","counters":[]},{"line":"                    },","counters":[]},{"line":"                );","counters":[]},{"line":"","counters":[]},{"line":"                let current_verification_keys = get_verification_keys(&proof_zkapp_command);","counters":[]},{"line":"","counters":[]},{"line":"                if proof_zkapp_command.len() == checked_verification_keys.len()","counters":[]},{"line":"                    && checked_verification_keys == current_verification_keys","counters":[]},{"line":"                {","counters":[]},{"line":"                    true","counters":[]},{"line":"                } else {","counters":[]},{"line":"                    eprintln!(","counters":[]},{"line":"                        \"Staged_ledger_diff creation: Verifcation keys used for verifying \\","counters":[]},{"line":"                             proofs {:#?} and verification keys in the \\","counters":[]},{"line":"                             ledger {:#?} don't match\",","counters":[]},{"line":"                        checked_verification_keys, current_verification_keys","counters":[]},{"line":"                    );","counters":[]},{"line":"                    false","counters":[]},{"line":"                }","counters":[]},{"line":"            }","counters":[]},{"line":"            valid::UserCommand::SignedCommand(_) => true,","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/staged_ledger/staged_ledger.ml#L1863","counters":[]},{"line":"    fn create_diff<F>(","counters":[]},{"line":"        &self,","counters":[]},{"line":"        constraint_constants: &ConstraintConstants,","counters":[]},{"line":"        log_block_creation: Option<bool>,","counters":[]},{"line":"        coinbase_receiver: CompressedPubKey,","counters":[]},{"line":"        logger: (),","counters":[]},{"line":"        current_state_view: &ProtocolStateView,","counters":[]},{"line":"        transactions_by_fee: Vec<valid::UserCommand>,","counters":[]},{"line":"        get_completed_work: F,","counters":[]},{"line":"        supercharge_coinbase: bool,","counters":[]},{"line":"    ) -> Result<","counters":[]},{"line":"        (","counters":[]},{"line":"            with_valid_signatures_and_proofs::Diff,","counters":[]},{"line":"            Vec<(valid::UserCommand, String)>,","counters":[]},{"line":"        ),","counters":[]},{"line":"        PreDiffError,","counters":[]},{"line":"    >","counters":[]},{"line":"    where","counters":[]},{"line":"        F: Fn(&work::Statement) -> Option<work::Checked>,","counters":[]},{"line":"    {","counters":[]},{"line":"        use super::sparse_ledger::LedgerIntf;","counters":[]},{"line":"","counters":[]},{"line":"        let _log_block_creation = log_block_creation.unwrap_or(false);","counters":[]},{"line":"","counters":[]},{"line":"        let mut validating_ledger = HashlessLedger::create(self.ledger.clone());","counters":[]},{"line":"","counters":[]},{"line":"        let is_new_account = |pk: &CompressedPubKey| {","counters":[]},{"line":"            validating_ledger","counters":[]},{"line":"                .location_of_account(&AccountId::new(pk.clone(), TokenId::default()))","counters":[]},{"line":"                .is_none()","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        let is_coinbase_receiver_new = is_new_account(&coinbase_receiver);","counters":[]},{"line":"","counters":[]},{"line":"        if supercharge_coinbase {","counters":[]},{"line":"            // println!(\"No locked tokens in the delegator/delegatee account, applying supercharged coinbase\");","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        let partitions = self.scan_state.partition_if_overflowing();","counters":[]},{"line":"        let work_to_do = self.scan_state.work_statements_for_new_diff();","counters":[]},{"line":"","counters":[]},{"line":"        let mut completed_works_seq = Vec::with_capacity(work_to_do.len());","counters":[]},{"line":"        let mut proof_count = 0;","counters":[]},{"line":"","counters":[]},{"line":"        for work in work_to_do {","counters":[]},{"line":"            match get_completed_work(&work) {","counters":[]},{"line":"                Some(cw_checked) => {","counters":[]},{"line":"                    // If new provers can't pay the account-creation-fee then discard","counters":[]},{"line":"                    // their work unless their fee is zero in which case their account","counters":[]},{"line":"                    // won't be created. This is to encourage using an existing accounts","counters":[]},{"line":"                    // for snarking.","counters":[]},{"line":"                    // This also imposes new snarkers to have a min fee until one of","counters":[]},{"line":"                    // their snarks are purchased and their accounts get created*)","counters":[]},{"line":"","counters":[]},{"line":"                    if cw_checked.fee.is_zero()","counters":[]},{"line":"                        || cw_checked.fee >= constraint_constants.account_creation_fee","counters":[]},{"line":"                        || !(is_new_account(&cw_checked.prover))","counters":[]},{"line":"                    {","counters":[]},{"line":"                        proof_count += cw_checked.proofs.len();","counters":[]},{"line":"                        completed_works_seq.push(cw_checked);","counters":[]},{"line":"                    } else {","counters":[]},{"line":"                        eprintln!(","counters":[]},{"line":"                            \"Staged_ledger_diff creation: Snark fee {:?} \\","counters":[]},{"line":"                             insufficient to create the snark worker account\",","counters":[]},{"line":"                            cw_checked.fee,","counters":[]},{"line":"                        );","counters":[]},{"line":"                        break;","counters":[]},{"line":"                    }","counters":[]},{"line":"                }","counters":[]},{"line":"                None => {","counters":[]},{"line":"                    eprintln!(","counters":[]},{"line":"                        \"Staged_ledger_diff creation: No snark work found for {:#?}\",","counters":[]},{"line":"                        work","counters":[]},{"line":"                    );","counters":[]},{"line":"                    break;","counters":[]},{"line":"                }","counters":[]},{"line":"            }","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        // Transactions in reverse order for faster removal if there is no space when creating the diff","counters":[]},{"line":"","counters":[]},{"line":"        let length = transactions_by_fee.len();","counters":[]},{"line":"        let mut valid_on_this_ledger = Vec::with_capacity(length);","counters":[]},{"line":"        let mut invalid_on_this_ledger = Vec::with_capacity(length);","counters":[]},{"line":"        let mut count = 0;","counters":[]},{"line":"","counters":[]},{"line":"        let _transactions_by_fee_len = transactions_by_fee.len();","counters":[]},{"line":"","counters":[]},{"line":"        for txn in transactions_by_fee {","counters":[]},{"line":"            let res = Self::validate_account_update_proofs(logger, &validating_ledger, &txn)","counters":[]},{"line":"                .then_some(())","counters":[]},{"line":"                .ok_or_else(|| \"Verification key mismatch\".to_string())","counters":[]},{"line":"                .and_then(|_| {","counters":[]},{"line":"                    let txn = Transaction::Command(txn.forget_check());","counters":[]},{"line":"                    validating_ledger.apply_transaction(","counters":[]},{"line":"                        constraint_constants,","counters":[]},{"line":"                        current_state_view,","counters":[]},{"line":"                        &txn,","counters":[]},{"line":"                    )","counters":[]},{"line":"                });","counters":[]},{"line":"","counters":[]},{"line":"            match res {","counters":[]},{"line":"                Err(e) => {","counters":[]},{"line":"                    eprintln!(","counters":[]},{"line":"                        \"Staged_ledger_diff creation: Skipping user command: {:#?} due to error: {:?}\",","counters":[]},{"line":"                        txn, e","counters":[]},{"line":"                    );","counters":[]},{"line":"                    invalid_on_this_ledger.push((txn, e));","counters":[]},{"line":"                }","counters":[]},{"line":"                Ok(status) => {","counters":[]},{"line":"                    let txn_with_status = WithStatus { data: txn, status };","counters":[]},{"line":"                    valid_on_this_ledger.push(txn_with_status);","counters":[]},{"line":"                    count += 1;","counters":[]},{"line":"                    if count >= self.scan_state.free_space() {","counters":[]},{"line":"                        break;","counters":[]},{"line":"                    }","counters":[]},{"line":"                }","counters":[]},{"line":"            }","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        valid_on_this_ledger.reverse();","counters":[]},{"line":"        invalid_on_this_ledger.reverse();","counters":[]},{"line":"","counters":[]},{"line":"        let _valid_on_this_ledger_len = valid_on_this_ledger.len();","counters":[]},{"line":"","counters":[]},{"line":"        let (diff, _log) = Self::generate(","counters":[]},{"line":"            constraint_constants,","counters":[]},{"line":"            logger,","counters":[]},{"line":"            completed_works_seq,","counters":[]},{"line":"            valid_on_this_ledger,","counters":[]},{"line":"            &coinbase_receiver,","counters":[]},{"line":"            is_coinbase_receiver_new,","counters":[]},{"line":"            supercharge_coinbase,","counters":[]},{"line":"            partitions,","counters":[]},{"line":"        );","counters":[]},{"line":"","counters":[]},{"line":"        let diff = {","counters":[]},{"line":"            // Fill in the statuses for commands.","counters":[]},{"line":"            let mut status_ledger = HashlessLedger::create(self.ledger.clone());","counters":[]},{"line":"","counters":[]},{"line":"            let mut generate_status = |txn: Transaction| -> Result<TransactionStatus, String> {","counters":[]},{"line":"                status_ledger.apply_transaction(constraint_constants, current_state_view, &txn)","counters":[]},{"line":"            };","counters":[]},{"line":"","counters":[]},{"line":"            pre_diff_info::compute_statuses::<valid::UserCommand, valid::Transaction, _>(","counters":[]},{"line":"                constraint_constants,","counters":[]},{"line":"                diff,","counters":[]},{"line":"                coinbase_receiver,","counters":[]},{"line":"                Self::coinbase_amount(supercharge_coinbase, constraint_constants)","counters":[]},{"line":"                    .expect(\"OCaml throws here\"),","counters":[]},{"line":"                &mut generate_status,","counters":[]},{"line":"            )?","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        // curr_job_seq_no is incremented later, but for the logs we increment it now","counters":[]},{"line":"        println!(","counters":[]},{"line":"            \"sequence_number={:?}\",","counters":[]},{"line":"            self.scan_state.state.curr_job_seq_no.incr()","counters":[]},{"line":"        );","counters":[]},{"line":"","counters":[]},{"line":"        let _ = proof_count;","counters":[]},{"line":"        // println!(","counters":[]},{"line":"        //     \"Number of proofs ready for purchase: {} Number of user \\","counters":[]},{"line":"        //      commands ready to be included: {} Diff creation log: {:#?}\",","counters":[]},{"line":"        //     proof_count,","counters":[]},{"line":"        //     valid_on_this_ledger_len,","counters":[]},{"line":"        //     log.iter().map(|l| &l.summary).collect::<Vec<_>>()","counters":[]},{"line":"        // );","counters":[]},{"line":"","counters":[]},{"line":"        // if log_block_creation {","counters":[]},{"line":"        //     println!(\"Detailed diff creation log: {:#?}\", {","counters":[]},{"line":"        //         let mut details = log.iter().map(|l| &l.detail).collect::<Vec<_>>();","counters":[]},{"line":"        //         details.reverse();","counters":[]},{"line":"        //         details","counters":[]},{"line":"        //     })","counters":[]},{"line":"        // }","counters":[]},{"line":"","counters":[]},{"line":"        let diff = with_valid_signatures_and_proofs::Diff { diff };","counters":[]},{"line":"","counters":[]},{"line":"        Ok((diff, invalid_on_this_ledger))","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/05c2f73d0f6e4f1341286843814ce02dcb3919e0/src/lib/staged_ledger/staged_ledger.ml#L2024","counters":[]},{"line":"    fn latest_block_accounts_created(&self, previous_block_state_hash: Fp) -> Vec<AccountId> {","counters":[]},{"line":"        use scan_state::transaction_logic::transaction_applied::signed_command_applied::Body;","counters":[]},{"line":"        use scan_state::transaction_logic::transaction_applied::CommandApplied;","counters":[]},{"line":"        use scan_state::transaction_logic::transaction_applied::Varying;","counters":[]},{"line":"","counters":[]},{"line":"        let block_transactions_applied = {","counters":[]},{"line":"            let f = |TransactionWithWitness {","counters":[]},{"line":"                         transaction_with_info,","counters":[]},{"line":"                         state_hash: (leaf_block_hash, _),","counters":[]},{"line":"                         ..","counters":[]},{"line":"                     }: TransactionWithWitness| {","counters":[]},{"line":"                if leaf_block_hash == previous_block_state_hash {","counters":[]},{"line":"                    Some(transaction_with_info.varying)","counters":[]},{"line":"                } else {","counters":[]},{"line":"                    None","counters":[]},{"line":"                }","counters":[]},{"line":"            };","counters":[]},{"line":"","counters":[]},{"line":"            let latest = self.scan_state.base_jobs_on_latest_tree().filter_map(f);","counters":[]},{"line":"","counters":[]},{"line":"            let earlier = self.scan_state.base_jobs_on_earlier_tree(0).filter_map(f);","counters":[]},{"line":"","counters":[]},{"line":"            latest.chain(earlier)","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        block_transactions_applied","counters":[]},{"line":"            .flat_map(|cmd| match cmd {","counters":[]},{"line":"                Varying::Command(CommandApplied::SignedCommand(cmd)) => match cmd.body {","counters":[]},{"line":"                    Body::Payments { new_accounts } => new_accounts,","counters":[]},{"line":"                    Body::StakeDelegation { .. } => Vec::new(),","counters":[]},{"line":"                    Body::Failed => Vec::new(),","counters":[]},{"line":"                },","counters":[]},{"line":"                Varying::Command(CommandApplied::ZkappCommand(cmd)) => cmd.new_accounts,","counters":[]},{"line":"                Varying::FeeTransfer(ft) => ft.new_accounts,","counters":[]},{"line":"                Varying::Coinbase(cb) => cb.new_accounts,","counters":[]},{"line":"            })","counters":[]},{"line":"            .collect::<Vec<_>>()","counters":[]},{"line":"    }","counters":[]},{"line":"}","counters":[]},{"line":"","counters":[]},{"line":"#[cfg(test)]","counters":[]},{"line":"mod tests_ocaml {","counters":[]},{"line":"    use std::{","counters":[]},{"line":"        str::FromStr,","counters":[]},{"line":"        sync::atomic::{AtomicUsize, Ordering::Relaxed},","counters":[]},{"line":"    };","counters":[]},{"line":"","counters":[]},{"line":"    use ark_ec::{AffineCurve, ProjectiveCurve};","counters":[]},{"line":"    use ark_ff::{UniformRand, Zero};","counters":[]},{"line":"    use mina_curves::pasta::Fq;","counters":[]},{"line":"    use mina_signer::Signer;","counters":[]},{"line":"    use mina_signer::{Keypair, Signature};","counters":[]},{"line":"    use o1_utils::FieldHelpers;","counters":[]},{"line":"    use once_cell::sync::Lazy;","counters":[]},{"line":"    use rand::{seq::SliceRandom, CryptoRng, Rng};","counters":[]},{"line":"","counters":[]},{"line":"    use crate::{","counters":[]},{"line":"        dummy::{self, trivial_verification_key},","counters":[]},{"line":"        gen_keypair,","counters":[]},{"line":"        generators::{","counters":[]},{"line":"            user_command::sequence_zkapp_command_with_ledger, zkapp_command_builder, Failure,","counters":[]},{"line":"        },","counters":[]},{"line":"        scan_state::{","counters":[]},{"line":"            currency::{Balance, BlockTime, Fee, Length, Nonce},","counters":[]},{"line":"            scan_state::transaction_snark::SokDigest,","counters":[]},{"line":"            transaction_logic::{","counters":[]},{"line":"                protocol_state::{EpochData, EpochLedger},","counters":[]},{"line":"                signed_command::{","counters":[]},{"line":"                    self, Common, PaymentPayload, SignedCommand, SignedCommandPayload,","counters":[]},{"line":"                },","counters":[]},{"line":"                transaction_union_payload::TransactionUnionPayload,","counters":[]},{"line":"                zkapp_command::{self, SetOrKeep, WithHash},","counters":[]},{"line":"                Memo, TransactionFailure,","counters":[]},{"line":"            },","counters":[]},{"line":"        },","counters":[]},{"line":"        staged_ledger::{","counters":[]},{"line":"            diff::{PreDiffOne, PreDiffWithAtMostOneCoinbase, PreDiffWithAtMostTwoCoinbase},","counters":[]},{"line":"            pre_diff_info::HashableCompressedPubKey,","counters":[]},{"line":"        },","counters":[]},{"line":"        util, AuthRequired, FpExt, Permissions, VerificationKey,","counters":[]},{"line":"    };","counters":[]},{"line":"","counters":[]},{"line":"    use super::*;","counters":[]},{"line":"","counters":[]},{"line":"    // const","counters":[]},{"line":"","counters":[]},{"line":"    static SELF_PK: Lazy<CompressedPubKey> = Lazy::new(|| gen_keypair().public.into_compressed());","counters":[]},{"line":"","counters":[]},{"line":"    static COINBASE_RECEIVER: Lazy<CompressedPubKey> = Lazy::new(|| {","counters":[]},{"line":"        CompressedPubKey::from_address(\"B62qmkso2Knz9pxo5V9YEZFJ9Frq57GZfKgem1DVTKiYH9D5H3n2DGS\")","counters":[]},{"line":"            .unwrap()","counters":[]},{"line":"    });","counters":[]},{"line":"    // Lazy::new(|| gen_keypair().public.into_compressed());","counters":[]},{"line":"","counters":[]},{"line":"    /// Same values when we run `dune runtest src/lib/staged_ledger -f`","counters":[]},{"line":"    const CONSTRAINT_CONSTANTS: ConstraintConstants = ConstraintConstants {","counters":[]},{"line":"        sub_windows_per_window: 11,","counters":[]},{"line":"        ledger_depth: 35,","counters":[]},{"line":"        work_delay: 2,","counters":[]},{"line":"        block_window_duration_ms: 180000,","counters":[]},{"line":"        transaction_capacity_log_2: 7,","counters":[]},{"line":"        pending_coinbase_depth: 5,","counters":[]},{"line":"        coinbase_amount: Amount::from_u64(720000000000),","counters":[]},{"line":"        supercharged_coinbase_factor: 2,","counters":[]},{"line":"        account_creation_fee: Fee::from_u64(1000000000),","counters":[]},{"line":"        fork: None,","counters":[]},{"line":"    };","counters":[]},{"line":"","counters":[]},{"line":"    const LOGGER: () = ();","counters":[]},{"line":"","counters":[]},{"line":"    const VERIFIER: Verifier = Verifier;","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L2092","counters":[]},{"line":"    fn supercharge_coinbase(ledger: Mask, winner: CompressedPubKey, global_slot: Slot) -> bool {","counters":[]},{"line":"        // using staged ledger to confirm coinbase amount is correctly generated","counters":[]},{"line":"","counters":[]},{"line":"        let epoch_ledger = SparseLedger::of_ledger_subset_exn(","counters":[]},{"line":"            ledger,","counters":[]},{"line":"            &[AccountId::new(winner.clone(), TokenId::default())],","counters":[]},{"line":"        );","counters":[]},{"line":"","counters":[]},{"line":"        StagedLedger::can_apply_supercharged_coinbase_exn(winner, &epoch_ledger, global_slot)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// Functor for testing with different instantiated staged ledger modules.","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L2102","counters":[]},{"line":"    fn create_and_apply_with_state_body_hash<F>(","counters":[]},{"line":"        coinbase_receiver: Option<CompressedPubKey>,","counters":[]},{"line":"        winner: Option<CompressedPubKey>,","counters":[]},{"line":"        current_state_view: &ProtocolStateView,","counters":[]},{"line":"        state_and_body_hash: (Fp, Fp),","counters":[]},{"line":"        sl: &mut StagedLedger,","counters":[]},{"line":"        txns: &[valid::UserCommand],","counters":[]},{"line":"        stmt_to_work: F,","counters":[]},{"line":"    ) -> (","counters":[]},{"line":"        Option<(LedgerProof, Vec<(WithStatus<Transaction>, Fp)>)>,","counters":[]},{"line":"        Diff,","counters":[]},{"line":"        bool,","counters":[]},{"line":"        Update,","counters":[]},{"line":"        bool,","counters":[]},{"line":"    )","counters":[]},{"line":"    where","counters":[]},{"line":"        F: Fn(&work::Statement) -> Option<work::Unchecked>,","counters":[]},{"line":"    {","counters":[]},{"line":"        let coinbase_receiver = coinbase_receiver.unwrap_or_else(|| COINBASE_RECEIVER.clone());","counters":[]},{"line":"        let winner = winner.unwrap_or_else(|| SELF_PK.clone());","counters":[]},{"line":"","counters":[]},{"line":"        let supercharge_coinbase = supercharge_coinbase(","counters":[]},{"line":"            sl.ledger.clone(),","counters":[]},{"line":"            winner,","counters":[]},{"line":"            current_state_view.global_slot_since_genesis,","counters":[]},{"line":"        );","counters":[]},{"line":"","counters":[]},{"line":"        let (diff, _invalid_txns) = sl","counters":[]},{"line":"            .create_diff(","counters":[]},{"line":"                &CONSTRAINT_CONSTANTS,","counters":[]},{"line":"                None,","counters":[]},{"line":"                coinbase_receiver.clone(),","counters":[]},{"line":"                LOGGER,","counters":[]},{"line":"                current_state_view,","counters":[]},{"line":"                txns.to_vec(),","counters":[]},{"line":"                stmt_to_work,","counters":[]},{"line":"                supercharge_coinbase,","counters":[]},{"line":"            )","counters":[]},{"line":"            .unwrap();","counters":[]},{"line":"","counters":[]},{"line":"        let diff = diff.forget();","counters":[]},{"line":"","counters":[]},{"line":"        let DiffResult {","counters":[]},{"line":"            hash_after_applying: hash,","counters":[]},{"line":"            ledger_proof,","counters":[]},{"line":"            pending_coinbase_update: (is_new_stack, pc_update),","counters":[]},{"line":"        } = sl","counters":[]},{"line":"            .apply(","counters":[]},{"line":"                None,","counters":[]},{"line":"                &CONSTRAINT_CONSTANTS,","counters":[]},{"line":"                diff.clone(),","counters":[]},{"line":"                LOGGER,","counters":[]},{"line":"                &VERIFIER,","counters":[]},{"line":"                current_state_view,","counters":[]},{"line":"                state_and_body_hash,","counters":[]},{"line":"                coinbase_receiver,","counters":[]},{"line":"                supercharge_coinbase,","counters":[]},{"line":"            )","counters":[]},{"line":"            .unwrap();","counters":[]},{"line":"","counters":[]},{"line":"        assert_eq!(hash, sl.hash());","counters":[]},{"line":"","counters":[]},{"line":"        (","counters":[]},{"line":"            ledger_proof,","counters":[]},{"line":"            diff,","counters":[]},{"line":"            is_new_stack,","counters":[]},{"line":"            pc_update,","counters":[]},{"line":"            supercharge_coinbase,","counters":[]},{"line":"        )","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    #[derive(Debug)]","counters":[]},{"line":"    struct LedgerInitialState {","counters":[]},{"line":"        state: Vec<(Keypair, Amount, Nonce, crate::account::Timing)>,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn gen<T>(n_accounts: usize, fun: impl FnMut() -> T) -> Vec<T> {","counters":[]},{"line":"        std::iter::repeat_with(fun)","counters":[]},{"line":"            .take(n_accounts)","counters":[]},{"line":"            .collect::<Vec<_>>()","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3a78f0e0c1343d14e2729c8b00205baa2ec70c93/src/lib/mina_ledger/ledger.ml#L408","counters":[]},{"line":"    fn gen_initial_ledger_state() -> LedgerInitialState {","counters":[]},{"line":"        let mut rng = rand::thread_rng();","counters":[]},{"line":"","counters":[]},{"line":"        let n_accounts = rng.gen_range(2..10);","counters":[]},{"line":"","counters":[]},{"line":"        let keypairs = gen(n_accounts, gen_keypair);","counters":[]},{"line":"        let balances = gen(n_accounts, || {","counters":[]},{"line":"            let balance: u64 = rng.gen_range(500_000_000..1_000_000_000);","counters":[]},{"line":"            Amount::from_u64(balance.checked_mul(1_000_000_000).unwrap())","counters":[]},{"line":"        });","counters":[]},{"line":"        let nonces = gen(n_accounts, || {","counters":[]},{"line":"            let nonce: u32 = rng.gen_range(0..1000);","counters":[]},{"line":"            Nonce::from_u32(nonce)","counters":[]},{"line":"        });","counters":[]},{"line":"","counters":[]},{"line":"        let state = keypairs","counters":[]},{"line":"            .into_iter()","counters":[]},{"line":"            .zip(balances)","counters":[]},{"line":"            .zip(nonces)","counters":[]},{"line":"            .map(|((keypair, balance), nonce)| {","counters":[]},{"line":"                (keypair, balance, nonce, crate::account::Timing::Untimed)","counters":[]},{"line":"            })","counters":[]},{"line":"            .collect();","counters":[]},{"line":"","counters":[]},{"line":"        LedgerInitialState { state }","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// How many blocks do we need to fully exercise the ledger","counters":[]},{"line":"    /// behavior and produce one ledger proof *)","counters":[]},{"line":"    const MIN_BLOCKS_FOR_FIRST_SNARKED_LEDGER_GENERIC: usize =","counters":[]},{"line":"        (CONSTRAINT_CONSTANTS.transaction_capacity_log_2 as usize + 1)","counters":[]},{"line":"            * (CONSTRAINT_CONSTANTS.work_delay as usize + 1)","counters":[]},{"line":"            + 1;","counters":[]},{"line":"","counters":[]},{"line":"    const TRANSACTION_CAPACITY: usize =","counters":[]},{"line":"        2u64.pow(CONSTRAINT_CONSTANTS.transaction_capacity_log_2 as u32) as usize;","counters":[]},{"line":"","counters":[]},{"line":"    // let transaction_capacity =","counters":[]},{"line":"    //   Int.pow 2 constraint_constants.transaction_capacity_log_2","counters":[]},{"line":"","counters":[]},{"line":"    /// n-1 extra blocks for n ledger proofs since we are already producing one","counters":[]},{"line":"    /// proof *)","counters":[]},{"line":"    fn max_blocks_for_coverage(n: usize) -> usize {","counters":[]},{"line":"        MIN_BLOCKS_FOR_FIRST_SNARKED_LEDGER_GENERIC + n - 1","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    #[derive(Debug, Copy, Clone)]","counters":[]},{"line":"    enum SignKind {","counters":[]},{"line":"        Fake,","counters":[]},{"line":"        Real,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// [gen_division n k] generates a list of [k] integers which sum to [n]","counters":[]},{"line":"    /// val gen_division : int -> int -> int list Generator.t","counters":[]},{"line":"    fn gen_division(n: usize, k: usize) -> Vec<usize> {","counters":[]},{"line":"        // TODO: Improve that","counters":[]},{"line":"","counters":[]},{"line":"        let mut rng = rand::thread_rng();","counters":[]},{"line":"        let mut sum = 0;","counters":[]},{"line":"","counters":[]},{"line":"        let vec = (0..k)","counters":[]},{"line":"            .map(|index| {","counters":[]},{"line":"                let int = rng.gen_range(1..(n / k) - 1);","counters":[]},{"line":"","counters":[]},{"line":"                let int = if index == k - 1 {","counters":[]},{"line":"                    n - sum","counters":[]},{"line":"                } else {","counters":[]},{"line":"                    int.min(n - sum)","counters":[]},{"line":"                };","counters":[]},{"line":"","counters":[]},{"line":"                sum += int;","counters":[]},{"line":"                int","counters":[]},{"line":"            })","counters":[]},{"line":"            .collect::<Vec<_>>();","counters":[]},{"line":"","counters":[]},{"line":"        assert_eq!(vec.len(), k);","counters":[]},{"line":"        assert_eq!(vec.iter().sum::<usize>(), n);","counters":[]},{"line":"","counters":[]},{"line":"        vec","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn gen_division_currency(amount: Amount, k: usize) -> Vec<Amount> {","counters":[]},{"line":"        let amount = amount.as_u64() as usize;","counters":[]},{"line":"        gen_division(amount, k)","counters":[]},{"line":"            .into_iter()","counters":[]},{"line":"            .map(|amount| Amount::from_u64(amount as u64))","counters":[]},{"line":"            .collect()","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn signed_command_sequence_impl(","counters":[]},{"line":"        length: usize,","counters":[]},{"line":"        sign_kind: SignKind,","counters":[]},{"line":"        ledger: &LedgerInitialState,","counters":[]},{"line":"    ) -> Result<Vec<valid::SignedCommand>, ()> {","counters":[]},{"line":"        use scan_state::transaction_logic::signed_command::Body;","counters":[]},{"line":"","counters":[]},{"line":"        let mut rng = rand::thread_rng();","counters":[]},{"line":"        let n_commands = length;","counters":[]},{"line":"","counters":[]},{"line":"        if n_commands == 0 {","counters":[]},{"line":"            return Ok(vec![]);","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        let n_accounts = ledger.state.len();","counters":[]},{"line":"","counters":[]},{"line":"        let (command_senders, mut currency_splits) = loop {","counters":[]},{"line":"            // How many commands will be issued from each account?","counters":[]},{"line":"            let command_splits = gen_division(n_commands, n_accounts);","counters":[]},{"line":"","counters":[]},{"line":"            // List of payment senders in the final order.","counters":[]},{"line":"            let mut command_senders = command_splits","counters":[]},{"line":"                .iter()","counters":[]},{"line":"                .enumerate()","counters":[]},{"line":"                .flat_map(|(idx, cmds)| vec![idx; *cmds])","counters":[]},{"line":"                .collect::<Vec<_>>();","counters":[]},{"line":"            command_senders.shuffle(&mut rng);","counters":[]},{"line":"","counters":[]},{"line":"            // within the accounts, how will the currency be split into separate","counters":[]},{"line":"            // payments?","counters":[]},{"line":"            let currency_splits = (0..n_accounts)","counters":[]},{"line":"                .map(|i| {","counters":[]},{"line":"                    let spend_all: bool = rng.gen();","counters":[]},{"line":"                    let (_, balance, _, _) = &ledger.state[i];","counters":[]},{"line":"                    let amount_to_spend = if spend_all {","counters":[]},{"line":"                        *balance","counters":[]},{"line":"                    } else {","counters":[]},{"line":"                        Amount::from_u64(balance.as_u64() / 2)","counters":[]},{"line":"                    };","counters":[]},{"line":"","counters":[]},{"line":"                    gen_division_currency(amount_to_spend, command_splits[i])","counters":[]},{"line":"                })","counters":[]},{"line":"                .collect::<Vec<_>>();","counters":[]},{"line":"","counters":[]},{"line":"            // We need to ensure each command has enough currency for a fee of 2","counters":[]},{"line":"            // or more, so it'll be enough to buy the requisite transaction","counters":[]},{"line":"            // snarks. It's important that the backtracking from filter goes and","counters":[]},{"line":"            // redraws command_splits as well as currency_splits, so we don't get","counters":[]},{"line":"            // stuck in a situation where it's very unlikely for the predicate to","counters":[]},{"line":"            // pass.","counters":[]},{"line":"            if currency_splits.iter().all(|list| {","counters":[]},{"line":"                !list.is_empty()","counters":[]},{"line":"                    && list","counters":[]},{"line":"                        .iter()","counters":[]},{"line":"                        .all(|amount| amount >= &Amount::from_u64(2_000_000_000))","counters":[]},{"line":"            }) {","counters":[]},{"line":"                break (command_senders, currency_splits);","counters":[]},{"line":"            }","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        let mut account_nonces: Vec<Nonce> =","counters":[]},{"line":"            ledger.state.iter().map(|(_, _, nonce, _)| *nonce).collect();","counters":[]},{"line":"","counters":[]},{"line":"        command_senders","counters":[]},{"line":"            .into_iter()","counters":[]},{"line":"            .enumerate()","counters":[]},{"line":"            .map(|(number, sender)| {","counters":[]},{"line":"                if currency_splits[sender].is_empty() {","counters":[]},{"line":"                    return Err(());","counters":[]},{"line":"                }","counters":[]},{"line":"","counters":[]},{"line":"                let (this_split, rest_splits) = currency_splits[sender].split_at(1);","counters":[]},{"line":"                let this_split = this_split[0];","counters":[]},{"line":"","counters":[]},{"line":"                let (sender_pk, _, _, _) = &ledger.state[sender];","counters":[]},{"line":"","counters":[]},{"line":"                currency_splits[sender] = rest_splits.to_vec();","counters":[]},{"line":"","counters":[]},{"line":"                let nonce = account_nonces[sender];","counters":[]},{"line":"                account_nonces[sender] = nonce.incr();","counters":[]},{"line":"","counters":[]},{"line":"                // println!(\"this={:?}\", this_split);","counters":[]},{"line":"                let min = 6000000000;","counters":[]},{"line":"                let fee = rng.gen_range(min..(10000000000.min(this_split.as_u64()).max(min + 1)));","counters":[]},{"line":"                let fee = Fee::from_u64(fee);","counters":[]},{"line":"","counters":[]},{"line":"                let amount = match this_split.checked_sub(&Amount::of_fee(&fee)) {","counters":[]},{"line":"                    Some(amount) => amount,","counters":[]},{"line":"                    None => return Err(()),","counters":[]},{"line":"                };","counters":[]},{"line":"","counters":[]},{"line":"                let receiver = {","counters":[]},{"line":"                    // Take random item in `ledger.state`","counters":[]},{"line":"                    let (kp, _, _, _) = ledger.state.choose(&mut rng).unwrap();","counters":[]},{"line":"                    kp.public.into_compressed()","counters":[]},{"line":"                };","counters":[]},{"line":"","counters":[]},{"line":"                // let memo = Memo::dummy();","counters":[]},{"line":"                let memo = Memo::with_number(number);","counters":[]},{"line":"","counters":[]},{"line":"                let payload = {","counters":[]},{"line":"                    let sender_pk = sender_pk.public.into_compressed();","counters":[]},{"line":"","counters":[]},{"line":"                    SignedCommandPayload::create(","counters":[]},{"line":"                        fee,","counters":[]},{"line":"                        sender_pk.clone(),","counters":[]},{"line":"                        nonce,","counters":[]},{"line":"                        None,","counters":[]},{"line":"                        memo,","counters":[]},{"line":"                        Body::Payment(PaymentPayload {","counters":[]},{"line":"                            source_pk: sender_pk,","counters":[]},{"line":"                            receiver_pk: receiver,","counters":[]},{"line":"                            amount,","counters":[]},{"line":"                        }),","counters":[]},{"line":"                    )","counters":[]},{"line":"                };","counters":[]},{"line":"","counters":[]},{"line":"                let signature = match sign_kind {","counters":[]},{"line":"                    SignKind::Fake => Signature::dummy(),","counters":[]},{"line":"                    SignKind::Real => {","counters":[]},{"line":"                        let payload_to_sign =","counters":[]},{"line":"                            TransactionUnionPayload::of_user_command_payload(&payload);","counters":[]},{"line":"","counters":[]},{"line":"                        let mut signer =","counters":[]},{"line":"                            mina_signer::create_legacy(mina_signer::NetworkId::TESTNET);","counters":[]},{"line":"                        signer.sign(sender_pk, &payload_to_sign)","counters":[]},{"line":"                    }","counters":[]},{"line":"                };","counters":[]},{"line":"","counters":[]},{"line":"                Ok(SignedCommand {","counters":[]},{"line":"                    payload,","counters":[]},{"line":"                    signer: sender_pk.public.into_compressed(),","counters":[]},{"line":"                    signature,","counters":[]},{"line":"                })","counters":[]},{"line":"            })","counters":[]},{"line":"            .collect::<Result<Vec<_>, ()>>()","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// Generate a valid sequence of payments based on the initial state of a","counters":[]},{"line":"    /// ledger. Use this together with Ledger.gen_initial_ledger_state.","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3a78f0e0c1343d14e2729c8b00205baa2ec70c93/src/lib/mina_base/signed_command.ml#L246","counters":[]},{"line":"    fn signed_command_sequence(","counters":[]},{"line":"        length: usize,","counters":[]},{"line":"        sign_kind: SignKind,","counters":[]},{"line":"        ledger: &LedgerInitialState,","counters":[]},{"line":"    ) -> Vec<valid::UserCommand> {","counters":[]},{"line":"        // Not clean but it's what OCaml does when an exception is throwned, if I understand correctly","counters":[]},{"line":"        for _ in 0..100 {","counters":[]},{"line":"            if let Ok(commands) = signed_command_sequence_impl(length, sign_kind, ledger) {","counters":[]},{"line":"                return commands","counters":[]},{"line":"                    .into_iter()","counters":[]},{"line":"                    .map(|cmd| valid::UserCommand::SignedCommand(Box::new(cmd)))","counters":[]},{"line":"                    .collect();","counters":[]},{"line":"            };","counters":[]},{"line":"        }","counters":[]},{"line":"        panic!(\"Failed to generate random user commands\");","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// Same as gen_at_capacity except that the number of iterations[iters] is","counters":[]},{"line":"    /// the function of [extra_block_count] and is same for all generated values","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L2597","counters":[]},{"line":"    fn gen_at_capacity_fixed_blocks(","counters":[]},{"line":"        extra_block_count: usize,","counters":[]},{"line":"    ) -> (","counters":[]},{"line":"        LedgerInitialState,","counters":[]},{"line":"        Vec<valid::UserCommand>,","counters":[]},{"line":"        Vec<Option<usize>>,","counters":[]},{"line":"    ) {","counters":[]},{"line":"        let state = gen_initial_ledger_state();","counters":[]},{"line":"        let iters = max_blocks_for_coverage(extra_block_count);","counters":[]},{"line":"        let total_cmds = TRANSACTION_CAPACITY * iters;","counters":[]},{"line":"","counters":[]},{"line":"        let cmds = signed_command_sequence(total_cmds, SignKind::Real, &state);","counters":[]},{"line":"        assert_eq!(cmds.len(), total_cmds);","counters":[]},{"line":"","counters":[]},{"line":"        (state, cmds, vec![None; iters])","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn apply_initialize_ledger_state(mask: &mut Mask, init_state: &LedgerInitialState) {","counters":[]},{"line":"        use crate::staged_ledger::sparse_ledger::LedgerIntf;","counters":[]},{"line":"","counters":[]},{"line":"        for (kp, balance, nonce, timing) in &init_state.state {","counters":[]},{"line":"            let pk_compressed = kp.public.into_compressed();","counters":[]},{"line":"            let account_id = AccountId::new(pk_compressed, TokenId::default());","counters":[]},{"line":"            let mut account = Account::initialize(&account_id);","counters":[]},{"line":"            account.balance = Balance::from_u64(balance.as_u64());","counters":[]},{"line":"            account.nonce = *nonce;","counters":[]},{"line":"            account.timing = timing.clone();","counters":[]},{"line":"","counters":[]},{"line":"            mask.create_new_account(account_id, account).unwrap();","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    static NITERS: AtomicUsize = AtomicUsize::new(0);","counters":[]},{"line":"","counters":[]},{"line":"    /// Run the given function inside of the Deferred monad, with a staged","counters":[]},{"line":"    ///   ledger and a separate test ledger, after applying the given","counters":[]},{"line":"    ///   init_state to both. In the below tests we apply the same commands to","counters":[]},{"line":"    ///   the staged and test ledgers, and verify they are in the same state.","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L2180","counters":[]},{"line":"    fn async_with_given_ledger<F, R>(","counters":[]},{"line":"        _ledger_init_state: &LedgerInitialState,","counters":[]},{"line":"        cmds: Vec<valid::UserCommand>,","counters":[]},{"line":"        cmd_iters: Vec<Option<usize>>,","counters":[]},{"line":"        mask: Mask,","counters":[]},{"line":"        fun: F,","counters":[]},{"line":"    ) where","counters":[]},{"line":"        F: Fn(StagedLedger, Mask) -> R + std::panic::UnwindSafe,","counters":[]},{"line":"    {","counters":[]},{"line":"        match std::panic::catch_unwind(move || {","counters":[]},{"line":"            let test_mask = mask.make_child();","counters":[]},{"line":"            let sl = StagedLedger::create_exn(CONSTRAINT_CONSTANTS, mask).unwrap();","counters":[]},{"line":"            fun(sl, test_mask.clone());","counters":[]},{"line":"            test_mask.unregister_mask(crate::UnregisterBehavior::Check);","counters":[]},{"line":"        }) {","counters":[]},{"line":"            Ok(_) => {}","counters":[]},{"line":"            Err(_) => {","counters":[]},{"line":"                let niters = NITERS.load(Relaxed);","counters":[]},{"line":"                let iters = cmd_iters","counters":[]},{"line":"                    .iter()","counters":[]},{"line":"                    .filter_map(|n| n.as_ref())","counters":[]},{"line":"                    .take(niters + 1)","counters":[]},{"line":"                    .collect::<Vec<_>>();","counters":[]},{"line":"","counters":[]},{"line":"                println!(\"NITERS_LA={}\", niters);","counters":[]},{"line":"                eprintln!(\"state={:#?}\", \"ignored\");","counters":[]},{"line":"                // eprintln!(\"state={:#?}\", ledger_init_state);","counters":[]},{"line":"                eprintln!(\"cmds[{}]={:#?}\", cmds.len(), \"ignored\");","counters":[]},{"line":"                // eprintln!(\"cmds[{}]={:#?}\", cmds.len(), cmds);","counters":[]},{"line":"                eprintln!(\"cmd_iters[{}]={:?}\", iters.len(), iters);","counters":[]},{"line":"                panic!(\"test failed (see logs above)\");","counters":[]},{"line":"            }","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// populate the ledger from an initial state before running the function","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// Print the generated state when a panic occurs","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L2192","counters":[]},{"line":"    fn async_with_ledgers<F, R>(","counters":[]},{"line":"        ledger_init_state: &LedgerInitialState,","counters":[]},{"line":"        cmds: Vec<valid::UserCommand>,","counters":[]},{"line":"        cmd_iters: Vec<Option<usize>>,","counters":[]},{"line":"        fun: F,","counters":[]},{"line":"    ) where","counters":[]},{"line":"        F: Fn(StagedLedger, Mask) -> R + std::panic::UnwindSafe,","counters":[]},{"line":"    {","counters":[]},{"line":"        let mut ephemeral_ledger = Mask::new_unattached(CONSTRAINT_CONSTANTS.ledger_depth as usize);","counters":[]},{"line":"","counters":[]},{"line":"        apply_initialize_ledger_state(&mut ephemeral_ledger, ledger_init_state);","counters":[]},{"line":"        async_with_given_ledger(ledger_init_state, cmds, cmd_iters, ephemeral_ledger, fun);","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// Get the public keys from a ledger init state.","counters":[]},{"line":"    fn init_pks(init: &LedgerInitialState) -> Vec<AccountId> {","counters":[]},{"line":"        init.state","counters":[]},{"line":"            .iter()","counters":[]},{"line":"            .map(|(kp, _, _, _)| AccountId::new(kp.public.into_compressed(), TokenId::default()))","counters":[]},{"line":"            .collect()","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    #[derive(Copy, Debug, Clone)]","counters":[]},{"line":"    enum NumProvers {","counters":[]},{"line":"        One,","counters":[]},{"line":"        Many,","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// Abstraction for the pattern of taking a list of commands and applying it","counters":[]},{"line":"    /// in chunks up to a given max size.","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L2392","counters":[]},{"line":"    fn iter_cmds_acc<A, F>(","counters":[]},{"line":"        cmds: &[valid::UserCommand],","counters":[]},{"line":"        cmd_iters: &[Option<usize>],","counters":[]},{"line":"        acc: A,","counters":[]},{"line":"        mut fun: F,","counters":[]},{"line":"    ) -> A","counters":[]},{"line":"    where","counters":[]},{"line":"        F: FnMut(","counters":[]},{"line":"            &[valid::UserCommand], // all remaining commands","counters":[]},{"line":"            Option<usize>,         // Current chunk size.","counters":[]},{"line":"            &[valid::UserCommand], // Sequence of commands to apply.","counters":[]},{"line":"            A,","counters":[]},{"line":"        ) -> (Diff, A),","counters":[]},{"line":"    {","counters":[]},{"line":"        match cmd_iters.first() {","counters":[]},{"line":"            None => acc,","counters":[]},{"line":"            Some(count_opt) => {","counters":[]},{"line":"                let cmds_this_iter_max = match count_opt {","counters":[]},{"line":"                    None => cmds,","counters":[]},{"line":"                    Some(count) => {","counters":[]},{"line":"                        assert!(*count <= cmds.len());","counters":[]},{"line":"                        util::take(cmds, *count)","counters":[]},{"line":"                    }","counters":[]},{"line":"                };","counters":[]},{"line":"","counters":[]},{"line":"                let (diff, acc) = fun(cmds, *count_opt, cmds_this_iter_max, acc);","counters":[]},{"line":"","counters":[]},{"line":"                let cmds_applied_count = diff.commands().len();","counters":[]},{"line":"","counters":[]},{"line":"                let cmds = util::drop(cmds, cmds_applied_count).to_vec();","counters":[]},{"line":"                let counts_rest = &cmd_iters[1..];","counters":[]},{"line":"","counters":[]},{"line":"                iter_cmds_acc(&cmds, counts_rest, acc, fun)","counters":[]},{"line":"            }","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// Same values when we run `dune runtest src/lib/staged_ledger -f`","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L2142","counters":[]},{"line":"    fn dummy_state_view(global_slot_since_genesis: Option<Slot>) -> ProtocolStateView {","counters":[]},{"line":"        // TODO: Use OCaml implementation, not hardcoded value","counters":[]},{"line":"","counters":[]},{"line":"        let f = |s: &str| Fp::from_str(s).unwrap();","counters":[]},{"line":"","counters":[]},{"line":"        ProtocolStateView {","counters":[]},{"line":"            snarked_ledger_hash: f(\"19095410909873291354237217869735884756874834695933531743203428046904386166496\"),","counters":[]},{"line":"            timestamp: BlockTime::from_u64(1600251300000),","counters":[]},{"line":"            blockchain_length: Length::from_u32(1),","counters":[]},{"line":"            min_window_density: Length::from_u32(77),","counters":[]},{"line":"            last_vrf_output: (),","counters":[]},{"line":"            total_currency: Amount::from_u64(10016100000000000),","counters":[]},{"line":"            global_slot_since_hard_fork: Slot::from_u32(0),","counters":[]},{"line":"            global_slot_since_genesis: global_slot_since_genesis.unwrap_or_else(Slot::zero),","counters":[]},{"line":"            staking_epoch_data: EpochData {","counters":[]},{"line":"                ledger: EpochLedger {","counters":[]},{"line":"                    hash: f(\"19095410909873291354237217869735884756874834695933531743203428046904386166496\"),","counters":[]},{"line":"                    total_currency: Amount::from_u64(10016100000000000),","counters":[]},{"line":"                },","counters":[]},{"line":"                seed: Fp::zero(),","counters":[]},{"line":"                start_checkpoint: Fp::zero(),","counters":[]},{"line":"                lock_checkpoint: Fp::zero(),","counters":[]},{"line":"                epoch_length: Length::from_u32(1),","counters":[]},{"line":"            },","counters":[]},{"line":"            next_epoch_data: EpochData {","counters":[]},{"line":"                ledger: EpochLedger {","counters":[]},{"line":"                    hash: f(\"19095410909873291354237217869735884756874834695933531743203428046904386166496\"),","counters":[]},{"line":"                    total_currency: Amount::from_u64(10016100000000000),","counters":[]},{"line":"                },","counters":[]},{"line":"                seed: f(\"18512313064034685696641580142878809378857342939026666126913761777372978255172\"),","counters":[]},{"line":"                start_checkpoint: Fp::zero(),","counters":[]},{"line":"                lock_checkpoint: f(\"9196091926153144288494889289330016873963015481670968646275122329689722912273\"),","counters":[]},{"line":"                epoch_length: Length::from_u32(2),","counters":[]},{"line":"            }","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L2164","counters":[]},{"line":"    fn create_and_apply<F>(","counters":[]},{"line":"        coinbase_receiver: Option<CompressedPubKey>,","counters":[]},{"line":"        winner: Option<CompressedPubKey>,","counters":[]},{"line":"        sl: &mut StagedLedger,","counters":[]},{"line":"        txns: &[valid::UserCommand],","counters":[]},{"line":"        stmt_to_work: F,","counters":[]},{"line":"    ) -> (","counters":[]},{"line":"        Option<(LedgerProof, Vec<(WithStatus<Transaction>, Fp)>)>,","counters":[]},{"line":"        Diff,","counters":[]},{"line":"    )","counters":[]},{"line":"    where","counters":[]},{"line":"        F: Fn(&work::Statement) -> Option<work::Checked>,","counters":[]},{"line":"    {","counters":[]},{"line":"        let (ledger_proof, diff, _, _, _) = create_and_apply_with_state_body_hash(","counters":[]},{"line":"            coinbase_receiver,","counters":[]},{"line":"            winner,","counters":[]},{"line":"            &dummy_state_view(None),","counters":[]},{"line":"            (Fp::zero(), Fp::zero()),","counters":[]},{"line":"            sl,","counters":[]},{"line":"            txns,","counters":[]},{"line":"            stmt_to_work,","counters":[]},{"line":"        );","counters":[]},{"line":"        (ledger_proof, diff)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// Fee excess at top level ledger proofs should always be zero","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L2377","counters":[]},{"line":"    fn assert_fee_excess(proof: &Option<(LedgerProof, Vec<(WithStatus<Transaction>, Fp)>)>) {","counters":[]},{"line":"        if let Some((proof, _txns)) = proof {","counters":[]},{"line":"            assert!(proof.statement().fee_excess.is_zero());","counters":[]},{"line":"        };","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L2322","counters":[]},{"line":"    fn coinbase_first_prediff(","counters":[]},{"line":"        v: &AtMostTwo<CoinbaseFeeTransfer>,","counters":[]},{"line":"    ) -> (usize, Vec<&CoinbaseFeeTransfer>) {","counters":[]},{"line":"        match v {","counters":[]},{"line":"            AtMostTwo::Zero => (0, vec![]),","counters":[]},{"line":"            AtMostTwo::One(None) => (1, vec![]),","counters":[]},{"line":"            AtMostTwo::One(Some(ft)) => (1, vec![ft]),","counters":[]},{"line":"            AtMostTwo::Two(None) => (2, vec![]),","counters":[]},{"line":"            AtMostTwo::Two(Some((ft, None))) => (2, vec![ft]),","counters":[]},{"line":"            AtMostTwo::Two(Some((ft, Some(ft2)))) => (2, vec![ft, ft2]),","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L2336","counters":[]},{"line":"    fn coinbase_second_prediff(","counters":[]},{"line":"        v: &AtMostOne<CoinbaseFeeTransfer>,","counters":[]},{"line":"    ) -> (usize, Vec<&CoinbaseFeeTransfer>) {","counters":[]},{"line":"        match v {","counters":[]},{"line":"            AtMostOne::Zero => (0, vec![]),","counters":[]},{"line":"            AtMostOne::One(None) => (1, vec![]),","counters":[]},{"line":"            AtMostOne::One(Some(ft)) => (1, vec![ft]),","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L2344","counters":[]},{"line":"    fn coinbase_count(sl_diff: &Diff) -> usize {","counters":[]},{"line":"        coinbase_first_prediff(&sl_diff.diff.0.coinbase).0","counters":[]},{"line":"            + sl_diff","counters":[]},{"line":"                .diff","counters":[]},{"line":"                .1","counters":[]},{"line":"                .as_ref()","counters":[]},{"line":"                .map(|d| coinbase_second_prediff(&d.coinbase).0)","counters":[]},{"line":"                .unwrap_or(0)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L2349","counters":[]},{"line":"    fn coinbase_cost(sl_diff: &Diff) -> Fee {","counters":[]},{"line":"        let first = coinbase_first_prediff(&sl_diff.diff.0.coinbase).1;","counters":[]},{"line":"        let snd = sl_diff","counters":[]},{"line":"            .diff","counters":[]},{"line":"            .1","counters":[]},{"line":"            .as_ref()","counters":[]},{"line":"            .map(|d| coinbase_second_prediff(&d.coinbase).1)","counters":[]},{"line":"            .unwrap_or_default();","counters":[]},{"line":"","counters":[]},{"line":"        first","counters":[]},{"line":"            .into_iter()","counters":[]},{"line":"            .chain(snd)","counters":[]},{"line":"            .fold(Fee::zero(), |total, ft| total.checked_add(&ft.fee).unwrap())","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// Assert the given staged ledger is in the correct state after applying","counters":[]},{"line":"    /// the first n user commands passed to the given base ledger. Checks the","counters":[]},{"line":"    /// states of the block producer account and user accounts but ignores","counters":[]},{"line":"    /// snark workers for simplicity.","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L2203","counters":[]},{"line":"    fn assert_ledger(","counters":[]},{"line":"        test_ledger: Mask,","counters":[]},{"line":"        coinbase_cost: Fee,","counters":[]},{"line":"        staged_ledger: &StagedLedger,","counters":[]},{"line":"        cmds_all: &[valid::UserCommand],","counters":[]},{"line":"        cmds_used: usize,","counters":[]},{"line":"        pks_to_check: &[AccountId],","counters":[]},{"line":"    ) {","counters":[]},{"line":"        let producer_account_id = AccountId::new(COINBASE_RECEIVER.clone(), TokenId::default());","counters":[]},{"line":"        let producer_account = test_ledger","counters":[]},{"line":"            .location_of_account(&producer_account_id)","counters":[]},{"line":"            .and_then(|loc| test_ledger.get(loc));","counters":[]},{"line":"","counters":[]},{"line":"        let is_producer_acc_new = producer_account.is_none();","counters":[]},{"line":"        let old_producer_balance = match producer_account.as_ref() {","counters":[]},{"line":"            Some(account) => account.balance,","counters":[]},{"line":"            None => Balance::zero(),","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        let mut test_ledger = test_ledger;","counters":[]},{"line":"","counters":[]},{"line":"        for cmd in util::take(cmds_all, cmds_used) {","counters":[]},{"line":"            let cmd = cmd.forget_check();","counters":[]},{"line":"            let tx = Transaction::Command(cmd);","counters":[]},{"line":"","counters":[]},{"line":"            apply_transaction(","counters":[]},{"line":"                &CONSTRAINT_CONSTANTS,","counters":[]},{"line":"                &dummy_state_view(None),","counters":[]},{"line":"                &mut test_ledger,","counters":[]},{"line":"                &tx,","counters":[]},{"line":"            )","counters":[]},{"line":"            .unwrap();","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        let get_account_exn = |ledger: &Mask, id: &AccountId| {","counters":[]},{"line":"            let loc = ledger.location_of_account(id).unwrap();","counters":[]},{"line":"            ledger.get(loc).unwrap()","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        // Check the user accounts in the updated staged ledger are as","counters":[]},{"line":"        // expected.","counters":[]},{"line":"","counters":[]},{"line":"        for id in pks_to_check {","counters":[]},{"line":"            let expect = get_account_exn(&test_ledger, id);","counters":[]},{"line":"            let actual = get_account_exn(&staged_ledger.ledger, id);","counters":[]},{"line":"            assert_eq!(expect, actual);","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        // We only test that the block producer got the coinbase reward here, since calculating","counters":[]},{"line":"        // the exact correct amount depends on the snark fees and tx fees.","counters":[]},{"line":"        let producer_balance_with_coinbase = {","counters":[]},{"line":"            let total_cost = if is_producer_acc_new {","counters":[]},{"line":"                coinbase_cost","counters":[]},{"line":"                    .checked_add(&CONSTRAINT_CONSTANTS.account_creation_fee)","counters":[]},{"line":"                    .unwrap()","counters":[]},{"line":"            } else {","counters":[]},{"line":"                coinbase_cost","counters":[]},{"line":"            };","counters":[]},{"line":"","counters":[]},{"line":"            let reward = CONSTRAINT_CONSTANTS","counters":[]},{"line":"                .coinbase_amount","counters":[]},{"line":"                .checked_sub(&Amount::of_fee(&total_cost))","counters":[]},{"line":"                .unwrap();","counters":[]},{"line":"","counters":[]},{"line":"            old_producer_balance.add_amount(reward).unwrap()","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        let new_producer_balance =","counters":[]},{"line":"            get_account_exn(&staged_ledger.ledger, &producer_account_id).balance;","counters":[]},{"line":"","counters":[]},{"line":"        assert!(new_producer_balance >= producer_balance_with_coinbase);","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// Generic test framework.","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L2427","counters":[]},{"line":"    fn test_simple<F>(","counters":[]},{"line":"        account_ids_to_check: Vec<AccountId>,","counters":[]},{"line":"        cmds: Vec<valid::UserCommand>,","counters":[]},{"line":"        cmd_iters: Vec<Option<usize>>,","counters":[]},{"line":"        mut sl: StagedLedger,","counters":[]},{"line":"        // Number of ledger proofs expected","counters":[]},{"line":"        expected_proof_count: Option<usize>,","counters":[]},{"line":"        allow_failure: Option<bool>,","counters":[]},{"line":"        test_mask: Mask,","counters":[]},{"line":"        provers: NumProvers,","counters":[]},{"line":"        stmt_to_work: &F,","counters":[]},{"line":"    ) -> StagedLedger","counters":[]},{"line":"    where","counters":[]},{"line":"        F: Fn(&work::Statement) -> Option<work::Checked>,","counters":[]},{"line":"    {","counters":[]},{"line":"        eprintln!(","counters":[]},{"line":"            \"test_simple ncmds={:?} niters={:?}\",","counters":[]},{"line":"            cmds.len(),","counters":[]},{"line":"            cmd_iters.len()","counters":[]},{"line":"        );","counters":[]},{"line":"","counters":[]},{"line":"        let allow_failure = allow_failure.unwrap_or(false);","counters":[]},{"line":"","counters":[]},{"line":"        // let mut niters = 0;","counters":[]},{"line":"","counters":[]},{"line":"        let total_ledger_proofs = iter_cmds_acc(","counters":[]},{"line":"            &cmds,","counters":[]},{"line":"            &cmd_iters,","counters":[]},{"line":"            0,","counters":[]},{"line":"            |cmds_left, count_opt, cmds_this_iter, mut proof_count| {","counters":[]},{"line":"                let niters = NITERS.load(std::sync::atomic::Ordering::Relaxed);","counters":[]},{"line":"","counters":[]},{"line":"                println!(\"\\n######## Start new batch {} ########\", niters);","counters":[]},{"line":"                println!(\"attempt_to_apply_nuser_commands={:?}\", cmds_this_iter.len());","counters":[]},{"line":"","counters":[]},{"line":"                let (ledger_proof, diff) =","counters":[]},{"line":"                    create_and_apply(None, None, &mut sl, cmds_this_iter, stmt_to_work);","counters":[]},{"line":"","counters":[]},{"line":"                for cmd in diff.commands() {","counters":[]},{"line":"                    if allow_failure {","counters":[]},{"line":"                        continue;","counters":[]},{"line":"                    }","counters":[]},{"line":"                    if let TransactionStatus::Failed(e) = &cmd.status {","counters":[]},{"line":"                        panic!(","counters":[]},{"line":"                            \"Transaction application failed for command {:#?}. Failures {:#?}\",","counters":[]},{"line":"                            cmd, e","counters":[]},{"line":"                        );","counters":[]},{"line":"                    };","counters":[]},{"line":"                }","counters":[]},{"line":"","counters":[]},{"line":"                if ledger_proof.is_some() {","counters":[]},{"line":"                    proof_count += 1;","counters":[]},{"line":"                }","counters":[]},{"line":"","counters":[]},{"line":"                assert_fee_excess(&ledger_proof);","counters":[]},{"line":"","counters":[]},{"line":"                let cmds_applied_this_iter = diff.commands().len();","counters":[]},{"line":"","counters":[]},{"line":"                let cb = coinbase_count(&diff);","counters":[]},{"line":"","counters":[]},{"line":"                match provers {","counters":[]},{"line":"                    NumProvers::One => assert_eq!(cb, 1),","counters":[]},{"line":"                    NumProvers::Many => assert!(cb > 0 && cb < 3, \"cb={:?}\", cb),","counters":[]},{"line":"                }","counters":[]},{"line":"","counters":[]},{"line":"                if count_opt.is_some() {","counters":[]},{"line":"                    // There is an edge case where cmds_applied_this_iter = 0, when","counters":[]},{"line":"                    // there is only enough space for coinbase transactions.","counters":[]},{"line":"                    assert!(cmds_applied_this_iter <= cmds_this_iter.len());","counters":[]},{"line":"","counters":[]},{"line":"                    let cmds = diff","counters":[]},{"line":"                        .commands()","counters":[]},{"line":"                        .into_iter()","counters":[]},{"line":"                        .map(|w| w.data)","counters":[]},{"line":"                        .collect::<Vec<_>>();","counters":[]},{"line":"                    let cmds2 = util::take(cmds_this_iter, cmds_applied_this_iter)","counters":[]},{"line":"                        .iter()","counters":[]},{"line":"                        .map(|c| c.forget_check())","counters":[]},{"line":"                        .collect::<Vec<_>>();","counters":[]},{"line":"                    assert_eq!(cmds, cmds2);","counters":[]},{"line":"                };","counters":[]},{"line":"","counters":[]},{"line":"                let coinbase_cost = coinbase_cost(&diff);","counters":[]},{"line":"","counters":[]},{"line":"                assert_ledger(","counters":[]},{"line":"                    test_mask.clone(),","counters":[]},{"line":"                    coinbase_cost,","counters":[]},{"line":"                    &sl,","counters":[]},{"line":"                    cmds_left,","counters":[]},{"line":"                    cmds_applied_this_iter,","counters":[]},{"line":"                    &account_ids_to_check,","counters":[]},{"line":"                );","counters":[]},{"line":"","counters":[]},{"line":"                eprintln!(","counters":[]},{"line":"                    \"######## Batch {} done: {} applied ########\\n\",","counters":[]},{"line":"                    niters, cmds_applied_this_iter","counters":[]},{"line":"                );","counters":[]},{"line":"","counters":[]},{"line":"                NITERS.store(niters + 1, Relaxed);","counters":[]},{"line":"","counters":[]},{"line":"                (diff, proof_count)","counters":[]},{"line":"            },","counters":[]},{"line":"        );","counters":[]},{"line":"","counters":[]},{"line":"        // Should have enough blocks to generate at least expected_proof_count","counters":[]},{"line":"        // proofs","counters":[]},{"line":"        if let Some(expected_proof_count) = expected_proof_count {","counters":[]},{"line":"            debug_assert_eq!(total_ledger_proofs, expected_proof_count);","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        sl","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// Deterministically compute a prover public key from a snark work statement.","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L2279","counters":[]},{"line":"    fn stmt_to_prover(stmt: &work::Statement) -> CompressedPubKey {","counters":[]},{"line":"        use rand::RngCore;","counters":[]},{"line":"        use rand_pcg::Pcg64;","counters":[]},{"line":"        use rand_seeder::Seeder;","counters":[]},{"line":"","counters":[]},{"line":"        struct MyRng(Pcg64);","counters":[]},{"line":"","counters":[]},{"line":"        impl RngCore for MyRng {","counters":[]},{"line":"            fn next_u32(&mut self) -> u32 {","counters":[]},{"line":"                self.0.next_u32()","counters":[]},{"line":"            }","counters":[]},{"line":"","counters":[]},{"line":"            fn next_u64(&mut self) -> u64 {","counters":[]},{"line":"                self.0.next_u64()","counters":[]},{"line":"            }","counters":[]},{"line":"","counters":[]},{"line":"            fn fill_bytes(&mut self, dest: &mut [u8]) {","counters":[]},{"line":"                self.0.fill_bytes(dest)","counters":[]},{"line":"            }","counters":[]},{"line":"","counters":[]},{"line":"            fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), rand::Error> {","counters":[]},{"line":"                self.0.try_fill_bytes(dest)","counters":[]},{"line":"            }","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        impl CryptoRng for MyRng {}","counters":[]},{"line":"","counters":[]},{"line":"        let seed = stmt.fold(vec![b'P'], |mut accum, v| {","counters":[]},{"line":"            accum.extend_from_slice(&v.target.ledger.to_bytes());","counters":[]},{"line":"            accum","counters":[]},{"line":"        });","counters":[]},{"line":"        let rng: Pcg64 = Seeder::from(&seed).make_rng();","counters":[]},{"line":"","counters":[]},{"line":"        Keypair::rand(&mut MyRng(rng)).public.into_compressed()","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L2289","counters":[]},{"line":"    fn proofs(stmt: &work::Statement) -> OneOrTwo<LedgerProof> {","counters":[]},{"line":"        stmt.map(|statement| {","counters":[]},{"line":"            LedgerProof::create(","counters":[]},{"line":"                statement.clone(),","counters":[]},{"line":"                SokDigest::default(),","counters":[]},{"line":"                dummy::dummy_transaction_proof(),","counters":[]},{"line":"            )","counters":[]},{"line":"        })","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L2295","counters":[]},{"line":"    fn stmt_to_work_random_prover(stmt: &work::Statement) -> Option<work::Checked> {","counters":[]},{"line":"        let mut rng = rand::thread_rng();","counters":[]},{"line":"        // TODO: In OCaml it is \"deterministic\"","counters":[]},{"line":"        let prover = Keypair::rand(&mut rng).public.into_compressed();","counters":[]},{"line":"","counters":[]},{"line":"        Some(work::Checked {","counters":[]},{"line":"            fee: CONSTRAINT_CONSTANTS.account_creation_fee,","counters":[]},{"line":"            proofs: proofs(stmt),","counters":[]},{"line":"            prover,","counters":[]},{"line":"        })","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// Max throughput-ledger proof count-fixed blocks","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L2636","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn max_throughput_ledger_proof_count_fixed_blocks() {","counters":[]},{"line":"        const EXPECTED_PROOF_COUNT: usize = 3;","counters":[]},{"line":"","counters":[]},{"line":"        let (ledger_init_state, cmds, iters) = gen_at_capacity_fixed_blocks(EXPECTED_PROOF_COUNT);","counters":[]},{"line":"","counters":[]},{"line":"        async_with_ledgers(","counters":[]},{"line":"            &ledger_init_state,","counters":[]},{"line":"            cmds.clone(),","counters":[]},{"line":"            iters.clone(),","counters":[]},{"line":"            |sl, test_mask| {","counters":[]},{"line":"                test_simple(","counters":[]},{"line":"                    init_pks(&ledger_init_state),","counters":[]},{"line":"                    cmds.to_vec(),","counters":[]},{"line":"                    iters.to_vec(),","counters":[]},{"line":"                    sl,","counters":[]},{"line":"                    Some(EXPECTED_PROOF_COUNT),","counters":[]},{"line":"                    None,","counters":[]},{"line":"                    test_mask,","counters":[]},{"line":"                    NumProvers::Many,","counters":[]},{"line":"                    &stmt_to_work_random_prover,","counters":[]},{"line":"                )","counters":[]},{"line":"            },","counters":[]},{"line":"        );","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// Max throughput-ledger proof count-fixed blocks, one prover","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn max_throughput_ledger_proof_count_fixed_blocks_one_prover() {","counters":[]},{"line":"        const EXPECTED_PROOF_COUNT: usize = 3;","counters":[]},{"line":"","counters":[]},{"line":"        let (ledger_init_state, cmds, iters) = gen_at_capacity_fixed_blocks(EXPECTED_PROOF_COUNT);","counters":[]},{"line":"","counters":[]},{"line":"        async_with_ledgers(","counters":[]},{"line":"            &ledger_init_state,","counters":[]},{"line":"            cmds.clone(),","counters":[]},{"line":"            iters.clone(),","counters":[]},{"line":"            |sl, test_mask| {","counters":[]},{"line":"                test_simple(","counters":[]},{"line":"                    init_pks(&ledger_init_state),","counters":[]},{"line":"                    cmds.to_vec(),","counters":[]},{"line":"                    iters.to_vec(),","counters":[]},{"line":"                    sl,","counters":[]},{"line":"                    Some(EXPECTED_PROOF_COUNT),","counters":[]},{"line":"                    None,","counters":[]},{"line":"                    test_mask,","counters":[]},{"line":"                    NumProvers::One,","counters":[]},{"line":"                    &stmt_to_work_one_prover,","counters":[]},{"line":"                )","counters":[]},{"line":"            },","counters":[]},{"line":"        );","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L2511","counters":[]},{"line":"    fn gen_at_capacity() -> (","counters":[]},{"line":"        LedgerInitialState,","counters":[]},{"line":"        Vec<valid::UserCommand>,","counters":[]},{"line":"        Vec<Option<usize>>,","counters":[]},{"line":"    ) {","counters":[]},{"line":"        let mut rng = rand::thread_rng();","counters":[]},{"line":"","counters":[]},{"line":"        let state = gen_initial_ledger_state();","counters":[]},{"line":"        let iters = rng.gen_range(1..max_blocks_for_coverage(0));","counters":[]},{"line":"        let total_cmds = TRANSACTION_CAPACITY * iters;","counters":[]},{"line":"","counters":[]},{"line":"        let cmds = signed_command_sequence(total_cmds, SignKind::Real, &state);","counters":[]},{"line":"        assert_eq!(cmds.len(), total_cmds);","counters":[]},{"line":"","counters":[]},{"line":"        (state, cmds, vec![None; iters])","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// Max throughput","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L2651","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn max_throughput_normal() {","counters":[]},{"line":"        let (ledger_init_state, cmds, iters) = gen_at_capacity();","counters":[]},{"line":"","counters":[]},{"line":"        async_with_ledgers(","counters":[]},{"line":"            &ledger_init_state,","counters":[]},{"line":"            cmds.clone(),","counters":[]},{"line":"            iters.clone(),","counters":[]},{"line":"            |sl, test_mask| {","counters":[]},{"line":"                test_simple(","counters":[]},{"line":"                    init_pks(&ledger_init_state),","counters":[]},{"line":"                    cmds.to_vec(),","counters":[]},{"line":"                    iters.to_vec(),","counters":[]},{"line":"                    sl,","counters":[]},{"line":"                    None,","counters":[]},{"line":"                    None,","counters":[]},{"line":"                    test_mask,","counters":[]},{"line":"                    NumProvers::Many,","counters":[]},{"line":"                    &stmt_to_work_random_prover,","counters":[]},{"line":"                )","counters":[]},{"line":"            },","counters":[]},{"line":"        );","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// Max throughput, one prover","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn max_throughput_normal_one_prover() {","counters":[]},{"line":"        let (ledger_init_state, cmds, iters) = gen_at_capacity();","counters":[]},{"line":"","counters":[]},{"line":"        async_with_ledgers(","counters":[]},{"line":"            &ledger_init_state,","counters":[]},{"line":"            cmds.clone(),","counters":[]},{"line":"            iters.clone(),","counters":[]},{"line":"            |sl, test_mask| {","counters":[]},{"line":"                test_simple(","counters":[]},{"line":"                    init_pks(&ledger_init_state),","counters":[]},{"line":"                    cmds.to_vec(),","counters":[]},{"line":"                    iters.to_vec(),","counters":[]},{"line":"                    sl,","counters":[]},{"line":"                    None,","counters":[]},{"line":"                    None,","counters":[]},{"line":"                    test_mask,","counters":[]},{"line":"                    NumProvers::One,","counters":[]},{"line":"                    &stmt_to_work_one_prover,","counters":[]},{"line":"                )","counters":[]},{"line":"            },","counters":[]},{"line":"        );","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    static VK: Lazy<WithHash<VerificationKey>> = Lazy::new(|| {","counters":[]},{"line":"        let vk = trivial_verification_key();","counters":[]},{"line":"        let hash = vk.hash();","counters":[]},{"line":"","counters":[]},{"line":"        assert_eq!(","counters":[]},{"line":"            hash.to_decimal(),","counters":[]},{"line":"            \"19499466121496341533850180868238667461929019416054840058730806488105861126057\"","counters":[]},{"line":"        );","counters":[]},{"line":"","counters":[]},{"line":"        WithHash { data: vk, hash }","counters":[]},{"line":"    });","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L2525","counters":[]},{"line":"    fn gen_zkapps(","counters":[]},{"line":"        failure: Option<Failure>,","counters":[]},{"line":"        num_zkapps: usize,","counters":[]},{"line":"        iters: usize,","counters":[]},{"line":"    ) -> (Mask, Vec<valid::UserCommand>, Vec<Option<usize>>) {","counters":[]},{"line":"        let (zkapp_command_and_fee_payer_keypairs, ledger) = sequence_zkapp_command_with_ledger(","counters":[]},{"line":"            None,","counters":[]},{"line":"            Some(1),","counters":[]},{"line":"            Some(num_zkapps),","counters":[]},{"line":"            Some(VK.clone()),","counters":[]},{"line":"            failure.as_ref(),","counters":[]},{"line":"        );","counters":[]},{"line":"","counters":[]},{"line":"        let zkapps: Vec<_> = zkapp_command_and_fee_payer_keypairs","counters":[]},{"line":"            .into_iter()","counters":[]},{"line":"            .map(|zkapp| {","counters":[]},{"line":"                let (valid::UserCommand::ZkAppCommand(zkapp), _, keymap) = zkapp else {","counters":[]},{"line":"                    panic!(\"Expected a Zkapp_command, got a Signed command\");","counters":[]},{"line":"                };","counters":[]},{"line":"","counters":[]},{"line":"                let mut zkapp = zkapp.forget();","counters":[]},{"line":"                zkapp_command_builder::replace_authorizations(None, &keymap, &mut zkapp);","counters":[]},{"line":"","counters":[]},{"line":"                let valid_zkapp_command_with_auths = zkapp_command::valid::to_valid(zkapp, &ledger)","counters":[]},{"line":"                    .expect(\"Could not create Zkapp_command.Valid.t\");","counters":[]},{"line":"","counters":[]},{"line":"                valid::UserCommand::ZkAppCommand(Box::new(valid_zkapp_command_with_auths))","counters":[]},{"line":"            })","counters":[]},{"line":"            .collect();","counters":[]},{"line":"","counters":[]},{"line":"        assert_eq!(zkapps.len(), num_zkapps);","counters":[]},{"line":"        (ledger, zkapps, vec![None; iters])","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L2571","counters":[]},{"line":"    fn gen_zkapps_at_capacity() -> (Mask, Vec<valid::UserCommand>, Vec<Option<usize>>) {","counters":[]},{"line":"        let mut rng = rand::thread_rng();","counters":[]},{"line":"","counters":[]},{"line":"        let iters = rng.gen_range(1..max_blocks_for_coverage(0));","counters":[]},{"line":"        let num_zkapps = TRANSACTION_CAPACITY * iters;","counters":[]},{"line":"        gen_zkapps(None, num_zkapps, iters)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/f6756507ff7380a691516ce02a3cf7d9d32915ae/src/lib/staged_ledger/staged_ledger.ml#L2560","counters":[]},{"line":"    fn gen_failing_zkapps_at_capacity() -> (Mask, Vec<valid::UserCommand>, Vec<Option<usize>>) {","counters":[]},{"line":"        let mut rng = rand::thread_rng();","counters":[]},{"line":"","counters":[]},{"line":"        let iters = rng.gen_range(1..max_blocks_for_coverage(0));","counters":[]},{"line":"        let num_zkapps = TRANSACTION_CAPACITY * iters;","counters":[]},{"line":"        gen_zkapps(Some(Failure::InvalidAccountPrecondition), num_zkapps, iters)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn de_serialize_zkapps() {","counters":[]},{"line":"        let (_ledger, zkapps, _iters) = gen_zkapps_at_capacity();","counters":[]},{"line":"","counters":[]},{"line":"        for (index, zkapp) in zkapps.into_iter().enumerate() {","counters":[]},{"line":"            let zkapp = match zkapp {","counters":[]},{"line":"                valid::UserCommand::SignedCommand(_) => todo!(),","counters":[]},{"line":"                valid::UserCommand::ZkAppCommand(zkapp) => zkapp,","counters":[]},{"line":"            };","counters":[]},{"line":"","counters":[]},{"line":"            let zkapp = zkapp.forget();","counters":[]},{"line":"","counters":[]},{"line":"            let a: mina_p2p_messages::v2::MinaBaseZkappCommandTStableV1WireStableV1 =","counters":[]},{"line":"                (&zkapp).into();","counters":[]},{"line":"            let b: zkapp_command::ZkAppCommand = (&a).into();","counters":[]},{"line":"","counters":[]},{"line":"            assert_eq!(zkapp, b, \"failed at {:?}\", index);","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// Max throughput (zkapps)","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L2664","counters":[]},{"line":"    // #[test]","counters":[]},{"line":"    fn max_throughput_zkapps() {","counters":[]},{"line":"        let (ledger, zkapps, iters) = gen_zkapps_at_capacity();","counters":[]},{"line":"","counters":[]},{"line":"        async_with_given_ledger(","counters":[]},{"line":"            &LedgerInitialState { state: vec![] },","counters":[]},{"line":"            zkapps.clone(),","counters":[]},{"line":"            iters.clone(),","counters":[]},{"line":"            ledger.clone(),","counters":[]},{"line":"            |sl, test_mask| {","counters":[]},{"line":"                let account_ids: Vec<_> = ledger.accounts().into_iter().collect();","counters":[]},{"line":"","counters":[]},{"line":"                test_simple(","counters":[]},{"line":"                    account_ids,","counters":[]},{"line":"                    zkapps.clone(),","counters":[]},{"line":"                    iters.clone(),","counters":[]},{"line":"                    sl,","counters":[]},{"line":"                    None,","counters":[]},{"line":"                    None,","counters":[]},{"line":"                    test_mask,","counters":[]},{"line":"                    NumProvers::Many,","counters":[]},{"line":"                    &stmt_to_work_random_prover,","counters":[]},{"line":"                )","counters":[]},{"line":"            },","counters":[]},{"line":"        );","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// Max_throughput with zkApp transactions that may fail","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L2675","counters":[]},{"line":"    // #[test]","counters":[]},{"line":"    fn max_throughput_zkapps_that_may_fail() {","counters":[]},{"line":"        let (ledger, zkapps, iters) = gen_failing_zkapps_at_capacity();","counters":[]},{"line":"","counters":[]},{"line":"        async_with_given_ledger(","counters":[]},{"line":"            &LedgerInitialState { state: vec![] },","counters":[]},{"line":"            zkapps.clone(),","counters":[]},{"line":"            iters.clone(),","counters":[]},{"line":"            ledger.clone(),","counters":[]},{"line":"            |sl, test_mask| {","counters":[]},{"line":"                let account_ids: Vec<_> = ledger.accounts().into_iter().collect();","counters":[]},{"line":"","counters":[]},{"line":"                test_simple(","counters":[]},{"line":"                    account_ids,","counters":[]},{"line":"                    zkapps.clone(),","counters":[]},{"line":"                    iters.clone(),","counters":[]},{"line":"                    sl,","counters":[]},{"line":"                    None,","counters":[]},{"line":"                    Some(true),","counters":[]},{"line":"                    test_mask,","counters":[]},{"line":"                    NumProvers::Many,","counters":[]},{"line":"                    &stmt_to_work_random_prover,","counters":[]},{"line":"                )","counters":[]},{"line":"            },","counters":[]},{"line":"        );","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// Generator for when we have less commands than needed to fill all slots.","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L2612","counters":[]},{"line":"    fn gen_below_capacity(","counters":[]},{"line":"        extra_blocks: Option<bool>,","counters":[]},{"line":"    ) -> (","counters":[]},{"line":"        LedgerInitialState,","counters":[]},{"line":"        Vec<valid::UserCommand>,","counters":[]},{"line":"        Vec<Option<usize>>,","counters":[]},{"line":"    ) {","counters":[]},{"line":"        let extra_blocks = extra_blocks.unwrap_or(false);","counters":[]},{"line":"","counters":[]},{"line":"        let mut rng = rand::thread_rng();","counters":[]},{"line":"","counters":[]},{"line":"        let state = gen_initial_ledger_state();","counters":[]},{"line":"        let iters_max = max_blocks_for_coverage(0) * if extra_blocks { 4 } else { 2 };","counters":[]},{"line":"","counters":[]},{"line":"        let iters = rng.gen_range(1..=iters_max);","counters":[]},{"line":"","counters":[]},{"line":"        // N.B. user commands per block is much less than transactions per block","counters":[]},{"line":"        // due to fee transfers and coinbases, especially with worse case number","counters":[]},{"line":"        // of provers, so in order to exercise not filling the scan state","counters":[]},{"line":"        // completely we always apply <= 1/2 transaction_capacity commands.","counters":[]},{"line":"","counters":[]},{"line":"        let cmds_per_iter: Vec<usize> = (0..iters)","counters":[]},{"line":"            .map(|_| rng.gen_range(1..((TRANSACTION_CAPACITY / 2) - 1)))","counters":[]},{"line":"            .collect();","counters":[]},{"line":"","counters":[]},{"line":"        let total_cmds = cmds_per_iter.iter().sum();","counters":[]},{"line":"","counters":[]},{"line":"        let cmds = signed_command_sequence(total_cmds, SignKind::Real, &state);","counters":[]},{"line":"        assert_eq!(cmds.len(), total_cmds);","counters":[]},{"line":"","counters":[]},{"line":"        (state, cmds, cmds_per_iter.into_iter().map(Some).collect())","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// Be able to include random number of commands","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L2686","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn be_able_to_include_random_number_of_commands_many_normal() {","counters":[]},{"line":"        let (ledger_init_state, cmds, iters) = gen_below_capacity(None);","counters":[]},{"line":"","counters":[]},{"line":"        async_with_ledgers(","counters":[]},{"line":"            &ledger_init_state,","counters":[]},{"line":"            cmds.to_vec(),","counters":[]},{"line":"            iters.to_vec(),","counters":[]},{"line":"            |sl, test_mask| {","counters":[]},{"line":"                test_simple(","counters":[]},{"line":"                    init_pks(&ledger_init_state),","counters":[]},{"line":"                    cmds.to_vec(),","counters":[]},{"line":"                    iters.to_vec(),","counters":[]},{"line":"                    sl,","counters":[]},{"line":"                    None,","counters":[]},{"line":"                    None,","counters":[]},{"line":"                    test_mask,","counters":[]},{"line":"                    NumProvers::Many,","counters":[]},{"line":"                    &stmt_to_work_random_prover,","counters":[]},{"line":"                )","counters":[]},{"line":"            },","counters":[]},{"line":"        );","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// Generate states that were known to fail","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// See https://github.com/openmina/ledger/commit/6de803f082ea986aa71e3cf30d7d83e54d2f5a3e","counters":[]},{"line":"    fn gen_below_capacity_failed() -> (","counters":[]},{"line":"        LedgerInitialState,","counters":[]},{"line":"        Vec<valid::UserCommand>,","counters":[]},{"line":"        Vec<Option<usize>>,","counters":[]},{"line":"    ) {","counters":[]},{"line":"        let state = gen_initial_ledger_state();","counters":[]},{"line":"        // let iters = [","counters":[]},{"line":"        //     7, 17, 26, 35, 50, 13, 54, 12, 29, 54, 62, 36, 44, 44, 7, 8, 25, 8, 3, 42, 4, 46, 61,","counters":[]},{"line":"        //     6, 60, 24, 34, 39, 9, 58, 23, 34, 10, 22, 15, 8, 4, 1, 42, 25, 5, 17, 60, 49, 45,","counters":[]},{"line":"        // ];","counters":[]},{"line":"","counters":[]},{"line":"        // // 2 slots availables","counters":[]},{"line":"        // let iters = [","counters":[]},{"line":"        //     124, 17, 80, 80","counters":[]},{"line":"        // ];","counters":[]},{"line":"","counters":[]},{"line":"        // let iters = vec![126; 25]","counters":[]},{"line":"        //     .into_iter()","counters":[]},{"line":"        //     .chain([","counters":[]},{"line":"        //         62, 17, 100, // 124, 17","counters":[]},{"line":"        //     ])","counters":[]},{"line":"        //     .collect::<Vec<_>>();","counters":[]},{"line":"","counters":[]},{"line":"        // let mut rng = rand::thread_rng();","counters":[]},{"line":"        // let iters: Vec<_> = (1..1024).map(|_| {","counters":[]},{"line":"        //     rng.gen_range(1..63)","counters":[]},{"line":"        // }).collect();","counters":[]},{"line":"","counters":[]},{"line":"        // // Failed with AAAA 1/2 (random)","counters":[]},{"line":"        // let iters = [","counters":[]},{"line":"        //     15,","counters":[]},{"line":"        //     6,","counters":[]},{"line":"        //     24,","counters":[]},{"line":"        //     10,","counters":[]},{"line":"        //     7,","counters":[]},{"line":"        //     12,","counters":[]},{"line":"        //     26,","counters":[]},{"line":"        //     4,","counters":[]},{"line":"        //     7,","counters":[]},{"line":"        //     57,","counters":[]},{"line":"        //     23,","counters":[]},{"line":"        //     59,","counters":[]},{"line":"        //     52,","counters":[]},{"line":"        //     35,","counters":[]},{"line":"        //     5,","counters":[]},{"line":"        //     12,","counters":[]},{"line":"        //     33,","counters":[]},{"line":"        //     12,","counters":[]},{"line":"        //     49,","counters":[]},{"line":"        //     29,","counters":[]},{"line":"        //     35,","counters":[]},{"line":"        //     37,","counters":[]},{"line":"        //     23,","counters":[]},{"line":"        //     33,","counters":[]},{"line":"        //     28,","counters":[]},{"line":"        //     38,","counters":[]},{"line":"        //     16,","counters":[]},{"line":"        //     10,","counters":[]},{"line":"        // ];","counters":[]},{"line":"","counters":[]},{"line":"        // Failed with AAAA2 (one_prover)","counters":[]},{"line":"        // let iters = [57, 16, 3, 16, 61, 26, 15, 21, 7, 34, 1, 52, 21, 29, 50, 40, 25];","counters":[]},{"line":"","counters":[]},{"line":"        // let iters = [","counters":[]},{"line":"        //     121, 4","counters":[]},{"line":"        // ];","counters":[]},{"line":"","counters":[]},{"line":"        // panic at incr coinbase -> two","counters":[]},{"line":"        let iters = [","counters":[]},{"line":"            12, 40, 10, 13, 1, 25, 3, 20, 41, 16, 30, 37, 26, 47, 33, 45, 44, 62, 18, 24, 55, 10,","counters":[]},{"line":"            53, 25, 19, 35, 44, 54, 60, 62, 32, 48, 31, 10, 20, 32, 57, 48, 37, 38,","counters":[]},{"line":"        ];","counters":[]},{"line":"","counters":[]},{"line":"        let total_cmds = iters.iter().sum();","counters":[]},{"line":"        eprintln!(\"total_cmds={:?}\", total_cmds);","counters":[]},{"line":"","counters":[]},{"line":"        let cmds = signed_command_sequence(total_cmds, SignKind::Real, &state);","counters":[]},{"line":"        assert_eq!(cmds.len(), total_cmds);","counters":[]},{"line":"","counters":[]},{"line":"        (state, cmds, iters.into_iter().map(Some).collect())","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// This test was failing, due to incorrect discarding user command","counters":[]},{"line":"    /// Note: Something interesting is that the batch 11 applies 0 commands","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// See https://github.com/openmina/ledger/commit/6de803f082ea986aa71e3cf30d7d83e54d2f5a3e","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn be_able_to_include_random_number_of_commands_many_failed() {","counters":[]},{"line":"        let (ledger_init_state, cmds, iters) = gen_below_capacity_failed();","counters":[]},{"line":"","counters":[]},{"line":"        async_with_ledgers(","counters":[]},{"line":"            &ledger_init_state,","counters":[]},{"line":"            cmds.to_vec(),","counters":[]},{"line":"            iters.to_vec(),","counters":[]},{"line":"            |sl, test_mask| {","counters":[]},{"line":"                test_simple(","counters":[]},{"line":"                    init_pks(&ledger_init_state),","counters":[]},{"line":"                    cmds.to_vec(),","counters":[]},{"line":"                    iters.to_vec(),","counters":[]},{"line":"                    sl,","counters":[]},{"line":"                    None,","counters":[]},{"line":"                    None,","counters":[]},{"line":"                    test_mask,","counters":[]},{"line":"                    NumProvers::Many,","counters":[]},{"line":"                    &stmt_to_work_random_prover,","counters":[]},{"line":"                )","counters":[]},{"line":"            },","counters":[]},{"line":"        );","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    // Deterministic, to get staged ledger hash","counters":[]},{"line":"    fn gen_for_hash(","counters":[]},{"line":"        iters: &[usize],","counters":[]},{"line":"        mut cmds: Vec<valid::UserCommand>,","counters":[]},{"line":"    ) -> (","counters":[]},{"line":"        LedgerInitialState,","counters":[]},{"line":"        Vec<valid::UserCommand>,","counters":[]},{"line":"        Vec<Option<usize>>,","counters":[]},{"line":"    ) {","counters":[]},{"line":"        fn keypair_from_private(private: &str) -> Keypair {","counters":[]},{"line":"            let bytes = bs58::decode(private).into_vec().unwrap();","counters":[]},{"line":"            let bytes = &bytes[1..]; // ignore base58 check byte","counters":[]},{"line":"","counters":[]},{"line":"            let secret = mina_signer::ScalarField::from_bytes(&bytes[1..]).unwrap();","counters":[]},{"line":"            let public: mina_signer::CurvePoint =","counters":[]},{"line":"                mina_signer::CurvePoint::prime_subgroup_generator()","counters":[]},{"line":"                    .mul(secret)","counters":[]},{"line":"                    .into_affine();","counters":[]},{"line":"","counters":[]},{"line":"            if !public.is_on_curve() {","counters":[]},{"line":"                panic!()","counters":[]},{"line":"                // return Err(KeypairError::NonCurvePoint);","counters":[]},{"line":"            }","counters":[]},{"line":"","counters":[]},{"line":"            // Safe now because we checked point is on the curve","counters":[]},{"line":"            Keypair::from_parts_unsafe(secret, public)","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        //        ledger_init_state=((((public_key B62qqrHu7qJJrUekPYqNEbsMMzxDebqfApuyT5y6K9xgwm4TUe77kNd)","counters":[]},{"line":"        //   (private_key EKDpdyjwhn5PWZzz2EumvUTDVtRKdy5QeP96i2iFntzhCQK5M8uU))","counters":[]},{"line":"        //  870234598000000000 555 Untimed)","counters":[]},{"line":"        // (((public_key B62qnxPe7DM72bh59QrubnREEyeNoeLM4J9s8iufT6Gi2iuUm6fe73R)","counters":[]},{"line":"        //   (private_key EKEVz18GAQ4zJaEHXRHrzbKYh5G4gzy1Kf4Y4x8MHuJN7pv1jmGx))","counters":[]},{"line":"        //  677094385000000000 289 Untimed)","counters":[]},{"line":"        // (((public_key B62qq4FFooVJ6TRGKA3chxE7M1Xh1F11jsanLBYmcZEqJZaYGPdye3D)","counters":[]},{"line":"        //   (private_key EKEkFGPRpiXfAfrgRi9DUSQ3zQ5eV4FGaD9rHLJwTBz7Ue4jWMnU))","counters":[]},{"line":"        //  966785966000000000 697 Untimed)","counters":[]},{"line":"        // (((public_key B62qiuynJSwKPepZGm8fcYbZ3zT2nynjcM23CD1Xzpofy5yKwMaC5N7)","counters":[]},{"line":"        //   (private_key EKFPQBAbjYkjM6p6fEaZAzufQgQs3spvUw1Uyq2Ghta81cpKrfGg))","counters":[]},{"line":"        //  871707103000000000 387 Untimed)","counters":[]},{"line":"        // (((public_key B62qrpPoKmGZWcWMn1Cb749dSym7cabp1wwoUS7AThuaCNJCfXHCLNw)","counters":[]},{"line":"        //   (private_key EKENSzF3YWq2Z3Rh9GXMwqN6bEVps9HxkfU38LkXfR3s2Lf3VPcD))","counters":[]},{"line":"        //  955060948000000000 468 Untimed))","counters":[]},{"line":"","counters":[]},{"line":"        let state = LedgerInitialState {","counters":[]},{"line":"            state: vec![","counters":[]},{"line":"                (","counters":[]},{"line":"                    keypair_from_private(\"EKDpdyjwhn5PWZzz2EumvUTDVtRKdy5QeP96i2iFntzhCQK5M8uU\"),","counters":[]},{"line":"                    Amount::from_u64(870234598000000000),","counters":[]},{"line":"                    Nonce::from_u32(555),","counters":[]},{"line":"                    crate::Timing::Untimed,","counters":[]},{"line":"                ),","counters":[]},{"line":"                (","counters":[]},{"line":"                    keypair_from_private(\"EKEVz18GAQ4zJaEHXRHrzbKYh5G4gzy1Kf4Y4x8MHuJN7pv1jmGx\"),","counters":[]},{"line":"                    Amount::from_u64(677094385000000000),","counters":[]},{"line":"                    Nonce::from_u32(289),","counters":[]},{"line":"                    crate::Timing::Untimed,","counters":[]},{"line":"                ),","counters":[]},{"line":"                (","counters":[]},{"line":"                    keypair_from_private(\"EKEkFGPRpiXfAfrgRi9DUSQ3zQ5eV4FGaD9rHLJwTBz7Ue4jWMnU\"),","counters":[]},{"line":"                    Amount::from_u64(966785966000000000),","counters":[]},{"line":"                    Nonce::from_u32(697),","counters":[]},{"line":"                    crate::Timing::Untimed,","counters":[]},{"line":"                ),","counters":[]},{"line":"                (","counters":[]},{"line":"                    keypair_from_private(\"EKFPQBAbjYkjM6p6fEaZAzufQgQs3spvUw1Uyq2Ghta81cpKrfGg\"),","counters":[]},{"line":"                    Amount::from_u64(871707103000000000),","counters":[]},{"line":"                    Nonce::from_u32(387),","counters":[]},{"line":"                    crate::Timing::Untimed,","counters":[]},{"line":"                ),","counters":[]},{"line":"                (","counters":[]},{"line":"                    keypair_from_private(\"EKENSzF3YWq2Z3Rh9GXMwqN6bEVps9HxkfU38LkXfR3s2Lf3VPcD\"),","counters":[]},{"line":"                    Amount::from_u64(955060948000000000),","counters":[]},{"line":"                    Nonce::from_u32(468),","counters":[]},{"line":"                    crate::Timing::Untimed,","counters":[]},{"line":"                ),","counters":[]},{"line":"            ],","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        // let state = gen_initial_ledger_state();","counters":[]},{"line":"        println!(\"state={:#?}\", state);","counters":[]},{"line":"","counters":[]},{"line":"        let iters_total: usize = iters.iter().sum();","counters":[]},{"line":"        assert!(iters_total <= cmds.len());","counters":[]},{"line":"","counters":[]},{"line":"        cmds.truncate(iters_total);","counters":[]},{"line":"","counters":[]},{"line":"        (state, cmds, iters.iter().copied().map(Some).collect())","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn test_hash(cmds: Vec<valid::UserCommand>, iters: &[usize], expected_hash: &StagedLedgerHash) {","counters":[]},{"line":"        let (ledger_init_state, cmds, iters) = gen_for_hash(iters, cmds);","counters":[]},{"line":"","counters":[]},{"line":"        async_with_ledgers(","counters":[]},{"line":"            &ledger_init_state,","counters":[]},{"line":"            cmds.to_vec(),","counters":[]},{"line":"            iters.to_vec(),","counters":[]},{"line":"            |mut sl, test_mask| {","counters":[]},{"line":"                // dbg!(sl.ledger.num_accounts());","counters":[]},{"line":"","counters":[]},{"line":"                let hash = sl.hash();","counters":[]},{"line":"","counters":[]},{"line":"                assert_eq!(hash, StagedLedgerHash::from_ocaml_strings(","counters":[]},{"line":"                    \"7213023165825031994332898585791275635753820608093286100176380057570051468967\",","counters":[]},{"line":"                    r\"T\\249\\245k\\176]TJ\\216\\183\\001\\204\\177\\131\\030\\244o\\178\\188\\191US\\156\\192Hi\\194P\\223\\004\\000\\003\",","counters":[]},{"line":"                    r\"_\\236\\235f\\255\\200o8\\217Rxlmily\\194\\219\\1949\\221N\\145\\180g)\\215:'\\251W\\233\",","counters":[]},{"line":"                    \"25504365445533103805898245102289650498571312278321176071043666991586378788150\"","counters":[]},{"line":"                ));","counters":[]},{"line":"","counters":[]},{"line":"                let mut sl = test_simple(","counters":[]},{"line":"                    init_pks(&ledger_init_state),","counters":[]},{"line":"                    cmds.to_vec(),","counters":[]},{"line":"                    iters.to_vec(),","counters":[]},{"line":"                    sl,","counters":[]},{"line":"                    None,","counters":[]},{"line":"                    None,","counters":[]},{"line":"                    test_mask,","counters":[]},{"line":"                    NumProvers::One,","counters":[]},{"line":"                    &stmt_to_work_one_prover,","counters":[]},{"line":"                );","counters":[]},{"line":"","counters":[]},{"line":"                let mut accounts = sl.ledger.accounts().into_iter().collect::<Vec<_>>();","counters":[]},{"line":"                accounts.sort_by_key(|a| a.public_key.x);","counters":[]},{"line":"","counters":[]},{"line":"                let hash = sl.hash();","counters":[]},{"line":"","counters":[]},{"line":"                let job: Vec<_> = sl.scan_state.base_jobs_on_latest_tree().collect();","counters":[]},{"line":"                dbg!(job.len(), &job);","counters":[]},{"line":"","counters":[]},{"line":"                for job in job {","counters":[]},{"line":"                    // dbg!(&job.ledger_witness);","counters":[]},{"line":"                    // println!(\"START\");","counters":[]},{"line":"                    let before = job.ledger_witness.clone().merkle_root();","counters":[]},{"line":"                    let ledger: mina_p2p_messages::v2::MinaBaseSparseLedgerBaseStableV2 =","counters":[]},{"line":"                        (&job.ledger_witness).into();","counters":[]},{"line":"","counters":[]},{"line":"                    // dbg!(&ledger);","counters":[]},{"line":"","counters":[]},{"line":"                    let mut ledger: SparseLedger<AccountId, Account> = (&ledger).into();","counters":[]},{"line":"                    let after = ledger.merkle_root();","counters":[]},{"line":"                    // dbg!(&ledger);","counters":[]},{"line":"                    assert_eq!(before, after);","counters":[]},{"line":"                    // dbg!(&ledger);","counters":[]},{"line":"                    // dbg!(&job.ledger_witness);","counters":[]},{"line":"","counters":[]},{"line":"                    assert_eq!(ledger, job.ledger_witness);","counters":[]},{"line":"                }","counters":[]},{"line":"","counters":[]},{"line":"                assert_eq!(","counters":[]},{"line":"                    &hash, expected_hash,","counters":[]},{"line":"                    \"\\ngot={:#?}\\nexpected={:#?}\",","counters":[]},{"line":"                    hash, expected_hash","counters":[]},{"line":"                );","counters":[]},{"line":"","counters":[]},{"line":"                // staged_ledger_hash=","counters":[]},{"line":"                // ((non_snark","counters":[]},{"line":"                //   ((ledger_hash","counters":[]},{"line":"                //     7403973954047799970700856317480467373315236045518635088954201291392464592256)","counters":[]},{"line":"                //    (aux_hash","counters":[]},{"line":"                //     \"\\183At\\174\\178]\\186\\b$\\182\\245&\\003=\\183\\241\\190\\214\\131@r\\162&\\138f\\187\\234\\191\\2002\\148\\249\")","counters":[]},{"line":"                //    (pending_coinbase_aux","counters":[]},{"line":"                //     \"\\147\\141\\184\\201\\248,\\140\\181\\141?>\\244\\253%\\0006\\164\\141&\\167\\018u=/\\222Z\\189\\003\\168\\\\\\171\\244\")))","counters":[]},{"line":"                //  (pending_coinbase_hash","counters":[]},{"line":"                //   3086764415430464582862741061906779337283239657859408605572481484787647764860))","counters":[]},{"line":"            },","counters":[]},{"line":"        );","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn staged_ledger_hash() {","counters":[]},{"line":"        let cmds = vec![valid::UserCommand::SignedCommand(Box::new(SignedCommand {","counters":[]},{"line":"            payload: SignedCommandPayload {","counters":[]},{"line":"                common: Common {","counters":[]},{"line":"                    fee: Fee::from_u64(8688709898),","counters":[]},{"line":"                    fee_payer_pk: CompressedPubKey::from_address(","counters":[]},{"line":"                        \"B62qqrHu7qJJrUekPYqNEbsMMzxDebqfApuyT5y6K9xgwm4TUe77kNd\",","counters":[]},{"line":"                    )","counters":[]},{"line":"                    .unwrap(),","counters":[]},{"line":"                    nonce: Nonce::from_u32(555),","counters":[]},{"line":"                    valid_until: Slot::from_u32(4294967295),","counters":[]},{"line":"                    memo: Memo::from_ocaml_str(","counters":[]},{"line":"                        r\"\\000 \\014WQ\\192&\\229C\\178\\232\\171.\\176`\\153\\218\\161\\209\\229\\223Gw\\143w\\135\\250\\171E\\205\\241/\\227\\168\",","counters":[]},{"line":"                    ),","counters":[]},{"line":"                },","counters":[]},{"line":"                body: signed_command::Body::Payment(PaymentPayload {","counters":[]},{"line":"                    source_pk: CompressedPubKey::from_address(","counters":[]},{"line":"                        \"B62qqrHu7qJJrUekPYqNEbsMMzxDebqfApuyT5y6K9xgwm4TUe77kNd\",","counters":[]},{"line":"                    )","counters":[]},{"line":"                    .unwrap(),","counters":[]},{"line":"                    receiver_pk: CompressedPubKey::from_address(","counters":[]},{"line":"                        \"B62qnxPe7DM72bh59QrubnREEyeNoeLM4J9s8iufT6Gi2iuUm6fe73R\",","counters":[]},{"line":"                    )","counters":[]},{"line":"                    .unwrap(),","counters":[]},{"line":"                    amount: Amount::from_u64(435117290311290102),","counters":[]},{"line":"                }),","counters":[]},{"line":"            },","counters":[]},{"line":"            signer: CompressedPubKey::from_address(","counters":[]},{"line":"                \"B62qqrHu7qJJrUekPYqNEbsMMzxDebqfApuyT5y6K9xgwm4TUe77kNd\",","counters":[]},{"line":"            )","counters":[]},{"line":"            .unwrap(),","counters":[]},{"line":"            signature: Signature {","counters":[]},{"line":"                rx: Fp::from_str(","counters":[]},{"line":"                    \"6619317331104517676070771956470715552778579643404520621914362882786941822698\",","counters":[]},{"line":"                )","counters":[]},{"line":"                .unwrap(),","counters":[]},{"line":"                s: Fq::from_str(","counters":[]},{"line":"                    \"4273977355509408506621406872367289068113165398006813670168359703884853847009\",","counters":[]},{"line":"                )","counters":[]},{"line":"                .unwrap(),","counters":[]},{"line":"            },","counters":[]},{"line":"        }))];","counters":[]},{"line":"","counters":[]},{"line":"        let iters = [1];","counters":[]},{"line":"        let expected = StagedLedgerHash::from_ocaml_strings(","counters":[]},{"line":"            \"7403973954047799970700856317480467373315236045518635088954201291392464592256\",","counters":[]},{"line":"            r\"\\183At\\174\\178]\\186\\b$\\182\\245&\\003=\\183\\241\\190\\214\\131@r\\162&\\138f\\187\\234\\191\\2002\\148\\249\",","counters":[]},{"line":"            r\"\\147\\141\\184\\201\\248,\\140\\181\\141?>\\244\\253%\\0006\\164\\141&\\167\\018u=/\\222Z\\189\\003\\168\\\\\\171\\244\",","counters":[]},{"line":"            \"3086764415430464582862741061906779337283239657859408605572481484787647764860\",","counters":[]},{"line":"        );","counters":[]},{"line":"","counters":[]},{"line":"        test_hash(cmds, &iters[..], &expected);","counters":[]},{"line":"","counters":[]},{"line":"        let cmds = vec![","counters":[]},{"line":"            valid::UserCommand::SignedCommand(Box::new(SignedCommand {","counters":[]},{"line":"                payload: SignedCommandPayload {","counters":[]},{"line":"                    common: Common {","counters":[]},{"line":"                        fee: Fee::from_u64(9552806101),","counters":[]},{"line":"                        fee_payer_pk: CompressedPubKey::from_address(","counters":[]},{"line":"                            \"B62qqrHu7qJJrUekPYqNEbsMMzxDebqfApuyT5y6K9xgwm4TUe77kNd\",","counters":[]},{"line":"                        )","counters":[]},{"line":"                            .unwrap(),","counters":[]},{"line":"                        nonce: Nonce::from_u32(555),","counters":[]},{"line":"                        valid_until: Slot::from_u32(4294967295),","counters":[]},{"line":"                        memo: Memo::from_ocaml_str(","counters":[]},{"line":"                            r\"\\000 \\014WQ\\192&\\229C\\178\\232\\171.\\176`\\153\\218\\161\\209\\229\\223Gw\\143w\\135\\250\\171E\\205\\241/\\227\\168\",","counters":[]},{"line":"                        ),","counters":[]},{"line":"                    },","counters":[]},{"line":"                    body: signed_command::Body::Payment(PaymentPayload {","counters":[]},{"line":"                        source_pk: CompressedPubKey::from_address(","counters":[]},{"line":"                            \"B62qqrHu7qJJrUekPYqNEbsMMzxDebqfApuyT5y6K9xgwm4TUe77kNd\",","counters":[]},{"line":"                        )","counters":[]},{"line":"                            .unwrap(),","counters":[]},{"line":"                        receiver_pk: CompressedPubKey::from_address(","counters":[]},{"line":"                            \"B62qq4FFooVJ6TRGKA3chxE7M1Xh1F11jsanLBYmcZEqJZaYGPdye3D\",","counters":[]},{"line":"                        )","counters":[]},{"line":"                            .unwrap(),","counters":[]},{"line":"                        amount: Amount::from_u64(469201635493516843),","counters":[]},{"line":"                    }),","counters":[]},{"line":"                },","counters":[]},{"line":"                signer: CompressedPubKey::from_address(","counters":[]},{"line":"                    \"B62qqrHu7qJJrUekPYqNEbsMMzxDebqfApuyT5y6K9xgwm4TUe77kNd\",","counters":[]},{"line":"                )","counters":[]},{"line":"                    .unwrap(),","counters":[]},{"line":"                signature: Signature {","counters":[]},{"line":"                    rx: Fp::from_str(","counters":[]},{"line":"                        \"13044376504321844748116412242934215884445305434730105658311275966836245013702\",","counters":[]},{"line":"                    )","counters":[]},{"line":"                        .unwrap(),","counters":[]},{"line":"                    s: Fq::from_str(","counters":[]},{"line":"                        \"12273578804512625613925108666574978157352049391462385103152803971242598973329\",","counters":[]},{"line":"                    )","counters":[]},{"line":"                        .unwrap(),","counters":[]},{"line":"                },","counters":[]},{"line":"            })),","counters":[]},{"line":"            valid::UserCommand::SignedCommand(Box::new(SignedCommand {","counters":[]},{"line":"                payload: SignedCommandPayload {","counters":[]},{"line":"                    common: Common {","counters":[]},{"line":"                        fee: Fee::from_u64(9575291918),","counters":[]},{"line":"                        fee_payer_pk: CompressedPubKey::from_address(","counters":[]},{"line":"                            \"B62qqrHu7qJJrUekPYqNEbsMMzxDebqfApuyT5y6K9xgwm4TUe77kNd\",","counters":[]},{"line":"                        )","counters":[]},{"line":"                            .unwrap(),","counters":[]},{"line":"                        nonce: Nonce::from_u32(556),","counters":[]},{"line":"                        valid_until: Slot::from_u32(4294967295),","counters":[]},{"line":"                        memo: Memo::from_ocaml_str(","counters":[]},{"line":"                            r\"\\000 \\014WQ\\192&\\229C\\178\\232\\171.\\176`\\153\\218\\161\\209\\229\\223Gw\\143w\\135\\250\\171E\\205\\241/\\227\\168\",","counters":[]},{"line":"                        ),","counters":[]},{"line":"                    },","counters":[]},{"line":"                    body: signed_command::Body::Payment(PaymentPayload {","counters":[]},{"line":"                        source_pk: CompressedPubKey::from_address(","counters":[]},{"line":"                            \"B62qqrHu7qJJrUekPYqNEbsMMzxDebqfApuyT5y6K9xgwm4TUe77kNd\",","counters":[]},{"line":"                        )","counters":[]},{"line":"                            .unwrap(),","counters":[]},{"line":"                        receiver_pk: CompressedPubKey::from_address(","counters":[]},{"line":"                            \"B62qqrHu7qJJrUekPYqNEbsMMzxDebqfApuyT5y6K9xgwm4TUe77kNd\",","counters":[]},{"line":"                        )","counters":[]},{"line":"                            .unwrap(),","counters":[]},{"line":"                        amount: Amount::from_u64(296784327960059186),","counters":[]},{"line":"                    }),","counters":[]},{"line":"                },","counters":[]},{"line":"                signer: CompressedPubKey::from_address(","counters":[]},{"line":"                    \"B62qqrHu7qJJrUekPYqNEbsMMzxDebqfApuyT5y6K9xgwm4TUe77kNd\",","counters":[]},{"line":"                )","counters":[]},{"line":"                    .unwrap(),","counters":[]},{"line":"                signature: Signature {","counters":[]},{"line":"                    rx: Fp::from_str(","counters":[]},{"line":"                        \"19459175650095724075239264136789847339652723660248405017158921230047021100311\",","counters":[]},{"line":"                    )","counters":[]},{"line":"                        .unwrap(),","counters":[]},{"line":"                    s: Fq::from_str(","counters":[]},{"line":"                        \"10619126644528613945289745005934480034669523474364234529309635443435990216318\",","counters":[]},{"line":"                    )","counters":[]},{"line":"                        .unwrap(),","counters":[]},{"line":"                },","counters":[]},{"line":"            })),","counters":[]},{"line":"            valid::UserCommand::SignedCommand(Box::new(SignedCommand {","counters":[]},{"line":"                payload: SignedCommandPayload {","counters":[]},{"line":"                    common: Common {","counters":[]},{"line":"                        fee: Fee::from_u64(6000000000),","counters":[]},{"line":"                        fee_payer_pk: CompressedPubKey::from_address(","counters":[]},{"line":"                            \"B62qqrHu7qJJrUekPYqNEbsMMzxDebqfApuyT5y6K9xgwm4TUe77kNd\",","counters":[]},{"line":"                        )","counters":[]},{"line":"                            .unwrap(),","counters":[]},{"line":"                        nonce: Nonce::from_u32(557),","counters":[]},{"line":"                        valid_until: Slot::from_u32(4294967295),","counters":[]},{"line":"                        memo: Memo::from_ocaml_str(","counters":[]},{"line":"                            r\"\\000 \\014WQ\\192&\\229C\\178\\232\\171.\\176`\\153\\218\\161\\209\\229\\223Gw\\143w\\135\\250\\171E\\205\\241/\\227\\168\",","counters":[]},{"line":"                        ),","counters":[]},{"line":"                    },","counters":[]},{"line":"                    body: signed_command::Body::Payment(PaymentPayload {","counters":[]},{"line":"                        source_pk: CompressedPubKey::from_address(","counters":[]},{"line":"                            \"B62qqrHu7qJJrUekPYqNEbsMMzxDebqfApuyT5y6K9xgwm4TUe77kNd\",","counters":[]},{"line":"                        )","counters":[]},{"line":"                            .unwrap(),","counters":[]},{"line":"                        receiver_pk: CompressedPubKey::from_address(","counters":[]},{"line":"                            \"B62qnxPe7DM72bh59QrubnREEyeNoeLM4J9s8iufT6Gi2iuUm6fe73R\",","counters":[]},{"line":"                        )","counters":[]},{"line":"                            .unwrap(),","counters":[]},{"line":"                        amount: Amount::from_u64(104248609418325952),","counters":[]},{"line":"                    }),","counters":[]},{"line":"                },","counters":[]},{"line":"                signer: CompressedPubKey::from_address(","counters":[]},{"line":"                    \"B62qqrHu7qJJrUekPYqNEbsMMzxDebqfApuyT5y6K9xgwm4TUe77kNd\",","counters":[]},{"line":"                )","counters":[]},{"line":"                    .unwrap(),","counters":[]},{"line":"                signature: Signature {","counters":[]},{"line":"                    rx: Fp::from_str(","counters":[]},{"line":"                        \"19184633593539053772878146013599475038165210841217779716455315092747869436447\",","counters":[]},{"line":"                    )","counters":[]},{"line":"                        .unwrap(),","counters":[]},{"line":"                    s: Fq::from_str(","counters":[]},{"line":"                        \"17897057128192645856092038224382359168869279402582452391679534470779618649008\",","counters":[]},{"line":"                    )","counters":[]},{"line":"                        .unwrap(),","counters":[]},{"line":"                },","counters":[]},{"line":"            }))","counters":[]},{"line":"        ];","counters":[]},{"line":"","counters":[]},{"line":"        let iters = [1, 2];","counters":[]},{"line":"        let expected = StagedLedgerHash::from_ocaml_strings(","counters":[]},{"line":"            \"21222488975521454969719816807666201571945933237784599135716531110886279420130\",","counters":[]},{"line":"            r\"C\\004\\240\\167\\1597Y\\205\\236br\\128\\2324<\\219[&\\027u\\173\\152\\212\\180N\\142\\193yP\\189\\129\\031\",","counters":[]},{"line":"            r\"\\147\\141\\184\\201\\248,\\140\\181\\141?>\\244\\253%\\0006\\164\\141&\\167\\018u=/\\222Z\\189\\003\\168\\\\\\171\\244\",","counters":[]},{"line":"            \"8909119019222126918708891766510490679262830386343981426610706812406879559705\",","counters":[]},{"line":"        );","counters":[]},{"line":"","counters":[]},{"line":"        // staged_ledger_hash=","counters":[]},{"line":"        // ((non_snark","counters":[]},{"line":"        //   ((ledger_hash","counters":[]},{"line":"        //     21222488975521454969719816807666201571945933237784599135716531110886279420130)","counters":[]},{"line":"        //    (aux_hash","counters":[]},{"line":"        //     \"C\\004\\240\\167\\1597Y\\205\\236br\\128\\2324<\\219[&\\027u\\173\\152\\212\\180N\\142\\193yP\\189\\129\\031\")","counters":[]},{"line":"        //    (pending_coinbase_aux","counters":[]},{"line":"        //     \"\\147\\141\\184\\201\\248,\\140\\181\\141?>\\244\\253%\\0006\\164\\141&\\167\\018u=/\\222Z\\189\\003\\168\\\\\\171\\244\")))","counters":[]},{"line":"        //  (pending_coinbase_hash","counters":[]},{"line":"        //   8909119019222126918708891766510490679262830386343981426610706812406879559705))","counters":[]},{"line":"","counters":[]},{"line":"        test_hash(cmds, &iters[..], &expected);","counters":[]},{"line":"","counters":[]},{"line":"        let cmds = dummy::for_tests::list_of_cmds();","counters":[]},{"line":"        let iters = [126, 1];","counters":[]},{"line":"","counters":[]},{"line":"        let expected = StagedLedgerHash::from_ocaml_strings(","counters":[]},{"line":"            \"17477048617623399278357380851139583927261600258225227089274676141994175991491\",","counters":[]},{"line":"            r\"\\031\\154\\249\\228\\236\\218\\178\\144\\220\\147|8\\217p3\\158ivC\\192\\129\\208>\\t\\2402\\n\\232\\225\\004\\172\\204\",","counters":[]},{"line":"            r\"7\\131O/%v/#\\225\\247JS\\028\\190D]\\183=ge\\235\\230\\bx\\167\\223\\190\\205}J\\246\\225\",","counters":[]},{"line":"            \"13628016176671996634125618970711117372294565467015081467173689084579176689763\",","counters":[]},{"line":"        );","counters":[]},{"line":"","counters":[]},{"line":"        test_hash(cmds.clone(), &iters[..], &expected);","counters":[]},{"line":"","counters":[]},{"line":"        let iters = [126, 126, 126, 1];","counters":[]},{"line":"","counters":[]},{"line":"        let expected = StagedLedgerHash::from_ocaml_strings(","counters":[]},{"line":"            \"3849036020651863715306758036604903453092892010402969196144652234888763588784\",","counters":[]},{"line":"            r\"l\\134Q\\000\\138DI\\190\\215\\219BqR\\142\\201#\\187\\219e\\138\\210\\142*\\210\\206E\\195Q\\221Un3\",","counters":[]},{"line":"            r\"\\245;\\157@E\\202~a\\226R\\155\\006&\\201)\\030&[\\238\\156\\027w&\\204_\\150G<U;\\1803\",","counters":[]},{"line":"            \"25017623412619027645642100741662603532612211443127692037797169213370969546910\",","counters":[]},{"line":"        );","counters":[]},{"line":"","counters":[]},{"line":"        test_hash(cmds.clone(), &iters[..], &expected);","counters":[]},{"line":"","counters":[]},{"line":"        let iters = [126, 126, 126, 126, 126, 126, 126];","counters":[]},{"line":"        let expected = StagedLedgerHash::from_ocaml_strings(","counters":[]},{"line":"            \"18582860218764414485081234471609377222894570081548691702645303871998665679024\",","counters":[]},{"line":"            r\"0\\136Wg\\182DbX\\203kLi\\212%\\199\\206\\142#\\213`L\\160bpCB\\1413\\240\\193\\171K\",","counters":[]},{"line":"            r\"\\n\\220\\211\\153\\014A\\191\\006\\019\\231/\\244\\155\\005\\212\\1310|\\227\\133\\176O\\196\\131\\023t\\152\\178\\130?\\206U\",","counters":[]},{"line":"            \"7755910003612203694232340741198062502757785525513434577565209492737983651491\",","counters":[]},{"line":"        );","counters":[]},{"line":"","counters":[]},{"line":"        test_hash(cmds, &iters[..], &expected);","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/f6756507ff7380a691516ce02a3cf7d9d32915ae/src/lib/staged_ledger/staged_ledger.ml#L2579","counters":[]},{"line":"    fn gen_zkapps_below_capacity(","counters":[]},{"line":"        extra_blocks: Option<bool>,","counters":[]},{"line":"    ) -> (Mask, Vec<valid::UserCommand>, Vec<Option<usize>>) {","counters":[]},{"line":"        let extra_blocks = extra_blocks.unwrap_or(false);","counters":[]},{"line":"        let mut rng = rand::thread_rng();","counters":[]},{"line":"","counters":[]},{"line":"        let iters_max = max_blocks_for_coverage(0) * if extra_blocks { 4 } else { 2 };","counters":[]},{"line":"        let iters = rng.gen_range(1..iters_max);","counters":[]},{"line":"","counters":[]},{"line":"        // see comment in gen_below_capacity for rationale","counters":[]},{"line":"","counters":[]},{"line":"        let zkapps_per_iter: Vec<usize> = (0..iters)","counters":[]},{"line":"            .map(|_| rng.gen_range(1..((TRANSACTION_CAPACITY / 2) - 1)))","counters":[]},{"line":"            .collect();","counters":[]},{"line":"","counters":[]},{"line":"        let num_zkapps: usize = zkapps_per_iter.iter().sum();","counters":[]},{"line":"        gen_zkapps(None, num_zkapps, iters)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// Be able to include random number of commands (zkapps)","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L2694","counters":[]},{"line":"    // #[test]","counters":[]},{"line":"    fn be_able_to_include_random_number_of_commands_zkapps() {","counters":[]},{"line":"        let (ledger, zkapps, iters) = gen_zkapps_below_capacity(None);","counters":[]},{"line":"","counters":[]},{"line":"        async_with_given_ledger(","counters":[]},{"line":"            &LedgerInitialState { state: vec![] },","counters":[]},{"line":"            zkapps.clone(),","counters":[]},{"line":"            iters.clone(),","counters":[]},{"line":"            ledger.clone(),","counters":[]},{"line":"            |sl, test_mask| {","counters":[]},{"line":"                let account_ids: Vec<_> = ledger.accounts().into_iter().collect();","counters":[]},{"line":"","counters":[]},{"line":"                test_simple(","counters":[]},{"line":"                    account_ids,","counters":[]},{"line":"                    zkapps.clone(),","counters":[]},{"line":"                    iters.clone(),","counters":[]},{"line":"                    sl,","counters":[]},{"line":"                    None,","counters":[]},{"line":"                    None,","counters":[]},{"line":"                    test_mask,","counters":[]},{"line":"                    NumProvers::Many,","counters":[]},{"line":"                    &stmt_to_work_random_prover,","counters":[]},{"line":"                )","counters":[]},{"line":"            },","counters":[]},{"line":"        );","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// Be able to include random number of commands (One prover)","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L2704","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn be_able_to_include_random_number_of_commands_one_prover_normal() {","counters":[]},{"line":"        let (ledger_init_state, cmds, iters) = gen_below_capacity(None);","counters":[]},{"line":"","counters":[]},{"line":"        async_with_ledgers(","counters":[]},{"line":"            &ledger_init_state,","counters":[]},{"line":"            cmds.to_vec(),","counters":[]},{"line":"            iters.to_vec(),","counters":[]},{"line":"            |sl, test_mask| {","counters":[]},{"line":"                test_simple(","counters":[]},{"line":"                    init_pks(&ledger_init_state),","counters":[]},{"line":"                    cmds.to_vec(),","counters":[]},{"line":"                    iters.to_vec(),","counters":[]},{"line":"                    sl,","counters":[]},{"line":"                    None,","counters":[]},{"line":"                    None,","counters":[]},{"line":"                    test_mask,","counters":[]},{"line":"                    NumProvers::One,","counters":[]},{"line":"                    &stmt_to_work_one_prover,","counters":[]},{"line":"                )","counters":[]},{"line":"            },","counters":[]},{"line":"        );","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// This test was failing, due to incorrect discarding user command","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// See https://github.com/openmina/ledger/commit/6de803f082ea986aa71e3cf30d7d83e54d2f5a3e","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn be_able_to_include_random_number_of_commands_one_prover_failed() {","counters":[]},{"line":"        let (ledger_init_state, cmds, iters) = gen_below_capacity_failed();","counters":[]},{"line":"","counters":[]},{"line":"        async_with_ledgers(","counters":[]},{"line":"            &ledger_init_state,","counters":[]},{"line":"            cmds.to_vec(),","counters":[]},{"line":"            iters.to_vec(),","counters":[]},{"line":"            |sl, test_mask| {","counters":[]},{"line":"                test_simple(","counters":[]},{"line":"                    init_pks(&ledger_init_state),","counters":[]},{"line":"                    cmds.to_vec(),","counters":[]},{"line":"                    iters.to_vec(),","counters":[]},{"line":"                    sl,","counters":[]},{"line":"                    None,","counters":[]},{"line":"                    None,","counters":[]},{"line":"                    test_mask,","counters":[]},{"line":"                    NumProvers::One,","counters":[]},{"line":"                    &stmt_to_work_one_prover,","counters":[]},{"line":"                )","counters":[]},{"line":"            },","counters":[]},{"line":"        );","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// Be able to include random number of commands (One prover, zkapps)","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L2712","counters":[]},{"line":"    // #[test]","counters":[]},{"line":"    fn be_able_to_include_random_number_of_commands_one_prover_zkapps() {","counters":[]},{"line":"        let (ledger, zkapps, iters) = gen_zkapps_below_capacity(None);","counters":[]},{"line":"","counters":[]},{"line":"        async_with_given_ledger(","counters":[]},{"line":"            &LedgerInitialState { state: vec![] },","counters":[]},{"line":"            zkapps.clone(),","counters":[]},{"line":"            iters.clone(),","counters":[]},{"line":"            ledger.clone(),","counters":[]},{"line":"            |sl, test_mask| {","counters":[]},{"line":"                let account_ids: Vec<_> = ledger.accounts().into_iter().collect();","counters":[]},{"line":"","counters":[]},{"line":"                test_simple(","counters":[]},{"line":"                    account_ids,","counters":[]},{"line":"                    zkapps.clone(),","counters":[]},{"line":"                    iters.clone(),","counters":[]},{"line":"                    sl,","counters":[]},{"line":"                    None,","counters":[]},{"line":"                    None,","counters":[]},{"line":"                    test_mask,","counters":[]},{"line":"                    NumProvers::One,","counters":[]},{"line":"                    &stmt_to_work_one_prover,","counters":[]},{"line":"                )","counters":[]},{"line":"            },","counters":[]},{"line":"        );","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// Fixed public key for when there is only one snark worker.","counters":[]},{"line":"    static SNARK_WORKER_PK: Lazy<CompressedPubKey> = Lazy::new(|| {","counters":[]},{"line":"        CompressedPubKey::from_address(\"B62qkEfRowNNxqpA4KZX5FsWu3EDa15SYyxkjC3KvxqKVPbpQZyLofw\")","counters":[]},{"line":"            .unwrap()","counters":[]},{"line":"    });","counters":[]},{"line":"    // Lazy::new(|| gen_keypair().public.into_compressed());","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L2295","counters":[]},{"line":"    fn stmt_to_work_one_prover(stmt: &work::Statement) -> Option<work::Checked> {","counters":[]},{"line":"        Some(work::Checked {","counters":[]},{"line":"            fee: WORK_FEE,","counters":[]},{"line":"            proofs: proofs(stmt),","counters":[]},{"line":"            prover: SNARK_WORKER_PK.clone(),","counters":[]},{"line":"        })","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// Zero proof-fee should not create a fee transfer","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L2723","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn zero_proof_fee_should_not_create_a_fee_transfer() {","counters":[]},{"line":"        const EXPECTED_PROOF_COUNT: usize = 3;","counters":[]},{"line":"","counters":[]},{"line":"        let stmt_to_work_zero_fee = |stmts: &OneOrTwo<Statement<()>>| {","counters":[]},{"line":"            Some(work::Checked {","counters":[]},{"line":"                fee: Fee::zero(),","counters":[]},{"line":"                proofs: proofs(stmts),","counters":[]},{"line":"                prover: SNARK_WORKER_PK.clone(),","counters":[]},{"line":"            })","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        let account_id_prover = AccountId::new(SNARK_WORKER_PK.clone(), TokenId::default());","counters":[]},{"line":"","counters":[]},{"line":"        let (ledger_init_state, cmds, iters) = gen_at_capacity_fixed_blocks(EXPECTED_PROOF_COUNT);","counters":[]},{"line":"","counters":[]},{"line":"        async_with_ledgers(","counters":[]},{"line":"            &ledger_init_state,","counters":[]},{"line":"            cmds.clone(),","counters":[]},{"line":"            iters.clone(),","counters":[]},{"line":"            |sl, test_mask| {","counters":[]},{"line":"                test_simple(","counters":[]},{"line":"                    init_pks(&ledger_init_state),","counters":[]},{"line":"                    cmds.to_vec(),","counters":[]},{"line":"                    iters.to_vec(),","counters":[]},{"line":"                    sl,","counters":[]},{"line":"                    Some(EXPECTED_PROOF_COUNT),","counters":[]},{"line":"                    None,","counters":[]},{"line":"                    test_mask.clone(),","counters":[]},{"line":"                    NumProvers::One,","counters":[]},{"line":"                    &stmt_to_work_zero_fee,","counters":[]},{"line":"                );","counters":[]},{"line":"","counters":[]},{"line":"                assert!(test_mask.location_of_account(&account_id_prover).is_none());","counters":[]},{"line":"            },","counters":[]},{"line":"        );","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L2745","counters":[]},{"line":"    fn compute_statutes(","counters":[]},{"line":"        ledger: Mask,","counters":[]},{"line":"        coinbase_amount: Amount,","counters":[]},{"line":"        diff: (","counters":[]},{"line":"            PreDiffTwo<work::Work, WithStatus<UserCommand>>,","counters":[]},{"line":"            Option<PreDiffOne<work::Work, WithStatus<UserCommand>>>,","counters":[]},{"line":"        ),","counters":[]},{"line":"    ) -> (","counters":[]},{"line":"        PreDiffTwo<work::Work, WithStatus<UserCommand>>,","counters":[]},{"line":"        Option<PreDiffOne<work::Work, WithStatus<UserCommand>>>,","counters":[]},{"line":"    ) {","counters":[]},{"line":"        // Fill in the statuses for commands.","counters":[]},{"line":"        let mut status_ledger = HashlessLedger::create(ledger);","counters":[]},{"line":"","counters":[]},{"line":"        let mut generate_status = |txn: Transaction| -> Result<TransactionStatus, String> {","counters":[]},{"line":"            status_ledger.apply_transaction(&CONSTRAINT_CONSTANTS, &dummy_state_view(None), &txn)","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        pre_diff_info::compute_statuses::<UserCommand, valid::Transaction, _>(","counters":[]},{"line":"            &CONSTRAINT_CONSTANTS,","counters":[]},{"line":"            diff,","counters":[]},{"line":"            COINBASE_RECEIVER.clone(),","counters":[]},{"line":"            coinbase_amount,","counters":[]},{"line":"            &mut generate_status,","counters":[]},{"line":"        )","counters":[]},{"line":"        .unwrap()","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// Invalid diff test: check zero fee excess for partitions","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L2761","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn check_zero_fee_excess_for_partitions() {","counters":[]},{"line":"        let create_diff_with_non_zero_fee_excess =","counters":[]},{"line":"            |ledger: Mask,","counters":[]},{"line":"             coinbase_amount: Amount,","counters":[]},{"line":"             txns: Vec<WithStatus<UserCommand>>,","counters":[]},{"line":"             completed_works: Vec<work::Unchecked>,","counters":[]},{"line":"             partition: SpacePartition| {","counters":[]},{"line":"                // With exact number of user commands in partition.first, the fee transfers that","counters":[]},{"line":"                // settle the fee_excess would be added to the next tree causing a non-zero fee excess","counters":[]},{"line":"                let (slots, job_count1) = partition.first;","counters":[]},{"line":"                match partition.second {","counters":[]},{"line":"                    None => Diff {","counters":[]},{"line":"                        diff: {","counters":[]},{"line":"                            compute_statutes(","counters":[]},{"line":"                                ledger,","counters":[]},{"line":"                                coinbase_amount,","counters":[]},{"line":"                                (","counters":[]},{"line":"                                    PreDiffTwo {","counters":[]},{"line":"                                        completed_works: completed_works","counters":[]},{"line":"                                            .iter()","counters":[]},{"line":"                                            .take(job_count1 as usize)","counters":[]},{"line":"                                            .cloned()","counters":[]},{"line":"                                            .collect(),","counters":[]},{"line":"                                        commands: txns","counters":[]},{"line":"                                            .iter()","counters":[]},{"line":"                                            .take(slots as usize)","counters":[]},{"line":"                                            .cloned()","counters":[]},{"line":"                                            .collect(),","counters":[]},{"line":"                                        coinbase: AtMostTwo::Zero,","counters":[]},{"line":"                                        internal_command_statuses: vec![],","counters":[]},{"line":"                                    },","counters":[]},{"line":"                                    None,","counters":[]},{"line":"                                ),","counters":[]},{"line":"                            )","counters":[]},{"line":"                        },","counters":[]},{"line":"                    },","counters":[]},{"line":"                    Some(_) => {","counters":[]},{"line":"                        let txns_in_second_diff = util::drop(&txns, slots as usize).to_vec();","counters":[]},{"line":"","counters":[]},{"line":"                        let a = PreDiffTwo {","counters":[]},{"line":"                            completed_works: completed_works","counters":[]},{"line":"                                .iter()","counters":[]},{"line":"                                .take(job_count1 as usize)","counters":[]},{"line":"                                .cloned()","counters":[]},{"line":"                                .collect(),","counters":[]},{"line":"                            commands: txns.iter().take(slots as usize).cloned().collect(),","counters":[]},{"line":"                            coinbase: AtMostTwo::Zero,","counters":[]},{"line":"                            internal_command_statuses: vec![],","counters":[]},{"line":"                        };","counters":[]},{"line":"","counters":[]},{"line":"                        let b = PreDiffOne {","counters":[]},{"line":"                            completed_works: if txns_in_second_diff.is_empty() {","counters":[]},{"line":"                                vec![]","counters":[]},{"line":"                            } else {","counters":[]},{"line":"                                util::drop(&completed_works, job_count1 as usize).to_vec()","counters":[]},{"line":"                            },","counters":[]},{"line":"                            commands: txns_in_second_diff,","counters":[]},{"line":"                            coinbase: AtMostOne::Zero,","counters":[]},{"line":"                            internal_command_statuses: vec![],","counters":[]},{"line":"                        };","counters":[]},{"line":"","counters":[]},{"line":"                        Diff {","counters":[]},{"line":"                            diff: compute_statutes(ledger, coinbase_amount, (a, Some(b))),","counters":[]},{"line":"                        }","counters":[]},{"line":"                    }","counters":[]},{"line":"                }","counters":[]},{"line":"            };","counters":[]},{"line":"","counters":[]},{"line":"        let empty_diff = Diff::empty();","counters":[]},{"line":"","counters":[]},{"line":"        let (ledger_init_state, cmds, iters) = gen_at_capacity();","counters":[]},{"line":"","counters":[]},{"line":"        async_with_ledgers(","counters":[]},{"line":"            &ledger_init_state,","counters":[]},{"line":"            cmds.clone(),","counters":[]},{"line":"            iters.clone(),","counters":[]},{"line":"            |mut sl, _test_mask| {","counters":[]},{"line":"                let checked = iter_cmds_acc(","counters":[]},{"line":"                    &cmds,","counters":[]},{"line":"                    &iters,","counters":[]},{"line":"                    true,","counters":[]},{"line":"                    |_cmds_left, _count_opt, cmds_this_iter, checked| {","counters":[]},{"line":"                        let work = sl.scan_state.work_statements_for_new_diff();","counters":[]},{"line":"                        let partitions = sl.scan_state.partition_if_overflowing();","counters":[]},{"line":"","counters":[]},{"line":"                        let work_done: Vec<work::Checked> = work","counters":[]},{"line":"                            .iter()","counters":[]},{"line":"                            .map(|work| work::Checked {","counters":[]},{"line":"                                fee: Fee::zero(),","counters":[]},{"line":"                                proofs: proofs(work),","counters":[]},{"line":"                                prover: SNARK_WORKER_PK.clone(),","counters":[]},{"line":"                            })","counters":[]},{"line":"                            .collect();","counters":[]},{"line":"","counters":[]},{"line":"                        let cmds_this_iter: Vec<WithStatus<UserCommand>> = cmds_this_iter","counters":[]},{"line":"                            .iter()","counters":[]},{"line":"                            .map(|cmd| WithStatus {","counters":[]},{"line":"                                data: cmd.forget_check(),","counters":[]},{"line":"                                status: TransactionStatus::Applied,","counters":[]},{"line":"                            })","counters":[]},{"line":"                            .collect();","counters":[]},{"line":"","counters":[]},{"line":"                        let diff = create_diff_with_non_zero_fee_excess(","counters":[]},{"line":"                            sl.ledger.clone(),","counters":[]},{"line":"                            CONSTRAINT_CONSTANTS.coinbase_amount,","counters":[]},{"line":"                            cmds_this_iter,","counters":[]},{"line":"                            work_done,","counters":[]},{"line":"                            partitions,","counters":[]},{"line":"                        );","counters":[]},{"line":"","counters":[]},{"line":"                        let apply_res = sl.apply(","counters":[]},{"line":"                            None,","counters":[]},{"line":"                            &CONSTRAINT_CONSTANTS,","counters":[]},{"line":"                            diff.clone(),","counters":[]},{"line":"                            (),","counters":[]},{"line":"                            &Verifier,","counters":[]},{"line":"                            &dummy_state_view(None),","counters":[]},{"line":"                            (Fp::zero(), Fp::zero()),","counters":[]},{"line":"                            COINBASE_RECEIVER.clone(),","counters":[]},{"line":"                            true,","counters":[]},{"line":"                        );","counters":[]},{"line":"","counters":[]},{"line":"                        let (new_checked, diff) = match apply_res {","counters":[]},{"line":"                            Err(StagedLedgerError::NonZeroFeeExcess(..)) => {","counters":[]},{"line":"                                (true, empty_diff.clone())","counters":[]},{"line":"                            }","counters":[]},{"line":"                            Err(e) => panic!(\"Expecting Non-zero-fee-excess error, got {:?}\", e),","counters":[]},{"line":"                            Ok(DiffResult { .. }) => (false, diff),","counters":[]},{"line":"                        };","counters":[]},{"line":"","counters":[]},{"line":"                        dbg!(new_checked, checked);","counters":[]},{"line":"","counters":[]},{"line":"                        (diff, checked | new_checked)","counters":[]},{"line":"                    },","counters":[]},{"line":"                );","counters":[]},{"line":"","counters":[]},{"line":"                // Note(OCaml): if this fails, try increasing the number of trials to get a diff that does fail","counters":[]},{"line":"                assert!(checked);","counters":[]},{"line":"            },","counters":[]},{"line":"        );","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    const WORK_FEE: Fee = CONSTRAINT_CONSTANTS.account_creation_fee;","counters":[]},{"line":"","counters":[]},{"line":"    /// Provers can't pay the account creation fee","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L2866","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn provers_cant_pay_the_account_creation_fee() {","counters":[]},{"line":"        let no_work_included = |diff: &Diff| diff.completed_works().is_empty();","counters":[]},{"line":"","counters":[]},{"line":"        let stmt_to_work = |stmts: &work::Statement| {","counters":[]},{"line":"            Some(work::Checked {","counters":[]},{"line":"                fee: WORK_FEE.checked_sub(&Fee::from_u64(1)).unwrap(),","counters":[]},{"line":"                proofs: proofs(stmts),","counters":[]},{"line":"                prover: stmt_to_prover(stmts),","counters":[]},{"line":"            })","counters":[]},{"line":"        };","counters":[]},{"line":"        let (ledger_init_state, cmds, iters) = gen_below_capacity(None);","counters":[]},{"line":"","counters":[]},{"line":"        async_with_ledgers(","counters":[]},{"line":"            &ledger_init_state,","counters":[]},{"line":"            cmds.to_vec(),","counters":[]},{"line":"            iters.to_vec(),","counters":[]},{"line":"            |sl, _test_mask| {","counters":[]},{"line":"                iter_cmds_acc(","counters":[]},{"line":"                    &cmds,","counters":[]},{"line":"                    &iters,","counters":[]},{"line":"                    (),","counters":[]},{"line":"                    |_cmds_left, _count_opt, cmds_this_iter, _| {","counters":[]},{"line":"                        let (diff, _invalid_txns) = sl","counters":[]},{"line":"                            .create_diff(","counters":[]},{"line":"                                &CONSTRAINT_CONSTANTS,","counters":[]},{"line":"                                None,","counters":[]},{"line":"                                COINBASE_RECEIVER.clone(),","counters":[]},{"line":"                                LOGGER,","counters":[]},{"line":"                                &dummy_state_view(None),","counters":[]},{"line":"                                cmds_this_iter.to_vec(),","counters":[]},{"line":"                                stmt_to_work,","counters":[]},{"line":"                                true,","counters":[]},{"line":"                            )","counters":[]},{"line":"                            .unwrap();","counters":[]},{"line":"","counters":[]},{"line":"                        let diff = diff.forget();","counters":[]},{"line":"","counters":[]},{"line":"                        // No proofs were purchased since the fee for the proofs are not","counters":[]},{"line":"                        // sufficient to pay for account creation","counters":[]},{"line":"                        assert!(no_work_included(&diff));","counters":[]},{"line":"","counters":[]},{"line":"                        (diff, ())","counters":[]},{"line":"                    },","counters":[]},{"line":"                );","counters":[]},{"line":"            },","counters":[]},{"line":"        );","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L2914","counters":[]},{"line":"    fn stmt_to_work_restricted(","counters":[]},{"line":"        work_list: &[work::Statement],","counters":[]},{"line":"        provers: NumProvers,","counters":[]},{"line":"    ) -> impl Fn(&work::Statement) -> Option<work::Checked> + '_ {","counters":[]},{"line":"        move |stmts: &work::Statement| {","counters":[]},{"line":"            if work_list.contains(stmts) {","counters":[]},{"line":"                let prover = match provers {","counters":[]},{"line":"                    NumProvers::Many => stmt_to_prover(stmts),","counters":[]},{"line":"                    NumProvers::One => SNARK_WORKER_PK.clone(),","counters":[]},{"line":"                };","counters":[]},{"line":"                Some(work::Checked {","counters":[]},{"line":"                    fee: WORK_FEE,","counters":[]},{"line":"                    proofs: proofs(stmts),","counters":[]},{"line":"                    prover,","counters":[]},{"line":"                })","counters":[]},{"line":"            } else {","counters":[]},{"line":"                None","counters":[]},{"line":"            }","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// Like test_simple but with a random number of completed jobs available.","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L2939","counters":[]},{"line":"    fn test_random_number_of_proofs(","counters":[]},{"line":"        init: &LedgerInitialState,","counters":[]},{"line":"        cmds: Vec<valid::UserCommand>,","counters":[]},{"line":"        cmd_iters: Vec<Option<usize>>,","counters":[]},{"line":"        proof_available: Vec<usize>,","counters":[]},{"line":"        mut sl: StagedLedger,","counters":[]},{"line":"        test_mask: Mask,","counters":[]},{"line":"        provers: NumProvers,","counters":[]},{"line":"    ) {","counters":[]},{"line":"        let mut niters = 0;","counters":[]},{"line":"","counters":[]},{"line":"        let proofs_available_left = iter_cmds_acc(","counters":[]},{"line":"            &cmds,","counters":[]},{"line":"            &cmd_iters,","counters":[]},{"line":"            proof_available,","counters":[]},{"line":"            |cmds_left, _count_opt, cmds_this_iter, mut proofs_available_left| {","counters":[]},{"line":"                println!(\"######## Start new batch {} ########\", niters);","counters":[]},{"line":"                println!(\"nto_applied={:?}\", cmds_this_iter.len());","counters":[]},{"line":"","counters":[]},{"line":"                let work_list = sl.scan_state.all_work_statements_exn();","counters":[]},{"line":"","counters":[]},{"line":"                let proofs_available_this_iter = *proofs_available_left.first().unwrap();","counters":[]},{"line":"","counters":[]},{"line":"                let (proof, diff) = create_and_apply(","counters":[]},{"line":"                    None,","counters":[]},{"line":"                    None,","counters":[]},{"line":"                    &mut sl,","counters":[]},{"line":"                    cmds_this_iter,","counters":[]},{"line":"                    stmt_to_work_restricted(","counters":[]},{"line":"                        util::take(&work_list, proofs_available_this_iter),","counters":[]},{"line":"                        provers,","counters":[]},{"line":"                    ),","counters":[]},{"line":"                );","counters":[]},{"line":"","counters":[]},{"line":"                assert_fee_excess(&proof);","counters":[]},{"line":"","counters":[]},{"line":"                let cmds_applied_this_iter = diff.commands().len();","counters":[]},{"line":"","counters":[]},{"line":"                let cb = coinbase_count(&diff);","counters":[]},{"line":"","counters":[]},{"line":"                assert!(proofs_available_this_iter == 0 || cb > 0);","counters":[]},{"line":"","counters":[]},{"line":"                match provers {","counters":[]},{"line":"                    NumProvers::One => assert!(cb <= 1),","counters":[]},{"line":"                    NumProvers::Many => assert!(cb <= 2),","counters":[]},{"line":"                }","counters":[]},{"line":"","counters":[]},{"line":"                let coinbase_cost = coinbase_cost(&diff);","counters":[]},{"line":"","counters":[]},{"line":"                assert_ledger(","counters":[]},{"line":"                    test_mask.clone(),","counters":[]},{"line":"                    coinbase_cost,","counters":[]},{"line":"                    &sl,","counters":[]},{"line":"                    cmds_left,","counters":[]},{"line":"                    cmds_applied_this_iter,","counters":[]},{"line":"                    &init_pks(init),","counters":[]},{"line":"                );","counters":[]},{"line":"","counters":[]},{"line":"                proofs_available_left.remove(0);","counters":[]},{"line":"","counters":[]},{"line":"                eprintln!(","counters":[]},{"line":"                    \"######## Batch {} done: {} applied, {} proofs ########\\n\",","counters":[]},{"line":"                    niters, cmds_applied_this_iter, proofs_available_this_iter","counters":[]},{"line":"                );","counters":[]},{"line":"","counters":[]},{"line":"                niters += 1;","counters":[]},{"line":"","counters":[]},{"line":"                (diff, proofs_available_left)","counters":[]},{"line":"            },","counters":[]},{"line":"        );","counters":[]},{"line":"","counters":[]},{"line":"        assert!(proofs_available_left.is_empty());","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// max throughput-random number of proofs-worst case provers","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// Always at worst case number of provers","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L2983","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn max_throughput_random_number_of_proofs_worst_case_provers() {","counters":[]},{"line":"        let mut rng = rand::thread_rng();","counters":[]},{"line":"","counters":[]},{"line":"        let (ledger_init_state, cmds, iters) = gen_at_capacity();","counters":[]},{"line":"","counters":[]},{"line":"        // How many proofs will be available at each iteration.","counters":[]},{"line":"        //","counters":[]},{"line":"        // (OCaml) I think in the worst case every user command begets 1.5","counters":[]},{"line":"        // transactions - one for the command and half of one for a fee","counters":[]},{"line":"        // transfer - and the merge overhead means you need (amortized) twice","counters":[]},{"line":"        // as many SNARKs as transactions, but since a SNARK work usually","counters":[]},{"line":"        // covers two SNARKS it cancels. So we need to admit up to (1.5 * the","counters":[]},{"line":"        // number of commands) works. I make it twice as many for simplicity","counters":[]},{"line":"        // and to cover coinbases.","counters":[]},{"line":"        let proofs_available: Vec<usize> = iters","counters":[]},{"line":"            .iter()","counters":[]},{"line":"            .map(|_| rng.gen_range(0..(TRANSACTION_CAPACITY * 2)))","counters":[]},{"line":"            .collect();","counters":[]},{"line":"","counters":[]},{"line":"        async_with_ledgers(","counters":[]},{"line":"            &ledger_init_state,","counters":[]},{"line":"            cmds.clone(),","counters":[]},{"line":"            iters.clone(),","counters":[]},{"line":"            |sl, test_mask| {","counters":[]},{"line":"                test_random_number_of_proofs(","counters":[]},{"line":"                    &ledger_init_state,","counters":[]},{"line":"                    cmds.clone(),","counters":[]},{"line":"                    iters.clone(),","counters":[]},{"line":"                    proofs_available.clone(),","counters":[]},{"line":"                    sl,","counters":[]},{"line":"                    test_mask,","counters":[]},{"line":"                    NumProvers::Many,","counters":[]},{"line":"                )","counters":[]},{"line":"            },","counters":[]},{"line":"        );","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// random no of transactions-random number of proofs-worst case provers","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L3008","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn random_number_of_transactions_random_number_of_proofs_worst_case_provers() {","counters":[]},{"line":"        let mut rng = rand::thread_rng();","counters":[]},{"line":"","counters":[]},{"line":"        let (ledger_init_state, cmds, iters) = gen_below_capacity(Some(true));","counters":[]},{"line":"","counters":[]},{"line":"        let proofs_available: Vec<usize> = iters","counters":[]},{"line":"            .iter()","counters":[]},{"line":"            .map(|cmds_opt| rng.gen_range(0..(3 * cmds_opt.unwrap())))","counters":[]},{"line":"            .collect();","counters":[]},{"line":"","counters":[]},{"line":"        async_with_ledgers(","counters":[]},{"line":"            &ledger_init_state,","counters":[]},{"line":"            cmds.clone(),","counters":[]},{"line":"            iters.clone(),","counters":[]},{"line":"            |sl, test_mask| {","counters":[]},{"line":"                test_random_number_of_proofs(","counters":[]},{"line":"                    &ledger_init_state,","counters":[]},{"line":"                    cmds.clone(),","counters":[]},{"line":"                    iters.clone(),","counters":[]},{"line":"                    proofs_available.clone(),","counters":[]},{"line":"                    sl,","counters":[]},{"line":"                    test_mask,","counters":[]},{"line":"                    NumProvers::Many,","counters":[]},{"line":"                )","counters":[]},{"line":"            },","counters":[]},{"line":"        );","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// Random number of commands-random number of proofs-one prover","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L3057","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn random_number_of_commands_random_number_of_proofs_one_prover() {","counters":[]},{"line":"        let mut rng = rand::thread_rng();","counters":[]},{"line":"","counters":[]},{"line":"        let (ledger_init_state, cmds, iters) = gen_below_capacity(Some(true));","counters":[]},{"line":"","counters":[]},{"line":"        let proofs_available: Vec<usize> = iters","counters":[]},{"line":"            .iter()","counters":[]},{"line":"            .map(|cmds_opt| rng.gen_range(0..(3 * cmds_opt.unwrap())))","counters":[]},{"line":"            .collect();","counters":[]},{"line":"","counters":[]},{"line":"        async_with_ledgers(","counters":[]},{"line":"            &ledger_init_state,","counters":[]},{"line":"            cmds.clone(),","counters":[]},{"line":"            iters.clone(),","counters":[]},{"line":"            |sl, test_mask| {","counters":[]},{"line":"                test_random_number_of_proofs(","counters":[]},{"line":"                    &ledger_init_state,","counters":[]},{"line":"                    cmds.clone(),","counters":[]},{"line":"                    iters.clone(),","counters":[]},{"line":"                    proofs_available.clone(),","counters":[]},{"line":"                    sl,","counters":[]},{"line":"                    test_mask,","counters":[]},{"line":"                    NumProvers::One,","counters":[]},{"line":"                )","counters":[]},{"line":"            },","counters":[]},{"line":"        );","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L3076","counters":[]},{"line":"    fn stmt_to_work_random_fee(","counters":[]},{"line":"        work_list: &[(work::Statement, Fee)],","counters":[]},{"line":"        provers: NumProvers,","counters":[]},{"line":"    ) -> impl Fn(&work::Statement) -> Option<work::Checked> + '_ {","counters":[]},{"line":"        move |stmts: &work::Statement| {","counters":[]},{"line":"            work_list.iter().find(|(w, _)| w == stmts).map(|(_, fee)| {","counters":[]},{"line":"                let prover = match provers {","counters":[]},{"line":"                    NumProvers::Many => stmt_to_prover(stmts),","counters":[]},{"line":"                    NumProvers::One => SNARK_WORKER_PK.clone(),","counters":[]},{"line":"                };","counters":[]},{"line":"","counters":[]},{"line":"                work::Checked {","counters":[]},{"line":"                    fee: *fee,","counters":[]},{"line":"                    proofs: proofs(stmts),","counters":[]},{"line":"                    prover,","counters":[]},{"line":"                }","counters":[]},{"line":"            })","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// Like test_random_number_of_proofs but with random proof fees.","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L3095","counters":[]},{"line":"    fn test_random_proof_fee(","counters":[]},{"line":"        _init: &LedgerInitialState,","counters":[]},{"line":"        cmds: Vec<valid::UserCommand>,","counters":[]},{"line":"        cmd_iters: Vec<Option<usize>>,","counters":[]},{"line":"        proof_available: Vec<(usize, Vec<Fee>)>,","counters":[]},{"line":"        mut sl: StagedLedger,","counters":[]},{"line":"        _test_mask: Mask,","counters":[]},{"line":"        provers: NumProvers,","counters":[]},{"line":"    ) {","counters":[]},{"line":"        let mut niters = 0;","counters":[]},{"line":"","counters":[]},{"line":"        let proofs_available_left = iter_cmds_acc(","counters":[]},{"line":"            &cmds,","counters":[]},{"line":"            &cmd_iters,","counters":[]},{"line":"            proof_available,","counters":[]},{"line":"            |_cmds_left, _count_opt, cmds_this_iter, mut proofs_available_left| {","counters":[]},{"line":"                println!(\"######## Start new batch {} ########\", niters);","counters":[]},{"line":"                println!(\"nto_applied={:?}\", cmds_this_iter.len());","counters":[]},{"line":"","counters":[]},{"line":"                let work_list = sl.scan_state.all_work_statements_exn();","counters":[]},{"line":"","counters":[]},{"line":"                let (proofs_available_this_iter, fees_for_each) =","counters":[]},{"line":"                    proofs_available_left.first().unwrap();","counters":[]},{"line":"                let proofs_available_this_iter = *proofs_available_this_iter;","counters":[]},{"line":"","counters":[]},{"line":"                let work_to_be_done = {","counters":[]},{"line":"                    let work_list = util::take(&work_list, proofs_available_this_iter).to_vec();","counters":[]},{"line":"                    let fees = util::take(fees_for_each, work_list.len()).to_vec();","counters":[]},{"line":"                    work_list.into_iter().zip(fees).collect::<Vec<_>>()","counters":[]},{"line":"                };","counters":[]},{"line":"","counters":[]},{"line":"                let (_proof, diff) = create_and_apply(","counters":[]},{"line":"                    None,","counters":[]},{"line":"                    None,","counters":[]},{"line":"                    &mut sl,","counters":[]},{"line":"                    cmds_this_iter,","counters":[]},{"line":"                    stmt_to_work_random_fee(&work_to_be_done, provers),","counters":[]},{"line":"                );","counters":[]},{"line":"","counters":[]},{"line":"                let sorted_work_from_diff1 = |pre_diff: &PreDiffWithAtMostTwoCoinbase| {","counters":[]},{"line":"                    let mut pre_diff = pre_diff.completed_works.clone();","counters":[]},{"line":"                    pre_diff.sort_by_key(|v| v.fee);","counters":[]},{"line":"                    pre_diff","counters":[]},{"line":"                };","counters":[]},{"line":"","counters":[]},{"line":"                let sorted_work_from_diff2 = |pre_diff: &Option<PreDiffWithAtMostOneCoinbase>| {","counters":[]},{"line":"                    pre_diff","counters":[]},{"line":"                        .as_ref()","counters":[]},{"line":"                        .map(|pre_diff| {","counters":[]},{"line":"                            let mut pre_diff = pre_diff.completed_works.clone();","counters":[]},{"line":"                            pre_diff.sort_by_key(|v| v.fee);","counters":[]},{"line":"                            pre_diff","counters":[]},{"line":"                        })","counters":[]},{"line":"                        .unwrap_or_else(Vec::new)","counters":[]},{"line":"                };","counters":[]},{"line":"","counters":[]},{"line":"                {","counters":[]},{"line":"                    let assert_same_fee = |cb: CoinbaseFeeTransfer, fee: Fee| {","counters":[]},{"line":"                        assert_eq!(cb.fee, fee);","counters":[]},{"line":"                    };","counters":[]},{"line":"","counters":[]},{"line":"                    let (first_pre_diff, second_pre_diff_opt) = &diff.diff;","counters":[]},{"line":"","counters":[]},{"line":"                    match (","counters":[]},{"line":"                        first_pre_diff.coinbase.clone(),","counters":[]},{"line":"                        second_pre_diff_opt","counters":[]},{"line":"                            .as_ref()","counters":[]},{"line":"                            .map(|d| d.coinbase.clone())","counters":[]},{"line":"                            .unwrap_or(AtMostOne::Zero),","counters":[]},{"line":"                    ) {","counters":[]},{"line":"                        (AtMostTwo::Zero, AtMostOne::Zero) => {}","counters":[]},{"line":"                        (AtMostTwo::Two(None), AtMostOne::Zero) => {}","counters":[]},{"line":"","counters":[]},{"line":"                        (AtMostTwo::One(ft_opt), AtMostOne::Zero) => {","counters":[]},{"line":"                            if let Some(single) = ft_opt {","counters":[]},{"line":"                                let work = sorted_work_from_diff1(first_pre_diff);","counters":[]},{"line":"                                let work = work[0].clone().forget();","counters":[]},{"line":"                                assert_same_fee(single, work.fee);","counters":[]},{"line":"                            };","counters":[]},{"line":"                        }","counters":[]},{"line":"","counters":[]},{"line":"                        (AtMostTwo::Zero, AtMostOne::One(ft_opt)) => {","counters":[]},{"line":"                            if let Some(single) = ft_opt {","counters":[]},{"line":"                                let work = sorted_work_from_diff2(second_pre_diff_opt);","counters":[]},{"line":"                                let work = work[0].clone().forget();","counters":[]},{"line":"                                assert_same_fee(single, work.fee);","counters":[]},{"line":"                            };","counters":[]},{"line":"                        }","counters":[]},{"line":"","counters":[]},{"line":"                        (AtMostTwo::Two(Some((ft, ft_opt))), AtMostOne::Zero) => {","counters":[]},{"line":"                            let work_done = sorted_work_from_diff1(first_pre_diff);","counters":[]},{"line":"                            let work = work_done[0].clone().forget();","counters":[]},{"line":"                            assert_same_fee(ft, work.fee);","counters":[]},{"line":"","counters":[]},{"line":"                            if let Some(single) = ft_opt {","counters":[]},{"line":"                                let work = util::drop(&work_done, 1);","counters":[]},{"line":"                                let work = work[0].clone().forget();","counters":[]},{"line":"                                assert_same_fee(single, work.fee);","counters":[]},{"line":"                            };","counters":[]},{"line":"                        }","counters":[]},{"line":"","counters":[]},{"line":"                        (AtMostTwo::One(_), AtMostOne::One(_)) => {","counters":[]},{"line":"                            panic!(\"Incorrect coinbase in the diff {:?}\", &diff)","counters":[]},{"line":"                        }","counters":[]},{"line":"                        (AtMostTwo::Two(_), AtMostOne::One(_)) => {","counters":[]},{"line":"                            panic!(\"Incorrect coinbase in the diff {:?}\", &diff)","counters":[]},{"line":"                        }","counters":[]},{"line":"                    }","counters":[]},{"line":"                }","counters":[]},{"line":"","counters":[]},{"line":"                proofs_available_left.remove(0);","counters":[]},{"line":"","counters":[]},{"line":"                eprintln!(","counters":[]},{"line":"                    \"######## Batch {} done: {} proofs ########\\n\",","counters":[]},{"line":"                    niters, proofs_available_this_iter","counters":[]},{"line":"                );","counters":[]},{"line":"","counters":[]},{"line":"                niters += 1;","counters":[]},{"line":"","counters":[]},{"line":"                (diff, proofs_available_left)","counters":[]},{"line":"            },","counters":[]},{"line":"        );","counters":[]},{"line":"","counters":[]},{"line":"        assert!(proofs_available_left.is_empty());","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// max throughput-random-random fee-number of proofs-worst case provers","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// Always at worst case number of provers","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L3188","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn max_throughput_random_number_fee_number_of_proofs_worst_case_provers() {","counters":[]},{"line":"        let mut rng = rand::thread_rng();","counters":[]},{"line":"","counters":[]},{"line":"        let (ledger_init_state, cmds, iters) = gen_at_capacity();","counters":[]},{"line":"","counters":[]},{"line":"        // How many proofs will be available at each iteration.","counters":[]},{"line":"        let proofs_available: Vec<(usize, Vec<Fee>)> = iters","counters":[]},{"line":"            .iter()","counters":[]},{"line":"            .map(|_| {","counters":[]},{"line":"                let number_of_proofs = rng.gen_range(0..TRANSACTION_CAPACITY * 2);","counters":[]},{"line":"                let fees = (0..number_of_proofs)","counters":[]},{"line":"                    .map(|_| {","counters":[]},{"line":"                        let fee = rng.gen_range(1..20);","counters":[]},{"line":"                        Fee::from_u64(fee)","counters":[]},{"line":"                    })","counters":[]},{"line":"                    .collect();","counters":[]},{"line":"","counters":[]},{"line":"                (number_of_proofs, fees)","counters":[]},{"line":"            })","counters":[]},{"line":"            .collect();","counters":[]},{"line":"","counters":[]},{"line":"        async_with_ledgers(","counters":[]},{"line":"            &ledger_init_state,","counters":[]},{"line":"            cmds.clone(),","counters":[]},{"line":"            iters.clone(),","counters":[]},{"line":"            |sl, test_mask| {","counters":[]},{"line":"                test_random_proof_fee(","counters":[]},{"line":"                    &ledger_init_state,","counters":[]},{"line":"                    cmds.clone(),","counters":[]},{"line":"                    iters.clone(),","counters":[]},{"line":"                    proofs_available.clone(),","counters":[]},{"line":"                    sl,","counters":[]},{"line":"                    test_mask,","counters":[]},{"line":"                    NumProvers::Many,","counters":[]},{"line":"                )","counters":[]},{"line":"            },","counters":[]},{"line":"        );","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// Max throughput-random fee","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L3214","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn max_throughput_random_fee() {","counters":[]},{"line":"        let mut rng = rand::thread_rng();","counters":[]},{"line":"","counters":[]},{"line":"        let (ledger_init_state, cmds, iters) = gen_at_capacity();","counters":[]},{"line":"","counters":[]},{"line":"        // How many proofs will be available at each iteration.","counters":[]},{"line":"        let proofs_available: Vec<(usize, Vec<Fee>)> = iters","counters":[]},{"line":"            .iter()","counters":[]},{"line":"            .map(|_| {","counters":[]},{"line":"                let number_of_proofs = TRANSACTION_CAPACITY;","counters":[]},{"line":"                // All proofs are available","counters":[]},{"line":"","counters":[]},{"line":"                let fees = (0..number_of_proofs)","counters":[]},{"line":"                    .map(|_| {","counters":[]},{"line":"                        let fee = rng.gen_range(1..20);","counters":[]},{"line":"                        Fee::from_u64(fee)","counters":[]},{"line":"                    })","counters":[]},{"line":"                    .collect();","counters":[]},{"line":"","counters":[]},{"line":"                (number_of_proofs, fees)","counters":[]},{"line":"            })","counters":[]},{"line":"            .collect();","counters":[]},{"line":"","counters":[]},{"line":"        async_with_ledgers(","counters":[]},{"line":"            &ledger_init_state,","counters":[]},{"line":"            cmds.clone(),","counters":[]},{"line":"            iters.clone(),","counters":[]},{"line":"            |sl, test_mask| {","counters":[]},{"line":"                test_random_proof_fee(","counters":[]},{"line":"                    &ledger_init_state,","counters":[]},{"line":"                    cmds.clone(),","counters":[]},{"line":"                    iters.clone(),","counters":[]},{"line":"                    proofs_available.clone(),","counters":[]},{"line":"                    sl,","counters":[]},{"line":"                    test_mask,","counters":[]},{"line":"                    NumProvers::Many,","counters":[]},{"line":"                )","counters":[]},{"line":"            },","counters":[]},{"line":"        );","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L3244","counters":[]},{"line":"    fn check_pending_coinbase() {","counters":[]},{"line":"        // TODO: this seems to be related to proof generation ? Which we don't support yet","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L3290","counters":[]},{"line":"    fn test_pending_coinbase(","counters":[]},{"line":"        init: &LedgerInitialState,","counters":[]},{"line":"        cmds: Vec<valid::UserCommand>,","counters":[]},{"line":"        cmd_iters: Vec<Option<usize>>,","counters":[]},{"line":"        proof_available: Vec<usize>,","counters":[]},{"line":"        state_body_hashes: Vec<(Fp, Fp)>,","counters":[]},{"line":"        current_state_view: &ProtocolStateView,","counters":[]},{"line":"        mut sl: StagedLedger,","counters":[]},{"line":"        test_mask: Mask,","counters":[]},{"line":"        provers: NumProvers,","counters":[]},{"line":"    ) {","counters":[]},{"line":"        let (proofs_available_left, _state_body_hashes_left) = iter_cmds_acc(","counters":[]},{"line":"            &cmds,","counters":[]},{"line":"            &cmd_iters,","counters":[]},{"line":"            (proof_available, state_body_hashes),","counters":[]},{"line":"            |cmds_left,","counters":[]},{"line":"             _count_opt,","counters":[]},{"line":"             cmds_this_iter,","counters":[]},{"line":"             (mut proofs_available_left, mut state_body_hashes)| {","counters":[]},{"line":"                let work_list = sl.scan_state.all_work_statements_exn();","counters":[]},{"line":"                let proofs_available_this_iter = proofs_available_left[0];","counters":[]},{"line":"","counters":[]},{"line":"                let state_body_hash = state_body_hashes[0];","counters":[]},{"line":"","counters":[]},{"line":"                let (proof, diff, _is_new_stack, _pc_update, _supercharge_coinbase) =","counters":[]},{"line":"                    create_and_apply_with_state_body_hash(","counters":[]},{"line":"                        None,","counters":[]},{"line":"                        None,","counters":[]},{"line":"                        current_state_view,","counters":[]},{"line":"                        state_body_hash,","counters":[]},{"line":"                        &mut sl,","counters":[]},{"line":"                        cmds_this_iter,","counters":[]},{"line":"                        stmt_to_work_restricted(","counters":[]},{"line":"                            util::take(&work_list, proofs_available_this_iter),","counters":[]},{"line":"                            provers,","counters":[]},{"line":"                        ),","counters":[]},{"line":"                    );","counters":[]},{"line":"","counters":[]},{"line":"                check_pending_coinbase();","counters":[]},{"line":"","counters":[]},{"line":"                assert_fee_excess(&proof);","counters":[]},{"line":"","counters":[]},{"line":"                let cmds_applied_this_iter = diff.commands().len();","counters":[]},{"line":"","counters":[]},{"line":"                let cb = coinbase_count(&diff);","counters":[]},{"line":"","counters":[]},{"line":"                assert!(proofs_available_this_iter == 0 || cb > 0);","counters":[]},{"line":"","counters":[]},{"line":"                match provers {","counters":[]},{"line":"                    NumProvers::One => assert!(cb <= 1),","counters":[]},{"line":"                    NumProvers::Many => assert!(cb <= 2),","counters":[]},{"line":"                }","counters":[]},{"line":"","counters":[]},{"line":"                let coinbase_cost = coinbase_cost(&diff);","counters":[]},{"line":"","counters":[]},{"line":"                assert_ledger(","counters":[]},{"line":"                    test_mask.clone(),","counters":[]},{"line":"                    coinbase_cost,","counters":[]},{"line":"                    &sl,","counters":[]},{"line":"                    cmds_left,","counters":[]},{"line":"                    cmds_applied_this_iter,","counters":[]},{"line":"                    &init_pks(init),","counters":[]},{"line":"                );","counters":[]},{"line":"","counters":[]},{"line":"                proofs_available_left.remove(0);","counters":[]},{"line":"                state_body_hashes.remove(0);","counters":[]},{"line":"","counters":[]},{"line":"                (diff, (proofs_available_left, state_body_hashes))","counters":[]},{"line":"            },","counters":[]},{"line":"        );","counters":[]},{"line":"","counters":[]},{"line":"        assert!(proofs_available_left.is_empty());","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L3348","counters":[]},{"line":"    fn pending_coinbase_test(prover: NumProvers) {","counters":[]},{"line":"        let mut rng = rand::thread_rng();","counters":[]},{"line":"","counters":[]},{"line":"        let (ledger_init_state, cmds, iters) = gen_below_capacity(Some(true));","counters":[]},{"line":"","counters":[]},{"line":"        let proofs_available: Vec<usize> = iters","counters":[]},{"line":"            .iter()","counters":[]},{"line":"            .map(|cmds_opt| rng.gen_range(0..(3 * cmds_opt.unwrap())))","counters":[]},{"line":"            .collect();","counters":[]},{"line":"","counters":[]},{"line":"        let state_body_hashes: Vec<(Fp, Fp)> = iters","counters":[]},{"line":"            .iter()","counters":[]},{"line":"            .map(|_| (Fp::rand(&mut rng), Fp::rand(&mut rng)))","counters":[]},{"line":"            .collect();","counters":[]},{"line":"","counters":[]},{"line":"        let current_state_view = dummy_state_view(None);","counters":[]},{"line":"","counters":[]},{"line":"        async_with_ledgers(","counters":[]},{"line":"            &ledger_init_state,","counters":[]},{"line":"            cmds.clone(),","counters":[]},{"line":"            iters.clone(),","counters":[]},{"line":"            |sl, test_mask| {","counters":[]},{"line":"                test_pending_coinbase(","counters":[]},{"line":"                    &ledger_init_state,","counters":[]},{"line":"                    cmds.clone(),","counters":[]},{"line":"                    iters.clone(),","counters":[]},{"line":"                    proofs_available.clone(),","counters":[]},{"line":"                    state_body_hashes.clone(),","counters":[]},{"line":"                    &current_state_view,","counters":[]},{"line":"                    sl,","counters":[]},{"line":"                    test_mask,","counters":[]},{"line":"                    prover,","counters":[]},{"line":"                )","counters":[]},{"line":"            },","counters":[]},{"line":"        );","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// Validate pending coinbase for random number of","counters":[]},{"line":"    /// commands-random number of proofs-one prover)","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L3379","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn validate_pending_coinbase_for_random_number_of_commands_one_prover() {","counters":[]},{"line":"        pending_coinbase_test(NumProvers::One);","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// Validate pending coinbase for random number of","counters":[]},{"line":"    /// commands-random number of proofs-many prover)","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L3383","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn validate_pending_coinbase_for_random_number_of_commands_many_prover() {","counters":[]},{"line":"        pending_coinbase_test(NumProvers::Many);","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L3387","counters":[]},{"line":"    fn timed_account(_n: usize) -> (Keypair, Account) {","counters":[]},{"line":"        let keypair = gen_keypair();","counters":[]},{"line":"        let account_id = AccountId::new(keypair.public.into_compressed(), TokenId::default());","counters":[]},{"line":"        let balance = Balance::from_u64(100_000_000_000);","counters":[]},{"line":"        // Should fully vest by slot = 7","counters":[]},{"line":"        let mut account = Account::create_with(account_id, balance);","counters":[]},{"line":"        account.timing = crate::Timing::Timed {","counters":[]},{"line":"            initial_minimum_balance: balance,","counters":[]},{"line":"            cliff_time: Slot::from_u32(4),","counters":[]},{"line":"            cliff_amount: Amount::zero(),","counters":[]},{"line":"            vesting_period: Slot::from_u32(2),","counters":[]},{"line":"            vesting_increment: Amount::from_u64(50_000_000_000),","counters":[]},{"line":"        };","counters":[]},{"line":"        (keypair, account)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L3410","counters":[]},{"line":"    fn untimed_account(_n: usize) -> (Keypair, Account) {","counters":[]},{"line":"        let keypair = gen_keypair();","counters":[]},{"line":"        let account_id = AccountId::new(keypair.public.into_compressed(), TokenId::default());","counters":[]},{"line":"        let balance = Balance::from_u64(100_000_000_000);","counters":[]},{"line":"        let account = Account::create_with(account_id, balance);","counters":[]},{"line":"        (keypair, account)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    fn stmt_to_work_zero_fee(","counters":[]},{"line":"        prover: CompressedPubKey,","counters":[]},{"line":"    ) -> impl Fn(&work::Statement) -> Option<work::Checked> {","counters":[]},{"line":"        move |stmts: &work::Statement| {","counters":[]},{"line":"            Some(work::Checked {","counters":[]},{"line":"                fee: Fee::zero(),","counters":[]},{"line":"                proofs: proofs(stmts),","counters":[]},{"line":"                prover: prover.clone(),","counters":[]},{"line":"            })","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L3425","counters":[]},{"line":"    fn supercharge_coinbase_test<F>(","counters":[]},{"line":"        this: Account,","counters":[]},{"line":"        delegator: Account,","counters":[]},{"line":"        block_count: usize,","counters":[]},{"line":"        f_expected_balance: F,","counters":[]},{"line":"        sl: &mut StagedLedger,","counters":[]},{"line":"    ) where","counters":[]},{"line":"        F: Fn(usize, Balance) -> Balance,","counters":[]},{"line":"    {","counters":[]},{"line":"        let coinbase_receiver = &this;","counters":[]},{"line":"        let init_balance = coinbase_receiver.balance;","counters":[]},{"line":"","counters":[]},{"line":"        let check_receiver_account = |sl: &StagedLedger, count: usize| {","counters":[]},{"line":"            let location = sl","counters":[]},{"line":"                .ledger","counters":[]},{"line":"                .location_of_account(&coinbase_receiver.id())","counters":[]},{"line":"                .unwrap();","counters":[]},{"line":"            let account = sl.ledger.get(location).unwrap();","counters":[]},{"line":"            dbg!(account.balance, f_expected_balance(count, init_balance));","counters":[]},{"line":"            assert_eq!(account.balance, f_expected_balance(count, init_balance));","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        (0..block_count).map(|n| n + 1).for_each(|block_count| {","counters":[]},{"line":"            create_and_apply_with_state_body_hash(","counters":[]},{"line":"                Some(coinbase_receiver.public_key.clone()),","counters":[]},{"line":"                Some(delegator.public_key.clone()),","counters":[]},{"line":"                &dummy_state_view(Some(Slot::from_u32(block_count.try_into().unwrap()))),","counters":[]},{"line":"                (Fp::zero(), Fp::zero()),","counters":[]},{"line":"                sl,","counters":[]},{"line":"                &[],","counters":[]},{"line":"                stmt_to_work_zero_fee(this.public_key.clone()),","counters":[]},{"line":"            );","counters":[]},{"line":"            check_receiver_account(sl, block_count);","counters":[]},{"line":"        });","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    const NORMAL_COINBASE: Amount = CONSTRAINT_CONSTANTS.coinbase_amount;","counters":[]},{"line":"","counters":[]},{"line":"    const fn scale_exn(amount: Amount, i: u64) -> Amount {","counters":[]},{"line":"        match amount.scale(i) {","counters":[]},{"line":"            Some(amount) => amount,","counters":[]},{"line":"            None => panic!(),","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    const SUPERCHARGED_COINBASE: Amount = scale_exn(","counters":[]},{"line":"        CONSTRAINT_CONSTANTS.coinbase_amount,","counters":[]},{"line":"        CONSTRAINT_CONSTANTS.supercharged_coinbase_factor,","counters":[]},{"line":"    );","counters":[]},{"line":"","counters":[]},{"line":"    /// Supercharged coinbase - staking","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L3468","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn supercharged_coinbase_staking() {","counters":[]},{"line":"        let (keypair_this, this) = timed_account(1);","counters":[]},{"line":"","counters":[]},{"line":"        // calculated from the timing values for timed_accounts","counters":[]},{"line":"        let slots_with_locked_tokens = 7;","counters":[]},{"line":"","counters":[]},{"line":"        let block_count = slots_with_locked_tokens + 5;","counters":[]},{"line":"","counters":[]},{"line":"        let f_expected_balance = |block_no: usize, init_balance: Balance| {","counters":[]},{"line":"            if block_no <= slots_with_locked_tokens {","counters":[]},{"line":"                init_balance","counters":[]},{"line":"                    .add_amount(scale_exn(NORMAL_COINBASE, block_no as u64))","counters":[]},{"line":"                    .unwrap()","counters":[]},{"line":"            } else {","counters":[]},{"line":"                // init balance +","counters":[]},{"line":"                //    (normal_coinbase * slots_with_locked_tokens) +","counters":[]},{"line":"                //    (supercharged_coinbase * remaining slots))*)","counters":[]},{"line":"                let balance = init_balance","counters":[]},{"line":"                    .add_amount(scale_exn(NORMAL_COINBASE, slots_with_locked_tokens as u64))","counters":[]},{"line":"                    .unwrap();","counters":[]},{"line":"                let amount = scale_exn(","counters":[]},{"line":"                    SUPERCHARGED_COINBASE,","counters":[]},{"line":"                    (block_no.checked_sub(slots_with_locked_tokens).unwrap()) as u64,","counters":[]},{"line":"                );","counters":[]},{"line":"                balance.add_amount(amount).unwrap()","counters":[]},{"line":"            }","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        let mut ledger_init_state = gen_initial_ledger_state();","counters":[]},{"line":"","counters":[]},{"line":"        ledger_init_state.state.insert(","counters":[]},{"line":"            0,","counters":[]},{"line":"            (","counters":[]},{"line":"                keypair_this,","counters":[]},{"line":"                this.balance.to_amount(),","counters":[]},{"line":"                this.nonce,","counters":[]},{"line":"                this.timing.clone(),","counters":[]},{"line":"            ),","counters":[]},{"line":"        );","counters":[]},{"line":"","counters":[]},{"line":"        async_with_ledgers(&ledger_init_state, vec![], vec![], |mut sl, _test_mask| {","counters":[]},{"line":"            supercharge_coinbase_test(","counters":[]},{"line":"                this.clone(),","counters":[]},{"line":"                this.clone(),","counters":[]},{"line":"                block_count,","counters":[]},{"line":"                f_expected_balance,","counters":[]},{"line":"                &mut sl,","counters":[]},{"line":"            )","counters":[]},{"line":"        });","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// Supercharged coinbase - unlocked account delegating to locked account","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L3505","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn supercharged_coinbase_unlocked_account_delegating_to_locked_account() {","counters":[]},{"line":"        let (keypair_this, locked_this) = timed_account(1);","counters":[]},{"line":"        let (keypair_delegator, unlocked_delegator) = untimed_account(1);","counters":[]},{"line":"","counters":[]},{"line":"        // calculated from the timing values for timed_accounts","counters":[]},{"line":"        let slots_with_locked_tokens = 7;","counters":[]},{"line":"","counters":[]},{"line":"        let block_count = slots_with_locked_tokens + 2;","counters":[]},{"line":"","counters":[]},{"line":"        let f_expected_balance = |block_no: usize, init_balance: Balance| {","counters":[]},{"line":"            init_balance","counters":[]},{"line":"                .add_amount(scale_exn(SUPERCHARGED_COINBASE, block_no as u64))","counters":[]},{"line":"                .unwrap()","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        let state = [","counters":[]},{"line":"            (","counters":[]},{"line":"                keypair_this,","counters":[]},{"line":"                locked_this.balance.to_amount(),","counters":[]},{"line":"                locked_this.nonce,","counters":[]},{"line":"                locked_this.timing.clone(),","counters":[]},{"line":"            ),","counters":[]},{"line":"            (","counters":[]},{"line":"                keypair_delegator,","counters":[]},{"line":"                unlocked_delegator.balance.to_amount(),","counters":[]},{"line":"                unlocked_delegator.nonce,","counters":[]},{"line":"                unlocked_delegator.timing.clone(),","counters":[]},{"line":"            ),","counters":[]},{"line":"        ]","counters":[]},{"line":"        .into_iter()","counters":[]},{"line":"        .chain(gen_initial_ledger_state().state)","counters":[]},{"line":"        .collect();","counters":[]},{"line":"","counters":[]},{"line":"        let ledger_init_state = LedgerInitialState { state };","counters":[]},{"line":"","counters":[]},{"line":"        async_with_ledgers(&ledger_init_state, vec![], vec![], |mut sl, _test_mask| {","counters":[]},{"line":"            supercharge_coinbase_test(","counters":[]},{"line":"                locked_this.clone(),","counters":[]},{"line":"                unlocked_delegator.clone(),","counters":[]},{"line":"                block_count,","counters":[]},{"line":"                f_expected_balance,","counters":[]},{"line":"                &mut sl,","counters":[]},{"line":"            )","counters":[]},{"line":"        });","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// Supercharged coinbase - locked account delegating to unlocked account","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L3537","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn supercharged_coinbase_locked_account_delegating_to_unlocked_account() {","counters":[]},{"line":"        let (keypair_this, unlocked_this) = untimed_account(1);","counters":[]},{"line":"        let (keypair_delegator, locked_delegator) = timed_account(1);","counters":[]},{"line":"","counters":[]},{"line":"        // calculated from the timing values for timed_accounts","counters":[]},{"line":"        let slots_with_locked_tokens = 7;","counters":[]},{"line":"","counters":[]},{"line":"        let block_count = slots_with_locked_tokens + 2;","counters":[]},{"line":"","counters":[]},{"line":"        let f_expected_balance = |block_no: usize, init_balance: Balance| {","counters":[]},{"line":"            if block_no <= slots_with_locked_tokens {","counters":[]},{"line":"                init_balance","counters":[]},{"line":"                    .add_amount(scale_exn(NORMAL_COINBASE, block_no as u64))","counters":[]},{"line":"                    .unwrap()","counters":[]},{"line":"            } else {","counters":[]},{"line":"                // init balance +","counters":[]},{"line":"                //    (normal_coinbase * slots_with_locked_tokens) +","counters":[]},{"line":"                //    (supercharged_coinbase * remaining slots))*)","counters":[]},{"line":"                let balance = init_balance","counters":[]},{"line":"                    .add_amount(scale_exn(NORMAL_COINBASE, slots_with_locked_tokens as u64))","counters":[]},{"line":"                    .unwrap();","counters":[]},{"line":"                let amount = scale_exn(","counters":[]},{"line":"                    SUPERCHARGED_COINBASE,","counters":[]},{"line":"                    (block_no.checked_sub(slots_with_locked_tokens).unwrap()) as u64,","counters":[]},{"line":"                );","counters":[]},{"line":"                balance.add_amount(amount).unwrap()","counters":[]},{"line":"            }","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        let state = [","counters":[]},{"line":"            (","counters":[]},{"line":"                keypair_this,","counters":[]},{"line":"                unlocked_this.balance.to_amount(),","counters":[]},{"line":"                unlocked_this.nonce,","counters":[]},{"line":"                unlocked_this.timing.clone(),","counters":[]},{"line":"            ),","counters":[]},{"line":"            (","counters":[]},{"line":"                keypair_delegator,","counters":[]},{"line":"                locked_delegator.balance.to_amount(),","counters":[]},{"line":"                locked_delegator.nonce,","counters":[]},{"line":"                locked_delegator.timing.clone(),","counters":[]},{"line":"            ),","counters":[]},{"line":"        ]","counters":[]},{"line":"        .into_iter()","counters":[]},{"line":"        .chain(gen_initial_ledger_state().state)","counters":[]},{"line":"        .collect();","counters":[]},{"line":"","counters":[]},{"line":"        let ledger_init_state = LedgerInitialState { state };","counters":[]},{"line":"","counters":[]},{"line":"        async_with_ledgers(&ledger_init_state, vec![], vec![], |mut sl, _test_mask| {","counters":[]},{"line":"            supercharge_coinbase_test(","counters":[]},{"line":"                unlocked_this.clone(),","counters":[]},{"line":"                locked_delegator.clone(),","counters":[]},{"line":"                block_count,","counters":[]},{"line":"                f_expected_balance,","counters":[]},{"line":"                &mut sl,","counters":[]},{"line":"            )","counters":[]},{"line":"        });","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// Supercharged coinbase - locked account delegating to locked account","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L3580","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn supercharged_coinbase_locked_account_delegating_to_locked_account() {","counters":[]},{"line":"        let (keypair_this, locked_this) = timed_account(1);","counters":[]},{"line":"        let (keypair_delegator, locked_delegator) = timed_account(2);","counters":[]},{"line":"","counters":[]},{"line":"        // calculated from the timing values for timed_accounts","counters":[]},{"line":"        let slots_with_locked_tokens = 7;","counters":[]},{"line":"","counters":[]},{"line":"        let block_count = slots_with_locked_tokens;","counters":[]},{"line":"","counters":[]},{"line":"        let f_expected_balance = |block_no: usize, init_balance: Balance| {","counters":[]},{"line":"            // running the test as long as both the accounts remain locked and hence","counters":[]},{"line":"            // normal coinbase in all the blocks","counters":[]},{"line":"            init_balance","counters":[]},{"line":"                .add_amount(scale_exn(NORMAL_COINBASE, block_no as u64))","counters":[]},{"line":"                .unwrap()","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        let state = [","counters":[]},{"line":"            (","counters":[]},{"line":"                keypair_this,","counters":[]},{"line":"                locked_this.balance.to_amount(),","counters":[]},{"line":"                locked_this.nonce,","counters":[]},{"line":"                locked_this.timing.clone(),","counters":[]},{"line":"            ),","counters":[]},{"line":"            (","counters":[]},{"line":"                keypair_delegator,","counters":[]},{"line":"                locked_delegator.balance.to_amount(),","counters":[]},{"line":"                locked_delegator.nonce,","counters":[]},{"line":"                locked_delegator.timing.clone(),","counters":[]},{"line":"            ),","counters":[]},{"line":"        ]","counters":[]},{"line":"        .into_iter()","counters":[]},{"line":"        .chain(gen_initial_ledger_state().state)","counters":[]},{"line":"        .collect();","counters":[]},{"line":"","counters":[]},{"line":"        let ledger_init_state = LedgerInitialState { state };","counters":[]},{"line":"","counters":[]},{"line":"        async_with_ledgers(&ledger_init_state, vec![], vec![], |mut sl, _test_mask| {","counters":[]},{"line":"            supercharge_coinbase_test(","counters":[]},{"line":"                locked_this.clone(),","counters":[]},{"line":"                locked_delegator.clone(),","counters":[]},{"line":"                block_count,","counters":[]},{"line":"                f_expected_balance,","counters":[]},{"line":"                &mut sl,","counters":[]},{"line":"            )","counters":[]},{"line":"        });","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L3612","counters":[]},{"line":"    fn command_insufficient_funds() -> (LedgerInitialState, valid::UserCommand) {","counters":[]},{"line":"        let ledger_initial_state = gen_initial_ledger_state();","counters":[]},{"line":"        let (kp, balance, nonce, _) = &ledger_initial_state.state[0];","counters":[]},{"line":"","counters":[]},{"line":"        let receiver_pk = gen_keypair().public.into_compressed();","counters":[]},{"line":"","counters":[]},{"line":"        let insufficient_account_creation_fee =","counters":[]},{"line":"            Amount::from_u64(CONSTRAINT_CONSTANTS.account_creation_fee.as_u64() / 2);","counters":[]},{"line":"","counters":[]},{"line":"        let source_pk = kp.public.into_compressed();","counters":[]},{"line":"","counters":[]},{"line":"        let body = signed_command::Body::Payment(PaymentPayload {","counters":[]},{"line":"            source_pk: source_pk.clone(),","counters":[]},{"line":"            receiver_pk,","counters":[]},{"line":"            amount: insufficient_account_creation_fee,","counters":[]},{"line":"        });","counters":[]},{"line":"        let fee = Fee::from_u64(balance.as_u64());","counters":[]},{"line":"","counters":[]},{"line":"        let payload =","counters":[]},{"line":"            SignedCommandPayload::create(fee, source_pk, *nonce, None, Memo::dummy(), body);","counters":[]},{"line":"","counters":[]},{"line":"        let payload_to_sign = TransactionUnionPayload::of_user_command_payload(&payload);","counters":[]},{"line":"","counters":[]},{"line":"        let mut signer = mina_signer::create_legacy(mina_signer::NetworkId::TESTNET);","counters":[]},{"line":"        let signature = signer.sign(kp, &payload_to_sign);","counters":[]},{"line":"","counters":[]},{"line":"        let signed_command = SignedCommand {","counters":[]},{"line":"            payload,","counters":[]},{"line":"            signer: kp.public.into_compressed(),","counters":[]},{"line":"            signature,","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        let cmd = valid::UserCommand::SignedCommand(Box::new(signed_command));","counters":[]},{"line":"        (ledger_initial_state, cmd)","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// Commands with Insufficient funds are not included","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L3643","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn commands_with_insufficient_funds_are_not_included() {","counters":[]},{"line":"        let (ledger_init_state, invalid_commands) = command_insufficient_funds();","counters":[]},{"line":"","counters":[]},{"line":"        async_with_ledgers(","counters":[]},{"line":"            &ledger_init_state,","counters":[]},{"line":"            vec![invalid_commands.clone()],","counters":[]},{"line":"            vec![],","counters":[]},{"line":"            |sl, _test_mask| {","counters":[]},{"line":"                let (diff, _invalid_txns) = sl","counters":[]},{"line":"                    .create_diff(","counters":[]},{"line":"                        &CONSTRAINT_CONSTANTS,","counters":[]},{"line":"                        None,","counters":[]},{"line":"                        COINBASE_RECEIVER.clone(),","counters":[]},{"line":"                        (),","counters":[]},{"line":"                        &dummy_state_view(None),","counters":[]},{"line":"                        vec![invalid_commands.clone()],","counters":[]},{"line":"                        stmt_to_work_zero_fee(SELF_PK.clone()),","counters":[]},{"line":"                        false,","counters":[]},{"line":"                    )","counters":[]},{"line":"                    .unwrap();","counters":[]},{"line":"","counters":[]},{"line":"                assert!(diff.commands().is_empty());","counters":[]},{"line":"            },","counters":[]},{"line":"        );","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// Blocks having commands with insufficient funds are rejected","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L3665","counters":[]},{"line":"    #[test]","counters":[]},{"line":"    fn blocks_having_commands_with_sufficient_funds_are_rejected() {","counters":[]},{"line":"        enum Validity {","counters":[]},{"line":"            Valid,","counters":[]},{"line":"            Invalid,","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"        let ledger_init_state = gen_initial_ledger_state();","counters":[]},{"line":"        // let (kp, balance, nonce, _) = &ledger_initial_state.state[0];","counters":[]},{"line":"","counters":[]},{"line":"        let command = |kp: Keypair, balance: Amount, nonce: Nonce, validity: Validity| {","counters":[]},{"line":"            let receiver_pk = gen_keypair().public.into_compressed();","counters":[]},{"line":"","counters":[]},{"line":"            let (account_creation_fee, fee) = {","counters":[]},{"line":"                match validity {","counters":[]},{"line":"                    Validity::Valid => {","counters":[]},{"line":"                        let account_creation_fee =","counters":[]},{"line":"                            Amount::of_fee(&CONSTRAINT_CONSTANTS.account_creation_fee);","counters":[]},{"line":"                        let fee = balance.checked_sub(&account_creation_fee).unwrap();","counters":[]},{"line":"                        (account_creation_fee, Fee::from_u64(fee.as_u64()))","counters":[]},{"line":"                    }","counters":[]},{"line":"                    Validity::Invalid => {","counters":[]},{"line":"                        // Not enough account creation fee and using full balance for fee","counters":[]},{"line":"                        let account_creation_fee =","counters":[]},{"line":"                            CONSTRAINT_CONSTANTS.account_creation_fee.as_u64() / 2;","counters":[]},{"line":"                        let account_creation_fee = Amount::from_u64(account_creation_fee);","counters":[]},{"line":"                        (account_creation_fee, Fee::from_u64(balance.as_u64()))","counters":[]},{"line":"                    }","counters":[]},{"line":"                }","counters":[]},{"line":"            };","counters":[]},{"line":"","counters":[]},{"line":"            let source_pk = kp.public.into_compressed();","counters":[]},{"line":"            let body = signed_command::Body::Payment(PaymentPayload {","counters":[]},{"line":"                source_pk: source_pk.clone(),","counters":[]},{"line":"                receiver_pk,","counters":[]},{"line":"                amount: account_creation_fee,","counters":[]},{"line":"            });","counters":[]},{"line":"            let payload = signed_command::SignedCommandPayload::create(","counters":[]},{"line":"                fee,","counters":[]},{"line":"                source_pk,","counters":[]},{"line":"                nonce,","counters":[]},{"line":"                None,","counters":[]},{"line":"                Memo::dummy(),","counters":[]},{"line":"                body,","counters":[]},{"line":"            );","counters":[]},{"line":"","counters":[]},{"line":"            let payload_to_sign = TransactionUnionPayload::of_user_command_payload(&payload);","counters":[]},{"line":"","counters":[]},{"line":"            let mut signer = mina_signer::create_legacy(mina_signer::NetworkId::TESTNET);","counters":[]},{"line":"            let signature = signer.sign(&kp, &payload_to_sign);","counters":[]},{"line":"","counters":[]},{"line":"            let signed_command = SignedCommand {","counters":[]},{"line":"                payload,","counters":[]},{"line":"                signer: kp.public.into_compressed(),","counters":[]},{"line":"                signature,","counters":[]},{"line":"            };","counters":[]},{"line":"","counters":[]},{"line":"            valid::UserCommand::SignedCommand(Box::new(signed_command))","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        let signed_command = {","counters":[]},{"line":"            let (kp, balance, nonce, _) = ledger_init_state.state[0].clone();","counters":[]},{"line":"            command(kp, balance, nonce, Validity::Valid)","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        let invalid_command = {","counters":[]},{"line":"            let (kp, balance, nonce, _) = ledger_init_state.state[1].clone();","counters":[]},{"line":"            command(kp, balance, nonce, Validity::Invalid)","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        async_with_ledgers(","counters":[]},{"line":"            &ledger_init_state,","counters":[]},{"line":"            vec![invalid_command.clone(), signed_command.clone()],","counters":[]},{"line":"            vec![],","counters":[]},{"line":"            |mut sl, _test_mask| {","counters":[]},{"line":"                let (diff, _invalid_txns) = sl","counters":[]},{"line":"                    .create_diff(","counters":[]},{"line":"                        &CONSTRAINT_CONSTANTS,","counters":[]},{"line":"                        None,","counters":[]},{"line":"                        COINBASE_RECEIVER.clone(),","counters":[]},{"line":"                        (),","counters":[]},{"line":"                        &dummy_state_view(None),","counters":[]},{"line":"                        vec![signed_command.clone()],","counters":[]},{"line":"                        stmt_to_work_zero_fee(SELF_PK.clone()),","counters":[]},{"line":"                        false,","counters":[]},{"line":"                    )","counters":[]},{"line":"                    .unwrap();","counters":[]},{"line":"","counters":[]},{"line":"                assert_eq!(diff.commands().len(), 1);","counters":[]},{"line":"","counters":[]},{"line":"                let (mut f, s) = diff.diff;","counters":[]},{"line":"","counters":[]},{"line":"                let failed_command = WithStatus {","counters":[]},{"line":"                    data: invalid_command.clone(),","counters":[]},{"line":"                    status: TransactionStatus::Failed(vec![vec![","counters":[]},{"line":"                        TransactionFailure::AmountInsufficientToCreateAccount,","counters":[]},{"line":"                    ]]),","counters":[]},{"line":"                };","counters":[]},{"line":"","counters":[]},{"line":"                // Replace the valid command with an invalid command","counters":[]},{"line":"                f.commands = vec![failed_command];","counters":[]},{"line":"                let diff = with_valid_signatures_and_proofs::Diff { diff: (f, s) };","counters":[]},{"line":"","counters":[]},{"line":"                let res = sl.apply(","counters":[]},{"line":"                    None,","counters":[]},{"line":"                    &CONSTRAINT_CONSTANTS,","counters":[]},{"line":"                    diff.forget(),","counters":[]},{"line":"                    (),","counters":[]},{"line":"                    &Verifier,","counters":[]},{"line":"                    &dummy_state_view(None),","counters":[]},{"line":"                    (Fp::zero(), Fp::zero()),","counters":[]},{"line":"                    COINBASE_RECEIVER.clone(),","counters":[]},{"line":"                    false,","counters":[]},{"line":"                );","counters":[]},{"line":"","counters":[]},{"line":"                let expected = format!(","counters":[]},{"line":"                    \"Error when applying transaction: {:?}\",","counters":[]},{"line":"                    TransactionFailure::SourceInsufficientBalance.to_string()","counters":[]},{"line":"                );","counters":[]},{"line":"","counters":[]},{"line":"                assert!(","counters":[]},{"line":"                    matches!(&res, Err(StagedLedgerError::Unexpected(s)) if {","counters":[]},{"line":"                        s == &expected","counters":[]},{"line":"                    }),","counters":[]},{"line":"                    \"{:?}\",","counters":[]},{"line":"                    res","counters":[]},{"line":"                );","counters":[]},{"line":"            },","counters":[]},{"line":"        );","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"    /// Mismatched verification keys in zkApp accounts and and transactions","counters":[]},{"line":"    ///","counters":[]},{"line":"    /// https://github.com/MinaProtocol/mina/blob/3753a8593cc1577bcf4da16620daf9946d88e8e5/src/lib/staged_ledger/staged_ledger.ml#L3776","counters":[]},{"line":"    // #[test] // TODO: This test requires the prover","counters":[]},{"line":"    #[allow(unused)]","counters":[]},{"line":"    fn mismatched_vk_in_zkapp_accounts_and_transactions() {","counters":[]},{"line":"        use scan_state::transaction_logic::for_tests::{TestSpec, UpdateStatesSpec};","counters":[]},{"line":"","counters":[]},{"line":"        let test_spec = TestSpec::gen();","counters":[]},{"line":"","counters":[]},{"line":"        let pks: HashSet<_> = test_spec","counters":[]},{"line":"            .init_ledger","counters":[]},{"line":"            .0","counters":[]},{"line":"            .iter()","counters":[]},{"line":"            .map(|(kp, _)| HashableCompressedPubKey(kp.public.into_compressed()))","counters":[]},{"line":"            .collect();","counters":[]},{"line":"","counters":[]},{"line":"        let kp = loop {","counters":[]},{"line":"            let keypair = gen_keypair();","counters":[]},{"line":"            if !pks.contains(&HashableCompressedPubKey(keypair.public.into_compressed())) {","counters":[]},{"line":"                break keypair;","counters":[]},{"line":"            }","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        let TestSpec {","counters":[]},{"line":"            init_ledger,","counters":[]},{"line":"            specs: _,","counters":[]},{"line":"        } = test_spec;","counters":[]},{"line":"        let new_kp = kp;","counters":[]},{"line":"","counters":[]},{"line":"        let fee = Fee::from_u64(1_000_000);","counters":[]},{"line":"        let amount = Amount::from_u64(10_000_000_000);","counters":[]},{"line":"","counters":[]},{"line":"        let snapp_pk = new_kp.public.into_compressed();","counters":[]},{"line":"","counters":[]},{"line":"        let mut snapp_update = zkapp_command::Update::dummy();","counters":[]},{"line":"        snapp_update.delegate = SetOrKeep::Set(snapp_pk.clone());","counters":[]},{"line":"","counters":[]},{"line":"        let memo = Memo::dummy();","counters":[]},{"line":"","counters":[]},{"line":"        let test_spec = UpdateStatesSpec {","counters":[]},{"line":"            fee,","counters":[]},{"line":"            sender: (new_kp.clone(), Nonce::zero()),","counters":[]},{"line":"            fee_payer: None,","counters":[]},{"line":"            receivers: vec![],","counters":[]},{"line":"            amount,","counters":[]},{"line":"            zkapp_account_keypairs: vec![new_kp],","counters":[]},{"line":"            memo,","counters":[]},{"line":"            new_zkapp_account: false,","counters":[]},{"line":"            snapp_update,","counters":[]},{"line":"            current_auth: AuthRequired::Proof,","counters":[]},{"line":"            sequence_events: vec![],","counters":[]},{"line":"            events: vec![],","counters":[]},{"line":"            call_data: Fp::zero(),","counters":[]},{"line":"            preconditions: None,","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        let mut ledger = Mask::new_unattached(CONSTRAINT_CONSTANTS.ledger_depth as usize);","counters":[]},{"line":"","counters":[]},{"line":"        init_ledger.init(&mut ledger);","counters":[]},{"line":"","counters":[]},{"line":"        // create a snapp account","counters":[]},{"line":"        let mut snapp_permissions = Permissions::user_default();","counters":[]},{"line":"        snapp_permissions.set_delegate = AuthRequired::Proof;","counters":[]},{"line":"","counters":[]},{"line":"        let snapp_account_id = AccountId::new(snapp_pk, TokenId::default());","counters":[]},{"line":"","counters":[]},{"line":"        let dummy_vk = {","counters":[]},{"line":"            let dummy_vk = VerificationKey::dummy();","counters":[]},{"line":"            let vk_hash = dummy_vk.digest();","counters":[]},{"line":"","counters":[]},{"line":"            WithHash {","counters":[]},{"line":"                data: dummy_vk,","counters":[]},{"line":"                hash: vk_hash,","counters":[]},{"line":"            }","counters":[]},{"line":"        };","counters":[]},{"line":"","counters":[]},{"line":"        #[allow(clippy::let_unit_value)]","counters":[]},{"line":"        let valid_against_ledger = {","counters":[]},{"line":"            let mut new_mask = ledger.make_child();","counters":[]},{"line":"            // for_tests::create_trivial_zkapp_account(Some(snapp_permissions), vk, &mut new_mask, snapp_pk);","counters":[]},{"line":"        };","counters":[]},{"line":"    }","counters":[]},{"line":"}","counters":[]}]}