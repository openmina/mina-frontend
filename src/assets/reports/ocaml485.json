{"filename":"src/lib/sgn/sgn.ml","lines":[{"line":"[%%import \"/src/config.mlh\"]","counters":[]},{"line":"","counters":[]},{"line":"open Core_kernel","counters":[]},{"line":"open Snark_params.Tick","counters":[]},{"line":"","counters":[]},{"line":"[%%versioned","counters":[]},{"line":"module Stable = struct","counters":[]},{"line":"  module V1 = struct","counters":[]},{"line":"    type t = Sgn_type.Sgn.Stable.V1.t = Pos | Neg","counters":[{"col_start":4,"col_end":4,"count":2},{"col_start":9,"col_end":9,"count":2},{"col_start":40,"col_end":40,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"    [@@deriving sexp, hash, compare, equal, yojson]","counters":[{"col_start":50,"col_end":50,"count":5}]},{"line":"","counters":[]},{"line":"    let to_latest = Fn.id","counters":[]},{"line":"  end","counters":[]},{"line":"end]","counters":[]},{"line":"","counters":[]},{"line":"let gen =","counters":[]},{"line":"  Quickcheck.Generator.map Bool.quickcheck_generator ~f:(fun b ->","counters":[{"col_start":25,"col_end":25,"count":1}]},{"line":"      if b then Pos else Neg )","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"let negate = function Pos -> Neg | Neg -> Pos","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"let neg_one = Field.(negate one)","counters":[{"col_start":26,"col_end":26,"count":1}]},{"line":"","counters":[]},{"line":"let to_field = function Pos -> Field.one | Neg -> neg_one","counters":[{"col_start":24,"col_end":24,"count":1},{"col_start":43,"col_end":43,"count":1}]},{"line":"","counters":[]},{"line":"let of_field_exn x =","counters":[]},{"line":"  if Field.equal x Field.one then Pos","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"  else if Field.equal x neg_one then Neg","counters":[{"col_start":7,"col_end":7,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"  else failwith \"Sgn.of_field: Expected positive or negative 1\"","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"","counters":[]},{"line":"[%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"type var = Field.Var.t","counters":[]},{"line":"","counters":[]},{"line":"let typ : (var, t) Typ.t =","counters":[]},{"line":"  let open Typ in","counters":[]},{"line":"  Typ","counters":[]},{"line":"    { check =","counters":[]},{"line":"        (fun x ->","counters":[]},{"line":"          make_checked_ast @@ assert_r1cs x x (Field.Var.constant Field.one) )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"    ; var_to_fields = (fun t -> ([| t |], ()))","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"    ; var_of_fields = (fun (ts, ()) -> ts.(0))","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"    ; value_to_fields = (fun t -> ([| to_field t |], ()))","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"    ; value_of_fields = (fun (ts, ()) -> of_field_exn ts.(0))","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"    ; size_in_field_elements = 1","counters":[]},{"line":"    ; constraint_system_auxiliary = (fun () -> ())","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"module Checked = struct","counters":[]},{"line":"  let two = Field.of_int 2","counters":[{"col_start":23,"col_end":23,"count":1}]},{"line":"","counters":[]},{"line":"  let neg_two = Field.negate two","counters":[{"col_start":27,"col_end":27,"count":1}]},{"line":"","counters":[]},{"line":"  let one_half = Field.inv two","counters":[{"col_start":25,"col_end":25,"count":1}]},{"line":"","counters":[]},{"line":"  let neg_one_half = Field.negate one_half","counters":[{"col_start":32,"col_end":32,"count":1}]},{"line":"","counters":[]},{"line":"  let is_pos (v : var) =","counters":[]},{"line":"    Boolean.Unsafe.of_cvar","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (let open Field.Checked in","counters":[]},{"line":"      one_half * (v + Field.Var.constant Field.one))","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"  let is_neg (v : var) =","counters":[]},{"line":"    Boolean.Unsafe.of_cvar","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (let open Field.Checked in","counters":[]},{"line":"      neg_one_half * (v - Field.Var.constant Field.one))","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"","counters":[]},{"line":"  let pos_if_true (b : Boolean.var) =","counters":[]},{"line":"    let open Field.Checked in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    (two * (b :> Field.Var.t)) - Field.Var.constant Field.one","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"","counters":[]},{"line":"  let neg_if_true (b : Boolean.var) =","counters":[]},{"line":"    let open Field.Checked in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    (neg_two * (b :> Field.Var.t)) + Field.Var.constant Field.one","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"","counters":[]},{"line":"  let negate t = Field.Var.scale t neg_one","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"","counters":[]},{"line":"  let constant = Fn.compose Field.Var.constant to_field","counters":[{"col_start":26,"col_end":26,"count":1}]},{"line":"","counters":[]},{"line":"  let neg = constant Neg","counters":[{"col_start":19,"col_end":19,"count":1}]},{"line":"","counters":[]},{"line":"  let pos = constant Pos","counters":[{"col_start":19,"col_end":19,"count":1}]},{"line":"","counters":[]},{"line":"  let if_ = Field.Checked.if_","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"[%%endif]","counters":[]}]}