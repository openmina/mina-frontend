{"filename":"src/lib/merkle_list_verifier/merkle_list_verifier.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"module type Inputs_intf = sig","counters":[]},{"line":"  type proof_elem","counters":[]},{"line":"","counters":[]},{"line":"  type hash [@@deriving equal]","counters":[]},{"line":"","counters":[]},{"line":"  val hash : hash -> proof_elem -> hash","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make_intf (Input : Inputs_intf) = struct","counters":[]},{"line":"  module type S = sig","counters":[]},{"line":"    val verify :","counters":[]},{"line":"         init:Input.hash","counters":[]},{"line":"      -> Input.proof_elem list","counters":[]},{"line":"      -> Input.hash","counters":[]},{"line":"      -> Input.hash Non_empty_list.t option","counters":[]},{"line":"","counters":[]},{"line":"    val verify_right :","counters":[]},{"line":"         init:Input.hash","counters":[]},{"line":"      -> Input.proof_elem list","counters":[]},{"line":"      -> Input.hash","counters":[]},{"line":"      -> Input.hash Non_empty_list.t option","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make (Input : Inputs_intf) : Make_intf(Input).S = struct","counters":[]},{"line":"  open Input","counters":[]},{"line":"","counters":[]},{"line":"  (* TODO: probably [verify_right] is the right thing in most cases, because we want","counters":[]},{"line":"     hashes to start with that, as we build up a list; the default left fold combines","counters":[]},{"line":"     the init hash with the head element","counters":[]},{"line":"","counters":[]},{"line":"     leaving the default [verify] because it's used a few places in the code","counters":[]},{"line":"  *)","counters":[]},{"line":"  let verify, verify_right =","counters":[]},{"line":"    let conser acc proof_elem =","counters":[]},{"line":"      Non_empty_list.cons (hash (Non_empty_list.head acc) proof_elem) acc","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"    in","counters":[]},{"line":"    let verify ~init merkle_list target_hash =","counters":[]},{"line":"      let hashes =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        List.fold merkle_list ~init:(Non_empty_list.singleton init) ~f:conser","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"      in","counters":[]},{"line":"      if equal_hash target_hash (Non_empty_list.head hashes) then Some hashes","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":51,"col_end":51,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"      else None","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"    in","counters":[]},{"line":"    let verify_right ~init merkle_list target_hash =","counters":[]},{"line":"      let hashes =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        List.fold_right merkle_list","counters":[]},{"line":"          ~init:(Non_empty_list.singleton init)","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"          ~f:(Fn.flip conser)","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"      in","counters":[]},{"line":"      if equal_hash target_hash (Non_empty_list.head hashes) then Some hashes","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":51,"col_end":51,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"      else None","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"    in","counters":[]},{"line":"    (verify, verify_right)","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}