{"filename":"src/lib/signature_lib/private_key.ml","lines":[{"line":"[%%import \"/src/config.mlh\"]","counters":[]},{"line":"","counters":[{"col_start":0,"col_end":0,"count":1}]},{"line":"open Core_kernel","counters":[]},{"line":"open Snark_params.Tick","counters":[]},{"line":"","counters":[]},{"line":"[%%versioned","counters":[]},{"line":"module Stable = struct","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"  module V1 = struct","counters":[]},{"line":"    [@@@with_all_version_tags]","counters":[]},{"line":"","counters":[]},{"line":"    type t = (Inner_curve.Scalar.t[@version_asserted])","counters":[{"col_start":4,"col_end":4,"count":4},{"col_start":9,"col_end":9,"count":2}]},{"line":"    [@@deriving compare, sexp]","counters":[{"col_start":29,"col_end":29,"count":15}]},{"line":"","counters":[]},{"line":"    (* deriver not working, apparently *)","counters":[]},{"line":"    let sexp_of_t = [%sexp_of: Inner_curve.Scalar.t]","counters":[]},{"line":"","counters":[]},{"line":"    let t_of_sexp = [%of_sexp: Inner_curve.Scalar.t]","counters":[]},{"line":"","counters":[]},{"line":"    let to_latest = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"    [%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"    let gen =","counters":[]},{"line":"      let open Snark_params.Tick.Inner_curve.Scalar in","counters":[]},{"line":"      let upperbound = Bignum_bigint.(pred size |> to_string) |> of_string in","counters":[{"col_start":51,"col_end":51,"count":1},{"col_start":59,"col_end":59,"count":1}]},{"line":"      gen_uniform_incl one upperbound","counters":[{"col_start":6,"col_end":6,"count":1},{"col_start":21,"col_end":21,"count":1}]},{"line":"","counters":[]},{"line":"    [%%else]","counters":[]},{"line":"","counters":[]},{"line":"    let gen = Inner_curve.Scalar.(gen_uniform_incl one (zero - one))","counters":[]},{"line":"","counters":[]},{"line":"    [%%endif]","counters":[]},{"line":"  end","counters":[]},{"line":"end]","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"[%%define_locally Stable.Latest.(gen)]","counters":[]},{"line":"","counters":[]},{"line":"[%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"let create () =","counters":[]},{"line":"  (* This calls into libsnark which uses /dev/urandom *)","counters":[]},{"line":"  Inner_curve.Scalar.random ()","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"[%%else]","counters":[]},{"line":"","counters":[]},{"line":"let create () : t =","counters":[]},{"line":"  let open Js_of_ocaml in","counters":[]},{"line":"  let random_bytes_32 =","counters":[]},{"line":"    Js.Unsafe.js_expr","counters":[]},{"line":"      {js|(function() {","counters":[]},{"line":"        var topLevel = (typeof self === 'object' && self.self === self && self) ||","counters":[]},{"line":"          (typeof global === 'object' && global.global === global && global) ||","counters":[]},{"line":"          this;","counters":[]},{"line":"        var b;","counters":[]},{"line":"","counters":[]},{"line":"        if (topLevel.crypto && topLevel.crypto.getRandomValues) {","counters":[]},{"line":"          b = new Uint8Array(32);","counters":[]},{"line":"          topLevel.crypto.getRandomValues(b);","counters":[]},{"line":"        } else {","counters":[]},{"line":"          if (typeof require === 'function') {","counters":[]},{"line":"            var crypto = require('crypto');","counters":[]},{"line":"            if (!crypto) {","counters":[]},{"line":"              throw 'random values not available'","counters":[]},{"line":"            }","counters":[]},{"line":"            b = crypto.randomBytes(32);","counters":[]},{"line":"          } else {","counters":[]},{"line":"            throw 'random values not available'","counters":[]},{"line":"          }","counters":[]},{"line":"        }","counters":[]},{"line":"        var res = [];","counters":[]},{"line":"        for (var i = 0; i < 32; ++i) {","counters":[]},{"line":"          res.push(b[i]);","counters":[]},{"line":"        }","counters":[]},{"line":"        res[31] &= 0x3f;","counters":[]},{"line":"        return res;","counters":[]},{"line":"      })|js}","counters":[]},{"line":"  in","counters":[]},{"line":"  let x : int Js.js_array Js.t = Js.Unsafe.fun_call random_bytes_32 [||] in","counters":[]},{"line":"  let byte_undefined () = failwith \"byte undefined\" in","counters":[]},{"line":"  Snarkette.Pasta.Fq.of_bigint","counters":[]},{"line":"    (Snarkette.Nat.of_bytes","counters":[]},{"line":"       (String.init 32 ~f:(fun i ->","counters":[]},{"line":"            Char.of_int_exn (Js.Optdef.get (Js.array_get x i) byte_undefined) )","counters":[]},{"line":"       ) )","counters":[]},{"line":"","counters":[]},{"line":"[%%endif]","counters":[]},{"line":"","counters":[]},{"line":"include Comparable.Make_binable (Stable.Latest)","counters":[]},{"line":"","counters":[]},{"line":"(* for compatibility with existing private key serializations *)","counters":[]},{"line":"let of_bigstring_exn =","counters":[]},{"line":"  Binable.of_bigstring (module Stable.Latest.With_all_version_tags)","counters":[{"col_start":21,"col_end":21,"count":1}]},{"line":"","counters":[]},{"line":"let to_bigstring =","counters":[]},{"line":"  Binable.to_bigstring (module Stable.Latest.With_all_version_tags)","counters":[{"col_start":21,"col_end":21,"count":1}]},{"line":"","counters":[]},{"line":"module Base58_check = Base58_check.Make (struct","counters":[]},{"line":"  let description = \"Private key\"","counters":[]},{"line":"","counters":[]},{"line":"  let version_byte = Base58_check.Version_bytes.private_key","counters":[]},{"line":"end)","counters":[]},{"line":"","counters":[]},{"line":"let to_base58_check t =","counters":[]},{"line":"  Base58_check.encode (to_bigstring t |> Bigstring.to_string)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"","counters":[]},{"line":"let of_base58_check_exn s =","counters":[]},{"line":"  let decoded = Base58_check.decode_exn s in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  decoded |> Bigstring.of_string |> of_bigstring_exn","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"","counters":[]},{"line":"let sexp_of_t t = to_base58_check t |> Sexp.of_string","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"let t_of_sexp sexp = Sexp.to_string sexp |> of_base58_check_exn","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"let to_yojson t = `String (to_base58_check t)","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"","counters":[]},{"line":"let of_yojson = function","counters":[]},{"line":"  | `String x -> (","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      try Ok (of_base58_check_exn x) with","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"      | Failure str ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Error str","counters":[]},{"line":"      | exn ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Error (\"Signature_lib.Private_key.of_yojson: \" ^ Exn.to_string exn) )","counters":[{"col_start":71,"col_end":71,"count":0}]},{"line":"  | _ ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Error \"Signature_lib.Private_key.of_yojson: Expected a string\"","counters":[{"col_start":67,"col_end":67,"count":1}]}]}