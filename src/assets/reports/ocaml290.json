{"filename":"src/lib/consensus/graphql_scalars.ml","lines":[{"line":"open Graphql_basic_scalars.Utils","counters":[]},{"line":"open Graphql_basic_scalars.Testing","counters":[]},{"line":"","counters":[]},{"line":"module Make (Schema : Schema) = struct","counters":[]},{"line":"  module type Json_intf =","counters":[]},{"line":"    Json_intf_any_typ with type ('a, 'b) typ := ('a, 'b) Schema.typ","counters":[]},{"line":"","counters":[]},{"line":"  module Slot_scalar =","counters":[]},{"line":"    Make_scalar_using_to_string","counters":[]},{"line":"      (Slot)","counters":[]},{"line":"      (struct","counters":[]},{"line":"        let name = \"Slot\"","counters":[]},{"line":"","counters":[]},{"line":"        let doc = \"slot\"","counters":[]},{"line":"      end)","counters":[]},{"line":"      (Schema)","counters":[]},{"line":"","counters":[]},{"line":"  module Epoch_scalar =","counters":[]},{"line":"    Make_scalar_using_to_string","counters":[]},{"line":"      (Epoch)","counters":[]},{"line":"      (struct","counters":[]},{"line":"        let name = \"Epoch\"","counters":[]},{"line":"","counters":[]},{"line":"        let doc = \"epoch\"","counters":[]},{"line":"      end)","counters":[]},{"line":"      (Schema)","counters":[]},{"line":"","counters":[]},{"line":"  module VrfScalar =","counters":[]},{"line":"    Make_scalar_using_to_string","counters":[]},{"line":"      (Consensus_vrf.Scalar)","counters":[]},{"line":"      (struct","counters":[]},{"line":"        let name = \"VrfScalar\"","counters":[]},{"line":"","counters":[]},{"line":"        let doc = \"consensus vrf scalar\"","counters":[]},{"line":"      end)","counters":[]},{"line":"      (Schema)","counters":[]},{"line":"","counters":[]},{"line":"  module VrfOutputTruncated =","counters":[]},{"line":"    Make_scalar_using_base58_check","counters":[]},{"line":"      (Consensus_vrf.Output.Truncated)","counters":[]},{"line":"      (struct","counters":[]},{"line":"        let name = \"VrfOutputTruncated\"","counters":[]},{"line":"","counters":[]},{"line":"        let doc = \"truncated vrf output\"","counters":[]},{"line":"      end)","counters":[]},{"line":"      (Schema)","counters":[]},{"line":"","counters":[]},{"line":"  module BodyReference : Json_intf with type t = Body_reference.t = struct","counters":[]},{"line":"    open Body_reference","counters":[]},{"line":"","counters":[]},{"line":"    type nonrec t = t","counters":[]},{"line":"","counters":[]},{"line":"    let parse json = Yojson.Basic.Util.to_string json |> of_hex_exn","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"","counters":[]},{"line":"    let serialize x = `String (to_hex x)","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"","counters":[]},{"line":"    let typ () =","counters":[]},{"line":"      Schema.scalar \"BodyReference\"","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ~doc:","counters":[]},{"line":"          \"A reference to how the block header refers to the body of the block \\","counters":[]},{"line":"           as a hex-encoded string\"","counters":[]},{"line":"        ~coerce:serialize","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"include Make (Schema)","counters":[]},{"line":"","counters":[]},{"line":"let%test_module \"Roundtrip tests\" =","counters":[]},{"line":"  ( module struct","counters":[]},{"line":"    include Make (Test_schema)","counters":[]},{"line":"","counters":[]},{"line":"    let%test_module \"Epoch\" = (module Make_test (Epoch_scalar) (Epoch))","counters":[]},{"line":"","counters":[]},{"line":"    let%test_module \"Slot\" =","counters":[]},{"line":"      ( module struct","counters":[]},{"line":"        module Slot_gen = struct","counters":[]},{"line":"          include Slot","counters":[]},{"line":"","counters":[]},{"line":"          let gen =","counters":[]},{"line":"            Core_kernel.Quickcheck.Generator.map ~f:Slot.of_uint32","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"              (Constants.for_unit_tests |> Lazy.force |> gen)","counters":[{"col_start":57,"col_end":57,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"        end","counters":[]},{"line":"","counters":[]},{"line":"        include Make_test (Slot_scalar) (Slot_gen)","counters":[]},{"line":"      end )","counters":[]},{"line":"","counters":[]},{"line":"    let%test_module \"VrfScalar\" =","counters":[]},{"line":"      ( module struct","counters":[]},{"line":"        module VrfScalar_gen = struct","counters":[]},{"line":"          include Snark_params.Tick.Inner_curve.Scalar","counters":[]},{"line":"        end","counters":[]},{"line":"","counters":[]},{"line":"        include Make_test (VrfScalar) (VrfScalar_gen)","counters":[]},{"line":"      end )","counters":[]},{"line":"","counters":[]},{"line":"    let%test_module \"VrfOutputTruncated\" =","counters":[]},{"line":"      ( module struct","counters":[]},{"line":"        module VrfOutputTruncated_gen = struct","counters":[]},{"line":"          include Consensus_vrf.Output.Truncated","counters":[]},{"line":"","counters":[]},{"line":"          let gen = Core_kernel.Quickcheck.Generator.return dummy","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"        end","counters":[]},{"line":"","counters":[]},{"line":"        include Make_test (VrfOutputTruncated) (VrfOutputTruncated_gen)","counters":[]},{"line":"      end )","counters":[]},{"line":"","counters":[]},{"line":"    let%test_module \"BodyReference\" =","counters":[]},{"line":"      ( module struct","counters":[]},{"line":"        module BodyReference_gen = struct","counters":[]},{"line":"          include Body_reference","counters":[]},{"line":"","counters":[]},{"line":"          let gen = Blake2.gen","counters":[]},{"line":"        end","counters":[]},{"line":"","counters":[]},{"line":"        include Make_test (BodyReference) (BodyReference_gen)","counters":[]},{"line":"      end )","counters":[]},{"line":"  end )","counters":[]},{"line":"","counters":[]},{"line":"module Slot = Slot_scalar","counters":[]},{"line":"module Epoch = Epoch_scalar","counters":[{"col_start":26,"col_end":26,"count":1}]}]}