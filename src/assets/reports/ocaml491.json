{"filename":"src/lib/transition_frontier/persistent_frontier/worker.ml","lines":[{"line":"open Async","counters":[]},{"line":"open Core","counters":[]},{"line":"open Otp_lib","counters":[]},{"line":"open Mina_base","counters":[]},{"line":"open Mina_block","counters":[]},{"line":"open Frontier_base","counters":[]},{"line":"","counters":[]},{"line":"type input = Diff.Lite.E.t list","counters":[]},{"line":"","counters":[]},{"line":"type create_args =","counters":[]},{"line":"  { db : Database.t","counters":[]},{"line":"  ; logger : Logger.t","counters":[]},{"line":"  ; persistent_root_instance : Persistent_root.Instance.t","counters":[]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"module Worker = struct","counters":[]},{"line":"  (* when this is transitioned to an RPC worker, the db argument","counters":[]},{"line":"   * should just be a directory, but while this is still in process,","counters":[]},{"line":"   * the full instance is needed to share with other threads","counters":[]},{"line":"   *)","counters":[]},{"line":"  type nonrec input = input","counters":[]},{"line":"","counters":[]},{"line":"  type t =","counters":[]},{"line":"    { db : Database.t","counters":[]},{"line":"    ; logger : Logger.t","counters":[]},{"line":"    ; persistent_root_instance : Persistent_root.Instance.t","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  type nonrec create_args = create_args","counters":[]},{"line":"","counters":[]},{"line":"  type output = unit","counters":[]},{"line":"","counters":[]},{"line":"  (* worker assumes database has already been checked and initialized *)","counters":[]},{"line":"  let create ({ db; logger; persistent_root_instance } : create_args) : t =","counters":[]},{"line":"    { db; logger; persistent_root_instance }","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  (* nothing to close *)","counters":[]},{"line":"  let close _ = Deferred.unit","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"","counters":[]},{"line":"  type apply_diff_error =","counters":[]},{"line":"    [ `Apply_diff of [ `New_node | `Root_transitioned | `Best_tip_changed ] ]","counters":[]},{"line":"","counters":[]},{"line":"  type apply_diff_error_internal =","counters":[]},{"line":"    [ `Not_found of","counters":[]},{"line":"      [ `New_root_transition","counters":[]},{"line":"      | `Old_root_transition","counters":[]},{"line":"      | `Parent_transition of State_hash.t","counters":[]},{"line":"      | `Arcs of State_hash.t","counters":[]},{"line":"      | `Best_tip ] ]","counters":[]},{"line":"","counters":[]},{"line":"  let apply_diff_error_internal_to_string = function","counters":[]},{"line":"    | `Not_found `New_root_transition ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        \"new root transition not found\"","counters":[]},{"line":"    | `Not_found `Old_root_transition ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        \"old root transition not found\"","counters":[]},{"line":"    | `Not_found (`Parent_transition hash) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Printf.sprintf \"parent transition %s not found\"","counters":[]},{"line":"          (State_hash.to_base58_check hash)","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"    | `Not_found `Best_tip ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        \"best tip not found\"","counters":[]},{"line":"    | `Not_found (`Arcs hash) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Printf.sprintf \"arcs not found for %s\" (State_hash.to_base58_check hash)","counters":[{"col_start":73,"col_end":73,"count":0}]},{"line":"","counters":[]},{"line":"  let apply_diff (type mutant) (t : t) (diff : mutant Diff.Lite.t) :","counters":[]},{"line":"      (mutant, apply_diff_error) Result.t =","counters":[]},{"line":"    let map_error result ~diff_type ~diff_type_name =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Result.map_error result ~f:(fun err ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          [%log' error t.logger] \"error applying %s diff: %s\" diff_type_name","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"            (apply_diff_error_internal_to_string err) ;","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"          `Apply_diff diff_type )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    in","counters":[]},{"line":"    match diff with","counters":[]},{"line":"    | New_node (Lite transition) -> (","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let r =","counters":[]},{"line":"          ( Database.add t.db ~transition","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"            :> (mutant, apply_diff_error_internal) Result.t )","counters":[]},{"line":"        in","counters":[]},{"line":"        match r with","counters":[]},{"line":"        | Ok x ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Ok x","counters":[]},{"line":"        | Error (`Not_found (`Parent_transition h | `Arcs h)) ->","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"            [%log' trace t.logger]","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"              \"Did not add node $hash to DB. Its $parent has already been \\","counters":[]},{"line":"               thrown away\"","counters":[]},{"line":"              ~metadata:","counters":[]},{"line":"                [ ( \"hash\"","counters":[]},{"line":"                  , `String","counters":[]},{"line":"                      (State_hash.to_base58_check","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"                         (Mina_block.Validated.state_hash transition) ) )","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"                ; (\"parent\", `String (State_hash.to_base58_check h))","counters":[{"col_start":63,"col_end":63,"count":0}]},{"line":"                ] ;","counters":[]},{"line":"            Ok ()","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"        | _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            map_error ~diff_type:`New_node ~diff_type_name:\"New_node\" r )","counters":[]},{"line":"    | Root_transitioned","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { new_root; garbage = Lite garbage; just_emitted_a_proof } ->","counters":[]},{"line":"        if just_emitted_a_proof then (","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"          [%log' info t.logger] \"Dequeued a snarked ledger\" ;","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"          Persistent_root.Instance.dequeue_snarked_ledger","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"            t.persistent_root_instance ) ;","counters":[]},{"line":"        map_error ~diff_type:`Root_transitioned","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ~diff_type_name:\"Root_transitioned\"","counters":[]},{"line":"          ( Database.move_root t.db ~new_root ~garbage","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"            :> (mutant, apply_diff_error_internal) Result.t )","counters":[]},{"line":"    | Best_tip_changed best_tip_hash ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        map_error ~diff_type:`Best_tip_changed","counters":[]},{"line":"          ~diff_type_name:\"Best_tip_changed\"","counters":[]},{"line":"          ( Database.set_best_tip t.db best_tip_hash","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"            :> (mutant, apply_diff_error_internal) Result.t )","counters":[]},{"line":"","counters":[]},{"line":"  let handle_diff t (Diff.Lite.E.E diff) =","counters":[]},{"line":"    let open Result.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let%map _mutant = apply_diff t diff in","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"    ()","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  (* result equivalent of Deferred.Or_error.List.fold *)","counters":[]},{"line":"  let rec deferred_result_list_fold ls ~init ~f =","counters":[]},{"line":"    let open Deferred.Result.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    match ls with","counters":[]},{"line":"    | [] ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        return init","counters":[]},{"line":"    | h :: t ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let%bind init = f init h in","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"        deferred_result_list_fold t ~init ~f","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"  let perform t input =","counters":[]},{"line":"    O1trace.thread \"persistent_frontier_write_to_disk\" (fun () ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        match%map","counters":[]},{"line":"          [%log' trace t.logger] \"Applying %d diffs to the persistent frontier\"","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"            (List.length input) ;","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"          (* Iterating over the diff application in this way","counters":[]},{"line":"             * effectively allows the scheduler to scheduler","counters":[]},{"line":"             * other tasks in between diff applications.","counters":[]},{"line":"             * If implemented otherwise, all diffs would be","counters":[]},{"line":"             * applied during the same scheduler cycle.","counters":[]},{"line":"          *)","counters":[]},{"line":"          deferred_result_list_fold input ~init:() ~f:(fun () diff ->","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"              Deferred.return (handle_diff t diff) )","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"        with","counters":[]},{"line":"        | Ok () ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ()","counters":[]},{"line":"        (* TODO: log the diff that failed *)","counters":[]},{"line":"        | Error (`Apply_diff _) ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            failwith","counters":[]},{"line":"              \"Failed to apply a diff to the persistent transition frontier\" )","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"include Worker_supervisor.Make (Worker)","counters":[{"col_start":38,"col_end":38,"count":2}]}]}