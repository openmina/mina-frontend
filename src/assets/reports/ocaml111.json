{"filename":"src/lib/pickles/util.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Pickles_types","counters":[]},{"line":"","counters":[]},{"line":"type m = Abc.Label.t = A | B | C","counters":[]},{"line":"","counters":[]},{"line":"let rec absorb :","counters":[]},{"line":"    type a g1 g1_opt f scalar.","counters":[]},{"line":"       absorb_field:(f -> unit)","counters":[]},{"line":"    -> absorb_scalar:(scalar -> unit)","counters":[]},{"line":"    -> g1_to_field_elements:(g1 -> f list)","counters":[]},{"line":"    -> mask_g1_opt:(g1_opt -> g1)","counters":[]},{"line":"    -> ( a","counters":[]},{"line":"       , < scalar : scalar ; g1 : g1 ; g1_opt : g1_opt ; base_field : f > )","counters":[]},{"line":"       Type.t","counters":[]},{"line":"    -> a","counters":[]},{"line":"    -> unit =","counters":[]},{"line":" fun ~absorb_field ~absorb_scalar ~g1_to_field_elements ~mask_g1_opt ty t ->","counters":[]},{"line":"  match ty with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | PC ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      List.iter ~f:absorb_field (g1_to_field_elements t)","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"  | Field ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      absorb_field t","counters":[]},{"line":"  | Scalar ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      absorb_scalar t","counters":[]},{"line":"  | Without_degree_bound ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Array.iter","counters":[]},{"line":"        ~f:(Fn.compose (List.iter ~f:absorb_field) g1_to_field_elements)","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"        t","counters":[]},{"line":"  | With_degree_bound ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Array.iter t.unshifted ~f:(fun t ->","counters":[]},{"line":"          absorb ~absorb_field ~absorb_scalar ~g1_to_field_elements ~mask_g1_opt","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            PC (mask_g1_opt t) ) ;","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"      absorb ~absorb_field ~absorb_scalar ~g1_to_field_elements ~mask_g1_opt PC","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (mask_g1_opt t.shifted)","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"  | ty1 :: ty2 ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let absorb t =","counters":[]},{"line":"        absorb t ~absorb_field ~absorb_scalar ~g1_to_field_elements ~mask_g1_opt","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      in","counters":[]},{"line":"      let t1, t2 = t in","counters":[]},{"line":"      absorb ty1 t1 ; absorb ty2 t2","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"let ones_vector :","counters":[]},{"line":"    type f n.","counters":[]},{"line":"       first_zero:f Snarky_backendless.Cvar.t","counters":[]},{"line":"    -> (module Snarky_backendless.Snark_intf.Run with type field = f)","counters":[]},{"line":"    -> n Nat.t","counters":[]},{"line":"    -> (f Snarky_backendless.Cvar.t Snarky_backendless.Boolean.t, n) Vector.t =","counters":[]},{"line":" fun ~first_zero (module Impl) n ->","counters":[]},{"line":"  let open Impl in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let rec go :","counters":[]},{"line":"      type m. Boolean.var -> int -> m Nat.t -> (Boolean.var, m) Vector.t =","counters":[]},{"line":"   fun value i m ->","counters":[]},{"line":"    match m with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Z ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        []","counters":[]},{"line":"    | S m ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let value =","counters":[]},{"line":"          Boolean.(value && not (Field.equal first_zero (Field.of_int i)))","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":43,"col_end":43,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"        in","counters":[]},{"line":"        value :: go value (i + 1) m","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"  in","counters":[]},{"line":"  go Boolean.true_ 0 n","counters":[]},{"line":"","counters":[]},{"line":"let split_last xs =","counters":[]},{"line":"  let rec go acc = function","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    | [ x ] ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (List.rev acc, x)","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"    | x :: xs ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        go (x :: acc) xs","counters":[]},{"line":"    | [] ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        failwith \"Empty list\"","counters":[]},{"line":"  in","counters":[]},{"line":"  go [] xs","counters":[]},{"line":"","counters":[]},{"line":"let boolean_constrain (type f)","counters":[]},{"line":"    (module Impl : Snarky_backendless.Snark_intf.Run with type field = f)","counters":[]},{"line":"    (xs : Impl.Boolean.var list) : unit =","counters":[]},{"line":"  let open Impl in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  assert_all (List.map xs ~f:(fun x -> Constraint.boolean (x :> Field.t)))","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"let seal (type f)","counters":[]},{"line":"    (module Impl : Snarky_backendless.Snark_intf.Run with type field = f)","counters":[]},{"line":"    (x : Impl.Field.t) : Impl.Field.t =","counters":[]},{"line":"  let open Impl in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  match Field.to_constant_and_terms x with","counters":[]},{"line":"  | None, [ (x, i) ] when Field.Constant.(equal x one) ->","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"      Snarky_backendless.Cvar.Var i","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  | Some c, [] ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Field.constant c","counters":[]},{"line":"  | _ ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let y = exists Field.typ ~compute:As_prover.(fun () -> read_var x) in","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"      Field.Assert.equal x y ; y","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"","counters":[]},{"line":"let lowest_128_bits (type f) ~constrain_low_bits ~assert_128_bits","counters":[]},{"line":"    (module Impl : Snarky_backendless.Snark_intf.Run with type field = f) x =","counters":[]},{"line":"  let open Impl in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let pow2 =","counters":[]},{"line":"    (* 2 ^ n *)","counters":[]},{"line":"    let rec pow2 x i =","counters":[]},{"line":"      if i = 0 then x else pow2 Field.Constant.(x + x) (i - 1)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"    in","counters":[]},{"line":"    fun n -> pow2 Field.Constant.one n","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"  in","counters":[]},{"line":"  let lo, hi =","counters":[]},{"line":"    exists","counters":[]},{"line":"      Typ.(field * field)","counters":[]},{"line":"      ~compute:(fun () ->","counters":[]},{"line":"        let lo, hi =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Field.Constant.unpack (As_prover.read_var x)","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"          |> Fn.flip List.split_n 128","counters":[]},{"line":"        in","counters":[]},{"line":"        (Field.Constant.project lo, Field.Constant.project hi) )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"  in","counters":[]},{"line":"  assert_128_bits hi ;","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  if constrain_low_bits then assert_128_bits lo ;","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"  Field.Assert.equal x Field.(lo + scale hi (pow2 128)) ;","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"  lo","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let unsafe_unpack_with_partial_sum (type f)","counters":[]},{"line":"    (module Impl : Snarky_backendless.Snark_intf.Run with type field = f) x ~n =","counters":[]},{"line":"  let open Impl in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let res =","counters":[]},{"line":"    let length = Field.size_in_bits in","counters":[]},{"line":"    exists","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"      (Typ.list Boolean.typ_unchecked ~length)","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"      ~compute:","counters":[]},{"line":"        As_prover.(","counters":[]},{"line":"          fun () -> List.take (Field.Constant.unpack (read_var x)) length)","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":51,"col_end":51,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"  in","counters":[]},{"line":"  let lo_bits, hi_bits = List.split_n res n in","counters":[]},{"line":"  let lo = seal (module Impl) (Field.project lo_bits) in","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"  let two_to_the n =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Fn.apply_n_times ~n (fun x -> Field.Constant.( + ) x x) Field.Constant.one","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"  in","counters":[]},{"line":"  Field.(Assert.equal x (lo + scale (project hi_bits) (two_to_the n))) ;","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":43,"col_end":43,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"  ((lo_bits, lo), hi_bits)","counters":[]},{"line":"","counters":[]},{"line":"let squeeze_with_packed (type f)","counters":[]},{"line":"    (module Impl : Snarky_backendless.Snark_intf.Run with type field = f)","counters":[]},{"line":"    ~squeeze ~high_entropy_bits t ~length:n =","counters":[]},{"line":"  assert (n = high_entropy_bits) ;","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":9,"col_end":9,"count":0}]},{"line":"  let x = squeeze t in","counters":[]},{"line":"  let lo, hi_bits = unsafe_unpack_with_partial_sum (module Impl) x ~n in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  boolean_constrain (module Impl) hi_bits ;","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  lo","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":3,"col_end":3,"count":2}]}]}