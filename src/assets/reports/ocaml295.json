{"filename":"src/lib/parallel_scan/parallel_scan.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Async_kernel","counters":[]},{"line":"open Pipe_lib","counters":[]},{"line":"","counters":[]},{"line":"(*Glossary of type variables used in this file:","counters":[]},{"line":"  1. 'base: polymorphic type for jobs in the leaves of the scan state tree","counters":[]},{"line":"  2. 'merge: polymorphic type for jobs in the intermediate nodes of the scan state tree","counters":[]},{"line":"  3. 'base_t: 'base Base.t","counters":[]},{"line":"  4. 'merge_t: 'merge Merge.t","counters":[]},{"line":"  5. 'base_job: Base.Job.t","counters":[]},{"line":"  6. 'merge_job: Merge.Job.t","counters":[]},{"line":"*)","counters":[]},{"line":"","counters":[]},{"line":"(*Note:  Prefixing some of the general purpose functions that could be used in the future with an \"_\" to not cause \"unused function\" error*)","counters":[]},{"line":"","counters":[]},{"line":"(**Sequence number for jobs in the scan state that corresponds to the order in","counters":[]},{"line":"which they were added*)","counters":[]},{"line":"module Sequence_number = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type t = int [@@deriving sexp]","counters":[{"col_start":6,"col_end":6,"count":2},{"col_start":11,"col_end":11,"count":1},{"col_start":35,"col_end":35,"count":5}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(**Each node on the tree is viewed as a job that needs to be completed. When a","counters":[]},{"line":"job is completed, it creates a new \"Todo\" job and marks the old job as \"Done\"*)","counters":[]},{"line":"module Job_status = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type t = Todo | Done [@@deriving sexp]","counters":[{"col_start":6,"col_end":6,"count":2},{"col_start":11,"col_end":11,"count":2},{"col_start":15,"col_end":15,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":43,"col_end":43,"count":5}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  let to_string = function Todo -> \"Todo\" | Done -> \"Done\"","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(**The number of new jobs- base and merge that can be added to this tree.","counters":[]},{"line":" * Each node has a weight associated to it and the","counters":[]},{"line":" * new jobs received are distributed across the tree based on this number. *)","counters":[]},{"line":"module Weight = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    [@@@no_toplevel_latest_type]","counters":[]},{"line":"","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type t = { base : int; merge : int } [@@deriving sexp]","counters":[{"col_start":6,"col_end":6,"count":2},{"col_start":11,"col_end":11,"count":2},{"col_start":17,"col_end":17,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":59,"col_end":59,"count":5}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  type t = Stable.Latest.t = { base : int; merge : int } [@@deriving sexp, lens]","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":43,"col_end":43,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(**For base proofs (Proving new transactions)*)","counters":[]},{"line":"module Base = struct","counters":[]},{"line":"  module Record = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type 'base t =","counters":[{"col_start":8,"col_end":8,"count":1},{"col_start":19,"col_end":19,"count":4}]},{"line":"          { job : 'base","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":14,"col_end":14,"count":0}]},{"line":"          ; seq_no : Sequence_number.Stable.V1.t","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"          ; status : Job_status.Stable.V1.t","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"          }","counters":[]},{"line":"        [@@deriving sexp]","counters":[{"col_start":24,"col_end":24,"count":3}]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    let map (t : 'a t) ~(f : 'a -> 'b) : 'b t = { t with job = f t.job }","counters":[{"col_start":48,"col_end":48,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Job = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type 'base t = Empty | Full of 'base Record.Stable.V1.t","counters":[{"col_start":8,"col_end":8,"count":1},{"col_start":19,"col_end":19,"count":4},{"col_start":23,"col_end":23,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"        [@@deriving sexp]","counters":[{"col_start":24,"col_end":24,"count":3}]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    let map (t : 'a t) ~(f : 'a -> 'b) : 'b t =","counters":[]},{"line":"      match t with Empty -> Empty | Full r -> Full (Record.map r ~f)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"","counters":[]},{"line":"    let job_str = function Empty -> \"Base.Empty\" | Full _ -> \"Base.Full\"","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type 'base t = Weight.Stable.V1.t * 'base Job.Stable.V1.t","counters":[{"col_start":6,"col_end":6,"count":1},{"col_start":17,"col_end":17,"count":3},{"col_start":21,"col_end":21,"count":0}]},{"line":"      [@@deriving sexp]","counters":[{"col_start":22,"col_end":22,"count":3}]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  let map ((x, j) : 'a t) ~(f : 'a -> 'b) : 'b t = (x, Job.map j ~f)","counters":[{"col_start":51,"col_end":51,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(** For merge proofs: Merging two base proofs or two merge proofs*)","counters":[]},{"line":"module Merge = struct","counters":[]},{"line":"  module Record = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type 'merge t =","counters":[{"col_start":8,"col_end":8,"count":1},{"col_start":20,"col_end":20,"count":4}]},{"line":"          { left : 'merge","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"          ; right : 'merge","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":16,"col_end":16,"count":0}]},{"line":"          ; seq_no : Sequence_number.Stable.V1.t","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"          ; status : Job_status.Stable.V1.t","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"          }","counters":[]},{"line":"        [@@deriving sexp]","counters":[{"col_start":24,"col_end":24,"count":3}]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    let map (t : 'a t) ~(f : 'a -> 'b) : 'b t =","counters":[]},{"line":"      { t with left = f t.left; right = f t.right }","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Job = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type 'merge t =","counters":[{"col_start":8,"col_end":8,"count":1},{"col_start":20,"col_end":20,"count":4}]},{"line":"          | Empty","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | Part of 'merge (*When only the left component of the job is available since we always complete the jobs from left to right*)","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | Full of 'merge Record.Stable.V1.t","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        [@@deriving sexp]","counters":[{"col_start":24,"col_end":24,"count":3}]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    let map (t : 'a t) ~(f : 'a -> 'b) : 'b t =","counters":[]},{"line":"      match t with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Empty ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Empty","counters":[]},{"line":"      | Part x ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Part (f x)","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"      | Full r ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Full (Record.map r ~f)","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"    let job_str = function","counters":[]},{"line":"      | Empty ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          \"Merge.Empty\"","counters":[]},{"line":"      | Full _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          \"Merge.Full\"","counters":[]},{"line":"      | Part _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          \"Merge.Part\"","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type 'merge t =","counters":[{"col_start":6,"col_end":6,"count":1},{"col_start":18,"col_end":18,"count":3}]},{"line":"        (Weight.Stable.V1.t * Weight.Stable.V1.t) * 'merge Job.Stable.V1.t","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":9,"col_end":9,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"      [@@deriving sexp]","counters":[{"col_start":22,"col_end":22,"count":3}]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  let map ((x, j) : 'a t) ~(f : 'a -> 'b) : 'b t = (x, Job.map j ~f)","counters":[{"col_start":51,"col_end":51,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(**All the jobs on a tree that can be done. Base.Full and Merge.Full*)","counters":[]},{"line":"module Available_job = struct","counters":[]},{"line":"  type ('merge, 'base) t = Base of 'base | Merge of 'merge * 'merge","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":57,"col_end":57,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"  [@@deriving sexp]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(**New jobs to be added (including new transactions or new merge jobs)*)","counters":[]},{"line":"module Job = struct","counters":[]},{"line":"  type ('merge, 'base) t = Base of 'base | Merge of 'merge [@@deriving sexp]","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(**Space available and number of jobs required to enqueue data.","counters":[]},{"line":" first = space on the current tree and number of jobs required","counters":[]},{"line":" to be completed","counters":[]},{"line":" second = If the current-tree space is less than <max_base_jobs>","counters":[]},{"line":" then remaining number of slots on a new tree and the corresponding","counters":[]},{"line":" job count.*)","counters":[]},{"line":"module Space_partition = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type t = { first : int * int; second : (int * int) option }","counters":[{"col_start":6,"col_end":6,"count":2},{"col_start":11,"col_end":11,"count":2},{"col_start":17,"col_end":17,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"      [@@deriving sexp]","counters":[{"col_start":22,"col_end":22,"count":5}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(**View of a job for json output*)","counters":[]},{"line":"module Job_view = struct","counters":[]},{"line":"  module Extra = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type t =","counters":[{"col_start":8,"col_end":8,"count":2},{"col_start":13,"col_end":13,"count":2}]},{"line":"          { seq_no : Sequence_number.Stable.V1.t","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"          ; status : Job_status.Stable.V1.t","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"          }","counters":[]},{"line":"        [@@deriving sexp]","counters":[{"col_start":24,"col_end":24,"count":5}]},{"line":"","counters":[]},{"line":"        let to_latest = Fn.id","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Node = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type 'a t =","counters":[{"col_start":8,"col_end":8,"count":1},{"col_start":16,"col_end":16,"count":4}]},{"line":"          | BEmpty","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | BFull of ('a * Extra.Stable.V1.t)","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"          | MEmpty","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | MPart of 'a","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | MFull of ('a * 'a * Extra.Stable.V1.t)","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":23,"col_end":23,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"        [@@deriving sexp]","counters":[{"col_start":24,"col_end":24,"count":3}]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type 'a t = { position : int; value : 'a Node.Stable.V1.t }","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":14,"col_end":14,"count":4},{"col_start":20,"col_end":20,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"      [@@deriving sexp]","counters":[{"col_start":22,"col_end":22,"count":1}]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Hash = struct","counters":[]},{"line":"  type t = Digestif.SHA256.t [@@deriving equal]","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(**A single tree with number of leaves = max_base_jobs = 2**transaction_capacity_log_2 *)","counters":[]},{"line":"module Tree = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type ('merge_t, 'base_t) t =","counters":[{"col_start":6,"col_end":6,"count":1},{"col_start":31,"col_end":31,"count":6}]},{"line":"        | Leaf of 'base_t","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | Node of","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            { depth : int","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"            ; value : 'merge_t","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"            ; sub_tree : ('merge_t * 'merge_t, 'base_t * 'base_t) t","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":47,"col_end":47,"count":0},{"col_start":53,"col_end":53,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"            }","counters":[]},{"line":"      [@@deriving sexp]","counters":[{"col_start":22,"col_end":22,"count":3}]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  (*Eg: Tree depth = 3","counters":[]},{"line":"","counters":[]},{"line":"    Node M","counters":[]},{"line":"    |","counters":[]},{"line":"    Node (M,M)","counters":[]},{"line":"    |","counters":[]},{"line":"    Node ((M,M),(M,M))","counters":[]},{"line":"    |","counters":[]},{"line":"    Leaf (((B,B),(B,B)),((B,B),(B,B)))","counters":[]},{"line":"  *)","counters":[]},{"line":"","counters":[]},{"line":"  (*mapi where i is the level of the tree*)","counters":[]},{"line":"  let rec map_depth :","counters":[]},{"line":"      type a_merge b_merge c_base d_base.","counters":[]},{"line":"         f_merge:(int -> a_merge -> b_merge)","counters":[]},{"line":"      -> f_base:(c_base -> d_base)","counters":[]},{"line":"      -> (a_merge, c_base) t","counters":[]},{"line":"      -> (b_merge, d_base) t =","counters":[]},{"line":"   fun ~f_merge ~f_base tree ->","counters":[]},{"line":"    match tree with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Leaf d ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Leaf (f_base d)","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"    | Node { depth; value; sub_tree } ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Node","counters":[]},{"line":"          { depth","counters":[]},{"line":"          ; value = f_merge depth value","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"          ; sub_tree =","counters":[]},{"line":"              map_depth","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                ~f_merge:(fun i (x, y) -> (f_merge i x, f_merge i y))","counters":[{"col_start":42,"col_end":42,"count":0},{"col_start":49,"col_end":49,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"                ~f_base:(fun (x, y) -> (f_base x, f_base y))","counters":[{"col_start":39,"col_end":39,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"                sub_tree","counters":[]},{"line":"          }","counters":[]},{"line":"","counters":[]},{"line":"  let map :","counters":[]},{"line":"      type a_merge b_merge c_base d_base.","counters":[]},{"line":"         f_merge:(a_merge -> b_merge)","counters":[]},{"line":"      -> f_base:(c_base -> d_base)","counters":[]},{"line":"      -> (a_merge, c_base) t","counters":[]},{"line":"      -> (b_merge, d_base) t =","counters":[]},{"line":"   fun ~f_merge ~f_base tree ->","counters":[]},{"line":"    map_depth tree ~f_base ~f_merge:(fun _ -> f_merge)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"","counters":[]},{"line":"  (* foldi where i is the cur_level*)","counters":[]},{"line":"  module Make_foldable (M : Monad.S) = struct","counters":[]},{"line":"    let rec fold_depth_until' :","counters":[]},{"line":"        type merge_t accum base_t final.","counters":[]},{"line":"           f_merge:","counters":[]},{"line":"             (int -> accum -> merge_t -> (accum, final) Continue_or_stop.t M.t)","counters":[]},{"line":"        -> f_base:(accum -> base_t -> (accum, final) Continue_or_stop.t M.t)","counters":[]},{"line":"        -> init:accum","counters":[]},{"line":"        -> (merge_t, base_t) t","counters":[]},{"line":"        -> (accum, final) Continue_or_stop.t M.t =","counters":[]},{"line":"     fun ~f_merge ~f_base ~init:acc t ->","counters":[]},{"line":"      let open Container.Continue_or_stop in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let open M.Let_syntax in","counters":[]},{"line":"      match t with","counters":[]},{"line":"      | Leaf d ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          f_base acc d","counters":[]},{"line":"      | Node { depth; value; sub_tree } -> (","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          match%bind f_merge depth acc value with","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"          | Continue acc' ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              fold_depth_until'","counters":[]},{"line":"                ~f_merge:(fun i acc (x, y) ->","counters":[]},{"line":"                  match%bind f_merge i acc x with","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                  | Continue r ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      f_merge i r y","counters":[]},{"line":"                  | x ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      M.return x )","counters":[]},{"line":"                ~f_base:(fun acc (x, y) ->","counters":[]},{"line":"                  match%bind f_base acc x with","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"                  | Continue r ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      f_base r y","counters":[]},{"line":"                  | x ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      M.return x )","counters":[]},{"line":"                ~init:acc' sub_tree","counters":[]},{"line":"          | x ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              M.return x )","counters":[]},{"line":"","counters":[]},{"line":"    let fold_depth_until :","counters":[]},{"line":"        type merge_t base_t accum final.","counters":[]},{"line":"           f_merge:","counters":[]},{"line":"             (int -> accum -> merge_t -> (accum, final) Continue_or_stop.t M.t)","counters":[]},{"line":"        -> f_base:(accum -> base_t -> (accum, final) Continue_or_stop.t M.t)","counters":[]},{"line":"        -> init:accum","counters":[]},{"line":"        -> finish:(accum -> final M.t)","counters":[]},{"line":"        -> (merge_t, base_t) t","counters":[]},{"line":"        -> final M.t =","counters":[]},{"line":"     fun ~f_merge ~f_base ~init ~finish t ->","counters":[]},{"line":"      let open M.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      match%bind fold_depth_until' ~f_merge ~f_base ~init t with","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"      | Continue result ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          finish result","counters":[]},{"line":"      | Stop e ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          M.return e","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Foldable_ident = Make_foldable (Monad.Ident)","counters":[]},{"line":"","counters":[]},{"line":"  let fold_depth :","counters":[]},{"line":"      type merge_t base_t accum.","counters":[]},{"line":"         f_merge:(int -> accum -> merge_t -> accum)","counters":[]},{"line":"      -> f_base:(accum -> base_t -> accum)","counters":[]},{"line":"      -> init:accum","counters":[]},{"line":"      -> (merge_t, base_t) t","counters":[]},{"line":"      -> accum =","counters":[]},{"line":"   fun ~f_merge ~f_base ~init t ->","counters":[]},{"line":"    Foldable_ident.fold_depth_until","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ~f_merge:(fun i acc a -> Continue (f_merge i acc a))","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"      ~f_base:(fun acc d -> Continue (f_base acc d))","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"      ~init ~finish:Fn.id t","counters":[]},{"line":"","counters":[]},{"line":"  let fold :","counters":[]},{"line":"      type merge_t base_t accum.","counters":[]},{"line":"         f_merge:(accum -> merge_t -> accum)","counters":[]},{"line":"      -> f_base:(accum -> base_t -> accum)","counters":[]},{"line":"      -> init:accum","counters":[]},{"line":"      -> (merge_t, base_t) t","counters":[]},{"line":"      -> accum =","counters":[]},{"line":"   fun ~f_merge ~f_base ~init t ->","counters":[]},{"line":"    fold_depth t ~init ~f_merge:(fun _ -> f_merge) ~f_base","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"","counters":[]},{"line":"  let _fold_until :","counters":[]},{"line":"      type merge_t base_t accum final.","counters":[]},{"line":"         f_merge:(accum -> merge_t -> (accum, final) Continue_or_stop.t)","counters":[]},{"line":"      -> f_base:(accum -> base_t -> (accum, final) Continue_or_stop.t)","counters":[]},{"line":"      -> init:accum","counters":[]},{"line":"      -> finish:(accum -> final)","counters":[]},{"line":"      -> (merge_t, base_t) t","counters":[]},{"line":"      -> final =","counters":[]},{"line":"   fun ~f_merge ~f_base ~init ~finish t ->","counters":[]},{"line":"    Foldable_ident.fold_depth_until","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ~f_merge:(fun _ -> f_merge)","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"      ~f_base ~init ~finish t","counters":[]},{"line":"","counters":[]},{"line":"  (*","counters":[]},{"line":"    result -> final proof","counters":[]},{"line":"    f_merge, f_base are to update the nodes with new jobs and mark old jobs as \"Done\"*)","counters":[]},{"line":"  let rec update_split :","counters":[]},{"line":"      type merge_t base_t data weight result.","counters":[]},{"line":"         f_merge:(data -> int -> merge_t -> (merge_t * result option) Or_error.t)","counters":[]},{"line":"      -> f_base:(data -> base_t -> base_t Or_error.t)","counters":[]},{"line":"      -> weight_merge:(merge_t -> weight * weight)","counters":[]},{"line":"      -> jobs:data","counters":[]},{"line":"      -> update_level:int","counters":[]},{"line":"      -> jobs_split:(weight * weight -> data -> data * data)","counters":[]},{"line":"      -> (merge_t, base_t) t","counters":[]},{"line":"      -> ((merge_t, base_t) t * result option) Or_error.t =","counters":[]},{"line":"   fun ~f_merge ~f_base ~weight_merge ~jobs ~update_level ~jobs_split t ->","counters":[]},{"line":"    let open Or_error.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    match t with","counters":[]},{"line":"    | Leaf d ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let%map updated = f_base jobs d in","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"        (Leaf updated, None)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    | Node { depth; value; sub_tree } ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let weight_left_subtree, weight_right_subtree = weight_merge value in","counters":[]},{"line":"        (*update the jobs at the current level*)","counters":[]},{"line":"        let%bind value', scan_result = f_merge jobs depth value in","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"        (*get the updated subtree*)","counters":[]},{"line":"        let%map sub, _ =","counters":[]},{"line":"          if update_level = depth then Ok (sub_tree, None)","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"          else","counters":[]},{"line":"            (*split the jobs for the next level*)","counters":[]},{"line":"            let new_jobs_list =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              jobs_split (weight_left_subtree, weight_right_subtree) jobs","counters":[]},{"line":"            in","counters":[]},{"line":"            update_split","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"              ~f_merge:(fun (b, b') i (x, y) ->","counters":[]},{"line":"                let%bind left = f_merge b i x in","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"                let%map right = f_merge b' i y in","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"                ((fst left, fst right), Option.both (snd left) (snd right)) )","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":50,"col_end":50,"count":0},{"col_start":55,"col_end":55,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"              ~f_base:(fun (b, b') (x, x') ->","counters":[]},{"line":"                let%bind left = f_base b x in","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                let%map right = f_base b' x' in","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                (left, right) )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"              ~weight_merge:(fun (a, b) -> (weight_merge a, weight_merge b))","counters":[{"col_start":43,"col_end":43,"count":0},{"col_start":55,"col_end":55,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"              ~update_level","counters":[]},{"line":"              ~jobs_split:(fun (x, y) (a, b) -> (jobs_split x a, jobs_split y b))","counters":[{"col_start":48,"col_end":48,"count":0},{"col_start":58,"col_end":58,"count":0},{"col_start":74,"col_end":74,"count":0}]},{"line":"              ~jobs:new_jobs_list sub_tree","counters":[]},{"line":"        in","counters":[]},{"line":"        (Node { depth; value = value'; sub_tree = sub }, scan_result)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"  let rec update_accumulate :","counters":[]},{"line":"      type merge_t base_t data.","counters":[]},{"line":"         f_merge:(data * data -> merge_t -> merge_t * data)","counters":[]},{"line":"      -> f_base:(base_t -> base_t * data)","counters":[]},{"line":"      -> (merge_t, base_t) t","counters":[]},{"line":"      -> (merge_t, base_t) t * data =","counters":[]},{"line":"   fun ~f_merge ~f_base t ->","counters":[]},{"line":"    let transpose ((x1, y1), (x2, y2)) = ((x1, x2), (y1, y2)) in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"    match t with","counters":[]},{"line":"    | Leaf d ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let new_base, count_list = f_base d in","counters":[]},{"line":"        (Leaf new_base, count_list)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    | Node { depth; value; sub_tree } ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (*get the updated subtree*)","counters":[]},{"line":"        let sub, counts =","counters":[]},{"line":"          update_accumulate","counters":[]},{"line":"            ~f_merge:(fun (b1, b2) (x, y) ->","counters":[]},{"line":"              transpose (f_merge b1 x, f_merge b2 y) )","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"            ~f_base:(fun (x, y) -> transpose (f_base x, f_base y))","counters":[{"col_start":35,"col_end":35,"count":0},{"col_start":51,"col_end":51,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"            sub_tree","counters":[]},{"line":"        in","counters":[]},{"line":"        let value', count_list = f_merge counts value in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        (Node { depth; value = value'; sub_tree = sub }, count_list)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"  let update :","counters":[]},{"line":"         ('merge_job, 'base_job) Job.t list","counters":[]},{"line":"      -> update_level:int","counters":[]},{"line":"      -> sequence_no:int","counters":[]},{"line":"      -> weight_lens:(Weight.t, int) Lens.t","counters":[]},{"line":"      -> ('merge_t, 'base_t) t","counters":[]},{"line":"      -> (('merge_t, 'base_t) t * 'b option) Or_error.t =","counters":[]},{"line":"   fun completed_jobs ~update_level ~sequence_no:seq_no ~weight_lens tree ->","counters":[]},{"line":"    let open Or_error.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let add_merges (jobs : ('b, 'c) Job.t list) cur_level","counters":[]},{"line":"        (((w1, w2) as weight), m) =","counters":[]},{"line":"      let left, right = (weight_lens.get w1, weight_lens.get w2) in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"      if cur_level = update_level - 1 then","counters":[]},{"line":"        (*Create new jobs from the completed ones*)","counters":[]},{"line":"        let%map new_weight, m' =","counters":[]},{"line":"          match (jobs, m) with","counters":[]},{"line":"          | [], _ ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Ok (weight, m)","counters":[]},{"line":"          | [ Job.Merge a; Merge b ], Merge.Job.Empty ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Ok","counters":[]},{"line":"                ( (weight_lens.set (left - 1) w1, weight_lens.set (right - 1) w2)","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"                , Full { left = a; right = b; seq_no; status = Job_status.Todo }","counters":[]},{"line":"                )","counters":[]},{"line":"          | [ Merge a ], Empty ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Ok","counters":[]},{"line":"                ( (weight_lens.set (left - 1) w1, weight_lens.set right w2)","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"                , Part a )","counters":[]},{"line":"          | [ Merge b ], Part a ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Ok","counters":[]},{"line":"                ( (weight_lens.set left w1, weight_lens.set (right - 1) w2)","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"                , Full { left = a; right = b; seq_no; status = Job_status.Todo }","counters":[]},{"line":"                )","counters":[]},{"line":"          | [ Base _ ], Empty ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (*Depending on whether this is the first or second of the two base jobs*)","counters":[]},{"line":"              let weight =","counters":[]},{"line":"                if left = 0 then","counters":[]},{"line":"                  (weight_lens.set left w1, weight_lens.set (right - 1) w2)","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"                else (weight_lens.set (left - 1) w1, weight_lens.set right w2)","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"              in","counters":[]},{"line":"              Ok (weight, m)","counters":[]},{"line":"          | [ Base _; Base _ ], Empty ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Ok","counters":[]},{"line":"                ( (weight_lens.set (left - 1) w1, weight_lens.set (right - 1) w2)","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"                , m )","counters":[]},{"line":"          | xs, m ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Or_error.errorf","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                \"Got %d jobs when updating level %d and when one of the merge \\","counters":[]},{"line":"                 nodes at level %d is %s\"","counters":[]},{"line":"                (List.length xs) update_level cur_level (Merge.Job.job_str m)","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":73,"col_end":73,"count":0}]},{"line":"        in","counters":[]},{"line":"        ((new_weight, m'), None)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      else if cur_level = update_level then","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"        (*Mark completed jobs as Done*)","counters":[]},{"line":"        match (jobs, m) with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | [ Merge a ], Full ({ status = Job_status.Todo; _ } as x) ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let new_job = Merge.Job.Full { x with status = Job_status.Done } in","counters":[]},{"line":"            let scan_result, weight' =","counters":[]},{"line":"              if cur_level = 0 then","counters":[]},{"line":"                (Some a, (weight_lens.set 0 w1, weight_lens.set 0 w2))","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"              else (None, weight)","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"            in","counters":[]},{"line":"            Ok ((weight', new_job), scan_result)","counters":[]},{"line":"        | [], m ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Ok ((weight, m), None)","counters":[]},{"line":"        | xs, m ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Or_error.errorf","counters":[]},{"line":"              \"Got %d jobs when updating level %d and when one of the merge \\","counters":[]},{"line":"               nodes at level %d is %s\"","counters":[]},{"line":"              (List.length xs) update_level cur_level (Merge.Job.job_str m)","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"      else if cur_level < update_level - 1 then","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"        (*Update the job count for all the level above*)","counters":[]},{"line":"        match jobs with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | [] ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Ok ((weight, m), None)","counters":[]},{"line":"        | _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let jobs_sent_left = min (List.length jobs) left in","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"            let jobs_sent_right =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              min (List.length jobs - jobs_sent_left) right","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"            in","counters":[]},{"line":"            let new_weight =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              ( weight_lens.set (left - jobs_sent_left) w1","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"              , weight_lens.set (right - jobs_sent_right) w2 )","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"            in","counters":[]},{"line":"            Ok ((new_weight, m), None)","counters":[]},{"line":"      else Ok ((weight, m), None)","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"    in","counters":[]},{"line":"    let add_bases jobs (w, d) =","counters":[]},{"line":"      let weight = weight_lens.get w in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      match (jobs, d) with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | [], _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Ok (w, d)","counters":[]},{"line":"      | [ Job.Base d ], Base.Job.Empty ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Ok","counters":[]},{"line":"            ( weight_lens.set (weight - 1) w","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"            , Base.Job.Full { job = d; seq_no; status = Job_status.Todo } )","counters":[]},{"line":"      | [ Job.Merge _ ], Full b ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Ok (w, Full { b with status = Job_status.Done })","counters":[]},{"line":"      | xs, _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Or_error.errorf","counters":[]},{"line":"            \"Got %d jobs when updating level %d and when one of the base nodes \\","counters":[]},{"line":"             is %s\"","counters":[]},{"line":"            (List.length xs) update_level (Base.Job.job_str d)","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"    in","counters":[]},{"line":"    let jobs = completed_jobs in","counters":[]},{"line":"    update_split ~f_merge:add_merges ~f_base:add_bases tree ~weight_merge:fst","counters":[]},{"line":"      ~jobs ~update_level ~jobs_split:(fun (w1, w2) a ->","counters":[]},{"line":"        let l = weight_lens.get w1 in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let r = weight_lens.get w2 in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        (List.take a l, List.take (List.drop a l) r) )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"","counters":[]},{"line":"  let reset_weights :","counters":[]},{"line":"         [ `Base | `Merge | `Both ]","counters":[]},{"line":"      -> ('merge_t, 'base_t) t","counters":[]},{"line":"      -> ('merge_t, 'base_t) t =","counters":[]},{"line":"   fun weight_type tree ->","counters":[]},{"line":"    let set_all_zero weight = Weight.base.set 0 (Weight.merge.set 0 weight) in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"    let f_base base =","counters":[]},{"line":"      let set_one (lens : (Weight.t, int) Lens.t) weight = lens.set 1 weight in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"      let set_zero (lens : (Weight.t, int) Lens.t) weight = lens.set 0 weight in","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"      let update_merge_weight weight =","counters":[]},{"line":"        (*When updating the merge-weight of base nodes, only the nodes with","counters":[]},{"line":"          \"Todo\" status needs to be included*)","counters":[]},{"line":"        match snd base with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | Base.Job.Full { status = Job_status.Todo; _ } ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            set_one Weight.merge weight","counters":[]},{"line":"        | _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            set_zero Weight.merge weight","counters":[]},{"line":"      in","counters":[]},{"line":"      let update_base_weight weight =","counters":[]},{"line":"        (*When updating the base-weight of base nodes, only the Empty nodes","counters":[]},{"line":"          need to be included*)","counters":[]},{"line":"        match snd base with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | Base.Job.Empty ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            set_one Weight.base weight","counters":[]},{"line":"        | _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            set_zero Weight.base weight","counters":[]},{"line":"      in","counters":[]},{"line":"      let new_weight, dummy_right_for_base_nodes =","counters":[]},{"line":"        match weight_type with","counters":[]},{"line":"        | `Merge ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (update_merge_weight (fst base), set_zero Weight.merge (fst base))","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":52,"col_end":52,"count":0},{"col_start":70,"col_end":70,"count":0}]},{"line":"        | `Base ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (update_base_weight (fst base), set_zero Weight.base (fst base))","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":51,"col_end":51,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"        | `Both ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let w' = update_base_weight (fst base) in","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"            (update_merge_weight w', set_all_zero w')","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"      in","counters":[]},{"line":"      ((new_weight, snd base), (new_weight, dummy_right_for_base_nodes))","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"    in","counters":[]},{"line":"    let f_merge lst m =","counters":[]},{"line":"      let (w1, w2), (w3, w4) = lst in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let reset (lens : (Weight.t, int) Lens.t) (w, w') =","counters":[]},{"line":"        (* Weights of all other jobs is sum of weights of its children*)","counters":[]},{"line":"        ( lens.set (lens.get w1 + lens.get w2) w","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"        , lens.set (lens.get w3 + lens.get w4) w' )","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"      in","counters":[]},{"line":"      let w' =","counters":[]},{"line":"        match weight_type with","counters":[]},{"line":"        | `Merge -> (","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (*When updating the merge-weight of merge nodes, only the nodes","counters":[]},{"line":"              with \"Todo\" status needs to be included*)","counters":[]},{"line":"            let lens = Weight.merge in","counters":[]},{"line":"            match m with","counters":[]},{"line":"            | (w1', w2'), Merge.Job.Full { status = Job_status.Todo; _ } ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (lens.set 1 w1', lens.set 0 w2')","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"            | w, _ ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                reset lens w )","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"        | `Base ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (* The base-weight of merge nodes is the sum of weights of its","counters":[]},{"line":"               children*)","counters":[]},{"line":"            reset Weight.base (fst m)","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"        | `Both ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            reset Weight.merge (reset Weight.base (fst m))","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"      in","counters":[]},{"line":"      ((w', snd m), w')","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"    in","counters":[]},{"line":"    fst (update_accumulate ~f_merge ~f_base tree)","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"  let jobs_on_level :","counters":[]},{"line":"         depth:int","counters":[]},{"line":"      -> level:int","counters":[]},{"line":"      -> ('merge_t, 'base_t) t","counters":[]},{"line":"      -> ('merge_job, 'base_job) Available_job.t list =","counters":[]},{"line":"   fun ~depth ~level tree ->","counters":[]},{"line":"    fold_depth ~init:[]","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":13,"col_end":13,"count":0}]},{"line":"      ~f_merge:(fun i acc a ->","counters":[]},{"line":"        match (i = level, a) with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | true, (_weight, Merge.Job.Full { left; right; status = Todo; _ }) ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Available_job.Merge (left, right) :: acc","counters":[]},{"line":"        | _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            acc )","counters":[]},{"line":"      ~f_base:(fun acc d ->","counters":[]},{"line":"        match (level = depth, d) with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | true, (_weight, Base.Job.Full { job; status = Todo; _ }) ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Available_job.Base job :: acc","counters":[]},{"line":"        | _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            acc )","counters":[]},{"line":"      tree","counters":[]},{"line":"    |> List.rev","counters":[]},{"line":"","counters":[]},{"line":"  let to_hashable_jobs :","counters":[]},{"line":"      ('merge_t, 'base_t) t -> ('merge_job, 'base_job) Job.t list =","counters":[]},{"line":"   fun tree ->","counters":[]},{"line":"    fold ~init:[]","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":7,"col_end":7,"count":0}]},{"line":"      ~f_merge:(fun acc a ->","counters":[]},{"line":"        match a with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | _, Merge.Job.Full { status = Job_status.Done; _ } ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            acc","counters":[]},{"line":"        | _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Job.Merge a :: acc )","counters":[]},{"line":"      ~f_base:(fun acc d ->","counters":[]},{"line":"        match d with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | _, Base.Job.Full { status = Job_status.Done; _ } ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            acc","counters":[]},{"line":"        | _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Job.Base d :: acc )","counters":[]},{"line":"      tree","counters":[]},{"line":"    |> List.rev","counters":[]},{"line":"","counters":[]},{"line":"  let jobs_records : ('merge_t, 'base_t) t -> ('merge_job, 'base_job) Job.t list","counters":[]},{"line":"      =","counters":[]},{"line":"   fun tree ->","counters":[]},{"line":"    fold ~init:[]","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":7,"col_end":7,"count":0}]},{"line":"      ~f_merge:(fun acc a ->","counters":[]},{"line":"        match a with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | _weight, Merge.Job.Full x ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Job.Merge x :: acc","counters":[]},{"line":"        | _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            acc )","counters":[]},{"line":"      ~f_base:(fun acc d ->","counters":[]},{"line":"        match d with _weight, Base.Job.Full j -> Job.Base j :: acc | _ -> acc )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"      tree","counters":[]},{"line":"    |> List.rev","counters":[]},{"line":"","counters":[]},{"line":"  let base_jobs : ('merge_t, _ * 'base_job Base.Job.t) t -> 'base_job list =","counters":[]},{"line":"   fun tree ->","counters":[]},{"line":"    fold_depth ~init:[]","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":13,"col_end":13,"count":0}]},{"line":"      ~f_merge:(fun _ _ _ -> [])","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"      ~f_base:(fun acc d ->","counters":[]},{"line":"        match d with _, Base.Job.Full { job; _ } -> job :: acc | _ -> acc )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"      tree","counters":[]},{"line":"    |> List.rev","counters":[]},{"line":"","counters":[]},{"line":"  (*calculates the number of base and merge jobs that is currently with the Todo status*)","counters":[]},{"line":"  let todo_job_count :","counters":[]},{"line":"      (_ * 'merge_job Merge.Job.t, _ * 'base_job Base.Job.t) t -> int * int =","counters":[]},{"line":"   fun tree ->","counters":[]},{"line":"    fold_depth ~init:(0, 0)","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ~f_merge:(fun _ (b, m) (_, j) ->","counters":[]},{"line":"        match j with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | Merge.Job.Full { status = Job_status.Todo; _ } ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (b, m + 1)","counters":[]},{"line":"        | _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (b, m) )","counters":[]},{"line":"      ~f_base:(fun (b, m) (_, d) ->","counters":[]},{"line":"        match d with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | Base.Job.Full { status = Job_status.Todo; _ } ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (b + 1, m)","counters":[]},{"line":"        | _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (b, m) )","counters":[]},{"line":"      tree","counters":[]},{"line":"","counters":[]},{"line":"  let leaves : ('merge_t, 'base_t) t -> 'base_t list =","counters":[]},{"line":"   fun tree ->","counters":[]},{"line":"    fold_depth ~init:[]","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":13,"col_end":13,"count":0}]},{"line":"      ~f_merge:(fun _ _ _ -> [])","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"      ~f_base:(fun acc d ->","counters":[]},{"line":"        match d with _, Base.Job.Full _ -> d :: acc | _ -> acc )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"      tree","counters":[]},{"line":"    |> List.rev","counters":[]},{"line":"","counters":[]},{"line":"  let rec _view_tree :","counters":[]},{"line":"      type merge_t base_t.","counters":[]},{"line":"         (merge_t, base_t) t","counters":[]},{"line":"      -> show_merge:(merge_t -> string)","counters":[]},{"line":"      -> show_base:(base_t -> string)","counters":[]},{"line":"      -> string =","counters":[]},{"line":"   fun tree ~show_merge ~show_base ->","counters":[]},{"line":"    match tree with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Leaf d ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        sprintf !\"Leaf %s\\n\" (show_base d)","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"    | Node { value; sub_tree; _ } ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let curr = sprintf !\"Node %s\\n\" (show_merge value) in","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"        let subtree =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          _view_tree sub_tree","counters":[]},{"line":"            ~show_merge:(fun (x, y) ->","counters":[]},{"line":"              sprintf !\"%s  %s\" (show_merge x) (show_merge y) )","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":42,"col_end":42,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"            ~show_base:(fun (x, y) ->","counters":[]},{"line":"              sprintf !\"%s  %s\" (show_base x) (show_base y) )","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"        in","counters":[]},{"line":"        curr ^ subtree","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"  let required_job_count = function","counters":[]},{"line":"    | Node { value = (w1, w2), _; _ } ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Weight.merge.get w1 + Weight.merge.get w2","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"    | Leaf (w, _) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Weight.merge.get w","counters":[]},{"line":"","counters":[]},{"line":"  let available_space = function","counters":[]},{"line":"    | Node { value = (w1, w2), _; _ } ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Weight.base.get w1 + Weight.base.get w2","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"    | Leaf (w, _) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Weight.base.get w","counters":[]},{"line":"","counters":[]},{"line":"  let view_jobs_with_position (tree : ('a, 'd) t) fa fd : 'c Job_view.t list =","counters":[]},{"line":"    let f_merge acc a =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let view =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        match snd a with","counters":[]},{"line":"        | Merge.Job.Empty ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Job_view.Node.MEmpty","counters":[]},{"line":"        | Part a ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            MPart (fa a)","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"        | Full { left; right; seq_no; status } ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            MFull (fa left, fa right, { Job_view.Extra.status; seq_no })","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"      in","counters":[]},{"line":"      view :: acc","counters":[]},{"line":"    in","counters":[]},{"line":"    let f_base acc a =","counters":[]},{"line":"      let view =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        match snd a with","counters":[]},{"line":"        | Base.Job.Empty ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Job_view.Node.BEmpty","counters":[]},{"line":"        | Full { seq_no; status; job } ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            BFull (fd job, { seq_no; status })","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"      in","counters":[]},{"line":"      view :: acc","counters":[]},{"line":"    in","counters":[]},{"line":"    let lst = fold ~f_merge ~f_base ~init:[] tree in","counters":[]},{"line":"    let len = List.length lst - 1 in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"    List.rev_mapi lst ~f:(fun i value -> { Job_view.position = len - i; value })","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(*This struture works well because we always complete all the nodes on a specific level before proceeding to the next level*)","counters":[]},{"line":"module T = struct","counters":[]},{"line":"  module Binable_arg = struct","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      [@@@no_toplevel_latest_type]","counters":[]},{"line":"","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type ('merge, 'base) t =","counters":[{"col_start":8,"col_end":8,"count":1},{"col_start":29,"col_end":29,"count":5}]},{"line":"          { trees :","counters":[]},{"line":"              ( 'merge Merge.Stable.V1.t","counters":[]},{"line":"              , 'base Base.Stable.V1.t )","counters":[]},{"line":"              Tree.Stable.V1.t","counters":[]},{"line":"              Non_empty_list.Stable.V1.t","counters":[]},{"line":"          ; acc : ('merge * 'base list) option","counters":[]},{"line":"          ; curr_job_seq_no : int","counters":[]},{"line":"          ; max_base_jobs : int","counters":[]},{"line":"          ; delay : int","counters":[]},{"line":"          }","counters":[{"col_start":10,"col_end":10,"count":3}]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  [%%versioned_binable","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type ('merge, 'base) t = ('merge, 'base) Binable_arg.Stable.V1.t =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { trees :","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":14,"col_end":14,"count":0}]},{"line":"            ('merge Merge.Stable.V1.t, 'base Base.Stable.V1.t) Tree.Stable.V1.t","counters":[]},{"line":"            Non_empty_list.Stable.V1.t","counters":[]},{"line":"              (*use non empty list*)","counters":[]},{"line":"        ; acc : ('merge * 'base list) option","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":12,"col_end":12,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"              (*last emitted proof and the corresponding transactions*)","counters":[]},{"line":"        ; curr_job_seq_no : int","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"              (*Sequence number for the jobs added every block*)","counters":[]},{"line":"        ; max_base_jobs : int (*transaction_capacity_log_2*)","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"        ; delay : int","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":14,"col_end":14,"count":0}]},{"line":"        }","counters":[]},{"line":"      [@@deriving sexp]","counters":[]},{"line":"","counters":[]},{"line":"      (* Delete all the completed jobs because","counters":[]},{"line":"         1. They are completed","counters":[]},{"line":"         2. They are not required to create new jobs anymore","counters":[]},{"line":"         3. We are not exposing these jobs for any sort of computation as of now","counters":[]},{"line":"      *)","counters":[]},{"line":"      let with_leaner_trees ({ trees; _ } as t) =","counters":[]},{"line":"        let trees =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Non_empty_list.map trees ~f:(fun tree ->","counters":[]},{"line":"              Tree.map tree","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ~f_merge:(fun merge_node ->","counters":[]},{"line":"                  match snd merge_node with","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  | Merge.Job.Full { status = Job_status.Done; _ } ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      (fst merge_node, Merge.Job.Empty)","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                  | _ ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      merge_node )","counters":[]},{"line":"                ~f_base:Fn.id )","counters":[]},{"line":"        in","counters":[]},{"line":"        { t with trees }","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"      include","counters":[]},{"line":"        Binable.Of_binable2_without_uuid","counters":[]},{"line":"          (Binable_arg.Stable.V1)","counters":[]},{"line":"          (struct","counters":[]},{"line":"            type nonrec ('merge, 'base) t = ('merge, 'base) t","counters":[]},{"line":"","counters":[]},{"line":"            let to_binable = with_leaner_trees","counters":[]},{"line":"","counters":[]},{"line":"            let of_binable = Fn.id","counters":[]},{"line":"          end)","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  [%%define_locally Stable.Latest.(with_leaner_trees)]","counters":[]},{"line":"","counters":[]},{"line":"  let create_tree_for_level ~level ~depth ~merge_job ~base_job =","counters":[]},{"line":"    let rec go :","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        type merge_t base_t.","counters":[]},{"line":"        int -> (int -> merge_t) -> base_t -> (merge_t, base_t) Tree.t =","counters":[]},{"line":"     fun d fmerge base ->","counters":[]},{"line":"      if d >= depth then Tree.Leaf base","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"      else","counters":[]},{"line":"        let sub_tree =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          go (d + 1) (fun i -> (fmerge i, fmerge i)) (base, base)","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"        in","counters":[]},{"line":"        Node { depth = d; value = fmerge d; sub_tree }","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"    in","counters":[]},{"line":"    let weight base merge = { Weight.base; merge } in","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"    let base_weight = if level = -1 then weight 0 0 else weight 1 0 in","counters":[{"col_start":41,"col_end":41,"count":0},{"col_start":46,"col_end":46,"count":0},{"col_start":57,"col_end":57,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"    go 0","counters":[]},{"line":"      (fun d ->","counters":[]},{"line":"        let weight =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          if level = -1 then (weight 0 0, weight 0 0)","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"          else","counters":[]},{"line":"            let x = Int.pow 2 level / Int.pow 2 (d + 1) in","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"            (weight x 0, weight x 0)","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"        in","counters":[]},{"line":"        (weight, merge_job) )","counters":[]},{"line":"      (base_weight, base_job)","counters":[]},{"line":"","counters":[]},{"line":"  let create_tree ~depth =","counters":[]},{"line":"    create_tree_for_level ~level:depth ~depth ~merge_job:Merge.Job.Empty","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ~base_job:Base.Job.Empty","counters":[]},{"line":"","counters":[]},{"line":"  let empty : type merge base. max_base_jobs:int -> delay:int -> (merge, base) t","counters":[]},{"line":"      =","counters":[]},{"line":"   fun ~max_base_jobs ~delay ->","counters":[]},{"line":"    let depth = Int.ceil_log2 max_base_jobs in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let first_tree :","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        ( (Weight.t * Weight.t) * merge Merge.Job.t","counters":[]},{"line":"        , Weight.t * base Base.Job.t )","counters":[]},{"line":"        Tree.t =","counters":[]},{"line":"      create_tree ~depth","counters":[]},{"line":"    in","counters":[]},{"line":"    { trees = Non_empty_list.singleton first_tree","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"    ; acc = None","counters":[]},{"line":"    ; curr_job_seq_no = 0","counters":[]},{"line":"    ; max_base_jobs","counters":[]},{"line":"    ; delay","counters":[]},{"line":"    }","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module State = struct","counters":[]},{"line":"  include T","counters":[]},{"line":"  module Hash = Hash","counters":[]},{"line":"","counters":[]},{"line":"  let map (type a1 a2 b1 b2) (t : (a1, a2) t) ~(f1 : a1 -> b1) ~(f2 : a2 -> b2)","counters":[]},{"line":"      : (b1, b2) t =","counters":[]},{"line":"    { t with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      trees =","counters":[]},{"line":"        Non_empty_list.map t.trees","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"          ~f:","counters":[]},{"line":"            (Tree.map_depth","counters":[]},{"line":"               ~f_merge:(fun _ -> Merge.map ~f:f1)","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"               ~f_base:(Base.map ~f:f2) )","counters":[]},{"line":"    ; acc = Option.map t.acc ~f:(fun (m, bs) -> (f1 m, List.map bs ~f:f2))","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":48,"col_end":48,"count":0},{"col_start":50,"col_end":50,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let hash t f_merge f_base =","counters":[]},{"line":"    let { trees; acc; max_base_jobs; curr_job_seq_no; delay; _ } =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      with_leaner_trees t","counters":[]},{"line":"    in","counters":[]},{"line":"    let h = ref (Digestif.SHA256.init ()) in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"    let add_string s = h := Digestif.SHA256.feed_string !h s in","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"    let () =","counters":[]},{"line":"      let tree_hash tree f_merge f_base =","counters":[]},{"line":"        List.iter (Tree.to_hashable_jobs tree) ~f:(fun job ->","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"            match job with Job.Merge a -> f_merge a | Base d -> f_base d )","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"      in","counters":[]},{"line":"      Non_empty_list.iter trees ~f:(fun tree ->","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"          let w_to_string { Weight.base = b; merge = m } =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Int.to_string b ^ Int.to_string m","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"          in","counters":[]},{"line":"          let w_to_string' (w1, w2) = w_to_string w1 ^ w_to_string w2 in","counters":[{"col_start":38,"col_end":38,"count":0},{"col_start":48,"col_end":48,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"          let f_merge = function","counters":[]},{"line":"            | w, Merge.Job.Empty ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                add_string (w_to_string' w ^ \"Empty\")","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"            | w, Merge.Job.Full { left; right; status; seq_no } ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                add_string","counters":[]},{"line":"                  ( w_to_string' w ^ \"Full\" ^ Int.to_string seq_no","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"                  ^ Job_status.to_string status ) ;","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"                add_string (f_merge left) ;","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"                add_string (f_merge right)","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"            | w, Merge.Job.Part j ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                add_string (w_to_string' w ^ \"Part\") ;","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"                add_string (f_merge j)","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"          in","counters":[]},{"line":"          let f_base = function","counters":[]},{"line":"            | w, Base.Job.Empty ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                add_string (w_to_string w ^ \"Empty\")","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"            | w, Base.Job.Full { job; status; seq_no } ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                add_string","counters":[]},{"line":"                  ( w_to_string w ^ \"Full\" ^ Int.to_string seq_no","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"                  ^ Job_status.to_string status ) ;","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"                add_string (f_base job)","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"          in","counters":[]},{"line":"          tree_hash tree f_merge f_base )","counters":[]},{"line":"    in","counters":[]},{"line":"    let acc_string =","counters":[]},{"line":"      Option.value_map acc ~default:\"None\" ~f:(fun (a, d_lst) ->","counters":[]},{"line":"          f_merge a ^ List.fold ~init:\"\" d_lst ~f:(fun acc d -> acc ^ f_base d) )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":16,"col_end":16,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":64,"col_end":64,"count":0},{"col_start":75,"col_end":75,"count":0}]},{"line":"    in","counters":[]},{"line":"    add_string acc_string ;","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    add_string (Int.to_string curr_job_seq_no) ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"    add_string (Int.to_string max_base_jobs) ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"    add_string (Int.to_string delay) ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"    Digestif.SHA256.get !h","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  module Make_foldable (M : Monad.S) = struct","counters":[]},{"line":"    module Tree_foldable = Tree.Make_foldable (M)","counters":[]},{"line":"","counters":[]},{"line":"    let fold_chronological_until :","counters":[]},{"line":"           ('merge, 'base) t","counters":[]},{"line":"        -> init:'acc","counters":[]},{"line":"        -> f_merge:","counters":[]},{"line":"             ('acc -> 'merge Merge.t -> ('acc, 'final) Continue_or_stop.t M.t)","counters":[]},{"line":"        -> f_base:('acc -> 'base Base.t -> ('acc, 'final) Continue_or_stop.t M.t)","counters":[]},{"line":"        -> finish:('acc -> 'final M.t)","counters":[]},{"line":"        -> 'final M.t =","counters":[]},{"line":"     fun t ~init ~f_merge ~f_base ~finish ->","counters":[]},{"line":"      let open M.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let open Container.Continue_or_stop in","counters":[]},{"line":"      let work_trees = Non_empty_list.rev t.trees |> Non_empty_list.to_list in","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"      let rec go acc = function","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        | [] ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            M.return (Continue acc)","counters":[]},{"line":"        | tree :: trees -> (","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            match%bind","counters":[]},{"line":"              Tree_foldable.fold_depth_until'","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"                ~f_merge:(fun _ -> f_merge)","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                ~f_base ~init:acc tree","counters":[]},{"line":"            with","counters":[]},{"line":"            | Continue r ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                go r trees","counters":[]},{"line":"            | Stop e ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                M.return (Stop e) )","counters":[]},{"line":"      in","counters":[]},{"line":"      match%bind go init work_trees with","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"      | Continue r ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          finish r","counters":[]},{"line":"      | Stop e ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          M.return e","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Foldable_ident = Make_foldable (Monad.Ident)","counters":[]},{"line":"","counters":[]},{"line":"  let fold_chronological t ~init ~f_merge ~f_base =","counters":[]},{"line":"    let open Container.Continue_or_stop in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Foldable_ident.fold_chronological_until t ~init","counters":[]},{"line":"      ~f_merge:(fun acc a -> Continue (f_merge acc a))","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"      ~f_base:(fun acc d -> Continue (f_base acc d))","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"      ~finish:Fn.id","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"include T","counters":[]},{"line":"module State_or_error = State_or_error.Make3 (T)","counters":[]},{"line":"","counters":[]},{"line":"let check b ~message = State_or_error.error_if b ~message ~value:()","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"","counters":[]},{"line":"let return_error e a =","counters":[]},{"line":"  State_or_error.error_if true ~message:(Error.to_string_hum e) ~value:a","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"","counters":[]},{"line":"let max_trees : ('merge, 'base) t -> int =","counters":[]},{"line":" fun t -> ((Int.ceil_log2 t.max_base_jobs + 1) * (t.delay + 1)) + 1","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"","counters":[]},{"line":"let work_to_do :","counters":[]},{"line":"    type merge base.","counters":[]},{"line":"       (merge Merge.t, base Base.t) Tree.t list","counters":[]},{"line":"    -> max_base_jobs:int","counters":[]},{"line":"    -> (merge, base) Available_job.t list =","counters":[]},{"line":" fun trees ~max_base_jobs ->","counters":[]},{"line":"  let depth = Int.ceil_log2 max_base_jobs in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  List.concat_mapi trees ~f:(fun i tree ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      Tree.jobs_on_level ~depth ~level:(depth - i) tree )","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"let work :","counters":[]},{"line":"    type merge base.","counters":[]},{"line":"       (merge Merge.t, base Base.t) Tree.t list","counters":[]},{"line":"    -> delay:int","counters":[]},{"line":"    -> max_base_jobs:int","counters":[]},{"line":"    -> (merge, base) Available_job.t list =","counters":[]},{"line":" fun trees ~delay ~max_base_jobs ->","counters":[]},{"line":"  let depth = Int.ceil_log2 max_base_jobs in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let work_trees =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    List.take","counters":[]},{"line":"      (List.filteri trees ~f:(fun i _ -> i % delay = delay - 1))","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"      (depth + 1)","counters":[]},{"line":"  in","counters":[]},{"line":"  work_to_do work_trees ~max_base_jobs","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let work_for_tree t ~data_tree =","counters":[]},{"line":"  let delay = t.delay + 1 in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let trees =","counters":[]},{"line":"    match data_tree with","counters":[]},{"line":"    | `Current ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Non_empty_list.tail t.trees","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"    | `Next ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Non_empty_list.to_list t.trees","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"  in","counters":[]},{"line":"  work trees ~max_base_jobs:t.max_base_jobs ~delay","counters":[]},{"line":"","counters":[]},{"line":"(*work on all the level and all the trees*)","counters":[]},{"line":"let all_work :","counters":[]},{"line":"    type merge base. (merge, base) t -> (merge, base) Available_job.t list list","counters":[]},{"line":"    =","counters":[]},{"line":" fun t ->","counters":[]},{"line":"  let depth = Int.ceil_log2 t.max_base_jobs in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let set1 = work_for_tree t ~data_tree:`Current in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let _, other_sets =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    List.fold ~init:(t, [])","counters":[]},{"line":"      (List.init ~f:Fn.id (t.delay + 1))","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"      ~f:(fun (t, work_list) _ ->","counters":[]},{"line":"        let trees' = Non_empty_list.cons (create_tree ~depth) t.trees in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let t' = { t with trees = trees' } in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        match work_for_tree t' ~data_tree:`Current with","counters":[]},{"line":"        | [] ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (t', work_list)","counters":[]},{"line":"        | work ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (t', work :: work_list) )","counters":[]},{"line":"  in","counters":[]},{"line":"  if List.is_empty set1 then List.rev other_sets","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"  else set1 :: List.rev other_sets","counters":[{"col_start":7,"col_end":7,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"let work_for_next_update :","counters":[]},{"line":"    type merge base.","counters":[]},{"line":"    (merge, base) t -> data_count:int -> (merge, base) Available_job.t list list","counters":[]},{"line":"    =","counters":[]},{"line":" fun t ~data_count ->","counters":[]},{"line":"  let delay = t.delay + 1 in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let current_tree_space = Tree.available_space (Non_empty_list.head t.trees) in","counters":[{"col_start":67,"col_end":67,"count":0}]},{"line":"  let set1 =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    work (Non_empty_list.tail t.trees) ~max_base_jobs:t.max_base_jobs ~delay","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"  in","counters":[]},{"line":"  let count = min data_count t.max_base_jobs in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  if current_tree_space < count then","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    let set2 =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      List.take","counters":[]},{"line":"        (work","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"           (Non_empty_list.to_list t.trees)","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"           ~max_base_jobs:t.max_base_jobs ~delay )","counters":[]},{"line":"        ((count - current_tree_space) * 2)","counters":[]},{"line":"    in","counters":[]},{"line":"    List.filter ~f:(Fn.compose not List.is_empty) [ set1; set2 ]","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"  else","counters":[]},{"line":"    let set = List.take set1 (2 * count) in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    if List.is_empty set then [] else [ set ]","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"","counters":[]},{"line":"let free_space_on_current_tree t =","counters":[]},{"line":"  let tree = Non_empty_list.head t.trees in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  Tree.available_space tree","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let cons b bs =","counters":[]},{"line":"  Option.value_map (Non_empty_list.of_list_opt bs)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"    ~default:(Non_empty_list.singleton b) ~f:(fun bs ->","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"      Non_empty_list.cons b bs )","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"let append bs bs' =","counters":[]},{"line":"  Option.value_map (Non_empty_list.of_list_opt bs') ~default:bs ~f:(fun bs' ->","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"      Non_empty_list.append bs bs' )","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"let add_merge_jobs :","counters":[]},{"line":"    completed_jobs:'merge list -> ('base, 'merge, _) State_or_error.t =","counters":[]},{"line":" fun ~completed_jobs ->","counters":[]},{"line":"  let open State_or_error.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  if List.length completed_jobs = 0 then return None","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"  else","counters":[]},{"line":"    let%bind state = State_or_error.get in","counters":[]},{"line":"    let delay = state.delay + 1 in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let depth = Int.ceil_log2 state.max_base_jobs in","counters":[]},{"line":"    let merge_jobs = List.map completed_jobs ~f:(fun j -> Job.Merge j) in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"    let jobs_required = work_for_tree state ~data_tree:`Current in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let%bind () =","counters":[]},{"line":"      check","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        (List.length merge_jobs > List.length jobs_required)","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"        ~message:","counters":[]},{"line":"          (sprintf","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"             !\"More work than required: Required- %d got- %d\"","counters":[]},{"line":"             (List.length jobs_required)","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"             (List.length merge_jobs) )","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"    in","counters":[]},{"line":"    let curr_tree, to_be_updated_trees =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (Non_empty_list.head state.trees, Non_empty_list.tail state.trees)","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"    in","counters":[]},{"line":"    let%bind updated_trees, result_opt, _ =","counters":[]},{"line":"      let res =","counters":[]},{"line":"        List.foldi to_be_updated_trees","counters":[]},{"line":"          ~init:(Ok ([], None, merge_jobs))","counters":[]},{"line":"          ~f:(fun i acc tree ->","counters":[]},{"line":"            let open Or_error.Let_syntax in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let%bind trees, scan_result, jobs = acc in","counters":[]},{"line":"            if i % delay = delay - 1 && not (List.is_empty jobs) then","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"              (*Every nth (n=delay) tree*)","counters":[]},{"line":"              match","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Tree.update","counters":[]},{"line":"                  (List.take jobs (Tree.required_job_count tree))","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"                  ~update_level:(depth - (i / delay))","counters":[]},{"line":"                  ~sequence_no:state.curr_job_seq_no ~weight_lens:Weight.merge","counters":[]},{"line":"                  tree","counters":[]},{"line":"              with","counters":[]},{"line":"              | Ok (tree', scan_result') ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Ok","counters":[]},{"line":"                    ( tree' :: trees","counters":[]},{"line":"                    , scan_result'","counters":[]},{"line":"                    , List.drop jobs (Tree.required_job_count tree) )","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"              | Error e ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Error","counters":[]},{"line":"                    (Error.tag_arg e \"Error while adding merge jobs to tree\"","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"                       (\"tree_number\", i) [%sexp_of: string * int] )","counters":[]},{"line":"            else Ok (tree :: trees, scan_result, jobs) )","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"      in","counters":[]},{"line":"      match res with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Ok res ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          State_or_error.return res","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"      | Error e ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          return_error e ([], None, [])","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"    in","counters":[]},{"line":"    let updated_trees, result_opt =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let updated_trees, result_opt =","counters":[]},{"line":"        Option.value_map result_opt","counters":[]},{"line":"          ~default:(List.rev updated_trees, None)","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"          ~f:(fun res ->","counters":[]},{"line":"            match updated_trees with","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            | [] ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ([], None)","counters":[]},{"line":"            | t :: ts ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                let tree_data = Tree.base_jobs t in","counters":[]},{"line":"                (List.rev ts, Some (res, tree_data)) )","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"      in","counters":[]},{"line":"      if","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Option.is_some result_opt","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"        || List.length (curr_tree :: updated_trees) < max_trees state","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"           && List.length completed_jobs = List.length jobs_required","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":53,"col_end":53,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"        (*exact number of jobs*)","counters":[]},{"line":"      then (List.map updated_trees ~f:(Tree.reset_weights `Merge), result_opt)","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"      else (updated_trees, result_opt)","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"    in","counters":[]},{"line":"    let all_trees = cons curr_tree updated_trees in","counters":[]},{"line":"    let%map _ = State_or_error.put { state with trees = all_trees } in","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"    result_opt","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"let add_data : data:'base list -> (_, _, 'base) State_or_error.t =","counters":[]},{"line":" fun ~data ->","counters":[]},{"line":"  let open State_or_error.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  if List.length data = 0 then return ()","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"  else","counters":[]},{"line":"    let%bind state = State_or_error.get in","counters":[]},{"line":"    let depth = Int.ceil_log2 state.max_base_jobs in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let tree = Non_empty_list.head state.trees in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let base_jobs = List.map data ~f:(fun j -> Job.Base j) in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"    let available_space = Tree.available_space tree in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let%bind () =","counters":[]},{"line":"      check","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        (List.length data > available_space)","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"        ~message:","counters":[]},{"line":"          (sprintf","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"             !\"Data count (%d) exceeded available space (%d)\"","counters":[]},{"line":"             (List.length data) available_space )","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"    in","counters":[]},{"line":"    let%bind tree, _ =","counters":[]},{"line":"      match","counters":[]},{"line":"        Tree.update base_jobs ~update_level:depth","counters":[]},{"line":"          ~sequence_no:state.curr_job_seq_no ~weight_lens:Weight.base tree","counters":[]},{"line":"      with","counters":[]},{"line":"      | Ok res ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          State_or_error.return res","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"      | Error e ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          return_error","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"            (Error.tag ~tag:\"Error while adding base jobs to the tree\" e)","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"            (tree, None)","counters":[]},{"line":"    in","counters":[]},{"line":"    let updated_trees =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      if List.length base_jobs = available_space then","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"        cons (create_tree ~depth) [ Tree.reset_weights `Both tree ]","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":11,"col_end":11,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"      else Non_empty_list.singleton (Tree.reset_weights `Merge tree)","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"    in","counters":[]},{"line":"    let%map _ =","counters":[]},{"line":"      State_or_error.put","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"        { state with","counters":[]},{"line":"          trees = append updated_trees (Non_empty_list.tail state.trees)","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"        }","counters":[]},{"line":"    in","counters":[]},{"line":"    ()","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"let reset_seq_no : type a b. (a, b) t -> (a, b) t =","counters":[]},{"line":" fun state ->","counters":[]},{"line":"  let oldest_seq_no =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    match List.hd @@ Tree.leaves (Non_empty_list.last state.trees) with","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"    | Some (_, Base.Job.Full { seq_no; _ }) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        seq_no","counters":[]},{"line":"    | _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        0","counters":[]},{"line":"  in","counters":[]},{"line":"  let new_seq seq = seq - oldest_seq_no + 1 in","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"  let f_merge (a : a Merge.t) : a Merge.t =","counters":[]},{"line":"    match a with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | w, Merge.Job.Full ({ seq_no; _ } as x) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (w, Merge.Job.Full { x with seq_no = new_seq seq_no })","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"    | m ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        m","counters":[]},{"line":"  in","counters":[]},{"line":"  let f_base (b : b Base.t) : b Base.t =","counters":[]},{"line":"    match b with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | w, Base.Job.Full ({ seq_no; _ } as x) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (w, Base.Job.Full { x with seq_no = new_seq seq_no })","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"    | b ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        b","counters":[]},{"line":"  in","counters":[]},{"line":"  let next_seq_no, updated_trees =","counters":[]},{"line":"    List.fold ~init:(0, []) (Non_empty_list.to_list state.trees)","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"      ~f:(fun (max_seq, updated_trees) tree ->","counters":[]},{"line":"        let tree' = Tree.map ~f_base ~f_merge tree in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let seq_no =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          match List.last @@ Tree.leaves tree' with","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"          | Some (_, Base.Job.Full { seq_no; _ }) ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              max seq_no max_seq","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"          | _ ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              max_seq","counters":[]},{"line":"        in","counters":[]},{"line":"        (seq_no, tree' :: updated_trees) )","counters":[]},{"line":"  in","counters":[]},{"line":"  { state with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    curr_job_seq_no = next_seq_no","counters":[]},{"line":"  ; trees =","counters":[]},{"line":"      Option.value_exn (Non_empty_list.of_list_opt (List.rev updated_trees))","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":49,"col_end":49,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"let incr_sequence_no : type a b. (a, b) t -> (unit, a, b) State_or_error.t =","counters":[]},{"line":" fun state ->","counters":[]},{"line":"  let open State_or_error in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  if state.curr_job_seq_no + 1 = Int.max_value then","counters":[]},{"line":"    let state = reset_seq_no state in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    put state","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  else put { state with curr_job_seq_no = state.curr_job_seq_no + 1 }","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"","counters":[]},{"line":"let update_metrics t =","counters":[]},{"line":"  Or_error.try_with (fun () ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      List.rev (Non_empty_list.to_list t.trees)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"      |> List.iteri ~f:(fun i t ->","counters":[]},{"line":"             let name = sprintf \"tree%d\" i in","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"             Mina_metrics.(","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"               Gauge.set (Scan_state_metrics.scan_state_available_space ~name))","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"               (Int.to_float @@ Tree.available_space t) ;","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"             let base_job_count, merge_job_count = Tree.todo_job_count t in","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"             Mina_metrics.(","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"               Gauge.set (Scan_state_metrics.scan_state_base_snarks ~name))","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"               (Int.to_float @@ base_job_count) ;","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"             Mina_metrics.(","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"               Gauge.set (Scan_state_metrics.scan_state_merge_snarks ~name))","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"               (Int.to_float @@ merge_job_count) ) )","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"","counters":[]},{"line":"let update_helper :","counters":[]},{"line":"       data:'base list","counters":[]},{"line":"    -> completed_jobs:'merge list","counters":[]},{"line":"    -> ('a, 'merge, 'base) State_or_error.t =","counters":[]},{"line":" fun ~data ~completed_jobs ->","counters":[]},{"line":"  let open State_or_error in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let open State_or_error.Let_syntax in","counters":[]},{"line":"  let%bind t = get in","counters":[]},{"line":"  let data_count = List.length data in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%bind () =","counters":[]},{"line":"    check","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      (data_count > t.max_base_jobs)","counters":[]},{"line":"      ~message:","counters":[]},{"line":"        (sprintf","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"           !\"Data count (%d) exceeded maximum (%d)\"","counters":[]},{"line":"           data_count t.max_base_jobs )","counters":[]},{"line":"  in","counters":[]},{"line":"  let required_jobs = List.concat @@ work_for_next_update t ~data_count in","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"  let%bind () =","counters":[]},{"line":"    let required = (List.length required_jobs + 1) / 2 in","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"    let got = (List.length completed_jobs + 1) / 2 in","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"    check","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      (got < required && List.length data > t.max_base_jobs - required + got)","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"      ~message:","counters":[]},{"line":"        (sprintf","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"           !\"Insufficient jobs (Data count %d): Required- %d got- %d\"","counters":[]},{"line":"           data_count required got )","counters":[]},{"line":"  in","counters":[]},{"line":"  let delay = t.delay + 1 in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  (*Increment the sequence number*)","counters":[]},{"line":"  let%bind () = incr_sequence_no t in","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"  let latest_tree = Non_empty_list.head t.trees in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let available_space = Tree.available_space latest_tree in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  (*Possible that new base jobs is added to a new tree within an update i.e., part of it is added to the first tree and the rest of it to a new tree. This happens when the throughput is not max. This also requires merge jobs to be done on two different set of trees*)","counters":[]},{"line":"  let data1, data2 = List.split_n data available_space in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let required_jobs_for_current_tree =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    work (Non_empty_list.tail t.trees) ~max_base_jobs:t.max_base_jobs ~delay","counters":[{"col_start":7,"col_end":7,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"    |> List.length","counters":[]},{"line":"  in","counters":[]},{"line":"  let jobs1, jobs2 =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    List.split_n completed_jobs required_jobs_for_current_tree","counters":[]},{"line":"  in","counters":[]},{"line":"  (*update first set of jobs and data*)","counters":[]},{"line":"  let%bind result_opt = add_merge_jobs ~completed_jobs:jobs1 in","counters":[]},{"line":"  let%bind () = add_data ~data:data1 in","counters":[]},{"line":"  (*update second set of jobs and data. This will be empty if all the data fit in the current tree*)","counters":[]},{"line":"  let%bind _ = add_merge_jobs ~completed_jobs:jobs2 in","counters":[]},{"line":"  let%bind () = add_data ~data:data2 in","counters":[]},{"line":"  let%bind state = State_or_error.get in","counters":[]},{"line":"  (*update the latest emitted value *)","counters":[]},{"line":"  let%bind () =","counters":[]},{"line":"    State_or_error.put","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"      { state with acc = Option.merge result_opt state.acc ~f:Fn.const }","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"  in","counters":[]},{"line":"  (*Check the tree-list length is under max*)","counters":[]},{"line":"  let%map () =","counters":[]},{"line":"    check","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      (Non_empty_list.length state.trees > max_trees state)","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"      ~message:","counters":[]},{"line":"        (sprintf","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"           !\"Tree list length (%d) exceeded maximum (%d)\"","counters":[]},{"line":"           (Non_empty_list.length state.trees)","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"           (max_trees state) )","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"  in","counters":[]},{"line":"  result_opt","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let update :","counters":[]},{"line":"       data:'base list","counters":[]},{"line":"    -> completed_jobs:'merge list","counters":[]},{"line":"    -> ('merge, 'base) t","counters":[]},{"line":"    -> (('merge * 'base list) option * ('merge, 'base) t) Or_error.t =","counters":[]},{"line":" fun ~data ~completed_jobs state ->","counters":[]},{"line":"  State_or_error.run_state (update_helper ~data ~completed_jobs) ~state","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let all_jobs t = all_work t","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"","counters":[]},{"line":"let jobs_for_next_update t = work_for_next_update t ~data_count:t.max_base_jobs","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"let jobs_for_slots t ~slots = work_for_next_update t ~data_count:slots","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"","counters":[]},{"line":"let free_space t = t.max_base_jobs","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"","counters":[]},{"line":"let last_emitted_value t = t.acc","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"","counters":[]},{"line":"let current_job_sequence_number t = t.curr_job_seq_no","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"","counters":[]},{"line":"let base_jobs_on_latest_tree t =","counters":[]},{"line":"  let depth = Int.ceil_log2 t.max_base_jobs in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  List.filter_map","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    (Tree.jobs_on_level ~depth ~level:depth (Non_empty_list.head t.trees))","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"    ~f:(fun job -> match job with Base d -> Some d | Merge _ -> None)","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"","counters":[]},{"line":"(* 0-based indexing, so 0 indicates next-to-latest tree *)","counters":[]},{"line":"let base_jobs_on_earlier_tree t ~index =","counters":[]},{"line":"  let depth = Int.ceil_log2 t.max_base_jobs in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let earlier_trees = Non_empty_list.tail t.trees in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  match List.nth earlier_trees index with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | None ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      []","counters":[]},{"line":"  | Some tree ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let jobs = Tree.jobs_on_level ~depth ~level:depth tree in","counters":[]},{"line":"      List.filter_map jobs ~f:(fun job ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          match job with Base d -> Some d | Merge _ -> None )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"let partition_if_overflowing : ('merge, 'base) t -> Space_partition.t =","counters":[]},{"line":" fun t ->","counters":[]},{"line":"  let cur_tree_space = free_space_on_current_tree t in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  (*Check actual work count because it would be zero initially*)","counters":[]},{"line":"  let work_count = work_for_tree t ~data_tree:`Current |> List.length in","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"  let work_count_new_tree = work_for_tree t ~data_tree:`Next |> List.length in","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"  { first = (cur_tree_space, work_count)","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  ; second =","counters":[]},{"line":"      ( if cur_tree_space < t.max_base_jobs then","counters":[]},{"line":"        let slots = t.max_base_jobs - cur_tree_space in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Some (slots, min work_count_new_tree (2 * slots))","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"      else None )","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"let next_on_new_tree t =","counters":[]},{"line":"  let curr_tree_space = free_space_on_current_tree t in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  curr_tree_space = t.max_base_jobs","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let pending_data t =","counters":[]},{"line":"  List.concat_map Non_empty_list.(to_list @@ rev t.trees) ~f:Tree.base_jobs","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"","counters":[]},{"line":"let view_jobs_with_position (state : ('merge, 'base) State.t) fa fd =","counters":[]},{"line":"  List.fold ~init:[] (Non_empty_list.to_list state.trees) ~f:(fun acc tree ->","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"      Tree.view_jobs_with_position tree fa fd :: acc )","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"","counters":[]},{"line":"let job_count t =","counters":[]},{"line":"  State.fold_chronological t ~init:(0., 0.)","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    ~f_merge:(fun (c, c') merge_node ->","counters":[]},{"line":"      let count_todo, count_done =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        match snd merge_node with","counters":[]},{"line":"        | Merge.Job.Part _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (0.5, 0.)","counters":[]},{"line":"        | Full { status = Job_status.Todo; _ } ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (1., 0.)","counters":[]},{"line":"        | Full { status = Job_status.Done; _ } ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (0., 1.)","counters":[]},{"line":"        | Empty ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (0., 0.)","counters":[]},{"line":"      in","counters":[]},{"line":"      (c +. count_todo, c' +. count_done) )","counters":[]},{"line":"    ~f_base:(fun (c, c') base_node ->","counters":[]},{"line":"      let count_todo, count_done =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        match snd base_node with","counters":[]},{"line":"        | Base.Job.Empty ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (0., 0.)","counters":[]},{"line":"        | Full { status = Job_status.Todo; _ } ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (1., 0.)","counters":[]},{"line":"        | Full { status = Job_status.Done; _ } ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (0., 1.)","counters":[]},{"line":"      in","counters":[]},{"line":"      (c +. count_todo, c' +. count_done) )","counters":[]},{"line":"","counters":[]},{"line":"let assert_job_count t t' ~completed_job_count ~base_job_count ~value_emitted =","counters":[]},{"line":"  let todo_before, done_before = job_count t in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let todo_after, done_after = job_count t' in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  (*ordered list of jobs that is actually called when distributing work*)","counters":[]},{"line":"  let all_jobs = List.concat (all_jobs t') in","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"  (*list of jobs*)","counters":[]},{"line":"  let all_jobs_expected =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    List.fold ~init:[] (Non_empty_list.to_list t'.trees) ~f:(fun acc tree ->","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"        Tree.jobs_records tree @ acc )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"    |> List.filter ~f:(fun job ->","counters":[]},{"line":"           match job with","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"           | Job.Base { status = Job_status.Todo; _ }","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"           | Job.Merge { status = Todo; _ } ->","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"               true","counters":[]},{"line":"           | _ ->","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"               false )","counters":[]},{"line":"  in","counters":[]},{"line":"  assert (List.length all_jobs = List.length all_jobs_expected) ;","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":9,"col_end":9,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"  let expected_todo_after =","counters":[]},{"line":"    let new_jobs =","counters":[]},{"line":"      if value_emitted then (completed_job_count -. 1.) /. 2.","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"      else completed_job_count /. 2.","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"    in","counters":[]},{"line":"    todo_before +. base_job_count -. completed_job_count +. new_jobs","counters":[]},{"line":"  in","counters":[]},{"line":"  let expected_done_after =","counters":[]},{"line":"    let jobs_from_delete_tree =","counters":[]},{"line":"      if value_emitted then Float.of_int @@ ((2 * t.max_base_jobs) - 1) else 0.","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":77,"col_end":77,"count":0}]},{"line":"    in","counters":[]},{"line":"    done_before +. completed_job_count -. jobs_from_delete_tree","counters":[]},{"line":"  in","counters":[]},{"line":"  assert (","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"    Float.equal todo_after expected_todo_after","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"    && Float.equal done_after expected_done_after )","counters":[{"col_start":7,"col_end":7,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"","counters":[]},{"line":"let test_update t ~data ~completed_jobs =","counters":[]},{"line":"  let result_opt, t' = update ~data ~completed_jobs t |> Or_error.ok_exn in","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"  assert_job_count t t'","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    ~base_job_count:(Float.of_int @@ List.length data)","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"    ~completed_job_count:(Float.of_int @@ List.length completed_jobs)","counters":[{"col_start":37,"col_end":37,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"    ~value_emitted:(Option.is_some result_opt) ;","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"  (result_opt, t')","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let%test_module \"test\" =","counters":[]},{"line":"  ( module struct","counters":[]},{"line":"    let%test_unit \"always max base jobs\" =","counters":[]},{"line":"      let max_base_jobs = 512 in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let state = empty ~max_base_jobs ~delay:3 in","counters":[]},{"line":"      let _t' =","counters":[]},{"line":"        List.foldi ~init:([], state) (List.init 100 ~f:Fn.id)","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"          ~f:(fun i (expected_results, t) _ ->","counters":[]},{"line":"            let data = List.init max_base_jobs ~f:(fun j -> i + j) in","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"            let expected_results = data :: expected_results in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let work =","counters":[]},{"line":"              work_for_next_update t ~data_count:(List.length data)","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"              |> List.concat","counters":[]},{"line":"            in","counters":[]},{"line":"            let new_merges =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              List.map work ~f:(fun job ->","counters":[]},{"line":"                  match job with Base i -> i | Merge (i, j) -> i + j )","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"            in","counters":[]},{"line":"            let result_opt, t' =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              test_update ~data ~completed_jobs:new_merges t","counters":[]},{"line":"            in","counters":[]},{"line":"            let expected_result, remaining_expected_results =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Option.value_map result_opt","counters":[]},{"line":"                ~default:((0, []), expected_results)","counters":[]},{"line":"                ~f:(fun _ ->","counters":[]},{"line":"                  match List.rev expected_results with","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  | [] ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      ((0, []), [])","counters":[]},{"line":"                  | x :: xs ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      ((List.sum (module Int) x ~f:Fn.id, x), List.rev xs) )","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"            in","counters":[]},{"line":"            assert (","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"              [%equal: int * int list]","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"                (Option.value ~default:expected_result result_opt)","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                expected_result ) ;","counters":[]},{"line":"            (remaining_expected_results, t') )","counters":[]},{"line":"      in","counters":[]},{"line":"      ()","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"Random base jobs\" =","counters":[]},{"line":"      let max_base_jobs = 512 in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let t = empty ~max_base_jobs ~delay:3 in","counters":[]},{"line":"      let state = ref t in","counters":[]},{"line":"      Quickcheck.test","counters":[]},{"line":"        (Quickcheck.Generator.list (Int.gen_incl 1 1))","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"        ~f:(fun list ->","counters":[]},{"line":"          let t = !state in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let data = List.take list max_base_jobs in","counters":[]},{"line":"          let work =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            List.take","counters":[]},{"line":"              ( work_for_next_update t ~data_count:(List.length data)","counters":[{"col_start":35,"col_end":35,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"              |> List.concat )","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"              (List.length data * 2)","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"          in","counters":[]},{"line":"          let new_merges =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            List.map work ~f:(fun job ->","counters":[]},{"line":"                match job with Base i -> i | Merge (i, j) -> i + j )","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"          in","counters":[]},{"line":"          let result_opt, t' = test_update ~data ~completed_jobs:new_merges t in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let expected_result =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (max_base_jobs, List.init max_base_jobs ~f:(fun _ -> 1))","counters":[{"col_start":36,"col_end":36,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"          in","counters":[]},{"line":"          assert (","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"            [%equal: int * int list]","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"              (Option.value ~default:expected_result result_opt)","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"              expected_result ) ;","counters":[]},{"line":"          state := t' )","counters":[]},{"line":"  end )","counters":[]},{"line":"","counters":[]},{"line":"let gen :","counters":[]},{"line":"       gen_data:'d Quickcheck.Generator.t","counters":[]},{"line":"    -> f_job_done:(('a, 'd) Available_job.t -> 'a)","counters":[]},{"line":"    -> f_acc:(('a * 'd list) option -> 'a * 'd list -> ('a * 'd list) option)","counters":[]},{"line":"    -> ('a, 'd) State.t Quickcheck.Generator.t =","counters":[]},{"line":" fun ~gen_data ~f_job_done ~f_acc ->","counters":[]},{"line":"  let open Quickcheck.Generator.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%bind depth, delay =","counters":[]},{"line":"    Quickcheck.Generator.tuple2 (Int.gen_incl 2 5) (Int.gen_incl 0 3)","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"  in","counters":[]},{"line":"  let max_base_jobs = Int.pow 2 depth in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let s = State.empty ~max_base_jobs ~delay in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%map datas =","counters":[]},{"line":"    Quickcheck.Generator.(","counters":[]},{"line":"      list_non_empty (list_with_length max_base_jobs gen_data))","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"  in","counters":[]},{"line":"  List.fold datas ~init:s ~f:(fun s chunk ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      let jobs =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        List.concat (work_for_next_update s ~data_count:(List.length chunk))","counters":[{"col_start":40,"col_end":40,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"      in","counters":[]},{"line":"      let jobs_done = List.map jobs ~f:f_job_done in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let old_tuple = s.acc in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let res_opt, s =","counters":[]},{"line":"        Or_error.ok_exn @@ update ~data:chunk s ~completed_jobs:jobs_done","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"      in","counters":[]},{"line":"      Option.value_map ~default:s res_opt ~f:(fun x ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          let tuple = if Option.is_some old_tuple then old_tuple else s.acc in","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":55,"col_end":55,"count":0},{"col_start":70,"col_end":70,"count":0}]},{"line":"          { s with acc = f_acc tuple x } ) )","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"let%test_module \"scans\" =","counters":[]},{"line":"  ( module struct","counters":[]},{"line":"    module Queue = Queue","counters":[]},{"line":"","counters":[]},{"line":"    let rec step_on_free_space state w ds f f_acc =","counters":[]},{"line":"      let data = List.take ds state.max_base_jobs in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let jobs =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        List.concat (work_for_next_update state ~data_count:(List.length data))","counters":[{"col_start":40,"col_end":40,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"      in","counters":[]},{"line":"      let jobs_done = List.map jobs ~f in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let old_tuple = state.acc in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let res_opt, state = test_update ~data state ~completed_jobs:jobs_done in","counters":[]},{"line":"      let state =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Option.value_map ~default:state res_opt ~f:(fun x ->","counters":[]},{"line":"            let tuple =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              if Option.is_some old_tuple then f_acc old_tuple x else state.acc","counters":[{"col_start":47,"col_end":47,"count":0},{"col_start":51,"col_end":51,"count":0},{"col_start":70,"col_end":70,"count":0}]},{"line":"            in","counters":[]},{"line":"            { state with acc = tuple } )","counters":[]},{"line":"      in","counters":[]},{"line":"      let%bind () = Linear_pipe.write w state.acc in","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"      let rem_ds = List.drop ds state.max_base_jobs in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      if List.length rem_ds > 0 then step_on_free_space state w rem_ds f f_acc","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"      else return state","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"","counters":[]},{"line":"    let do_steps ~state ~data ~f ~f_acc w =","counters":[]},{"line":"      let rec go () =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        match%bind Linear_pipe.read' data with","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"        | `Eof ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            return ()","counters":[]},{"line":"        | `Ok q ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let ds = Queue.to_list q in","counters":[]},{"line":"            let%bind s = step_on_free_space !state w ds f f_acc in","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"            state := s ;","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            go ()","counters":[]},{"line":"      in","counters":[]},{"line":"      go ()","counters":[]},{"line":"","counters":[]},{"line":"    let scan ~data ~depth ~f ~f_acc =","counters":[]},{"line":"      Linear_pipe.create_reader ~close_on_exception:true (fun w ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          let s = ref (empty ~max_base_jobs:(Int.pow 2 depth) ~delay:1) in","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"          do_steps ~state:s ~data ~f w ~f_acc )","counters":[]},{"line":"","counters":[]},{"line":"    let step_repeatedly ~state ~data ~f ~f_acc =","counters":[]},{"line":"      Linear_pipe.create_reader ~close_on_exception:true (fun w ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          do_steps ~state ~data ~f w ~f_acc )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_module \"scan (+) over ints\" =","counters":[]},{"line":"      ( module struct","counters":[]},{"line":"        let f_merge_up (state : (int64 * int64 list) option) x =","counters":[]},{"line":"          let open Option.Let_syntax in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let%map acc = state in","counters":[]},{"line":"          (Int64.( + ) (fst acc) (fst x), snd acc @ snd x)","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"","counters":[]},{"line":"        let job_done (job : (Int64.t, Int64.t) Available_job.t) : Int64.t =","counters":[]},{"line":"          match job with Base x -> x | Merge (x, y) -> Int64.( + ) x y","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"        let%test_unit \"Split only if enqueuing onto the next queue\" =","counters":[]},{"line":"          let p = 4 in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let max_base_jobs = Int.pow 2 p in","counters":[]},{"line":"          let g = Int.gen_incl 0 max_base_jobs in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let state = State.empty ~max_base_jobs ~delay:1 in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          Quickcheck.test g ~trials:1000 ~f:(fun i ->","counters":[]},{"line":"              let data = List.init i ~f:Int64.of_int in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              let partition = partition_if_overflowing state in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              let jobs =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                List.concat","counters":[]},{"line":"                @@ work_for_next_update state ~data_count:(List.length data)","counters":[{"col_start":38,"col_end":38,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"              in","counters":[]},{"line":"              let jobs_done = List.map jobs ~f:job_done in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              let tree_count_before = Non_empty_list.length state.trees in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              let _, state =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                test_update ~data state ~completed_jobs:jobs_done","counters":[]},{"line":"              in","counters":[]},{"line":"              match partition.second with","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              | None ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  let tree_count_after = Non_empty_list.length state.trees in","counters":[]},{"line":"                  let expected_tree_count =","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    if i = fst partition.first then tree_count_before + 1","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"                    else tree_count_before","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                  in","counters":[]},{"line":"                  assert (tree_count_after = expected_tree_count)","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"              | Some _ ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  let tree_count_after = Non_empty_list.length state.trees in","counters":[]},{"line":"                  let expected_tree_count =","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    if i > fst partition.first then tree_count_before + 1","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"                    else tree_count_before","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                  in","counters":[]},{"line":"                  assert (tree_count_after = expected_tree_count) )","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"        let%test_unit \"sequence number reset\" =","counters":[]},{"line":"          (*create jobs with unique sequence numbers starting from 1. At any","counters":[]},{"line":"            point, after reset, the jobs should be labelled starting from 1.","counters":[]},{"line":"          *)","counters":[]},{"line":"          Backtrace.elide := false ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let p = 3 in","counters":[]},{"line":"          let g = Int.gen_incl 0 (Int.pow 2 p) in","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"          let max_base_jobs = Int.pow 2 p in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let jobs state =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            List.fold ~init:[] (Non_empty_list.to_list state.trees)","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"              ~f:(fun acc tree -> Tree.jobs_records tree :: acc)","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"          in","counters":[]},{"line":"          let verify_sequence_number state =","counters":[]},{"line":"            let state = reset_seq_no state in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let jobs_list = jobs state in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let depth = Int.ceil_log2 max_base_jobs + 1 in","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"            List.iteri jobs_list ~f:(fun i jobs ->","counters":[]},{"line":"                (*each tree has jobs up till a level below the older tree*)","counters":[]},{"line":"                (* and have the following sequence numbers after reset","counters":[]},{"line":"                   *         4","counters":[]},{"line":"                   *     3       3","counters":[]},{"line":"                   *   2   2   2   2","counters":[]},{"line":"                   *  1 1 1 1 1 1 1 1","counters":[]},{"line":"                *)","counters":[]},{"line":"                let cur_levels = depth - i in","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                let seq_sum =","counters":[]},{"line":"                  List.fold (List.init cur_levels ~f:Fn.id) ~init:0","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                    ~f:(fun acc j ->","counters":[]},{"line":"                      let j = j + i in","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                      acc + (Int.pow 2 j * (depth - j)) )","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                in","counters":[]},{"line":"                let offset = i in","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                let sum_of_all_seq_numbers =","counters":[]},{"line":"                  List.sum","counters":[]},{"line":"                    (module Int)","counters":[]},{"line":"                    ~f:(fun (job :","counters":[]},{"line":"                              (int64 Merge.Record.t, int64 Base.Record.t) Job.t","counters":[]},{"line":"                              ) ->","counters":[]},{"line":"                      match job with","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                      | Job.Merge { seq_no; _ } ->","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          seq_no - offset","counters":[]},{"line":"                      | Base { seq_no; _ } ->","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          seq_no - offset )","counters":[]},{"line":"                    jobs","counters":[]},{"line":"                in","counters":[]},{"line":"                assert (sum_of_all_seq_numbers = seq_sum) )","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"          in","counters":[]},{"line":"          let state = ref (State.empty ~max_base_jobs ~delay:0) in","counters":[]},{"line":"          let counter = ref 0 in","counters":[]},{"line":"          Quickcheck.test g ~trials:50 ~f:(fun _ ->","counters":[]},{"line":"              let jobs = List.concat (jobs_for_next_update !state) in","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"              let jobs_done = List.map jobs ~f:job_done in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              let data = List.init max_base_jobs ~f:Int64.of_int in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              let res_opt, s =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                test_update ~data !state ~completed_jobs:jobs_done","counters":[]},{"line":"              in","counters":[]},{"line":"              state := s ;","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              if Option.is_some res_opt then","counters":[]},{"line":"                (*start the rest after enough jobs are created*)","counters":[]},{"line":"                if !counter >= p + 1 then verify_sequence_number !state","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"                else counter := !counter + 1","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"              else () )","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"","counters":[]},{"line":"        let%test_unit \"serialize, deserialize scan state\" =","counters":[]},{"line":"          Backtrace.elide := false ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let g =","counters":[]},{"line":"            gen","counters":[]},{"line":"              ~gen_data:","counters":[]},{"line":"                Quickcheck.Generator.Let_syntax.(","counters":[]},{"line":"                  Int.quickcheck_generator >>| Int64.of_int)","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"              ~f_job_done:job_done ~f_acc:f_merge_up","counters":[]},{"line":"          in","counters":[]},{"line":"          Quickcheck.test g ~sexp_of:[%sexp_of: (int64, int64) State.t]","counters":[]},{"line":"            ~trials:50 ~f:(fun s ->","counters":[]},{"line":"              let hash_s = State.hash s Int64.to_string Int64.to_string in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              let sz =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                State.Stable.Latest.bin_size_t Int64.bin_size_t Int64.bin_size_t","counters":[]},{"line":"                  s","counters":[]},{"line":"              in","counters":[]},{"line":"              let buf = Bin_prot.Common.create_buf sz in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              ignore","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ( State.Stable.Latest.bin_write_t Int64.bin_write_t","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"                    Int64.bin_write_t buf ~pos:0 s","counters":[]},{"line":"                  : int ) ;","counters":[]},{"line":"              let deserialized =","counters":[]},{"line":"                State.Stable.Latest.bin_read_t Int64.bin_read_t Int64.bin_read_t","counters":[]},{"line":"                  ~pos_ref:(ref 0) buf","counters":[]},{"line":"              in","counters":[]},{"line":"              let new_hash =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                State.hash deserialized Int64.to_string Int64.to_string","counters":[]},{"line":"              in","counters":[]},{"line":"              assert (Hash.equal hash_s new_hash) )","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"","counters":[]},{"line":"        let%test_unit \"scan can be initialized from intermediate state\" =","counters":[]},{"line":"          Backtrace.elide := false ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let g =","counters":[]},{"line":"            gen","counters":[]},{"line":"              ~gen_data:","counters":[]},{"line":"                Quickcheck.Generator.Let_syntax.(","counters":[]},{"line":"                  Int.quickcheck_generator >>| Int64.of_int)","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"              ~f_job_done:job_done ~f_acc:f_merge_up","counters":[]},{"line":"          in","counters":[]},{"line":"          Quickcheck.test g ~sexp_of:[%sexp_of: (int64, int64) State.t]","counters":[]},{"line":"            ~trials:10 ~f:(fun s ->","counters":[]},{"line":"              let s = ref s in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              Async.Thread_safe.block_on_async_exn (fun () ->","counters":[]},{"line":"                  let do_one_next = ref false in","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  (* For any arbitrary intermediate state *)","counters":[]},{"line":"                  (* if we then add 1 and a bunch of zeros *)","counters":[]},{"line":"                  let one_then_zeros =","counters":[]},{"line":"                    Linear_pipe.create_reader ~close_on_exception:true (fun w ->","counters":[]},{"line":"                        let rec go () =","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          let next =","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                            if !do_one_next then (","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"                              do_one_next := false ;","counters":[]},{"line":"                              Int64.one )","counters":[]},{"line":"                            else Int64.zero","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"                          in","counters":[]},{"line":"                          let%bind () = Pipe.write w next in","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"                          go ()","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                        in","counters":[]},{"line":"                        go () )","counters":[]},{"line":"                  in","counters":[]},{"line":"                  let pipe s =","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    step_repeatedly ~state:s ~data:one_then_zeros ~f:job_done","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      ~f_acc:f_merge_up","counters":[]},{"line":"                  in","counters":[]},{"line":"                  let parallelism =","counters":[]},{"line":"                    !s.max_base_jobs * Int.ceil_log2 !s.max_base_jobs","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                  in","counters":[]},{"line":"                  let fill_some_zeros v s =","counters":[]},{"line":"                    List.init (parallelism * parallelism) ~f:(fun _ -> ())","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"                    |> Deferred.List.fold ~init:v ~f:(fun v _ ->","counters":[]},{"line":"                           match%map Linear_pipe.read (pipe s) with","counters":[{"col_start":52,"col_end":52,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"                           | `Eof ->","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                               v","counters":[]},{"line":"                           | `Ok (Some (v', _)) ->","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                               v'","counters":[]},{"line":"                           | `Ok None ->","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                               v )","counters":[]},{"line":"                  in","counters":[]},{"line":"                  (* after we flush intermediate work *)","counters":[]},{"line":"                  let old_acc =","counters":[]},{"line":"                    !s.acc |> Option.value ~default:Int64.(zero, [])","counters":[]},{"line":"                  in","counters":[]},{"line":"                  let%bind v = fill_some_zeros Int64.zero s in","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"                  do_one_next := true ;","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  let acc = !s.acc |> Option.value_exn in","counters":[]},{"line":"                  assert (not ([%equal: int64] (fst acc) (fst old_acc))) ;","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":50,"col_end":50,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"                  (* eventually we'll emit the acc+1 element *)","counters":[]},{"line":"                  let%map _ = fill_some_zeros v s in","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"                  let acc_plus_one = !s.acc |> Option.value_exn in","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  assert (Int64.(equal (fst acc_plus_one) (fst acc + one))) ) )","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":42,"col_end":42,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"      end )","counters":[]},{"line":"","counters":[]},{"line":"    let%test_module \"scan (+) over ints, map from string\" =","counters":[]},{"line":"      ( module struct","counters":[]},{"line":"        let f_merge_up (tuple : (int64 * string list) option) x =","counters":[]},{"line":"          let open Option.Let_syntax in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let%map acc = tuple in","counters":[]},{"line":"          (Int64.( + ) (fst acc) (fst x), snd acc @ snd x)","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"","counters":[]},{"line":"        let job_done (job : (Int64.t, string) Available_job.t) : Int64.t =","counters":[]},{"line":"          match job with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | Base x ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Int64.of_string x","counters":[]},{"line":"          | Merge (x, y) ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Int64.( + ) x y","counters":[]},{"line":"","counters":[]},{"line":"        let%test_unit \"scan behaves like a fold long-term\" =","counters":[]},{"line":"          let a_bunch_of_ones_then_zeros x =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            { Linear_pipe.Reader.pipe =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"                Pipe.unfold ~init:x ~f:(fun count ->","counters":[]},{"line":"                    let next =","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      if count <= 0 then \"0\" else Int.to_string (x - count)","counters":[{"col_start":41,"col_end":41,"count":0},{"col_start":50,"col_end":50,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"                    in","counters":[]},{"line":"                    return (Some (next, count - 1)) )","counters":[]},{"line":"            ; has_reader = false","counters":[]},{"line":"            }","counters":[]},{"line":"          in","counters":[]},{"line":"          let depth = 7 in","counters":[]},{"line":"          let n = 1000 in","counters":[]},{"line":"          let result =","counters":[]},{"line":"            scan","counters":[]},{"line":"              ~data:(a_bunch_of_ones_then_zeros n)","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"              ~depth ~f:job_done ~f_acc:f_merge_up","counters":[]},{"line":"          in","counters":[]},{"line":"          Async.Thread_safe.block_on_async_exn (fun () ->","counters":[]},{"line":"              let%map after_3n =","counters":[]},{"line":"                List.init (4 * n) ~f:(fun _ -> ())","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"                |> Deferred.List.fold ~init:Int64.zero ~f:(fun acc _ ->","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"                       match%map Linear_pipe.read result with","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"                       | `Eof ->","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                           acc","counters":[]},{"line":"                       | `Ok (Some (v, _)) ->","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                           v","counters":[]},{"line":"                       | `Ok None ->","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                           acc )","counters":[]},{"line":"              in","counters":[]},{"line":"              let expected =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                List.fold","counters":[]},{"line":"                  (List.init n ~f:(fun i -> Int64.of_int i))","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"                  ~init:Int64.zero ~f:Int64.( + )","counters":[]},{"line":"              in","counters":[]},{"line":"              assert ([%equal: int64] after_3n expected) )","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"      end )","counters":[]},{"line":"","counters":[]},{"line":"    let%test_module \"scan (concat) over strings\" =","counters":[]},{"line":"      ( module struct","counters":[]},{"line":"        let f_merge_up (tuple : (string * string list) option) x =","counters":[]},{"line":"          let open Option.Let_syntax in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let%map acc = tuple in","counters":[]},{"line":"          (String.( ^ ) (fst acc) (fst x), snd acc @ snd x)","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":22,"col_end":22,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"","counters":[]},{"line":"        let job_done (job : (string, string) Available_job.t) : string =","counters":[]},{"line":"          match job with Base x -> x | Merge (x, y) -> String.( ^ ) x y","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"        let%test_unit \"scan performs operation in correct order with \\","counters":[]},{"line":"                       non-commutative semigroup\" =","counters":[]},{"line":"          Backtrace.elide := false ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let a_bunch_of_nums_then_empties x =","counters":[]},{"line":"            { Linear_pipe.Reader.pipe =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"                Pipe.unfold ~init:x ~f:(fun count ->","counters":[]},{"line":"                    let next =","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      if count <= 0 then \"\" else Int.to_string (x - count) ^ \",\"","counters":[{"col_start":41,"col_end":41,"count":0},{"col_start":49,"col_end":49,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"                    in","counters":[]},{"line":"                    return (Some (next, count - 1)) )","counters":[]},{"line":"            ; has_reader = false","counters":[]},{"line":"            }","counters":[]},{"line":"          in","counters":[]},{"line":"          let n = 100 in","counters":[]},{"line":"          let result =","counters":[]},{"line":"            scan","counters":[]},{"line":"              ~data:(a_bunch_of_nums_then_empties n)","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"              ~depth:7 ~f:job_done ~f_acc:f_merge_up","counters":[]},{"line":"          in","counters":[]},{"line":"          Async.Thread_safe.block_on_async_exn (fun () ->","counters":[]},{"line":"              let%map after_42n =","counters":[]},{"line":"                List.init (42 * n) ~f:(fun _ -> ())","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"                |> Deferred.List.fold ~init:\"\" ~f:(fun acc _ ->","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"                       match%map Linear_pipe.read result with","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"                       | `Eof ->","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                           acc","counters":[]},{"line":"                       | `Ok (Some (v, _)) ->","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                           v","counters":[]},{"line":"                       | `Ok None ->","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                           acc )","counters":[]},{"line":"              in","counters":[]},{"line":"              let expected =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                List.fold","counters":[]},{"line":"                  (List.init n ~f:(fun i -> Int.to_string i ^ \",\"))","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"                  ~init:\"\" ~f:String.( ^ )","counters":[]},{"line":"              in","counters":[]},{"line":"              assert (String.equal after_42n expected) )","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"      end )","counters":[]},{"line":"  end )","counters":[{"col_start":6,"col_end":6,"count":2}]}]}