{"filename":"src/lib/fake_network/fake_network.ml","lines":[{"line":"open Async","counters":[]},{"line":"open Core","counters":[]},{"line":"open Mina_base","counters":[]},{"line":"module Sync_ledger = Mina_ledger.Sync_ledger","counters":[]},{"line":"open Gadt_lib","counters":[]},{"line":"open Signature_lib","counters":[]},{"line":"open Network_peer","counters":[]},{"line":"module Gossip_net = Mina_networking.Gossip_net","counters":[]},{"line":"","counters":[]},{"line":"module type CONTEXT = sig","counters":[]},{"line":"  val logger : Logger.t","counters":[]},{"line":"","counters":[]},{"line":"  val precomputed_values : Precomputed_values.t","counters":[]},{"line":"","counters":[]},{"line":"  val constraint_constants : Genesis_constants.Constraint_constants.t","counters":[]},{"line":"","counters":[]},{"line":"  val consensus_constants : Consensus.Constants.t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(* There must be at least 2 peers to create a network *)","counters":[]},{"line":"type 'n num_peers = 'n Peano.gt_1","counters":[]},{"line":"","counters":[]},{"line":"(* TODO: make transition frontier a mutable option *)","counters":[]},{"line":"type peer_state =","counters":[]},{"line":"  { frontier : Transition_frontier.t","counters":[]},{"line":"  ; consensus_local_state : Consensus.Data.Local_state.t","counters":[]},{"line":"  ; get_staged_ledger_aux_and_pending_coinbases_at_hash :","counters":[]},{"line":"         Pasta_bindings.Fp.t Envelope.Incoming.t","counters":[]},{"line":"      -> ( Staged_ledger.Scan_state.t","counters":[]},{"line":"         * Pasta_bindings.Fp.t","counters":[]},{"line":"         * Pending_coinbase.t","counters":[]},{"line":"         * Mina_state.Protocol_state.value list )","counters":[]},{"line":"         option","counters":[]},{"line":"         Deferred.t","counters":[]},{"line":"  ; get_some_initial_peers : unit Envelope.Incoming.t -> Peer.t list Deferred.t","counters":[]},{"line":"  ; answer_sync_ledger_query :","counters":[]},{"line":"         (Pasta_bindings.Fp.t * Sync_ledger.Query.t) Envelope.Incoming.t","counters":[]},{"line":"      -> (Sync_ledger.Answer.t, Error.t) result Deferred.t","counters":[]},{"line":"  ; get_ancestry :","counters":[]},{"line":"         ( Consensus.Data.Consensus_state.Value.t","counters":[]},{"line":"         , Pasta_bindings.Fp.t )","counters":[]},{"line":"         With_hash.t","counters":[]},{"line":"         Envelope.Incoming.t","counters":[]},{"line":"      -> ( Mina_block.t","counters":[]},{"line":"         , State_body_hash.t list * Mina_block.t )","counters":[]},{"line":"         Proof_carrying_data.t","counters":[]},{"line":"         option","counters":[]},{"line":"         Deferred.t","counters":[]},{"line":"  ; get_best_tip :","counters":[]},{"line":"         unit Envelope.Incoming.t","counters":[]},{"line":"      -> ( Mina_block.t","counters":[]},{"line":"         , Pasta_bindings.Fp.t list * Mina_block.t )","counters":[]},{"line":"         Proof_carrying_data.t","counters":[]},{"line":"         option","counters":[]},{"line":"         Deferred.t","counters":[]},{"line":"  ; get_node_status :","counters":[]},{"line":"         unit Envelope.Incoming.t","counters":[]},{"line":"      -> (Mina_networking.Rpcs.Get_node_status.Node_status.t, Error.t) result","counters":[]},{"line":"         Deferred.t","counters":[]},{"line":"  ; get_transition_knowledge :","counters":[]},{"line":"      unit Envelope.Incoming.t -> Pasta_bindings.Fp.t list Deferred.t","counters":[]},{"line":"  ; get_transition_chain_proof :","counters":[]},{"line":"         Pasta_bindings.Fp.t Envelope.Incoming.t","counters":[]},{"line":"      -> (Pasta_bindings.Fp.t * Pasta_bindings.Fp.t list) option Deferred.t","counters":[]},{"line":"  ; get_transition_chain :","counters":[]},{"line":"         Pasta_bindings.Fp.t list Envelope.Incoming.t","counters":[]},{"line":"      -> Mina_block.t list option Deferred.t","counters":[]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"type peer_network =","counters":[]},{"line":"  { peer : Network_peer.Peer.t","counters":[]},{"line":"  ; state : peer_state","counters":[]},{"line":"  ; network : Mina_networking.t","counters":[]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"type nonrec 'n t =","counters":[]},{"line":"  { fake_gossip_network : Gossip_net.Fake.network","counters":[]},{"line":"  ; peer_networks : (peer_network, 'n) Vect.t","counters":[]},{"line":"  }","counters":[]},{"line":"  constraint 'n = _ num_peers","counters":[]},{"line":"","counters":[]},{"line":"module Constants = struct","counters":[]},{"line":"  let init_ip = Int32.of_int_exn 1","counters":[{"col_start":31,"col_end":31,"count":1}]},{"line":"","counters":[]},{"line":"  let init_discovery_port = 1337","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let setup (type n) ~context:(module Context : CONTEXT)","counters":[]},{"line":"    ?(time_controller = Block_time.Controller.basic ~logger:Context.logger)","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"    (states : (peer_state, n num_peers) Vect.t) : n num_peers t =","counters":[]},{"line":"  let open Context in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let _, peers =","counters":[]},{"line":"    Vect.fold_map states","counters":[]},{"line":"      ~init:(Constants.init_ip, Constants.init_discovery_port)","counters":[]},{"line":"      ~f:(fun (ip, libp2p_port) _ ->","counters":[]},{"line":"        (* each peer has a distinct IP address, so we lookup frontiers by IP *)","counters":[]},{"line":"        let peer =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Network_peer.Peer.create","counters":[]},{"line":"            (Unix.Inet_addr.inet4_addr_of_int32 ip)","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"            ~libp2p_port","counters":[]},{"line":"            ~peer_id:","counters":[]},{"line":"              (Peer.Id.unsafe_of_string","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"                 (sprintf \"fake peer at port %d\" libp2p_port) )","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"        in","counters":[]},{"line":"        ((Int32.( + ) Int32.one ip, libp2p_port + 1), peer) )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":20,"col_end":20,"count":0}]},{"line":"  in","counters":[]},{"line":"  let fake_gossip_network =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Gossip_net.Fake.create_network (Vect.to_list peers)","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"  in","counters":[]},{"line":"  let config peer consensus_local_state =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    let trust_system = Trust_system.null () in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let open Mina_networking.Config in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    don't_wait_for","counters":[]},{"line":"      (Pipe_lib.Strict_pipe.Reader.iter","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"         (Trust_system.upcall_pipe trust_system)","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"         ~f:(const Deferred.unit) ) ;","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"    { logger","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    ; trust_system","counters":[]},{"line":"    ; time_controller","counters":[]},{"line":"    ; consensus_local_state","counters":[]},{"line":"    ; is_seed = Vect.is_empty peers","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"    ; genesis_ledger_hash =","counters":[]},{"line":"        Mina_ledger.Ledger.merkle_root","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"          (Lazy.force (Precomputed_values.genesis_ledger precomputed_values))","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"    ; constraint_constants = precomputed_values.constraint_constants","counters":[]},{"line":"    ; consensus_constants = precomputed_values.consensus_constants","counters":[]},{"line":"    ; precomputed_values","counters":[]},{"line":"    ; creatable_gossip_net =","counters":[]},{"line":"        Gossip_net.Any.Creatable","counters":[]},{"line":"          ( (module Gossip_net.Fake)","counters":[]},{"line":"          , Gossip_net.Fake.create_instance fake_gossip_network peer )","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"    ; log_gossip_heard =","counters":[]},{"line":"        { snark_pool_diff = true","counters":[]},{"line":"        ; transaction_pool_diff = true","counters":[]},{"line":"        ; new_state = true","counters":[]},{"line":"        }","counters":[]},{"line":"    }","counters":[]},{"line":"  in","counters":[]},{"line":"  let peer_networks =","counters":[]},{"line":"    Vect.map2 peers states ~f:(fun peer state ->","counters":[]},{"line":"        let network =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Thread_safe.block_on_async_exn (fun () ->","counters":[]},{"line":"              (* TODO: merge implementations with mina_lib *)","counters":[]},{"line":"              Mina_networking.create","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (config peer state.consensus_local_state)","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                ~sinks:","counters":[]},{"line":"                  ( Transition_handler.Block_sink.void","counters":[]},{"line":"                  , Network_pool.Transaction_pool.Remote_sink.void","counters":[]},{"line":"                  , Network_pool.Snark_pool.Remote_sink.void )","counters":[]},{"line":"                ~get_staged_ledger_aux_and_pending_coinbases_at_hash:","counters":[]},{"line":"                  state.get_staged_ledger_aux_and_pending_coinbases_at_hash","counters":[]},{"line":"                ~get_some_initial_peers:state.get_some_initial_peers","counters":[]},{"line":"                ~answer_sync_ledger_query:state.answer_sync_ledger_query","counters":[]},{"line":"                ~get_ancestry:state.get_ancestry","counters":[]},{"line":"                ~get_best_tip:state.get_best_tip","counters":[]},{"line":"                ~get_node_status:state.get_node_status","counters":[]},{"line":"                ~get_transition_knowledge:state.get_transition_knowledge","counters":[]},{"line":"                ~get_transition_chain_proof:state.get_transition_chain_proof","counters":[]},{"line":"                ~get_transition_chain:state.get_transition_chain )","counters":[]},{"line":"        in","counters":[]},{"line":"        { peer; state; network } )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"  in","counters":[]},{"line":"  { fake_gossip_network; peer_networks }","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"module Generator = struct","counters":[]},{"line":"  open Quickcheck","counters":[]},{"line":"  open Generator.Let_syntax","counters":[]},{"line":"","counters":[]},{"line":"  type peer_config =","counters":[]},{"line":"       context:(module CONTEXT)","counters":[]},{"line":"    -> verifier:Verifier.t","counters":[]},{"line":"    -> max_frontier_length:int","counters":[]},{"line":"    -> use_super_catchup:bool","counters":[]},{"line":"    -> peer_state Generator.t","counters":[]},{"line":"","counters":[]},{"line":"  let make_peer_state ?get_staged_ledger_aux_and_pending_coinbases_at_hash","counters":[]},{"line":"      ?get_some_initial_peers ?answer_sync_ledger_query ?get_ancestry","counters":[]},{"line":"      ?get_best_tip ?get_node_status ?get_transition_knowledge","counters":[]},{"line":"      ?get_transition_chain_proof ?get_transition_chain ~frontier","counters":[]},{"line":"      ~consensus_local_state ~context:(module Context : CONTEXT) =","counters":[]},{"line":"    let open Context in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    { frontier","counters":[]},{"line":"    ; consensus_local_state","counters":[]},{"line":"    ; get_staged_ledger_aux_and_pending_coinbases_at_hash =","counters":[]},{"line":"        ( match get_staged_ledger_aux_and_pending_coinbases_at_hash with","counters":[]},{"line":"        | Some f ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            f","counters":[]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            fun query_env ->","counters":[]},{"line":"              let input = Envelope.Incoming.data query_env in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              Deferred.return","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (let open Option.Let_syntax in","counters":[]},{"line":"                let%map ( scan_state","counters":[]},{"line":"                        , expected_merkle_root","counters":[]},{"line":"                        , pending_coinbases","counters":[]},{"line":"                        , protocol_states ) =","counters":[]},{"line":"                  Sync_handler","counters":[]},{"line":"                  .get_staged_ledger_aux_and_pending_coinbases_at_hash ~frontier","counters":[{"col_start":69,"col_end":69,"count":0}]},{"line":"                    input","counters":[]},{"line":"                in","counters":[]},{"line":"                let staged_ledger_hash =","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Staged_ledger_hash.of_aux_ledger_and_coinbase_hash","counters":[]},{"line":"                    (Staged_ledger.Scan_state.hash scan_state)","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"                    expected_merkle_root pending_coinbases","counters":[]},{"line":"                in","counters":[]},{"line":"                [%log debug]","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"                  ~metadata:","counters":[]},{"line":"                    [ ( \"staged_ledger_hash\"","counters":[]},{"line":"                      , Staged_ledger_hash.to_yojson staged_ledger_hash )","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                    ]","counters":[]},{"line":"                  \"sending scan state and pending coinbase\" ;","counters":[]},{"line":"                ( scan_state","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                , expected_merkle_root","counters":[]},{"line":"                , pending_coinbases","counters":[]},{"line":"                , protocol_states )) )","counters":[]},{"line":"    ; get_some_initial_peers =","counters":[]},{"line":"        ( match get_some_initial_peers with","counters":[]},{"line":"        | Some f ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            f","counters":[]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            fun _ -> Deferred.return [] )","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"    ; answer_sync_ledger_query =","counters":[]},{"line":"        ( match answer_sync_ledger_query with","counters":[]},{"line":"        | Some f ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            f","counters":[]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            fun query_env ->","counters":[]},{"line":"              let ledger_hash, _ = Envelope.Incoming.data query_env in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              Sync_handler.answer_query ~frontier ledger_hash","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"                (Envelope.Incoming.map ~f:Tuple2.get2 query_env)","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                ~logger:(Logger.create ()) ~trust_system:(Trust_system.null ())","counters":[{"col_start":37,"col_end":37,"count":0},{"col_start":74,"col_end":74,"count":0}]},{"line":"              |> Deferred.map","counters":[]},{"line":"                 (* begin error string prefix so we can pattern-match *)","counters":[]},{"line":"                   ~f:","counters":[]},{"line":"                     (Result.of_option","counters":[]},{"line":"                        ~error:","counters":[]},{"line":"                          (Error.createf","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"                             !\"%s for ledger_hash: %{sexp:Ledger_hash.t}\"","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                             Mina_networking.refused_answer_query_string","counters":[]},{"line":"                             ledger_hash ) ) )","counters":[]},{"line":"    ; get_ancestry =","counters":[]},{"line":"        ( match get_ancestry with","counters":[]},{"line":"        | Some f ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            f","counters":[]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            fun query_env ->","counters":[]},{"line":"              Deferred.return","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (Sync_handler.Root.prove","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"                   ~context:(module Context)","counters":[]},{"line":"                   ~frontier","counters":[]},{"line":"                   ( Envelope.Incoming.data query_env","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"                   |> With_hash.map_hash ~f:(fun state_hash ->","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"                          { State_hash.State_hashes.state_hash","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                          ; state_body_hash = None","counters":[]},{"line":"                          } ) ) ) )","counters":[]},{"line":"    ; get_best_tip =","counters":[]},{"line":"        ( match get_best_tip with","counters":[]},{"line":"        | Some f ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            f","counters":[]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            fun _ -> failwith \"Get_best_tip unimplemented\" )","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"    ; get_node_status =","counters":[]},{"line":"        ( match get_node_status with","counters":[]},{"line":"        | Some f ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            f","counters":[]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            fun _ -> failwith \"Get_node_status unimplemented\" )","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"    ; get_transition_knowledge =","counters":[]},{"line":"        ( match get_transition_knowledge with","counters":[]},{"line":"        | Some f ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            f","counters":[]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            fun _query -> Deferred.return (Sync_handler.best_tip_path ~frontier)","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"        )","counters":[]},{"line":"    ; get_transition_chain_proof =","counters":[]},{"line":"        ( match get_transition_chain_proof with","counters":[]},{"line":"        | Some f ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            f","counters":[]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            fun query_env ->","counters":[]},{"line":"              Deferred.return","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (Transition_chain_prover.prove ~frontier","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"                   (Envelope.Incoming.data query_env) ) )","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"    ; get_transition_chain =","counters":[]},{"line":"        ( match get_transition_chain with","counters":[]},{"line":"        | Some f ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            f","counters":[]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            fun query_env ->","counters":[]},{"line":"              Deferred.return","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (Sync_handler.get_transition_chain ~frontier","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"                   (Envelope.Incoming.data query_env) ) )","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let fresh_peer_custom_rpc ?get_staged_ledger_aux_and_pending_coinbases_at_hash","counters":[]},{"line":"      ?get_some_initial_peers ?answer_sync_ledger_query ?get_ancestry","counters":[]},{"line":"      ?get_best_tip ?get_node_status ?get_transition_knowledge","counters":[]},{"line":"      ?get_transition_chain_proof ?get_transition_chain","counters":[]},{"line":"      ~context:(module Context : CONTEXT) ~verifier ~max_frontier_length","counters":[]},{"line":"      ~use_super_catchup =","counters":[]},{"line":"    let open Context in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let epoch_ledger_location =","counters":[]},{"line":"      Filename.temp_dir_name ^/ \"epoch_ledger\"","counters":[]},{"line":"      ^ (Uuid_unix.create () |> Uuid.to_string)","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"    in","counters":[]},{"line":"    let genesis_ledger = Precomputed_values.genesis_ledger precomputed_values in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let consensus_local_state =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Consensus.Data.Local_state.create Public_key.Compressed.Set.empty","counters":[]},{"line":"        ~context:(module Context)","counters":[]},{"line":"        ~genesis_ledger","counters":[]},{"line":"        ~genesis_epoch_data:precomputed_values.genesis_epoch_data","counters":[]},{"line":"        ~epoch_ledger_location","counters":[]},{"line":"        ~genesis_state_hash:","counters":[]},{"line":"          precomputed_values.protocol_state_with_hashes.hash.state_hash","counters":[]},{"line":"    in","counters":[]},{"line":"    let%map frontier =","counters":[]},{"line":"      Transition_frontier.For_tests.gen ~precomputed_values ~verifier","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"        ~consensus_local_state ~max_length:max_frontier_length ~size:0","counters":[]},{"line":"        ~use_super_catchup ()","counters":[]},{"line":"    in","counters":[]},{"line":"    make_peer_state ~frontier ~consensus_local_state","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ~context:(module Context)","counters":[]},{"line":"      ?get_staged_ledger_aux_and_pending_coinbases_at_hash","counters":[]},{"line":"      ?get_some_initial_peers ?answer_sync_ledger_query ?get_ancestry","counters":[]},{"line":"      ?get_best_tip ?get_node_status ?get_transition_knowledge","counters":[]},{"line":"      ?get_transition_chain_proof ?get_transition_chain","counters":[]},{"line":"","counters":[]},{"line":"  let fresh_peer ~context:(module Context : CONTEXT) ~verifier","counters":[]},{"line":"      ~max_frontier_length ~use_super_catchup =","counters":[]},{"line":"    fresh_peer_custom_rpc","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ?get_staged_ledger_aux_and_pending_coinbases_at_hash:None","counters":[]},{"line":"      ?get_some_initial_peers:None ?answer_sync_ledger_query:None","counters":[]},{"line":"      ?get_ancestry:None ?get_best_tip:None ?get_node_status:None","counters":[]},{"line":"      ?get_transition_knowledge:None ?get_transition_chain_proof:None","counters":[]},{"line":"      ?get_transition_chain:None","counters":[]},{"line":"      ~context:(module Context)","counters":[]},{"line":"      ~verifier ~max_frontier_length ~use_super_catchup","counters":[]},{"line":"","counters":[]},{"line":"  let peer_with_branch_custom_rpc ~frontier_branch_size","counters":[]},{"line":"      ?get_staged_ledger_aux_and_pending_coinbases_at_hash","counters":[]},{"line":"      ?get_some_initial_peers ?answer_sync_ledger_query ?get_ancestry","counters":[]},{"line":"      ?get_best_tip ?get_node_status ?get_transition_knowledge","counters":[]},{"line":"      ?get_transition_chain_proof ?get_transition_chain","counters":[]},{"line":"      ~context:(module Context : CONTEXT) ~verifier ~max_frontier_length","counters":[]},{"line":"      ~use_super_catchup =","counters":[]},{"line":"    let open Context in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let epoch_ledger_location =","counters":[]},{"line":"      Filename.temp_dir_name ^/ \"epoch_ledger\"","counters":[]},{"line":"      ^ (Uuid_unix.create () |> Uuid.to_string)","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"    in","counters":[]},{"line":"    let genesis_ledger = Precomputed_values.genesis_ledger precomputed_values in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let consensus_local_state =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Consensus.Data.Local_state.create Public_key.Compressed.Set.empty","counters":[]},{"line":"        ~context:(module Context)","counters":[]},{"line":"        ~genesis_ledger","counters":[]},{"line":"        ~genesis_epoch_data:precomputed_values.genesis_epoch_data","counters":[]},{"line":"        ~epoch_ledger_location","counters":[]},{"line":"        ~genesis_state_hash:","counters":[]},{"line":"          precomputed_values.protocol_state_with_hashes.hash.state_hash","counters":[]},{"line":"    in","counters":[]},{"line":"    let%map frontier, branch =","counters":[]},{"line":"      Transition_frontier.For_tests.gen_with_branch ~precomputed_values","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"        ~verifier ~use_super_catchup ~max_length:max_frontier_length","counters":[]},{"line":"        ~frontier_size:0 ~branch_size:frontier_branch_size","counters":[]},{"line":"        ~consensus_local_state ()","counters":[]},{"line":"    in","counters":[]},{"line":"    Async.Thread_safe.block_on_async_exn (fun () ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        Deferred.List.iter branch","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ~f:(Transition_frontier.add_breadcrumb_exn frontier) ) ;","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"","counters":[]},{"line":"    make_peer_state ~frontier ~consensus_local_state","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ~context:(module Context)","counters":[]},{"line":"      ?get_staged_ledger_aux_and_pending_coinbases_at_hash","counters":[]},{"line":"      ?get_some_initial_peers ?answer_sync_ledger_query ?get_ancestry","counters":[]},{"line":"      ?get_best_tip ?get_node_status ?get_transition_knowledge","counters":[]},{"line":"      ?get_transition_chain_proof ?get_transition_chain","counters":[]},{"line":"","counters":[]},{"line":"  let peer_with_branch ~frontier_branch_size ~context:(module Context : CONTEXT)","counters":[]},{"line":"      ~verifier ~max_frontier_length ~use_super_catchup =","counters":[]},{"line":"    peer_with_branch_custom_rpc ~frontier_branch_size","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ?get_staged_ledger_aux_and_pending_coinbases_at_hash:None","counters":[]},{"line":"      ?get_some_initial_peers:None ?answer_sync_ledger_query:None","counters":[]},{"line":"      ?get_ancestry:None ?get_best_tip:None ?get_node_status:None","counters":[]},{"line":"      ?get_transition_knowledge:None ?get_transition_chain_proof:None","counters":[]},{"line":"      ?get_transition_chain:None","counters":[]},{"line":"      ~context:(module Context)","counters":[]},{"line":"      ~verifier ~max_frontier_length ~use_super_catchup","counters":[]},{"line":"","counters":[]},{"line":"  let gen ?(logger = Logger.null ()) ~precomputed_values ~verifier","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"      ~max_frontier_length ~use_super_catchup","counters":[]},{"line":"      (configs : (peer_config, 'n num_peers) Gadt_lib.Vect.t) =","counters":[]},{"line":"    (* TODO: Pass in *)","counters":[]},{"line":"    let module Context = struct","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let logger = logger","counters":[]},{"line":"","counters":[]},{"line":"      let precomputed_values = precomputed_values","counters":[]},{"line":"","counters":[]},{"line":"      let constraint_constants =","counters":[]},{"line":"        precomputed_values.Precomputed_values.constraint_constants","counters":[]},{"line":"","counters":[]},{"line":"      let consensus_constants =","counters":[]},{"line":"        precomputed_values.Precomputed_values.consensus_constants","counters":[]},{"line":"    end in","counters":[]},{"line":"    let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"    let%map states =","counters":[]},{"line":"      Vect.Quickcheck_generator.map configs ~f:(fun (config : peer_config) ->","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"          config","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ~context:(module Context)","counters":[]},{"line":"            ~verifier ~max_frontier_length ~use_super_catchup )","counters":[]},{"line":"    in","counters":[]},{"line":"    setup ~context:(module Context) states","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}