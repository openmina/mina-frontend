{"filename":"src/lib/mina_base/account_id.ml","lines":[{"line":"[%%import \"/src/config.mlh\"]","counters":[]},{"line":"","counters":[{"col_start":0,"col_end":0,"count":1}]},{"line":"open Core_kernel","counters":[]},{"line":"open Mina_base_import","counters":[]},{"line":"","counters":[]},{"line":"(** See documentation of the {!Mina_wire_types} library *)","counters":[]},{"line":"module Wire_types = Mina_wire_types.Mina_base.Account_id","counters":[]},{"line":"","counters":[]},{"line":"module Make_sig (A : Wire_types.Types.S) = struct","counters":[]},{"line":"  module type S =","counters":[]},{"line":"    Account_id_intf.S","counters":[]},{"line":"      with type Digest.Stable.V1.t = A.Digest.V1.t","counters":[]},{"line":"       and type Stable.V2.t = A.V2.t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make_str (_ : Wire_types.Concrete) = struct","counters":[]},{"line":"  let invalid = (Public_key.Compressed.empty, Pickles.Backend.Tick.Field.zero)","counters":[]},{"line":"","counters":[]},{"line":"  module Digest = struct","counters":[]},{"line":"    [%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"    let of_bigstring_exn =","counters":[]},{"line":"      Binable.of_bigstring (module Pickles.Backend.Tick.Field.Stable.Latest)","counters":[{"col_start":25,"col_end":25,"count":1}]},{"line":"","counters":[]},{"line":"    let to_bigstring =","counters":[]},{"line":"      Binable.to_bigstring (module Pickles.Backend.Tick.Field.Stable.Latest)","counters":[{"col_start":25,"col_end":25,"count":1}]},{"line":"","counters":[]},{"line":"    [%%else]","counters":[]},{"line":"","counters":[]},{"line":"    let of_bigstring_exn =","counters":[]},{"line":"      Binable.of_bigstring (module Snark_params.Tick.Field.Stable.Latest)","counters":[]},{"line":"","counters":[]},{"line":"    let to_bigstring =","counters":[]},{"line":"      Binable.to_bigstring (module Snark_params.Tick.Field.Stable.Latest)","counters":[]},{"line":"","counters":[]},{"line":"    [%%endif]","counters":[]},{"line":"","counters":[]},{"line":"    module Base58_check = Base58_check.Make (struct","counters":[]},{"line":"      let description = \"Token ID\"","counters":[]},{"line":"","counters":[]},{"line":"      let version_byte = Base58_check.Version_bytes.token_id_key","counters":[]},{"line":"    end)","counters":[]},{"line":"","counters":[]},{"line":"    let to_base58_check t : string =","counters":[]},{"line":"      Base58_check.encode (to_bigstring t |> Bigstring.to_string)","counters":[{"col_start":6,"col_end":6,"count":2},{"col_start":38,"col_end":38,"count":2},{"col_start":63,"col_end":63,"count":2}]},{"line":"","counters":[]},{"line":"    let of_base58_check_exn (s : string) =","counters":[]},{"line":"      let decoded = Base58_check.decode_exn s in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      decoded |> Bigstring.of_string |> of_bigstring_exn","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"    let to_string = to_base58_check","counters":[]},{"line":"","counters":[]},{"line":"    let of_string = of_base58_check_exn","counters":[]},{"line":"","counters":[]},{"line":"    let of_field = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"    let to_field_unsafe = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"    [%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type t = Pickles.Backend.Tick.Field.Stable.V1.t","counters":[{"col_start":8,"col_end":8,"count":2},{"col_start":13,"col_end":13,"count":1}]},{"line":"        [@@deriving sexp, equal, compare, hash]","counters":[{"col_start":46,"col_end":46,"count":5}]},{"line":"","counters":[]},{"line":"        let to_yojson (t : t) : Yojson.Safe.t = `String (to_string t)","counters":[{"col_start":48,"col_end":48,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"","counters":[]},{"line":"        let of_yojson (j : Yojson.Safe.t) : (t, string) result =","counters":[]},{"line":"          try Ok (of_string (Yojson.Safe.Util.to_string j))","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"          with e -> Error (Exn.to_string e)","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"        let to_latest = Fn.id","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    [%%else]","counters":[]},{"line":"","counters":[]},{"line":"    [%%versioned","counters":[]},{"line":"    module Stable = struct","counters":[]},{"line":"      module V1 = struct","counters":[]},{"line":"        type t = Snark_params.Tick.Field.Stable.V1.t","counters":[]},{"line":"        [@@deriving sexp, equal, compare, hash]","counters":[]},{"line":"","counters":[]},{"line":"        let to_yojson (t : t) : Yojson.Safe.t = `String (to_string t)","counters":[]},{"line":"","counters":[]},{"line":"        let of_yojson (j : Yojson.Safe.t) : (t, string) result =","counters":[]},{"line":"          try Ok (of_string (Yojson.Safe.Util.to_string j))","counters":[]},{"line":"          with e -> Error (Exn.to_string e)","counters":[]},{"line":"","counters":[]},{"line":"        let to_latest = Fn.id","counters":[]},{"line":"      end","counters":[]},{"line":"    end]","counters":[]},{"line":"","counters":[]},{"line":"    [%%endif]","counters":[]},{"line":"","counters":[]},{"line":"    [%%define_locally Stable.Latest.(of_yojson, to_yojson)]","counters":[]},{"line":"","counters":[]},{"line":"    module Binables = struct","counters":[]},{"line":"      include Comparable.Make_binable (Stable.Latest)","counters":[]},{"line":"      include Hashable.Make_binable (Stable.Latest)","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    include Binables","counters":[]},{"line":"","counters":[]},{"line":"    let to_input : t -> _ Random_oracle_input.Chunked.t =","counters":[]},{"line":"      Random_oracle_input.Chunked.field","counters":[]},{"line":"","counters":[]},{"line":"    (* Just matters that this no one can find a preimage to this with poseidon.","counters":[]},{"line":"       Chose 1 for consistency for the old uint64 based token IDs *)","counters":[]},{"line":"    let default : t = Snark_params.Tick.Field.one","counters":[]},{"line":"","counters":[]},{"line":"    let gen : t Quickcheck.Generator.t = Snark_params.Tick.Field.gen","counters":[]},{"line":"","counters":[]},{"line":"    let gen_non_default =","counters":[]},{"line":"      Quickcheck.Generator.filter gen ~f:(fun x -> not (equal x default))","counters":[{"col_start":32,"col_end":32,"count":1},{"col_start":51,"col_end":51,"count":1},{"col_start":60,"col_end":60,"count":1}]},{"line":"","counters":[]},{"line":"    [%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"    module Checked = struct","counters":[]},{"line":"      open Pickles.Impls.Step","counters":[]},{"line":"","counters":[]},{"line":"      type t = Field.t","counters":[]},{"line":"","counters":[]},{"line":"      let to_input : t -> _ Random_oracle_input.Chunked.t =","counters":[]},{"line":"        Random_oracle_input.Chunked.field","counters":[]},{"line":"","counters":[]},{"line":"      let constant : Stable.Latest.t -> t = Field.constant","counters":[]},{"line":"","counters":[]},{"line":"      let equal : t -> t -> Boolean.var = Field.equal","counters":[]},{"line":"","counters":[]},{"line":"      let if_ = Field.if_","counters":[]},{"line":"","counters":[]},{"line":"      let of_field = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"      let to_field_unsafe = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"      module Assert = struct","counters":[]},{"line":"        let equal : t -> t -> unit = Field.Assert.equal","counters":[]},{"line":"      end","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    let typ = Snark_params.Tick.Field.typ","counters":[]},{"line":"","counters":[]},{"line":"    [%%endif]","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V2 = struct","counters":[]},{"line":"      type t = Public_key.Compressed.Stable.V1.t * Digest.Stable.V1.t","counters":[{"col_start":6,"col_end":6,"count":2},{"col_start":11,"col_end":11,"count":1},{"col_start":15,"col_end":15,"count":0},{"col_start":47,"col_end":47,"count":0},{"col_start":51,"col_end":51,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"      [@@deriving sexp, equal, compare, hash, yojson]","counters":[{"col_start":52,"col_end":52,"count":5}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  let create key tid = (key, tid)","counters":[{"col_start":23,"col_end":23,"count":56}]},{"line":"","counters":[]},{"line":"  let empty : t = (Public_key.Compressed.empty, Digest.default)","counters":[]},{"line":"","counters":[]},{"line":"  let public_key (key, _tid) = key","counters":[{"col_start":31,"col_end":31,"count":19}]},{"line":"","counters":[]},{"line":"  let token_id (_key, id) = id","counters":[{"col_start":28,"col_end":28,"count":19}]},{"line":"","counters":[]},{"line":"  let to_input ((key, tid) : t) =","counters":[]},{"line":"    Random_oracle_input.Chunked.(","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      append (Public_key.Compressed.to_input key) (field tid))","counters":[{"col_start":43,"col_end":43,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"","counters":[]},{"line":"  let derive_token_id ~(owner : t) : Digest.t =","counters":[]},{"line":"    Random_oracle.hash ~init:Hash_prefix.derive_token_id","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (Random_oracle.pack_input (to_input owner))","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"  let gen =","counters":[]},{"line":"    let open Quickcheck.Let_syntax in","counters":[]},{"line":"    let%map key = Public_key.Compressed.gen and tid = Digest.gen in","counters":[]},{"line":"    (key, tid)","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  include Comparable.Make_binable (Stable.Latest)","counters":[]},{"line":"  include Hashable.Make_binable (Stable.Latest)","counters":[]},{"line":"","counters":[]},{"line":"  let to_input ((key, tid) : t) =","counters":[]},{"line":"    Random_oracle.Input.Chunked.append","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (Public_key.Compressed.to_input key)","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"      (Digest.to_input tid)","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"","counters":[]},{"line":"  [%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"  type var = Public_key.Compressed.var * Digest.Checked.t","counters":[]},{"line":"","counters":[]},{"line":"  let typ = Snarky_backendless.Typ.(Public_key.Compressed.typ * Digest.typ)","counters":[]},{"line":"","counters":[]},{"line":"  let var_of_t ((key, tid) : t) =","counters":[]},{"line":"    ( Public_key.Compressed.var_of_t key","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"    , Snark_params.Tick.Field.Var.constant tid )","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"","counters":[]},{"line":"  module Checked = struct","counters":[]},{"line":"    open Snark_params","counters":[]},{"line":"    open Tick","counters":[]},{"line":"","counters":[]},{"line":"    let create key tid = (key, tid)","counters":[{"col_start":25,"col_end":25,"count":1}]},{"line":"","counters":[]},{"line":"    let public_key (key, _tid) = key","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"","counters":[]},{"line":"    let token_id (_key, tid) = tid","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"","counters":[]},{"line":"    let to_input ((key, tid) : var) =","counters":[]},{"line":"      let tid = Digest.Checked.to_input tid in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Random_oracle.Input.Chunked.append","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (Public_key.Compressed.Checked.to_input key)","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"        tid","counters":[]},{"line":"","counters":[]},{"line":"    let derive_token_id ~(owner : var) : Digest.Checked.t =","counters":[]},{"line":"      Random_oracle.Checked.hash ~init:Hash_prefix.derive_token_id","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (Random_oracle.Checked.pack_input (to_input owner))","counters":[{"col_start":40,"col_end":40,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"","counters":[]},{"line":"    let equal (pk1, tid1) (pk2, tid2) =","counters":[]},{"line":"      let%bind pk_equal = Public_key.Compressed.Checked.equal pk1 pk2 in","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"      let%bind tid_equal = Snark_params.Tick.Field.Checked.equal tid1 tid2 in","counters":[{"col_start":63,"col_end":63,"count":0}]},{"line":"      Tick.Boolean.(pk_equal && tid_equal)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"","counters":[]},{"line":"    let if_ b ~then_:(pk_then, tid_then) ~else_:(pk_else, tid_else) =","counters":[]},{"line":"      let%bind pk =","counters":[]},{"line":"        Public_key.Compressed.Checked.if_ b ~then_:pk_then ~else_:pk_else","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"      in","counters":[]},{"line":"      let%map tid =","counters":[]},{"line":"        Snark_params.Tick.Field.Checked.if_ b ~then_:tid_then ~else_:tid_else","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"      in","counters":[]},{"line":"      (pk, tid)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  [%%endif]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"include Wire_types.Make (Make_sig) (Make_str)","counters":[{"col_start":44,"col_end":44,"count":1}]}]}