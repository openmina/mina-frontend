{"filename":"src/lib/network_pool/mocks.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"open Async_kernel","counters":[]},{"line":"open Pipe_lib","counters":[]},{"line":"","counters":[]},{"line":"let trust_system = Trust_system.null ()","counters":[{"col_start":35,"col_end":35,"count":1}]},{"line":"","counters":[]},{"line":"module Transaction_snark_work = Transaction_snark_work","counters":[]},{"line":"module Base_ledger = Mina_ledger.Ledger","counters":[]},{"line":"","counters":[]},{"line":"module Staged_ledger = struct","counters":[]},{"line":"  type t = Base_ledger.t [@@deriving sexp]","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"  let ledger = Fn.id","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Transition_frontier = struct","counters":[]},{"line":"  type table = int Transaction_snark_work.Statement.Table.t [@@deriving sexp]","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"  type diff = Extensions.Snark_pool_refcount.view [@@deriving sexp]","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"  type best_tip_diff = unit","counters":[]},{"line":"","counters":[]},{"line":"  module Breadcrumb = struct","counters":[]},{"line":"    type t = Staged_ledger.t","counters":[]},{"line":"","counters":[]},{"line":"    let staged_ledger = Fn.id","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  type t =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    { refcount_table : table","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"    ; best_tip_table : Transaction_snark_work.Statement.Hash_set.t","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"    ; mutable ledger : Base_ledger.t","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"    ; diff_writer : (diff Broadcast_pipe.Writer.t[@sexp.opaque])","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":16,"col_end":16,"count":0}]},{"line":"    ; diff_reader : (diff Broadcast_pipe.Reader.t[@sexp.opaque])","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":16,"col_end":16,"count":0}]},{"line":"    }","counters":[]},{"line":"  [@@deriving sexp]","counters":[]},{"line":"","counters":[]},{"line":"  let add_statements table stmts =","counters":[]},{"line":"    List.iter stmts ~f:(fun s ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        Transaction_snark_work.Statement.Table.change table s ~f:(function","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Some 1","counters":[]},{"line":"          | Some count ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Some (count + 1) ) )","counters":[]},{"line":"","counters":[]},{"line":"  (*Create tf with some statements referenced to be able to add snark work for those statements to the pool*)","counters":[]},{"line":"  let create _stmts : t =","counters":[]},{"line":"    let refcount_table = Transaction_snark_work.Statement.Table.create () in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let best_tip_table = Transaction_snark_work.Statement.Hash_set.create () in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    (*add_statements table stmts ;*)","counters":[]},{"line":"    let diff_reader, diff_writer =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Broadcast_pipe.create","counters":[]},{"line":"        { Extensions.Snark_pool_refcount.removed = 0","counters":[]},{"line":"        ; refcount_table","counters":[]},{"line":"        ; best_tip_table","counters":[]},{"line":"        }","counters":[]},{"line":"    in","counters":[]},{"line":"    { refcount_table","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    ; best_tip_table","counters":[]},{"line":"    ; ledger = Mina_ledger.Ledger.create_ephemeral ~depth:10 ()","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"    ; diff_writer","counters":[]},{"line":"    ; diff_reader","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let best_tip t = t.ledger","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"","counters":[]},{"line":"  module Extensions = struct","counters":[]},{"line":"    module Work = Transaction_snark_work.Statement","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let snark_pool_refcount_pipe (t : t) : diff Broadcast_pipe.Reader.t =","counters":[]},{"line":"    t.diff_reader","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let best_tip_diff_pipe _ =","counters":[]},{"line":"    let r, _ = Broadcast_pipe.create () in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    r","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  (*Adds statements to the table of referenced work. Snarks for only the referenced statements are added to the pool*)","counters":[]},{"line":"  let refer_statements (t : t) stmts =","counters":[]},{"line":"    let open Deferred.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    add_statements t.refcount_table stmts ;","counters":[]},{"line":"    List.iter ~f:(Hash_set.add t.best_tip_table) stmts ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"    let%bind () =","counters":[]},{"line":"      Broadcast_pipe.Writer.write t.diff_writer","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"        { Transition_frontier.Extensions.Snark_pool_refcount.removed = 0","counters":[]},{"line":"        ; refcount_table = t.refcount_table","counters":[]},{"line":"        ; best_tip_table = t.best_tip_table","counters":[]},{"line":"        }","counters":[]},{"line":"    in","counters":[]},{"line":"    Async.Scheduler.yield_until_no_jobs_remain ()","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let remove_from_best_tip (t : t) stmts =","counters":[]},{"line":"    List.iter ~f:(Hash_set.remove t.best_tip_table) stmts ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"    let%bind () =","counters":[]},{"line":"      Broadcast_pipe.Writer.write t.diff_writer","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"        { Transition_frontier.Extensions.Snark_pool_refcount.removed = 0","counters":[]},{"line":"        ; refcount_table = t.refcount_table","counters":[]},{"line":"        ; best_tip_table = t.best_tip_table","counters":[]},{"line":"        }","counters":[]},{"line":"    in","counters":[]},{"line":"    Async.Scheduler.yield_until_no_jobs_remain ()","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":1}]}]}