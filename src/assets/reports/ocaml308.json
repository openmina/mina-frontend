{"filename":"src/lib/pickles/make_sponge.ml","lines":[{"line":"module D = Composition_types.Digest","counters":[]},{"line":"open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"module Rounds = struct","counters":[]},{"line":"  let rounds_full = 55","counters":[]},{"line":"","counters":[]},{"line":"  let initial_ark = false","counters":[]},{"line":"","counters":[]},{"line":"  let rounds_partial = 0","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let high_entropy_bits = 128","counters":[]},{"line":"","counters":[]},{"line":"module Make (Field : Kimchi_backend.Field.S) = struct","counters":[]},{"line":"  module Inputs = struct","counters":[]},{"line":"    include Rounds","counters":[]},{"line":"    module Field = Field","counters":[]},{"line":"","counters":[]},{"line":"    let alpha = 7","counters":[]},{"line":"","counters":[]},{"line":"    (* x^7 *)","counters":[]},{"line":"    let to_the_alpha x =","counters":[]},{"line":"      (* square |> mul x |> square |> mul x *)","counters":[]},{"line":"      (* 7 = 1 + 2 (1 + 2) *)","counters":[]},{"line":"      let open Field in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let res = square x in","counters":[]},{"line":"      res *= x ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      (* x^3 *)","counters":[]},{"line":"      Mutable.square res ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      (* x^6 *)","counters":[]},{"line":"      res *= x ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      (* x^7 *)","counters":[]},{"line":"      res","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    module Operations = struct","counters":[]},{"line":"      let add_assign ~state i x = Field.(state.(i) += x)","counters":[{"col_start":34,"col_end":34,"count":930}]},{"line":"","counters":[]},{"line":"      let apply_affine_map (matrix, constants) v =","counters":[]},{"line":"        let dotv row =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Array.reduce_exn (Array.map2_exn row v ~f:Field.( * )) ~f:Field.( + )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"        in","counters":[]},{"line":"        let res = Array.map matrix ~f:dotv in","counters":[]},{"line":"        for i = 0 to Array.length res - 1 do","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"          Field.(res.(i) += constants.(i))","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"        done ;","counters":[]},{"line":"        res","counters":[]},{"line":"","counters":[]},{"line":"      let copy a = Array.map a ~f:(fun x -> Field.(x + zero))","counters":[{"col_start":19,"col_end":19,"count":235},{"col_start":44,"col_end":44,"count":705}]},{"line":"    end","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Field = Sponge.Make_sponge (Sponge.Poseidon (Inputs))","counters":[]},{"line":"","counters":[]},{"line":"  module Bits =","counters":[]},{"line":"    Sponge.Bit_sponge.Make","counters":[]},{"line":"      (Bool)","counters":[]},{"line":"      (struct","counters":[]},{"line":"        include Inputs.Field","counters":[]},{"line":"","counters":[]},{"line":"        let high_entropy_bits = high_entropy_bits","counters":[]},{"line":"","counters":[]},{"line":"        let finalize_discarded = ignore","counters":[]},{"line":"      end)","counters":[]},{"line":"      (Inputs.Field)","counters":[]},{"line":"      (Field)","counters":[]},{"line":"","counters":[]},{"line":"  let digest params elts =","counters":[]},{"line":"    let sponge = Bits.create params in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    Array.iter elts ~f:(Bits.absorb sponge) ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"    Bits.squeeze_field sponge |> Inputs.Field.to_bits |> D.Constant.of_bits","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module T (M : Sponge.Intf.T) = M","counters":[]},{"line":"","counters":[]},{"line":"module Test","counters":[]},{"line":"    (Impl : Snarky_backendless.Snark_intf.Run)","counters":[]},{"line":"    (S_constant : Sponge.Intf.Sponge","counters":[]},{"line":"                    with module Field := T(Impl.Field.Constant)","counters":[]},{"line":"                     and module State := Sponge.State","counters":[]},{"line":"                     and type input := Impl.field","counters":[]},{"line":"                     and type digest := Impl.field)","counters":[]},{"line":"    (S_checked : Sponge.Intf.Sponge","counters":[]},{"line":"                   with module Field := Impl.Field","counters":[]},{"line":"                    and module State := Sponge.State","counters":[]},{"line":"                    and type input := Impl.Field.t","counters":[]},{"line":"                    and type digest := Impl.Field.t) =","counters":[]},{"line":"struct","counters":[]},{"line":"  open Impl","counters":[]},{"line":"","counters":[]},{"line":"  let test params : unit =","counters":[]},{"line":"    let n = 10 in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let a = Array.init n ~f:(fun _ -> Field.Constant.random ()) in","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"    Impl.Internal_Basic.Test.test_equal ~sexp_of_t:Field.Constant.sexp_of_t","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ~equal:Field.Constant.equal","counters":[]},{"line":"      (Typ.array ~length:n Field.typ)","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"      Field.typ","counters":[]},{"line":"      (fun a ->","counters":[]},{"line":"        make_checked (fun () ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            let s =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              S_checked.create (Sponge.Params.map ~f:Field.constant params)","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"            in","counters":[]},{"line":"            Array.iter a ~f:(S_checked.absorb s) ;","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"            S_checked.squeeze s ) )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"      (fun a ->","counters":[]},{"line":"        let s = S_constant.create params in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Array.iter a ~f:(S_constant.absorb s) ;","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"        S_constant.squeeze s )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      a","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}