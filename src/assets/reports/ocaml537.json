{"filename":"src/lib/staged_ledger/staged_ledger.ml","lines":[{"line":"[%%import \"/src/config.mlh\"]","counters":[]},{"line":"","counters":[]},{"line":"(* Only show stdout for failed inline tests. *)","counters":[{"col_start":47,"col_end":47,"count":1}]},{"line":"open Inline_test_quiet_logs","counters":[]},{"line":"open Core_kernel","counters":[]},{"line":"open Async","counters":[]},{"line":"open Mina_base","counters":[]},{"line":"open Mina_transaction","counters":[]},{"line":"open Currency","counters":[]},{"line":"open Signature_lib","counters":[]},{"line":"module Ledger = Mina_ledger.Ledger","counters":[]},{"line":"module Sparse_ledger = Mina_ledger.Sparse_ledger","counters":[]},{"line":"","counters":[]},{"line":"let option lab =","counters":[]},{"line":"  Option.value_map ~default:(Or_error.error_string lab) ~f:(fun x -> Ok x)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":49,"col_end":49,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"","counters":[]},{"line":"let yield_result () = Deferred.map (Scheduler.yield ()) ~f:Result.return","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"","counters":[]},{"line":"module T = struct","counters":[]},{"line":"  module Scan_state = Transaction_snark_scan_state","counters":[]},{"line":"  module Pre_diff_info = Pre_diff_info","counters":[]},{"line":"","counters":[]},{"line":"  module Staged_ledger_error = struct","counters":[]},{"line":"    type t =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      | Non_zero_fee_excess of","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          Scan_state.Space_partition.t * Transaction.t With_status.t list","counters":[]},{"line":"      | Invalid_proofs of","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          ( Ledger_proof.t","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          * Transaction_snark.Statement.t","counters":[]},{"line":"          * Mina_base.Sok_message.t )","counters":[]},{"line":"          list","counters":[]},{"line":"      | Couldn't_reach_verifier of Error.t","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Pre_diff of Pre_diff_info.Error.t","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Insufficient_work of string","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Mismatched_statuses of","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          Transaction.t With_status.t * Transaction_status.t","counters":[]},{"line":"      | Invalid_public_key of Public_key.Compressed.t","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Unexpected of Error.t","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    [@@deriving sexp]","counters":[]},{"line":"","counters":[]},{"line":"    let to_string = function","counters":[]},{"line":"      | Couldn't_reach_verifier e ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Format.asprintf","counters":[]},{"line":"            !\"The verifier could not be reached: %{sexp:Error.t}\"","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"            e","counters":[]},{"line":"      | Non_zero_fee_excess (partition, txns) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Format.asprintf","counters":[]},{"line":"            !\"Fee excess is non-zero for the transactions: %{sexp: \\","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"              Transaction.t With_status.t list} and the current queue with \\","counters":[]},{"line":"              slots partitioned as %{sexp: Scan_state.Space_partition.t} \\n\"","counters":[]},{"line":"            txns partition","counters":[]},{"line":"      | Pre_diff pre_diff_error ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Format.asprintf","counters":[]},{"line":"            !\"Pre_diff_info.Error error: %{sexp:Pre_diff_info.Error.t}\"","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"            pre_diff_error","counters":[]},{"line":"      | Invalid_proofs ts ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Format.asprintf","counters":[]},{"line":"            !\"Verification failed for proofs with (statement, work_id, \\","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"              prover): %{sexp: (Transaction_snark.Statement.t * int * string) \\","counters":[]},{"line":"              list}\\n\"","counters":[]},{"line":"            (List.map ts ~f:(fun (_p, s, m) ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                 ( s","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                 , Transaction_snark.Statement.hash s","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                 , Yojson.Safe.to_string","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"                   @@ Public_key.Compressed.to_yojson m.prover ) ) )","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"      | Insufficient_work str ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          str","counters":[]},{"line":"      | Mismatched_statuses (transaction, status) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Format.asprintf","counters":[]},{"line":"            !\"Got a different status %{sexp: Transaction_status.t} when \\","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"              applying the transaction %{sexp: Transaction.t With_status.t}\"","counters":[]},{"line":"            status transaction","counters":[]},{"line":"      | Invalid_public_key pk ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Format.asprintf","counters":[]},{"line":"            !\"A transaction contained an invalid public key %{sexp: \\","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"              Public_key.Compressed.t}\"","counters":[]},{"line":"            pk","counters":[]},{"line":"      | Unexpected e ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Error.to_string_hum e","counters":[]},{"line":"","counters":[]},{"line":"    let to_error = Fn.compose Error.of_string to_string","counters":[{"col_start":28,"col_end":28,"count":1}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let to_staged_ledger_or_error = function","counters":[]},{"line":"    | Ok a ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Ok a","counters":[]},{"line":"    | Error e ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Error (Staged_ledger_error.Unexpected e)","counters":[]},{"line":"","counters":[]},{"line":"  type job = Scan_state.Available_job.t [@@deriving sexp]","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"  let verify_proofs ~logger ~verifier proofs =","counters":[]},{"line":"    let statements () =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      `List","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (List.map proofs ~f:(fun (_, s, _) ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"             Transaction_snark.Statement.to_yojson s ) )","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"    in","counters":[]},{"line":"    let log_error err_str ~metadata =","counters":[]},{"line":"      [%log warn]","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":16,"col_end":16,"count":0}]},{"line":"        ~metadata:","counters":[]},{"line":"          ( [ (\"statements\", statements ())","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"            ; (\"error\", `String err_str)","counters":[]},{"line":"            ; ( \"sok_messages\"","counters":[]},{"line":"              , `List","counters":[]},{"line":"                  (List.map proofs ~f:(fun (_, _, m) -> Sok_message.to_yojson m))","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"              )","counters":[]},{"line":"            ]","counters":[]},{"line":"          @ metadata )","counters":[]},{"line":"        \"Invalid transaction snark for statement $statement: $error\" ;","counters":[]},{"line":"      Deferred.return (Or_error.error_string err_str)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"    in","counters":[]},{"line":"    if","counters":[]},{"line":"      List.exists proofs ~f:(fun (proof, statement, _msg) ->","counters":[]},{"line":"          not","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (Transaction_snark.Statement.equal","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"               (Ledger_proof.statement proof)","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"               statement ) )","counters":[]},{"line":"    then","counters":[]},{"line":"      log_error \"Statement and proof do not match\"","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ~metadata:","counters":[]},{"line":"          [ ( \"statements_from_proof\"","counters":[]},{"line":"            , `List","counters":[]},{"line":"                (List.map proofs ~f:(fun (p, _, _) ->","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                     Transaction_snark.Statement.to_yojson","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                       (Ledger_proof.statement p) ) ) )","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"          ]","counters":[]},{"line":"    else","counters":[]},{"line":"      let start = Time.now () in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      match%map","counters":[]},{"line":"        Verifier.verify_transaction_snarks verifier","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"          (List.map proofs ~f:(fun (proof, _, msg) -> (proof, msg)))","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"      with","counters":[]},{"line":"      | Ok b ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let time_ms = Time.abs_diff (Time.now ()) start |> Time.Span.to_ms in","counters":[{"col_start":36,"col_end":36,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"          [%log trace]","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"            ~metadata:","counters":[]},{"line":"              [ ( \"work_id\"","counters":[]},{"line":"                , `List","counters":[]},{"line":"                    (List.map proofs ~f:(fun (_, s, _) ->","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                         `Int (Transaction_snark.Statement.hash s) ) ) )","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"              ; (\"time\", `Float time_ms)","counters":[]},{"line":"              ]","counters":[]},{"line":"            \"Verification in apply_diff for work $work_id took $time ms\" ;","counters":[]},{"line":"          Ok b","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"      | Error e ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          [%log fatal]","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"            ~metadata:","counters":[]},{"line":"              [ ( \"statement\"","counters":[]},{"line":"                , `List","counters":[]},{"line":"                    (List.map proofs ~f:(fun (_, s, _) ->","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                         Transaction_snark.Statement.to_yojson s ) ) )","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"              ; (\"error\", Error_json.error_to_yojson e)","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"              ]","counters":[]},{"line":"            \"Verifier error when checking transaction snark for statement \\","counters":[]},{"line":"             $statement: $error\" ;","counters":[]},{"line":"          Error e","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"  let map_opt xs ~f =","counters":[]},{"line":"    with_return (fun { return } ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        Some","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (List.map xs ~f:(fun x ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"               match f x with Some y -> y | None -> return None ) ) )","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"  let verify ~logger ~verifier job_msg_proofs =","counters":[]},{"line":"    let open Deferred.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    match","counters":[]},{"line":"      map_opt job_msg_proofs ~f:(fun (job, msg, proof) ->","counters":[]},{"line":"          Option.map (Scan_state.statement_of_job job) ~f:(fun s ->","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"              (proof, s, msg) ) )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"    with","counters":[]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Deferred.return","counters":[]},{"line":"          ( Or_error.errorf","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"              !\"Error creating statement from job %{sexp:job list}\"","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"              (List.map job_msg_proofs ~f:(fun (j, _, _) -> j))","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"          |> to_staged_ledger_or_error )","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"    | Some proof_statement_msgs -> (","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        match%map verify_proofs ~logger ~verifier proof_statement_msgs with","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"        | Ok true ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Ok ()","counters":[]},{"line":"        | Ok false ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Error (Staged_ledger_error.Invalid_proofs proof_statement_msgs)","counters":[]},{"line":"        | Error e ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Error (Couldn't_reach_verifier e) )","counters":[]},{"line":"","counters":[]},{"line":"  module Statement_scanner = struct","counters":[]},{"line":"    include Scan_state.Make_statement_scanner (struct","counters":[]},{"line":"      type t = unit","counters":[]},{"line":"","counters":[]},{"line":"      let verify ~verifier:() _proofs = Deferred.Or_error.return true","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"    end)","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Statement_scanner_proof_verifier = struct","counters":[]},{"line":"    type t = { logger : Logger.t; verifier : Verifier.t }","counters":[]},{"line":"","counters":[]},{"line":"    let verify ~verifier:{ logger; verifier } ts =","counters":[]},{"line":"      verify_proofs ~logger ~verifier","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (List.map ts ~f:(fun (p, m) -> (p, Ledger_proof.statement p, m)))","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":39,"col_end":39,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Statement_scanner_with_proofs =","counters":[]},{"line":"    Scan_state.Make_statement_scanner (Statement_scanner_proof_verifier)","counters":[]},{"line":"","counters":[]},{"line":"  type t =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    { scan_state : Scan_state.t","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"    ; ledger :","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":11,"col_end":11,"count":0}]},{"line":"        ((* Invariant: this is the ledger after having applied all the","counters":[]},{"line":"            transactions in the above state. *)","counters":[]},{"line":"         Ledger.attached_mask","counters":[]},{"line":"        [@sexp.opaque] )","counters":[]},{"line":"    ; constraint_constants : Genesis_constants.Constraint_constants.t","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"    ; pending_coinbase_collection : Pending_coinbase.t","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"    }","counters":[]},{"line":"  [@@deriving sexp]","counters":[]},{"line":"","counters":[]},{"line":"  let proof_txns_with_state_hashes t =","counters":[]},{"line":"    Scan_state.latest_ledger_proof t.scan_state","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"    |> Option.bind ~f:(Fn.compose Non_empty_list.of_list_opt snd)","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"","counters":[]},{"line":"  let scan_state { scan_state; _ } = scan_state","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"  let all_work_pairs t","counters":[]},{"line":"      ~(get_state : State_hash.t -> Mina_state.Protocol_state.value Or_error.t)","counters":[]},{"line":"      =","counters":[]},{"line":"    Scan_state.all_work_pairs t.scan_state ~get_state","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let all_work_statements_exn t =","counters":[]},{"line":"    Scan_state.all_work_statements_exn t.scan_state","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let pending_coinbase_collection { pending_coinbase_collection; _ } =","counters":[]},{"line":"    pending_coinbase_collection","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let get_target ((proof, _), _) =","counters":[]},{"line":"    let { Transaction_snark.Statement.target; _ } =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Ledger_proof.statement proof","counters":[]},{"line":"    in","counters":[]},{"line":"    target","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let verify_scan_state_after_apply ~constraint_constants","counters":[]},{"line":"      ~pending_coinbase_stack ledger (scan_state : Scan_state.t) =","counters":[]},{"line":"    let error_prefix =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      \"Error verifying the parallel scan state after applying the diff.\"","counters":[]},{"line":"    in","counters":[]},{"line":"    let registers_end : _ Mina_state.Registers.t =","counters":[]},{"line":"      { ledger","counters":[]},{"line":"      ; local_state = Mina_state.Local_state.empty ()","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"      ; pending_coinbase_stack","counters":[]},{"line":"      }","counters":[]},{"line":"    in","counters":[]},{"line":"    let statement_check = `Partial in","counters":[]},{"line":"    let registers_begin =","counters":[]},{"line":"      Option.map ~f:get_target (Scan_state.latest_ledger_proof scan_state)","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"    in","counters":[]},{"line":"    Statement_scanner.check_invariants ~constraint_constants scan_state","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ~statement_check ~verifier:() ~error_prefix ~registers_end","counters":[]},{"line":"      ~registers_begin","counters":[]},{"line":"","counters":[]},{"line":"  let of_scan_state_and_ledger_unchecked ~ledger ~scan_state","counters":[]},{"line":"      ~constraint_constants ~pending_coinbase_collection =","counters":[]},{"line":"    { ledger; scan_state; constraint_constants; pending_coinbase_collection }","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let of_scan_state_and_ledger ~logger","counters":[]},{"line":"      ~(constraint_constants : Genesis_constants.Constraint_constants.t)","counters":[]},{"line":"      ~verifier ~snarked_registers ~ledger ~scan_state","counters":[]},{"line":"      ~pending_coinbase_collection ~get_state =","counters":[]},{"line":"    let open Deferred.Or_error.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let t =","counters":[]},{"line":"      of_scan_state_and_ledger_unchecked ~ledger ~scan_state","counters":[]},{"line":"        ~constraint_constants ~pending_coinbase_collection","counters":[]},{"line":"    in","counters":[]},{"line":"    let%bind pending_coinbase_stack =","counters":[]},{"line":"      Pending_coinbase.latest_stack ~is_new_stack:false","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"        pending_coinbase_collection","counters":[]},{"line":"      |> Deferred.return","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"    in","counters":[]},{"line":"    let%bind () =","counters":[]},{"line":"      Statement_scanner_with_proofs.check_invariants ~constraint_constants","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"        scan_state ~statement_check:(`Full get_state)","counters":[]},{"line":"        ~verifier:{ Statement_scanner_proof_verifier.logger; verifier }","counters":[]},{"line":"        ~error_prefix:\"Staged_ledger.of_scan_state_and_ledger\"","counters":[]},{"line":"        ~registers_begin:(Some snarked_registers)","counters":[]},{"line":"        ~registers_end:","counters":[]},{"line":"          { local_state = Mina_state.Local_state.empty ()","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"          ; ledger =","counters":[]},{"line":"              Frozen_ledger_hash.of_ledger_hash (Ledger.merkle_root ledger)","counters":[{"col_start":46,"col_end":46,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"          ; pending_coinbase_stack","counters":[]},{"line":"          }","counters":[]},{"line":"    in","counters":[]},{"line":"    return t","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let of_scan_state_and_ledger_unchecked","counters":[]},{"line":"      ~(constraint_constants : Genesis_constants.Constraint_constants.t)","counters":[]},{"line":"      ~snarked_registers ~ledger ~scan_state ~pending_coinbase_collection =","counters":[]},{"line":"    let open Deferred.Or_error.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let t =","counters":[]},{"line":"      { ledger; scan_state; constraint_constants; pending_coinbase_collection }","counters":[]},{"line":"    in","counters":[]},{"line":"    let%bind pending_coinbase_stack =","counters":[]},{"line":"      Pending_coinbase.latest_stack ~is_new_stack:false","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"        pending_coinbase_collection","counters":[]},{"line":"      |> Deferred.return","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"    in","counters":[]},{"line":"    let%bind () =","counters":[]},{"line":"      Statement_scanner.check_invariants ~constraint_constants scan_state","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"        ~statement_check:`Partial ~verifier:()","counters":[]},{"line":"        ~error_prefix:\"Staged_ledger.of_scan_state_and_ledger\"","counters":[]},{"line":"        ~registers_begin:(Some snarked_registers)","counters":[]},{"line":"        ~registers_end:","counters":[]},{"line":"          { local_state = Mina_state.Local_state.empty ()","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"          ; ledger =","counters":[]},{"line":"              Frozen_ledger_hash.of_ledger_hash (Ledger.merkle_root ledger)","counters":[{"col_start":46,"col_end":46,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"          ; pending_coinbase_stack","counters":[]},{"line":"          }","counters":[]},{"line":"    in","counters":[]},{"line":"    return t","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let of_scan_state_pending_coinbases_and_snarked_ledger' ~constraint_constants","counters":[]},{"line":"      ~pending_coinbases ~scan_state ~snarked_ledger ~snarked_local_state","counters":[]},{"line":"      ~expected_merkle_root ~get_state f =","counters":[]},{"line":"    let open Deferred.Or_error.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let snarked_ledger_hash = Ledger.merkle_root snarked_ledger in","counters":[]},{"line":"    let snarked_frozen_ledger_hash =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Frozen_ledger_hash.of_ledger_hash snarked_ledger_hash","counters":[]},{"line":"    in","counters":[]},{"line":"    let%bind txs_with_protocol_state =","counters":[]},{"line":"      Scan_state.staged_transactions_with_protocol_states scan_state ~get_state","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"      |> Deferred.return","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"    in","counters":[]},{"line":"    let%bind _ =","counters":[]},{"line":"      Deferred.Or_error.List.iter txs_with_protocol_state","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"        ~f:(fun (tx, protocol_state) ->","counters":[]},{"line":"          let%map.Deferred () = Scheduler.yield () in","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"          let%bind.Or_error txn_with_info =","counters":[]},{"line":"            Ledger.apply_transaction ~constraint_constants","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"              ~txn_state_view:","counters":[]},{"line":"                (Mina_state.Protocol_state.Body.view protocol_state.body)","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"              snarked_ledger tx.data","counters":[]},{"line":"          in","counters":[]},{"line":"          let computed_status =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Ledger.Transaction_applied.transaction_status txn_with_info","counters":[]},{"line":"          in","counters":[]},{"line":"          if Transaction_status.equal tx.status computed_status then Ok ()","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"          else","counters":[]},{"line":"            Or_error.errorf","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              !\"Mismatched user command status. Expected: %{sexp: \\","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                Transaction_status.t} Got: %{sexp: Transaction_status.t}\"","counters":[]},{"line":"              tx.status computed_status )","counters":[]},{"line":"    in","counters":[]},{"line":"    let%bind () =","counters":[]},{"line":"      let staged_ledger_hash = Ledger.merkle_root snarked_ledger in","counters":[]},{"line":"      Deferred.return","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":20,"col_end":20,"count":0}]},{"line":"      @@ Result.ok_if_true","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"           (Ledger_hash.equal expected_merkle_root staged_ledger_hash)","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"           ~error:","counters":[]},{"line":"             (Error.createf","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                !\"Mismatching merkle root Expected:%{sexp:Ledger_hash.t} \\","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                  Got:%{sexp:Ledger_hash.t}\"","counters":[]},{"line":"                expected_merkle_root staged_ledger_hash )","counters":[]},{"line":"    in","counters":[]},{"line":"    let pending_coinbase_stack =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      match Scan_state.latest_ledger_proof scan_state with","counters":[]},{"line":"      | Some proof ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (get_target proof).pending_coinbase_stack","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"      | None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Pending_coinbase.Stack.empty","counters":[]},{"line":"    in","counters":[]},{"line":"    f ~constraint_constants","counters":[]},{"line":"      ~snarked_registers:","counters":[]},{"line":"        ( { ledger = snarked_frozen_ledger_hash","counters":[]},{"line":"          ; local_state = snarked_local_state","counters":[]},{"line":"          ; pending_coinbase_stack","counters":[]},{"line":"          }","counters":[]},{"line":"          : Mina_state.Registers.Value.t )","counters":[]},{"line":"      ~ledger:snarked_ledger ~scan_state","counters":[]},{"line":"      ~pending_coinbase_collection:pending_coinbases","counters":[]},{"line":"","counters":[]},{"line":"  let of_scan_state_pending_coinbases_and_snarked_ledger ~logger","counters":[]},{"line":"      ~constraint_constants ~verifier ~scan_state ~snarked_ledger","counters":[]},{"line":"      ~snarked_local_state ~expected_merkle_root ~pending_coinbases ~get_state =","counters":[]},{"line":"    of_scan_state_pending_coinbases_and_snarked_ledger' ~constraint_constants","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ~pending_coinbases ~scan_state ~snarked_ledger ~snarked_local_state","counters":[]},{"line":"      ~expected_merkle_root ~get_state","counters":[]},{"line":"      (of_scan_state_and_ledger ~logger ~get_state ~verifier)","counters":[]},{"line":"","counters":[]},{"line":"  let of_scan_state_pending_coinbases_and_snarked_ledger_unchecked","counters":[]},{"line":"      ~constraint_constants ~scan_state ~snarked_ledger ~snarked_local_state","counters":[]},{"line":"      ~expected_merkle_root ~pending_coinbases ~get_state =","counters":[]},{"line":"    of_scan_state_pending_coinbases_and_snarked_ledger' ~constraint_constants","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ~pending_coinbases ~scan_state ~snarked_ledger ~snarked_local_state","counters":[]},{"line":"      ~expected_merkle_root ~get_state of_scan_state_and_ledger_unchecked","counters":[]},{"line":"","counters":[]},{"line":"  let copy","counters":[]},{"line":"      { scan_state; ledger; constraint_constants; pending_coinbase_collection }","counters":[]},{"line":"      =","counters":[]},{"line":"    let new_mask = Ledger.Mask.create ~depth:(Ledger.depth ledger) () in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"    { scan_state","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    ; ledger = Ledger.register_mask ledger new_mask","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"    ; constraint_constants","counters":[]},{"line":"    ; pending_coinbase_collection","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let hash","counters":[]},{"line":"      { scan_state","counters":[]},{"line":"      ; ledger","counters":[]},{"line":"      ; constraint_constants = _","counters":[]},{"line":"      ; pending_coinbase_collection","counters":[]},{"line":"      } : Staged_ledger_hash.t =","counters":[]},{"line":"    Staged_ledger_hash.of_aux_ledger_and_coinbase_hash","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (Scan_state.hash scan_state)","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"      (Ledger.merkle_root ledger)","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"      pending_coinbase_collection","counters":[]},{"line":"","counters":[]},{"line":"  [%%if call_logger]","counters":[]},{"line":"","counters":[]},{"line":"  let hash t =","counters":[]},{"line":"    Mina_debug.Call_logger.record_call \"Staged_ledger.hash\" ;","counters":[]},{"line":"    hash t","counters":[]},{"line":"","counters":[]},{"line":"  [%%endif]","counters":[]},{"line":"","counters":[]},{"line":"  let ledger { ledger; _ } = ledger","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"  let create_exn ~constraint_constants ~ledger : t =","counters":[]},{"line":"    { scan_state = Scan_state.empty ~constraint_constants ()","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"    ; ledger","counters":[]},{"line":"    ; constraint_constants","counters":[]},{"line":"    ; pending_coinbase_collection =","counters":[]},{"line":"        Pending_coinbase.create","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"          ~depth:constraint_constants.pending_coinbase_depth ()","counters":[]},{"line":"        |> Or_error.ok_exn","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let current_ledger_proof t =","counters":[]},{"line":"    Option.map","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (Scan_state.latest_ledger_proof t.scan_state)","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"      ~f:(Fn.compose fst fst)","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"","counters":[]},{"line":"  let replace_ledger_exn t ledger =","counters":[]},{"line":"    [%test_result: Ledger_hash.t]","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"      ~message:\"Cannot replace ledger since merkle_root differs\"","counters":[]},{"line":"      ~expect:(Ledger.merkle_root t.ledger)","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"      (Ledger.merkle_root ledger) ;","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"    { t with ledger }","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let sum_fees xs ~f =","counters":[]},{"line":"    with_return (fun { return } ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        Ok","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (List.fold ~init:Fee.zero xs ~f:(fun acc x ->","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"               match Fee.add acc (f x) with","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"               | None ->","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                   return (Or_error.error_string \"Fee overflow\")","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"               | Some res ->","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                   res ) ) )","counters":[]},{"line":"","counters":[]},{"line":"  let working_stack pending_coinbase_collection ~is_new_stack =","counters":[]},{"line":"    to_staged_ledger_or_error","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (Pending_coinbase.latest_stack pending_coinbase_collection ~is_new_stack)","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"  let push_coinbase current_stack (t : Transaction.t) =","counters":[]},{"line":"    match t with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Coinbase c ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Pending_coinbase.Stack.push_coinbase c current_stack","counters":[]},{"line":"    | _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        current_stack","counters":[]},{"line":"","counters":[]},{"line":"  let push_state current_stack state_body_hash =","counters":[]},{"line":"    Pending_coinbase.Stack.push_state state_body_hash current_stack","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  module Stack_state_with_init_stack = struct","counters":[]},{"line":"    type t =","counters":[]},{"line":"      { pc : Transaction_snark.Pending_coinbase_stack_state.t","counters":[]},{"line":"      ; init_stack : Pending_coinbase.Stack.t","counters":[]},{"line":"      }","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let coinbase_amount ~supercharge_coinbase","counters":[]},{"line":"      ~(constraint_constants : Genesis_constants.Constraint_constants.t) =","counters":[]},{"line":"    if supercharge_coinbase then","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Currency.Amount.scale constraint_constants.coinbase_amount","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        constraint_constants.supercharged_coinbase_factor","counters":[]},{"line":"    else Some constraint_constants.coinbase_amount","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"  let _coinbase_amount_or_error ~supercharge_coinbase","counters":[]},{"line":"      ~(constraint_constants : Genesis_constants.Constraint_constants.t) =","counters":[]},{"line":"    if supercharge_coinbase then","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Option.value_map","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ~default:","counters":[]},{"line":"          (Error","counters":[]},{"line":"             (Pre_diff_info.Error.Coinbase_error","counters":[]},{"line":"                (sprintf","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                   !\"Overflow when calculating coinbase amount: Supercharged \\","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                     coinbase factor (%d) x coinbase amount (%{sexp: \\","counters":[]},{"line":"                     Currency.Amount.t})\"","counters":[]},{"line":"                   constraint_constants.supercharged_coinbase_factor","counters":[]},{"line":"                   constraint_constants.coinbase_amount ) ) )","counters":[]},{"line":"        (coinbase_amount ~supercharge_coinbase ~constraint_constants)","counters":[]},{"line":"        ~f:(fun x -> Ok x)","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"    else Ok constraint_constants.coinbase_amount","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"  let apply_transaction_and_get_statement ~constraint_constants ledger","counters":[]},{"line":"      (pending_coinbase_stack_state : Stack_state_with_init_stack.t) s","counters":[]},{"line":"      txn_state_view =","counters":[]},{"line":"    (* let () = *)","counters":[]},{"line":"    (*   Core.Printf.eprintf \"MY_LOG.APPLY_TRANSACTION_AND_GET_STATEMENT\\n%!\" *)","counters":[]},{"line":"    (* in *)","counters":[]},{"line":"    let open Result.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    (*TODO: check fee_excess as a result of applying the txns matches with this*)","counters":[]},{"line":"    let%bind fee_excess =","counters":[]},{"line":"      Transaction.fee_excess s |> to_staged_ledger_or_error","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"    in","counters":[]},{"line":"    let source_merkle_root =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Ledger.merkle_root ledger |> Frozen_ledger_hash.of_ledger_hash","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"    in","counters":[]},{"line":"    let pending_coinbase_target =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      push_coinbase pending_coinbase_stack_state.pc.target s","counters":[]},{"line":"    in","counters":[]},{"line":"    let new_init_stack =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      push_coinbase pending_coinbase_stack_state.init_stack s","counters":[]},{"line":"    in","counters":[]},{"line":"    let empty_local_state = Mina_state.Local_state.empty () in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let%bind applied_txn =","counters":[]},{"line":"      ( match","counters":[]},{"line":"          Ledger.apply_transaction ~constraint_constants ~txn_state_view ledger","counters":[]},{"line":"            s","counters":[]},{"line":"        with","counters":[]},{"line":"      | Error e ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Or_error.error_string","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"            (sprintf","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"               !\"Error when applying transaction %{sexp: Transaction.t}: %s\"","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"               s (Error.to_string_hum e) )","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"      | res ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          res )","counters":[]},{"line":"      |> to_staged_ledger_or_error","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"    in","counters":[]},{"line":"    let%map supply_increase =","counters":[]},{"line":"      Ledger.Transaction_applied.supply_increase applied_txn","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"      |> to_staged_ledger_or_error","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"    in","counters":[]},{"line":"    (* Core.Printf.eprintf \"MY_LOG.apply_transaction_and_get_statement\\n%!\" ; *)","counters":[]},{"line":"    let target_merkle_root =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Ledger.merkle_root ledger |> Frozen_ledger_hash.of_ledger_hash","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"    in","counters":[]},{"line":"    (* Core.Printf.eprintf \"MY_LOG.apply_transaction_and_get_statement2\\n%!\" ; *)","counters":[]},{"line":"    ( applied_txn","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    , { Transaction_snark.Statement.source =","counters":[]},{"line":"          { ledger = source_merkle_root","counters":[]},{"line":"          ; pending_coinbase_stack = pending_coinbase_stack_state.pc.source","counters":[]},{"line":"          ; local_state = empty_local_state","counters":[]},{"line":"          }","counters":[]},{"line":"      ; target =","counters":[]},{"line":"          { ledger = target_merkle_root","counters":[]},{"line":"          ; pending_coinbase_stack = pending_coinbase_target","counters":[]},{"line":"          ; local_state = empty_local_state","counters":[]},{"line":"          }","counters":[]},{"line":"      ; fee_excess","counters":[]},{"line":"      ; supply_increase","counters":[]},{"line":"      ; sok_digest = ()","counters":[]},{"line":"      }","counters":[]},{"line":"    , { Stack_state_with_init_stack.pc =","counters":[]},{"line":"          { source = pending_coinbase_target; target = pending_coinbase_target }","counters":[]},{"line":"      ; init_stack = new_init_stack","counters":[]},{"line":"      } )","counters":[]},{"line":"","counters":[]},{"line":"  let apply_transaction_and_get_witness ~constraint_constants ledger","counters":[]},{"line":"      pending_coinbase_stack_state s status txn_state_view state_and_body_hash =","counters":[]},{"line":"    (* Core.Printf.eprintf \"MY_LOG.APPLY_TRANSACTION_AND_GET_WITNESS\\n%!\" ; *)","counters":[]},{"line":"    let open Deferred.Result.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let account_ids : Transaction.t -> _ = function","counters":[]},{"line":"      | Fee_transfer t ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Fee_transfer.receivers t","counters":[]},{"line":"      | Command t ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let t = (t :> User_command.t) in","counters":[]},{"line":"          User_command.accounts_referenced t","counters":[]},{"line":"      | Coinbase c ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let ft_receivers =","counters":[]},{"line":"            Option.map ~f:Coinbase.Fee_transfer.receiver c.fee_transfer","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"            |> Option.to_list","counters":[]},{"line":"          in","counters":[]},{"line":"          Account_id.create c.receiver Token_id.default :: ft_receivers","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"    in","counters":[]},{"line":"    (* Core.Printf.eprintf \"MY_LOG.APPLY_TRANSACTION_AND_GET_WITNESS_111\\n%!\" ; *)","counters":[]},{"line":"    let ledger_witness =","counters":[]},{"line":"      O1trace.sync_thread \"create_ledger_witness\" (fun () ->","counters":[]},{"line":"          Sparse_ledger.of_ledger_subset_exn ledger (account_ids s) )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"    in","counters":[]},{"line":"    (* Core.Printf.eprintf \"MY_LOG.APPLY_TRANSACTION_AND_GET_WITNESS_222\\n%!\" ; *)","counters":[]},{"line":"    let%bind () = yield_result () in","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"    let%bind applied_txn, statement, updated_pending_coinbase_stack_state =","counters":[]},{"line":"      O1trace.sync_thread \"apply_transaction_to_scan_state\" (fun () ->","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"          apply_transaction_and_get_statement ~constraint_constants ledger","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            pending_coinbase_stack_state s txn_state_view )","counters":[]},{"line":"      |> Deferred.return","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"    in","counters":[]},{"line":"    (* Core.Printf.eprintf \"MY_LOG.APPLY_TRANSACTION_AND_GET_STATEMENT.AAA\\n%!\" ; *)","counters":[]},{"line":"    let%bind () = yield_result () in","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"    (* Core.Printf.eprintf \"MY_LOG.APPLY_TRANSACTION_AND_GET_STATEMENT.BBB\\n%!\" ; *)","counters":[]},{"line":"    let%map () =","counters":[]},{"line":"      match status with","counters":[]},{"line":"      | None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (* Core.Printf.eprintf *)","counters":[]},{"line":"          (*   \"MY_LOG.APPLY_TRANSACTION_AND_GET_STATEMENT.NONE\\n%!\" ; *)","counters":[]},{"line":"          return ()","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"      | Some status ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (* Validate that command status matches. *)","counters":[]},{"line":"          let got_status =","counters":[]},{"line":"            Ledger.Transaction_applied.transaction_status applied_txn","counters":[]},{"line":"          in","counters":[]},{"line":"          (* Core.Printf.eprintf *)","counters":[]},{"line":"          (*   \"MY_LOG.APPLY_TRANSACTION_AND_GET_STATEMENT STATUS=%s GOT_STATUS=%s\\n\\ *)","counters":[]},{"line":"          (*    %!\" *)","counters":[]},{"line":"          (*   ( match status with *)","counters":[]},{"line":"          (*   | Transaction_status.Applied -> *)","counters":[]},{"line":"          (*       \"applied\" *)","counters":[]},{"line":"          (*   | Transaction_status.Failed _e -> *)","counters":[]},{"line":"          (*       \"failed\" ) *)","counters":[]},{"line":"          (*   ( match got_status with *)","counters":[]},{"line":"          (*   | Transaction_status.Applied -> *)","counters":[]},{"line":"          (*       \"applied\" *)","counters":[]},{"line":"          (*   | Transaction_status.Failed _ -> *)","counters":[]},{"line":"          (*       \"failed\" ) ; *)","counters":[]},{"line":"          if Transaction_status.equal status got_status then (","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (* Core.Printf.eprintf *)","counters":[]},{"line":"            (*   \"MY_LOG.APPLY_TRANSACTION_AND_GET_STATEMENT.EQUAL\\n%!\" ; *)","counters":[]},{"line":"            return () )","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"          else","counters":[]},{"line":"            Deferred.Result.fail","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"              (Staged_ledger_error.Mismatched_statuses","counters":[]},{"line":"                 ({ With_status.data = s; status }, got_status) )","counters":[]},{"line":"    in","counters":[]},{"line":"    (* Core.Printf.eprintf \"MY_LOG.APPLY_TRANSACTION_AND_GET_STATEMENT.SUCCESS\\n%!\" ; *)","counters":[]},{"line":"    ( { Scan_state.Transaction_with_witness.transaction_with_info = applied_txn","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ; state_hash = state_and_body_hash","counters":[]},{"line":"      ; ledger_witness","counters":[]},{"line":"      ; init_stack = Base pending_coinbase_stack_state.init_stack","counters":[]},{"line":"      ; statement","counters":[]},{"line":"      }","counters":[]},{"line":"    , updated_pending_coinbase_stack_state )","counters":[]},{"line":"","counters":[]},{"line":"  let update_ledger_and_get_statements ~constraint_constants ledger","counters":[]},{"line":"      current_stack ts current_state_view state_and_body_hash =","counters":[]},{"line":"    let open Deferred.Result.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let current_stack_with_state =","counters":[]},{"line":"      push_state current_stack (snd state_and_body_hash)","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"    in","counters":[]},{"line":"    let%map res_rev, pending_coinbase_stack_state =","counters":[]},{"line":"      let pending_coinbase_stack_state : Stack_state_with_init_stack.t =","counters":[]},{"line":"        { pc = { source = current_stack; target = current_stack_with_state }","counters":[]},{"line":"        ; init_stack = current_stack","counters":[]},{"line":"        }","counters":[]},{"line":"      in","counters":[]},{"line":"      let exception Exit of Staged_ledger_error.t in","counters":[]},{"line":"      Async.try_with ~extract_exn:true (fun () ->","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"          Deferred.List.fold ts ~init:([], pending_coinbase_stack_state)","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ~f:(fun (acc, pending_coinbase_stack_state) t ->","counters":[]},{"line":"              let open Deferred.Let_syntax in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              ( match","counters":[]},{"line":"                  List.find (Transaction.public_keys t.With_status.data)","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                    ~f:(fun pk ->","counters":[]},{"line":"                      Option.is_none (Signature_lib.Public_key.decompress pk) )","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":72,"col_end":72,"count":0}]},{"line":"                with","counters":[]},{"line":"              | None ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  ()","counters":[]},{"line":"              | Some pk ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  raise (Exit (Invalid_public_key pk)) ) ;","counters":[]},{"line":"              match%map","counters":[]},{"line":"                apply_transaction_and_get_witness ~constraint_constants ledger","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"                  pending_coinbase_stack_state t.With_status.data","counters":[]},{"line":"                  (Some t.status) current_state_view state_and_body_hash","counters":[]},{"line":"              with","counters":[]},{"line":"              | Ok (res, updated_pending_coinbase_stack_state) ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  (* Core.Printf.eprintf *)","counters":[]},{"line":"                  (*   \"MY_LOG.update_ledger_and_get_statements OK\\n%!\" ; *)","counters":[]},{"line":"                  (res :: acc, updated_pending_coinbase_stack_state)","counters":[]},{"line":"              | Error err ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  (*Core.Printf.eprintf","counters":[]},{"line":"                    \"MY_LOG.update_ledger_and_get_statements ERR=%s\\n%!\"","counters":[]},{"line":"                    (Staged_ledger_error.to_string err) ;*)","counters":[]},{"line":"                  raise (Exit err) ) )","counters":[]},{"line":"      |> Deferred.Result.map_error ~f:(function","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"           | Exit err ->","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"               err","counters":[]},{"line":"           | exn ->","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"               raise exn )","counters":[]},{"line":"    in","counters":[]},{"line":"    (List.rev res_rev, pending_coinbase_stack_state.pc.target)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":12,"col_end":12,"count":0}]},{"line":"","counters":[]},{"line":"  let check_completed_works ~logger ~verifier scan_state","counters":[]},{"line":"      (completed_works : Transaction_snark_work.t list) =","counters":[]},{"line":"    let work_count = List.length completed_works in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let job_pairs =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Scan_state.k_work_pairs_for_new_diff scan_state ~k:work_count","counters":[]},{"line":"    in","counters":[]},{"line":"    let jmps =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      List.concat_map (List.zip_exn job_pairs completed_works)","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"        ~f:(fun (jobs, work) ->","counters":[]},{"line":"          let message = Sok_message.create ~fee:work.fee ~prover:work.prover in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          One_or_two.(","counters":[]},{"line":"            to_list","counters":[]},{"line":"              (map (zip_exn jobs work.proofs) ~f:(fun (job, proof) ->","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"                   (job, message, proof) ) )) )","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"    in","counters":[]},{"line":"    verify jmps ~logger ~verifier","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  (**The total fee excess caused by any diff should be zero. In the case where","counters":[]},{"line":"     the slots are split into two partitions, total fee excess of the transactions","counters":[]},{"line":"     to be enqueued on each of the partitions should be zero respectively *)","counters":[]},{"line":"  let check_zero_fee_excess scan_state data =","counters":[]},{"line":"    let partitions = Scan_state.partition_if_overflowing scan_state in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let txns_from_data data =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      List.fold_right ~init:(Ok []) data","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ~f:(fun (d : Scan_state.Transaction_with_witness.t) acc ->","counters":[]},{"line":"          let open Or_error.Let_syntax in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let%map acc = acc in","counters":[]},{"line":"          let t =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            d.transaction_with_info |> Ledger.Transaction_applied.transaction","counters":[]},{"line":"          in","counters":[]},{"line":"          t :: acc )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    in","counters":[]},{"line":"    let total_fee_excess txns =","counters":[]},{"line":"      List.fold_until txns ~init:Fee_excess.empty ~finish:Or_error.return","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":20,"col_end":20,"count":0}]},{"line":"        ~f:(fun acc (txn : Transaction.t With_status.t) ->","counters":[]},{"line":"          match","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let open Or_error.Let_syntax in","counters":[]},{"line":"            let%bind fee_excess = Transaction.fee_excess txn.data in","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"            Fee_excess.combine acc fee_excess","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          with","counters":[]},{"line":"          | Ok fee_excess ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Continue fee_excess","counters":[]},{"line":"          | Error _ as err ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Stop err )","counters":[]},{"line":"      |> to_staged_ledger_or_error","counters":[]},{"line":"    in","counters":[]},{"line":"    let open Result.Let_syntax in","counters":[]},{"line":"    let check data slots =","counters":[]},{"line":"      let%bind txns = txns_from_data data |> to_staged_ledger_or_error in","counters":[{"col_start":35,"col_end":35,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"      let%bind fee_excess = total_fee_excess txns in","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"      if Fee_excess.is_zero fee_excess then Ok ()","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"      else Error (Non_zero_fee_excess (slots, txns))","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"    in","counters":[]},{"line":"    let%bind () = check (List.take data (fst partitions.first)) partitions in","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"    Option.value_map ~default:(Result.return ())","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"      ~f:(fun _ -> check (List.drop data (fst partitions.first)) partitions)","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"      partitions.second","counters":[]},{"line":"","counters":[]},{"line":"  let update_coinbase_stack_and_get_data ~constraint_constants scan_state ledger","counters":[]},{"line":"      pending_coinbase_collection transactions current_state_view","counters":[]},{"line":"      state_and_body_hash =","counters":[]},{"line":"    let open Deferred.Result.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let coinbase_exists txns =","counters":[]},{"line":"      List.fold_until ~init:false txns","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ~f:(fun acc t ->","counters":[]},{"line":"          match t.With_status.data with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | Transaction.Coinbase _ ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Stop true","counters":[]},{"line":"          | _ ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Continue acc )","counters":[]},{"line":"        ~finish:Fn.id","counters":[]},{"line":"    in","counters":[]},{"line":"    let { Scan_state.Space_partition.first = slots, _; second } =","counters":[]},{"line":"      Scan_state.partition_if_overflowing scan_state","counters":[]},{"line":"    in","counters":[]},{"line":"    if List.length transactions > 0 then","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":17,"col_end":17,"count":0}]},{"line":"      match second with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (*Single partition:","counters":[]},{"line":"            1.Check if a new stack is required and get a working stack [working_stack]","counters":[]},{"line":"            2.create data for enqueuing onto the scan state *)","counters":[]},{"line":"          let is_new_stack = Scan_state.next_on_new_tree scan_state in","counters":[]},{"line":"          let%bind working_stack =","counters":[]},{"line":"            working_stack pending_coinbase_collection ~is_new_stack","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"            |> Deferred.return","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%map data, updated_stack =","counters":[]},{"line":"            update_ledger_and_get_statements ~constraint_constants ledger","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"              working_stack transactions current_state_view state_and_body_hash","counters":[]},{"line":"          in","counters":[]},{"line":"          ( is_new_stack","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          , data","counters":[]},{"line":"          , Pending_coinbase.Update.Action.Update_one","counters":[]},{"line":"          , `Update_one updated_stack )","counters":[]},{"line":"      | Some _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (*Two partition:","counters":[]},{"line":"            Assumption: Only one of the partition will have coinbase transaction(s)in it.","counters":[]},{"line":"            1. Get the latest stack for coinbase in the first set of transactions","counters":[]},{"line":"            2. get the first set of scan_state data[data1]","counters":[]},{"line":"            3. get a new stack for the second partion because the second set of transactions would start from the begining of the next tree in the scan_state","counters":[]},{"line":"            4. Initialize the new stack with the state from the first stack","counters":[]},{"line":"            5. get the second set of scan_state data[data2]*)","counters":[]},{"line":"          let txns_for_partition1 = List.take transactions slots in","counters":[]},{"line":"          let coinbase_in_first_partition =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            coinbase_exists txns_for_partition1","counters":[]},{"line":"          in","counters":[]},{"line":"          let%bind working_stack1 =","counters":[]},{"line":"            working_stack pending_coinbase_collection ~is_new_stack:false","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"            |> Deferred.return","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%bind data1, updated_stack1 =","counters":[]},{"line":"            update_ledger_and_get_statements ~constraint_constants ledger","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"              working_stack1 txns_for_partition1 current_state_view","counters":[]},{"line":"              state_and_body_hash","counters":[]},{"line":"          in","counters":[]},{"line":"          let txns_for_partition2 = List.drop transactions slots in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          (*Push the new state to the state_stack from the previous block even in the second stack*)","counters":[]},{"line":"          let working_stack2 =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Pending_coinbase.Stack.create_with working_stack1","counters":[]},{"line":"          in","counters":[]},{"line":"          let%map data2, updated_stack2 =","counters":[]},{"line":"            update_ledger_and_get_statements ~constraint_constants ledger","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"              working_stack2 txns_for_partition2 current_state_view","counters":[]},{"line":"              state_and_body_hash","counters":[]},{"line":"          in","counters":[]},{"line":"          let second_has_data = List.length txns_for_partition2 > 0 in","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"          let pending_coinbase_action, stack_update =","counters":[]},{"line":"            match (coinbase_in_first_partition, second_has_data) with","counters":[]},{"line":"            | true, true ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ( Pending_coinbase.Update.Action.Update_two_coinbase_in_first","counters":[]},{"line":"                , `Update_two (updated_stack1, updated_stack2) )","counters":[]},{"line":"            (*updated_stack2 does not have coinbase and but has the state from the previous stack*)","counters":[]},{"line":"            | true, false ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (*updated_stack1 has some new coinbase but parition 2 has no","counters":[]},{"line":"                  data and so we have only one stack to update*)","counters":[]},{"line":"                (Update_one, `Update_one updated_stack1)","counters":[]},{"line":"            | false, true ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (*updated_stack1 just has the new state. [updated stack2] might have coinbase, definitely has some","counters":[]},{"line":"                  data and therefore will have a non-dummy state.*)","counters":[]},{"line":"                ( Update_two_coinbase_in_second","counters":[]},{"line":"                , `Update_two (updated_stack1, updated_stack2) )","counters":[]},{"line":"            | false, false ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (* a diff consists of only non-coinbase transactions. This is currently not possible because a diff will have a coinbase at the very least, so don't update anything?*)","counters":[]},{"line":"                (Update_none, `Update_none)","counters":[]},{"line":"          in","counters":[]},{"line":"          (false, data1 @ data2, pending_coinbase_action, stack_update)","counters":[]},{"line":"    else","counters":[]},{"line":"      Deferred.return","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (Ok (false, [], Pending_coinbase.Update.Action.Update_none, `Update_none)","counters":[]},{"line":"        )","counters":[]},{"line":"","counters":[]},{"line":"  (*update the pending_coinbase tree with the updated/new stack and delete the oldest stack if a proof was emitted*)","counters":[]},{"line":"  let update_pending_coinbase_collection ~depth pending_coinbase_collection","counters":[]},{"line":"      stack_update ~is_new_stack ~ledger_proof =","counters":[]},{"line":"    let open Result.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    (*Deleting oldest stack if proof emitted*)","counters":[]},{"line":"    let%bind pending_coinbase_collection_updated1 =","counters":[]},{"line":"      match ledger_proof with","counters":[]},{"line":"      | Some (proof, _) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let%bind oldest_stack, pending_coinbase_collection_updated1 =","counters":[]},{"line":"            Pending_coinbase.remove_coinbase_stack ~depth","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"              pending_coinbase_collection","counters":[]},{"line":"            |> to_staged_ledger_or_error","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"          in","counters":[]},{"line":"          let ledger_proof_stack =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (Ledger_proof.statement proof).target.pending_coinbase_stack","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%map () =","counters":[]},{"line":"            if Pending_coinbase.Stack.equal oldest_stack ledger_proof_stack then","counters":[]},{"line":"              Ok ()","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"            else","counters":[]},{"line":"              Error","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (Staged_ledger_error.Unexpected","counters":[]},{"line":"                   (Error.of_string","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"                      \"Pending coinbase stack of the ledger proof did not \\","counters":[]},{"line":"                       match the oldest stack in the pending coinbase tree.\" )","counters":[]},{"line":"                )","counters":[]},{"line":"          in","counters":[]},{"line":"          pending_coinbase_collection_updated1","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"      | None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Ok pending_coinbase_collection","counters":[]},{"line":"    in","counters":[]},{"line":"    (*updating the latest stack and/or adding a new one*)","counters":[]},{"line":"    match stack_update with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | `Update_none ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Ok pending_coinbase_collection_updated1","counters":[]},{"line":"    | `Update_one stack1 ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Pending_coinbase.update_coinbase_stack ~depth","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"          pending_coinbase_collection_updated1 stack1 ~is_new_stack","counters":[]},{"line":"        |> to_staged_ledger_or_error","counters":[]},{"line":"    | `Update_two (stack1, stack2) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (*The case when some of the transactions go into the old tree and remaining on to the new tree*)","counters":[]},{"line":"        let%bind update1 =","counters":[]},{"line":"          Pending_coinbase.update_coinbase_stack ~depth","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"            pending_coinbase_collection_updated1 stack1 ~is_new_stack:false","counters":[]},{"line":"          |> to_staged_ledger_or_error","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"        in","counters":[]},{"line":"        Pending_coinbase.update_coinbase_stack ~depth update1 stack2","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"          ~is_new_stack:true","counters":[]},{"line":"        |> to_staged_ledger_or_error","counters":[]},{"line":"","counters":[]},{"line":"  let coinbase_for_blockchain_snark = function","counters":[]},{"line":"    | [] ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Ok Currency.Amount.zero","counters":[]},{"line":"    | [ amount ] ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Ok amount","counters":[]},{"line":"    | [ amount1; _ ] ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Ok amount1","counters":[]},{"line":"    | _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Error","counters":[]},{"line":"          (Staged_ledger_error.Pre_diff","counters":[]},{"line":"             (Pre_diff_info.Error.Coinbase_error \"More than two coinbase parts\")","counters":[]},{"line":"          )","counters":[]},{"line":"","counters":[]},{"line":"  let apply_diff ?(skip_verification = false) ~logger ~constraint_constants t","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"      pre_diff_info ~current_state_view ~state_and_body_hash ~log_prefix =","counters":[]},{"line":"    let open Deferred.Result.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let max_throughput =","counters":[]},{"line":"      Int.pow 2 t.constraint_constants.transaction_capacity_log_2","counters":[]},{"line":"    in","counters":[]},{"line":"    let spots_available, proofs_waiting =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let jobs = Scan_state.all_work_statements_exn t.scan_state in","counters":[]},{"line":"      ( Int.min (Scan_state.free_space t.scan_state) max_throughput","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":14,"col_end":14,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"      , List.length jobs )","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"    in","counters":[]},{"line":"    let new_mask = Ledger.Mask.create ~depth:(Ledger.depth t.ledger) () in","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"    let new_ledger = Ledger.register_mask t.ledger new_mask in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let transactions, works, commands_count, coinbases = pre_diff_info in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let%bind is_new_stack, data, stack_update_in_snark, stack_update =","counters":[]},{"line":"      O1trace.thread \"update_coinbase_stack_start_time\" (fun () ->","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"          update_coinbase_stack_and_get_data ~constraint_constants t.scan_state","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            new_ledger t.pending_coinbase_collection transactions","counters":[]},{"line":"            current_state_view state_and_body_hash )","counters":[]},{"line":"    in","counters":[]},{"line":"    let slots = List.length data in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let work_count = List.length works in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let required_pairs = Scan_state.work_statements_for_new_diff t.scan_state in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let%bind () =","counters":[]},{"line":"      O1trace.thread \"check_for_sufficient_snark_work\" (fun () ->","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"          let required = List.length required_pairs in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          if","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            work_count < required","counters":[]},{"line":"            && List.length data","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"               > Scan_state.free_space t.scan_state - required + work_count","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"          then","counters":[]},{"line":"            Deferred.Result.fail","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (Staged_ledger_error.Insufficient_work","counters":[]},{"line":"                 (sprintf","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                    !\"Insufficient number of transaction snark work (slots \\","counters":[]},{"line":"                      occupying: %d)  required %d, got %d\"","counters":[]},{"line":"                    slots required work_count ) )","counters":[]},{"line":"          else Deferred.Result.return () )","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"    in","counters":[]},{"line":"    let%bind () = Deferred.return (check_zero_fee_excess t.scan_state data) in","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"    let%bind res_opt, scan_state' =","counters":[]},{"line":"      O1trace.thread \"fill_work_and_enqueue_transactions\" (fun () ->","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"          let r =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Scan_state.fill_work_and_enqueue_transactions t.scan_state data","counters":[]},{"line":"              works","counters":[]},{"line":"          in","counters":[]},{"line":"          Or_error.iter_error r ~f:(fun e ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              let data_json =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                `List","counters":[]},{"line":"                  (List.map data","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                     ~f:(fun","counters":[]},{"line":"                          { Scan_state.Transaction_with_witness.statement; _ }","counters":[]},{"line":"                        -> Transaction_snark.Statement.to_yojson statement ) )","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"              in","counters":[]},{"line":"              [%log error]","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                ~metadata:","counters":[]},{"line":"                  [ ( \"scan_state\"","counters":[]},{"line":"                    , `String (Scan_state.snark_job_list_json t.scan_state) )","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"                  ; (\"data\", data_json)","counters":[]},{"line":"                  ; (\"error\", Error_json.error_to_yojson e)","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"                  ; (\"prefix\", `String log_prefix)","counters":[]},{"line":"                  ]","counters":[]},{"line":"                !\"$prefix: Unexpected error when applying diff data $data to \\","counters":[]},{"line":"                  the scan_state $scan_state: $error\" ) ;","counters":[]},{"line":"          Deferred.return (to_staged_ledger_or_error r) )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"    in","counters":[]},{"line":"    let%bind () = yield_result () in","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"    let%bind updated_pending_coinbase_collection' =","counters":[]},{"line":"      O1trace.thread \"update_pending_coinbase_collection\" (fun () ->","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"          update_pending_coinbase_collection","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"            ~depth:t.constraint_constants.pending_coinbase_depth","counters":[]},{"line":"            t.pending_coinbase_collection stack_update ~is_new_stack","counters":[]},{"line":"            ~ledger_proof:res_opt","counters":[]},{"line":"          |> Deferred.return )","counters":[]},{"line":"    in","counters":[]},{"line":"    let%bind () = yield_result () in","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"    let%bind coinbase_amount =","counters":[]},{"line":"      Deferred.return (coinbase_for_blockchain_snark coinbases)","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"    in","counters":[]},{"line":"    let%bind latest_pending_coinbase_stack =","counters":[]},{"line":"      Pending_coinbase.latest_stack ~is_new_stack:false","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"        updated_pending_coinbase_collection'","counters":[]},{"line":"      |> to_staged_ledger_or_error |> Deferred.return","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"    in","counters":[]},{"line":"    let%bind () = yield_result () in","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"    let%map () =","counters":[]},{"line":"      if skip_verification then Deferred.return (Ok ())","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"      else","counters":[]},{"line":"        O1trace.thread \"verify_scan_state_after_apply\" (fun () ->","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"            Deferred.(","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              verify_scan_state_after_apply ~constraint_constants","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"                (Frozen_ledger_hash.of_ledger_hash","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"                   (Ledger.merkle_root new_ledger) )","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                ~pending_coinbase_stack:latest_pending_coinbase_stack","counters":[]},{"line":"                scan_state'","counters":[]},{"line":"              >>| to_staged_ledger_or_error) )","counters":[]},{"line":"    in","counters":[]},{"line":"    [%log debug]","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"      ~metadata:","counters":[]},{"line":"        [ (\"user_command_count\", `Int commands_count)","counters":[]},{"line":"        ; (\"coinbase_count\", `Int (List.length coinbases))","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"        ; (\"spots_available\", `Int spots_available)","counters":[]},{"line":"        ; (\"proof_bundles_waiting\", `Int proofs_waiting)","counters":[]},{"line":"        ; (\"work_count\", `Int (List.length works))","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"        ; (\"prefix\", `String log_prefix)","counters":[]},{"line":"        ]","counters":[]},{"line":"      \"$prefix: apply_diff block info: No of transactions \\","counters":[]},{"line":"       included:$user_command_count\\n\\","counters":[]},{"line":"      \\      Coinbase parts:$coinbase_count Spots\\n\\","counters":[]},{"line":"      \\      available:$spots_available Pending work in the \\","counters":[]},{"line":"       scan-state:$proof_bundles_waiting Work included:$work_count\" ;","counters":[]},{"line":"    let new_staged_ledger =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      { scan_state = scan_state'","counters":[]},{"line":"      ; ledger = new_ledger","counters":[]},{"line":"      ; constraint_constants = t.constraint_constants","counters":[]},{"line":"      ; pending_coinbase_collection = updated_pending_coinbase_collection'","counters":[]},{"line":"      }","counters":[]},{"line":"    in","counters":[]},{"line":"    ( `Hash_after_applying (hash new_staged_ledger)","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"    , `Ledger_proof res_opt","counters":[]},{"line":"    , `Staged_ledger new_staged_ledger","counters":[]},{"line":"    , `Pending_coinbase_update","counters":[]},{"line":"        ( is_new_stack","counters":[]},{"line":"        , { Pending_coinbase.Update.Poly.action = stack_update_in_snark","counters":[]},{"line":"          ; coinbase_amount","counters":[]},{"line":"          } ) )","counters":[]},{"line":"","counters":[]},{"line":"  let update_metrics (t : t) (witness : Staged_ledger_diff.t) =","counters":[]},{"line":"    let open Or_error.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let commands = Staged_ledger_diff.commands witness in","counters":[]},{"line":"    let work = Staged_ledger_diff.completed_works witness in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let%bind total_txn_fee =","counters":[]},{"line":"      sum_fees commands ~f:(fun { data = cmd; _ } -> User_command.fee cmd)","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"    in","counters":[]},{"line":"    let%bind total_snark_fee = sum_fees work ~f:Transaction_snark_work.fee in","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"    let%bind () = Scan_state.update_metrics t.scan_state in","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"    Or_error.try_with (fun () ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        let open Mina_metrics in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Gauge.set Scan_state_metrics.snark_fee_per_block","counters":[]},{"line":"          (Int.to_float @@ Fee.to_int total_snark_fee) ;","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"        Gauge.set Scan_state_metrics.transaction_fees_per_block","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (Int.to_float @@ Fee.to_int total_txn_fee) ;","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"        Gauge.set Scan_state_metrics.purchased_snark_work_per_block","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (Float.of_int @@ List.length work) ;","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"        Gauge.set Scan_state_metrics.snark_work_required","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (Float.of_int","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"             (List.length (Scan_state.all_work_statements_exn t.scan_state)) ) )","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"","counters":[]},{"line":"  let forget_prediff_info ((a : Transaction.Valid.t With_status.t list), b, c, d)","counters":[]},{"line":"      =","counters":[]},{"line":"    (List.map ~f:(With_status.map ~f:Transaction.forget) a, b, c, d)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":12,"col_end":12,"count":0}]},{"line":"","counters":[]},{"line":"  let check_commands ledger ~verifier (cs : User_command.t list) =","counters":[]},{"line":"    let cs =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      List.map cs","counters":[]},{"line":"        ~f:","counters":[]},{"line":"          (let open Ledger in","counters":[]},{"line":"          User_command.to_verifiable ~ledger ~get ~location_of_account)","counters":[]},{"line":"    in","counters":[]},{"line":"    let open Deferred.Or_error.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let%map xs = Verifier.verify_commands verifier cs in","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"    Result.all","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (List.map xs ~f:(function","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"        | `Valid x ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Ok x","counters":[]},{"line":"        | ( `Invalid_keys _","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          | `Invalid_signature _","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          | `Invalid_proof","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          | `Missing_verification_key _ ) as invalid ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            Error","counters":[]},{"line":"              (Verifier.Failure.Verification_failed","counters":[]},{"line":"                 (Error.of_string","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                    (sprintf \"verification failed on command, %s\"","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                       (Verifier.invalid_to_string invalid) ) ) )","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"        | `Valid_assuming _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Error","counters":[]},{"line":"              (Verifier.Failure.Verification_failed","counters":[]},{"line":"                 (Error.of_string \"batch verification failed\") ) ) )","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"","counters":[]},{"line":"  let apply ?skip_verification ~constraint_constants t","counters":[]},{"line":"      (witness : Staged_ledger_diff.t) ~logger ~verifier ~current_state_view","counters":[]},{"line":"      ~state_and_body_hash ~coinbase_receiver ~supercharge_coinbase =","counters":[]},{"line":"    let open Deferred.Result.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let work = Staged_ledger_diff.completed_works witness in","counters":[]},{"line":"    let%bind () =","counters":[]},{"line":"      O1trace.thread \"check_completed_works\" (fun () ->","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"          match skip_verification with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | Some `All | Some `Proofs ->","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"              return ()","counters":[]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              check_completed_works ~logger ~verifier t.scan_state work )","counters":[]},{"line":"    in","counters":[]},{"line":"    let%bind prediff =","counters":[]},{"line":"      Pre_diff_info.get witness ~constraint_constants ~coinbase_receiver","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"        ~supercharge_coinbase","counters":[]},{"line":"        ~check:(check_commands t.ledger ~verifier)","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"      |> Deferred.map","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"           ~f:","counters":[]},{"line":"             (Result.map_error ~f:(fun error ->","counters":[]},{"line":"                  Staged_ledger_error.Pre_diff error ) )","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"    in","counters":[]},{"line":"    let apply_diff_start_time = Core.Time.now () in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let%map ((_, _, `Staged_ledger new_staged_ledger, _) as res) =","counters":[]},{"line":"      apply_diff","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"        ~skip_verification:","counters":[]},{"line":"          ([%equal: [ `All | `Proofs ] option] skip_verification (Some `All))","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"        ~constraint_constants t","counters":[]},{"line":"        (forget_prediff_info prediff)","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"        ~logger ~current_state_view ~state_and_body_hash","counters":[]},{"line":"        ~log_prefix:\"apply_diff\"","counters":[]},{"line":"    in","counters":[]},{"line":"    [%log debug]","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"      ~metadata:","counters":[]},{"line":"        [ ( \"time_elapsed\"","counters":[]},{"line":"          , `Float Core.Time.(Span.to_ms @@ diff (now ()) apply_diff_start_time)","counters":[{"col_start":39,"col_end":39,"count":0},{"col_start":47,"col_end":47,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"          )","counters":[]},{"line":"        ]","counters":[]},{"line":"      \"Staged_ledger.apply_diff take $time_elapsed\" ;","counters":[]},{"line":"    let () =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Or_error.iter_error (update_metrics new_staged_ledger witness)","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"        ~f:(fun e ->","counters":[]},{"line":"          [%log error]","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"            ~metadata:[ (\"error\", Error_json.error_to_yojson e) ]","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"            !\"Error updating metrics after applying staged_ledger diff: $error\" )","counters":[]},{"line":"    in","counters":[]},{"line":"    res","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let apply_diff_unchecked ~constraint_constants t","counters":[]},{"line":"      (sl_diff : Staged_ledger_diff.With_valid_signatures_and_proofs.t) ~logger","counters":[]},{"line":"      ~current_state_view ~state_and_body_hash ~coinbase_receiver","counters":[]},{"line":"      ~supercharge_coinbase =","counters":[]},{"line":"    let open Deferred.Result.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let%bind prediff =","counters":[]},{"line":"      Result.map_error ~f:(fun error -> Staged_ledger_error.Pre_diff error)","counters":[{"col_start":40,"col_end":40,"count":0},{"col_start":74,"col_end":74,"count":0}]},{"line":"      @@ Pre_diff_info.get_unchecked ~constraint_constants ~coinbase_receiver","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"           ~supercharge_coinbase sl_diff","counters":[]},{"line":"      |> Deferred.return","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"    in","counters":[]},{"line":"    apply_diff t","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (forget_prediff_info prediff)","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"      ~constraint_constants ~logger ~current_state_view ~state_and_body_hash","counters":[]},{"line":"      ~log_prefix:\"apply_diff_unchecked\"","counters":[]},{"line":"","counters":[]},{"line":"  module Resources = struct","counters":[]},{"line":"    module Discarded = struct","counters":[]},{"line":"      type t =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { commands_rev : User_command.Valid.t With_status.t Sequence.t","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        ; completed_work : Transaction_snark_work.Checked.t Sequence.t","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        }","counters":[]},{"line":"      [@@deriving sexp_of]","counters":[]},{"line":"","counters":[]},{"line":"      let add_user_command t uc =","counters":[]},{"line":"        { t with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          commands_rev = Sequence.append t.commands_rev (Sequence.singleton uc)","counters":[{"col_start":39,"col_end":39,"count":0},{"col_start":74,"col_end":74,"count":0}]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"      let add_completed_work t cw =","counters":[]},{"line":"        { t with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          completed_work =","counters":[]},{"line":"            Sequence.append (Sequence.singleton cw) t.completed_work","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"        }","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    type t =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      { max_space : int (*max space available currently*)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      ; max_jobs : int","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            (*Required amount of work for max_space that can be purchased*)","counters":[]},{"line":"      ; commands_rev : User_command.Valid.t With_status.t Sequence.t","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      ; completed_work_rev : Transaction_snark_work.Checked.t Sequence.t","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      ; fee_transfers : Fee.t Public_key.Compressed.Map.t","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      ; add_coinbase : bool","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      ; coinbase : Coinbase.Fee_transfer.t Staged_ledger_diff.At_most_two.t","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      ; supercharge_coinbase : bool","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      ; receiver_pk : Public_key.Compressed.t","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      ; budget : Fee.t Or_error.t","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      ; discarded : Discarded.t","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      ; is_coinbase_receiver_new : bool","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      ; logger : (Logger.t[@sexp.opaque])","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      }","counters":[]},{"line":"    [@@deriving sexp_of]","counters":[]},{"line":"","counters":[]},{"line":"    let coinbase_ft (cw : Transaction_snark_work.t) =","counters":[]},{"line":"      (* Here we could not add the fee transfer if the prover=receiver_pk but","counters":[]},{"line":"         retaining it to preserve that information in the","counters":[]},{"line":"         staged_ledger_diff. It will be checked in apply_diff before adding*)","counters":[]},{"line":"      Option.some_if","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Fee.(cw.fee > Fee.zero)","counters":[]},{"line":"        (Coinbase.Fee_transfer.create ~receiver_pk:cw.prover ~fee:cw.fee)","counters":[]},{"line":"","counters":[]},{"line":"    let cheapest_two_work (works : Transaction_snark_work.Checked.t Sequence.t)","counters":[]},{"line":"        =","counters":[]},{"line":"      Sequence.fold works ~init:(None, None) ~f:(fun (w1, w2) w ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          match (w1, w2) with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | None, _ ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (Some w, None)","counters":[]},{"line":"          | Some x, None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              if Currency.Fee.compare w.fee x.fee < 0 then (Some w, w1)","counters":[{"col_start":36,"col_end":36,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"              else (w1, Some w)","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"          | Some x, Some y ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              if Currency.Fee.compare w.fee x.fee < 0 then (Some w, w1)","counters":[{"col_start":36,"col_end":36,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"              else if Currency.Fee.compare w.fee y.fee < 0 then (w1, Some w)","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"              else (w1, w2) )","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"","counters":[]},{"line":"    let coinbase_work","counters":[]},{"line":"        ~(constraint_constants : Genesis_constants.Constraint_constants.t)","counters":[]},{"line":"        ?(is_two = false) (works : Transaction_snark_work.Checked.t Sequence.t)","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"        ~is_coinbase_receiver_new ~supercharge_coinbase =","counters":[]},{"line":"      let open Option.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let min1, min2 = cheapest_two_work works in","counters":[]},{"line":"      let diff ws ws' =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Sequence.filter ws ~f:(fun w ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            Sequence.mem ws'","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"              (Transaction_snark_work.statement w)","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"              ~equal:Transaction_snark_work.Statement.equal","counters":[]},{"line":"            |> not )","counters":[]},{"line":"      in","counters":[]},{"line":"      let%bind coinbase_amount =","counters":[]},{"line":"        coinbase_amount ~supercharge_coinbase ~constraint_constants","counters":[]},{"line":"      in","counters":[]},{"line":"      let%bind budget =","counters":[]},{"line":"        (*if the coinbase receiver is new then the account creation fee will be deducted from the reward*)","counters":[]},{"line":"        if is_coinbase_receiver_new then","counters":[]},{"line":"          Currency.Amount.(","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            sub coinbase_amount","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              (of_fee constraint_constants.account_creation_fee))","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"        else Some coinbase_amount","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"      in","counters":[]},{"line":"      let stmt = Transaction_snark_work.statement in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      if is_two then","counters":[]},{"line":"        match (min1, min2) with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | None, _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            None","counters":[]},{"line":"        | Some w, None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            if Amount.(of_fee w.fee <= budget) then","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"              let cb =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Staged_ledger_diff.At_most_two.Two","counters":[]},{"line":"                  (Option.map (coinbase_ft w) ~f:(fun ft -> (ft, None)))","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"              in","counters":[]},{"line":"              Some (cb, diff works (Sequence.of_list [ stmt w ]))","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":51,"col_end":51,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"            else","counters":[]},{"line":"              let cb = Staged_ledger_diff.At_most_two.Two None in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              Some (cb, works)","counters":[]},{"line":"        | Some w1, Some w2 ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let%map sum = Fee.add w1.fee w2.fee in","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"            if Amount.(of_fee sum <= budget) then","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"              let cb =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Staged_ledger_diff.At_most_two.Two","counters":[]},{"line":"                  (Option.map (coinbase_ft w1) ~f:(fun ft ->","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"                       (ft, coinbase_ft w2) ) )","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"                (*Why add work without checking if work constraints are","counters":[]},{"line":"                  satisfied? If we reach here then it means that we are trying to","counters":[]},{"line":"                  fill the last two slots of the tree with coinbase trnasactions","counters":[]},{"line":"                  and if there's any work in [works] then that has to be included,","counters":[]},{"line":"                  either in the coinbase or as fee transfers that gets paid by","counters":[]},{"line":"                  the transaction fees. So having it as coinbase ft will at least","counters":[]},{"line":"                  reduce the slots occupied by fee transfers*)","counters":[]},{"line":"              in","counters":[]},{"line":"              (cb, diff works (Sequence.of_list [ stmt w1; stmt w2 ]))","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":46,"col_end":46,"count":0},{"col_start":53,"col_end":53,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"            else if Amount.(of_fee w1.fee <= coinbase_amount) then","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"              let cb =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Staged_ledger_diff.At_most_two.Two","counters":[]},{"line":"                  (Option.map (coinbase_ft w1) ~f:(fun ft -> (ft, None)))","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"              in","counters":[]},{"line":"              (cb, diff works (Sequence.of_list [ stmt w1 ]))","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":46,"col_end":46,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"            else","counters":[]},{"line":"              let cb = Staged_ledger_diff.At_most_two.Two None in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              (cb, works)","counters":[]},{"line":"      else","counters":[]},{"line":"        Option.map min1 ~f:(fun w ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            if Amount.(of_fee w.fee <= budget) then","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"              let cb = Staged_ledger_diff.At_most_two.One (coinbase_ft w) in","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"              (cb, diff works (Sequence.of_list [ stmt w ]))","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":46,"col_end":46,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"            else","counters":[]},{"line":"              let cb = Staged_ledger_diff.At_most_two.One None in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              (cb, works) )","counters":[]},{"line":"","counters":[]},{"line":"    let init_coinbase_and_fee_transfers ~constraint_constants cw_seq","counters":[]},{"line":"        ~add_coinbase ~job_count ~slots ~is_coinbase_receiver_new","counters":[]},{"line":"        ~supercharge_coinbase =","counters":[]},{"line":"      let cw_unchecked work =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Sequence.map work ~f:Transaction_snark_work.forget","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      in","counters":[]},{"line":"      let coinbase, rem_cw =","counters":[]},{"line":"        match","counters":[]},{"line":"          ( add_coinbase","counters":[]},{"line":"          , coinbase_work ~constraint_constants cw_seq ~is_coinbase_receiver_new","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"              ~supercharge_coinbase )","counters":[]},{"line":"        with","counters":[]},{"line":"        | true, Some (ft, rem_cw) ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (ft, rem_cw)","counters":[]},{"line":"        | true, None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (*Coinbase could not be added because work-fees > coinbase-amount*)","counters":[]},{"line":"            if job_count = 0 || slots - job_count >= 1 then","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"              (*Either no jobs are required or there is a free slot that can be filled without having to include any work*)","counters":[]},{"line":"              (One None, cw_seq)","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"            else (Zero, cw_seq)","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"        | _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (Zero, cw_seq)","counters":[]},{"line":"      in","counters":[]},{"line":"      let rem_cw = cw_unchecked rem_cw in","counters":[]},{"line":"      let singles =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Sequence.filter_map rem_cw","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"          ~f:(fun { Transaction_snark_work.fee; prover; _ } ->","counters":[]},{"line":"            if Fee.equal fee Fee.zero then None else Some (prover, fee) )","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":43,"col_end":43,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"        |> Sequence.to_list_rev","counters":[]},{"line":"      in","counters":[]},{"line":"      (coinbase, singles)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let init ~constraint_constants","counters":[]},{"line":"        (uc_seq : User_command.Valid.t With_status.t Sequence.t)","counters":[]},{"line":"        (cw_seq : Transaction_snark_work.Checked.t Sequence.t)","counters":[]},{"line":"        (slots, job_count) ~receiver_pk ~add_coinbase ~supercharge_coinbase","counters":[]},{"line":"        logger ~is_coinbase_receiver_new =","counters":[]},{"line":"      let seq_rev seq =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let rec go seq rev_seq =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          match Sequence.next seq with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | Some (w, rem_seq) ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              go rem_seq (Sequence.append (Sequence.singleton w) rev_seq)","counters":[{"col_start":40,"col_end":40,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              rev_seq","counters":[]},{"line":"        in","counters":[]},{"line":"        go seq Sequence.empty","counters":[]},{"line":"      in","counters":[]},{"line":"      let coinbase, singles =","counters":[]},{"line":"        init_coinbase_and_fee_transfers ~constraint_constants cw_seq","counters":[]},{"line":"          ~add_coinbase ~job_count ~slots ~is_coinbase_receiver_new","counters":[]},{"line":"          ~supercharge_coinbase","counters":[]},{"line":"      in","counters":[]},{"line":"      let fee_transfers =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Public_key.Compressed.Map.of_alist_reduce singles ~f:(fun f1 f2 ->","counters":[]},{"line":"            Option.value_exn (Fee.add f1 f2) )","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"      in","counters":[]},{"line":"      let budget =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Or_error.map2","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"          (sum_fees (Sequence.to_list uc_seq) ~f:(fun t ->","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"               User_command.fee (User_command.forget_check t.data) ) )","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"          (sum_fees","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"             (List.filter","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                ~f:(fun (k, _) ->","counters":[]},{"line":"                  not (Public_key.Compressed.equal k receiver_pk) )","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"                singles )","counters":[]},{"line":"             ~f:snd )","counters":[]},{"line":"          ~f:(fun r c -> option \"budget did not suffice\" (Fee.sub r c))","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"        |> Or_error.join","counters":[]},{"line":"      in","counters":[]},{"line":"      let discarded =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { Discarded.completed_work = Sequence.empty","counters":[]},{"line":"        ; commands_rev = Sequence.empty","counters":[]},{"line":"        }","counters":[]},{"line":"      in","counters":[]},{"line":"      { max_space = slots","counters":[]},{"line":"      ; max_jobs = job_count","counters":[]},{"line":"      ; commands_rev =","counters":[]},{"line":"          uc_seq","counters":[]},{"line":"          (*Completed work in reverse order for faster removal of proofs if budget doesn't suffice*)","counters":[]},{"line":"      ; completed_work_rev = seq_rev cw_seq","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"      ; fee_transfers","counters":[]},{"line":"      ; add_coinbase","counters":[]},{"line":"      ; supercharge_coinbase","counters":[]},{"line":"      ; receiver_pk","counters":[]},{"line":"      ; coinbase","counters":[]},{"line":"      ; budget","counters":[]},{"line":"      ; discarded","counters":[]},{"line":"      ; is_coinbase_receiver_new","counters":[]},{"line":"      ; logger","counters":[]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    let reselect_coinbase_work ~constraint_constants t =","counters":[]},{"line":"      let cw_unchecked work =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Sequence.map work ~f:Transaction_snark_work.forget","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      in","counters":[]},{"line":"      let coinbase, rem_cw =","counters":[]},{"line":"        match t.coinbase with","counters":[]},{"line":"        | Staged_ledger_diff.At_most_two.Zero ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (t.coinbase, t.completed_work_rev)","counters":[]},{"line":"        | One _ -> (","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            match","counters":[]},{"line":"              coinbase_work ~constraint_constants t.completed_work_rev","counters":[]},{"line":"                ~is_coinbase_receiver_new:t.is_coinbase_receiver_new","counters":[]},{"line":"                ~supercharge_coinbase:t.supercharge_coinbase","counters":[]},{"line":"            with","counters":[]},{"line":"            | None ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (One None, t.completed_work_rev)","counters":[]},{"line":"            | Some (ft, rem_cw) ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (ft, rem_cw) )","counters":[]},{"line":"        | Two _ -> (","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            match","counters":[]},{"line":"              coinbase_work ~constraint_constants t.completed_work_rev","counters":[]},{"line":"                ~is_two:true","counters":[]},{"line":"                ~is_coinbase_receiver_new:t.is_coinbase_receiver_new","counters":[]},{"line":"                ~supercharge_coinbase:t.supercharge_coinbase","counters":[]},{"line":"            with","counters":[]},{"line":"            | None ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (Two None, t.completed_work_rev)","counters":[]},{"line":"                (*Check for work constraint will be done in [check_constraints_and_update]*)","counters":[]},{"line":"            | Some (fts', rem_cw) ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (fts', rem_cw) )","counters":[]},{"line":"      in","counters":[]},{"line":"      let rem_cw = cw_unchecked rem_cw in","counters":[]},{"line":"      let singles =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Sequence.filter_map rem_cw","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"          ~f:(fun { Transaction_snark_work.fee; prover; _ } ->","counters":[]},{"line":"            if Fee.equal fee Fee.zero then None else Some (prover, fee) )","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":43,"col_end":43,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"        |> Sequence.to_list_rev","counters":[]},{"line":"      in","counters":[]},{"line":"      let fee_transfers =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Public_key.Compressed.Map.of_alist_reduce singles ~f:(fun f1 f2 ->","counters":[]},{"line":"            Option.value_exn (Fee.add f1 f2) )","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"      in","counters":[]},{"line":"      { t with coinbase; fee_transfers }","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let rebudget t =","counters":[]},{"line":"      (*get the correct coinbase and calculate the fee transfers*)","counters":[]},{"line":"      let open Or_error.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let payment_fees =","counters":[]},{"line":"        sum_fees (Sequence.to_list t.commands_rev) ~f:(fun t ->","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"            User_command.(fee (forget_check t.data)) )","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"      in","counters":[]},{"line":"      let prover_fee_others =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Public_key.Compressed.Map.fold t.fee_transfers ~init:(Ok Fee.zero)","counters":[]},{"line":"          ~f:(fun ~key ~data fees ->","counters":[]},{"line":"            let%bind others = fees in","counters":[]},{"line":"            if Public_key.Compressed.equal t.receiver_pk key then Ok others","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"            else option \"Fee overflow\" (Fee.add others data) )","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"      in","counters":[]},{"line":"      let revenue = payment_fees in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let cost = prover_fee_others in","counters":[]},{"line":"      Or_error.map2 revenue cost ~f:(fun r c ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"          option \"budget did not suffice\" (Fee.sub r c) )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"      |> Or_error.join","counters":[]},{"line":"","counters":[]},{"line":"    let budget_sufficient t =","counters":[]},{"line":"      match t.budget with Ok _ -> true | Error _ -> false","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"","counters":[]},{"line":"    let coinbase_added t =","counters":[]},{"line":"      match t.coinbase with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Staged_ledger_diff.At_most_two.Zero ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          0","counters":[]},{"line":"      | One _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          1","counters":[]},{"line":"      | Two _ ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          2","counters":[]},{"line":"","counters":[]},{"line":"    let slots_occupied t =","counters":[]},{"line":"      let fee_for_self =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        match t.budget with","counters":[]},{"line":"        | Error _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            0","counters":[]},{"line":"        | Ok b ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            if Fee.(b > Fee.zero) then 1 else 0","counters":[{"col_start":39,"col_end":39,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"      in","counters":[]},{"line":"      let other_provers =","counters":[]},{"line":"        Public_key.Compressed.Map.filter_keys t.fee_transfers","counters":[]},{"line":"          ~f:(Fn.compose not (Public_key.Compressed.equal t.receiver_pk))","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"      in","counters":[]},{"line":"      let total_fee_transfer_pks =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Public_key.Compressed.Map.length other_provers + fee_for_self","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"      in","counters":[]},{"line":"      Sequence.length t.commands_rev","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"      + ((total_fee_transfer_pks + 1) / 2)","counters":[]},{"line":"      + coinbase_added t","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"","counters":[]},{"line":"    let space_available res =","counters":[]},{"line":"      let slots = slots_occupied res in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      res.max_space > slots","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let work_done t =","counters":[]},{"line":"      let no_of_proof_bundles = Sequence.length t.completed_work_rev in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let slots = slots_occupied t in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      (*If more jobs were added in the previous diff then ( t.max_space-t.max_jobs) slots can go for free in this diff*)","counters":[]},{"line":"      no_of_proof_bundles = t.max_jobs || slots <= t.max_space - t.max_jobs","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":74,"col_end":74,"count":0}]},{"line":"","counters":[]},{"line":"    let space_constraint_satisfied t =","counters":[]},{"line":"      let occupied = slots_occupied t in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      occupied <= t.max_space","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let work_constraint_satisfied (t : t) =","counters":[]},{"line":"      (*Are we doing all the work available? *)","counters":[]},{"line":"      let all_proofs = work_done t in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      (*enough work*)","counters":[]},{"line":"      let slots = slots_occupied t in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let cw_count = Sequence.length t.completed_work_rev in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let enough_work = cw_count >= slots in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      (*if there are no transactions then don't need any proofs*)","counters":[]},{"line":"      all_proofs || slots = 0 || enough_work","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"","counters":[]},{"line":"    let available_space t = t.max_space - slots_occupied t","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"","counters":[]},{"line":"    let discard_last_work ~constraint_constants t =","counters":[]},{"line":"      match Sequence.next t.completed_work_rev with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (t, None)","counters":[]},{"line":"      | Some (w, rem_seq) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let to_be_discarded = Transaction_snark_work.forget w in","counters":[]},{"line":"          let discarded = Discarded.add_completed_work t.discarded w in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let new_t =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            reselect_coinbase_work ~constraint_constants","counters":[]},{"line":"              { t with completed_work_rev = rem_seq; discarded }","counters":[]},{"line":"          in","counters":[]},{"line":"          let budget =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            match t.budget with","counters":[]},{"line":"            | Ok b ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                option \"Currency overflow\" (Fee.add b to_be_discarded.fee)","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"            | _ ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                rebudget new_t","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"          in","counters":[]},{"line":"          ({ new_t with budget }, Some w)","counters":[]},{"line":"","counters":[]},{"line":"    let discard_user_command t =","counters":[]},{"line":"      let decr_coinbase t =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (*When discarding coinbase's fee transfer, add the fee transfer to the fee_transfers map so that budget checks can be done *)","counters":[]},{"line":"        let update_fee_transfers t (ft : Coinbase.Fee_transfer.t) coinbase =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let updated_fee_transfers =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Public_key.Compressed.Map.update t.fee_transfers ft.receiver_pk","counters":[]},{"line":"              ~f:(fun _ -> ft.fee)","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"          in","counters":[]},{"line":"          let new_t =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            { t with coinbase; fee_transfers = updated_fee_transfers }","counters":[]},{"line":"          in","counters":[]},{"line":"          let updated_budget = rebudget new_t in","counters":[]},{"line":"          { new_t with budget = updated_budget }","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        in","counters":[]},{"line":"        match t.coinbase with","counters":[]},{"line":"        | Staged_ledger_diff.At_most_two.Zero ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            t","counters":[]},{"line":"        | One None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            { t with coinbase = Staged_ledger_diff.At_most_two.Zero }","counters":[]},{"line":"        | Two None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            { t with coinbase = One None }","counters":[]},{"line":"        | Two (Some (ft, None)) ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            { t with coinbase = One (Some ft) }","counters":[]},{"line":"        | One (Some ft) ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            update_fee_transfers t ft Zero","counters":[]},{"line":"        | Two (Some (ft1, Some ft2)) ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            update_fee_transfers t ft2 (One (Some ft1))","counters":[]},{"line":"      in","counters":[]},{"line":"      match Sequence.next t.commands_rev with","counters":[]},{"line":"      | None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (* If we have reached here then it means we couldn't afford a slot for coinbase as well *)","counters":[]},{"line":"          (decr_coinbase t, None)","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"      | Some (uc, rem_seq) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let discarded = Discarded.add_user_command t.discarded uc in","counters":[]},{"line":"          let new_t = { t with commands_rev = rem_seq; discarded } in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let budget =","counters":[]},{"line":"            match t.budget with","counters":[]},{"line":"            | Ok b ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                option \"Fee insufficient\"","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                  (Fee.sub b User_command.(fee (forget_check uc.data)))","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"            | _ ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                rebudget new_t","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"          in","counters":[]},{"line":"          ({ new_t with budget }, Some uc)","counters":[]},{"line":"","counters":[]},{"line":"    let worked_more ~constraint_constants resources =","counters":[]},{"line":"      (*Is the work constraint satisfied even after discarding a work bundle?","counters":[]},{"line":"         We reach here after having more than enough work*)","counters":[]},{"line":"      let more_work t =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let slots = slots_occupied t in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let cw_count = Sequence.length t.completed_work_rev in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        cw_count > 0 && cw_count >= slots","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"      in","counters":[]},{"line":"      let r, _ = discard_last_work ~constraint_constants resources in","counters":[]},{"line":"      more_work r","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let incr_coinbase_part_by ~constraint_constants t count =","counters":[]},{"line":"      let open Or_error.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let incr = function","counters":[]},{"line":"        | Staged_ledger_diff.At_most_two.Zero ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Ok (Staged_ledger_diff.At_most_two.One None)","counters":[]},{"line":"        | One None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Ok (Two None)","counters":[]},{"line":"        | One (Some ft) ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Ok (Two (Some (ft, None)))","counters":[]},{"line":"        | _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Or_error.error_string \"Coinbase count cannot be more than two\"","counters":[]},{"line":"      in","counters":[]},{"line":"      let by_one res =","counters":[]},{"line":"        let res' =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          match Sequence.next res.discarded.completed_work with","counters":[]},{"line":"          (*add one from the discarded list to [completed_work_rev] and then select a work from [completed_work_rev] except the one already used*)","counters":[]},{"line":"          | Some (w, rem_work) ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let%map coinbase = incr res.coinbase in","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"              let res' =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                { res with","counters":[]},{"line":"                  completed_work_rev =","counters":[]},{"line":"                    Sequence.append (Sequence.singleton w)","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"                      res.completed_work_rev","counters":[]},{"line":"                ; discarded = { res.discarded with completed_work = rem_work }","counters":[]},{"line":"                ; coinbase","counters":[]},{"line":"                }","counters":[]},{"line":"              in","counters":[]},{"line":"              reselect_coinbase_work ~constraint_constants res'","counters":[]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let%bind coinbase = incr res.coinbase in","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"              let res = { res with coinbase } in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              if work_done res then Ok res","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"              else","counters":[]},{"line":"                Or_error.error_string","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  \"Could not increment coinbase transaction count because of \\","counters":[]},{"line":"                   insufficient work\"","counters":[]},{"line":"        in","counters":[]},{"line":"        match res' with","counters":[]},{"line":"        | Ok res'' ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            res''","counters":[]},{"line":"        | Error e ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            [%log' error t.logger] \"Error when increasing coinbase: $error\"","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"              ~metadata:[ (\"error\", Error_json.error_to_yojson e) ] ;","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"            res","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"      in","counters":[]},{"line":"      match count with `One -> by_one t | `Two -> by_one (by_one t)","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":42,"col_end":42,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let rec check_constraints_and_update ~constraint_constants","counters":[]},{"line":"      (resources : Resources.t) log =","counters":[]},{"line":"    if Resources.slots_occupied resources = 0 then (resources, log)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"    else if Resources.work_constraint_satisfied resources then","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"      if","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (*There's enough work. Check if they satisfy other constraints*)","counters":[]},{"line":"        Resources.budget_sufficient resources","counters":[]},{"line":"      then","counters":[]},{"line":"        if Resources.space_constraint_satisfied resources then (resources, log)","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"        else if Resources.worked_more ~constraint_constants resources then","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"          (*There are too many fee_transfers(from the proofs) occupying the slots. discard one and check*)","counters":[]},{"line":"          let resources', work_opt =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Resources.discard_last_work ~constraint_constants resources","counters":[]},{"line":"          in","counters":[]},{"line":"          check_constraints_and_update ~constraint_constants resources'","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (Option.value_map work_opt ~default:log ~f:(fun work ->","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                 Diff_creation_log.discard_completed_work `Extra_work work log )","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"            )","counters":[]},{"line":"        else","counters":[]},{"line":"          (*Well, there's no space; discard a user command *)","counters":[]},{"line":"          let resources', uc_opt = Resources.discard_user_command resources in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          check_constraints_and_update ~constraint_constants resources'","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (Option.value_map uc_opt ~default:log ~f:(fun uc ->","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                 Diff_creation_log.discard_command `No_space","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                   (User_command.forget_check uc.data)","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"                   log ) )","counters":[]},{"line":"      else","counters":[]},{"line":"        (* insufficient budget; reduce the cost*)","counters":[]},{"line":"        let resources', work_opt =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Resources.discard_last_work ~constraint_constants resources","counters":[]},{"line":"        in","counters":[]},{"line":"        check_constraints_and_update ~constraint_constants resources'","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (Option.value_map work_opt ~default:log ~f:(fun work ->","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"               Diff_creation_log.discard_completed_work `Insufficient_fees work","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                 log ) )","counters":[]},{"line":"    else","counters":[]},{"line":"      (* There isn't enough work for the transactions. Discard a transaction and check again *)","counters":[]},{"line":"      let resources', uc_opt = Resources.discard_user_command resources in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      check_constraints_and_update ~constraint_constants resources'","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (Option.value_map uc_opt ~default:log ~f:(fun uc ->","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"             Diff_creation_log.discard_command `No_work","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"               (User_command.forget_check uc.data)","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"               log ) )","counters":[]},{"line":"","counters":[]},{"line":"  let one_prediff ~constraint_constants cw_seq ts_seq ~receiver ~add_coinbase","counters":[]},{"line":"      slot_job_count logger ~is_coinbase_receiver_new partition","counters":[]},{"line":"      ~supercharge_coinbase =","counters":[]},{"line":"    O1trace.sync_thread \"create_staged_ledger_diff_one_prediff\" (fun () ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        let init_resources =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Resources.init ~constraint_constants ts_seq cw_seq slot_job_count","counters":[]},{"line":"            ~receiver_pk:receiver ~add_coinbase logger ~is_coinbase_receiver_new","counters":[]},{"line":"            ~supercharge_coinbase","counters":[]},{"line":"        in","counters":[]},{"line":"        let log =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Diff_creation_log.init","counters":[]},{"line":"            ~completed_work:init_resources.completed_work_rev","counters":[]},{"line":"            ~commands:init_resources.commands_rev","counters":[]},{"line":"            ~coinbase:init_resources.coinbase ~partition","counters":[]},{"line":"            ~available_slots:(fst slot_job_count)","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"            ~required_work_count:(snd slot_job_count)","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"        in","counters":[]},{"line":"        check_constraints_and_update ~constraint_constants init_resources log )","counters":[]},{"line":"","counters":[]},{"line":"  let generate ~constraint_constants logger cw_seq ts_seq ~receiver","counters":[]},{"line":"      ~is_coinbase_receiver_new ~supercharge_coinbase","counters":[]},{"line":"      (partitions : Scan_state.Space_partition.t) =","counters":[]},{"line":"    let pre_diff_with_one (res : Resources.t) :","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        Staged_ledger_diff.With_valid_signatures_and_proofs","counters":[]},{"line":"        .pre_diff_with_at_most_one_coinbase =","counters":[]},{"line":"      O1trace.sync_thread \"create_staged_ledger_pre_diff_with_one\" (fun () ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          let to_at_most_one = function","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            | Staged_ledger_diff.At_most_two.Zero ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Staged_ledger_diff.At_most_one.Zero","counters":[]},{"line":"            | One x ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                One x","counters":[]},{"line":"            | _ ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                [%log error]","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                  \"Error creating staged ledger diff: Should have at most one \\","counters":[]},{"line":"                   coinbase in the second pre_diff\" ;","counters":[]},{"line":"                Zero","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"          in","counters":[]},{"line":"          (* We have to reverse here because we only know they work in THIS order *)","counters":[]},{"line":"          { Staged_ledger_diff.Pre_diff_one.commands =","counters":[]},{"line":"              Sequence.to_list_rev res.commands_rev","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"          ; completed_works = Sequence.to_list_rev res.completed_work_rev","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"          ; coinbase = to_at_most_one res.coinbase","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"          ; internal_command_statuses =","counters":[]},{"line":"              [] (*updated later based on application result*)","counters":[]},{"line":"          } )","counters":[]},{"line":"    in","counters":[]},{"line":"    let pre_diff_with_two (res : Resources.t) :","counters":[]},{"line":"        Staged_ledger_diff.With_valid_signatures_and_proofs","counters":[]},{"line":"        .pre_diff_with_at_most_two_coinbase =","counters":[]},{"line":"      (* We have to reverse here because we only know they work in THIS order *)","counters":[]},{"line":"      { commands = Sequence.to_list_rev res.commands_rev","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"      ; completed_works = Sequence.to_list_rev res.completed_work_rev","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"      ; coinbase = res.coinbase","counters":[]},{"line":"      ; internal_command_statuses =","counters":[]},{"line":"          [] (*updated later based on application result*)","counters":[]},{"line":"      }","counters":[]},{"line":"    in","counters":[]},{"line":"    let end_log ((res : Resources.t), (log : Diff_creation_log.t)) =","counters":[]},{"line":"      Diff_creation_log.end_log log ~completed_work:res.completed_work_rev","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ~commands:res.commands_rev ~coinbase:res.coinbase","counters":[]},{"line":"    in","counters":[]},{"line":"    let make_diff res1 = function","counters":[]},{"line":"      | Some res2 ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ( (pre_diff_with_two (fst res1), Some (pre_diff_with_one (fst res2)))","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":65,"col_end":65,"count":0},{"col_start":70,"col_end":70,"count":0}]},{"line":"          , List.map ~f:end_log [ res1; res2 ] )","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"      | None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ((pre_diff_with_two (fst res1), None), [ end_log res1 ])","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"    in","counters":[]},{"line":"    let has_no_commands (res : Resources.t) =","counters":[]},{"line":"      Sequence.length res.commands_rev = 0","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":20,"col_end":20,"count":0}]},{"line":"    in","counters":[]},{"line":"    let second_pre_diff (res : Resources.t) partition ~add_coinbase work =","counters":[]},{"line":"      one_prediff ~constraint_constants work res.discarded.commands_rev","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ~receiver partition ~add_coinbase logger ~is_coinbase_receiver_new","counters":[]},{"line":"        ~supercharge_coinbase `Second","counters":[]},{"line":"    in","counters":[]},{"line":"    let isEmpty (res : Resources.t) =","counters":[]},{"line":"      has_no_commands res && Resources.coinbase_added res = 0","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":20,"col_end":20,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"    in","counters":[]},{"line":"    (*Partitioning explained in PR #687 *)","counters":[]},{"line":"    match partitions.second with","counters":[]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let res, log =","counters":[]},{"line":"          one_prediff ~constraint_constants cw_seq ts_seq ~receiver","counters":[]},{"line":"            partitions.first ~add_coinbase:true logger ~is_coinbase_receiver_new","counters":[]},{"line":"            ~supercharge_coinbase `First","counters":[]},{"line":"        in","counters":[]},{"line":"        make_diff (res, log) None","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    | Some y ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        assert (Sequence.length cw_seq <= snd partitions.first + snd y) ;","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"        let cw_seq_1 = Sequence.take cw_seq (snd partitions.first) in","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"        let cw_seq_2 = Sequence.drop cw_seq (snd partitions.first) in","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"        let res, log1 =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          one_prediff ~constraint_constants cw_seq_1 ts_seq ~receiver","counters":[]},{"line":"            partitions.first ~add_coinbase:false logger","counters":[]},{"line":"            ~is_coinbase_receiver_new ~supercharge_coinbase `First","counters":[]},{"line":"        in","counters":[]},{"line":"        let incr_coinbase_and_compute res count =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let new_res =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Resources.incr_coinbase_part_by ~constraint_constants res count","counters":[]},{"line":"          in","counters":[]},{"line":"          if Resources.space_available new_res then","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (*All slots could not be filled either because of budget constraints or not enough work done. Don't create the second prediff instead recompute first diff with just once coinbase*)","counters":[]},{"line":"            ( one_prediff ~constraint_constants cw_seq_1 ts_seq ~receiver","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"                partitions.first ~add_coinbase:true logger","counters":[]},{"line":"                ~is_coinbase_receiver_new ~supercharge_coinbase `First","counters":[]},{"line":"            , None )","counters":[]},{"line":"          else","counters":[]},{"line":"            let res2, log2 =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              second_pre_diff new_res y ~add_coinbase:false cw_seq_2","counters":[]},{"line":"            in","counters":[]},{"line":"            if isEmpty res2 then","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (*Don't create the second prediff instead recompute first diff with just once coinbase*)","counters":[]},{"line":"              ( one_prediff ~constraint_constants cw_seq_1 ts_seq ~receiver","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"                  partitions.first ~add_coinbase:true logger","counters":[]},{"line":"                  ~is_coinbase_receiver_new ~supercharge_coinbase `First","counters":[]},{"line":"              , None )","counters":[]},{"line":"            else ((new_res, log1), Some (res2, log2))","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"        in","counters":[]},{"line":"        let try_with_coinbase () =","counters":[]},{"line":"          one_prediff ~constraint_constants cw_seq_1 ts_seq ~receiver","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            partitions.first ~add_coinbase:true logger ~is_coinbase_receiver_new","counters":[]},{"line":"            ~supercharge_coinbase `First","counters":[]},{"line":"        in","counters":[]},{"line":"        let res1, res2 =","counters":[]},{"line":"          if Sequence.is_empty res.commands_rev then","counters":[]},{"line":"            let res = try_with_coinbase () in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            (res, None)","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          else","counters":[]},{"line":"            match Resources.available_space res with","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            | 0 ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (*generate the next prediff with a coinbase at least*)","counters":[]},{"line":"                let res2 = second_pre_diff res y ~add_coinbase:true cw_seq_2 in","counters":[]},{"line":"                ((res, log1), Some res2)","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"            | 1 ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (*There's a slot available in the first partition, fill it with coinbase and create another pre_diff for the slots in the second partiton with the remaining user commands and work *)","counters":[]},{"line":"                incr_coinbase_and_compute res `One","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"            | 2 ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (*There are two slots which cannot be filled using user commands, so we split the coinbase into two parts and fill those two spots*)","counters":[]},{"line":"                incr_coinbase_and_compute res `Two","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"            | _ ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (* Too many slots left in the first partition. Either there wasn't enough work to add transactions or there weren't enough transactions. Create a new pre_diff for just the first partition*)","counters":[]},{"line":"                let res = try_with_coinbase () in","counters":[]},{"line":"                (res, None)","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"        in","counters":[]},{"line":"        let coinbase_added =","counters":[]},{"line":"          Resources.coinbase_added (fst res1)","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"          + Option.value_map","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"              ~f:(Fn.compose Resources.coinbase_added fst)","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"              res2 ~default:0","counters":[]},{"line":"        in","counters":[]},{"line":"        if coinbase_added > 0 then make_diff res1 res2","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"        else","counters":[]},{"line":"          (*Coinbase takes priority over user-commands. Create a diff in partitions.first with coinbase first and user commands if possible*)","counters":[]},{"line":"          let res = try_with_coinbase () in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          make_diff res None","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"  let can_apply_supercharged_coinbase_exn ~winner ~epoch_ledger ~global_slot =","counters":[]},{"line":"    Sparse_ledger.has_locked_tokens_exn ~global_slot","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"      ~account_id:(Account_id.create winner Token_id.default)","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"      epoch_ledger","counters":[]},{"line":"    |> not","counters":[]},{"line":"","counters":[]},{"line":"  let validate_account_update_proofs ~logger ~validating_ledger","counters":[]},{"line":"      (txn : User_command.Valid.t) =","counters":[]},{"line":"    let open Result.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let get_verification_keys account_ids =","counters":[]},{"line":"      List.fold_until account_ids ~init:Account_id.Map.empty","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ~f:(fun acc id ->","counters":[]},{"line":"          let get_vk () =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let open Option.Let_syntax in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let%bind loc =","counters":[]},{"line":"              Transaction_snark.Transaction_validator.Hashless_ledger","counters":[]},{"line":"              .location_of_account validating_ledger id","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"            in","counters":[]},{"line":"            let%bind account =","counters":[]},{"line":"              Transaction_snark.Transaction_validator.Hashless_ledger.get","counters":[{"col_start":72,"col_end":72,"count":0}]},{"line":"                validating_ledger loc","counters":[]},{"line":"            in","counters":[]},{"line":"            let%bind zkapp = account.zkapp in","counters":[]},{"line":"            let%map vk = zkapp.verification_key in","counters":[]},{"line":"            vk.hash","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          in","counters":[]},{"line":"          match get_vk () with","counters":[]},{"line":"          | Some vk ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Continue (Account_id.Map.update acc id ~f:(fun _ -> vk))","counters":[{"col_start":44,"col_end":44,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              [%log error]","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                ~metadata:[ (\"account_id\", Account_id.to_yojson id) ]","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"                \"Staged_ledger_diff creation: Verification key not found for \\","counters":[]},{"line":"                 account_update with proof authorization and account_id \\","counters":[]},{"line":"                 $account_id\" ;","counters":[]},{"line":"              Stop Account_id.Map.empty )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"        ~finish:Fn.id","counters":[]},{"line":"    in","counters":[]},{"line":"    match txn with","counters":[]},{"line":"    | Zkapp_command p ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let%map checked_verification_keys =","counters":[]},{"line":"          Account_id.Map.of_alist_or_error p.verification_keys","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"        in","counters":[]},{"line":"        let proof_zkapp_command =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Zkapp_command.Call_forest.fold ~init:Account_id.Set.empty","counters":[]},{"line":"            p.zkapp_command.account_updates ~f:(fun acc p ->","counters":[]},{"line":"              if","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Control.(Tag.equal Proof (tag (Account_update.authorization p)))","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":44,"col_end":44,"count":0},{"col_start":74,"col_end":74,"count":0}]},{"line":"              then Account_id.Set.add acc (Account_update.account_id p)","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"              else acc )","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"        in","counters":[]},{"line":"        let current_verification_keys =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          get_verification_keys (Account_id.Set.to_list proof_zkapp_command)","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"        in","counters":[]},{"line":"        if","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Account_id.Set.length proof_zkapp_command","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"          = Account_id.Map.length checked_verification_keys","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"          && Account_id.Map.equal","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"               Zkapp_command.Valid.Verification_key_hash.equal","counters":[]},{"line":"               checked_verification_keys current_verification_keys","counters":[]},{"line":"        then true","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"        else (","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"          [%log error]","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"            ~metadata:","counters":[]},{"line":"              [ ( \"checked_verification_keys\"","counters":[]},{"line":"                , [%to_yojson:","counters":[]},{"line":"                    (Account_id.t * Zkapp_command.Valid.Verification_key_hash.t)","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":78,"col_end":78,"count":0}]},{"line":"                    list]","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                    (Account_id.Map.to_alist checked_verification_keys) )","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"              ; ( \"current_verification_keys\"","counters":[]},{"line":"                , [%to_yojson:","counters":[]},{"line":"                    (Account_id.t * Zkapp_command.Valid.Verification_key_hash.t)","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":78,"col_end":78,"count":0}]},{"line":"                    list]","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                    (Account_id.Map.to_alist current_verification_keys) )","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"              ]","counters":[]},{"line":"            \"Staged_ledger_diff creation: Verifcation keys used for verifying \\","counters":[]},{"line":"             proofs $checked_verification_keys and verification keys in the \\","counters":[]},{"line":"             ledger $current_verification_keys don't match\" ;","counters":[]},{"line":"          false )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"    | _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Ok true","counters":[]},{"line":"","counters":[]},{"line":"  let create_diff","counters":[]},{"line":"      ~(constraint_constants : Genesis_constants.Constraint_constants.t)","counters":[]},{"line":"      ?(log_block_creation = false) t ~coinbase_receiver ~logger","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"      ~current_state_view","counters":[]},{"line":"      ~(transactions_by_fee : User_command.Valid.t Sequence.t)","counters":[]},{"line":"      ~(get_completed_work :","counters":[]},{"line":"            Transaction_snark_work.Statement.t","counters":[]},{"line":"         -> Transaction_snark_work.Checked.t option ) ~supercharge_coinbase =","counters":[]},{"line":"    O1trace.sync_thread \"create_staged_ledger_diff\" (fun () ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        let open Result.Let_syntax in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let module Transaction_validator =","counters":[]},{"line":"          Transaction_snark.Transaction_validator","counters":[]},{"line":"        in","counters":[]},{"line":"        let validating_ledger = Transaction_validator.create t.ledger in","counters":[]},{"line":"        let is_new_account pk =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Transaction_validator.Hashless_ledger.location_of_account","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"            validating_ledger","counters":[]},{"line":"            (Account_id.create pk Token_id.default)","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"          |> Option.is_none","counters":[]},{"line":"        in","counters":[]},{"line":"        let is_coinbase_receiver_new = is_new_account coinbase_receiver in","counters":[]},{"line":"        if supercharge_coinbase then","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          [%log info]","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":20,"col_end":20,"count":0}]},{"line":"            \"No locked tokens in the delegator/delegatee account, applying \\","counters":[]},{"line":"             supercharged coinbase\" ;","counters":[]},{"line":"        let partitions = Scan_state.partition_if_overflowing t.scan_state in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let work_to_do = Scan_state.work_statements_for_new_diff t.scan_state in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let completed_works_seq, proof_count =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          List.fold_until work_to_do ~init:(Sequence.empty, 0)","counters":[]},{"line":"            ~f:(fun (seq, count) w ->","counters":[]},{"line":"              match get_completed_work w with","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              | Some cw_checked ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  (*If new provers can't pay the account-creation-fee then discard","counters":[]},{"line":"                    their work unless their fee is zero in which case their account","counters":[]},{"line":"                    won't be created. This is to encourage using an existing accounts","counters":[]},{"line":"                    for snarking.","counters":[]},{"line":"                    This also imposes new snarkers to have a min fee until one of","counters":[]},{"line":"                    their snarks are purchased and their accounts get created*)","counters":[]},{"line":"                  if","counters":[]},{"line":"                    Currency.Fee.(cw_checked.fee = zero)","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"                    || Currency.Fee.(","counters":[]},{"line":"                         cw_checked.fee","counters":[]},{"line":"                         >= constraint_constants.account_creation_fee)","counters":[{"col_start":69,"col_end":69,"count":0}]},{"line":"                    || not (is_new_account cw_checked.prover)","counters":[{"col_start":41,"col_end":41,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"                  then","counters":[]},{"line":"                    Continue","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      ( Sequence.append seq (Sequence.singleton cw_checked)","counters":[{"col_start":38,"col_end":38,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"                      , One_or_two.length cw_checked.proofs + count )","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"                  else (","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                    [%log debug]","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                      ~metadata:","counters":[]},{"line":"                        [ ( \"work\"","counters":[]},{"line":"                          , Transaction_snark_work.Checked.to_yojson cw_checked","counters":[{"col_start":67,"col_end":67,"count":0}]},{"line":"                          )","counters":[]},{"line":"                        ; ( \"work_ids\"","counters":[]},{"line":"                          , Transaction_snark_work.Statement.compact_json w )","counters":[{"col_start":72,"col_end":72,"count":0}]},{"line":"                        ; (\"snark_fee\", Currency.Fee.to_yojson cw_checked.fee)","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"                        ; ( \"account_creation_fee\"","counters":[]},{"line":"                          , Currency.Fee.to_yojson","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"                              constraint_constants.account_creation_fee )","counters":[]},{"line":"                        ]","counters":[]},{"line":"                      !\"Staged_ledger_diff creation: Snark fee $snark_fee \\","counters":[]},{"line":"                        insufficient to create the snark worker account\" ;","counters":[]},{"line":"                    Stop (seq, count) )","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"              | None ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  [%log debug]","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                    ~metadata:","counters":[]},{"line":"                      [ ( \"statement\"","counters":[]},{"line":"                        , Transaction_snark_work.Statement.to_yojson w )","counters":[{"col_start":67,"col_end":67,"count":0}]},{"line":"                      ; ( \"work_ids\"","counters":[]},{"line":"                        , Transaction_snark_work.Statement.compact_json w )","counters":[{"col_start":70,"col_end":70,"count":0}]},{"line":"                      ]","counters":[]},{"line":"                    !\"Staged_ledger_diff creation: No snark work found for \\","counters":[]},{"line":"                      $statement\" ;","counters":[]},{"line":"                  Stop (seq, count) )","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"            ~finish:Fn.id","counters":[]},{"line":"        in","counters":[]},{"line":"        (*Transactions in reverse order for faster removal if there is no space when creating the diff*)","counters":[]},{"line":"        let valid_on_this_ledger, invalid_on_this_ledger =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Sequence.fold_until transactions_by_fee ~init:(Sequence.empty, [], 0)","counters":[]},{"line":"            ~f:(fun (valid_seq, invalid_txns, count) txn ->","counters":[]},{"line":"              match","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                O1trace.sync_thread \"validate_transaction_against_staged_ledger\"","counters":[]},{"line":"                  (fun () ->","counters":[]},{"line":"                    let%bind valid_proofs =","counters":[]},{"line":"                      validate_account_update_proofs ~logger ~validating_ledger","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                        txn","counters":[]},{"line":"                    in","counters":[]},{"line":"                    let%bind () =","counters":[]},{"line":"                      if valid_proofs then Ok ()","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"                      else Or_error.errorf \"Verification key mismatch\"","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"                    in","counters":[]},{"line":"                    Transaction_validator.apply_transaction","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      ~constraint_constants validating_ledger","counters":[]},{"line":"                      ~txn_state_view:current_state_view","counters":[]},{"line":"                      (Command (User_command.forget_check txn)) )","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"              with","counters":[]},{"line":"              | Error e ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  [%log error]","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                    ~metadata:","counters":[]},{"line":"                      [ (\"user_command\", User_command.Valid.to_yojson txn)","counters":[{"col_start":68,"col_end":68,"count":0}]},{"line":"                      ; (\"error\", Error_json.error_to_yojson e)","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"                      ]","counters":[]},{"line":"                    \"Staged_ledger_diff creation: Skipping user command: \\","counters":[]},{"line":"                     $user_command due to error: $error\" ;","counters":[]},{"line":"                  Continue (valid_seq, (txn, e) :: invalid_txns, count)","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"              | Ok status ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  let txn_with_status = { With_status.data = txn; status } in","counters":[]},{"line":"                  let valid_seq' =","counters":[]},{"line":"                    Sequence.append","counters":[]},{"line":"                      (Sequence.singleton txn_with_status)","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"                      valid_seq","counters":[]},{"line":"                  in","counters":[]},{"line":"                  let count' = count + 1 in","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  if count' >= Scan_state.free_space t.scan_state then","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                    Stop (valid_seq', invalid_txns)","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                  else Continue (valid_seq', invalid_txns, count') )","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"            ~finish:(fun (valid, invalid, _) -> (valid, invalid))","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"        in","counters":[]},{"line":"        let diff, log =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          O1trace.sync_thread \"generate_staged_ledger_diff\" (fun () ->","counters":[]},{"line":"              generate ~constraint_constants logger completed_works_seq","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                valid_on_this_ledger ~receiver:coinbase_receiver","counters":[]},{"line":"                ~is_coinbase_receiver_new ~supercharge_coinbase partitions )","counters":[]},{"line":"        in","counters":[]},{"line":"        let%map diff =","counters":[]},{"line":"          (* Fill in the statuses for commands. *)","counters":[]},{"line":"          let generate_status =","counters":[]},{"line":"            let status_ledger = Transaction_validator.create t.ledger in","counters":[]},{"line":"            fun txn ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              O1trace.sync_thread \"get_transaction__status\" (fun () ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                  Transaction_validator.apply_transaction ~constraint_constants","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    status_ledger ~txn_state_view:current_state_view txn )","counters":[]},{"line":"          in","counters":[]},{"line":"          Pre_diff_info.compute_statuses ~constraint_constants ~diff","counters":[]},{"line":"            ~coinbase_amount:","counters":[]},{"line":"              (Option.value_exn","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                 (coinbase_amount ~constraint_constants ~supercharge_coinbase) )","counters":[]},{"line":"            ~coinbase_receiver ~generate_status","counters":[]},{"line":"            ~forget:User_command.forget_check","counters":[]},{"line":"        in","counters":[]},{"line":"        let summaries, detailed = List.unzip log in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        [%log debug]","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"          \"Number of proofs ready for purchase: $proof_count Number of user \\","counters":[]},{"line":"           commands ready to be included: $txn_count Diff creation log: \\","counters":[]},{"line":"           $diff_log\"","counters":[]},{"line":"          ~metadata:","counters":[]},{"line":"            [ (\"proof_count\", `Int proof_count)","counters":[]},{"line":"            ; (\"txn_count\", `Int (Sequence.length valid_on_this_ledger))","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"            ; (\"diff_log\", Diff_creation_log.summary_list_to_yojson summaries)","counters":[{"col_start":66,"col_end":66,"count":0}]},{"line":"            ] ;","counters":[]},{"line":"        if log_block_creation then","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          [%log debug] \"Detailed diff creation log: $diff_log\"","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"            ~metadata:","counters":[]},{"line":"              [ ( \"diff_log\"","counters":[]},{"line":"                , Diff_creation_log.detail_list_to_yojson","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"                    (List.map ~f:List.rev detailed) )","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"              ] ;","counters":[]},{"line":"        ( { Staged_ledger_diff.With_valid_signatures_and_proofs.diff }","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        , invalid_on_this_ledger ) )","counters":[]},{"line":"","counters":[]},{"line":"  let latest_block_accounts_created t ~previous_block_state_hash =","counters":[]},{"line":"    let scan_state = scan_state t in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    (* filter leaves by state hash from previous block *)","counters":[]},{"line":"    let block_transactions_applied =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let f","counters":[]},{"line":"          ({ state_hash = leaf_block_hash, _; transaction_with_info; _ } :","counters":[]},{"line":"            Scan_state.Transaction_with_witness.t ) =","counters":[]},{"line":"        if State_hash.equal leaf_block_hash previous_block_state_hash then","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Some transaction_with_info.varying","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        else None","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"      in","counters":[]},{"line":"      List.filter_map (Scan_state.base_jobs_on_latest_tree scan_state) ~f","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"      @ List.filter_map","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"          (Scan_state.base_jobs_on_earlier_tree ~index:0 scan_state)","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"          ~f","counters":[]},{"line":"    in","counters":[]},{"line":"    List.map block_transactions_applied ~f:(function","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"      | Command (Signed_command cmd) -> (","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          match cmd.body with","counters":[]},{"line":"          | Payment { new_accounts } ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              new_accounts","counters":[]},{"line":"          | Stake_delegation _ ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              []","counters":[]},{"line":"          | Failed ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              [] )","counters":[]},{"line":"      | Command (Zkapp_command { new_accounts; _ }) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          new_accounts","counters":[]},{"line":"      | Fee_transfer { new_accounts; _ } ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          new_accounts","counters":[]},{"line":"      | Coinbase { new_accounts; _ } ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          new_accounts )","counters":[]},{"line":"    |> List.concat","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"include T","counters":[]},{"line":"","counters":[]},{"line":"let%test_module \"staged ledger tests\" =","counters":[]},{"line":"  ( module struct","counters":[]},{"line":"    module Sl = T","counters":[]},{"line":"","counters":[]},{"line":"    let () =","counters":[]},{"line":"      Backtrace.elide := false ;","counters":[]},{"line":"      Async.Scheduler.set_record_backtraces true","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"","counters":[]},{"line":"    let self_pk =","counters":[]},{"line":"      Quickcheck.random_value ~seed:(`Deterministic \"self_pk\")","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"        Public_key.Compressed.gen","counters":[]},{"line":"","counters":[]},{"line":"    let coinbase_receiver =","counters":[]},{"line":"      Quickcheck.random_value ~seed:(`Deterministic \"receiver_pk\")","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"        Public_key.Compressed.gen","counters":[]},{"line":"","counters":[]},{"line":"    let proof_level = Genesis_constants.Proof_level.for_unit_tests","counters":[]},{"line":"","counters":[]},{"line":"    let constraint_constants =","counters":[]},{"line":"      Genesis_constants.Constraint_constants.for_unit_tests","counters":[]},{"line":"","counters":[]},{"line":"    let logger = Logger.null ()","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"","counters":[]},{"line":"    let `VK vk, `Prover zkapp_prover =","counters":[]},{"line":"      Transaction_snark.For_tests.create_trivial_snapp ~constraint_constants ()","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"","counters":[]},{"line":"    let verifier =","counters":[]},{"line":"      Async.Thread_safe.block_on_async_exn (fun () ->","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"          Verifier.create ~logger ~proof_level ~constraint_constants","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ~conf_dir:None","counters":[]},{"line":"            ~pids:(Child_processes.Termination.create_pid_table ()) )","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"","counters":[]},{"line":"    let supercharge_coinbase ~ledger ~winner ~global_slot =","counters":[]},{"line":"      (*using staged ledger to confirm coinbase amount is correctly generated*)","counters":[]},{"line":"      let epoch_ledger =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Sparse_ledger.of_ledger_subset_exn ledger","counters":[]},{"line":"          (List.map [ winner ] ~f:(fun k ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"               Account_id.create k Token_id.default ) )","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"      in","counters":[]},{"line":"      Sl.can_apply_supercharged_coinbase_exn ~winner ~global_slot ~epoch_ledger","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    (* Functor for testing with different instantiated staged ledger modules. *)","counters":[]},{"line":"    let create_and_apply_with_state_body_hash","counters":[]},{"line":"        ?(coinbase_receiver = coinbase_receiver) ?(winner = self_pk)","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"        ~(current_state_view : Zkapp_precondition.Protocol_state.View.t)","counters":[]},{"line":"        ~state_and_body_hash sl txns stmt_to_work =","counters":[]},{"line":"      let open Deferred.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let supercharge_coinbase =","counters":[]},{"line":"        supercharge_coinbase ~ledger:(Sl.ledger !sl) ~winner","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"          ~global_slot:current_state_view.global_slot_since_genesis","counters":[]},{"line":"      in","counters":[]},{"line":"      let diff =","counters":[]},{"line":"        Sl.create_diff ~constraint_constants !sl ~logger ~current_state_view","counters":[]},{"line":"          ~transactions_by_fee:txns ~get_completed_work:stmt_to_work","counters":[]},{"line":"          ~supercharge_coinbase ~coinbase_receiver","counters":[]},{"line":"      in","counters":[]},{"line":"      let diff, _invalid_txns =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        match diff with","counters":[]},{"line":"        | Ok x ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            x","counters":[]},{"line":"        | Error e ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Error.raise (Pre_diff_info.Error.to_error e)","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"      in","counters":[]},{"line":"      let diff' = Staged_ledger_diff.forget diff in","counters":[]},{"line":"      let%map ( `Hash_after_applying hash","counters":[]},{"line":"              , `Ledger_proof ledger_proof","counters":[]},{"line":"              , `Staged_ledger sl'","counters":[]},{"line":"              , `Pending_coinbase_update (is_new_stack, pc_update) ) =","counters":[]},{"line":"        match%map","counters":[]},{"line":"          Sl.apply ~constraint_constants !sl diff' ~logger ~verifier","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"            ~current_state_view ~state_and_body_hash ~coinbase_receiver","counters":[]},{"line":"            ~supercharge_coinbase","counters":[]},{"line":"        with","counters":[]},{"line":"        | Ok x ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            x","counters":[]},{"line":"        | Error e ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Error.raise (Sl.Staged_ledger_error.to_error e)","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"      in","counters":[]},{"line":"      assert (Staged_ledger_hash.equal hash (Sl.hash sl')) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"      sl := sl' ;","counters":[]},{"line":"      (ledger_proof, diff', is_new_stack, pc_update, supercharge_coinbase)","counters":[]},{"line":"","counters":[]},{"line":"    let dummy_state_view","counters":[]},{"line":"        ?(global_slot_since_genesis = Mina_numbers.Global_slot.zero) () =","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"      let state_body =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let consensus_constants =","counters":[]},{"line":"          let genesis_constants = Genesis_constants.for_unit_tests in","counters":[]},{"line":"          Consensus.Constants.create ~constraint_constants","counters":[]},{"line":"            ~protocol_constants:genesis_constants.protocol","counters":[]},{"line":"        in","counters":[]},{"line":"        let compile_time_genesis =","counters":[]},{"line":"          let open Staged_ledger_diff in","counters":[]},{"line":"          (*not using Precomputed_values.for_unit_test because of dependency cycle*)","counters":[]},{"line":"          Mina_state.Genesis_protocol_state.t","counters":[]},{"line":"            ~genesis_ledger:Genesis_ledger.(Packed.t for_unit_tests)","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"            ~genesis_epoch_data:Consensus.Genesis_epoch_data.for_unit_tests","counters":[]},{"line":"            ~constraint_constants ~consensus_constants ~genesis_body_reference","counters":[]},{"line":"        in","counters":[]},{"line":"        compile_time_genesis.data |> Mina_state.Protocol_state.body","counters":[{"col_start":66,"col_end":66,"count":0}]},{"line":"      in","counters":[]},{"line":"      { (Mina_state.Protocol_state.Body.view state_body) with","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"        global_slot_since_genesis","counters":[]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    let create_and_apply ?(coinbase_receiver = coinbase_receiver)","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"        ?(winner = self_pk) sl txns stmt_to_work =","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"      let open Deferred.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%map ledger_proof, diff, _, _, _ =","counters":[]},{"line":"        create_and_apply_with_state_body_hash ~coinbase_receiver ~winner","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"          ~current_state_view:(dummy_state_view ())","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"          ~state_and_body_hash:(State_hash.dummy, State_body_hash.dummy)","counters":[]},{"line":"          sl txns stmt_to_work","counters":[]},{"line":"      in","counters":[]},{"line":"      (ledger_proof, diff)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    (* Run the given function inside of the Deferred monad, with a staged","counters":[]},{"line":"         ledger and a separate test ledger, after applying the given","counters":[]},{"line":"         init_state to both. In the below tests we apply the same commands to","counters":[]},{"line":"         the staged and test ledgers, and verify they are in the same state.","counters":[]},{"line":"    *)","counters":[]},{"line":"    let async_with_given_ledger ledger","counters":[]},{"line":"        (f : Sl.t ref -> Ledger.Mask.Attached.t -> unit Deferred.t) =","counters":[]},{"line":"      let casted = Ledger.Any_ledger.cast (module Ledger) ledger in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let test_mask =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Ledger.Maskable.register_mask casted","counters":[]},{"line":"          (Ledger.Mask.create ~depth:(Ledger.depth ledger) ())","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"      in","counters":[]},{"line":"      let sl = ref @@ Sl.create_exn ~constraint_constants ~ledger in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Async.Thread_safe.block_on_async_exn (fun () -> f sl test_mask) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"      ignore @@ Ledger.Maskable.unregister_mask_exn ~loc:__LOC__ test_mask","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"","counters":[]},{"line":"    (* populate the ledger from an initial state before running the function *)","counters":[]},{"line":"    let async_with_ledgers ledger_init_state","counters":[]},{"line":"        (f : Sl.t ref -> Ledger.Mask.Attached.t -> unit Deferred.t) =","counters":[]},{"line":"      Ledger.with_ephemeral_ledger ~depth:constraint_constants.ledger_depth","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ~f:(fun ledger ->","counters":[]},{"line":"          Ledger.apply_initial_ledger_state ledger ledger_init_state ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          async_with_given_ledger ledger f )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"    (* Assert the given staged ledger is in the correct state after applying","counters":[]},{"line":"         the first n user commands passed to the given base ledger. Checks the","counters":[]},{"line":"         states of the block producer account and user accounts but ignores","counters":[]},{"line":"         snark workers for simplicity. *)","counters":[]},{"line":"    let assert_ledger :","counters":[]},{"line":"           Ledger.t","counters":[]},{"line":"        -> coinbase_cost:Currency.Fee.t","counters":[]},{"line":"        -> Sl.t","counters":[]},{"line":"        -> User_command.Valid.t list","counters":[]},{"line":"        -> int","counters":[]},{"line":"        -> Account_id.t list","counters":[]},{"line":"        -> unit =","counters":[]},{"line":"     fun test_ledger ~coinbase_cost staged_ledger cmds_all cmds_used","counters":[]},{"line":"         pks_to_check ->","counters":[]},{"line":"      let producer_account_id =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Account_id.create coinbase_receiver Token_id.default","counters":[]},{"line":"      in","counters":[]},{"line":"      let producer_account =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Option.bind","counters":[]},{"line":"          (Ledger.location_of_account test_ledger producer_account_id)","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"          ~f:(Ledger.get test_ledger)","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"      in","counters":[]},{"line":"      let is_producer_acc_new = Option.is_none producer_account in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let old_producer_balance =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Option.value_map producer_account ~default:Currency.Balance.zero","counters":[]},{"line":"          ~f:(fun a -> a.balance)","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"      in","counters":[]},{"line":"      let rec apply_cmds =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let open Or_error.Let_syntax in","counters":[]},{"line":"        function","counters":[]},{"line":"        | [] ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            return ()","counters":[]},{"line":"        | (cmd : User_command.Valid.t) :: cmds ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let%bind _ =","counters":[]},{"line":"              Ledger.apply_transaction ~constraint_constants test_ledger","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                ~txn_state_view:(dummy_state_view ())","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"                (Command (User_command.forget_check cmd))","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"            in","counters":[]},{"line":"            apply_cmds cmds","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"      in","counters":[]},{"line":"      Or_error.ok_exn @@ apply_cmds @@ List.take cmds_all cmds_used ;","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"      let get_account_exn ledger pk =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Option.value_exn","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (Option.bind","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"             (Ledger.location_of_account ledger pk)","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"             ~f:(Ledger.get ledger) )","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"      in","counters":[]},{"line":"      (* Check the user accounts in the updated staged ledger are as","counters":[]},{"line":"         expected.","counters":[]},{"line":"      *)","counters":[]},{"line":"      List.iter pks_to_check ~f:(fun pk ->","counters":[]},{"line":"          let expect = get_account_exn test_ledger pk in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let actual = get_account_exn (Sl.ledger staged_ledger) pk in","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"          [%test_result: Account.t] ~expect actual ) ;","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"      (* We only test that the block producer got the coinbase reward here, since calculating the exact correct amount depends on the snark fees and tx fees. *)","counters":[]},{"line":"      let producer_balance_with_coinbase =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (let open Option.Let_syntax in","counters":[]},{"line":"        let%bind total_cost =","counters":[]},{"line":"          if is_producer_acc_new then","counters":[]},{"line":"            Currency.Fee.add coinbase_cost","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"              constraint_constants.account_creation_fee","counters":[]},{"line":"          else Some coinbase_cost","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"        in","counters":[]},{"line":"        let%bind reward =","counters":[]},{"line":"          Currency.Amount.(","counters":[]},{"line":"            sub constraint_constants.coinbase_amount (of_fee total_cost))","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"        in","counters":[]},{"line":"        Currency.Balance.add_amount old_producer_balance reward)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        |> Option.value_exn","counters":[]},{"line":"      in","counters":[]},{"line":"      let new_producer_balance =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (get_account_exn (Sl.ledger staged_ledger) producer_account_id).balance","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"      in","counters":[]},{"line":"      assert (","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"        Currency.Balance.(","counters":[]},{"line":"          new_producer_balance >= producer_balance_with_coinbase) )","counters":[]},{"line":"","counters":[]},{"line":"    let work_fee = constraint_constants.account_creation_fee","counters":[]},{"line":"","counters":[]},{"line":"    (* Deterministically compute a prover public key from a snark work statement. *)","counters":[]},{"line":"    let stmt_to_prover :","counters":[]},{"line":"        Transaction_snark_work.Statement.t -> Public_key.Compressed.t =","counters":[]},{"line":"     fun stmts ->","counters":[]},{"line":"      let prover_seed =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        One_or_two.fold stmts ~init:\"P\" ~f:(fun p stmt ->","counters":[]},{"line":"            p ^ Frozen_ledger_hash.to_bytes stmt.target.ledger )","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"      in","counters":[]},{"line":"      Quickcheck.random_value ~seed:(`Deterministic prover_seed)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Public_key.Compressed.gen","counters":[]},{"line":"","counters":[]},{"line":"    let proofs stmts : Ledger_proof.t One_or_two.t =","counters":[]},{"line":"      let sok_digest = Sok_message.Digest.default in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      One_or_two.map stmts ~f:(fun statement ->","counters":[]},{"line":"          Ledger_proof.create ~statement ~sok_digest","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ~proof:Proof.transaction_dummy )","counters":[]},{"line":"","counters":[]},{"line":"    let stmt_to_work_random_prover (stmts : Transaction_snark_work.Statement.t)","counters":[]},{"line":"        : Transaction_snark_work.Checked.t option =","counters":[]},{"line":"      let prover = stmt_to_prover stmts in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Some","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { Transaction_snark_work.Checked.fee = work_fee","counters":[]},{"line":"        ; proofs = proofs stmts","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"        ; prover","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"    let stmt_to_work_zero_fee ~prover","counters":[]},{"line":"        (stmts : Transaction_snark_work.Statement.t) :","counters":[]},{"line":"        Transaction_snark_work.Checked.t option =","counters":[]},{"line":"      Some","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { Transaction_snark_work.Checked.fee = Currency.Fee.zero","counters":[]},{"line":"        ; proofs = proofs stmts","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"        ; prover","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"    (* Fixed public key for when there is only one snark worker. *)","counters":[]},{"line":"    let snark_worker_pk =","counters":[]},{"line":"      Quickcheck.random_value ~seed:(`Deterministic \"snark worker\")","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"        Public_key.Compressed.gen","counters":[]},{"line":"","counters":[]},{"line":"    let stmt_to_work_one_prover (stmts : Transaction_snark_work.Statement.t) :","counters":[]},{"line":"        Transaction_snark_work.Checked.t option =","counters":[]},{"line":"      Some { fee = work_fee; proofs = proofs stmts; prover = snark_worker_pk }","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"","counters":[]},{"line":"    let coinbase_first_prediff = function","counters":[]},{"line":"      | Staged_ledger_diff.At_most_two.Zero ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (0, [])","counters":[]},{"line":"      | One None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (1, [])","counters":[]},{"line":"      | One (Some ft) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (1, [ ft ])","counters":[]},{"line":"      | Two None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (2, [])","counters":[]},{"line":"      | Two (Some (ft, None)) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (2, [ ft ])","counters":[]},{"line":"      | Two (Some (ft1, Some ft2)) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (2, [ ft1; ft2 ])","counters":[]},{"line":"","counters":[]},{"line":"    let coinbase_second_prediff = function","counters":[]},{"line":"      | Staged_ledger_diff.At_most_one.Zero ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (0, [])","counters":[]},{"line":"      | One None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (1, [])","counters":[]},{"line":"      | One (Some ft) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (1, [ ft ])","counters":[]},{"line":"","counters":[]},{"line":"    let coinbase_count (sl_diff : Staged_ledger_diff.t) =","counters":[]},{"line":"      (coinbase_first_prediff (fst sl_diff.diff).coinbase |> fst)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":33,"col_end":33,"count":0},{"col_start":63,"col_end":63,"count":0}]},{"line":"      + Option.value_map ~default:0 (snd sl_diff.diff) ~f:(fun d ->","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"            coinbase_second_prediff d.coinbase |> fst )","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"","counters":[]},{"line":"    let coinbase_cost (sl_diff : Staged_ledger_diff.t) =","counters":[]},{"line":"      let coinbase_fts =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (coinbase_first_prediff (fst sl_diff.diff).coinbase |> snd)","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"        @ Option.value_map ~default:[] (snd sl_diff.diff) ~f:(fun d ->","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"              coinbase_second_prediff d.coinbase |> snd )","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"      in","counters":[]},{"line":"      List.fold coinbase_fts ~init:Currency.Fee.zero ~f:(fun total ft ->","counters":[]},{"line":"          Currency.Fee.add total ft.fee |> Option.value_exn )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"    let () =","counters":[]},{"line":"      Async.Scheduler.set_record_backtraces true ;","counters":[]},{"line":"      Backtrace.elide := false","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    (* The tests are still very slow, so we set ~trials very low for all the","counters":[]},{"line":"       QuickCheck tests. We may be able to turn them up after #2759 and/or #2760","counters":[]},{"line":"       happen.","counters":[]},{"line":"    *)","counters":[]},{"line":"","counters":[]},{"line":"    (* Get the public keys from a ledger init state. *)","counters":[]},{"line":"    let init_pks (init : Ledger.init_state) =","counters":[]},{"line":"      Array.to_sequence init","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"      |> Sequence.map ~f:(fun (kp, _, _, _) ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"             Account_id.create","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"               (Public_key.compress kp.public_key)","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"               Token_id.default )","counters":[]},{"line":"      |> Sequence.to_list","counters":[]},{"line":"","counters":[]},{"line":"    (* Fee excess at top level ledger proofs should always be zero *)","counters":[]},{"line":"    let assert_fee_excess :","counters":[]},{"line":"        (Ledger_proof.t * (Transaction.t With_status.t * _) list) option -> unit","counters":[]},{"line":"        =","counters":[]},{"line":"     fun proof_opt ->","counters":[]},{"line":"      let fee_excess =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Option.value_map ~default:Fee_excess.zero proof_opt","counters":[]},{"line":"          ~f:(fun (proof, _txns) -> (Ledger_proof.statement proof).fee_excess)","counters":[{"col_start":36,"col_end":36,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"      in","counters":[]},{"line":"      assert (Fee_excess.is_zero fee_excess)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"","counters":[]},{"line":"    let transaction_capacity =","counters":[]},{"line":"      Int.pow 2 constraint_constants.transaction_capacity_log_2","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"","counters":[]},{"line":"    (* Abstraction for the pattern of taking a list of commands and applying it","counters":[]},{"line":"       in chunks up to a given max size. *)","counters":[]},{"line":"    let rec iter_cmds_acc :","counters":[]},{"line":"           User_command.Valid.t list (** All the commands to apply. *)","counters":[]},{"line":"        -> int option list","counters":[]},{"line":"           (** A list of chunk sizes. If a chunk's size is None, apply as many","counters":[]},{"line":"            commands as possible. *)","counters":[]},{"line":"        -> 'acc","counters":[]},{"line":"        -> (   User_command.Valid.t list (** All commands remaining. *)","counters":[]},{"line":"            -> int option (* Current chunk size. *)","counters":[]},{"line":"            -> User_command.Valid.t Sequence.t","counters":[]},{"line":"               (* Sequence of commands to apply. *)","counters":[]},{"line":"            -> 'acc","counters":[]},{"line":"            -> (Staged_ledger_diff.t * 'acc) Deferred.t )","counters":[]},{"line":"        -> 'acc Deferred.t =","counters":[]},{"line":"     fun cmds cmd_iters acc f ->","counters":[]},{"line":"      match cmd_iters with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | [] ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Deferred.return acc","counters":[]},{"line":"      | count_opt :: counts_rest ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let cmds_this_iter_max =","counters":[]},{"line":"            match count_opt with","counters":[]},{"line":"            | None ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                cmds","counters":[]},{"line":"            | Some count ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                assert (count <= List.length cmds) ;","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"                List.take cmds count","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"          in","counters":[]},{"line":"          let%bind diff, acc' =","counters":[]},{"line":"            f cmds count_opt (Sequence.of_list cmds_this_iter_max) acc","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"          in","counters":[]},{"line":"          let cmds_applied_count =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            List.length @@ Staged_ledger_diff.commands diff","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"          in","counters":[]},{"line":"          iter_cmds_acc (List.drop cmds cmds_applied_count) counts_rest acc' f","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"","counters":[]},{"line":"    (** Generic test framework. *)","counters":[]},{"line":"    let test_simple :","counters":[]},{"line":"           Account_id.t list","counters":[]},{"line":"        -> User_command.Valid.t list","counters":[]},{"line":"        -> int option list","counters":[]},{"line":"        -> Sl.t ref","counters":[]},{"line":"        -> ?expected_proof_count:int option (*Number of ledger proofs expected*)","counters":[]},{"line":"        -> ?allow_failures:bool","counters":[]},{"line":"        -> Ledger.Mask.Attached.t","counters":[]},{"line":"        -> [ `One_prover | `Many_provers ]","counters":[]},{"line":"        -> (   Transaction_snark_work.Statement.t","counters":[]},{"line":"            -> Transaction_snark_work.Checked.t option )","counters":[]},{"line":"        -> unit Deferred.t =","counters":[]},{"line":"     fun account_ids_to_check cmds cmd_iters sl ?(expected_proof_count = None)","counters":[{"col_start":73,"col_end":73,"count":0}]},{"line":"         ?(allow_failures = false) test_mask provers stmt_to_work ->","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"      let%map total_ledger_proofs =","counters":[]},{"line":"        iter_cmds_acc cmds cmd_iters 0","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"          (fun cmds_left count_opt cmds_this_iter proof_count ->","counters":[]},{"line":"            let%bind ledger_proof, diff =","counters":[]},{"line":"              create_and_apply sl cmds_this_iter stmt_to_work","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"            in","counters":[]},{"line":"            List.iter (Staged_ledger_diff.commands diff) ~f:(fun c ->","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"                match With_status.status c with","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                | Applied ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    ()","counters":[]},{"line":"                | Failed ftl ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    if not allow_failures then","counters":[]},{"line":"                      failwith","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        (sprintf","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                           \"Transaction application failed for command %s. \\","counters":[]},{"line":"                            Failures %s\"","counters":[]},{"line":"                           ( User_command.to_yojson (With_status.data c)","counters":[{"col_start":50,"col_end":50,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"                           |> Yojson.Safe.to_string )","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                           ( Transaction_status.Failure.Collection.to_yojson ftl","counters":[{"col_start":75,"col_end":75,"count":0}]},{"line":"                           |> Yojson.Safe.to_string ) ) ) ;","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"            let proof_count' =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              proof_count + if Option.is_some ledger_proof then 1 else 0","counters":[{"col_start":64,"col_end":64,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"            in","counters":[]},{"line":"            assert_fee_excess ledger_proof ;","counters":[]},{"line":"            let cmds_applied_this_iter =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              List.length @@ Staged_ledger_diff.commands diff","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"            in","counters":[]},{"line":"            let cb = coinbase_count diff in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            ( match provers with","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            | `One_prover ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                assert (cb = 1)","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"            | `Many_provers ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                assert (cb > 0 && cb < 3) ) ;","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"            ( match count_opt with","counters":[]},{"line":"            | Some _ ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (* There is an edge case where cmds_applied_this_iter = 0, when","counters":[]},{"line":"                   there is only enough space for coinbase transactions. *)","counters":[]},{"line":"                assert (cmds_applied_this_iter <= Sequence.length cmds_this_iter) ;","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"                [%test_eq: User_command.t list]","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"                  (List.map (Staged_ledger_diff.commands diff)","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"                     ~f:(fun { With_status.data; _ } -> data) )","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"                  ( Sequence.take cmds_this_iter cmds_applied_this_iter","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                  |> Sequence.map ~f:User_command.forget_check","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                  |> Sequence.to_list )","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"            | None ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                () ) ;","counters":[]},{"line":"            let coinbase_cost = coinbase_cost diff in","counters":[]},{"line":"            assert_ledger test_mask ~coinbase_cost !sl cmds_left","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              cmds_applied_this_iter account_ids_to_check ;","counters":[]},{"line":"            return (diff, proof_count') )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"      in","counters":[]},{"line":"      (*Should have enough blocks to generate at least expected_proof_count","counters":[]},{"line":"        proofs*)","counters":[]},{"line":"      if Option.is_some expected_proof_count then","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        assert (total_ledger_proofs = Option.value_exn expected_proof_count)","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"","counters":[]},{"line":"    (* How many blocks do we need to fully exercise the ledger","counters":[]},{"line":"       behavior and produce one ledger proof *)","counters":[]},{"line":"    let min_blocks_for_first_snarked_ledger_generic =","counters":[]},{"line":"      (constraint_constants.transaction_capacity_log_2 + 1)","counters":[]},{"line":"      * (constraint_constants.work_delay + 1)","counters":[]},{"line":"      + 1","counters":[]},{"line":"","counters":[]},{"line":"    (* n-1 extra blocks for n ledger proofs since we are already producing one","counters":[]},{"line":"       proof *)","counters":[]},{"line":"    let max_blocks_for_coverage n =","counters":[]},{"line":"      min_blocks_for_first_snarked_ledger_generic + n - 1","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    (** Generator for when we always have enough commands to fill all slots. *)","counters":[]},{"line":"","counters":[]},{"line":"    let gen_at_capacity :","counters":[]},{"line":"        (Ledger.init_state * User_command.Valid.t list * int option list)","counters":[]},{"line":"        Quickcheck.Generator.t =","counters":[]},{"line":"      let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"      let%bind ledger_init_state = Ledger.gen_initial_ledger_state in","counters":[]},{"line":"      let%bind iters = Int.gen_incl 1 (max_blocks_for_coverage 0) in","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"      let num_cmds = transaction_capacity * iters in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%bind cmds =","counters":[]},{"line":"        User_command.Valid.Gen.sequence ~length:num_cmds ~sign_type:`Real","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"          ledger_init_state","counters":[]},{"line":"      in","counters":[]},{"line":"      assert (List.length cmds = num_cmds) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"      return (ledger_init_state, cmds, List.init iters ~f:(Fn.const None))","counters":[{"col_start":47,"col_end":47,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"","counters":[]},{"line":"    let gen_zkapps ?failure ~num_zkapps iters :","counters":[]},{"line":"        (Ledger.t * User_command.Valid.t list * int option list)","counters":[]},{"line":"        Quickcheck.Generator.t =","counters":[]},{"line":"      let open Quickcheck.Generator.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%bind zkapp_command_and_fee_payer_keypairs, ledger =","counters":[]},{"line":"        Mina_generators.User_command_generators","counters":[]},{"line":"        .sequence_zkapp_command_with_ledger ~max_token_updates:1","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"          ~length:num_zkapps ~vk ?failure ()","counters":[]},{"line":"      in","counters":[]},{"line":"      let zkapps =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        List.map zkapp_command_and_fee_payer_keypairs ~f:(function","counters":[]},{"line":"          | Zkapp_command zkapp_command_valid, _fee_payer_keypair, keymap ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let zkapp_command_with_auths =","counters":[]},{"line":"                Async.Thread_safe.block_on_async_exn (fun () ->","counters":[]},{"line":"                    Zkapp_command_builder.replace_authorizations ~keymap","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      (Zkapp_command.Valid.forget zkapp_command_valid) )","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"              in","counters":[]},{"line":"              let valid_zkapp_command_with_auths : Zkapp_command.Valid.t =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                match","counters":[]},{"line":"                  Zkapp_command.Valid.to_valid zkapp_command_with_auths ~ledger","counters":[]},{"line":"                    ~get:Ledger.get","counters":[]},{"line":"                    ~location_of_account:Ledger.location_of_account","counters":[]},{"line":"                with","counters":[]},{"line":"                | Some ps ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    ps","counters":[]},{"line":"                | None ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    failwith \"Could not create Zkapp_command.Valid.t\"","counters":[]},{"line":"              in","counters":[]},{"line":"              User_command.Zkapp_command valid_zkapp_command_with_auths","counters":[]},{"line":"          | Signed_command _, _, _ ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              failwith \"Expected a Zkapp_command, got a Signed command\" )","counters":[]},{"line":"      in","counters":[]},{"line":"      assert (List.length zkapps = num_zkapps) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"      return (ledger, zkapps, List.init iters ~f:(Fn.const None))","counters":[{"col_start":38,"col_end":38,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"","counters":[]},{"line":"    let gen_failing_zkapps_at_capacity :","counters":[]},{"line":"        (Ledger.t * User_command.Valid.t list * int option list)","counters":[]},{"line":"        Quickcheck.Generator.t =","counters":[]},{"line":"      let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"      let%bind iters = Int.gen_incl 1 (max_blocks_for_coverage 0) in","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"      let num_zkapps = transaction_capacity * iters in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      gen_zkapps","counters":[]},{"line":"        ~failure:","counters":[]},{"line":"          Mina_generators.Zkapp_command_generators.Invalid_account_precondition","counters":[]},{"line":"        ~num_zkapps iters","counters":[]},{"line":"","counters":[]},{"line":"    let gen_zkapps_at_capacity :","counters":[]},{"line":"        (Ledger.t * User_command.Valid.t list * int option list)","counters":[]},{"line":"        Quickcheck.Generator.t =","counters":[]},{"line":"      let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"      let%bind iters = Int.gen_incl 1 (max_blocks_for_coverage 0) in","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"      let num_zkapps = transaction_capacity * iters in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      gen_zkapps ~num_zkapps iters","counters":[]},{"line":"","counters":[]},{"line":"    let gen_zkapps_below_capacity ?(extra_blocks = false) () :","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"        (Ledger.t * User_command.Valid.t list * int option list)","counters":[]},{"line":"        Quickcheck.Generator.t =","counters":[]},{"line":"      let open Quickcheck.Generator.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let iters_max =","counters":[]},{"line":"        max_blocks_for_coverage 0 * if extra_blocks then 4 else 2","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":57,"col_end":57,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"      in","counters":[]},{"line":"      let%bind iters = Int.gen_incl 1 iters_max in","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"      (* see comment in gen_below_capacity for rationale *)","counters":[]},{"line":"      let%bind zkapps_per_iter =","counters":[]},{"line":"        Quickcheck.Generator.list_with_length iters","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"          (Int.gen_incl 1 ((transaction_capacity / 2) - 1))","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"      in","counters":[]},{"line":"      let num_zkapps = List.fold zkapps_per_iter ~init:0 ~f:( + ) in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      gen_zkapps ~num_zkapps iters","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    (*Same as gen_at_capacity except that the number of iterations[iters] is","counters":[]},{"line":"      the function of [extra_block_count] and is same for all generated values*)","counters":[]},{"line":"    let gen_at_capacity_fixed_blocks extra_block_count :","counters":[]},{"line":"        (Ledger.init_state * User_command.Valid.t list * int option list)","counters":[]},{"line":"        Quickcheck.Generator.t =","counters":[]},{"line":"      let open Quickcheck.Generator.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%bind ledger_init_state = Ledger.gen_initial_ledger_state in","counters":[]},{"line":"      let iters = max_blocks_for_coverage extra_block_count in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let total_cmds = transaction_capacity * iters in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%bind cmds =","counters":[]},{"line":"        User_command.Valid.Gen.sequence ~length:total_cmds ~sign_type:`Real","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"          ledger_init_state","counters":[]},{"line":"      in","counters":[]},{"line":"      assert (List.length cmds = total_cmds) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"      return (ledger_init_state, cmds, List.init iters ~f:(Fn.const None))","counters":[{"col_start":47,"col_end":47,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"","counters":[]},{"line":"    (* Generator for when we have less commands than needed to fill all slots. *)","counters":[]},{"line":"    let gen_below_capacity ?(extra_blocks = false) () =","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"      let open Quickcheck.Generator.Let_syntax in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%bind ledger_init_state = Ledger.gen_initial_ledger_state in","counters":[]},{"line":"      let iters_max =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        max_blocks_for_coverage 0 * if extra_blocks then 4 else 2","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":57,"col_end":57,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"      in","counters":[]},{"line":"      let%bind iters = Int.gen_incl 1 iters_max in","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"      (* N.B. user commands per block is much less than transactions per block","counters":[]},{"line":"         due to fee transfers and coinbases, especially with worse case number","counters":[]},{"line":"         of provers, so in order to exercise not filling the scan state","counters":[]},{"line":"         completely we always apply <= 1/2 transaction_capacity commands.","counters":[]},{"line":"      *)","counters":[]},{"line":"      let%bind cmds_per_iter =","counters":[]},{"line":"        Quickcheck.Generator.list_with_length iters","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"          (Int.gen_incl 1 ((transaction_capacity / 2) - 1))","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"      in","counters":[]},{"line":"      let total_cmds = List.fold cmds_per_iter ~init:0 ~f:( + ) in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let%bind cmds =","counters":[]},{"line":"        User_command.Valid.Gen.sequence ~length:total_cmds ~sign_type:`Real","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"          ledger_init_state","counters":[]},{"line":"      in","counters":[]},{"line":"      assert (List.length cmds = total_cmds) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"      return (ledger_init_state, cmds, List.map ~f:Option.some cmds_per_iter)","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"Max throughput-ledger proof count-fixed blocks\" =","counters":[]},{"line":"      let expected_proof_count = 3 in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Quickcheck.test (gen_at_capacity_fixed_blocks expected_proof_count)","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"        ~sexp_of:","counters":[]},{"line":"          [%sexp_of:","counters":[]},{"line":"            Ledger.init_state","counters":[]},{"line":"            * Mina_base.User_command.Valid.t list","counters":[]},{"line":"            * int option list] ~trials:1","counters":[]},{"line":"        ~f:(fun (ledger_init_state, cmds, iters) ->","counters":[]},{"line":"          async_with_ledgers ledger_init_state (fun sl test_mask ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              test_simple","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (init_pks ledger_init_state)","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                cmds iters sl ~expected_proof_count:(Some expected_proof_count)","counters":[]},{"line":"                test_mask `Many_provers stmt_to_work_random_prover ) )","counters":[]},{"line":"","counters":[]},{"line":"    let%test_unit \"Max throughput\" =","counters":[]},{"line":"      Quickcheck.test gen_at_capacity","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ~sexp_of:","counters":[]},{"line":"          [%sexp_of:","counters":[]},{"line":"            Ledger.init_state","counters":[]},{"line":"            * Mina_base.User_command.Valid.t list","counters":[]},{"line":"            * int option list] ~trials:15","counters":[]},{"line":"        ~f:(fun (ledger_init_state, cmds, iters) ->","counters":[]},{"line":"          async_with_ledgers ledger_init_state (fun sl test_mask ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              test_simple","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (init_pks ledger_init_state)","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                cmds iters sl test_mask `Many_provers stmt_to_work_random_prover ) )","counters":[]},{"line":"","counters":[]},{"line":"    let%test_unit \"Max_throughput (zkapps)\" =","counters":[]},{"line":"      (* limit trials to prevent too-many-open-files failure *)","counters":[]},{"line":"      Quickcheck.test ~trials:3 gen_zkapps_at_capacity","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ~f:(fun (ledger, zkapps, iters) ->","counters":[]},{"line":"          async_with_given_ledger ledger (fun sl test_mask ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              let account_ids =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Ledger.accounts ledger |> Account_id.Set.to_list","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"              in","counters":[]},{"line":"              test_simple account_ids zkapps iters sl test_mask `Many_provers","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                stmt_to_work_random_prover ) )","counters":[]},{"line":"","counters":[]},{"line":"    let%test_unit \"Max_throughput with zkApp transactions that may fail\" =","counters":[]},{"line":"      (* limit trials to prevent too-many-open-files failure *)","counters":[]},{"line":"      Quickcheck.test ~trials:2 gen_failing_zkapps_at_capacity","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ~f:(fun (ledger, zkapps, iters) ->","counters":[]},{"line":"          async_with_given_ledger ledger (fun sl test_mask ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              let account_ids =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Ledger.accounts ledger |> Account_id.Set.to_list","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"              in","counters":[]},{"line":"              test_simple account_ids zkapps iters ~allow_failures:true sl","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                test_mask `Many_provers stmt_to_work_random_prover ) )","counters":[]},{"line":"","counters":[]},{"line":"    let%test_unit \"Be able to include random number of commands\" =","counters":[]},{"line":"      Quickcheck.test (gen_below_capacity ()) ~trials:20","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"        ~f:(fun (ledger_init_state, cmds, iters) ->","counters":[]},{"line":"          async_with_ledgers ledger_init_state (fun sl test_mask ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              test_simple","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (init_pks ledger_init_state)","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                cmds iters sl test_mask `Many_provers stmt_to_work_random_prover ) )","counters":[]},{"line":"","counters":[]},{"line":"    let%test_unit \"Be able to include random number of commands (zkapps)\" =","counters":[]},{"line":"      Quickcheck.test (gen_zkapps_below_capacity ()) ~trials:4","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"        ~f:(fun (ledger, zkapps, iters) ->","counters":[]},{"line":"          async_with_given_ledger ledger (fun sl test_mask ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              let account_ids =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Ledger.accounts ledger |> Account_id.Set.to_list","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"              in","counters":[]},{"line":"              test_simple account_ids zkapps iters sl test_mask `Many_provers","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                stmt_to_work_random_prover ) )","counters":[]},{"line":"","counters":[]},{"line":"    let%test_unit \"Be able to include random number of commands (One prover)\" =","counters":[]},{"line":"      Quickcheck.test (gen_below_capacity ()) ~trials:20","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"        ~f:(fun (ledger_init_state, cmds, iters) ->","counters":[]},{"line":"          async_with_ledgers ledger_init_state (fun sl test_mask ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              test_simple","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (init_pks ledger_init_state)","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                cmds iters sl test_mask `One_prover stmt_to_work_one_prover ) )","counters":[]},{"line":"","counters":[]},{"line":"    let%test_unit \"Be able to include random number of commands (One prover, \\","counters":[]},{"line":"                   zkapps)\" =","counters":[]},{"line":"      Quickcheck.test (gen_zkapps_below_capacity ()) ~trials:4","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"        ~f:(fun (ledger, zkapps, iters) ->","counters":[]},{"line":"          async_with_given_ledger ledger (fun sl test_mask ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              let account_ids =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Ledger.accounts ledger |> Account_id.Set.to_list","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"              in","counters":[]},{"line":"              test_simple account_ids zkapps iters sl test_mask `One_prover","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                stmt_to_work_one_prover ) )","counters":[]},{"line":"","counters":[]},{"line":"    let%test_unit \"Zero proof-fee should not create a fee transfer\" =","counters":[]},{"line":"      let stmt_to_work_zero_fee stmts =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Some","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          { Transaction_snark_work.Checked.fee = Currency.Fee.zero","counters":[]},{"line":"          ; proofs = proofs stmts","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"          ; prover = snark_worker_pk","counters":[]},{"line":"          }","counters":[]},{"line":"      in","counters":[]},{"line":"      let expected_proof_count = 3 in","counters":[]},{"line":"      Quickcheck.test (gen_at_capacity_fixed_blocks expected_proof_count)","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"        ~trials:20 ~f:(fun (ledger_init_state, cmds, iters) ->","counters":[]},{"line":"          async_with_ledgers ledger_init_state (fun sl test_mask ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              let%map () =","counters":[]},{"line":"                test_simple ~expected_proof_count:(Some expected_proof_count)","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                  (init_pks ledger_init_state)","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                  cmds iters sl test_mask `One_prover stmt_to_work_zero_fee","counters":[]},{"line":"              in","counters":[]},{"line":"              assert (","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                Option.is_none","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                  (Ledger.location_of_account test_mask","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"                     (Account_id.create snark_worker_pk Token_id.default) ) ) ) )","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"","counters":[]},{"line":"    let compute_statuses ~ledger ~coinbase_amount diff =","counters":[]},{"line":"      let generate_status =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let module Transaction_validator =","counters":[]},{"line":"          Transaction_snark.Transaction_validator","counters":[]},{"line":"        in","counters":[]},{"line":"        let status_ledger = Transaction_validator.create ledger in","counters":[]},{"line":"        fun txn ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          O1trace.sync_thread \"get_transactin_status\" (fun () ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              Transaction_validator.apply_transaction ~constraint_constants","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                status_ledger ~txn_state_view:(dummy_state_view ()) txn )","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"      in","counters":[]},{"line":"      Pre_diff_info.compute_statuses ~constraint_constants ~diff","counters":[]},{"line":"        ~coinbase_amount ~coinbase_receiver ~generate_status ~forget:Fn.id","counters":[]},{"line":"      |> Result.map_error ~f:Pre_diff_info.Error.to_error","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"      |> Or_error.ok_exn","counters":[]},{"line":"","counters":[]},{"line":"    let%test_unit \"Invalid diff test: check zero fee excess for partitions\" =","counters":[]},{"line":"      let create_diff_with_non_zero_fee_excess ~ledger ~coinbase_amount txns","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          completed_works (partition : Sl.Scan_state.Space_partition.t) :","counters":[]},{"line":"          Staged_ledger_diff.t =","counters":[]},{"line":"        (*With exact number of user commands in partition.first, the fee transfers that settle the fee_excess would be added to the next tree causing a non-zero fee excess*)","counters":[]},{"line":"        let slots, job_count1 = partition.first in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        match partition.second with","counters":[]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            { diff =","counters":[]},{"line":"                compute_statuses ~ledger ~coinbase_amount","counters":[{"col_start":56,"col_end":56,"count":0}]},{"line":"                @@ ( { completed_works = List.take completed_works job_count1","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"                     ; commands = List.take txns slots","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"                     ; coinbase = Zero","counters":[]},{"line":"                     ; internal_command_statuses = []","counters":[]},{"line":"                     }","counters":[]},{"line":"                   , None )","counters":[]},{"line":"            }","counters":[]},{"line":"        | Some (_, _) ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let txns_in_second_diff = List.drop txns slots in","counters":[]},{"line":"            let diff : Staged_ledger_diff.Diff.t =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              ( { completed_works = List.take completed_works job_count1","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"                ; commands = List.take txns slots","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                ; coinbase = Zero","counters":[]},{"line":"                ; internal_command_statuses = []","counters":[]},{"line":"                }","counters":[]},{"line":"              , Some","counters":[]},{"line":"                  { completed_works =","counters":[]},{"line":"                      ( if List.is_empty txns_in_second_diff then []","counters":[{"col_start":66,"col_end":66,"count":0}]},{"line":"                      else List.drop completed_works job_count1 )","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"                  ; commands = txns_in_second_diff","counters":[]},{"line":"                  ; coinbase = Zero","counters":[]},{"line":"                  ; internal_command_statuses = []","counters":[]},{"line":"                  } )","counters":[]},{"line":"            in","counters":[]},{"line":"            { diff = compute_statuses ~ledger ~coinbase_amount diff }","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"      in","counters":[]},{"line":"      let empty_diff = Staged_ledger_diff.empty_diff in","counters":[]},{"line":"      Quickcheck.test gen_at_capacity","counters":[]},{"line":"        ~sexp_of:","counters":[]},{"line":"          [%sexp_of:","counters":[]},{"line":"            Ledger.init_state * User_command.Valid.t list * int option list]","counters":[]},{"line":"        ~trials:10 ~f:(fun (ledger_init_state, cmds, iters) ->","counters":[]},{"line":"          async_with_ledgers ledger_init_state (fun sl _test_mask ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              let%map checked =","counters":[]},{"line":"                iter_cmds_acc cmds iters true","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                  (fun _cmds_left _count_opt cmds_this_iter checked ->","counters":[]},{"line":"                    let scan_state = Sl.scan_state !sl in","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                    let work =","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      Sl.Scan_state.work_statements_for_new_diff scan_state","counters":[]},{"line":"                    in","counters":[]},{"line":"                    let partitions =","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      Sl.Scan_state.partition_if_overflowing scan_state","counters":[]},{"line":"                    in","counters":[]},{"line":"                    let work_done =","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      List.map","counters":[]},{"line":"                        ~f:(fun stmts ->","counters":[]},{"line":"                          { Transaction_snark_work.Checked.fee = Fee.zero","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                          ; proofs = proofs stmts","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"                          ; prover = snark_worker_pk","counters":[]},{"line":"                          } )","counters":[]},{"line":"                        work","counters":[]},{"line":"                    in","counters":[]},{"line":"                    let cmds_this_iter =","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      cmds_this_iter |> Sequence.to_list","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"                      |> List.map ~f:(fun cmd ->","counters":[]},{"line":"                             { With_status.data = User_command.forget_check cmd","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":74,"col_end":74,"count":0}]},{"line":"                             ; status = Applied","counters":[]},{"line":"                             } )","counters":[]},{"line":"                    in","counters":[]},{"line":"                    let diff =","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      create_diff_with_non_zero_fee_excess","counters":[]},{"line":"                        ~ledger:(Sl.ledger !sl)","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"                        ~coinbase_amount:constraint_constants.coinbase_amount","counters":[]},{"line":"                        cmds_this_iter work_done partitions","counters":[]},{"line":"                    in","counters":[]},{"line":"                    let%bind apply_res =","counters":[]},{"line":"                      Sl.apply ~constraint_constants !sl diff ~logger ~verifier","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                        ~current_state_view:(dummy_state_view ())","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"                        ~state_and_body_hash:","counters":[]},{"line":"                          (State_hash.dummy, State_body_hash.dummy)","counters":[]},{"line":"                        ~coinbase_receiver ~supercharge_coinbase:true","counters":[]},{"line":"                    in","counters":[]},{"line":"                    let checked', diff' =","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      match apply_res with","counters":[]},{"line":"                      | Error (Sl.Staged_ledger_error.Non_zero_fee_excess _) ->","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          (true, empty_diff)","counters":[]},{"line":"                      | Error err ->","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          failwith","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"                          @@ sprintf","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                               !\"Expecting Non-zero-fee-excess error, got \\","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                                 %{sexp: Sl.Staged_ledger_error.t}\"","counters":[]},{"line":"                               err","counters":[]},{"line":"                      | Ok","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          ( `Hash_after_applying _hash","counters":[]},{"line":"                          , `Ledger_proof _ledger_proof","counters":[]},{"line":"                          , `Staged_ledger sl'","counters":[]},{"line":"                          , `Pending_coinbase_update _ ) ->","counters":[]},{"line":"                          sl := sl' ;","counters":[]},{"line":"                          (false, diff)","counters":[]},{"line":"                    in","counters":[]},{"line":"                    return (diff', checked || checked') )","counters":[{"col_start":41,"col_end":41,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"              in","counters":[]},{"line":"              (*Note: if this fails, try increasing the number of trials to get a diff that does fail*)","counters":[]},{"line":"              assert checked ) )","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"Provers can't pay the account creation fee\" =","counters":[]},{"line":"      let no_work_included (diff : Staged_ledger_diff.t) =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        List.is_empty (Staged_ledger_diff.completed_works diff)","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"      in","counters":[]},{"line":"      let stmt_to_work stmts =","counters":[]},{"line":"        let prover = stmt_to_prover stmts in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Some","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          { Transaction_snark_work.Checked.fee =","counters":[]},{"line":"              Currency.Fee.(sub work_fee (of_int 1)) |> Option.value_exn","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":47,"col_end":47,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"          ; proofs = proofs stmts","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"          ; prover","counters":[]},{"line":"          }","counters":[]},{"line":"      in","counters":[]},{"line":"      Quickcheck.test (gen_below_capacity ())","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"        ~sexp_of:","counters":[]},{"line":"          [%sexp_of:","counters":[]},{"line":"            Ledger.init_state * User_command.Valid.t list * int option list]","counters":[]},{"line":"        ~shrinker:","counters":[]},{"line":"          (Quickcheck.Shrinker.create (fun (init_state, cmds, iters) ->","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"               if List.length iters > 1 then","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"                 Sequence.singleton","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                   ( init_state","counters":[]},{"line":"                   , List.take cmds (List.length cmds - transaction_capacity)","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"                   , [ None ] )","counters":[]},{"line":"               else Sequence.empty ) )","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"        ~trials:1","counters":[]},{"line":"        ~f:(fun (ledger_init_state, cmds, iters) ->","counters":[]},{"line":"          async_with_ledgers ledger_init_state (fun sl _test_mask ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              iter_cmds_acc cmds iters ()","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (fun _cmds_left _count_opt cmds_this_iter () ->","counters":[]},{"line":"                  let diff =","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    let diff_result =","counters":[]},{"line":"                      Sl.create_diff ~constraint_constants !sl ~logger","counters":[]},{"line":"                        ~current_state_view:(dummy_state_view ())","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"                        ~transactions_by_fee:cmds_this_iter","counters":[]},{"line":"                        ~get_completed_work:stmt_to_work ~coinbase_receiver","counters":[]},{"line":"                        ~supercharge_coinbase:true","counters":[]},{"line":"                    in","counters":[]},{"line":"                    match diff_result with","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                    | Ok (diff, _invalid_txns) ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        Staged_ledger_diff.forget diff","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"                    | Error e ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        Error.raise (Pre_diff_info.Error.to_error e)","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"                  in","counters":[]},{"line":"                  (*No proofs were purchased since the fee for the proofs are not sufficient to pay for account creation*)","counters":[]},{"line":"                  assert (no_work_included diff) ;","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"                  Deferred.return (diff, ()) ) ) )","counters":[]},{"line":"","counters":[]},{"line":"    let stmt_to_work_restricted work_list provers","counters":[]},{"line":"        (stmts : Transaction_snark_work.Statement.t) :","counters":[]},{"line":"        Transaction_snark_work.Checked.t option =","counters":[]},{"line":"      let prover =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        match provers with","counters":[]},{"line":"        | `Many_provers ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            stmt_to_prover stmts","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"        | `One_prover ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            snark_worker_pk","counters":[]},{"line":"      in","counters":[]},{"line":"      if","counters":[]},{"line":"        Option.is_some","counters":[]},{"line":"          (List.find work_list ~f:(fun s ->","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"               Transaction_snark_work.Statement.compare s stmts = 0 ) )","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"      then","counters":[]},{"line":"        Some","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          { Transaction_snark_work.Checked.fee = work_fee","counters":[]},{"line":"          ; proofs = proofs stmts","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"          ; prover","counters":[]},{"line":"          }","counters":[]},{"line":"      else None","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"","counters":[]},{"line":"    (** Like test_simple but with a random number of completed jobs available.","counters":[]},{"line":"           *)","counters":[]},{"line":"","counters":[]},{"line":"    let test_random_number_of_proofs :","counters":[]},{"line":"           Ledger.init_state","counters":[]},{"line":"        -> User_command.Valid.t list","counters":[]},{"line":"        -> int option list","counters":[]},{"line":"        -> int list","counters":[]},{"line":"        -> Sl.t ref","counters":[]},{"line":"        -> Ledger.Mask.Attached.t","counters":[]},{"line":"        -> [ `One_prover | `Many_provers ]","counters":[]},{"line":"        -> unit Deferred.t =","counters":[]},{"line":"     fun init_state cmds cmd_iters proofs_available sl test_mask provers ->","counters":[]},{"line":"      let%map proofs_available_left =","counters":[]},{"line":"        iter_cmds_acc cmds cmd_iters proofs_available","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"          (fun cmds_left _count_opt cmds_this_iter proofs_available_left ->","counters":[]},{"line":"            let work_list : Transaction_snark_work.Statement.t list =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Transaction_snark_scan_state.all_work_statements_exn","counters":[{"col_start":65,"col_end":65,"count":0}]},{"line":"                !sl.scan_state","counters":[]},{"line":"            in","counters":[]},{"line":"            let proofs_available_this_iter =","counters":[]},{"line":"              List.hd_exn proofs_available_left","counters":[]},{"line":"            in","counters":[]},{"line":"            let%map proof, diff =","counters":[]},{"line":"              create_and_apply sl cmds_this_iter","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                (stmt_to_work_restricted","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"                   (List.take work_list proofs_available_this_iter)","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                   provers )","counters":[]},{"line":"            in","counters":[]},{"line":"            assert_fee_excess proof ;","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let cmds_applied_this_iter =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              List.length @@ Staged_ledger_diff.commands diff","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"            in","counters":[]},{"line":"            let cb = coinbase_count diff in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            assert (proofs_available_this_iter = 0 || cb > 0) ;","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":49,"col_end":49,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"            ( match provers with","counters":[]},{"line":"            | `One_prover ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                assert (cb <= 1)","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"            | `Many_provers ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                assert (cb <= 2) ) ;","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"            let coinbase_cost = coinbase_cost diff in","counters":[]},{"line":"            assert_ledger test_mask ~coinbase_cost !sl cmds_left","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              cmds_applied_this_iter (init_pks init_state) ;","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"            (diff, List.tl_exn proofs_available_left) )","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"      in","counters":[]},{"line":"      assert (List.is_empty proofs_available_left)","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"max throughput-random number of proofs-worst case provers\" =","counters":[]},{"line":"      (* Always at worst case number of provers *)","counters":[]},{"line":"      let g =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"        let%bind ledger_init_state, cmds, iters = gen_at_capacity in","counters":[]},{"line":"        (* How many proofs will be available at each iteration. *)","counters":[]},{"line":"        let%bind proofs_available =","counters":[]},{"line":"          (* I think in the worst case every user command begets 1.5","counters":[]},{"line":"             transactions - one for the command and half of one for a fee","counters":[]},{"line":"             transfer - and the merge overhead means you need (amortized) twice","counters":[]},{"line":"             as many SNARKs as transactions, but since a SNARK work usually","counters":[]},{"line":"             covers two SNARKS it cancels. So we need to admit up to (1.5 * the","counters":[]},{"line":"             number of commands) works. I make it twice as many for simplicity","counters":[]},{"line":"             and to cover coinbases. *)","counters":[]},{"line":"          Quickcheck_lib.map_gens iters ~f:(fun _ ->","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"              Int.gen_incl 0 (transaction_capacity * 2) )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"        in","counters":[]},{"line":"        return (ledger_init_state, cmds, iters, proofs_available)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      in","counters":[]},{"line":"      Quickcheck.test g ~trials:10","counters":[]},{"line":"        ~f:(fun (ledger_init_state, cmds, iters, proofs_available) ->","counters":[]},{"line":"          async_with_ledgers ledger_init_state (fun sl test_mask ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              test_random_number_of_proofs ledger_init_state cmds iters","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                proofs_available sl test_mask `Many_provers ) )","counters":[]},{"line":"","counters":[]},{"line":"    let%test_unit \"random no of transactions-random number of proofs-worst \\","counters":[]},{"line":"                   case provers\" =","counters":[]},{"line":"      let g =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"        let%bind ledger_init_state, cmds, iters =","counters":[]},{"line":"          gen_below_capacity ~extra_blocks:true ()","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"        in","counters":[]},{"line":"        let%bind proofs_available =","counters":[]},{"line":"          Quickcheck_lib.map_gens iters ~f:(fun cmds_opt ->","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"              Int.gen_incl 0 (3 * Option.value_exn cmds_opt) )","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"        in","counters":[]},{"line":"        return (ledger_init_state, cmds, iters, proofs_available)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      in","counters":[]},{"line":"      let shrinker =","counters":[]},{"line":"        Quickcheck.Shrinker.create","counters":[]},{"line":"          (fun (ledger_init_state, cmds, iters, proofs_available) ->","counters":[]},{"line":"            let all_but_last xs = List.take xs (List.length xs - 1) in","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"            let iter_count = List.length iters in","counters":[]},{"line":"            let mod_iters iters' =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              ( ledger_init_state","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              , List.take cmds","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                @@ List.sum (module Int) iters' ~f:(Option.value ~default:0)","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"              , iters'","counters":[]},{"line":"              , List.take proofs_available (List.length iters') )","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"            in","counters":[]},{"line":"            let half_iters =","counters":[]},{"line":"              if iter_count > 1 then","counters":[]},{"line":"                Some (mod_iters (List.take iters (iter_count / 2)))","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"              else None","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"            in","counters":[]},{"line":"            let one_less_iters =","counters":[]},{"line":"              if iter_count > 2 then Some (mod_iters (all_but_last iters))","counters":[{"col_start":37,"col_end":37,"count":0},{"col_start":51,"col_end":51,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"              else None","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"            in","counters":[]},{"line":"            List.filter_map [ half_iters; one_less_iters ] ~f:Fn.id","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"            |> Sequence.of_list )","counters":[]},{"line":"      in","counters":[]},{"line":"      Quickcheck.test g ~shrinker ~shrink_attempts:`Exhaustive","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ~sexp_of:","counters":[]},{"line":"          [%sexp_of:","counters":[]},{"line":"            Ledger.init_state","counters":[]},{"line":"            * User_command.Valid.t list","counters":[]},{"line":"            * int option list","counters":[]},{"line":"            * int list] ~trials:50","counters":[]},{"line":"        ~f:(fun (ledger_init_state, cmds, iters, proofs_available) ->","counters":[]},{"line":"          async_with_ledgers ledger_init_state (fun sl test_mask ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              test_random_number_of_proofs ledger_init_state cmds iters","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                proofs_available sl test_mask `Many_provers ) )","counters":[]},{"line":"","counters":[]},{"line":"    let%test_unit \"Random number of commands-random number of proofs-one \\","counters":[]},{"line":"                   prover)\" =","counters":[]},{"line":"      let g =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"        let%bind ledger_init_state, cmds, iters =","counters":[]},{"line":"          gen_below_capacity ~extra_blocks:true ()","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"        in","counters":[]},{"line":"        let%bind proofs_available =","counters":[]},{"line":"          Quickcheck_lib.map_gens iters ~f:(fun cmds_opt ->","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"              Int.gen_incl 0 (3 * Option.value_exn cmds_opt) )","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"        in","counters":[]},{"line":"        return (ledger_init_state, cmds, iters, proofs_available)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      in","counters":[]},{"line":"      Quickcheck.test g ~trials:10","counters":[]},{"line":"        ~f:(fun (ledger_init_state, cmds, iters, proofs_available) ->","counters":[]},{"line":"          async_with_ledgers ledger_init_state (fun sl test_mask ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              test_random_number_of_proofs ledger_init_state cmds iters","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                proofs_available sl test_mask `One_prover ) )","counters":[]},{"line":"","counters":[]},{"line":"    let stmt_to_work_random_fee work_list provers","counters":[]},{"line":"        (stmts : Transaction_snark_work.Statement.t) :","counters":[]},{"line":"        Transaction_snark_work.Checked.t option =","counters":[]},{"line":"      let prover =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        match provers with","counters":[]},{"line":"        | `Many_provers ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            stmt_to_prover stmts","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"        | `One_prover ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            snark_worker_pk","counters":[]},{"line":"      in","counters":[]},{"line":"      Option.map","counters":[]},{"line":"        (List.find work_list ~f:(fun (s, _) ->","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"             Transaction_snark_work.Statement.compare s stmts = 0 ) )","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"        ~f:(fun (_, fee) ->","counters":[]},{"line":"          { Transaction_snark_work.Checked.fee; proofs = proofs stmts; prover }","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"          )","counters":[]},{"line":"","counters":[]},{"line":"    (** Like test_random_number_of_proofs but with random proof fees.","counters":[]},{"line":"           *)","counters":[]},{"line":"    let test_random_proof_fee :","counters":[]},{"line":"           Ledger.init_state","counters":[]},{"line":"        -> User_command.Valid.t list","counters":[]},{"line":"        -> int option list","counters":[]},{"line":"        -> (int * Fee.t list) list","counters":[]},{"line":"        -> Sl.t ref","counters":[]},{"line":"        -> Ledger.Mask.Attached.t","counters":[]},{"line":"        -> [ `One_prover | `Many_provers ]","counters":[]},{"line":"        -> unit Deferred.t =","counters":[]},{"line":"     fun _init_state cmds cmd_iters proofs_available sl _test_mask provers ->","counters":[]},{"line":"      let%map proofs_available_left =","counters":[]},{"line":"        iter_cmds_acc cmds cmd_iters proofs_available","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"          (fun _cmds_left _count_opt cmds_this_iter proofs_available_left ->","counters":[]},{"line":"            let work_list : Transaction_snark_work.Statement.t list =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Sl.Scan_state.work_statements_for_new_diff (Sl.scan_state !sl)","counters":[{"col_start":55,"col_end":55,"count":0},{"col_start":70,"col_end":70,"count":0}]},{"line":"            in","counters":[]},{"line":"            let proofs_available_this_iter, fees_for_each =","counters":[]},{"line":"              List.hd_exn proofs_available_left","counters":[]},{"line":"            in","counters":[]},{"line":"            let work_to_be_done =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let work_list = List.take work_list proofs_available_this_iter in","counters":[]},{"line":"              List.(zip_exn work_list (take fees_for_each (length work_list)))","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":42,"col_end":42,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"            in","counters":[]},{"line":"            let%map _proof, diff =","counters":[]},{"line":"              create_and_apply sl cmds_this_iter","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                (stmt_to_work_random_fee work_to_be_done provers)","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"            in","counters":[]},{"line":"            let sorted_work_from_diff1","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"                (pre_diff :","counters":[]},{"line":"                  Staged_ledger_diff.Pre_diff_with_at_most_two_coinbase.t ) =","counters":[]},{"line":"              List.sort pre_diff.completed_works ~compare:(fun w w' ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                  Fee.compare w.fee w'.fee )","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"            in","counters":[]},{"line":"            let sorted_work_from_diff2","counters":[]},{"line":"                (pre_diff :","counters":[]},{"line":"                  Staged_ledger_diff.Pre_diff_with_at_most_one_coinbase.t option","counters":[]},{"line":"                  ) =","counters":[]},{"line":"              Option.value_map pre_diff ~default:[] ~f:(fun p ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                  List.sort p.completed_works ~compare:(fun w w' ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                      Fee.compare w.fee w'.fee ) )","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"            in","counters":[]},{"line":"            let () =","counters":[]},{"line":"              let assert_same_fee { Coinbase.Fee_transfer.fee; _ } fee' =","counters":[]},{"line":"                assert (Fee.equal fee fee')","counters":[{"col_start":23,"col_end":23,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"              in","counters":[]},{"line":"              let first_pre_diff, second_pre_diff_opt = diff.diff in","counters":[]},{"line":"              match","counters":[]},{"line":"                ( first_pre_diff.coinbase","counters":[]},{"line":"                , Option.value_map second_pre_diff_opt","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"                    ~default:Staged_ledger_diff.At_most_one.Zero ~f:(fun d ->","counters":[]},{"line":"                      d.coinbase ) )","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"              with","counters":[]},{"line":"              | ( Staged_ledger_diff.At_most_two.Zero","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                , Staged_ledger_diff.At_most_one.Zero )","counters":[]},{"line":"              | Two None, Zero ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  ()","counters":[]},{"line":"              | One ft_opt, Zero ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Option.value_map ft_opt ~default:() ~f:(fun single ->","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"                      let work =","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        List.hd_exn (sorted_work_from_diff1 first_pre_diff)","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"                        |> Transaction_snark_work.forget","counters":[]},{"line":"                      in","counters":[]},{"line":"                      assert_same_fee single work.fee )","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"              | Zero, One ft_opt ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Option.value_map ft_opt ~default:() ~f:(fun single ->","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"                      let work =","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        List.hd_exn (sorted_work_from_diff2 second_pre_diff_opt)","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"                        |> Transaction_snark_work.forget","counters":[]},{"line":"                      in","counters":[]},{"line":"                      assert_same_fee single work.fee )","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"              | Two (Some (ft, ft_opt)), Zero ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  let work_done = sorted_work_from_diff1 first_pre_diff in","counters":[]},{"line":"                  let work =","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    List.hd_exn work_done |> Transaction_snark_work.forget","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                  in","counters":[]},{"line":"                  assert_same_fee ft work.fee ;","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  Option.value_map ft_opt ~default:() ~f:(fun single ->","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":33,"col_end":33,"count":0}]},{"line":"                      let work =","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        List.hd_exn (List.drop work_done 1)","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"                        |> Transaction_snark_work.forget","counters":[]},{"line":"                      in","counters":[]},{"line":"                      assert_same_fee single work.fee )","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"              | _ ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  failwith","counters":[]},{"line":"                    (sprintf","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                       !\"Incorrect coinbase in the diff %{sexp: \\","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                         Staged_ledger_diff.t}\"","counters":[]},{"line":"                       diff )","counters":[]},{"line":"            in","counters":[]},{"line":"            (diff, List.tl_exn proofs_available_left) )","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"      in","counters":[]},{"line":"      assert (List.is_empty proofs_available_left)","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"max throughput-random-random fee-number of proofs-worst \\","counters":[]},{"line":"                   case provers\" =","counters":[]},{"line":"      (* Always at worst case number of provers *)","counters":[]},{"line":"      let g =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"        let%bind ledger_init_state, cmds, iters = gen_at_capacity in","counters":[]},{"line":"        (* How many proofs will be available at each iteration. *)","counters":[]},{"line":"        let%bind proofs_available =","counters":[]},{"line":"          Quickcheck_lib.map_gens iters ~f:(fun _ ->","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"              let%bind number_of_proofs =","counters":[]},{"line":"                Int.gen_incl 0 (transaction_capacity * 2)","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"              in","counters":[]},{"line":"              let%map fees =","counters":[]},{"line":"                Quickcheck.Generator.list_with_length number_of_proofs","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"                  Fee.(gen_incl (of_int 1) (of_int 20))","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"              in","counters":[]},{"line":"              (number_of_proofs, fees) )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"        in","counters":[]},{"line":"        return (ledger_init_state, cmds, iters, proofs_available)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      in","counters":[]},{"line":"      Quickcheck.test g ~trials:10","counters":[]},{"line":"        ~f:(fun (ledger_init_state, cmds, iters, proofs_available) ->","counters":[]},{"line":"          async_with_ledgers ledger_init_state (fun sl test_mask ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              test_random_proof_fee ledger_init_state cmds iters","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                proofs_available sl test_mask `Many_provers ) )","counters":[]},{"line":"","counters":[]},{"line":"    let%test_unit \"Max throughput-random fee\" =","counters":[]},{"line":"      let g =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"        let%bind ledger_init_state, cmds, iters = gen_at_capacity in","counters":[]},{"line":"        let%bind proofs_available =","counters":[]},{"line":"          Quickcheck_lib.map_gens iters ~f:(fun _ ->","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"              let number_of_proofs =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                transaction_capacity","counters":[]},{"line":"                (*All proofs are available*)","counters":[]},{"line":"              in","counters":[]},{"line":"              let%map fees =","counters":[]},{"line":"                Quickcheck.Generator.list_with_length number_of_proofs","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"                  Fee.(gen_incl (of_int 1) (of_int 20))","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"              in","counters":[]},{"line":"              (number_of_proofs, fees) )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"        in","counters":[]},{"line":"        return (ledger_init_state, cmds, iters, proofs_available)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      in","counters":[]},{"line":"      Quickcheck.test g","counters":[]},{"line":"        ~sexp_of:","counters":[]},{"line":"          [%sexp_of:","counters":[]},{"line":"            Ledger.init_state","counters":[]},{"line":"            * Mina_base.User_command.Valid.t list","counters":[]},{"line":"            * int option list","counters":[]},{"line":"            * (int * Fee.t list) list] ~trials:10","counters":[]},{"line":"        ~f:(fun (ledger_init_state, cmds, iters, proofs_available) ->","counters":[]},{"line":"          async_with_ledgers ledger_init_state (fun sl test_mask ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              test_random_proof_fee ledger_init_state cmds iters","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                proofs_available sl test_mask `Many_provers ) )","counters":[]},{"line":"","counters":[]},{"line":"    let check_pending_coinbase ~supercharge_coinbase proof ~sl_before ~sl_after","counters":[]},{"line":"        (_state_hash, state_body_hash) pc_update ~is_new_stack =","counters":[]},{"line":"      let pending_coinbase_before = Sl.pending_coinbase_collection sl_before in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let root_before = Pending_coinbase.merkle_root pending_coinbase_before in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let unchecked_root_after =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Pending_coinbase.merkle_root (Sl.pending_coinbase_collection sl_after)","counters":[{"col_start":67,"col_end":67,"count":0}]},{"line":"      in","counters":[]},{"line":"      let f_pop_and_add () =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let open Snark_params.Tick in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let open Pending_coinbase in","counters":[]},{"line":"        let proof_emitted =","counters":[]},{"line":"          if Option.is_some proof then Boolean.true_ else Boolean.false_","counters":[{"col_start":39,"col_end":39,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"        in","counters":[]},{"line":"        let%bind root_after_popping, _deleted_stack =","counters":[]},{"line":"          Pending_coinbase.Checked.pop_coinbases ~constraint_constants","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"            ~proof_emitted","counters":[]},{"line":"            (Hash.var_of_t root_before)","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"        in","counters":[]},{"line":"        let pc_update_var = Update.var_of_t pc_update in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let coinbase_receiver =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Public_key.Compressed.(var_of_t coinbase_receiver)","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"        in","counters":[]},{"line":"        let supercharge_coinbase = Boolean.var_of_value supercharge_coinbase in","counters":[]},{"line":"        let state_body_hash_var = State_body_hash.var_of_t state_body_hash in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Pending_coinbase.Checked.add_coinbase ~constraint_constants","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          root_after_popping pc_update_var ~coinbase_receiver","counters":[]},{"line":"          ~supercharge_coinbase state_body_hash_var","counters":[]},{"line":"      in","counters":[]},{"line":"      let checked_root_after_update =","counters":[]},{"line":"        let open Snark_params.Tick in","counters":[]},{"line":"        let open Pending_coinbase in","counters":[]},{"line":"        let comp =","counters":[]},{"line":"          let%map result =","counters":[]},{"line":"            handle f_pop_and_add","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"              (unstage","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                 (handler ~depth:constraint_constants.pending_coinbase_depth","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                    pending_coinbase_before ~is_new_stack ) )","counters":[]},{"line":"          in","counters":[]},{"line":"          As_prover.read Hash.typ result","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        in","counters":[]},{"line":"        let x = Or_error.ok_exn (run_and_check comp) in","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"        x","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      in","counters":[]},{"line":"      [%test_eq: Pending_coinbase.Hash.t] unchecked_root_after","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"        checked_root_after_update","counters":[]},{"line":"","counters":[]},{"line":"    let test_pending_coinbase :","counters":[]},{"line":"           Ledger.init_state","counters":[]},{"line":"        -> User_command.Valid.t list","counters":[]},{"line":"        -> int option list","counters":[]},{"line":"        -> int list","counters":[]},{"line":"        -> (State_hash.t * State_body_hash.t) list","counters":[]},{"line":"        -> Mina_base.Zkapp_precondition.Protocol_state.View.t","counters":[]},{"line":"        -> Sl.t ref","counters":[]},{"line":"        -> Ledger.Mask.Attached.t","counters":[]},{"line":"        -> [ `One_prover | `Many_provers ]","counters":[]},{"line":"        -> unit Deferred.t =","counters":[]},{"line":"     fun init_state cmds cmd_iters proofs_available state_body_hashes","counters":[]},{"line":"         current_state_view sl test_mask provers ->","counters":[]},{"line":"      let%map proofs_available_left, _state_body_hashes_left =","counters":[]},{"line":"        iter_cmds_acc cmds cmd_iters (proofs_available, state_body_hashes)","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"          (fun","counters":[]},{"line":"            cmds_left","counters":[]},{"line":"            _count_opt","counters":[]},{"line":"            cmds_this_iter","counters":[]},{"line":"            (proofs_available_left, state_body_hashes)","counters":[]},{"line":"          ->","counters":[]},{"line":"            let work_list : Transaction_snark_work.Statement.t list =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Sl.Scan_state.all_work_statements_exn !sl.scan_state","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"            in","counters":[]},{"line":"            let proofs_available_this_iter =","counters":[]},{"line":"              List.hd_exn proofs_available_left","counters":[]},{"line":"            in","counters":[]},{"line":"            let sl_before = !sl in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let state_body_hash = List.hd_exn state_body_hashes in","counters":[]},{"line":"            let%map proof, diff, is_new_stack, pc_update, supercharge_coinbase =","counters":[]},{"line":"              create_and_apply_with_state_body_hash ~current_state_view","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                ~state_and_body_hash:state_body_hash sl cmds_this_iter","counters":[]},{"line":"                (stmt_to_work_restricted","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"                   (List.take work_list proofs_available_this_iter)","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                   provers )","counters":[]},{"line":"            in","counters":[]},{"line":"            check_pending_coinbase proof ~supercharge_coinbase ~sl_before","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              ~sl_after:!sl state_body_hash pc_update ~is_new_stack ;","counters":[]},{"line":"            assert_fee_excess proof ;","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            let cmds_applied_this_iter =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              List.length @@ Staged_ledger_diff.commands diff","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"            in","counters":[]},{"line":"            let cb = coinbase_count diff in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            assert (proofs_available_this_iter = 0 || cb > 0) ;","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":49,"col_end":49,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"            ( match provers with","counters":[]},{"line":"            | `One_prover ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                assert (cb <= 1)","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"            | `Many_provers ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                assert (cb <= 2) ) ;","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"            let coinbase_cost = coinbase_cost diff in","counters":[]},{"line":"            assert_ledger test_mask ~coinbase_cost !sl cmds_left","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              cmds_applied_this_iter (init_pks init_state) ;","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"            ( diff","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            , (List.tl_exn proofs_available_left, List.tl_exn state_body_hashes)","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"            ) )","counters":[]},{"line":"      in","counters":[]},{"line":"      assert (List.is_empty proofs_available_left)","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"","counters":[]},{"line":"    let pending_coinbase_test prover =","counters":[]},{"line":"      let g =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"        let%bind ledger_init_state, cmds, iters =","counters":[]},{"line":"          gen_below_capacity ~extra_blocks:true ()","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"        in","counters":[]},{"line":"        let%bind state_body_hashes =","counters":[]},{"line":"          Quickcheck_lib.map_gens iters ~f:(fun _ ->","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"              Quickcheck.Generator.tuple2 State_hash.gen State_body_hash.gen )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"        in","counters":[]},{"line":"        let%bind proofs_available =","counters":[]},{"line":"          Quickcheck_lib.map_gens iters ~f:(fun cmds_opt ->","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"              Int.gen_incl 0 (3 * Option.value_exn cmds_opt) )","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"        in","counters":[]},{"line":"        return","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          (ledger_init_state, cmds, iters, proofs_available, state_body_hashes)","counters":[]},{"line":"      in","counters":[]},{"line":"      let current_state_view = dummy_state_view () in","counters":[]},{"line":"      Quickcheck.test g ~trials:5","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ~f:(fun","counters":[]},{"line":"             ( ledger_init_state","counters":[]},{"line":"             , cmds","counters":[]},{"line":"             , iters","counters":[]},{"line":"             , proofs_available","counters":[]},{"line":"             , state_body_hashes )","counters":[]},{"line":"           ->","counters":[]},{"line":"          async_with_ledgers ledger_init_state (fun sl test_mask ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              test_pending_coinbase ledger_init_state cmds iters","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                proofs_available state_body_hashes current_state_view sl","counters":[]},{"line":"                test_mask prover ) )","counters":[]},{"line":"","counters":[]},{"line":"    let%test_unit \"Validate pending coinbase for random number of \\","counters":[]},{"line":"                   commands-random number of proofs-one prover)\" =","counters":[]},{"line":"      pending_coinbase_test `One_prover","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"Validate pending coinbase for random number of \\","counters":[]},{"line":"                   commands-random number of proofs-many provers)\" =","counters":[]},{"line":"      pending_coinbase_test `Many_provers","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let timed_account n =","counters":[]},{"line":"      let keypair =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Quickcheck.random_value","counters":[]},{"line":"          ~seed:(`Deterministic (sprintf \"timed_account_%d\" n))","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"          Keypair.gen","counters":[]},{"line":"      in","counters":[]},{"line":"      let account_id =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Account_id.create","counters":[]},{"line":"          (Public_key.compress keypair.public_key)","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"          Token_id.default","counters":[]},{"line":"      in","counters":[]},{"line":"      let balance = Balance.of_int 100_000_000_000 in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      (*Should fully vest by slot = 7*)","counters":[]},{"line":"      let acc =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Account.create_timed account_id balance ~initial_minimum_balance:balance","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"          ~cliff_time:(Mina_numbers.Global_slot.of_int 4)","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"          ~cliff_amount:Amount.zero","counters":[]},{"line":"          ~vesting_period:(Mina_numbers.Global_slot.of_int 2)","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"          ~vesting_increment:(Amount.of_int 50_000_000_000)","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"        |> Or_error.ok_exn","counters":[]},{"line":"      in","counters":[]},{"line":"      (keypair, acc)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let untimed_account n =","counters":[]},{"line":"      let keypair =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Quickcheck.random_value","counters":[]},{"line":"          ~seed:(`Deterministic (sprintf \"untimed_account_%d\" n))","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"          Keypair.gen","counters":[]},{"line":"      in","counters":[]},{"line":"      let account_id =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Account_id.create","counters":[]},{"line":"          (Public_key.compress keypair.public_key)","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"          Token_id.default","counters":[]},{"line":"      in","counters":[]},{"line":"      let balance = Balance.of_int 100_000_000_000 in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let acc = Account.create account_id balance in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      (keypair, acc)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let supercharge_coinbase_test ~(self : Account.t) ~(delegator : Account.t)","counters":[]},{"line":"        ~block_count f_expected_balance sl =","counters":[]},{"line":"      let coinbase_receiver = self in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let init_balance = coinbase_receiver.balance in","counters":[]},{"line":"      let check_receiver_account sl count =","counters":[]},{"line":"        let location =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Ledger.location_of_account (Sl.ledger sl)","counters":[{"col_start":35,"col_end":35,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"            (Account.identifier coinbase_receiver)","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"          |> Option.value_exn","counters":[]},{"line":"        in","counters":[]},{"line":"        let account = Ledger.get (Sl.ledger sl) location |> Option.value_exn in","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"        [%test_eq: Balance.t]","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"          (f_expected_balance count init_balance)","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"          account.balance","counters":[]},{"line":"      in","counters":[]},{"line":"      Deferred.List.iter","counters":[]},{"line":"        (List.init block_count ~f:(( + ) 1))","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"        ~f:(fun block_count ->","counters":[]},{"line":"          let%bind _ =","counters":[]},{"line":"            create_and_apply_with_state_body_hash ~winner:delegator.public_key","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"              ~coinbase_receiver:coinbase_receiver.public_key sl","counters":[]},{"line":"              ~current_state_view:","counters":[]},{"line":"                (dummy_state_view","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                   ~global_slot_since_genesis:","counters":[]},{"line":"                     (Mina_numbers.Global_slot.of_int block_count)","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"                   () )","counters":[]},{"line":"              ~state_and_body_hash:(State_hash.dummy, State_body_hash.dummy)","counters":[]},{"line":"              Sequence.empty","counters":[]},{"line":"              (stmt_to_work_zero_fee ~prover:self.public_key)","counters":[]},{"line":"          in","counters":[]},{"line":"          check_receiver_account !sl block_count ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          return () )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"","counters":[]},{"line":"    let normal_coinbase = constraint_constants.coinbase_amount","counters":[]},{"line":"","counters":[]},{"line":"    let scale_exn amt i = Amount.scale amt i |> Option.value_exn","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"","counters":[]},{"line":"    let supercharged_coinbase =","counters":[]},{"line":"      scale_exn constraint_constants.coinbase_amount","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"        constraint_constants.supercharged_coinbase_factor","counters":[]},{"line":"","counters":[]},{"line":"    let g = Ledger.gen_initial_ledger_state","counters":[]},{"line":"","counters":[]},{"line":"    let%test_unit \"Supercharged coinbase - staking\" =","counters":[]},{"line":"      let keypair_self, self = timed_account 1 in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let slots_with_locked_tokens =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        7","counters":[]},{"line":"        (*calculated from the timing values for timed_accounts*)","counters":[]},{"line":"      in","counters":[]},{"line":"      let block_count = slots_with_locked_tokens + 5 in","counters":[]},{"line":"      let f_expected_balance block_no init_balance =","counters":[]},{"line":"        if block_no <= slots_with_locked_tokens then","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Balance.add_amount init_balance (scale_exn normal_coinbase block_no)","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"          |> Option.value_exn","counters":[]},{"line":"        else","counters":[]},{"line":"          (* init balance +","counters":[]},{"line":"                (normal_coinbase * slots_with_locked_tokens) +","counters":[]},{"line":"                (supercharged_coinbase * remaining slots))*)","counters":[]},{"line":"          Balance.add_amount","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"            ( Balance.add_amount init_balance","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                (scale_exn normal_coinbase slots_with_locked_tokens)","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"            |> Option.value_exn )","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"            (scale_exn supercharged_coinbase","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"               (block_no - slots_with_locked_tokens) )","counters":[]},{"line":"          |> Option.value_exn","counters":[]},{"line":"      in","counters":[]},{"line":"      Quickcheck.test g ~trials:1 ~f:(fun ledger_init_state ->","counters":[]},{"line":"          let ledger_init_state =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Array.append","counters":[]},{"line":"              [| ( keypair_self","counters":[]},{"line":"                 , Balance.to_amount self.balance","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                 , self.nonce","counters":[]},{"line":"                 , self.timing )","counters":[]},{"line":"              |]","counters":[]},{"line":"              ledger_init_state","counters":[]},{"line":"          in","counters":[]},{"line":"          async_with_ledgers ledger_init_state (fun sl _test_mask ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              supercharge_coinbase_test ~self ~delegator:self ~block_count","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                f_expected_balance sl ) )","counters":[]},{"line":"","counters":[]},{"line":"    let%test_unit \"Supercharged coinbase - unlocked account delegating to \\","counters":[]},{"line":"                   locked account\" =","counters":[]},{"line":"      let keypair_self, locked_self = timed_account 1 in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let keypair_delegator, unlocked_delegator = untimed_account 1 in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let slots_with_locked_tokens =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        7","counters":[]},{"line":"        (*calculated from the timing values for timed_accounts*)","counters":[]},{"line":"      in","counters":[]},{"line":"      let block_count = slots_with_locked_tokens + 2 in","counters":[]},{"line":"      let f_expected_balance block_no init_balance =","counters":[]},{"line":"        Balance.add_amount init_balance","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"          (scale_exn supercharged_coinbase block_no)","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"        |> Option.value_exn","counters":[]},{"line":"      in","counters":[]},{"line":"      Quickcheck.test g ~trials:1 ~f:(fun ledger_init_state ->","counters":[]},{"line":"          let ledger_init_state =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Array.append","counters":[]},{"line":"              [| ( keypair_self","counters":[]},{"line":"                 , Balance.to_amount locked_self.balance","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                 , locked_self.nonce","counters":[]},{"line":"                 , locked_self.timing )","counters":[]},{"line":"               ; ( keypair_delegator","counters":[]},{"line":"                 , Balance.to_amount unlocked_delegator.balance","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                 , unlocked_delegator.nonce","counters":[]},{"line":"                 , unlocked_delegator.timing )","counters":[]},{"line":"              |]","counters":[]},{"line":"              ledger_init_state","counters":[]},{"line":"          in","counters":[]},{"line":"          async_with_ledgers ledger_init_state (fun sl _test_mask ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              supercharge_coinbase_test ~self:locked_self","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ~delegator:unlocked_delegator ~block_count f_expected_balance sl ) )","counters":[]},{"line":"","counters":[]},{"line":"    let%test_unit \"Supercharged coinbase - locked account delegating to \\","counters":[]},{"line":"                   unlocked account\" =","counters":[]},{"line":"      let keypair_self, unlocked_self = untimed_account 1 in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let keypair_delegator, locked_delegator = timed_account 1 in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let slots_with_locked_tokens =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        7","counters":[]},{"line":"        (*calculated from the timing values for the timed_account*)","counters":[]},{"line":"      in","counters":[]},{"line":"      let block_count = slots_with_locked_tokens + 2 in","counters":[]},{"line":"      let f_expected_balance block_no init_balance =","counters":[]},{"line":"        if block_no <= slots_with_locked_tokens then","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Balance.add_amount init_balance (scale_exn normal_coinbase block_no)","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"          |> Option.value_exn","counters":[]},{"line":"        else","counters":[]},{"line":"          (* init balance +","counters":[]},{"line":"                (normal_coinbase * slots_with_locked_tokens) +","counters":[]},{"line":"                (supercharged_coinbase * remaining slots))*)","counters":[]},{"line":"          Balance.add_amount","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"            ( Balance.add_amount init_balance","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                (scale_exn normal_coinbase slots_with_locked_tokens)","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"            |> Option.value_exn )","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"            (scale_exn supercharged_coinbase","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"               (block_no - slots_with_locked_tokens) )","counters":[]},{"line":"          |> Option.value_exn","counters":[]},{"line":"      in","counters":[]},{"line":"      Quickcheck.test g ~trials:1 ~f:(fun ledger_init_state ->","counters":[]},{"line":"          let ledger_init_state =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Array.append","counters":[]},{"line":"              [| ( keypair_self","counters":[]},{"line":"                 , Balance.to_amount unlocked_self.balance","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                 , unlocked_self.nonce","counters":[]},{"line":"                 , unlocked_self.timing )","counters":[]},{"line":"               ; ( keypair_delegator","counters":[]},{"line":"                 , Balance.to_amount locked_delegator.balance","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                 , locked_delegator.nonce","counters":[]},{"line":"                 , locked_delegator.timing )","counters":[]},{"line":"              |]","counters":[]},{"line":"              ledger_init_state","counters":[]},{"line":"          in","counters":[]},{"line":"          async_with_ledgers ledger_init_state (fun sl _test_mask ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              supercharge_coinbase_test ~self:unlocked_self","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ~delegator:locked_delegator ~block_count f_expected_balance sl ) )","counters":[]},{"line":"","counters":[]},{"line":"    let%test_unit \"Supercharged coinbase - locked account delegating to locked \\","counters":[]},{"line":"                   account\" =","counters":[]},{"line":"      let keypair_self, locked_self = timed_account 1 in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let keypair_delegator, locked_delegator = timed_account 2 in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let slots_with_locked_tokens =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        7","counters":[]},{"line":"        (*calculated from the timing values for timed_accounts*)","counters":[]},{"line":"      in","counters":[]},{"line":"      let block_count = slots_with_locked_tokens in","counters":[]},{"line":"      let f_expected_balance block_no init_balance =","counters":[]},{"line":"        (*running the test as long as both the accounts remain locked and hence normal coinbase in all the blocks*)","counters":[]},{"line":"        Balance.add_amount init_balance (scale_exn normal_coinbase block_no)","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"        |> Option.value_exn","counters":[]},{"line":"      in","counters":[]},{"line":"      Quickcheck.test g ~trials:1 ~f:(fun ledger_init_state ->","counters":[]},{"line":"          let ledger_init_state =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Array.append","counters":[]},{"line":"              [| ( keypair_self","counters":[]},{"line":"                 , Balance.to_amount locked_self.balance","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                 , locked_self.nonce","counters":[]},{"line":"                 , locked_self.timing )","counters":[]},{"line":"               ; ( keypair_delegator","counters":[]},{"line":"                 , Balance.to_amount locked_delegator.balance","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                 , locked_delegator.nonce","counters":[]},{"line":"                 , locked_delegator.timing )","counters":[]},{"line":"              |]","counters":[]},{"line":"              ledger_init_state","counters":[]},{"line":"          in","counters":[]},{"line":"          async_with_ledgers ledger_init_state (fun sl _test_mask ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              supercharge_coinbase_test ~self:locked_self","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ~delegator:locked_delegator ~block_count f_expected_balance sl ) )","counters":[]},{"line":"","counters":[]},{"line":"    let command_insufficient_funds =","counters":[]},{"line":"      let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"      let%map ledger_init_state = Ledger.gen_initial_ledger_state in","counters":[]},{"line":"      let kp, balance, nonce, _ = ledger_init_state.(0) in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let receiver_pk =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Quickcheck.random_value ~seed:(`Deterministic \"receiver_pk\")","counters":[]},{"line":"          Public_key.Compressed.gen","counters":[]},{"line":"      in","counters":[]},{"line":"      let insufficient_account_creation_fee =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Currency.Fee.to_int constraint_constants.account_creation_fee / 2","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"        |> Currency.Amount.of_int","counters":[]},{"line":"      in","counters":[]},{"line":"      let source_pk = Public_key.compress kp.public_key in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let body =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Signed_command_payload.Body.Payment","counters":[]},{"line":"          Payment_payload.Poly.","counters":[]},{"line":"            { source_pk","counters":[]},{"line":"            ; receiver_pk","counters":[]},{"line":"            ; amount = insufficient_account_creation_fee","counters":[]},{"line":"            }","counters":[]},{"line":"      in","counters":[]},{"line":"      let fee = Currency.Amount.to_fee balance in","counters":[]},{"line":"      let payload =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Signed_command.Payload.create ~fee ~fee_payer_pk:source_pk ~nonce","counters":[]},{"line":"          ~memo:Signed_command_memo.dummy ~valid_until:None ~body","counters":[]},{"line":"      in","counters":[]},{"line":"      let signed_command =","counters":[]},{"line":"        User_command.Signed_command (Signed_command.sign kp payload)","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"      in","counters":[]},{"line":"      (ledger_init_state, signed_command)","counters":[]},{"line":"","counters":[]},{"line":"    let%test_unit \"Commands with Insufficient funds are not included\" =","counters":[]},{"line":"      let logger = Logger.null () in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Quickcheck.test command_insufficient_funds ~trials:1","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ~f:(fun (ledger_init_state, invalid_command) ->","counters":[]},{"line":"          async_with_ledgers ledger_init_state (fun sl _test_mask ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              let diff_result =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Sl.create_diff ~constraint_constants !sl ~logger","counters":[]},{"line":"                  ~current_state_view:(dummy_state_view ())","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"                  ~transactions_by_fee:(Sequence.of_list [ invalid_command ])","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"                  ~get_completed_work:(stmt_to_work_zero_fee ~prover:self_pk)","counters":[]},{"line":"                  ~coinbase_receiver ~supercharge_coinbase:false","counters":[]},{"line":"              in","counters":[]},{"line":"              ( match diff_result with","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              | Ok (diff, _invalid_txns) ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  assert (","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                    List.is_empty","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                      (Staged_ledger_diff.With_valid_signatures_and_proofs","counters":[]},{"line":"                       .commands diff ) )","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"              | Error e ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Error.raise (Pre_diff_info.Error.to_error e) ) ;","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"              Deferred.unit ) )","counters":[]},{"line":"","counters":[]},{"line":"    let%test_unit \"Blocks having commands with insufficient funds are rejected\"","counters":[]},{"line":"        =","counters":[]},{"line":"      let logger = Logger.create () in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let g =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"        let%map ledger_init_state = Ledger.gen_initial_ledger_state in","counters":[]},{"line":"        let command (kp : Keypair.t) (balance : Currency.Amount.t)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            (nonce : Account.Nonce.t) (validity : [ `Valid | `Invalid ]) =","counters":[]},{"line":"          let receiver_pk =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Quickcheck.random_value ~seed:(`Deterministic \"receiver_pk\")","counters":[]},{"line":"              Public_key.Compressed.gen","counters":[]},{"line":"          in","counters":[]},{"line":"          let account_creation_fee, fee =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            match validity with","counters":[]},{"line":"            | `Valid ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                let account_creation_fee =","counters":[]},{"line":"                  constraint_constants.account_creation_fee","counters":[]},{"line":"                  |> Currency.Amount.of_fee","counters":[]},{"line":"                in","counters":[]},{"line":"                ( account_creation_fee","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                , Currency.Amount.to_fee","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"                    ( Currency.Amount.sub balance account_creation_fee","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"                    |> Option.value_exn ) )","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"            | `Invalid ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (* Not enough account creation fee and using full balance for fee*)","counters":[]},{"line":"                ( Currency.Fee.to_int constraint_constants.account_creation_fee","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"                  / 2","counters":[]},{"line":"                  |> Currency.Amount.of_int","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"                , Currency.Amount.to_fee balance )","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"          in","counters":[]},{"line":"          let source_pk = Public_key.compress kp.public_key in","counters":[]},{"line":"          let body =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Signed_command_payload.Body.Payment","counters":[]},{"line":"              Payment_payload.Poly.","counters":[]},{"line":"                { source_pk; receiver_pk; amount = account_creation_fee }","counters":[]},{"line":"          in","counters":[]},{"line":"          let payload =","counters":[]},{"line":"            Signed_command.Payload.create ~fee ~fee_payer_pk:source_pk ~nonce","counters":[]},{"line":"              ~memo:Signed_command_memo.dummy ~valid_until:None ~body","counters":[]},{"line":"          in","counters":[]},{"line":"          User_command.Signed_command (Signed_command.sign kp payload)","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"        in","counters":[]},{"line":"        let signed_command =","counters":[]},{"line":"          let kp, balance, nonce, _ = ledger_init_state.(0) in","counters":[]},{"line":"          command kp balance nonce `Valid","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":16,"col_end":16,"count":0}]},{"line":"        in","counters":[]},{"line":"        let invalid_command =","counters":[]},{"line":"          let kp, balance, nonce, _ = ledger_init_state.(1) in","counters":[]},{"line":"          command kp balance nonce `Invalid","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":16,"col_end":16,"count":0}]},{"line":"        in","counters":[]},{"line":"        (ledger_init_state, signed_command, invalid_command)","counters":[]},{"line":"      in","counters":[]},{"line":"      Quickcheck.test g ~trials:1","counters":[]},{"line":"        ~f:(fun (ledger_init_state, valid_command, invalid_command) ->","counters":[]},{"line":"          async_with_ledgers ledger_init_state (fun sl _test_mask ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              let diff_result =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Sl.create_diff ~constraint_constants !sl ~logger","counters":[]},{"line":"                  ~current_state_view:(dummy_state_view ())","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"                  ~transactions_by_fee:(Sequence.of_list [ valid_command ])","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"                  ~get_completed_work:(stmt_to_work_zero_fee ~prover:self_pk)","counters":[]},{"line":"                  ~coinbase_receiver ~supercharge_coinbase:false","counters":[]},{"line":"              in","counters":[]},{"line":"              match diff_result with","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              | Error e ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Error.raise (Pre_diff_info.Error.to_error e)","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"              | Ok (diff, _invalid_txns) -> (","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  assert (","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                    List.length","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                      (Staged_ledger_diff.With_valid_signatures_and_proofs","counters":[]},{"line":"                       .commands diff )","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                    = 1 ) ;","counters":[]},{"line":"                  let f, s = diff.diff in","counters":[]},{"line":"                  [%log info] \"Diff %s\"","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                    ( Staged_ledger_diff.With_valid_signatures_and_proofs","counters":[]},{"line":"                      .to_yojson diff","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                    |> Yojson.Safe.to_string ) ;","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"                  let failed_command =","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    With_status.","counters":[]},{"line":"                      { data = invalid_command","counters":[]},{"line":"                      ; status =","counters":[]},{"line":"                          Transaction_status.Failed","counters":[]},{"line":"                            Transaction_status.Failure.(","counters":[]},{"line":"                              Collection.of_single_failure","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"                                Amount_insufficient_to_create_account)","counters":[]},{"line":"                      }","counters":[]},{"line":"                  in","counters":[]},{"line":"                  (*Replace the valid command with an invalid command)*)","counters":[]},{"line":"                  let diff =","counters":[]},{"line":"                    { Staged_ledger_diff.With_valid_signatures_and_proofs.diff =","counters":[]},{"line":"                        ({ f with commands = [ failed_command ] }, s)","counters":[]},{"line":"                    }","counters":[]},{"line":"                  in","counters":[]},{"line":"                  let%map res =","counters":[]},{"line":"                    Sl.apply ~constraint_constants !sl","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                      (Staged_ledger_diff.forget diff)","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"                      ~logger ~verifier","counters":[]},{"line":"                      ~current_state_view:(dummy_state_view ())","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"                      ~state_and_body_hash:","counters":[]},{"line":"                        (State_hash.dummy, State_body_hash.dummy)","counters":[]},{"line":"                      ~coinbase_receiver ~supercharge_coinbase:false","counters":[]},{"line":"                  in","counters":[]},{"line":"                  match res with","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  | Ok _x ->","counters":[]},{"line":"                      assert false","counters":[]},{"line":"                  (*TODO: check transaction logic errors here. Verified that the error is here is [The source account has an insufficient balance]*)","counters":[]},{"line":"                  | Error (Staged_ledger_error.Unexpected _ as e) ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      [%log info] \"Error %s\" (Staged_ledger_error.to_string e) ;","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":74,"col_end":74,"count":0}]},{"line":"                      assert true","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                  | Error _ ->","counters":[]},{"line":"                      assert false ) ) )","counters":[]},{"line":"","counters":[]},{"line":"    let%test_unit \"Mismatched verification keys in zkApp accounts and \\","counters":[]},{"line":"                   transactions\" =","counters":[]},{"line":"      let open Transaction_snark.For_tests in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let gen =","counters":[]},{"line":"        let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"        let%bind test_spec = Mina_transaction_logic.For_tests.Test_spec.gen in","counters":[]},{"line":"        let pks =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Public_key.Compressed.Set.of_list","counters":[]},{"line":"            (List.map (Array.to_list test_spec.init_ledger) ~f:(fun s ->","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"                 Public_key.compress (fst s).public_key ) )","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"        in","counters":[]},{"line":"        let%map kp =","counters":[]},{"line":"          Quickcheck.Generator.filter Keypair.gen ~f:(fun kp ->","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"              not","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                (Public_key.Compressed.Set.mem pks","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"                   (Public_key.compress kp.public_key) ) )","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"        in","counters":[]},{"line":"        (test_spec, kp)","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      in","counters":[]},{"line":"      Quickcheck.test ~trials:1 gen","counters":[]},{"line":"        ~f:(fun ({ init_ledger; specs = _ }, new_kp) ->","counters":[]},{"line":"          let fee = Fee.of_int 1_000_000 in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let amount = Amount.of_int 10_000_000_000 in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let snapp_pk = Signature_lib.Public_key.compress new_kp.public_key in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let snapp_update =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            { Account_update.Update.dummy with","counters":[]},{"line":"              delegate = Zkapp_basic.Set_or_keep.Set snapp_pk","counters":[]},{"line":"            }","counters":[]},{"line":"          in","counters":[]},{"line":"          let memo = Signed_command_memo.dummy in","counters":[]},{"line":"          let test_spec : Update_states_spec.t =","counters":[]},{"line":"            { sender = (new_kp, Mina_base.Account.Nonce.zero)","counters":[]},{"line":"            ; fee","counters":[]},{"line":"            ; fee_payer = None","counters":[]},{"line":"            ; receivers = []","counters":[]},{"line":"            ; amount","counters":[]},{"line":"            ; zkapp_account_keypairs = [ new_kp ]","counters":[]},{"line":"            ; memo","counters":[]},{"line":"            ; new_zkapp_account = false","counters":[]},{"line":"            ; snapp_update","counters":[]},{"line":"            ; current_auth = Permissions.Auth_required.Proof","counters":[]},{"line":"            ; call_data = Snark_params.Tick.Field.zero","counters":[]},{"line":"            ; events = []","counters":[]},{"line":"            ; sequence_events = []","counters":[]},{"line":"            ; preconditions = None","counters":[]},{"line":"            }","counters":[]},{"line":"          in","counters":[]},{"line":"          Ledger.with_ledger ~depth:constraint_constants.ledger_depth","counters":[]},{"line":"            ~f:(fun ledger ->","counters":[]},{"line":"              Async.Thread_safe.block_on_async_exn (fun () ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                  Mina_transaction_logic.For_tests.Init_ledger.init","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    (module Ledger.Ledger_inner)","counters":[]},{"line":"                    init_ledger ledger ;","counters":[]},{"line":"                  (*create a snapp account*)","counters":[]},{"line":"                  let snapp_permissions =","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    let default = Permissions.user_default in","counters":[]},{"line":"                    { default with","counters":[]},{"line":"                      set_delegate = Permissions.Auth_required.Proof","counters":[]},{"line":"                    }","counters":[]},{"line":"                  in","counters":[]},{"line":"                  let snapp_account_id =","counters":[]},{"line":"                    Account_id.create snapp_pk Token_id.default","counters":[]},{"line":"                  in","counters":[]},{"line":"                  let dummy_vk =","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    let data = Pickles.Side_loaded.Verification_key.dummy in","counters":[]},{"line":"                    let hash = Zkapp_account.digest_vk data in","counters":[]},{"line":"                    ({ data; hash } : _ With_hash.t)","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                  in","counters":[]},{"line":"                  let valid_against_ledger =","counters":[]},{"line":"                    let new_mask =","counters":[]},{"line":"                      Ledger.Mask.create ~depth:(Ledger.depth ledger) ()","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"                    in","counters":[]},{"line":"                    let l = Ledger.register_mask ledger new_mask in","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                    Transaction_snark.For_tests.create_trivial_zkapp_account","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      ~permissions:snapp_permissions ~vk ~ledger:l snapp_pk ;","counters":[]},{"line":"                    l","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                  in","counters":[]},{"line":"                  let%bind zkapp_command =","counters":[]},{"line":"                    Transaction_snark.For_tests.update_states ~zkapp_prover","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"                      ~constraint_constants test_spec","counters":[]},{"line":"                  in","counters":[]},{"line":"                  let valid_zkapp_command =","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    Option.value_exn","counters":[]},{"line":"                      (Zkapp_command.Valid.to_valid ~ledger:valid_against_ledger","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                         ~get:Ledger.get","counters":[]},{"line":"                         ~location_of_account:Ledger.location_of_account","counters":[]},{"line":"                         zkapp_command )","counters":[]},{"line":"                  in","counters":[]},{"line":"                  ignore","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    (Ledger.unregister_mask_exn valid_against_ledger","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"                       ~loc:__LOC__ ) ;","counters":[]},{"line":"                  (*Different key in the staged ledger*)","counters":[]},{"line":"                  Transaction_snark.For_tests.create_trivial_zkapp_account","counters":[]},{"line":"                    ~permissions:snapp_permissions ~vk:dummy_vk ~ledger snapp_pk ;","counters":[]},{"line":"                  let open Async.Deferred.Let_syntax in","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  let sl = ref @@ Sl.create_exn ~constraint_constants ~ledger in","counters":[]},{"line":"                  let%bind _proof, diff =","counters":[]},{"line":"                    create_and_apply sl","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                      (Sequence.singleton","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"                         (User_command.Zkapp_command valid_zkapp_command) )","counters":[]},{"line":"                      stmt_to_work_one_prover","counters":[]},{"line":"                  in","counters":[]},{"line":"                  let commands = Staged_ledger_diff.commands diff in","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  (*Zkapp_command with incompatible vk should not be in the diff*)","counters":[]},{"line":"                  assert (List.is_empty commands) ;","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"                  (*Update the account to have correct vk*)","counters":[]},{"line":"                  let loc =","counters":[]},{"line":"                    Option.value_exn","counters":[]},{"line":"                      (Ledger.location_of_account ledger snapp_account_id)","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"                  in","counters":[]},{"line":"                  let account = Option.value_exn (Ledger.get ledger loc) in","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"                  Ledger.set ledger loc","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    { account with","counters":[]},{"line":"                      zkapp =","counters":[]},{"line":"                        Some","counters":[]},{"line":"                          { (Option.value_exn account.zkapp) with","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"                            verification_key = Some vk","counters":[]},{"line":"                          }","counters":[]},{"line":"                    } ;","counters":[]},{"line":"                  let sl = ref @@ Sl.create_exn ~constraint_constants ~ledger in","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  let%bind _proof, diff =","counters":[]},{"line":"                    create_and_apply sl","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                      (Sequence.singleton","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"                         (User_command.Zkapp_command valid_zkapp_command) )","counters":[]},{"line":"                      stmt_to_work_one_prover","counters":[]},{"line":"                  in","counters":[]},{"line":"                  let commands = Staged_ledger_diff.commands diff in","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  assert (List.length commands = 1) ;","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"                  match List.hd_exn commands with","counters":[]},{"line":"                  | { With_status.data = Zkapp_command _ps; status = Applied }","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                    ->","counters":[]},{"line":"                      return ()","counters":[]},{"line":"                  | { With_status.data = Zkapp_command _ps","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                    ; status = Failed tbl","counters":[]},{"line":"                    } ->","counters":[]},{"line":"                      failwith","counters":[]},{"line":"                        (sprintf \"Zkapp_command application failed %s\"","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                           ( Transaction_status.Failure.Collection.to_yojson tbl","counters":[{"col_start":75,"col_end":75,"count":0}]},{"line":"                           |> Yojson.Safe.to_string ) )","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                  | _ ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      failwith \"expecting zkapp_command transaction\" ) ) )","counters":[]},{"line":"  end )","counters":[{"col_start":6,"col_end":6,"count":1}]}]}