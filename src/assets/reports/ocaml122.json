{"filename":"src/lib/pickles/opt_sponge.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"(* This module implements snarky functions for a sponge that can *conditionally* absorb input,","counters":[]},{"line":"   while branching minimally. Specifically, if absorbing N field elements, this sponge can absorb","counters":[]},{"line":"   a variable subset of N field elements, while performing N + 1 invocations of the sponge's","counters":[]},{"line":"   underlying permutation. *)","counters":[]},{"line":"","counters":[]},{"line":"let m = 3","counters":[]},{"line":"","counters":[]},{"line":"let capacity = 1","counters":[]},{"line":"","counters":[]},{"line":"let rate = m - capacity","counters":[]},{"line":"","counters":[]},{"line":"type 'f sponge_state =","counters":[]},{"line":"  | Absorbing of","counters":[]},{"line":"      { next_index : 'f Snarky_backendless.Boolean.t","counters":[]},{"line":"      ; xs : ('f Snarky_backendless.Boolean.t * 'f) list","counters":[]},{"line":"      }","counters":[]},{"line":"  | Squeezed of int","counters":[]},{"line":"","counters":[]},{"line":"type 'f t =","counters":[]},{"line":"  { mutable state : 'f array","counters":[]},{"line":"  ; params : 'f Sponge.Params.t","counters":[]},{"line":"  ; needs_final_permute_if_empty : bool","counters":[]},{"line":"  ; mutable sponge_state : 'f sponge_state","counters":[]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"module Make","counters":[]},{"line":"    (Impl : Snarky_backendless.Snark_intf.Run)","counters":[]},{"line":"    (P : Sponge.Intf.Permutation with type Field.t = Impl.Field.t) =","counters":[]},{"line":"struct","counters":[]},{"line":"  open P","counters":[]},{"line":"  open Impl","counters":[]},{"line":"","counters":[]},{"line":"  type nonrec t = Field.t t","counters":[]},{"line":"","counters":[]},{"line":"  let state { state; _ } = Array.copy state","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"","counters":[]},{"line":"  let copy { state; params; sponge_state; needs_final_permute_if_empty } =","counters":[]},{"line":"    { state = Array.copy state","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"    ; params","counters":[]},{"line":"    ; sponge_state","counters":[]},{"line":"    ; needs_final_permute_if_empty","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let initial_state = Array.init m ~f:(fun _ -> Field.zero)","counters":[{"col_start":31,"col_end":31,"count":2},{"col_start":48,"col_end":48,"count":6}]},{"line":"","counters":[]},{"line":"  let of_sponge { Sponge.state; params; sponge_state } =","counters":[]},{"line":"    match sponge_state with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Squeezed n ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        { sponge_state = Squeezed n","counters":[]},{"line":"        ; state = Array.copy state","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"        ; needs_final_permute_if_empty = true","counters":[]},{"line":"        ; params","counters":[]},{"line":"        }","counters":[]},{"line":"    | Absorbed n -> (","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let abs i =","counters":[]},{"line":"          { sponge_state = Absorbing { next_index = i; xs = [] }","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          ; state = Array.copy state","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"          ; params","counters":[]},{"line":"          ; needs_final_permute_if_empty = true","counters":[]},{"line":"          }","counters":[]},{"line":"        in","counters":[]},{"line":"        match n with","counters":[]},{"line":"        | 0 ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            abs Boolean.false_","counters":[]},{"line":"        | 1 ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            abs Boolean.true_","counters":[]},{"line":"        | 2 ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            { sponge_state = Absorbing { next_index = Boolean.false_; xs = [] }","counters":[]},{"line":"            ; state = P.block_cipher params state","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"            ; needs_final_permute_if_empty = false","counters":[]},{"line":"            ; params","counters":[]},{"line":"            }","counters":[]},{"line":"        | _ ->","counters":[]},{"line":"            assert false )","counters":[]},{"line":"","counters":[]},{"line":"  let create ?(init = initial_state) params =","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"    { params","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    ; state = Array.copy init","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"    ; needs_final_permute_if_empty = true","counters":[]},{"line":"    ; sponge_state = Absorbing { next_index = Boolean.false_; xs = [] }","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let () = assert (rate = 2)","counters":[{"col_start":18,"col_end":18,"count":2}]},{"line":"","counters":[]},{"line":"  let add_in a i x =","counters":[]},{"line":"    let i_equals_0 = Boolean.not i in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let i_equals_1 = i in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    (*","counters":[]},{"line":"      a.(0) <- a.(0) + i_equals_0 * x","counters":[]},{"line":"      a.(1) <- a.(1) + i_equals_1 * x *)","counters":[]},{"line":"    List.iteri [ i_equals_0; i_equals_1 ] ~f:(fun j i_equals_j ->","counters":[]},{"line":"        let a_j' =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          exists Field.typ","counters":[]},{"line":"            ~compute:","counters":[]},{"line":"              As_prover.(","counters":[]},{"line":"                fun () ->","counters":[]},{"line":"                  let a_j = read Field.typ a.(j) in","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  if read Boolean.typ i_equals_j then","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    Field.Constant.(a_j + read Field.typ x)","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"                  else a_j)","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"        in","counters":[]},{"line":"        assert_r1cs x (i_equals_j :> Field.t) Field.(a_j' - a.(j)) ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        a.(j) <- a_j' )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"  let consume ~needs_final_permute_if_empty ~params ~start_pos input state =","counters":[]},{"line":"    assert (Array.length state = m) ;","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":11,"col_end":11,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"    let n = Array.length input in","counters":[]},{"line":"    let pos = ref start_pos in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let cond_permute permute =","counters":[]},{"line":"      let permuted = P.block_cipher params (Array.copy state) in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"      for i = 0 to m - 1 do","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        state.(i) <- Field.if_ permute ~then_:permuted.(i) ~else_:state.(i)","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"      done","counters":[]},{"line":"    in","counters":[]},{"line":"    let pairs = n / 2 in","counters":[]},{"line":"    let remaining = n - (2 * pairs) in","counters":[]},{"line":"    for i = 0 to pairs - 1 do","counters":[]},{"line":"      (* Semantically, we want to do this.","counters":[]},{"line":"         match b, b' with","counters":[]},{"line":"         | 1, 1 ->","counters":[]},{"line":"          if p = 0","counters":[]},{"line":"          then state := perm {state with .0 += x, .1 += y }","counters":[]},{"line":"          else state := {perm {state with .1 += x} with .0 += y}","counters":[]},{"line":"         | 1, 0 ->","counters":[]},{"line":"          if p = 0","counters":[]},{"line":"          then state := {state with .0 += x}","counters":[]},{"line":"          else state := perm {state with .1 += x}","counters":[]},{"line":"         | 0, 1 ->","counters":[]},{"line":"          if p = 0","counters":[]},{"line":"          then state := {state with .0 += y }","counters":[]},{"line":"          else state := perm {state with .1 += y}","counters":[]},{"line":"         | 0, 0 ->","counters":[]},{"line":"          state","counters":[]},{"line":"      *)","counters":[]},{"line":"      let b, x = input.(2 * i) in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let b', y = input.((2 * i) + 1) in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let p = !pos in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let p' = Boolean.( lxor ) p b in","counters":[]},{"line":"      pos := Boolean.( lxor ) p' b' ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"      let y = Field.(y * (b' :> t)) in","counters":[]},{"line":"      let add_in_y_after_perm =","counters":[]},{"line":"        (* post","counters":[]},{"line":"           add in","counters":[]},{"line":"           (1, 1, 1)","counters":[]},{"line":"","counters":[]},{"line":"           do not add in","counters":[]},{"line":"           (1, 1, 0)","counters":[]},{"line":"           (0, 1, 0)","counters":[]},{"line":"           (0, 1, 1)","counters":[]},{"line":"","counters":[]},{"line":"           (1, 0, 0)","counters":[]},{"line":"           (1, 0, 1)","counters":[]},{"line":"           (0, 0, 0)","counters":[]},{"line":"           (0, 0, 1)","counters":[]},{"line":"        *)","counters":[]},{"line":"        (* Only one case where we add in y after the permutation is applied *)","counters":[]},{"line":"        Boolean.all [ b; b'; p ]","counters":[]},{"line":"      in","counters":[]},{"line":"      let add_in_y_before_perm = Boolean.not add_in_y_after_perm in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      add_in state p Field.(x * (b :> t)) ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      add_in state p' Field.(y * (add_in_y_before_perm :> t)) ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let permute =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (* (b, b', p)","counters":[]},{"line":"            true:","counters":[]},{"line":"            (0, 1, 1)","counters":[]},{"line":"            (1, 0, 1)","counters":[]},{"line":"            (1, 1, 0)","counters":[]},{"line":"            (1, 1, 1)","counters":[]},{"line":"","counters":[]},{"line":"           false:","counters":[]},{"line":"            (0, 0, 0)","counters":[]},{"line":"            (0, 0, 1)","counters":[]},{"line":"            (0, 1, 0)","counters":[]},{"line":"            (1, 0, 0)","counters":[]},{"line":"        *)","counters":[]},{"line":"        (* (b && b') || (p && (b || b')) *)","counters":[]},{"line":"        Boolean.(any [ all [ b; b' ]; all [ p; b ||| b' ] ])","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":40,"col_end":40,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"      in","counters":[]},{"line":"      cond_permute permute ;","counters":[]},{"line":"      add_in state p' Field.(y * (add_in_y_after_perm :> t))","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":11,"col_end":11,"count":0}]},{"line":"    done ;","counters":[]},{"line":"    let empty_imput =","counters":[]},{"line":"      Boolean.not (Boolean.Array.any (Array.map input ~f:fst))","counters":[{"col_start":35,"col_end":35,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"    in","counters":[]},{"line":"    let should_permute =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      match remaining with","counters":[]},{"line":"      | 0 ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          if needs_final_permute_if_empty then Boolean.(empty_imput ||| !pos)","counters":[{"col_start":47,"col_end":47,"count":0},{"col_start":70,"col_end":70,"count":0}]},{"line":"          else !pos","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"      | 1 ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let b, x = input.(n - 1) in","counters":[]},{"line":"          let p = !pos in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          pos := Boolean.( lxor ) p b ;","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"          add_in state p Field.(x * (b :> t)) ;","counters":[]},{"line":"          if needs_final_permute_if_empty then Boolean.any [ p; b; empty_imput ]","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":47,"col_end":47,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"          else Boolean.any [ p; b ]","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"      | _ ->","counters":[]},{"line":"          assert false","counters":[]},{"line":"    in","counters":[]},{"line":"    cond_permute should_permute","counters":[]},{"line":"","counters":[]},{"line":"  let absorb (t : t) x =","counters":[]},{"line":"    match t.sponge_state with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Absorbing { next_index; xs } ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        t.sponge_state <- Absorbing { next_index; xs = x :: xs }","counters":[]},{"line":"    | Squeezed _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        t.sponge_state <- Absorbing { next_index = Boolean.false_; xs = [ x ] }","counters":[]},{"line":"","counters":[]},{"line":"  let squeeze (t : t) =","counters":[]},{"line":"    match t.sponge_state with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Squeezed n ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        if n = rate then (","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"          t.state <- block_cipher t.params t.state ;","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"          t.sponge_state <- Squeezed 1 ;","counters":[]},{"line":"          t.state.(0) )","counters":[]},{"line":"        else (","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"          t.sponge_state <- Squeezed (n + 1) ;","counters":[]},{"line":"          t.state.(n) )","counters":[]},{"line":"    | Absorbing { next_index; xs } ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        consume ~needs_final_permute_if_empty:t.needs_final_permute_if_empty","counters":[]},{"line":"          ~start_pos:next_index ~params:t.params (Array.of_list_rev xs) t.state ;","counters":[{"col_start":66,"col_end":66,"count":0}]},{"line":"        t.sponge_state <- Squeezed 1 ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        t.state.(0)","counters":[]},{"line":"","counters":[]},{"line":"  let%test_module \"opt_sponge\" =","counters":[]},{"line":"    ( module struct","counters":[]},{"line":"      module S = Sponge.Make_sponge (P)","counters":[]},{"line":"","counters":[]},{"line":"      let%test_unit \"correctness\" =","counters":[]},{"line":"        let params : _ Sponge.Params.t =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let a () =","counters":[]},{"line":"            Array.init 3 ~f:(fun _ -> Field.(constant (Constant.random ())))","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":38,"col_end":38,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"          in","counters":[]},{"line":"          { mds = Array.init 3 ~f:(fun _ -> a ())","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"          ; round_constants = Array.init 40 ~f:(fun _ -> a ())","counters":[{"col_start":39,"col_end":39,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"          }","counters":[]},{"line":"        in","counters":[]},{"line":"        let gen =","counters":[]},{"line":"          let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"          let%bind n = Quickcheck.Generator.small_positive_int","counters":[]},{"line":"          and n_pre = Quickcheck.Generator.small_positive_int in","counters":[]},{"line":"          let%map xs = List.gen_with_length n Field.Constant.gen","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"          and bs = List.gen_with_length n Bool.quickcheck_generator","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"          and pre = List.gen_with_length n_pre Field.Constant.gen in","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"          (pre, List.zip_exn bs xs)","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"        in","counters":[]},{"line":"        Quickcheck.test gen ~trials:10 ~f:(fun (pre, ps) ->","counters":[]},{"line":"            let filtered =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              List.filter_map ps ~f:(fun (b, x) -> if b then Some x else None)","counters":[{"col_start":51,"col_end":51,"count":0},{"col_start":61,"col_end":61,"count":0},{"col_start":73,"col_end":73,"count":0}]},{"line":"            in","counters":[]},{"line":"            let init () =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let pre =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                exists","counters":[]},{"line":"                  (Typ.list ~length:(List.length pre) Field.typ)","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"                  ~compute:(fun () -> pre)","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"              in","counters":[]},{"line":"              let s = S.create params in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              List.iter pre ~f:(S.absorb s) ;","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":39,"col_end":39,"count":0}]},{"line":"              s","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"            in","counters":[]},{"line":"            let filtered_res =","counters":[]},{"line":"              let n = List.length filtered in","counters":[]},{"line":"              Impl.Internal_Basic.Test.checked_to_unchecked","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"                (Typ.list ~length:n Field.typ)","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                Field.typ","counters":[]},{"line":"                (fun xs ->","counters":[]},{"line":"                  make_checked (fun () ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                      let s = init () in","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                      List.iter xs ~f:(S.absorb s) ;","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"                      S.squeeze s ) )","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                filtered","counters":[]},{"line":"            in","counters":[]},{"line":"            let opt_res =","counters":[]},{"line":"              let n = List.length ps in","counters":[]},{"line":"              Impl.Internal_Basic.Test.checked_to_unchecked","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"                (Typ.list ~length:n (Typ.tuple2 Boolean.typ Field.typ))","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"                Field.typ","counters":[]},{"line":"                (fun xs ->","counters":[]},{"line":"                  make_checked (fun () ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                      let s =","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        if List.length pre = 0 then create params","counters":[{"col_start":37,"col_end":37,"count":0},{"col_start":52,"col_end":52,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"                        else of_sponge (init ())","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"                      in","counters":[]},{"line":"                      List.iter xs ~f:(absorb s) ;","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"                      squeeze s ) )","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                ps","counters":[]},{"line":"            in","counters":[]},{"line":"            if not (Field.Constant.equal filtered_res opt_res) then","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"              failwithf","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                !\"hash(%{sexp:Field.Constant.t list}) = %{sexp:Field.Constant.t}\\n\\","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                  hash(%{sexp:(bool * Field.Constant.t) list}) = \\","counters":[]},{"line":"                  %{sexp:Field.Constant.t}\"","counters":[]},{"line":"                filtered filtered_res ps opt_res () )","counters":[]},{"line":"    end )","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}