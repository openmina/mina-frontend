{"filename":"src/lib/vrf_evaluator/vrf_evaluator.ml","lines":[{"line":"open Core","counters":[]},{"line":"open Async","counters":[]},{"line":"open Signature_lib","counters":[]},{"line":"module Epoch = Mina_numbers.Length","counters":[]},{"line":"module Global_slot = Mina_numbers.Global_slot","counters":[]},{"line":"","counters":[]},{"line":"module type CONTEXT = sig","counters":[]},{"line":"  val logger : Logger.t","counters":[]},{"line":"","counters":[]},{"line":"  val constraint_constants : Genesis_constants.Constraint_constants.t","counters":[]},{"line":"","counters":[]},{"line":"  val consensus_constants : Consensus.Constants.t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(*Slot number within an epoch*)","counters":[]},{"line":"module Slot = Mina_numbers.Global_slot","counters":[]},{"line":"","counters":[]},{"line":"(* Can extract both slot numbers and epoch number*)","counters":[]},{"line":"module Consensus_time = Consensus.Data.Consensus_time","counters":[]},{"line":"","counters":[]},{"line":"module Block_producer_keys = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    [@@@no_toplevel_latest_type]","counters":[]},{"line":"","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type t = (Keypair.Stable.V1.t * Public_key.Compressed.Stable.V1.t) list","counters":[{"col_start":6,"col_end":6,"count":2},{"col_start":11,"col_end":11,"count":1},{"col_start":16,"col_end":16,"count":0}]},{"line":"      [@@deriving sexp]","counters":[{"col_start":22,"col_end":22,"count":5}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  type t = Stable.Latest.t [@@deriving sexp]","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Evaluator_status = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    [@@@no_toplevel_latest_type]","counters":[]},{"line":"","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type t = At of Global_slot.Stable.V1.t | Completed","counters":[{"col_start":6,"col_end":6,"count":2},{"col_start":11,"col_end":11,"count":2},{"col_start":15,"col_end":15,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":55,"col_end":55,"count":5}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  type t = Stable.Latest.t = At of Global_slot.t | Completed [@@deriving sexp]","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Vrf_evaluation_result = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    [@@@no_toplevel_latest_type]","counters":[]},{"line":"","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type t =","counters":[{"col_start":6,"col_end":6,"count":2},{"col_start":11,"col_end":11,"count":2}]},{"line":"        { slots_won : Consensus.Data.Slot_won.Stable.V1.t list","counters":[]},{"line":"        ; evaluator_status : Evaluator_status.Stable.V1.t","counters":[]},{"line":"        }","counters":[{"col_start":8,"col_end":8,"count":5}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  type t = Stable.Latest.t =","counters":[]},{"line":"    { slots_won : Consensus.Data.Slot_won.t list","counters":[]},{"line":"    ; evaluator_status : Evaluator_status.t","counters":[]},{"line":"    }","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Worker_state = struct","counters":[]},{"line":"  type init_arg =","counters":[{"col_start":2,"col_end":2,"count":1},{"col_start":14,"col_end":14,"count":2}]},{"line":"    { constraint_constants : Genesis_constants.Constraint_constants.t","counters":[]},{"line":"    ; consensus_constants : Consensus.Constants.Stable.Latest.t","counters":[]},{"line":"    ; conf_dir : string","counters":[]},{"line":"    ; logger : Logger.Stable.Latest.t","counters":[]},{"line":"    }","counters":[]},{"line":"  [@@deriving bin_io_unversioned]","counters":[{"col_start":32,"col_end":32,"count":4}]},{"line":"","counters":[]},{"line":"  let context_of_config","counters":[]},{"line":"      ({ constraint_constants; consensus_constants; logger; conf_dir = _ } :","counters":[]},{"line":"        init_arg ) : (module CONTEXT) =","counters":[]},{"line":"    ( module struct","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let constraint_constants = constraint_constants","counters":[]},{"line":"","counters":[]},{"line":"      let consensus_constants = consensus_constants","counters":[]},{"line":"","counters":[]},{"line":"      let logger = logger","counters":[]},{"line":"    end )","counters":[]},{"line":"","counters":[]},{"line":"  type t =","counters":[]},{"line":"    { config : init_arg","counters":[]},{"line":"    ; mutable last_checked_slot_and_epoch :","counters":[]},{"line":"        (Epoch.t * Slot.t) Public_key.Compressed.Table.t","counters":[]},{"line":"    ; slots_won : Consensus.Data.Slot_won.t Queue.t","counters":[]},{"line":"          (*possibly multiple producers per slot*)","counters":[]},{"line":"    ; mutable current_slot : Global_slot.t option","counters":[]},{"line":"    ; mutable epoch_data :","counters":[]},{"line":"        unit Ivar.t * Consensus.Data.Epoch_data_for_vrf.t option","counters":[]},{"line":"    ; mutable block_producer_keys : Block_producer_keys.t","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let make_last_checked_slot_and_epoch_table old_table new_keys ~default =","counters":[]},{"line":"    let module Set = Public_key.Compressed.Set in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let module Table = Public_key.Compressed.Table in","counters":[]},{"line":"    let last_checked_slot_and_epoch = Table.create () in","counters":[]},{"line":"    List.iter new_keys ~f:(fun (_, pk) ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        let data = Option.value (Table.find old_table pk) ~default in","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"        Table.add_exn last_checked_slot_and_epoch ~key:pk ~data ) ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    last_checked_slot_and_epoch","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let seen_slot last_checked_slot_and_epoch epoch slot =","counters":[]},{"line":"    let module Table = Public_key.Compressed.Table in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let unseens =","counters":[]},{"line":"      Table.to_alist last_checked_slot_and_epoch","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"      |> List.filter_map ~f:(fun (pk, last_checked_epoch_and_slot) ->","counters":[]},{"line":"             let i =","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"               Tuple2.compare ~cmp1:Epoch.compare ~cmp2:Slot.compare","counters":[]},{"line":"                 last_checked_epoch_and_slot (epoch, slot)","counters":[]},{"line":"             in","counters":[]},{"line":"             if i > 0 then None","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"             else if i = 0 then","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"               (*vrf evaluation was stopped at this point because it was either the end of the epoch or the key won this slot; re-check this slot when staking keys are reset so that we don't skip producing block. This will not occur in the normal flow because [slot] will be greater than the last-checked-slot*)","counters":[]},{"line":"               Some pk","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"             else (","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"               Table.set last_checked_slot_and_epoch ~key:pk ~data:(epoch, slot) ;","counters":[]},{"line":"               Some pk ) )","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"    in","counters":[]},{"line":"    match unseens with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | [] ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        `All_seen","counters":[]},{"line":"    | nel ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        `Unseen (Public_key.Compressed.Set.of_list nel)","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"","counters":[]},{"line":"  let evaluate","counters":[]},{"line":"      ( { config","counters":[]},{"line":"        ; slots_won","counters":[]},{"line":"        ; block_producer_keys","counters":[]},{"line":"        ; epoch_data = interrupt_ivar, epoch_data","counters":[]},{"line":"        ; _","counters":[]},{"line":"        } as t ) : (unit, unit) Interruptible.t =","counters":[]},{"line":"    let (module Context) = context_of_config config in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let open Context in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    match epoch_data with","counters":[]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Interruptible.return ()","counters":[]},{"line":"    | Some epoch_data ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let open Interruptible.Let_syntax in","counters":[]},{"line":"        let%bind () =","counters":[]},{"line":"          Interruptible.lift Deferred.unit (Ivar.read interrupt_ivar)","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"        in","counters":[]},{"line":"        let module Slot = Mina_numbers.Global_slot in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let epoch = epoch_data.epoch in","counters":[]},{"line":"        [%log info] \"Starting VRF evaluation for epoch: $epoch\"","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"          ~metadata:[ (\"epoch\", Epoch.to_yojson epoch) ] ;","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"        let keypairs = block_producer_keys in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let start_global_slot = epoch_data.global_slot in","counters":[]},{"line":"        let start_global_slot_since_genesis =","counters":[]},{"line":"          epoch_data.global_slot_since_genesis","counters":[]},{"line":"        in","counters":[]},{"line":"        let delegatee_table = epoch_data.delegatee_table in","counters":[]},{"line":"        (*slot in the epoch*)","counters":[]},{"line":"        let start_consensus_time =","counters":[]},{"line":"          Consensus.Data.Consensus_time.(","counters":[]},{"line":"            of_global_slot ~constants:consensus_constants start_global_slot)","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"        in","counters":[]},{"line":"        let total_stake = epoch_data.epoch_ledger.total_currency in","counters":[]},{"line":"        let evaluate_vrf ~consensus_time =","counters":[]},{"line":"          (* Try vrfs for all keypairs that are unseen within this slot until one wins or all lose *)","counters":[]},{"line":"          (* TODO: Don't do this, and instead pick the one that has the highest chance of winning. See #2573 *)","counters":[]},{"line":"          let slot = Consensus_time.slot consensus_time in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let global_slot = Consensus_time.to_global_slot consensus_time in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          [%log info] \"Checking VRF evaluations for epoch: $epoch, slot: $slot\"","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":20,"col_end":20,"count":0}]},{"line":"            ~metadata:","counters":[]},{"line":"              [ (\"epoch\", `Int (Epoch.to_int epoch))","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"              ; (\"slot\", `Int (Slot.to_int slot))","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"              ] ;","counters":[]},{"line":"          let rec go = function","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            | [] ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Interruptible.return None","counters":[]},{"line":"            | ((keypair : Keypair.t), public_key_compressed) :: keypairs -> (","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                let global_slot_since_genesis =","counters":[]},{"line":"                  let slot_diff =","counters":[]},{"line":"                    match Global_slot.sub global_slot start_global_slot with","counters":[]},{"line":"                    | None ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        failwith","counters":[]},{"line":"                          \"Checking slot-winner for a slot which is older than \\","counters":[]},{"line":"                           the slot in the latest consensus state. System time \\","counters":[]},{"line":"                           might be out-of-sync\"","counters":[]},{"line":"                    | Some diff ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        diff","counters":[]},{"line":"                  in","counters":[]},{"line":"                  Global_slot.add start_global_slot_since_genesis slot_diff","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                in","counters":[]},{"line":"                [%log info]","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                  \"Checking VRF evaluations at epoch: $epoch, slot: $slot\"","counters":[]},{"line":"                  ~metadata:","counters":[]},{"line":"                    [ (\"epoch\", `Int (Epoch.to_int epoch))","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"                    ; (\"slot\", `Int (Slot.to_int slot))","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"                    ] ;","counters":[]},{"line":"                match%bind","counters":[]},{"line":"                  Consensus.Data.Vrf.check","counters":[]},{"line":"                    ~context:(module Context)","counters":[]},{"line":"                    ~global_slot ~seed:epoch_data.epoch_seed","counters":[]},{"line":"                    ~get_delegators:","counters":[]},{"line":"                      (Public_key.Compressed.Table.find delegatee_table)","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"                    ~producer_private_key:keypair.private_key","counters":[]},{"line":"                    ~producer_public_key:public_key_compressed ~total_stake","counters":[]},{"line":"                with","counters":[]},{"line":"                | None ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    go keypairs","counters":[]},{"line":"                | Some","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    ( `Vrf_eval _vrf_string","counters":[]},{"line":"                    , `Vrf_output vrf_result","counters":[]},{"line":"                    , `Delegator delegator ) ->","counters":[]},{"line":"                    [%log info] \"Won slot %d in epoch %d\" (Slot.to_int slot)","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"                      (Epoch.to_int epoch) ;","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"                    let slot_won =","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      Consensus.Data.Slot_won.","counters":[]},{"line":"                        { delegator","counters":[]},{"line":"                        ; producer = keypair","counters":[]},{"line":"                        ; global_slot","counters":[]},{"line":"                        ; global_slot_since_genesis","counters":[]},{"line":"                        ; vrf_result","counters":[]},{"line":"                        }","counters":[]},{"line":"                    in","counters":[]},{"line":"                    Interruptible.return (Some slot_won) )","counters":[]},{"line":"          in","counters":[]},{"line":"          go keypairs","counters":[]},{"line":"        in","counters":[]},{"line":"        let rec find_winning_slot (consensus_time : Consensus_time.t) =","counters":[]},{"line":"          let slot = Consensus_time.slot consensus_time in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let global_slot = Consensus_time.to_global_slot consensus_time in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          t.current_slot <- Some global_slot ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let epoch' = Consensus_time.epoch consensus_time in","counters":[]},{"line":"          if Epoch.(epoch' > epoch) then (","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"            t.current_slot <- None ;","counters":[]},{"line":"            Interruptible.return () )","counters":[]},{"line":"          else","counters":[]},{"line":"            let start = Time.now () in","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            match%bind evaluate_vrf ~consensus_time with","counters":[]},{"line":"            | None ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                [%log info] \"Did not win slot $slot, took $time ms\"","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                  ~metadata:","counters":[]},{"line":"                    [ (\"time\", `Float Time.(Span.to_ms (diff (now ()) start)))","counters":[{"col_start":53,"col_end":53,"count":0},{"col_start":59,"col_end":59,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"                    ; (\"slot\", Slot.to_yojson slot)","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"                    ] ;","counters":[]},{"line":"                find_winning_slot (Consensus_time.succ consensus_time)","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"            | Some slot_won ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                [%log info] \"Won a slot $slot, took $time ms\"","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                  ~metadata:","counters":[]},{"line":"                    [ (\"time\", `Float Time.(Span.to_ms (diff (now ()) start)))","counters":[{"col_start":53,"col_end":53,"count":0},{"col_start":59,"col_end":59,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"                    ; (\"slot\", Slot.to_yojson slot)","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"                    ] ;","counters":[]},{"line":"                Queue.enqueue slots_won slot_won ;","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                find_winning_slot (Consensus_time.succ consensus_time)","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"        in","counters":[]},{"line":"        find_winning_slot start_consensus_time","counters":[]},{"line":"","counters":[]},{"line":"  let create config =","counters":[]},{"line":"    { config","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    ; last_checked_slot_and_epoch = Public_key.Compressed.Table.create ()","counters":[{"col_start":69,"col_end":69,"count":0}]},{"line":"    ; slots_won =","counters":[]},{"line":"        Queue.create","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"          ~capacity:","counters":[]},{"line":"            (Global_slot.to_int config.consensus_constants.slots_per_epoch)","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"          ()","counters":[]},{"line":"    ; current_slot = None","counters":[]},{"line":"    ; epoch_data = (Ivar.create (), None)","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"    ; block_producer_keys = []","counters":[]},{"line":"    }","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Functions = struct","counters":[]},{"line":"  type ('i, 'o) t =","counters":[]},{"line":"    'i Bin_prot.Type_class.t","counters":[]},{"line":"    * 'o Bin_prot.Type_class.t","counters":[]},{"line":"    * (Worker_state.t -> 'i -> 'o Deferred.t)","counters":[]},{"line":"","counters":[]},{"line":"  let create input output f : ('i, 'o) t = (input, output, f)","counters":[{"col_start":43,"col_end":43,"count":3}]},{"line":"","counters":[]},{"line":"  let set_new_epoch_state =","counters":[]},{"line":"    create Consensus.Data.Epoch_data_for_vrf.Stable.Latest.bin_t Unit.bin_t","counters":[{"col_start":9,"col_end":9,"count":1}]},{"line":"      (fun w e ->","counters":[]},{"line":"        let logger = w.config.logger in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let update () =","counters":[]},{"line":"          [%log info]","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":20,"col_end":20,"count":0}]},{"line":"            \"Updating epoch data for the VRF evaluation for epoch $epoch\"","counters":[]},{"line":"            ~metadata:[ (\"epoch\", Epoch.to_yojson e.epoch) ] ;","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"          let interrupt_ivar, _ = w.epoch_data in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          Ivar.fill_if_empty interrupt_ivar () ;","counters":[]},{"line":"          Queue.clear w.slots_won ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          w.current_slot <- None ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          w.epoch_data <- (Ivar.create (), Some e) ;","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"          Interruptible.don't_wait_for (Worker_state.evaluate w) ;","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"          Deferred.unit","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        in","counters":[]},{"line":"        match w.epoch_data with","counters":[]},{"line":"        | _, None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            update ()","counters":[]},{"line":"        | _, Some current ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            if Epoch.(succ e.epoch > current.epoch) then update ()","counters":[{"col_start":25,"col_end":25,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"            else (","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"              [%log info]","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                \"Received epoch data for current epoch $epoch. Skipping \"","counters":[]},{"line":"                ~metadata:[ (\"epoch\", Epoch.to_yojson e.epoch) ] ;","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"              Deferred.unit ) )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"","counters":[]},{"line":"  let slots_won_so_far =","counters":[]},{"line":"    create Unit.bin_t Vrf_evaluation_result.Stable.Latest.bin_t (fun w () ->","counters":[{"col_start":9,"col_end":9,"count":1}]},{"line":"        let slots_won = Queue.to_list w.slots_won in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        [%log' info w.config.logger]","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"          !\"Slots won evaluator: %{sexp: Consensus.Data.Slot_won.t list}\"","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"          slots_won ;","counters":[]},{"line":"        Queue.clear w.slots_won ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let evaluator_status =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          match w.current_slot with","counters":[]},{"line":"          | Some slot ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Evaluator_status.At slot","counters":[]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Completed","counters":[]},{"line":"        in","counters":[]},{"line":"        return Vrf_evaluation_result.{ slots_won; evaluator_status } )","counters":[]},{"line":"","counters":[]},{"line":"  let update_block_producer_keys =","counters":[]},{"line":"    create Block_producer_keys.Stable.Latest.bin_t Unit.bin_t (fun w e ->","counters":[{"col_start":9,"col_end":9,"count":1}]},{"line":"        let logger = w.config.logger in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        [%log info] \"Updating block producer keys\" ;","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"        w.block_producer_keys <- e ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        (*TODO: Interrupt the evaluation here when we handle key updated*)","counters":[]},{"line":"        Deferred.unit )","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Worker = struct","counters":[]},{"line":"  module T = struct","counters":[]},{"line":"    type 'worker functions =","counters":[]},{"line":"      { set_new_epoch_state :","counters":[]},{"line":"          ( 'worker","counters":[]},{"line":"          , Consensus.Data.Epoch_data_for_vrf.t","counters":[]},{"line":"          , unit )","counters":[]},{"line":"          Rpc_parallel.Function.t","counters":[]},{"line":"      ; slots_won_so_far :","counters":[]},{"line":"          ('worker, unit, Vrf_evaluation_result.t) Rpc_parallel.Function.t","counters":[]},{"line":"      ; update_block_producer_keys :","counters":[]},{"line":"          ('worker, Block_producer_keys.t, unit) Rpc_parallel.Function.t","counters":[]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    module Worker_state = Worker_state","counters":[]},{"line":"","counters":[]},{"line":"    module Connection_state = struct","counters":[]},{"line":"      type init_arg = unit [@@deriving bin_io_unversioned]","counters":[{"col_start":6,"col_end":6,"count":1},{"col_start":18,"col_end":18,"count":1},{"col_start":57,"col_end":57,"count":4}]},{"line":"","counters":[]},{"line":"      type t = unit","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Functions","counters":[]},{"line":"        (C : Rpc_parallel.Creator","counters":[]},{"line":"               with type worker_state := Worker_state.t","counters":[]},{"line":"                and type connection_state := Connection_state.t) =","counters":[]},{"line":"    struct","counters":[]},{"line":"      let functions =","counters":[]},{"line":"        let f (i, o, f) =","counters":[]},{"line":"          C.create_rpc","counters":[{"col_start":10,"col_end":10,"count":3}]},{"line":"            ~f:(fun ~worker_state ~conn_state:_ i -> f worker_state i)","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"            ~bin_input:i ~bin_output:o ()","counters":[]},{"line":"        in","counters":[]},{"line":"        let open Functions in","counters":[]},{"line":"        { set_new_epoch_state = f set_new_epoch_state","counters":[{"col_start":32,"col_end":32,"count":1}]},{"line":"        ; slots_won_so_far = f slots_won_so_far","counters":[{"col_start":29,"col_end":29,"count":1}]},{"line":"        ; update_block_producer_keys = f update_block_producer_keys","counters":[{"col_start":39,"col_end":39,"count":1}]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"      let init_worker_state (init_arg : Worker_state.init_arg) =","counters":[]},{"line":"        let logger = init_arg.logger in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let max_size = 200 * 1024 * 1024 in","counters":[]},{"line":"        let num_rotate = 1 in","counters":[]},{"line":"        Logger.Consumer_registry.register ~id:\"default\"","counters":[]},{"line":"          ~processor:(Logger.Processor.raw ())","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"          ~transport:","counters":[]},{"line":"            (Logger_file_system.dumb_logrotate ~directory:init_arg.conf_dir","counters":[]},{"line":"               ~log_filename:\"mina-vrf-evaluator.log\" ~max_size ~num_rotate ) ;","counters":[]},{"line":"        [%log info] \"Vrf_evaluator started\" ;","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"        return (Worker_state.create init_arg)","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"","counters":[]},{"line":"      let init_connection_state ~connection:_ ~worker_state:_ = return","counters":[{"col_start":64,"col_end":64,"count":0}]},{"line":"    end","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  include Rpc_parallel.Make (T)","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"type t = { connection : Worker.Connection.t; process : Process.t }","counters":[]},{"line":"","counters":[]},{"line":"let update_block_producer_keys { connection; process = _ } ~keypairs =","counters":[]},{"line":"  Worker.Connection.run connection","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    ~f:Worker.functions.update_block_producer_keys","counters":[]},{"line":"    ~arg:(Keypair.And_compressed_pk.Set.to_list keypairs)","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"","counters":[]},{"line":"let create ~constraint_constants ~pids ~consensus_constants ~conf_dir ~logger","counters":[]},{"line":"    ~keypairs =","counters":[]},{"line":"  let on_failure err =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    [%log error] \"VRF evaluator process failed with error $err\"","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"      ~metadata:[ (\"err\", Error_json.error_to_yojson err) ] ;","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"    Error.raise err","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  in","counters":[]},{"line":"  [%log info] \"Starting a new vrf-evaluator process\" ;","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"  let%bind connection, process =","counters":[]},{"line":"    Worker.spawn_in_foreground_exn ~connection_timeout:(Time.Span.of_min 1.)","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":71,"col_end":71,"count":0}]},{"line":"      ~on_failure ~shutdown_on:Connection_closed ~connection_state_init_arg:()","counters":[]},{"line":"      { constraint_constants; consensus_constants; conf_dir; logger }","counters":[]},{"line":"  in","counters":[]},{"line":"  [%log info]","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":12,"col_end":12,"count":0}]},{"line":"    \"Daemon started process of kind $process_kind with pid $vrf_evaluator_pid\"","counters":[]},{"line":"    ~metadata:","counters":[]},{"line":"      [ (\"vrf_evaluator_pid\", `Int (Process.pid process |> Pid.to_int))","counters":[{"col_start":46,"col_end":46,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"      ; ( \"process_kind\"","counters":[]},{"line":"        , `String Child_processes.Termination.(show_process_kind Vrf_evaluator)","counters":[{"col_start":63,"col_end":63,"count":0}]},{"line":"        )","counters":[]},{"line":"      ] ;","counters":[]},{"line":"  Child_processes.Termination.register_process pids process","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Child_processes.Termination.Vrf_evaluator ;","counters":[]},{"line":"  don't_wait_for","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  @@ Pipe.iter","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"       (Process.stdout process |> Reader.pipe)","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"       ~f:(fun stdout ->","counters":[]},{"line":"         return","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"         @@ [%log debug] \"Vrf_evaluator stdout: $stdout\"","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"              ~metadata:[ (\"stdout\", `String stdout) ] ) ;","counters":[]},{"line":"  don't_wait_for","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  @@ Pipe.iter","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"       (Process.stderr process |> Reader.pipe)","counters":[{"col_start":21,"col_end":21,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"       ~f:(fun stderr ->","counters":[]},{"line":"         return","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"         @@ [%log error] \"Vrf_evaluator stderr: $stderr\"","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"              ~metadata:[ (\"stderr\", `String stderr) ] ) ;","counters":[]},{"line":"  let t = { connection; process } in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%map _ = update_block_producer_keys ~keypairs t in","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"  t","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let set_new_epoch_state { connection; process = _ } ~epoch_data_for_vrf =","counters":[]},{"line":"  Worker.Connection.run connection ~f:Worker.functions.set_new_epoch_state","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    ~arg:epoch_data_for_vrf","counters":[]},{"line":"","counters":[]},{"line":"let slots_won_so_far { connection; process = _ } =","counters":[]},{"line":"  Worker.Connection.run connection ~f:Worker.functions.slots_won_so_far ~arg:()","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":78,"col_end":78,"count":2}]}]}