{"filename":"src/lib/merkle_ledger/any_ledger.ml","lines":[{"line":"(** Any_ledger lets you use any arbitrary ledger whenever some ledger is","counters":[]},{"line":" * required. This uses dynamic dispatch and is equivalent to the notion of","counters":[]},{"line":" * consuming a value conforming to an interface in Java.","counters":[]},{"line":" *","counters":[]},{"line":" * It uses GADTs to type-erase the specific underlying first-class module","counters":[]},{"line":" * for some given signature and delegates all function calls.","counters":[]},{"line":" *","counters":[]},{"line":" * The restriction here is that one cannot conform to some signature that","counters":[]},{"line":" * exposes a `create` function because we can't magically pull a conforming","counters":[]},{"line":" * module out of thin air. However, one can always just pack any concrete","counters":[]},{"line":" * instance with the GADT constructor `witness`.","counters":[]},{"line":" *","counters":[]},{"line":" * Props to @nholland for showing me this trick.","counters":[]},{"line":" * *)","counters":[]},{"line":"","counters":[{"col_start":0,"col_end":0,"count":1}]},{"line":"open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"module type S = sig","counters":[]},{"line":"  type key","counters":[]},{"line":"","counters":[]},{"line":"  type token_id","counters":[]},{"line":"","counters":[]},{"line":"  type token_id_set","counters":[]},{"line":"","counters":[]},{"line":"  type account_id","counters":[]},{"line":"","counters":[]},{"line":"  type account_id_set","counters":[]},{"line":"","counters":[]},{"line":"  type account","counters":[]},{"line":"","counters":[]},{"line":"  type hash","counters":[]},{"line":"","counters":[]},{"line":"  module Location : Location_intf.S","counters":[]},{"line":"","counters":[]},{"line":"  (** The type of the witness for a base ledger exposed here so that it can","counters":[]},{"line":"   * be easily accessed from outside this module *)","counters":[]},{"line":"  type witness","counters":[]},{"line":"  (* type witness [@@deriving sexp_of] *)","counters":[]},{"line":"","counters":[]},{"line":"  module type Base_intf =","counters":[]},{"line":"    Base_ledger_intf.S","counters":[]},{"line":"      with module Addr = Location.Addr","counters":[]},{"line":"      with module Location = Location","counters":[]},{"line":"      with type key := key","counters":[]},{"line":"       and type token_id := token_id","counters":[]},{"line":"       and type token_id_set := token_id_set","counters":[]},{"line":"       and type account_id := account_id","counters":[]},{"line":"       and type account_id_set := account_id_set","counters":[]},{"line":"       and type hash := hash","counters":[]},{"line":"       and type root_hash := hash","counters":[]},{"line":"       and type account := account","counters":[]},{"line":"","counters":[]},{"line":"  val cast : (module Base_intf with type t = 'a) -> 'a -> witness","counters":[]},{"line":"","counters":[]},{"line":"  val cast_database_to_mask :","counters":[]},{"line":"    (module Base_intf with type t = 'a) -> 'a -> witness","counters":[]},{"line":"","counters":[]},{"line":"  module M : Base_intf with type t = witness","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type Inputs_intf = sig","counters":[]},{"line":"  include Base_inputs_intf.S","counters":[]},{"line":"","counters":[]},{"line":"  module Location : Location_intf.S","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make_base (Inputs : Inputs_intf) :","counters":[]},{"line":"  S","counters":[]},{"line":"    with module Location = Inputs.Location","counters":[]},{"line":"    with type key := Inputs.Key.t","counters":[]},{"line":"     and type token_id := Inputs.Token_id.t","counters":[]},{"line":"     and type token_id_set := Inputs.Token_id.Set.t","counters":[]},{"line":"     and type account_id := Inputs.Account_id.t","counters":[]},{"line":"     and type hash := Inputs.Hash.t","counters":[]},{"line":"     and type account_id_set := Inputs.Account_id.Set.t","counters":[]},{"line":"     and type account := Inputs.Account.t = struct","counters":[]},{"line":"  open Inputs","counters":[]},{"line":"  module Location = Location","counters":[]},{"line":"","counters":[]},{"line":"  module type Base_intf =","counters":[]},{"line":"    Base_ledger_intf.S","counters":[]},{"line":"      with module Addr = Location.Addr","counters":[]},{"line":"      with module Location = Location","counters":[]},{"line":"      with type key := Inputs.Key.t","counters":[]},{"line":"       and type token_id := Inputs.Token_id.t","counters":[]},{"line":"       and type token_id_set := Inputs.Token_id.Set.t","counters":[]},{"line":"       and type account_id := Account_id.t","counters":[]},{"line":"       and type account_id_set := Account_id.Set.t","counters":[]},{"line":"       and type hash := Hash.t","counters":[]},{"line":"       and type root_hash := Hash.t","counters":[]},{"line":"       and type account := Account.t","counters":[]},{"line":"","counters":[]},{"line":"  type witness = T : (module Base_intf with type t = 't) * 't -> witness","counters":[]},{"line":"","counters":[]},{"line":"  (* external mask_create : int -> t = \"rust_mask_create\" *)","counters":[]},{"line":"  (* val cast : (module Base_intf with type t = 'a) -> 'a -> witness *)","counters":[]},{"line":"  (* external rust_cast : (module Base_intf with type t = 'a) -> 'a -> witness *)","counters":[]},{"line":"  external rust_cast : 'a -> witness = \"rust_cast\"","counters":[]},{"line":"","counters":[]},{"line":"  external rust_cast_database_to_mask : 'a -> witness","counters":[]},{"line":"    = \"rust_cast_database_to_mask\"","counters":[]},{"line":"","counters":[]},{"line":"  let cast (_m : (module Base_intf with type t = 'a)) (t : 'a) = rust_cast t","counters":[{"col_start":65,"col_end":65,"count":1}]},{"line":"","counters":[]},{"line":"  let cast_database_to_mask (_m : (module Base_intf with type t = 'a)) (t : 'a)","counters":[]},{"line":"      =","counters":[]},{"line":"    rust_cast_database_to_mask t","counters":[{"col_start":4,"col_end":4,"count":2}]},{"line":"","counters":[]},{"line":"  let _cast2 (m : (module Base_intf with type t = 'a)) (t : 'a) = T (m, t)","counters":[{"col_start":66,"col_end":66,"count":0}]},{"line":"","counters":[]},{"line":"  (* let cast (m : (module Base_intf with type t = 'a)) (t : 'a) = T (m, t) *)","counters":[]},{"line":"","counters":[]},{"line":"  let sexp_of_witness (T ((module B), t)) = B.sexp_of_t t","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"  (** M can be used wherever a base ledger is demanded, construct instances","counters":[]},{"line":"   * by using the witness constructor directly","counters":[]},{"line":"   *","counters":[]},{"line":"   * We delegate to the underlying functions in the base interface mechanically","counters":[]},{"line":"   *","counters":[]},{"line":"   * In the future, this should be a `ppx`.","counters":[]},{"line":"   *)","counters":[]},{"line":"  module M : Base_intf with type t = witness = struct","counters":[]},{"line":"    (* type t *)","counters":[]},{"line":"    type t = witness [@@deriving sexp_of]","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"    let t_of_sexp _ = failwith \"t_of_sexp unimplemented\"","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"    type index = int","counters":[]},{"line":"","counters":[]},{"line":"    module Location = Location","counters":[]},{"line":"    module Path = Merkle_path.Make (Hash)","counters":[]},{"line":"","counters":[]},{"line":"    type path = Path.t","counters":[]},{"line":"","counters":[]},{"line":"    module Addr = Location.Addr","counters":[]},{"line":"","counters":[]},{"line":"    let account_id_to_rust account_id =","counters":[]},{"line":"      let buf =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Bigstring.create (Account_id.Stable.Latest.bin_size_t account_id)","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"      in","counters":[]},{"line":"      ignore (Account_id.Stable.Latest.bin_write_t buf ~pos:0 account_id : int) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"      Bigstring.to_bytes buf","counters":[]},{"line":"","counters":[]},{"line":"    let account_location_from_rust addr = Location.Account (Addr.of_string addr)","counters":[{"col_start":42,"col_end":42,"count":0},{"col_start":73,"col_end":73,"count":0}]},{"line":"","counters":[]},{"line":"    let account_from_rust account =","counters":[]},{"line":"      Account.bin_read_t (Bigstring.of_bytes account) ~pos_ref:(ref 0)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"","counters":[]},{"line":"    let account_to_rust account =","counters":[]},{"line":"      let buf = Bigstring.create (Account.bin_size_t account) in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"      ignore (Account.bin_write_t buf ~pos:0 account : int) ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"      Bigstring.to_bytes buf","counters":[]},{"line":"","counters":[]},{"line":"    let hash_from_rust hash =","counters":[]},{"line":"      hash |> Bigstring.of_bytes |> Hash.bin_read_t ~pos_ref:(ref 0)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"","counters":[]},{"line":"    let location_to_rust location =","counters":[]},{"line":"      Location.to_path_exn location |> Addr.to_string","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"    let path_from_rust path =","counters":[]},{"line":"      match path with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | `Left hash ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          `Left (hash_from_rust hash)","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"      | `Right hash ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          `Right (hash_from_rust hash)","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"","counters":[]},{"line":"    external print_backtrace : int -> unit = \"rust_print_backtrace\"","counters":[]},{"line":"","counters":[]},{"line":"    external mask_remove_accounts : 'a -> 'b list -> unit","counters":[]},{"line":"      = \"rust_mask_remove_accounts\"","counters":[]},{"line":"","counters":[]},{"line":"    let remove_accounts_exn m account_ids =","counters":[]},{"line":"      (*Printf.eprintf \"MY_LOG.ANY.REMOVE_ACCOUNTS\\n%!\" ;*)","counters":[]},{"line":"      print_backtrace 0 ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let account_ids = List.map account_ids ~f:account_id_to_rust in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      mask_remove_accounts m account_ids","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    external mask_merkle_path_at_index : 'a -> int -> 'b list","counters":[]},{"line":"      = \"rust_mask_merkle_path_at_index\"","counters":[]},{"line":"","counters":[]},{"line":"    let merkle_path_at_index_exn m index =","counters":[]},{"line":"      (*Printf.eprintf \"MY_LOG.ANY.MERKLE_PATH_AT_INDEX\\n%!\" ;*)","counters":[]},{"line":"      mask_merkle_path_at_index m index |> List.map ~f:path_from_rust","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"","counters":[]},{"line":"    (* let merkle_path_at_index_exn (T ((module Base), t)) =","counters":[]},{"line":"     *   Printf.eprintf \"MY_LOG.ANY.MERKLE_PATH_AT_INDEX\\n%!\" ;","counters":[]},{"line":"     *   Base.merkle_path_at_index_exn t *)","counters":[]},{"line":"","counters":[]},{"line":"    external mask_merkle_path : 'a -> 'b -> 'c list = \"rust_mask_merkle_path\"","counters":[]},{"line":"","counters":[]},{"line":"    let merkle_path m location =","counters":[]},{"line":"      (*Printf.eprintf \"MY_LOG.ANY.MERKLE_PATH\\n%!\" ;*)","counters":[]},{"line":"      mask_merkle_path m (location_to_rust location)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"      |> List.map ~f:path_from_rust","counters":[]},{"line":"","counters":[]},{"line":"    (* let merkle_path (T ((module Base), t)) =","counters":[]},{"line":"     *   Printf.eprintf \"MY_LOG.ANY.MERKLE_PATH\\n%!\" ;","counters":[]},{"line":"     *   Base.merkle_path t *)","counters":[]},{"line":"","counters":[]},{"line":"    external mask2_merkle_root : 'a -> bytes = \"rust_mask_merkle_root\"","counters":[]},{"line":"","counters":[]},{"line":"    let merkle_root a =","counters":[]},{"line":"      (*Printf.eprintf \"MY_LOG.ANY.MERKLE_ROOT\\n%!\" ;*)","counters":[]},{"line":"      print_backtrace 0 ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let res = mask2_merkle_root a |> hash_from_rust in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":32,"col_end":32,"count":0}]},{"line":"      (* let res = Base.merkle_root t in *)","counters":[]},{"line":"      (*Printf.eprintf \"MY_LOG.ANY.MERKLE_ROOT2\\n%!\" ;*)","counters":[]},{"line":"      res","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    external mask_index_of_account : 'a -> 'b -> int","counters":[]},{"line":"      = \"rust_mask_index_of_account\"","counters":[]},{"line":"","counters":[]},{"line":"    let index_of_account_exn m account_id =","counters":[]},{"line":"      (*Printf.eprintf \"MY_LOG.ANY.INDEX_OF_ACCOUNT\\n%!\" ;*)","counters":[]},{"line":"      print_backtrace 0 ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      mask_index_of_account m (account_id_to_rust account_id)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"","counters":[]},{"line":"    external mask_set_at_index : 'a -> int -> 'b -> unit","counters":[]},{"line":"      = \"rust_mask_set_at_index\"","counters":[]},{"line":"","counters":[]},{"line":"    let set_at_index_exn m index account =","counters":[]},{"line":"      (*Printf.eprintf \"MY_LOG.ANY.SET_AT_INDEX\\n%!\" ;*)","counters":[]},{"line":"      print_backtrace 0 ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      mask_set_at_index m index (account_to_rust account)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"","counters":[]},{"line":"    external mask_get_at_index : 'a -> int -> 'b = \"rust_mask_get_at_index\"","counters":[]},{"line":"","counters":[]},{"line":"    let get_at_index_exn m index =","counters":[]},{"line":"      (*Printf.eprintf \"MY_LOG.ANY.GET_AT_INDEX\\n%!\" ;*)","counters":[]},{"line":"      print_backtrace 0 ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      mask_get_at_index m index |> account_from_rust","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":22,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"    (* let get_at_index_exn (T ((module Base), t)) =","counters":[]},{"line":"     *   Printf.eprintf \"MY_LOG.ANY.GET_AT_INDEX\\n%!\" ;","counters":[]},{"line":"     *   Base.get_at_index_exn t *)","counters":[]},{"line":"","counters":[]},{"line":"    external mask_set_batch_accounts : 'a -> ('b * 'c) list -> unit","counters":[]},{"line":"      = \"rust_mask_set_batch_accounts\"","counters":[]},{"line":"","counters":[]},{"line":"    let set_batch m locations_and_accounts =","counters":[]},{"line":"      let accounts =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        List.map locations_and_accounts ~f:(fun (location, account) ->","counters":[]},{"line":"            (location_to_rust location, account_to_rust account) )","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"      in","counters":[]},{"line":"      mask_set_batch_accounts m accounts","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    external mask_set : 'a -> 'b -> 'c -> unit = \"rust_mask_set\"","counters":[]},{"line":"","counters":[]},{"line":"    let set m location account =","counters":[]},{"line":"      (*Printf.eprintf \"MY_LOG.ANY.SET\\n%!\" ;*)","counters":[]},{"line":"      print_backtrace 0 ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let location = location_to_rust location in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      mask_set m location (account_to_rust account)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"","counters":[]},{"line":"    (* let set (T ((module Base), t)) = *)","counters":[]},{"line":"    (*   Base.set t *)","counters":[]},{"line":"","counters":[]},{"line":"    external mask_get : 'a -> 'b -> 'c option = \"rust_mask_get\"","counters":[]},{"line":"","counters":[]},{"line":"    let get m location =","counters":[]},{"line":"      (*Printf.eprintf \"MY_LOG.ANY.GET\\n%!\" ;*)","counters":[]},{"line":"      let addr = location_to_rust location in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      mask_get m addr |> Option.map ~f:account_from_rust","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":13,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"    (* let get (T ((module Base), t)) =","counters":[]},{"line":"     *   Printf.eprintf \"MY_LOG.ANY.GET\\n%!\" ;","counters":[]},{"line":"     *   Base.get t *)","counters":[]},{"line":"","counters":[]},{"line":"    external mask_get_batch : 'a -> 'addr list -> ('addr * 'account option) list","counters":[]},{"line":"      = \"rust_mask_get_batch\"","counters":[]},{"line":"","counters":[]},{"line":"    let get_batch m locations =","counters":[]},{"line":"      (*Printf.eprintf \"MY_LOG.ANY.GET_BATCH\\n%!\" ;*)","counters":[]},{"line":"      print_backtrace 0 ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let addrs = List.map locations ~f:location_to_rust in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      mask_get_batch m addrs","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"      |> List.map ~f:(fun (addr, account) ->","counters":[]},{"line":"             ( account_location_from_rust addr","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"             , Option.map account ~f:account_from_rust ) )","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"","counters":[]},{"line":"    (* let get_batch (T ((module Base), t)) = *)","counters":[]},{"line":"    (*   Base.get_batch t *)","counters":[]},{"line":"","counters":[]},{"line":"    let get_uuid (T ((module Base), t)) =","counters":[]},{"line":"      (*Printf.eprintf \"MY_LOG.ANY.GET_UUID\\n%!\" ;*)","counters":[]},{"line":"      print_backtrace 0 ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Base.get_uuid t","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let get_directory (T ((module Base), t)) =","counters":[]},{"line":"      (*Printf.eprintf \"MY_LOG.ANY.GET_DIRECTORY\\n%!\" ;*)","counters":[]},{"line":"      print_backtrace 0 ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Base.get_directory t","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let last_filled (T ((module Base), t)) =","counters":[]},{"line":"      (*Printf.eprintf \"MY_LOG.ANY.LAST_FILLED\\n%!\" ;*)","counters":[]},{"line":"      print_backtrace 0 ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Base.last_filled t","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let close (T ((module Base), t)) =","counters":[]},{"line":"      (*Printf.eprintf \"MY_LOG.ANY.CLOSE\\n%!\" ;*)","counters":[]},{"line":"      print_backtrace 0 ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Base.close t","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let get_or_create_account (T ((module Base), t)) =","counters":[]},{"line":"      (*Printf.eprintf \"MY_LOG.ANY.GET_OR_CREATE_ACCOUNT\\n%!\" ;*)","counters":[]},{"line":"      print_backtrace 0 ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Base.get_or_create_account t","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    (* let location_of_account (T ((module Base), t)) =","counters":[]},{"line":"     *   Printf.eprintf \"MY_LOG.ANY.LOCATION_OF_ACCOUNT\\n%!\" ;","counters":[]},{"line":"     *   Base.location_of_account t *)","counters":[]},{"line":"","counters":[]},{"line":"    external mask_location_of_account : 'a -> 'b -> 'c option","counters":[]},{"line":"      = \"rust_mask_location_of_account\"","counters":[]},{"line":"","counters":[]},{"line":"    let location_of_account m account_id =","counters":[]},{"line":"      (*Printf.eprintf \"MY_LOG.ANY.LOCATION_OF_ACCOUNT\\n%!\" ;*)","counters":[]},{"line":"      mask_location_of_account m (account_id_to_rust account_id)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":51,"col_end":51,"count":0}]},{"line":"      |> Option.map ~f:(fun addr -> Location.Account (Addr.of_string addr))","counters":[{"col_start":36,"col_end":36,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"","counters":[]},{"line":"    let location_of_account_batch (T ((module Base), t)) =","counters":[]},{"line":"      (*Printf.eprintf \"MY_LOG.ANY.LOCATION_OF_ACCOUNT_BATCH\\n%!\" ;*)","counters":[]},{"line":"      print_backtrace 0 ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Base.location_of_account_batch t","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let fold_until (T ((module Base), t)) =","counters":[]},{"line":"      (*Printf.eprintf \"MY_LOG.ANY.FOLD_UNTIL\\n%!\" ;*)","counters":[]},{"line":"      print_backtrace 0 ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Base.fold_until t","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let accounts (T ((module Base), t)) =","counters":[]},{"line":"      (*Printf.eprintf \"MY_LOG.ANY.ACCOUNTS\\n%!\" ;*)","counters":[]},{"line":"      Base.accounts t","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let token_owner (T ((module Base), t)) tid =","counters":[]},{"line":"      (*Printf.eprintf \"MY_LOG.ANY.TOKEN_OWNER\\n%!\" ;*)","counters":[]},{"line":"      print_backtrace 0 ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Base.token_owner t tid","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let tokens (T ((module Base), t)) pk =","counters":[]},{"line":"      (*Printf.eprintf \"MY_LOG.ANY.TOKENS\\n%!\" ;*)","counters":[]},{"line":"      print_backtrace 0 ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Base.tokens t pk","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let token_owners (T ((module Base), t)) =","counters":[]},{"line":"      (*Printf.eprintf \"MY_LOG.ANY.TOKEN_OWNERS\\n%!\" ;*)","counters":[]},{"line":"      print_backtrace 0 ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Base.token_owners t","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let iteri (T ((module Base), t)) =","counters":[]},{"line":"      (*Printf.eprintf \"MY_LOG.ANY.ITERI\\n%!\" ;*)","counters":[]},{"line":"      print_backtrace 0 ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Base.iteri t","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    (* ignored_keys must be Base.Keys.Set.t, but that isn't necessarily the same as Keys.Set.t for the","counters":[]},{"line":"       Keys passed to this functor; as long as we use the same Keys for all ledgers, this should work","counters":[]},{"line":"    *)","counters":[]},{"line":"    let foldi_with_ignored_accounts (T ((module Base), t)) =","counters":[]},{"line":"      (*Printf.eprintf \"MY_LOG.ANY.FOLDI_WITH_IGNORED_ACCOUNTS\\n%!\" ;*)","counters":[]},{"line":"      print_backtrace 0 ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Base.foldi_with_ignored_accounts t","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    external mask_foldi : 'a -> ('b -> bytes -> unit) -> unit","counters":[]},{"line":"      = \"rust_mask_foldi\"","counters":[]},{"line":"","counters":[]},{"line":"    let foldi m ~init ~f =","counters":[]},{"line":"      (*Printf.eprintf \"MY_LOG.ANY.FOLDI\\n%!\" ;*)","counters":[]},{"line":"      let accum = ref init in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      mask_foldi m (fun addr account ->","counters":[]},{"line":"          accum := f (Addr.of_string addr) !accum (account_from_rust account) ) ;","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":19,"col_end":19,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":67,"col_end":67,"count":0}]},{"line":"      !accum","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    (* let foldi (T ((module Base), t)) =","counters":[]},{"line":"     *   Printf.eprintf \"MY_LOG.ANY.FOLDI\\n%!\" ;","counters":[]},{"line":"     *   Base.foldi t *)","counters":[]},{"line":"","counters":[]},{"line":"    external mask_get_list : 'a -> bytes list = \"rust_mask_get_list\"","counters":[]},{"line":"","counters":[]},{"line":"    let to_list m =","counters":[]},{"line":"      (*Printf.eprintf \"MY_LOG.ANY.TO_LIST\\n%!\" ;*)","counters":[]},{"line":"      print_backtrace 0 ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      mask_get_list m |> List.map ~f:account_from_rust","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"","counters":[]},{"line":"    (* let to_list (T ((module Base), t)) =","counters":[]},{"line":"     *   Printf.eprintf \"MY_LOG.ANY.TO_LIST\\n%!\" ;","counters":[]},{"line":"     *   Base.to_list t *)","counters":[]},{"line":"","counters":[]},{"line":"    let make_space_for _m _index =","counters":[]},{"line":"      (*Printf.eprintf \"MY_LOG.ANY.MAKE_SPACE_FOR\\n%!\" ;*)","counters":[]},{"line":"      print_backtrace 0","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    (* Base.make_space_for t *)","counters":[]},{"line":"","counters":[]},{"line":"    external mask_get_all_accounts_rooted_at : 'a -> 'b -> ('b * 'c) list","counters":[]},{"line":"      = \"rust_mask_get_all_accounts_rooted_at\"","counters":[]},{"line":"","counters":[]},{"line":"    let get_all_accounts_rooted_at_exn m addr =","counters":[]},{"line":"      (*Printf.eprintf \"MY_LOG.ANY.GET_ALL_ACCOUNTS_ROOTED_AT\\n%!\" ;*)","counters":[]},{"line":"      print_backtrace 0 ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let accounts = mask_get_all_accounts_rooted_at m (Addr.to_string addr) in","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"      List.map accounts ~f:(fun (addr, account) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          (Addr.of_string addr, account_from_rust account) )","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"","counters":[]},{"line":"    external mask_set_all_accounts_rooted_at : 'a -> 'b -> bytes list -> unit","counters":[]},{"line":"      = \"rust_mask_set_all_accounts_rooted_at\"","counters":[]},{"line":"","counters":[]},{"line":"    let set_all_accounts_rooted_at_exn m addr accounts =","counters":[]},{"line":"      (*Printf.eprintf \"MY_LOG.ANY.SET_ALL_ACCOUNTS_ROOTED_AT\\n%!\" ;*)","counters":[]},{"line":"      print_backtrace 0 ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let accounts = List.map accounts ~f:account_to_rust in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      mask_set_all_accounts_rooted_at m (Addr.to_string addr) accounts","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"","counters":[]},{"line":"    let set_batch_accounts m addresses_and_accounts =","counters":[]},{"line":"      (*Printf.eprintf \"MY_LOG.ANY.SET_BATCH_ACCOUNTS\\n%!\" ;*)","counters":[]},{"line":"      print_backtrace 0 ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let accounts =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        List.map addresses_and_accounts ~f:(fun (addr, account) ->","counters":[]},{"line":"            (Addr.to_string addr, account_to_rust account) )","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":26,"col_end":26,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"      in","counters":[]},{"line":"      mask_set_batch_accounts m accounts","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let set_inner_hash_at_addr_exn (T ((module Base), t)) =","counters":[]},{"line":"      (*Printf.eprintf \"MY_LOG.ANY.SET_INNER_HASH_AT_ADDR\\n%!\" ;*)","counters":[]},{"line":"      print_backtrace 0 ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Base.set_inner_hash_at_addr_exn t","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    external mask_get_inner_hash_at_addr : 'a -> 'b -> bytes","counters":[]},{"line":"      = \"rust_mask_get_inner_hash_at_addr\"","counters":[]},{"line":"","counters":[]},{"line":"    let get_inner_hash_at_addr_exn m address =","counters":[]},{"line":"      let hash =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        mask_get_inner_hash_at_addr m (Addr.to_string address) |> hash_from_rust","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"      in","counters":[]},{"line":"      hash","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    (* let get_inner_hash_at_addr_exn (T ((module Base), t)) =","counters":[]},{"line":"     *   Printf.eprintf \"MY_LOG.ANY.GET_INNER_HASH_AT_ADDR\\n%!\" ;","counters":[]},{"line":"     *   print_backtrace 0 ;","counters":[]},{"line":"     *   Base.get_inner_hash_at_addr_exn t *)","counters":[]},{"line":"","counters":[]},{"line":"    external mask_merkle_path_at_addr : 'a -> 'b -> 'c list","counters":[]},{"line":"      = \"rust_mask_merkle_path_at_addr\"","counters":[]},{"line":"","counters":[]},{"line":"    let merkle_path_at_addr_exn m addr =","counters":[]},{"line":"      (*Printf.eprintf \"MY_LOG.ANY.MERKLE_PATH_AT_ADDR\\n%!\" ;*)","counters":[]},{"line":"      print_backtrace 0 ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      mask_merkle_path_at_addr m (Addr.to_string addr)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"      |> List.map ~f:path_from_rust","counters":[]},{"line":"","counters":[]},{"line":"    external mask_num_accounts : 'a -> int = \"rust_mask_num_accounts\"","counters":[]},{"line":"","counters":[]},{"line":"    let num_accounts m =","counters":[]},{"line":"      (*Printf.eprintf \"MY_LOG.ANY.NUM_ACCOUNTS\\n%!\" ;*)","counters":[]},{"line":"      mask_num_accounts m","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    (* let num_accounts (T ((module Base), t)) = *)","counters":[]},{"line":"    (*   Printf.eprintf \"MY_LOG.ANY.NUM_ACCOUNTS\\n%!\" ; *)","counters":[]},{"line":"    (*   Base.num_accounts t *)","counters":[]},{"line":"","counters":[]},{"line":"    external mask_depth : 'a -> int = \"rust_mask_depth\"","counters":[]},{"line":"","counters":[]},{"line":"    (* This better be the same depth inside Base or you're going to have a bad","counters":[]},{"line":"     * time *)","counters":[]},{"line":"    let depth m =","counters":[]},{"line":"      (*Printf.eprintf \"MY_LOG.ANY.DEPTH\\n%!\" ;*)","counters":[]},{"line":"      mask_depth m","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    (* let depth (T ((module Base), t)) =","counters":[]},{"line":"     *   Printf.eprintf \"MY_LOG.ANY.DEPTH\\n%!\" ;","counters":[]},{"line":"     *   Base.depth t *)","counters":[]},{"line":"","counters":[]},{"line":"    let detached_signal (T ((module Base), t)) =","counters":[]},{"line":"      (*Printf.eprintf \"MY_LOG.ANY.DETACHED\\n%!\" ;*)","counters":[]},{"line":"      print_backtrace 0 ;","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      Base.detached_signal t","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  end","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}