{"filename":"src/lib/ledger_catchup/normal_catchup.ml","lines":[{"line":"(* Only show stdout for failed inline tests. *)","counters":[{"col_start":46,"col_end":46,"count":1}]},{"line":"open Inline_test_quiet_logs","counters":[]},{"line":"open Core","counters":[]},{"line":"open Async","counters":[]},{"line":"open Cache_lib","counters":[]},{"line":"open Pipe_lib","counters":[]},{"line":"open Mina_base","counters":[]},{"line":"open Network_peer","counters":[]},{"line":"","counters":[]},{"line":"module type CONTEXT = sig","counters":[]},{"line":"  val logger : Logger.t","counters":[]},{"line":"","counters":[]},{"line":"  val precomputed_values : Precomputed_values.t","counters":[]},{"line":"","counters":[]},{"line":"  val constraint_constants : Genesis_constants.Constraint_constants.t","counters":[]},{"line":"","counters":[]},{"line":"  val consensus_constants : Consensus.Constants.t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(** [Ledger_catchup] is a procedure that connects a foreign external transition","counters":[]},{"line":"    into a transition frontier by requesting a path of external_transitions","counters":[]},{"line":"    from its peer. It receives the state_hash to catchup from","counters":[]},{"line":"    [Catchup_scheduler]. With that state_hash, it will ask its peers for","counters":[]},{"line":"    a merkle path/list from their oldest transition to the state_hash it is","counters":[]},{"line":"    asking for. Upon receiving the merkle path/list, it will do the following:","counters":[]},{"line":"","counters":[]},{"line":"    1. verify the merkle path/list is correct by calling","counters":[]},{"line":"    [Transition_chain_verifier.verify]. This function would returns a list","counters":[]},{"line":"    of state hashes if the verification is successful.","counters":[]},{"line":"","counters":[]},{"line":"    2. using the list of state hashes to poke a transition frontier","counters":[]},{"line":"    in order to find the hashes of missing transitions. If none of the hashes","counters":[]},{"line":"    are found, then it means some more transitions are missing.","counters":[]},{"line":"","counters":[]},{"line":"    Once the list of missing hashes are computed, it would do another request to","counters":[]},{"line":"    download the corresponding transitions in a batch fashion. Next it will perform the","counters":[]},{"line":"    following validations on each external_transition:","counters":[]},{"line":"","counters":[]},{"line":"    1. Check the list of transitions corresponds to the list of hashes that we","counters":[]},{"line":"    requested;","counters":[]},{"line":"","counters":[]},{"line":"    2. Each transition is checked through [Transition_processor.Validator] and","counters":[]},{"line":"    [Protocol_state_validator]","counters":[]},{"line":"","counters":[]},{"line":"    If any of the external_transitions is invalid,","counters":[]},{"line":"    1) the sender is punished;","counters":[]},{"line":"    2) those external_transitions that already passed validation would be","counters":[]},{"line":"       invalidated.","counters":[]},{"line":"    Otherwise, [Ledger_catchup] will build a corresponding breadcrumb path from","counters":[]},{"line":"    the path of external_transitions. A breadcrumb from the path is built using","counters":[]},{"line":"    its corresponding external_transition staged_ledger_diff and applying it to","counters":[]},{"line":"    its preceding breadcrumb staged_ledger to obtain its corresponding","counters":[]},{"line":"    staged_ledger. If there was an error in building the breadcrumbs, then","counters":[]},{"line":"    catchup would invalidate the cached transitions.","counters":[]},{"line":"    After building the breadcrumb path, [Ledger_catchup] will then send it to","counters":[]},{"line":"    the [Processor] via writing them to catchup_breadcrumbs_writer. *)","counters":[]},{"line":"","counters":[]},{"line":"let verify_transition ~context:(module Context : CONTEXT) ~trust_system","counters":[]},{"line":"    ~frontier ~unprocessed_transition_cache enveloped_transition =","counters":[]},{"line":"  let open Context in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let sender = Envelope.Incoming.sender enveloped_transition in","counters":[]},{"line":"  let genesis_state_hash = Transition_frontier.genesis_state_hash frontier in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let transition_with_hash = Envelope.Incoming.data enveloped_transition in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let cached_initially_validated_transition_result =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    let open Result.Let_syntax in","counters":[]},{"line":"    let%bind initially_validated_transition =","counters":[]},{"line":"      transition_with_hash","counters":[]},{"line":"      |> Mina_block.Validation.skip_time_received_validation","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"           `This_block_was_not_received_via_gossip","counters":[]},{"line":"      |> Mina_block.Validation.validate_genesis_protocol_state","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"           ~genesis_state_hash","counters":[]},{"line":"      >>= Mina_block.Validation.validate_protocol_versions","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      >>= Mina_block.Validation.validate_delta_block_chain","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    in","counters":[]},{"line":"    let enveloped_initially_validated_transition =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Envelope.Incoming.map enveloped_transition","counters":[]},{"line":"        ~f:(Fn.const initially_validated_transition)","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"    in","counters":[]},{"line":"    Transition_handler.Validator.validate_transition","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ~context:(module Context)","counters":[]},{"line":"      ~frontier ~unprocessed_transition_cache","counters":[]},{"line":"      enveloped_initially_validated_transition","counters":[]},{"line":"  in","counters":[]},{"line":"  let open Deferred.Let_syntax in","counters":[]},{"line":"  match cached_initially_validated_transition_result with","counters":[]},{"line":"  | Ok x ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Deferred.return @@ Ok (`Building_path x)","counters":[]},{"line":"  | Error (`In_frontier hash) ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      [%log trace]","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"        \"transition queried during ledger catchup has already been seen\" ;","counters":[]},{"line":"      Deferred.return @@ Ok (`In_frontier hash)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  | Error (`In_process consumed_state) -> (","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      [%log trace]","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"        \"transition queried during ledger catchup is still in process in one \\","counters":[]},{"line":"         of the components in transition_frontier\" ;","counters":[]},{"line":"      match%map Ivar.read consumed_state with","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"      | `Failed ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          [%log trace] \"transition queried during ledger catchup failed\" ;","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"          Error (Error.of_string \"Previous transition failed\")","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"      | `Success hash ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Ok (`In_frontier hash) )","counters":[]},{"line":"  | Error (`Verifier_error error) ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      [%log warn]","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"        ~metadata:[ (\"error\", Error_json.error_to_yojson error) ]","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"        \"verifier threw an error while verifying transiton queried during \\","counters":[]},{"line":"         ledger catchup: $error\" ;","counters":[]},{"line":"      Deferred.Or_error.fail (Error.tag ~tag:\"verifier threw an error\" error)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"  | Error `Invalid_proof ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let%map () =","counters":[]},{"line":"        Trust_system.record_envelope_sender trust_system logger sender","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"          ( Trust_system.Actions.Gossiped_invalid_transition","counters":[]},{"line":"          , Some (\"invalid proof\", []) )","counters":[]},{"line":"      in","counters":[]},{"line":"      Error (Error.of_string \"invalid proof\")","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"  | Error `Invalid_genesis_protocol_state ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let%map () =","counters":[]},{"line":"        Trust_system.record_envelope_sender trust_system logger sender","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"          ( Trust_system.Actions.Gossiped_invalid_transition","counters":[]},{"line":"          , Some (\"invalid genesis protocol state\", []) )","counters":[]},{"line":"      in","counters":[]},{"line":"      Error (Error.of_string \"invalid genesis protocol state\")","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"  | Error `Invalid_delta_block_chain_proof ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let%map () =","counters":[]},{"line":"        Trust_system.record_envelope_sender trust_system logger sender","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"          ( Trust_system.Actions.Gossiped_invalid_transition","counters":[]},{"line":"          , Some (\"invalid delta transition chain witness\", []) )","counters":[]},{"line":"      in","counters":[]},{"line":"      Error (Error.of_string \"invalid delta transition chain witness\")","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"  | Error `Invalid_protocol_version ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let transition = Mina_block.Validation.block transition_with_hash in","counters":[]},{"line":"      let%map () =","counters":[]},{"line":"        Trust_system.record_envelope_sender trust_system logger sender","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"          ( Trust_system.Actions.Sent_invalid_protocol_version","counters":[]},{"line":"          , Some","counters":[]},{"line":"              ( \"Invalid current or proposed protocol version in catchup block\"","counters":[]},{"line":"              , [ ( \"current_protocol_version\"","counters":[]},{"line":"                  , `String","counters":[]},{"line":"                      ( Mina_block.Header.current_protocol_version","counters":[{"col_start":65,"col_end":65,"count":0}]},{"line":"                          (Mina_block.header transition)","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"                      |> Protocol_version.to_string ) )","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                ; ( \"proposed_protocol_version\"","counters":[]},{"line":"                  , `String","counters":[]},{"line":"                      ( Mina_block.Header.proposed_protocol_version_opt","counters":[{"col_start":70,"col_end":70,"count":0}]},{"line":"                          (Mina_block.header transition)","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"                      |> Option.value_map ~default:\"<None>\"","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"                           ~f:Protocol_version.to_string ) )","counters":[]},{"line":"                ] ) )","counters":[]},{"line":"      in","counters":[]},{"line":"      Error (Error.of_string \"invalid protocol version\")","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"  | Error `Mismatched_protocol_version ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let transition = Mina_block.Validation.block transition_with_hash in","counters":[]},{"line":"      let%map () =","counters":[]},{"line":"        Trust_system.record_envelope_sender trust_system logger sender","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"          ( Trust_system.Actions.Sent_mismatched_protocol_version","counters":[]},{"line":"          , Some","counters":[]},{"line":"              ( \"Current protocol version in catchup block does not match \\","counters":[]},{"line":"                 daemon protocol version\"","counters":[]},{"line":"              , [ ( \"block_current_protocol_version\"","counters":[]},{"line":"                  , `String","counters":[]},{"line":"                      ( Mina_block.Header.current_protocol_version","counters":[{"col_start":65,"col_end":65,"count":0}]},{"line":"                          (Mina_block.header transition)","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"                      |> Protocol_version.to_string ) )","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                ; ( \"daemon_current_protocol_version\"","counters":[]},{"line":"                  , `String Protocol_version.(get_current () |> to_string) )","counters":[{"col_start":56,"col_end":56,"count":0},{"col_start":72,"col_end":72,"count":0}]},{"line":"                ] ) )","counters":[]},{"line":"      in","counters":[]},{"line":"      Error (Error.of_string \"mismatched protocol version\")","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"  | Error `Disconnected ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Deferred.Or_error.fail @@ Error.of_string \"disconnected chain\"","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"","counters":[]},{"line":"let rec fold_until ~(init : 'accum)","counters":[]},{"line":"    ~(f :","counters":[]},{"line":"       'accum -> 'a -> ('accum, 'final) Continue_or_stop.t Deferred.Or_error.t","counters":[]},{"line":"       ) ~(finish : 'accum -> 'final Deferred.Or_error.t) :","counters":[]},{"line":"    'a list -> 'final Deferred.Or_error.t = function","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"  | [] ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      finish init","counters":[]},{"line":"  | x :: xs -> (","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let open Deferred.Or_error.Let_syntax in","counters":[]},{"line":"      match%bind f init x with","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"      | Continue_or_stop.Stop res ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Deferred.Or_error.return res","counters":[]},{"line":"      | Continue_or_stop.Continue init ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          fold_until ~init ~f ~finish xs )","counters":[]},{"line":"","counters":[]},{"line":"let find_map_ok l ~f =","counters":[]},{"line":"  Deferred.repeat_until_finished (l, []) (fun (l, errors) ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      match l with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | [] ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let errors = List.rev errors in","counters":[]},{"line":"          Deferred.return @@ `Finished (Error errors)","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"      | hd :: tl ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Deferred.map (f hd) ~f:(function","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"            | Error current_error ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                `Repeat (tl, current_error :: errors)","counters":[]},{"line":"            | Ok result ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                `Finished (Ok result) ) )","counters":[]},{"line":"","counters":[]},{"line":"type download_state_hashes_error =","counters":[]},{"line":"  [ `Peer_moves_too_fast of Error.t","counters":[]},{"line":"  | `No_common_ancestor of Error.t","counters":[]},{"line":"  | `Failed_to_download_transition_chain_proof of Error.t","counters":[]},{"line":"  | `Invalid_transition_chain_proof of Error.t ]","counters":[]},{"line":"","counters":[]},{"line":"let display_error = function","counters":[]},{"line":"  | `Peer_moves_too_fast err ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Error.to_string_hum err","counters":[]},{"line":"  | `No_common_ancestor err ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Error.to_string_hum err","counters":[]},{"line":"  | `Failed_to_download_transition_chain_proof err ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Error.to_string_hum err","counters":[]},{"line":"  | `Invalid_transition_chain_proof err ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Error.to_string_hum err","counters":[]},{"line":"","counters":[]},{"line":"let rec contains_no_common_ancestor = function","counters":[]},{"line":"  | [] ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      false","counters":[]},{"line":"  | `No_common_ancestor _ :: _ ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      true","counters":[]},{"line":"  | _ :: errors ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      contains_no_common_ancestor errors","counters":[]},{"line":"","counters":[]},{"line":"let to_error = function","counters":[]},{"line":"  | `Peer_moves_too_fast err ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      err","counters":[]},{"line":"  | `No_common_ancestor err ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      err","counters":[]},{"line":"  | `Failed_to_download_transition_chain_proof err ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      err","counters":[]},{"line":"  | `Invalid_transition_chain_proof err ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      err","counters":[]},{"line":"","counters":[]},{"line":"(* returns a list of state-hashes with the older ones at the front *)","counters":[]},{"line":"let download_state_hashes ~logger ~trust_system ~network ~frontier ~peers","counters":[]},{"line":"    ~target_hash ~job ~hash_tree ~blockchain_length_of_target_hash =","counters":[]},{"line":"  [%log debug]","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":13,"col_end":13,"count":0}]},{"line":"    ~metadata:[ (\"target_hash\", State_hash.to_yojson target_hash) ]","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"    \"Doing a catchup job with target $target_hash\" ;","counters":[]},{"line":"  let blockchain_length_of_root =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Transition_frontier.root frontier","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"    |> Transition_frontier.Breadcrumb.consensus_state","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"    |> Consensus.Data.Consensus_state.blockchain_length","counters":[]},{"line":"  in","counters":[]},{"line":"  let open Deferred.Result.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  find_map_ok peers ~f:(fun peer ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"      let%bind transition_chain_proof =","counters":[]},{"line":"        let open Deferred.Let_syntax in","counters":[]},{"line":"        match%map","counters":[]},{"line":"          Mina_networking.get_transition_chain_proof network peer target_hash","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"        with","counters":[]},{"line":"        | Error err ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Result.fail @@ `Failed_to_download_transition_chain_proof err","counters":[]},{"line":"        | Ok transition_chain_proof ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Result.return transition_chain_proof","counters":[]},{"line":"      in","counters":[]},{"line":"      (* a list of state_hashes from new to old *)","counters":[]},{"line":"      let%bind hashes =","counters":[]},{"line":"        match","counters":[]},{"line":"          Transition_chain_verifier.verify ~target_hash ~transition_chain_proof","counters":[]},{"line":"        with","counters":[]},{"line":"        | Some hashes ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Deferred.Result.return hashes","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"        | None ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let error_msg =","counters":[]},{"line":"              sprintf !\"Peer %{sexp:Network_peer.Peer.t} sent us bad proof\" peer","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"            in","counters":[]},{"line":"            let%bind.Deferred () =","counters":[]},{"line":"              Trust_system.(","counters":[]},{"line":"                record trust_system logger peer","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                  Actions.","counters":[]},{"line":"                    ( Sent_invalid_transition_chain_merkle_proof","counters":[]},{"line":"                    , Some (error_msg, []) ))","counters":[]},{"line":"            in","counters":[]},{"line":"            Deferred.Result.fail","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            @@ `Invalid_transition_chain_proof (Error.of_string error_msg)","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"      in","counters":[]},{"line":"      Deferred.return","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      @@ List.fold_until","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"           (Non_empty_list.to_list hashes)","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"           ~init:(blockchain_length_of_target_hash, [])","counters":[]},{"line":"           ~f:(fun (blockchain_length, acc) hash ->","counters":[]},{"line":"             match Transition_frontier.find frontier hash with","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"             | Some final ->","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                 Continue_or_stop.Stop","counters":[]},{"line":"                   (Ok (peer, Frontier_base.Breadcrumb.state_hash final, acc))","counters":[{"col_start":64,"col_end":64,"count":0}]},{"line":"             | None ->","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                 Continue_or_stop.Continue","counters":[]},{"line":"                   (Unsigned.UInt32.pred blockchain_length, hash :: acc) )","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"           ~finish:(fun (blockchain_length, acc) ->","counters":[]},{"line":"             let module T = struct","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"               type t = State_hash.t list [@@deriving to_yojson]","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":24,"col_end":24,"count":0},{"col_start":40,"col_end":40,"count":0}]},{"line":"             end in","counters":[]},{"line":"             let all_hashes =","counters":[]},{"line":"               List.map (Transition_frontier.all_breadcrumbs frontier)","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"                 ~f:(fun b -> Frontier_base.Breadcrumb.state_hash b)","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"             in","counters":[]},{"line":"             [%log debug]","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":24,"col_end":24,"count":0}]},{"line":"               ~metadata:","counters":[]},{"line":"                 [ (\"n\", `Int (List.length acc))","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"                 ; (\"hashes\", T.to_yojson acc)","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"                 ; (\"all_hashes\", T.to_yojson all_hashes)","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"                 ]","counters":[]},{"line":"               \"Finishing download_state_hashes with $n $hashes. with \\","counters":[]},{"line":"                $all_hashes\" ;","counters":[]},{"line":"             if","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"               Unsigned.UInt32.compare blockchain_length","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                 blockchain_length_of_root","counters":[]},{"line":"               <= 0","counters":[]},{"line":"             then","counters":[]},{"line":"               Result.fail","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"               @@ `No_common_ancestor","counters":[]},{"line":"                    (Error.of_string","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                       \"Requested block doesn't have a path to the root of our \\","counters":[]},{"line":"                        frontier\" )","counters":[]},{"line":"             else","counters":[]},{"line":"               let err_msg =","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                 sprintf !\"Peer %{sexp:Network_peer.Peer.t} moves too fast\" peer","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"               in","counters":[]},{"line":"               Result.fail @@ `Peer_moves_too_fast (Error.of_string err_msg) ) )","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"  >>| fun (peer, final, hashes) ->","counters":[]},{"line":"  let (_ : State_hash.t) =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    List.fold hashes ~init:final ~f:(fun parent h ->","counters":[]},{"line":"        Transition_frontier.Catchup_hash_tree.add hash_tree h ~parent ~job ;","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        h )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"  in","counters":[]},{"line":"  (peer, hashes)","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let verify_against_hashes transitions hashes =","counters":[]},{"line":"  List.length transitions = List.length hashes","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":12,"col_end":12,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"  && List.for_all2_exn transitions hashes ~f:(fun transition hash ->","counters":[{"col_start":5,"col_end":5,"count":0}]},{"line":"         State_hash.equal","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"           (State_hash.With_state_hashes.state_hash transition)","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"           hash )","counters":[]},{"line":"","counters":[]},{"line":"let rec partition size = function","counters":[]},{"line":"  | [] ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      []","counters":[]},{"line":"  | ls ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let sub, rest = List.split_n ls size in","counters":[]},{"line":"      sub :: partition size rest","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"","counters":[]},{"line":"module Peers_pool = struct","counters":[]},{"line":"  type t =","counters":[]},{"line":"    { preferred : Peer.t Queue.t","counters":[]},{"line":"    ; normal : Peer.t Queue.t","counters":[]},{"line":"    ; busy : Peer.Hash_set.t","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let create ~busy ~preferred peers =","counters":[]},{"line":"    { preferred = Queue.of_list preferred; normal = Queue.of_list peers; busy }","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"","counters":[]},{"line":"  let dequeue { preferred; normal; busy } =","counters":[]},{"line":"    let find_available q =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let n = Queue.length q in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let rec go tried =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        if tried = n then `All_busy","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"        else","counters":[]},{"line":"          match Queue.dequeue q with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              `Empty","counters":[]},{"line":"          | Some x ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              if Hash_set.mem busy x then (","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"                Queue.enqueue q x ;","counters":[]},{"line":"                go (tried + 1) )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"              else `Available x","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"      in","counters":[]},{"line":"      go 0","counters":[]},{"line":"    in","counters":[]},{"line":"    match find_available preferred with","counters":[]},{"line":"    | `Available x ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        `Available x","counters":[]},{"line":"    | `Empty ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        find_available normal","counters":[]},{"line":"    | `All_busy -> (","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        match find_available normal with","counters":[]},{"line":"        | `Available x ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            `Available x","counters":[]},{"line":"        | `Empty | `All_busy ->","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"            `All_busy )","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(* returns a list of transitions with old ones comes first *)","counters":[]},{"line":"let download_transitions ~target_hash ~logger ~trust_system ~network","counters":[]},{"line":"    ~preferred_peer ~hashes_of_missing_transitions =","counters":[]},{"line":"  let busy = Peer.Hash_set.create () in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  Deferred.Or_error.List.concat_map","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    (partition Transition_frontier.max_catchup_chunk_length","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"       hashes_of_missing_transitions ) ~how:`Parallel ~f:(fun hashes ->","counters":[]},{"line":"      let%bind.Async.Deferred peers = Mina_networking.peers network in","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"      let peers =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Peers_pool.create ~busy ~preferred:[ preferred_peer ]","counters":[]},{"line":"          (List.permute peers)","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"      in","counters":[]},{"line":"      let rec go errs =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        match Peers_pool.dequeue peers with","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        | `Empty ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (* Tried everyone *)","counters":[]},{"line":"            Deferred.return (Error (Error.of_list (List.rev errs)))","counters":[{"col_start":48,"col_end":48,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"        | `All_busy ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let%bind () = after (Time.Span.of_sec 10.) in","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"            go errs","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"        | `Available peer -> (","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Hash_set.add busy peer ;","counters":[]},{"line":"            let%bind res =","counters":[]},{"line":"              Deferred.Or_error.try_with_join ~here:[%here] (fun () ->","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"                  let open Deferred.Or_error.Let_syntax in","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  [%log debug]","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                    ~metadata:","counters":[]},{"line":"                      [ (\"n\", `Int (List.length hashes))","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"                      ; (\"peer\", Peer.to_yojson peer)","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"                      ; (\"target_hash\", State_hash.to_yojson target_hash)","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"                      ]","counters":[]},{"line":"                    \"requesting $n blocks from $peer for catchup to \\","counters":[]},{"line":"                     $target_hash\" ;","counters":[]},{"line":"                  let%bind transitions =","counters":[]},{"line":"                    match%map.Async.Deferred","counters":[]},{"line":"                      Mina_networking.get_transition_chain network peer hashes","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"                    with","counters":[]},{"line":"                    | Ok x ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        Ok x","counters":[]},{"line":"                    | Error e ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        [%log debug]","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                          ~metadata:","counters":[]},{"line":"                            [ (\"error\", `String (Error.to_string_hum e))","counters":[{"col_start":67,"col_end":67,"count":0}]},{"line":"                            ; (\"n\", `Int (List.length hashes))","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"                            ; (\"peer\", Peer.to_yojson peer)","counters":[{"col_start":52,"col_end":52,"count":0}]},{"line":"                            ]","counters":[]},{"line":"                          \"$error from downloading $n blocks from $peer\" ;","counters":[]},{"line":"                        Error e","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                  in","counters":[]},{"line":"                  Mina_metrics.(","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    Gauge.set","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                      Transition_frontier_controller","counters":[]},{"line":"                      .transitions_downloaded_from_catchup","counters":[]},{"line":"                      (Float.of_int (List.length transitions))) ;","counters":[{"col_start":34,"col_end":34,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"                  [%log debug]","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                    ~metadata:","counters":[]},{"line":"                      [ (\"n\", `Int (List.length transitions))","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"                      ; (\"peer\", Peer.to_yojson peer)","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"                      ]","counters":[]},{"line":"                    \"downloaded $n blocks from $peer\" ;","counters":[]},{"line":"                  let hashed_transitions =","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    List.map transitions","counters":[]},{"line":"                      ~f:","counters":[]},{"line":"                        (With_hash.of_data","counters":[]},{"line":"                           ~hash_data:","counters":[]},{"line":"                             (Fn.compose Mina_state.Protocol_state.hashes","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"                                (Fn.compose Mina_block.Header.protocol_state","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"                                   Mina_block.header ) ) )","counters":[]},{"line":"                  in","counters":[]},{"line":"                  if not @@ verify_against_hashes hashed_transitions hashes then (","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":48,"col_end":48,"count":0},{"col_start":81,"col_end":81,"count":0}]},{"line":"                    let error_msg =","counters":[]},{"line":"                      sprintf","counters":[]},{"line":"                        !\"Peer %{sexp:Network_peer.Peer.t} returned a list \\","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                          that is different from the one that is requested.\"","counters":[]},{"line":"                        peer","counters":[]},{"line":"                    in","counters":[]},{"line":"                    Trust_system.(","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      record trust_system logger peer","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                        Actions.(Violated_protocol, Some (error_msg, [])))","counters":[]},{"line":"                    |> don't_wait_for ;","counters":[]},{"line":"                    Deferred.Or_error.error_string error_msg )","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                  else","counters":[]},{"line":"                    Deferred.Or_error.return","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                    @@ List.map hashed_transitions ~f:(fun data ->","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                           Envelope.Incoming.wrap_peer ~data ~sender:peer ) )","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"            in","counters":[]},{"line":"            Hash_set.remove busy peer ;","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            match res with","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            | Ok x ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Deferred.return (Ok x)","counters":[]},{"line":"            | Error e ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                go (e :: errs) )","counters":[]},{"line":"      in","counters":[]},{"line":"      go [] )","counters":[]},{"line":"","counters":[]},{"line":"let verify_transitions_and_build_breadcrumbs ~context:(module Context : CONTEXT)","counters":[]},{"line":"    ~trust_system ~verifier ~frontier ~unprocessed_transition_cache ~transitions","counters":[]},{"line":"    ~target_hash ~subtrees =","counters":[]},{"line":"  let open Context in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let open Deferred.Or_error.Let_syntax in","counters":[]},{"line":"  let verification_start_time = Core.Time.now () in","counters":[]},{"line":"  let%bind transitions_with_initial_validation, initial_hash =","counters":[]},{"line":"    let%bind tvs =","counters":[]},{"line":"      let open Deferred.Let_syntax in","counters":[]},{"line":"      let genesis_state_hash =","counters":[]},{"line":"        Precomputed_values.genesis_state_with_hashes precomputed_values","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"        |> State_hash.With_state_hashes.state_hash","counters":[]},{"line":"      in","counters":[]},{"line":"      match%bind","counters":[]},{"line":"        Mina_block.Validation.validate_proofs ~verifier ~genesis_state_hash","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"          (List.map transitions ~f:(fun t ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"               Mina_block.Validation.wrap (Envelope.Incoming.data t) ) )","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"      with","counters":[]},{"line":"      | Ok tvs ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          return","counters":[]},{"line":"            (Ok","counters":[]},{"line":"               (List.map2_exn transitions tvs ~f:(fun e data ->","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                    (* this does not update the envelope timestamps *)","counters":[]},{"line":"                    { e with data } ) ) )","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"      | Error (`Verifier_error error) ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          [%log warn]","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"            ~metadata:[ (\"error\", Error_json.error_to_yojson error) ]","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"            \"verifier threw an error while verifying transition queried during \\","counters":[]},{"line":"             ledger catchup: $error\" ;","counters":[]},{"line":"          Deferred.Or_error.fail","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            (Error.tag ~tag:\"verifier threw an error\" error)","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"      | Error `Invalid_proof ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let%map () =","counters":[]},{"line":"            (* TODO: Isolate and punish all the evil sender *)","counters":[]},{"line":"            Deferred.unit","counters":[]},{"line":"          in","counters":[]},{"line":"          Error (Error.of_string \"invalid proof\")","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"    in","counters":[]},{"line":"    let verification_end_time = Core.Time.now () in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    [%log debug]","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":15,"col_end":15,"count":0}]},{"line":"      ~metadata:","counters":[]},{"line":"        [ (\"target_hash\", State_hash.to_yojson target_hash)","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"        ; ( \"time_elapsed\"","counters":[]},{"line":"          , `Float","counters":[]},{"line":"              Core.Time.(","counters":[]},{"line":"                Span.to_sec","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                @@ diff verification_end_time verification_start_time) )","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"        ]","counters":[]},{"line":"      \"verification of proofs complete\" ;","counters":[]},{"line":"    fold_until (List.rev tvs) ~init:[]","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"      ~f:(fun acc transition ->","counters":[]},{"line":"        let open Deferred.Let_syntax in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        match%bind","counters":[]},{"line":"          verify_transition","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"            ~context:(module Context)","counters":[]},{"line":"            ~trust_system ~frontier ~unprocessed_transition_cache transition","counters":[]},{"line":"        with","counters":[]},{"line":"        | Error e ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            List.iter acc ~f:(fun (node, vc) ->","counters":[]},{"line":"                (* TODO consider rejecting the callback in some cases,","counters":[]},{"line":"                   see https://github.com/MinaProtocol/mina/issues/11087 *)","counters":[]},{"line":"                Option.value_map vc ~default:ignore","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  ~f:Mina_net2.Validation_callback.fire_if_not_already_fired","counters":[]},{"line":"                  `Ignore ;","counters":[]},{"line":"                ignore @@ Cached.invalidate_with_failure node ) ;","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"            Deferred.Or_error.fail e","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"        | Ok (`In_frontier initial_hash) ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Deferred.Or_error.return @@ Continue_or_stop.Stop (acc, initial_hash)","counters":[]},{"line":"        | Ok (`Building_path transition_with_initial_validation) ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Deferred.Or_error.return","counters":[]},{"line":"            @@ Continue_or_stop.Continue","counters":[]},{"line":"                 (* It's fine to pass None as validation callback here because","counters":[]},{"line":"                    this function is called only for downloaded transitions *)","counters":[]},{"line":"                 ((transition_with_initial_validation, None) :: acc) )","counters":[]},{"line":"      ~finish:(fun acc ->","counters":[]},{"line":"        let validation_end_time = Core.Time.now () in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        [%log debug]","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"          ~metadata:","counters":[]},{"line":"            [ (\"target_hash\", State_hash.to_yojson target_hash)","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"            ; ( \"time_elapsed\"","counters":[]},{"line":"              , `Float","counters":[]},{"line":"                  Core.Time.(","counters":[]},{"line":"                    Span.to_sec","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                    @@ diff validation_end_time verification_end_time) )","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"            ]","counters":[]},{"line":"          \"validation of transitions complete\" ;","counters":[]},{"line":"        if List.length transitions <= 0 then","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"          Deferred.Or_error.return ([], target_hash)","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        else","counters":[]},{"line":"          let oldest_missing_transition =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            List.hd_exn transitions |> Envelope.Incoming.data |> With_hash.data","counters":[{"col_start":22,"col_end":22,"count":0},{"col_start":60,"col_end":60,"count":0}]},{"line":"          in","counters":[]},{"line":"          let initial_state_hash =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            oldest_missing_transition |> Mina_block.header","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"            |> Mina_block.Header.protocol_state","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"            |> Mina_state.Protocol_state.previous_state_hash","counters":[]},{"line":"          in","counters":[]},{"line":"          Deferred.Or_error.return (acc, initial_state_hash) )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"  in","counters":[]},{"line":"  let build_start_time = Core.Time.now () in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let trees_of_transitions =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Option.fold (Non_empty_list.of_list_opt transitions_with_initial_validation)","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"      ~init:subtrees ~f:(fun _ transitions ->","counters":[]},{"line":"        [ Rose_tree.of_non_empty_list ~subtrees transitions ] )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"  in","counters":[]},{"line":"  let open Deferred.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  match%bind","counters":[]},{"line":"    Transition_handler.Breadcrumb_builder.build_subtrees_of_breadcrumbs ~logger","counters":[{"col_start":70,"col_end":70,"count":0}]},{"line":"      ~precomputed_values ~verifier ~trust_system ~frontier ~initial_hash","counters":[]},{"line":"      trees_of_transitions","counters":[]},{"line":"  with","counters":[]},{"line":"  | Ok result ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      [%log debug]","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"        ~metadata:","counters":[]},{"line":"          [ (\"target_hash\", State_hash.to_yojson target_hash)","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"          ; ( \"time_elapsed\"","counters":[]},{"line":"            , `Float Core.Time.(Span.to_sec @@ diff (now ()) build_start_time)","counters":[{"col_start":42,"col_end":42,"count":0},{"col_start":50,"col_end":50,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"            )","counters":[]},{"line":"          ]","counters":[]},{"line":"        \"build of breadcrumbs complete\" ;","counters":[]},{"line":"      Deferred.Or_error.return result","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  | Error e ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      [%log debug]","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"        ~metadata:","counters":[]},{"line":"          [ (\"target_hash\", State_hash.to_yojson target_hash)","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"          ; ( \"time_elapsed\"","counters":[]},{"line":"            , `Float Core.Time.(Span.to_sec @@ diff (now ()) build_start_time)","counters":[{"col_start":42,"col_end":42,"count":0},{"col_start":50,"col_end":50,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"            )","counters":[]},{"line":"          ; (\"error\", `String (Error.to_string_hum e))","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"          ]","counters":[]},{"line":"        \"build of breadcrumbs failed with $error\" ;","counters":[]},{"line":"      ( try","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          List.iter transitions_with_initial_validation ~f:(fun (node, vc) ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"              (* TODO consider rejecting the callback in some cases,","counters":[]},{"line":"                 see https://github.com/MinaProtocol/mina/issues/11087 *)","counters":[]},{"line":"              Option.value_map vc ~default:ignore","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ~f:Mina_net2.Validation_callback.fire_if_not_already_fired","counters":[]},{"line":"                `Ignore ;","counters":[]},{"line":"              ignore @@ Cached.invalidate_with_failure node )","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"        with e ->","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"          [%log error]","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"            ~metadata:[ (\"exn\", `String (Exn.to_string e)) ]","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"            \"$exn in cached\" ) ;","counters":[]},{"line":"      Deferred.Or_error.fail e","counters":[]},{"line":"","counters":[]},{"line":"let garbage_collect_subtrees ~logger ~subtrees =","counters":[]},{"line":"  List.iter subtrees ~f:(fun subtree ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      Rose_tree.iter subtree ~f:(fun (node, vc) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"          (* TODO consider rejecting the callback in some cases,","counters":[]},{"line":"             see https://github.com/MinaProtocol/mina/issues/11087 *)","counters":[]},{"line":"          Option.value_map vc ~default:ignore","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ~f:Mina_net2.Validation_callback.fire_if_not_already_fired `Ignore ;","counters":[]},{"line":"          ignore @@ Cached.invalidate_with_failure node ) ) ;","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"  [%log trace] \"garbage collected failed cached transitions\"","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":13,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"let run ~context:(module Context : CONTEXT) ~trust_system ~verifier ~network","counters":[]},{"line":"    ~frontier ~catchup_job_reader ~catchup_breadcrumbs_writer","counters":[]},{"line":"    ~unprocessed_transition_cache : unit =","counters":[]},{"line":"  let open Context in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let hash_tree =","counters":[]},{"line":"    match Transition_frontier.catchup_tree frontier with","counters":[]},{"line":"    | Hash t ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        t","counters":[]},{"line":"    | Full _ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        failwith","counters":[]},{"line":"          \"If normal catchup is running, the frontier should have a hash tree, \\","counters":[]},{"line":"           got a full one.\"","counters":[]},{"line":"  in","counters":[]},{"line":"  O1trace.background_thread \"perform_normal_catchup\" (fun () ->","counters":[]},{"line":"      Strict_pipe.Reader.iter_without_pushback catchup_job_reader","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ~f:(fun (target_hash, subtrees) ->","counters":[]},{"line":"          let job =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Transition_frontier.Catchup_hash_tree.Catchup_job_id.create ()","counters":[]},{"line":"          in","counters":[]},{"line":"          let notify_hash_tree_of_failure () =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Transition_frontier.(Catchup_hash_tree.catchup_failed hash_tree job)","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          in","counters":[]},{"line":"          don't_wait_for","counters":[]},{"line":"            (let start_time = Core.Time.now () in","counters":[]},{"line":"             [%log info] \"Catch up to $target_hash\"","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":23,"col_end":23,"count":0}]},{"line":"               ~metadata:[ (\"target_hash\", State_hash.to_yojson target_hash) ] ;","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"             let%bind () = Catchup_jobs.incr () in","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"             let blockchain_length_of_target_hash =","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"               let blockchain_length_of_dangling_block =","counters":[]},{"line":"                 List.hd_exn subtrees |> Rose_tree.root |> Tuple2.get1","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":54,"col_end":54,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"                 |> Cached.peek |> Envelope.Incoming.data","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"                 |> Mina_block.Validation.block |> Mina_block.blockchain_length","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"               in","counters":[]},{"line":"               Unsigned.UInt32.pred blockchain_length_of_dangling_block","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"             in","counters":[]},{"line":"             let subtree_peers =","counters":[]},{"line":"               List.fold subtrees ~init:[] ~f:(fun acc_outer tree ->","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                   let cacheds = Rose_tree.flatten tree in","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"                   let cached_peers =","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"                     List.fold cacheds ~init:[]","counters":[]},{"line":"                       ~f:(fun acc_inner (cached, _vc) ->","counters":[]},{"line":"                         let envelope = Cached.peek cached in","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                         match Envelope.Incoming.sender envelope with","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                         | Local ->","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                             acc_inner","counters":[]},{"line":"                         | Remote peer ->","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                             peer :: acc_inner )","counters":[]},{"line":"                   in","counters":[]},{"line":"                   cached_peers @ acc_outer )","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"               |> List.dedup_and_sort ~compare:Peer.compare","counters":[]},{"line":"             in","counters":[]},{"line":"             match%bind","counters":[]},{"line":"               let open Deferred.Or_error.Let_syntax in","counters":[]},{"line":"               let%bind preferred_peer, hashes_of_missing_transitions =","counters":[]},{"line":"                 (* try peers from subtrees first *)","counters":[]},{"line":"                 let open Deferred.Let_syntax in","counters":[]},{"line":"                 match%bind","counters":[]},{"line":"                   download_state_hashes ~hash_tree ~logger ~trust_system","counters":[]},{"line":"                     ~network ~frontier ~peers:subtree_peers ~target_hash ~job","counters":[]},{"line":"                     ~blockchain_length_of_target_hash","counters":[]},{"line":"                 with","counters":[]},{"line":"                 | Ok (peer, hashes) ->","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"                     return (Ok (peer, hashes))","counters":[]},{"line":"                 | Error errors -> (","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"                     [%log info]","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                       \"Could not download state hashes using peers from \\","counters":[]},{"line":"                        subtrees; trying again with random peers\"","counters":[]},{"line":"                       ~metadata:","counters":[]},{"line":"                         [ ( \"errors\"","counters":[]},{"line":"                           , `List","counters":[]},{"line":"                               (List.map errors ~f:(fun err ->","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"                                    `String (display_error err) ) ) )","counters":[{"col_start":36,"col_end":36,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"                         ] ;","counters":[]},{"line":"                     let%bind random_peers =","counters":[]},{"line":"                       Mina_networking.peers network >>| List.permute","counters":[{"col_start":43,"col_end":43,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"                     in","counters":[]},{"line":"                     match%bind","counters":[]},{"line":"                       download_state_hashes ~hash_tree ~logger ~trust_system","counters":[]},{"line":"                         ~network ~frontier ~peers:random_peers ~target_hash","counters":[]},{"line":"                         ~job ~blockchain_length_of_target_hash","counters":[]},{"line":"                     with","counters":[]},{"line":"                     | Ok (peer, hashes) ->","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                         return (Ok (peer, hashes))","counters":[]},{"line":"                     | Error errors ->","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"                         [%log info]","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                           \"Could not download state hashes using random peers\"","counters":[]},{"line":"                           ~metadata:","counters":[]},{"line":"                             [ ( \"errors\"","counters":[]},{"line":"                               , `List","counters":[]},{"line":"                                   (List.map errors ~f:(fun err ->","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"                                        `String (display_error err) ) ) )","counters":[{"col_start":40,"col_end":40,"count":0},{"col_start":61,"col_end":61,"count":0}]},{"line":"                             ] ;","counters":[]},{"line":"                         if contains_no_common_ancestor errors then","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                           List.iter subtrees ~f:(fun subtree ->","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"                               let transition =","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                                 Rose_tree.root subtree |> Tuple2.get1","counters":[{"col_start":46,"col_end":46,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"                                 |> Cached.peek |> Envelope.Incoming.data","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"                               in","counters":[]},{"line":"                               let children_transitions =","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                                 List.concat_map","counters":[]},{"line":"                                   (Rose_tree.children subtree)","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"                                   ~f:Rose_tree.flatten","counters":[]},{"line":"                               in","counters":[]},{"line":"                               let children_state_hashes =","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                                 List.map children_transitions","counters":[]},{"line":"                                   ~f:(fun (cached_transition, _vc) ->","counters":[]},{"line":"                                     Cached.peek cached_transition","counters":[{"col_start":37,"col_end":37,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"                                     |> Envelope.Incoming.data","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"                                     |> Mina_block.Validation.block_with_hash","counters":[{"col_start":76,"col_end":76,"count":0}]},{"line":"                                     |> State_hash.With_state_hashes.state_hash )","counters":[]},{"line":"                               in","counters":[]},{"line":"                               [%log error]","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"                                 ~metadata:","counters":[]},{"line":"                                   [ ( \"state_hashes_of_children\"","counters":[]},{"line":"                                     , `List","counters":[]},{"line":"                                         (List.map children_state_hashes","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"                                            ~f:State_hash.to_yojson ) )","counters":[]},{"line":"                                   ; ( \"state_hash\"","counters":[]},{"line":"                                     , State_hash.to_yojson","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"                                         ( transition","counters":[]},{"line":"                                         |> Mina_block.Validation","counters":[]},{"line":"                                            .block_with_hash","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"                                         |> State_hash.With_state_hashes","counters":[]},{"line":"                                            .state_hash ) )","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"                                   ; ( \"reason\"","counters":[]},{"line":"                                     , `String","counters":[]},{"line":"                                         \"no common ancestor with our \\","counters":[]},{"line":"                                          transition frontier\" )","counters":[]},{"line":"                                   ; ( \"protocol_state\"","counters":[]},{"line":"                                     , Mina_block.Validation.block transition","counters":[{"col_start":65,"col_end":65,"count":0}]},{"line":"                                       |> Mina_block.header","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"                                       |> Mina_block.Header.protocol_state","counters":[{"col_start":73,"col_end":73,"count":0}]},{"line":"                                       |> Mina_state.Protocol_state","counters":[]},{"line":"                                          .value_to_yojson )","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"                                   ]","counters":[]},{"line":"                                 \"Validation error: external transition with \\","counters":[]},{"line":"                                  state hash $state_hash and its children were \\","counters":[]},{"line":"                                  rejected for reason $reason\" ;","counters":[]},{"line":"                               Mina_metrics.(","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                                 Counter.inc Rejected_blocks.no_common_ancestor","counters":[]},{"line":"                                   ( Float.of_int","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"                                   @@ (1 + List.length children_transitions) )) ) ;","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"                         return","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                           (Error (Error.of_list @@ List.map errors ~f:to_error))","counters":[{"col_start":47,"col_end":47,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"                     )","counters":[]},{"line":"               in","counters":[]},{"line":"               let num_of_missing_transitions =","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                 List.length hashes_of_missing_transitions","counters":[]},{"line":"               in","counters":[]},{"line":"               [%log debug]","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"                 ~metadata:","counters":[]},{"line":"                   [ ( \"hashes_of_missing_transitions\"","counters":[]},{"line":"                     , `List","counters":[]},{"line":"                         (List.map hashes_of_missing_transitions","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"                            ~f:State_hash.to_yojson ) )","counters":[]},{"line":"                   ]","counters":[]},{"line":"                 !\"Number of missing transitions is %d\"","counters":[]},{"line":"                 num_of_missing_transitions ;","counters":[]},{"line":"               let%bind transitions =","counters":[]},{"line":"                 if num_of_missing_transitions <= 0 then","counters":[]},{"line":"                   Deferred.Or_error.return []","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"                 else","counters":[]},{"line":"                   download_transitions ~logger ~trust_system ~network","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"                     ~preferred_peer ~hashes_of_missing_transitions ~target_hash","counters":[]},{"line":"               in","counters":[]},{"line":"               [%log debug]","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"                 ~metadata:[ (\"target_hash\", State_hash.to_yojson target_hash) ]","counters":[{"col_start":64,"col_end":64,"count":0}]},{"line":"                 \"Download transitions complete\" ;","counters":[]},{"line":"               verify_transitions_and_build_breadcrumbs","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                 ~context:(module Context)","counters":[]},{"line":"                 ~trust_system ~verifier ~frontier ~unprocessed_transition_cache","counters":[]},{"line":"                 ~transitions ~target_hash ~subtrees","counters":[]},{"line":"             with","counters":[]},{"line":"             | Ok trees_of_breadcrumbs ->","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                 [%log trace]","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                   ~metadata:","counters":[]},{"line":"                     [ ( \"hashes of transitions\"","counters":[]},{"line":"                       , `List","counters":[]},{"line":"                           (List.map trees_of_breadcrumbs ~f:(fun tree ->","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                                Rose_tree.to_yojson","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                                  (fun (breadcrumb, _vc) ->","counters":[]},{"line":"                                    Cached.peek breadcrumb","counters":[{"col_start":36,"col_end":36,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"                                    |> Transition_frontier.Breadcrumb.state_hash","counters":[{"col_start":79,"col_end":79,"count":0}]},{"line":"                                    |> State_hash.to_yojson )","counters":[]},{"line":"                                  tree ) ) )","counters":[]},{"line":"                     ]","counters":[]},{"line":"                   \"about to write to the catchup breadcrumbs pipe\" ;","counters":[]},{"line":"                 if Strict_pipe.Writer.is_closed catchup_breadcrumbs_writer then (","counters":[{"col_start":17,"col_end":17,"count":0},{"col_start":81,"col_end":81,"count":0}]},{"line":"                   [%log trace]","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                     \"catchup breadcrumbs pipe was closed; attempt to write to \\","counters":[]},{"line":"                      closed pipe\" ;","counters":[]},{"line":"                   notify_hash_tree_of_failure () ;","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"                   garbage_collect_subtrees ~logger","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"                     ~subtrees:trees_of_breadcrumbs ;","counters":[]},{"line":"                   Mina_metrics.(","counters":[]},{"line":"                     Gauge.set Transition_frontier_controller.catchup_time_ms","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                       Core.Time.(Span.to_ms @@ diff (now ()) start_time)) ;","counters":[{"col_start":43,"col_end":43,"count":0},{"col_start":51,"col_end":51,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"                   Catchup_jobs.decr () )","counters":[]},{"line":"                 else","counters":[]},{"line":"                   let ivar = Ivar.create () in","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"                   Strict_pipe.Writer.write catchup_breadcrumbs_writer","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"                     (trees_of_breadcrumbs, `Ledger_catchup ivar) ;","counters":[]},{"line":"                   let%bind () = Ivar.read ivar in","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"                   Mina_metrics.(","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"                     Gauge.set Transition_frontier_controller.catchup_time_ms","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                       Core.Time.(Span.to_ms @@ diff (now ()) start_time)) ;","counters":[{"col_start":43,"col_end":43,"count":0},{"col_start":51,"col_end":51,"count":0},{"col_start":56,"col_end":56,"count":0}]},{"line":"                   Catchup_jobs.decr ()","counters":[]},{"line":"             | Error e ->","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"                 [%log warn]","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                   ~metadata:[ (\"error\", Error_json.error_to_yojson e) ]","counters":[{"col_start":66,"col_end":66,"count":0}]},{"line":"                   \"Catchup process failed -- unable to receive valid data \\","counters":[]},{"line":"                    from peers or transition frontier progressed faster than \\","counters":[]},{"line":"                    catchup data received. See error for details: $error\" ;","counters":[]},{"line":"                 notify_hash_tree_of_failure () ;","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                 garbage_collect_subtrees ~logger ~subtrees ;","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                 Mina_metrics.(","counters":[]},{"line":"                   Gauge.set Transition_frontier_controller.catchup_time_ms","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                     Core.Time.(Span.to_ms @@ diff (now ()) start_time)) ;","counters":[{"col_start":41,"col_end":41,"count":0},{"col_start":49,"col_end":49,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"                 Catchup_jobs.decr () ) ) )","counters":[]},{"line":"","counters":[]},{"line":"(* Unit tests *)","counters":[]},{"line":"","counters":[]},{"line":"let%test_module \"Ledger_catchup tests\" =","counters":[]},{"line":"  ( module struct","counters":[]},{"line":"    let () =","counters":[]},{"line":"      Core.Backtrace.elide := false ;","counters":[]},{"line":"      Async.Scheduler.set_record_backtraces true","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"","counters":[]},{"line":"    let max_frontier_length = 10","counters":[]},{"line":"","counters":[]},{"line":"    let logger = Logger.null ()","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"","counters":[]},{"line":"    let precomputed_values = Lazy.force Precomputed_values.for_unit_tests","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"","counters":[]},{"line":"    let proof_level = precomputed_values.proof_level","counters":[]},{"line":"","counters":[]},{"line":"    let constraint_constants = precomputed_values.constraint_constants","counters":[]},{"line":"","counters":[]},{"line":"    let trust_system = Trust_system.null ()","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"    let time_controller = Block_time.Controller.basic ~logger","counters":[]},{"line":"","counters":[]},{"line":"    let use_super_catchup = false","counters":[]},{"line":"","counters":[]},{"line":"    let verifier =","counters":[]},{"line":"      Async.Thread_safe.block_on_async_exn (fun () ->","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"          Verifier.create ~logger ~proof_level ~constraint_constants","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ~conf_dir:None","counters":[]},{"line":"            ~pids:(Child_processes.Termination.create_pid_table ()) )","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"","counters":[]},{"line":"    module Context = struct","counters":[]},{"line":"      let logger = logger","counters":[]},{"line":"","counters":[]},{"line":"      let precomputed_values = precomputed_values","counters":[]},{"line":"","counters":[]},{"line":"      let constraint_constants = constraint_constants","counters":[]},{"line":"","counters":[]},{"line":"      let consensus_constants = precomputed_values.consensus_constants","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    let downcast_transition transition =","counters":[]},{"line":"      let transition =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        transition","counters":[]},{"line":"        |> Mina_block.Validation.reset_frontier_dependencies_validation","counters":[{"col_start":70,"col_end":70,"count":0}]},{"line":"        |> Mina_block.Validation.reset_staged_ledger_diff_validation","counters":[]},{"line":"      in","counters":[]},{"line":"      Envelope.Incoming.wrap ~data:transition ~sender:Envelope.Sender.Local","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let downcast_breadcrumb breadcrumb =","counters":[]},{"line":"      downcast_transition","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        ( Transition_frontier.Breadcrumb.validated_transition breadcrumb","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"        |> Mina_block.Validated.remember )","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"","counters":[]},{"line":"    type catchup_test =","counters":[]},{"line":"      { cache : Transition_handler.Unprocessed_transition_cache.t","counters":[]},{"line":"      ; job_writer :","counters":[]},{"line":"          ( State_hash.t","counters":[]},{"line":"            * ( ( Mina_block.initial_valid_block Envelope.Incoming.t","counters":[]},{"line":"                , State_hash.t )","counters":[]},{"line":"                Cached.t","counters":[]},{"line":"              * Mina_net2.Validation_callback.t option )","counters":[]},{"line":"              Rose_tree.t","counters":[]},{"line":"              list","counters":[]},{"line":"          , Strict_pipe.crash Strict_pipe.buffered","counters":[]},{"line":"          , unit )","counters":[]},{"line":"          Strict_pipe.Writer.t","counters":[]},{"line":"      ; breadcrumbs_reader :","counters":[]},{"line":"          ( ( (Transition_frontier.Breadcrumb.t, State_hash.t) Cached.t","counters":[]},{"line":"            * Mina_net2.Validation_callback.t option )","counters":[]},{"line":"            Rose_tree.t","counters":[]},{"line":"            list","counters":[]},{"line":"          * [ `Catchup_scheduler | `Ledger_catchup of unit Ivar.t ] )","counters":[]},{"line":"          Strict_pipe.Reader.t","counters":[]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    let run_catchup ~network ~frontier =","counters":[]},{"line":"      let catchup_job_reader, catchup_job_writer =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Strict_pipe.create ~name:(__MODULE__ ^ __LOC__)","counters":[]},{"line":"          (Buffered (`Capacity 10, `Overflow Crash))","counters":[]},{"line":"      in","counters":[]},{"line":"      let catchup_breadcrumbs_reader, catchup_breadcrumbs_writer =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Strict_pipe.create ~name:(__MODULE__ ^ __LOC__)","counters":[]},{"line":"          (Buffered (`Capacity 10, `Overflow Crash))","counters":[]},{"line":"      in","counters":[]},{"line":"      let unprocessed_transition_cache =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Transition_handler.Unprocessed_transition_cache.create ~logger","counters":[]},{"line":"      in","counters":[]},{"line":"      run","counters":[]},{"line":"        ~context:(module Context)","counters":[]},{"line":"        ~verifier ~trust_system ~network ~frontier ~catchup_breadcrumbs_writer","counters":[]},{"line":"        ~catchup_job_reader ~unprocessed_transition_cache ;","counters":[]},{"line":"      { cache = unprocessed_transition_cache","counters":[]},{"line":"      ; job_writer = catchup_job_writer","counters":[]},{"line":"      ; breadcrumbs_reader = catchup_breadcrumbs_reader","counters":[]},{"line":"      }","counters":[]},{"line":"","counters":[]},{"line":"    let run_catchup_with_target ~network ~frontier ~target_breadcrumb =","counters":[]},{"line":"      let test = run_catchup ~network ~frontier in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let parent_hash =","counters":[]},{"line":"        Transition_frontier.Breadcrumb.parent_hash target_breadcrumb","counters":[]},{"line":"      in","counters":[]},{"line":"      let target_transition =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Transition_handler.Unprocessed_transition_cache.register_exn test.cache","counters":[]},{"line":"          (downcast_breadcrumb target_breadcrumb)","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"      in","counters":[]},{"line":"      Strict_pipe.Writer.write test.job_writer","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (parent_hash, [ Rose_tree.T ((target_transition, None), []) ]) ;","counters":[]},{"line":"      (`Test test, `Cached_transition target_transition)","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"    let test_successful_catchup ~my_net ~target_best_tip_path =","counters":[]},{"line":"      let open Fake_network in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let target_breadcrumb = List.last_exn target_best_tip_path in","counters":[]},{"line":"      let `Test { breadcrumbs_reader; _ }, _ =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        run_catchup_with_target ~network:my_net.network","counters":[]},{"line":"          ~frontier:my_net.state.frontier ~target_breadcrumb","counters":[]},{"line":"      in","counters":[]},{"line":"      (* TODO: expose Strict_pipe.read *)","counters":[]},{"line":"      let%map cached_catchup_breadcrumbs =","counters":[]},{"line":"        Block_time.Timeout.await_exn time_controller","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"          ~timeout_duration:(Block_time.Span.of_ms 30000L)","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"          ( match%map Strict_pipe.Reader.read breadcrumbs_reader with","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"          | `Eof ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              failwith \"unexpected EOF\"","counters":[]},{"line":"          | `Ok (_, `Catchup_scheduler) ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              failwith \"did not expect a catchup scheduler action\"","counters":[]},{"line":"          | `Ok (breadcrumbs, `Ledger_catchup ivar) ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Ivar.fill ivar () ; List.hd_exn breadcrumbs )","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"      in","counters":[]},{"line":"      let catchup_breadcrumbs =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Rose_tree.map cached_catchup_breadcrumbs ~f:(fun (b, _vc) ->","counters":[]},{"line":"            Cache_lib.Cached.invalidate_with_success b )","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"      in","counters":[]},{"line":"      [%test_result: int]","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"        ~message:","counters":[]},{"line":"          \"Transition_frontier should not have any more catchup jobs at the \\","counters":[]},{"line":"           end of the test\"","counters":[]},{"line":"        ~equal:( = ) ~expect:0","counters":[]},{"line":"        (Broadcast_pipe.Reader.peek Catchup_jobs.reader) ;","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"      let catchup_breadcrumbs_are_best_tip_path =","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Rose_tree.equal (Rose_tree.of_list_exn target_best_tip_path)","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"          catchup_breadcrumbs ~f:(fun breadcrumb_tree1 breadcrumb_tree2 ->","counters":[]},{"line":"            Mina_block.Validated.equal","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (Transition_frontier.Breadcrumb.validated_transition","counters":[{"col_start":65,"col_end":65,"count":0}]},{"line":"                 breadcrumb_tree1 )","counters":[]},{"line":"              (Transition_frontier.Breadcrumb.validated_transition","counters":[{"col_start":65,"col_end":65,"count":0}]},{"line":"                 breadcrumb_tree2 ) )","counters":[]},{"line":"      in","counters":[]},{"line":"      if not catchup_breadcrumbs_are_best_tip_path then","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        failwith","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          \"catchup breadcrumbs were not equal to the best tip path we expected\"","counters":[]},{"line":"","counters":[]},{"line":"    let%test_unit \"can catchup to a peer within [k/2,k]\" =","counters":[]},{"line":"      [%log info] \"running catchup to peer\" ;","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":16,"col_end":16,"count":0}]},{"line":"      Quickcheck.test ~trials:5","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Fake_network.Generator.(","counters":[]},{"line":"          let open Quickcheck.Generator.Let_syntax in","counters":[]},{"line":"          let%bind peer_branch_size =","counters":[]},{"line":"            Int.gen_incl (max_frontier_length / 2) (max_frontier_length - 1)","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"          in","counters":[]},{"line":"          gen ~precomputed_values ~verifier ~max_frontier_length","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ~use_super_catchup","counters":[]},{"line":"            [ fresh_peer","counters":[]},{"line":"            ; peer_with_branch ~frontier_branch_size:peer_branch_size","counters":[]},{"line":"            ])","counters":[]},{"line":"        ~f:(fun network ->","counters":[]},{"line":"          let open Fake_network in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let [ my_net; peer_net ] = network.peer_networks in","counters":[]},{"line":"          (* TODO: I don't think I'm testing this right... *)","counters":[]},{"line":"          let target_best_tip_path =","counters":[]},{"line":"            Transition_frontier.(","counters":[]},{"line":"              path_map ~f:Fn.id peer_net.state.frontier","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                (best_tip peer_net.state.frontier))","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"          in","counters":[]},{"line":"          Thread_safe.block_on_async_exn (fun () ->","counters":[]},{"line":"              test_successful_catchup ~my_net ~target_best_tip_path ) )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"catchup succeeds even if the parent transition is already \\","counters":[]},{"line":"                   in the frontier\" =","counters":[]},{"line":"      Quickcheck.test ~trials:1","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Fake_network.Generator.(","counters":[]},{"line":"          gen ~precomputed_values ~verifier ~max_frontier_length","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            ~use_super_catchup","counters":[]},{"line":"            [ fresh_peer; peer_with_branch ~frontier_branch_size:1 ])","counters":[]},{"line":"        ~f:(fun network ->","counters":[]},{"line":"          let open Fake_network in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let [ my_net; peer_net ] = network.peer_networks in","counters":[]},{"line":"          let target_best_tip_path =","counters":[]},{"line":"            [ Transition_frontier.best_tip peer_net.state.frontier ]","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"          in","counters":[]},{"line":"          Thread_safe.block_on_async_exn (fun () ->","counters":[]},{"line":"              test_successful_catchup ~my_net ~target_best_tip_path ) )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"","counters":[]},{"line":"    let%test_unit \"catchup fails if one of the parent transitions fail\" =","counters":[]},{"line":"      Quickcheck.test ~trials:1","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Fake_network.Generator.(","counters":[]},{"line":"          gen ~precomputed_values ~verifier ~max_frontier_length","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            ~use_super_catchup","counters":[]},{"line":"            [ fresh_peer","counters":[]},{"line":"            ; peer_with_branch ~frontier_branch_size:(max_frontier_length * 2)","counters":[]},{"line":"            ])","counters":[]},{"line":"        ~f:(fun network ->","counters":[]},{"line":"          let open Fake_network in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let [ my_net; peer_net ] = network.peer_networks in","counters":[]},{"line":"          let target_breadcrumb =","counters":[]},{"line":"            Transition_frontier.best_tip peer_net.state.frontier","counters":[]},{"line":"          in","counters":[]},{"line":"          let failing_transition =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            let open Transition_frontier.Extensions in","counters":[]},{"line":"            let history =","counters":[]},{"line":"              get_extension","counters":[]},{"line":"                (Transition_frontier.extensions peer_net.state.frontier)","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"                Root_history","counters":[]},{"line":"            in","counters":[]},{"line":"            let failing_root_data =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              List.nth_exn (Root_history.to_list history) 1","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"            in","counters":[]},{"line":"            downcast_transition","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"              ( Frontier_base.Root_data.Historical.transition failing_root_data","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"              |> Mina_block.Validated.remember )","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"          in","counters":[]},{"line":"          Thread_safe.block_on_async_exn (fun () ->","counters":[]},{"line":"              let `Test { cache; _ }, `Cached_transition cached_transition =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                run_catchup_with_target ~network:my_net.network","counters":[]},{"line":"                  ~frontier:my_net.state.frontier ~target_breadcrumb","counters":[]},{"line":"              in","counters":[]},{"line":"              let cached_failing_transition =","counters":[]},{"line":"                Transition_handler.Unprocessed_transition_cache.register_exn","counters":[]},{"line":"                  cache failing_transition","counters":[]},{"line":"              in","counters":[]},{"line":"              let%bind () = after (Core.Time.Span.of_sec 1.) in","counters":[{"col_start":32,"col_end":32,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"              ignore","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ( Cache_lib.Cached.invalidate_with_failure","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"                    cached_failing_transition","counters":[]},{"line":"                  : Mina_block.initial_valid_block Envelope.Incoming.t ) ;","counters":[]},{"line":"              let%map result =","counters":[]},{"line":"                Block_time.Timeout.await_exn time_controller","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"                  ~timeout_duration:(Block_time.Span.of_ms 10000L)","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"                  (Ivar.read (Cache_lib.Cached.final_state cached_transition))","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"              in","counters":[]},{"line":"              if not ([%equal: [ `Failed | `Success of _ ]] result `Failed) then","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"                failwith \"expected ledger catchup to fail, but it succeeded\" )","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"          )","counters":[]},{"line":"","counters":[]},{"line":"    (* TODO: fix and re-enable *)","counters":[]},{"line":"    (*","counters":[]},{"line":"    let%test_unit \"catchup won't be blocked by transitions that are still being processed\" =","counters":[]},{"line":"      Quickcheck.test ~trials:1","counters":[]},{"line":"        Fake_network.Generator.(","counters":[]},{"line":"          gen ~max_frontier_length","counters":[]},{"line":"            [ fresh_peer","counters":[]},{"line":"            ; peer_with_branch ~frontier_branch_size:(max_frontier_length-1) ])","counters":[]},{"line":"        ~f:(fun network ->","counters":[]},{"line":"          let open Fake_network in","counters":[]},{"line":"          let [my_net; peer_net] = network.peer_networks in","counters":[]},{"line":"          Core.Printf.printf \"$my_net.state.frontier.root = %s\\n\"","counters":[]},{"line":"            (State_hash.to_base58_check @@ Transition_frontier.(Breadcrumb.state_hash @@ root my_net.state.frontier));","counters":[]},{"line":"          Core.Printf.printf \"$peer_net.state.frontier.root = %s\\n\"","counters":[]},{"line":"            (State_hash.to_base58_check @@ Transition_frontier.(Breadcrumb.state_hash @@ root my_net.state.frontier));","counters":[]},{"line":"          let missing_breadcrumbs =","counters":[]},{"line":"            let best_tip_path = Transition_frontier.best_tip_path peer_net.state.frontier in","counters":[]},{"line":"            Core.Printf.printf \"$best_tip_path=\\n  %s\\n\"","counters":[]},{"line":"              (String.concat ~sep:\"\\n  \" @@ List.map ~f:(Fn.compose State_hash.to_base58_check Transition_frontier.Breadcrumb.state_hash) best_tip_path);","counters":[]},{"line":"            (* List.take best_tip_path (List.length best_tip_path - 1) *)","counters":[]},{"line":"            best_tip_path","counters":[]},{"line":"          in","counters":[]},{"line":"          Async.Thread_safe.block_on_async_exn (fun () ->","counters":[]},{"line":"            let%bind {cache; job_writer; breadcrumbs_reader} = run_catchup ~network:my_net.network ~frontier:my_net.state.frontier in","counters":[]},{"line":"            let jobs =","counters":[]},{"line":"              List.map (List.rev missing_breadcrumbs) ~f:(fun breadcrumb ->","counters":[]},{"line":"                let parent_hash = Transition_frontier.Breadcrumb.parent_hash breadcrumb in","counters":[]},{"line":"                let cached_transition =","counters":[]},{"line":"                  Transition_handler.Unprocessed_transition_cache.register_exn cache","counters":[]},{"line":"                    (downcast_breadcrumb breadcrumb)","counters":[]},{"line":"                in","counters":[]},{"line":"                Core.Printf.printf \"$job = %s --> %s\\n\"","counters":[]},{"line":"                  (State_hash.to_base58_check @@ Mina_block.state_hash @@ Envelope.Incoming.data @@ Cached.peek cached_transition)","counters":[]},{"line":"                  (State_hash.to_base58_check parent_hash);","counters":[]},{"line":"                (parent_hash, [Rose_tree.T (cached_transition, [])]))","counters":[]},{"line":"            in","counters":[]},{"line":"            let%bind () = after (Core.Time.Span.of_ms 500.) in","counters":[]},{"line":"            List.iter jobs ~f:(Strict_pipe.Writer.write job_writer);","counters":[]},{"line":"            match%map","counters":[]},{"line":"              Block_time.Timeout.await_exn time_controller","counters":[]},{"line":"                ~timeout_duration:(Block_time.Span.of_ms 15000L)","counters":[]},{"line":"                (Strict_pipe.Reader.fold_until breadcrumbs_reader ~init:missing_breadcrumbs ~f:(fun remaining_breadcrumbs (rose_trees, catchup_signal) ->","counters":[]},{"line":"                  let[@warning \"-8\"] [rose_tree] = rose_trees in","counters":[]},{"line":"                  let catchup_breadcrumb_tree = Rose_tree.map rose_tree ~f:Cached.invalidate_with_success in","counters":[]},{"line":"                  Core.Printf.printf \"!!!%d\\n\" (List.length @@ Rose_tree.flatten catchup_breadcrumb_tree);","counters":[]},{"line":"                  let[@warning \"-8\"] [received_breadcrumb] = Rose_tree.flatten catchup_breadcrumb_tree in","counters":[]},{"line":"                  match remaining_breadcrumbs with","counters":[]},{"line":"                  | [] -> failwith \"received more breadcrumbs than expected\"","counters":[]},{"line":"                  | expected_breadcrumb :: remaining_breadcrumbs' ->","counters":[]},{"line":"                      Core.Printf.printf \"COMPARING %s vs. %s...\"","counters":[]},{"line":"                        (State_hash.to_base58_check @@ Transition_frontier.Breadcrumb.state_hash expected_breadcrumb)","counters":[]},{"line":"                        (State_hash.to_base58_check @@ Transition_frontier.Breadcrumb.state_hash received_breadcrumb);","counters":[]},{"line":"                      [%test_eq: State_hash.t]","counters":[]},{"line":"                        (Transition_frontier.Breadcrumb.state_hash expected_breadcrumb)","counters":[]},{"line":"                        (Transition_frontier.Breadcrumb.state_hash received_breadcrumb)","counters":[]},{"line":"                        ~message:\"received breadcrumb state hash did not match expected breadcrumb state hash\";","counters":[]},{"line":"                      [%test_eq: Transition_frontier.Breadcrumb.t]","counters":[]},{"line":"                        expected_breadcrumb","counters":[]},{"line":"                        received_breadcrumb","counters":[]},{"line":"                        ~message:\"received breadcrumb matched expected state hash, but was not equal to expected breadcrumb\";","counters":[]},{"line":"                      ( match catchup_signal with","counters":[]},{"line":"                      | `Catchup_scheduler ->","counters":[]},{"line":"                          failwith \"Did not expect a catchup scheduler action\"","counters":[]},{"line":"                      | `Ledger_catchup ivar ->","counters":[]},{"line":"                          Ivar.fill ivar () ) ;","counters":[]},{"line":"                      print_endline \" ok\";","counters":[]},{"line":"                      if remaining_breadcrumbs' = [] then","counters":[]},{"line":"                        return (`Stop ())","counters":[]},{"line":"                      else","counters":[]},{"line":"                        return (`Continue remaining_breadcrumbs')))","counters":[]},{"line":"            with","counters":[]},{"line":"            | `Eof _ -> failwith \"unexpected EOF\"","counters":[]},{"line":"            | `Terminated () -> ()))","counters":[]},{"line":"    *)","counters":[]},{"line":"  end )","counters":[{"col_start":6,"col_end":6,"count":2}]}]}