{"filename":"src/lib/pickles/per_proof_witness.ml","lines":[{"line":"open Backend","counters":[]},{"line":"open Pickles_types","counters":[]},{"line":"open Import","counters":[]},{"line":"module Impl = Impls.Step","counters":[]},{"line":"module One_hot_vector = One_hot_vector.Make (Impl)","counters":[]},{"line":"","counters":[]},{"line":"(* Let F, K be the two fields (either (Fp, Fq) or (Fq, Fp)).","counters":[]},{"line":"   Each proof over F has an accumulator state which contains","counters":[]},{"line":"   - a set of IPA challenges c_0, ..., c_{k-1}, which can be interpreted as F elements.","counters":[]},{"line":"   - a polynomial commitment challenge_polynomial_commitment, which has coordinates in K.","counters":[]},{"line":"","counters":[]},{"line":"   This part of the accumulator state is finalized by checking that challenge_polynomial_commitment","counters":[]},{"line":"   is a commitment to the polynomial","counters":[]},{"line":"","counters":[]},{"line":"   f_c := prod_{i = 0}^{k-1} (1 + c_i x^{2^{k-1 - i}})","counters":[]},{"line":"","counters":[]},{"line":"   When incrementally-verifying such a proof in a K-circuit (since we need K-arithmetic to perform","counters":[]},{"line":"   the group operations on the F-polynomial-commitments that constitute the proof),","counters":[]},{"line":"   instead of checking this, we get an evaluation E_c at a random point zeta and check","counters":[]},{"line":"   that challenge_polynomial_commitment opens to E_c at zeta. Then we will need to check that","counters":[]},{"line":"   E_c = f_c(zeta) = prod_{i = 0}^{k-1} (1 + c_i zeta^{2^{k-1 - i}}).","counters":[]},{"line":"","counters":[]},{"line":"   However, because we are then in a K-circuit, we cannot actually compute f_c(zeta), which requires","counters":[]},{"line":"   F-arithmetic.","counters":[]},{"line":"","counters":[]},{"line":"   Therefore, after incrementally verifying the F-proof, the challenges (c_0, ..., c_{k-1}) which are","counters":[]},{"line":"   part of the accumulator of the F-proof we just incrementally verified, must remain part of","counters":[]},{"line":"   the accumulator of the K-proof, along with E_c (or at least some kind of commitment to it, which is","counters":[]},{"line":"   what we actually do).","counters":[]},{"line":"","counters":[]},{"line":"   Then, when we incrementally verify that K-proof in an F-circuit, we will check that E_c was","counters":[]},{"line":"   computed correctly using c_0, ..., c_{k-1} and they along with E_c can be discarded.","counters":[]},{"line":"","counters":[]},{"line":"   So, to summarize, the accumulator state for each proof P (corresponding to an F-circuit)","counters":[]},{"line":"   contains","counters":[]},{"line":"   - a set of IPA challenges (thought of as K-elements) for every proof that it incrementally verified inside its circuit","counters":[]},{"line":"   - a challenge_polynomial_commitment (coordinates in F) for every proof that it incrementally verified inside its circuit","counters":[]},{"line":"   - a challenge_polynomial_commitment (coordinates in K) corresponding to P's own inner-product argument","counters":[]},{"line":"   - a set of IPA challenges (thought of as F-elements) corresponding to P's own inner-product argument","counters":[]},{"line":"*)","counters":[]},{"line":"","counters":[]},{"line":"(** Represents a proof (along with its accumulation state) which wraps a","counters":[]},{"line":"    \"step\" proof S on the other curve.","counters":[]},{"line":"","counters":[]},{"line":"    To have some notation, the proof S itself comes from a circuit that verified","counters":[]},{"line":"    up to 'max_proofs_verified many wrap proofs W_0, ..., W_max_proofs_verified.","counters":[]},{"line":"*)","counters":[]},{"line":"type ('app_state, 'max_proofs_verified, 'num_branches) t =","counters":[{"col_start":0,"col_end":0,"count":0}]},{"line":"  { app_state : 'app_state","counters":[]},{"line":"        (** The user-level statement corresponding to this proof. *)","counters":[]},{"line":"  ; wrap_proof : Wrap_proof.Checked.t","counters":[]},{"line":"        (** The polynomial commitments, polynomial evaluations, and opening proof corresponding to","counters":[]},{"line":"      this latest wrap proof.","counters":[]},{"line":"  *)","counters":[]},{"line":"  ; proof_state :","counters":[]},{"line":"      ( Challenge.Make(Impl).t","counters":[]},{"line":"      , Challenge.Make(Impl).t Scalar_challenge.t","counters":[]},{"line":"      , Impl.Field.t Shifted_value.Type1.t","counters":[]},{"line":"      , ( ( Challenge.Make(Impl).t Scalar_challenge.t","counters":[]},{"line":"          , Impl.Field.t Shifted_value.Type1.t )","counters":[]},{"line":"          Types.Wrap.Proof_state.Deferred_values.Plonk.In_circuit.Lookup.t","counters":[]},{"line":"        , Impl.Boolean.var )","counters":[]},{"line":"        Plonk_types.Opt.t","counters":[]},{"line":"      , unit","counters":[]},{"line":"      , Digest.Make(Impl).t","counters":[]},{"line":"      , Challenge.Make(Impl).t Scalar_challenge.t Types.Bulletproof_challenge.t","counters":[]},{"line":"        Types.Step_bp_vec.t","counters":[]},{"line":"      , Impl.field Branch_data.Checked.t )","counters":[]},{"line":"      Types.Wrap.Proof_state.In_circuit.t","counters":[]},{"line":"        (** The accumulator state corresponding to the above proof. Contains","counters":[]},{"line":"      - `deferred_values`: The values necessary for finishing the deferred \"scalar field\" computations.","counters":[]},{"line":"      That is, computations which are over the \"step\" circuit's internal field that the","counters":[]},{"line":"      previous \"wrap\" circuit was unable to verify directly, due to its internal field","counters":[]},{"line":"      being different.","counters":[]},{"line":"      - `sponge_digest_before_evaluations`: the sponge state: TODO","counters":[]},{"line":"      - `messages_for_next_wrap_proof`","counters":[]},{"line":"  *)","counters":[]},{"line":"  ; prev_proof_evals :","counters":[]},{"line":"      ( Impl.Field.t","counters":[]},{"line":"      , Impl.Field.t array","counters":[]},{"line":"      , Impl.Boolean.var )","counters":[]},{"line":"      Plonk_types.All_evals.In_circuit.t","counters":[]},{"line":"        (** The evaluations from the step proof that this proof wraps *)","counters":[]},{"line":"  ; prev_challenges :","counters":[]},{"line":"      ((Impl.Field.t, Tick.Rounds.n) Vector.t, 'max_proofs_verified) Vector.t","counters":[]},{"line":"        (** The challenges c_0, ... c_{k - 1} corresponding to each W_i. *)","counters":[]},{"line":"  ; prev_challenge_polynomial_commitments :","counters":[]},{"line":"      (Step_main_inputs.Inner_curve.t, 'max_proofs_verified) Vector.t","counters":[]},{"line":"        (** The commitments to the \"challenge polynomials\" \\prod_{i = 0}^k (1 + c_{k - 1 - i} x^{2^i})","counters":[]},{"line":"      corresponding to each of the \"prev_challenges\".","counters":[]},{"line":"  *)","counters":[]},{"line":"  }","counters":[]},{"line":"[@@deriving hlist]","counters":[]},{"line":"","counters":[]},{"line":"module No_app_state = struct","counters":[]},{"line":"  type nonrec (_, 'max_proofs_verified, 'num_branches) t =","counters":[]},{"line":"    (unit, 'max_proofs_verified, 'num_branches) t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Constant = struct","counters":[]},{"line":"  open Kimchi_backend","counters":[]},{"line":"","counters":[]},{"line":"  type ('statement, 'max_proofs_verified, _) t =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    { app_state : 'statement","counters":[]},{"line":"    ; wrap_proof : Wrap_proof.Constant.t","counters":[]},{"line":"    ; proof_state :","counters":[]},{"line":"        ( Challenge.Constant.t","counters":[]},{"line":"        , Challenge.Constant.t Scalar_challenge.t","counters":[]},{"line":"        , Tick.Field.t Shifted_value.Type1.t","counters":[]},{"line":"        , ( Challenge.Constant.t Scalar_challenge.t","counters":[]},{"line":"          , Tick.Field.t Shifted_value.Type1.t )","counters":[]},{"line":"          Types.Wrap.Proof_state.Deferred_values.Plonk.In_circuit.Lookup.t","counters":[]},{"line":"          option","counters":[]},{"line":"        , unit","counters":[]},{"line":"        , Digest.Constant.t","counters":[]},{"line":"        , Challenge.Constant.t Scalar_challenge.t Types.Bulletproof_challenge.t","counters":[]},{"line":"          Types.Step_bp_vec.t","counters":[]},{"line":"        , Branch_data.t )","counters":[]},{"line":"        Types.Wrap.Proof_state.In_circuit.t","counters":[]},{"line":"    ; prev_proof_evals :","counters":[]},{"line":"        (Tick.Field.t, Tick.Field.t array) Plonk_types.All_evals.t","counters":[]},{"line":"    ; prev_challenges :","counters":[]},{"line":"        ((Tick.Field.t, Tick.Rounds.n) Vector.t, 'max_proofs_verified) Vector.t","counters":[]},{"line":"    ; prev_challenge_polynomial_commitments :","counters":[]},{"line":"        (Tick.Inner_curve.Affine.t, 'max_proofs_verified) Vector.t","counters":[]},{"line":"    }","counters":[]},{"line":"  [@@deriving hlist]","counters":[]},{"line":"","counters":[]},{"line":"  module No_app_state = struct","counters":[]},{"line":"    type nonrec (_, 'max_proofs_verified, 'num_branches) t =","counters":[]},{"line":"      (unit, 'max_proofs_verified, 'num_branches) t","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"let typ (type n avar aval m) ~lookup (statement : (avar, aval) Impls.Step.Typ.t)","counters":[]},{"line":"    (max_proofs_verified : n Nat.t) (branches : m Nat.t) :","counters":[]},{"line":"    ((avar, n, m) t, (aval, n, m) Constant.t) Impls.Step.Typ.t =","counters":[]},{"line":"  let module Sc = Scalar_challenge in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let open Impls.Step in","counters":[]},{"line":"  let open Step_main_inputs in","counters":[]},{"line":"  let open Step_verifier in","counters":[]},{"line":"  Snarky_backendless.Typ.of_hlistable ~var_to_hlist:to_hlist","counters":[]},{"line":"    ~var_of_hlist:of_hlist ~value_to_hlist:Constant.to_hlist","counters":[]},{"line":"    ~value_of_hlist:Constant.of_hlist","counters":[]},{"line":"    [ statement","counters":[]},{"line":"    ; Wrap_proof.typ","counters":[]},{"line":"    ; Types.Wrap.Proof_state.In_circuit.typ","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"        (module Impl)","counters":[]},{"line":"        ~challenge:Challenge.typ ~scalar_challenge:Challenge.typ ~lookup","counters":[]},{"line":"        ~dummy_scalar:(Shifted_value.Type1.Shifted_value Field.Constant.zero)","counters":[]},{"line":"        ~dummy_scalar_challenge:(Sc.create Limb_vector.Challenge.Constant.zero)","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"        (Shifted_value.Type1.typ Field.typ)","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"        (Snarky_backendless.Typ.unit ())","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"        Digest.typ","counters":[]},{"line":"        (Branch_data.typ","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"           (module Impl)","counters":[]},{"line":"           ~assert_16_bits:(Step_verifier.assert_n_bits ~n:16) )","counters":[]},{"line":"    ; Plonk_types.All_evals.typ","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"        (module Impl)","counters":[]},{"line":"        (* Assume we have lookup iff we have runtime tables *)","counters":[]},{"line":"        { lookup; runtime = lookup }","counters":[]},{"line":"    ; Vector.typ (Vector.typ Field.typ Tick.Rounds.n) max_proofs_verified","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"    ; Vector.typ Inner_curve.typ max_proofs_verified","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"    ]","counters":[{"col_start":4,"col_end":4,"count":2}]}]}