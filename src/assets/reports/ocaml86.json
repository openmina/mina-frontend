{"filename":"src/lib/mina_net2/mina_net2.ml","lines":[{"line":"open Core","counters":[]},{"line":"open Async","counters":[]},{"line":"open Async_unix","counters":[]},{"line":"open Network_peer","counters":[]},{"line":"module Keypair = Keypair","counters":[]},{"line":"module Libp2p_stream = Libp2p_stream","counters":[]},{"line":"module Multiaddr = Multiaddr","counters":[]},{"line":"module Validation_callback = Validation_callback","counters":[]},{"line":"module Sink = Sink","counters":[]},{"line":"","counters":[]},{"line":"exception","counters":[]},{"line":"  Libp2p_helper_died_unexpectedly = Libp2p_helper","counters":[]},{"line":"                                    .Libp2p_helper_died_unexpectedly","counters":[]},{"line":"","counters":[]},{"line":"(** Set of peers, represented as a host/port pair. We ignore the peer ID so","counters":[]},{"line":"    that the same node restarting and attaining a new peer ID will not be","counters":[]},{"line":"    double (or triple, etc.) counted.","counters":[]},{"line":"*)","counters":[]},{"line":"module Peer_without_id = struct","counters":[]},{"line":"  module T = struct","counters":[]},{"line":"    type t = { libp2p_port : int; host : string }","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":15,"col_end":15,"count":0},{"col_start":25,"col_end":25,"count":0},{"col_start":29,"col_end":29,"count":0},{"col_start":31,"col_end":31,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":41,"col_end":41,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"    [@@deriving sexp, compare, yojson]","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  include T","counters":[]},{"line":"  module Set = Set.Make (T)","counters":[]},{"line":"","counters":[]},{"line":"  let of_peer ({ libp2p_port; host; _ } : Peer.t) =","counters":[]},{"line":"    { libp2p_port; host = Unix.Inet_addr.to_string host }","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(* TODO: connection gating info is currently stored in to places, that needs to be fixed... *)","counters":[]},{"line":"type connection_gating =","counters":[]},{"line":"  { banned_peers : Peer.t list; trusted_peers : Peer.t list; isolate : bool }","counters":[]},{"line":"","counters":[]},{"line":"let gating_config_to_helper_format (config : connection_gating) =","counters":[]},{"line":"  let trusted_ips =","counters":[{"col_start":2,"col_end":2,"count":1}]},{"line":"    List.map ~f:(fun p -> Unix.Inet_addr.to_string p.host) config.trusted_peers","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"  in","counters":[]},{"line":"  let banned_ips =","counters":[{"col_start":2,"col_end":2,"count":1}]},{"line":"    let trusted = String.Set.of_list trusted_ips in","counters":[]},{"line":"    List.filter_map","counters":[{"col_start":4,"col_end":4,"count":1},{"col_start":18,"col_end":18,"count":1}]},{"line":"      ~f:(fun p ->","counters":[]},{"line":"        let p = Unix.Inet_addr.to_string p.host in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        (* Trusted peers cannot be banned. *)","counters":[]},{"line":"        if Set.mem trusted p then None else Some p )","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":34,"col_end":34,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"      config.banned_peers","counters":[]},{"line":"  in","counters":[]},{"line":"  let banned_peers =","counters":[]},{"line":"    List.map","counters":[]},{"line":"      ~f:(fun p -> Libp2p_ipc.create_peer_id p.peer_id)","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"      config.banned_peers","counters":[]},{"line":"  in","counters":[]},{"line":"  let trusted_peers =","counters":[{"col_start":2,"col_end":2,"count":1}]},{"line":"    List.map","counters":[]},{"line":"      ~f:(fun p -> Libp2p_ipc.create_peer_id p.peer_id)","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"      config.trusted_peers","counters":[]},{"line":"  in","counters":[]},{"line":"  Libp2p_ipc.create_gating_config ~banned_ips ~banned_peers ~trusted_ips","counters":[{"col_start":2,"col_end":2,"count":1}]},{"line":"    ~trusted_peers ~isolate:config.isolate","counters":[]},{"line":"","counters":[]},{"line":"module For_tests = struct","counters":[]},{"line":"  module Helper = Libp2p_helper","counters":[]},{"line":"","counters":[]},{"line":"  let generate_random_keypair = Keypair.generate_random","counters":[]},{"line":"","counters":[]},{"line":"  let multiaddr_to_libp2p_ipc = Multiaddr.to_libp2p_ipc","counters":[]},{"line":"","counters":[]},{"line":"  let empty_libp2p_ipc_gating_config =","counters":[]},{"line":"    gating_config_to_helper_format","counters":[{"col_start":33,"col_end":33,"count":1}]},{"line":"      { banned_peers = []; trusted_peers = []; isolate = false }","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"type protocol_handler =","counters":[]},{"line":"  { protocol_name : string","counters":[]},{"line":"  ; mutable closed : bool","counters":[]},{"line":"  ; on_handler_error :","counters":[]},{"line":"      [ `Raise | `Ignore | `Call of Libp2p_stream.t -> exn -> unit ]","counters":[]},{"line":"  ; handler : Libp2p_stream.t -> unit Deferred.t","counters":[]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"type t =","counters":[]},{"line":"  { conf_dir : string","counters":[]},{"line":"  ; helper : Libp2p_helper.t","counters":[]},{"line":"  ; logger : Logger.t","counters":[]},{"line":"  ; my_keypair : Keypair.t Ivar.t","counters":[]},{"line":"  ; subscriptions : Subscription.e Subscription.Id.Table.t","counters":[]},{"line":"        (* we use string as the key here because there is no hashable instance for Uint64.t *)","counters":[]},{"line":"  ; streams : Libp2p_stream.t String.Table.t","counters":[]},{"line":"  ; protocol_handlers : protocol_handler String.Table.t","counters":[]},{"line":"  ; mutable connection_gating : connection_gating","counters":[]},{"line":"  ; mutable all_peers_seen : Peer_without_id.Set.t option","counters":[]},{"line":"  ; mutable banned_ips : Unix.Inet_addr.t list","counters":[]},{"line":"  ; peer_connected_callback : string -> unit","counters":[]},{"line":"  ; peer_disconnected_callback : string -> unit","counters":[]},{"line":"  }","counters":[]},{"line":"","counters":[]},{"line":"let banned_ips t = t.banned_ips","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"","counters":[]},{"line":"let connection_gating_config t = t.connection_gating","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"","counters":[]},{"line":"let me t = Ivar.read t.my_keypair","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"","counters":[]},{"line":"(** TODO: graceful shutdown. Reset all our streams, sync the databases, then","counters":[]},{"line":"    shutdown. Replace kill invocation with an RPC. *)","counters":[]},{"line":"let shutdown t = Libp2p_helper.shutdown t.helper","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"","counters":[]},{"line":"let generate_random_keypair t = Keypair.generate_random t.helper","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"","counters":[]},{"line":"module Pubsub = struct","counters":[]},{"line":"  type 'a subscription = 'a Subscription.t","counters":[]},{"line":"","counters":[]},{"line":"  let subscribe_raw t topic ~handle_and_validate_incoming_message ~encode","counters":[]},{"line":"      ~decode ~on_decode_failure =","counters":[]},{"line":"    let open Deferred.Or_error.Let_syntax in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    (* Linear scan over all subscriptions. Should generally be small, probably not a problem. *)","counters":[]},{"line":"    let topic_subscription_already_exists =","counters":[]},{"line":"      Hashtbl.data t.subscriptions","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"      |> List.exists ~f:(fun (Subscription.E sub') ->","counters":[]},{"line":"             String.equal (Subscription.topic sub') topic )","counters":[{"col_start":13,"col_end":13,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"    in","counters":[]},{"line":"    if topic_subscription_already_exists then","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Deferred.Or_error.errorf \"already subscribed to topic %s\" topic","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    else","counters":[]},{"line":"      let%map sub =","counters":[]},{"line":"        Subscription.subscribe ~helper:t.helper ~topic ~encode ~decode","counters":[]},{"line":"          ~on_decode_failure ~validator:handle_and_validate_incoming_message","counters":[]},{"line":"      in","counters":[]},{"line":"      Hashtbl.add_exn t.subscriptions ~key:(Subscription.id sub)","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"        ~data:(Subscription.E sub) ;","counters":[]},{"line":"      sub","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"  let subscribe_encode t topic ~handle_and_validate_incoming_message ~bin_prot","counters":[]},{"line":"      ~on_decode_failure =","counters":[]},{"line":"    subscribe_raw","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      ~decode:(fun msg_str ->","counters":[]},{"line":"        let b = Bigstring.of_string msg_str in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Bigstring.read_bin_prot b bin_prot.Bin_prot.Type_class.reader","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"        |> Or_error.map ~f:fst )","counters":[]},{"line":"      ~encode:(fun msg ->","counters":[]},{"line":"        Bin_prot.Utils.bin_dump ~header:true bin_prot.Bin_prot.Type_class.writer","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"          msg","counters":[]},{"line":"        |> Bigstring.to_string )","counters":[]},{"line":"      ~handle_and_validate_incoming_message ~on_decode_failure t topic","counters":[]},{"line":"","counters":[]},{"line":"  let subscribe =","counters":[]},{"line":"    subscribe_raw ~encode:Fn.id ~decode:Or_error.return","counters":[]},{"line":"      ~on_decode_failure:`Ignore","counters":[]},{"line":"","counters":[]},{"line":"  let unsubscribe t = Subscription.unsubscribe ~helper:t.helper","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"  let publish t = Subscription.publish ~logger:t.logger ~helper:t.helper","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"","counters":[]},{"line":"  let publish_raw t = Subscription.publish_raw ~logger:t.logger ~helper:t.helper","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let set_node_status t data =","counters":[]},{"line":"  Libp2p_helper.do_rpc t.helper","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":21,"col_end":21,"count":0}]},{"line":"    (module Libp2p_ipc.Rpcs.SetNodeStatus)","counters":[]},{"line":"    (Libp2p_ipc.Rpcs.SetNodeStatus.create_request ~data)","counters":[]},{"line":"  |> Deferred.Or_error.ignore_m","counters":[]},{"line":"","counters":[]},{"line":"let get_peer_node_status t peer =","counters":[]},{"line":"  let open Deferred.Or_error.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let peer_multiaddr = Multiaddr.to_libp2p_ipc peer in","counters":[]},{"line":"  let%map response =","counters":[]},{"line":"    Libp2p_helper.do_rpc t.helper","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"      (module Libp2p_ipc.Rpcs.GetPeerNodeStatus)","counters":[]},{"line":"      (Libp2p_ipc.Rpcs.GetPeerNodeStatus.create_request ~peer_multiaddr)","counters":[]},{"line":"  in","counters":[]},{"line":"  let open Libp2p_ipc.Reader.Libp2pHelperInterface.GetPeerNodeStatus.Response in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  result_get response","counters":[]},{"line":"","counters":[]},{"line":"let list_peers t =","counters":[]},{"line":"  match%map","counters":[]},{"line":"    Libp2p_helper.do_rpc t.helper","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"      (module Libp2p_ipc.Rpcs.ListPeers)","counters":[]},{"line":"      (Libp2p_ipc.Rpcs.ListPeers.create_request ())","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"  with","counters":[]},{"line":"  | Ok response ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let open Libp2p_ipc.Reader.Libp2pHelperInterface.ListPeers.Response in","counters":[]},{"line":"      let peers = result_get_list response in","counters":[]},{"line":"      (* FIXME #4039: filter_map shouldn't be necessary *)","counters":[]},{"line":"      peers","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      |> List.map ~f:Libp2p_ipc.unsafe_parse_peer","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"      |> List.filter ~f:(fun peer -> not (Int.equal peer.libp2p_port 0))","counters":[{"col_start":37,"col_end":37,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"  | Error error ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      [%log' error t.logger]","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"        \"Encountered $error while asking libp2p_helper for peers\"","counters":[]},{"line":"        ~metadata:[ (\"error\", Error_json.error_to_yojson error) ] ;","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"      []","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"","counters":[]},{"line":"let bandwidth_info t =","counters":[]},{"line":"  Deferred.Or_error.map ~f:(fun response ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      let open Libp2p_ipc.Reader.Libp2pHelperInterface.BandwidthInfo.Response in","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      let input_bandwidth = input_bandwidth_get response","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"      and output_bandwidth = output_bandwidth_get response","counters":[{"col_start":48,"col_end":48,"count":0}]},{"line":"      and cpu_usage = cpu_usage_get response in","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"      (`Input input_bandwidth, `Output output_bandwidth, `Cpu_usage cpu_usage) )","counters":[]},{"line":"  @@ Libp2p_helper.do_rpc t.helper","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"       (module Libp2p_ipc.Rpcs.BandwidthInfo)","counters":[]},{"line":"       (Libp2p_ipc.Rpcs.BandwidthInfo.create_request ())","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"","counters":[]},{"line":"(* `on_new_peer` fires whenever a peer connects OR disconnects *)","counters":[]},{"line":"let configure t ~me ~external_maddr ~maddrs ~network_id ~metrics_port","counters":[]},{"line":"    ~unsafe_no_trust_ip ~flooding ~direct_peers ~peer_exchange","counters":[]},{"line":"    ~peer_protection_ratio ~seed_peers ~initial_gating_config ~min_connections","counters":[]},{"line":"    ~max_connections ~validation_queue_size ~known_private_ip_nets ~topic_config","counters":[]},{"line":"    =","counters":[]},{"line":"  let open Deferred.Or_error.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let libp2p_config =","counters":[]},{"line":"    Libp2p_ipc.create_libp2p_config ~private_key:(Keypair.secret me)","counters":[{"col_start":63,"col_end":63,"count":0}]},{"line":"      ~statedir:t.conf_dir","counters":[]},{"line":"      ~listen_on:(List.map ~f:Multiaddr.to_libp2p_ipc maddrs)","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"      ?metrics_port","counters":[]},{"line":"      ~external_multiaddr:(Multiaddr.to_libp2p_ipc external_maddr)","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"      ~network_id ~unsafe_no_trust_ip ~flood:flooding","counters":[]},{"line":"      ~direct_peers:(List.map ~f:Multiaddr.to_libp2p_ipc direct_peers)","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"      ~seed_peers:(List.map ~f:Multiaddr.to_libp2p_ipc seed_peers)","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"      ~known_private_ip_nets:","counters":[]},{"line":"        (List.map ~f:Core.Unix.Cidr.to_string known_private_ip_nets)","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"      ~peer_exchange ~peer_protection_ratio ~min_connections ~max_connections","counters":[]},{"line":"      ~validation_queue_size","counters":[]},{"line":"      ~gating_config:(gating_config_to_helper_format initial_gating_config)","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"      ~topic_config","counters":[]},{"line":"  in","counters":[]},{"line":"  let%map _ =","counters":[]},{"line":"    Libp2p_helper.do_rpc t.helper","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"      (module Libp2p_ipc.Rpcs.Configure)","counters":[]},{"line":"      (Libp2p_ipc.Rpcs.Configure.create_request ~libp2p_config)","counters":[]},{"line":"  in","counters":[]},{"line":"  t.connection_gating <- initial_gating_config ;","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  Ivar.fill_if_empty t.my_keypair me","counters":[]},{"line":"","counters":[]},{"line":"(** List of all peers we are currently connected to. *)","counters":[]},{"line":"let peers t = list_peers t","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"","counters":[]},{"line":"let listen_on t iface =","counters":[]},{"line":"  let open Deferred.Or_error.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%map response =","counters":[]},{"line":"    Libp2p_helper.do_rpc t.helper","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"      (module Libp2p_ipc.Rpcs.Listen)","counters":[]},{"line":"      (Libp2p_ipc.Rpcs.Listen.create_request","counters":[]},{"line":"         ~iface:(Multiaddr.to_libp2p_ipc iface) )","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"  in","counters":[]},{"line":"  let open Libp2p_ipc.Reader.Libp2pHelperInterface.Listen.Response in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  result_get_list response |> List.map ~f:Multiaddr.of_libp2p_ipc","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"","counters":[]},{"line":"let listening_addrs t =","counters":[]},{"line":"  let open Deferred.Or_error.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let%map response =","counters":[]},{"line":"    Libp2p_helper.do_rpc t.helper","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"      (module Libp2p_ipc.Rpcs.GetListeningAddrs)","counters":[]},{"line":"      (Libp2p_ipc.Rpcs.GetListeningAddrs.create_request ())","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"  in","counters":[]},{"line":"  let open Libp2p_ipc.Reader.Libp2pHelperInterface.GetListeningAddrs.Response in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  result_get_list response |> List.map ~f:Multiaddr.of_libp2p_ipc","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"","counters":[]},{"line":"let open_protocol t ~on_handler_error ~protocol f =","counters":[]},{"line":"  let open Deferred.Or_error.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let protocol_handler =","counters":[]},{"line":"    { closed = false; on_handler_error; handler = f; protocol_name = protocol }","counters":[]},{"line":"  in","counters":[]},{"line":"  if Hashtbl.mem t.protocol_handlers protocol then","counters":[]},{"line":"    Deferred.Or_error.errorf \"already handling protocol %s\" protocol","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  else","counters":[]},{"line":"    let%map _ =","counters":[]},{"line":"      Libp2p_helper.do_rpc t.helper","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"        (module Libp2p_ipc.Rpcs.AddStreamHandler)","counters":[]},{"line":"        (Libp2p_ipc.Rpcs.AddStreamHandler.create_request ~protocol)","counters":[]},{"line":"    in","counters":[]},{"line":"    Hashtbl.add_exn t.protocol_handlers ~key:protocol ~data:protocol_handler","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"let close_protocol ?(reset_existing_streams = false) t ~protocol =","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"  let%map result =","counters":[]},{"line":"    Libp2p_helper.do_rpc t.helper","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"      (module Libp2p_ipc.Rpcs.RemoveStreamHandler)","counters":[]},{"line":"      (Libp2p_ipc.Rpcs.RemoveStreamHandler.create_request ~protocol)","counters":[]},{"line":"  in","counters":[]},{"line":"  if reset_existing_streams then","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    Hashtbl.filter_inplace t.streams ~f:(fun stream ->","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":25,"col_end":25,"count":0}]},{"line":"        if not (String.equal (Libp2p_stream.protocol stream) protocol) then true","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":27,"col_end":27,"count":0},{"col_start":51,"col_end":51,"count":0},{"col_start":76,"col_end":76,"count":0}]},{"line":"        else (","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"          don't_wait_for","counters":[]},{"line":"            (* TODO: this probably needs to be more thorough than a reset. Also force the write pipe closed? *)","counters":[]},{"line":"            ( match%map Libp2p_stream.reset ~helper:t.helper stream with","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"            | Ok () ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                ()","counters":[]},{"line":"            | Error e ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                [%log' error t.logger]","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                  \"failed to reset stream while closing protocol: $error\"","counters":[]},{"line":"                  ~metadata:[ (\"error\", `String (Error.to_string_hum e)) ] ) ;","counters":[{"col_start":67,"col_end":67,"count":0}]},{"line":"          false ) ) ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"  match result with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | Ok _ ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Hashtbl.remove t.protocol_handlers protocol","counters":[]},{"line":"  | Error e ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      [%log' info t.logger]","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"        \"error while closing handler for $protocol, closing connections \\","counters":[]},{"line":"         anyway: $err\"","counters":[]},{"line":"        ~metadata:","counters":[]},{"line":"          [ (\"protocol\", `String protocol)","counters":[]},{"line":"          ; (\"err\", Error_json.error_to_yojson e)","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"          ]","counters":[]},{"line":"","counters":[]},{"line":"let release_stream t id =","counters":[]},{"line":"  Hashtbl.remove t.streams (Libp2p_ipc.stream_id_to_string id)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"","counters":[]},{"line":"let open_stream t ~protocol ~peer =","counters":[]},{"line":"  let open Deferred.Or_error.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let peer_id = Libp2p_ipc.create_peer_id (Peer.Id.to_string peer) in","counters":[{"col_start":59,"col_end":59,"count":0}]},{"line":"  let%map stream =","counters":[]},{"line":"    Libp2p_stream.open_ ~logger:t.logger ~helper:t.helper ~protocol ~peer_id","counters":[]},{"line":"      ~release_stream:(release_stream t)","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"  in","counters":[]},{"line":"  Hashtbl.add_exn t.streams","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    ~key:(Libp2p_ipc.stream_id_to_string (Libp2p_stream.id stream))","counters":[{"col_start":39,"col_end":39,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"    ~data:stream ;","counters":[]},{"line":"  stream","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let reset_stream t = Libp2p_stream.reset ~helper:t.helper","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"","counters":[]},{"line":"let add_peer t maddr ~is_seed =","counters":[]},{"line":"  Libp2p_ipc.Rpcs.AddPeer.create_request","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    ~multiaddr:(Multiaddr.to_libp2p_ipc maddr)","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"    ~is_seed","counters":[]},{"line":"  |> Libp2p_helper.do_rpc t.helper (module Libp2p_ipc.Rpcs.AddPeer)","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"  |> Deferred.Or_error.ignore_m","counters":[]},{"line":"","counters":[]},{"line":"let begin_advertising t =","counters":[]},{"line":"  Libp2p_ipc.Rpcs.BeginAdvertising.create_request ()","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"  |> Libp2p_helper.do_rpc t.helper (module Libp2p_ipc.Rpcs.BeginAdvertising)","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"  |> Deferred.Or_error.ignore_m","counters":[]},{"line":"","counters":[]},{"line":"let set_connection_gating_config t config =","counters":[]},{"line":"  match%map","counters":[]},{"line":"    Libp2p_helper.do_rpc t.helper","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"      (module Libp2p_ipc.Rpcs.SetGatingConfig)","counters":[]},{"line":"      (Libp2p_ipc.Rpcs.SetGatingConfig.create_request","counters":[]},{"line":"         ~gating_config:(gating_config_to_helper_format config) )","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"  with","counters":[]},{"line":"  | Ok _ ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      t.connection_gating <- config ;","counters":[]},{"line":"      config","counters":[]},{"line":"  | Error e ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Error.tag e ~tag:\"Unexpected error doing setGatingConfig\" |> Error.raise","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"","counters":[]},{"line":"let handle_push_message t push_message =","counters":[]},{"line":"  let open Libp2p_ipc.Reader in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let open DaemonInterface in","counters":[]},{"line":"  let open PushMessage in","counters":[]},{"line":"  let handle name f =","counters":[]},{"line":"    O1trace.sync_thread (\"handle_libp2p_ipc_push_\" ^ name) f","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  in","counters":[]},{"line":"  match push_message with","counters":[]},{"line":"  | PeerConnected m ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      handle \"handle_libp2p_ipc_push_peer_connected\" (fun () ->","counters":[]},{"line":"          let peer_id =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Libp2p_ipc.unsafe_parse_peer_id (PeerConnected.peer_id_get m)","counters":[{"col_start":69,"col_end":69,"count":0}]},{"line":"          in","counters":[]},{"line":"          t.peer_connected_callback peer_id )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"  | PeerDisconnected m ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      handle \"handle_libp2p_helper_subprocess_push_peer_disconnected\" (fun () ->","counters":[]},{"line":"          let peer_id =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Libp2p_ipc.unsafe_parse_peer_id (PeerDisconnected.peer_id_get m)","counters":[{"col_start":72,"col_end":72,"count":0}]},{"line":"          in","counters":[]},{"line":"          t.peer_disconnected_callback peer_id )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"  | GossipReceived m ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      handle \"handle_libp2p_helper_subprocess_push_gossip_received\" (fun () ->","counters":[]},{"line":"          let open GossipReceived in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let data = data_get m in","counters":[]},{"line":"          let subscription_id = subscription_id_get m in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let sender = Libp2p_ipc.unsafe_parse_peer (sender_get m) in","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"          let validation_id = validation_id_get m in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let validation_expiration =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Libp2p_ipc.unix_nano_to_time_span (expiration_get m)","counters":[{"col_start":60,"col_end":60,"count":0}]},{"line":"          in","counters":[]},{"line":"          match Hashtbl.find t.subscriptions subscription_id with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | Some (Subscription.E sub) ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              upon","counters":[]},{"line":"                (O1trace.thread \"validate_libp2p_gossip\" (fun () ->","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                     Subscription.handle_and_validate sub ~validation_expiration","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"                       ~sender ~data ) )","counters":[]},{"line":"                (function","counters":[]},{"line":"                  | `Validation_timeout ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      [%log' warn t.logger]","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"                        \"validation callback timed out before we could respond\"","counters":[]},{"line":"                  | `Decoding_error e ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      [%log' error t.logger]","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"                        \"failed to decode message published on subscription \\","counters":[]},{"line":"                         $topic ($subscription_id): $error\"","counters":[]},{"line":"                        ~metadata:","counters":[]},{"line":"                          [ (\"topic\", `String (Subscription.topic sub))","counters":[{"col_start":64,"col_end":64,"count":0}]},{"line":"                          ; ( \"subscription_id\"","counters":[]},{"line":"                            , `String","counters":[]},{"line":"                                (Subscription.Id.to_string subscription_id) )","counters":[{"col_start":57,"col_end":57,"count":0}]},{"line":"                          ; (\"error\", Error_json.error_to_yojson e)","counters":[{"col_start":63,"col_end":63,"count":0}]},{"line":"                          ] ;","counters":[]},{"line":"                      Libp2p_helper.send_validation t.helper ~validation_id","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        ~validation_result:ValidationResult.Reject","counters":[]},{"line":"                  | `Validation_result validation_result ->","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      Libp2p_helper.send_validation t.helper ~validation_id","counters":[]},{"line":"                        ~validation_result )","counters":[]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              [%log' error t.logger]","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                \"asked to validate message for unregistered subscription id \\","counters":[]},{"line":"                 $subscription_id\"","counters":[]},{"line":"                ~metadata:","counters":[]},{"line":"                  [ ( \"subscription_id\"","counters":[]},{"line":"                    , `String (Subscription.Id.to_string subscription_id) )","counters":[{"col_start":55,"col_end":55,"count":0}]},{"line":"                  ] )","counters":[]},{"line":"  (* A new inbound stream was opened *)","counters":[]},{"line":"  | IncomingStream m ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      handle \"handle_libp2p_helper_subprocess_push_incoming_stream\" (fun () ->","counters":[]},{"line":"          let open IncomingStream in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let stream_id = stream_id_get m in","counters":[]},{"line":"          let protocol = protocol_get m in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let peer = Libp2p_ipc.unsafe_parse_peer (peer_get m) in","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":58,"col_end":58,"count":0}]},{"line":"          Option.iter t.all_peers_seen ~f:(fun all_peers_seen ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"              let all_peers_seen =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                Set.add all_peers_seen (Peer_without_id.of_peer peer)","counters":[{"col_start":62,"col_end":62,"count":0}]},{"line":"              in","counters":[]},{"line":"              t.all_peers_seen <- Some all_peers_seen ;","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              Mina_metrics.(","counters":[]},{"line":"                Gauge.set Network.all_peers","counters":[]},{"line":"                  (Set.length all_peers_seen |> Int.to_float)) ) ;","counters":[{"col_start":28,"col_end":28,"count":0},{"col_start":59,"col_end":59,"count":0}]},{"line":"          let stream =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Libp2p_stream.create_from_existing ~logger:t.logger ~helper:t.helper","counters":[]},{"line":"              ~stream_id ~protocol ~peer ~release_stream:(release_stream t)","counters":[{"col_start":71,"col_end":71,"count":0}]},{"line":"          in","counters":[]},{"line":"          match Hashtbl.find t.protocol_handlers protocol with","counters":[]},{"line":"          | Some ph ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              if not ph.closed then (","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"                Hashtbl.add_exn t.streams","counters":[]},{"line":"                  ~key:(Libp2p_ipc.stream_id_to_string stream_id)","counters":[{"col_start":53,"col_end":53,"count":0}]},{"line":"                  ~data:stream ;","counters":[]},{"line":"                O1trace.background_thread \"dispatch_libp2p_stream_handler\"","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  (fun () ->","counters":[]},{"line":"                    let open Deferred.Let_syntax in","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                    (* Call the protocol handler. If it throws an exception,","counters":[]},{"line":"                        handle it according to [on_handler_error]. Mimics","counters":[]},{"line":"                        [Tcp.Server.create]. See [handle_protocol] doc comment.","counters":[]},{"line":"                    *)","counters":[]},{"line":"                    match%map","counters":[]},{"line":"                      Monitor.try_with ~here:[%here] ~extract_exn:true","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                        (fun () -> ph.handler stream)","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                    with","counters":[]},{"line":"                    | Ok () ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        ()","counters":[]},{"line":"                    | Error e -> (","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        try","counters":[]},{"line":"                          match ph.on_handler_error with","counters":[]},{"line":"                          | `Raise ->","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                              raise e","counters":[]},{"line":"                          | `Ignore ->","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                              ()","counters":[]},{"line":"                          | `Call f ->","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                              f stream e","counters":[{"col_start":30,"col_end":30,"count":0}]},{"line":"                        with handler_exn ->","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                          ph.closed <- true ;","counters":[]},{"line":"                          don't_wait_for","counters":[]},{"line":"                            (let%map result =","counters":[]},{"line":"                               Libp2p_helper.do_rpc t.helper","counters":[{"col_start":50,"col_end":50,"count":0}]},{"line":"                                 (module Libp2p_ipc.Rpcs.RemoveStreamHandler)","counters":[]},{"line":"                                 (Libp2p_ipc.Rpcs.RemoveStreamHandler","counters":[]},{"line":"                                  .create_request ~protocol )","counters":[]},{"line":"                             in","counters":[]},{"line":"                             if Or_error.is_ok result then","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"                               Hashtbl.remove t.protocol_handlers protocol ) ;","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                          raise handler_exn ) ) )","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"              else","counters":[]},{"line":"                (* silently ignore new streams for closed protocol handlers.","counters":[]},{"line":"                    these are buffered stream open RPCs that were enqueued before","counters":[]},{"line":"                    our close went into effect. *)","counters":[]},{"line":"                (* TODO: we leak the new pipes here*)","counters":[]},{"line":"                [%log' warn t.logger]","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"                  \"incoming stream for protocol that is being closed after \\","counters":[]},{"line":"                   error\"","counters":[]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              (* TODO: punish *)","counters":[]},{"line":"              [%log' error t.logger]","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                \"incoming stream for protocol we don't know about?\" )","counters":[]},{"line":"  (* Received a message on some stream *)","counters":[]},{"line":"  | StreamMessageReceived m ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      handle \"handle_libp2p_helper_subprocess_push_stream_message_received\"","counters":[]},{"line":"        (fun () ->","counters":[]},{"line":"          let open StreamMessageReceived in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let open StreamMessage in","counters":[]},{"line":"          let msg = msg_get m in","counters":[]},{"line":"          let stream_id = stream_id_get msg in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let data = data_get msg in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          match","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Hashtbl.find t.streams (Libp2p_ipc.stream_id_to_string stream_id)","counters":[{"col_start":65,"col_end":65,"count":0}]},{"line":"          with","counters":[]},{"line":"          | Some stream ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Libp2p_stream.data_received stream data","counters":[]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              [%log' error t.logger]","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                \"incoming stream message for stream we don't know about?\" )","counters":[]},{"line":"  (* Stream was reset, either by the remote peer or an error on our end. *)","counters":[]},{"line":"  | StreamLost m ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      handle \"handle_libp2p_helper_subprocess_push_stream_lost\" (fun () ->","counters":[]},{"line":"          let open StreamLost in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let stream_id = stream_id_get m in","counters":[]},{"line":"          let reason = reason_get m in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let stream_id_str = Libp2p_ipc.stream_id_to_string stream_id in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          ( match Hashtbl.find t.streams stream_id_str with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | Some stream ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let (`Stream_should_be_released should_release) =","counters":[]},{"line":"                Libp2p_stream.stream_closed ~logger:t.logger ~who_closed:Them","counters":[]},{"line":"                  stream","counters":[]},{"line":"              in","counters":[]},{"line":"              if should_release then Hashtbl.remove t.streams stream_id_str","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              () ) ;","counters":[]},{"line":"          [%log' trace t.logger]","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"            \"Encountered error while reading stream $id: $error\"","counters":[]},{"line":"            ~metadata:","counters":[]},{"line":"              [ (\"error\", `String reason)","counters":[]},{"line":"              ; (\"id\", `String (Libp2p_ipc.stream_id_to_string stream_id))","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"              ] )","counters":[]},{"line":"  (* The remote peer closed its write end of one of our streams *)","counters":[]},{"line":"  | StreamComplete m ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      handle \"handle_libp2p_helper_subprocess_push_stream_complete\" (fun () ->","counters":[]},{"line":"          let open StreamComplete in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let stream_id = stream_id_get m in","counters":[]},{"line":"          let stream_id_str = Libp2p_ipc.stream_id_to_string stream_id in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          match Hashtbl.find t.streams stream_id_str with","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          | Some stream ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let (`Stream_should_be_released should_release) =","counters":[]},{"line":"                Libp2p_stream.stream_closed ~logger:t.logger ~who_closed:Them","counters":[]},{"line":"                  stream","counters":[]},{"line":"              in","counters":[]},{"line":"              if should_release then Hashtbl.remove t.streams stream_id_str","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":37,"col_end":37,"count":0}]},{"line":"          | None ->","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              [%log' error t.logger]","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                \"streamReadComplete for stream we don't know about $stream_id\"","counters":[]},{"line":"                ~metadata:[ (\"stream_id\", `String stream_id_str) ] )","counters":[]},{"line":"  | ResourceUpdated _ ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      [%log' error t.logger] \"resourceUpdated upcall not supported yet\"","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"  | Undefined n ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Libp2p_ipc.undefined_union ~context:\"DaemonInterface.PushMessage\" n","counters":[]},{"line":"","counters":[]},{"line":"let create ~all_peers_seen_metric ~logger ~pids ~conf_dir ~on_peer_connected","counters":[]},{"line":"    ~on_peer_disconnected =","counters":[]},{"line":"  let open Deferred.Or_error.Let_syntax in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let push_message_handler =","counters":[]},{"line":"    ref (fun _msg ->","counters":[]},{"line":"        [%log error]","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":19,"col_end":19,"count":0}]},{"line":"          \"received push message from libp2p_helper before handler was attached\" )","counters":[]},{"line":"  in","counters":[]},{"line":"  let%bind helper =","counters":[]},{"line":"    O1trace.thread \"manage_libp2p_helper_subprocess\" (fun () ->","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"        Libp2p_helper.spawn ~logger ~pids ~conf_dir","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ~handle_push_message:(fun _helper msg ->","counters":[]},{"line":"            Deferred.return (!push_message_handler msg) ) )","counters":[{"col_start":12,"col_end":12,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"  in","counters":[]},{"line":"  let t =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    { helper","counters":[]},{"line":"    ; conf_dir","counters":[]},{"line":"    ; logger","counters":[]},{"line":"    ; banned_ips = []","counters":[]},{"line":"    ; connection_gating =","counters":[]},{"line":"        { banned_peers = []; trusted_peers = []; isolate = false }","counters":[]},{"line":"    ; my_keypair = Ivar.create ()","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"    ; subscriptions = Subscription.Id.Table.create ()","counters":[{"col_start":49,"col_end":49,"count":0}]},{"line":"    ; streams = String.Table.create ()","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"    ; all_peers_seen =","counters":[]},{"line":"        (if all_peers_seen_metric then Some Peer_without_id.Set.empty else None)","counters":[{"col_start":39,"col_end":39,"count":0},{"col_start":75,"col_end":75,"count":0}]},{"line":"    ; peer_connected_callback =","counters":[]},{"line":"        (fun peer_id -> on_peer_connected (Peer.Id.unsafe_of_string peer_id))","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":66,"col_end":66,"count":0}]},{"line":"    ; peer_disconnected_callback =","counters":[]},{"line":"        (fun peer_id -> on_peer_disconnected (Peer.Id.unsafe_of_string peer_id))","counters":[{"col_start":24,"col_end":24,"count":0},{"col_start":69,"col_end":69,"count":0}]},{"line":"    ; protocol_handlers = Hashtbl.create (module String)","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"    }","counters":[]},{"line":"  in","counters":[]},{"line":"  (push_message_handler := fun msg -> handle_push_message t msg) ;","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"  ( if all_peers_seen_metric then","counters":[]},{"line":"    let log_all_peers_interval = Time.Span.of_hr 2.0 in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let log_message_batch_size = 50 in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    every log_all_peers_interval (fun () ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        Option.iter t.all_peers_seen ~f:(fun all_peers_seen ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            let num_batches, num_in_batch, batches, batch =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              Set.fold_right all_peers_seen ~init:(0, 0, [], [])","counters":[]},{"line":"                ~f:(fun peer (num_batches, num_in_batch, batches, batch) ->","counters":[]},{"line":"                  if num_in_batch >= log_message_batch_size then","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    (num_batches + 1, 1, batch :: batches, [ peer ])","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                  else (num_batches, num_in_batch + 1, batches, peer :: batch) )","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"            in","counters":[]},{"line":"            let num_batches, batches =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              if num_in_batch > 0 then (num_batches + 1, batch :: batches)","counters":[{"col_start":39,"col_end":39,"count":0}]},{"line":"              else (num_batches, batches)","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"            in","counters":[]},{"line":"            List.iteri batches ~f:(fun batch_num batch ->","counters":[]},{"line":"                [%log info]","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":26,"col_end":26,"count":0}]},{"line":"                  \"All peers seen by this node, batch $batch_num/$num_batches\"","counters":[]},{"line":"                  ~metadata:","counters":[]},{"line":"                    [ (\"batch_num\", `Int batch_num)","counters":[]},{"line":"                    ; (\"num_batches\", `Int num_batches)","counters":[]},{"line":"                    ; ( \"peers\"","counters":[]},{"line":"                      , `List (List.map ~f:Peer_without_id.to_yojson batch) )","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"                    ] ) ) ) ) ;","counters":[]},{"line":"  Deferred.Or_error.return t","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"let send_heartbeat t peer_id = Libp2p_helper.send_heartbeat ~peer_id t.helper","counters":[{"col_start":31,"col_end":31,"count":0},{"col_start":76,"col_end":76,"count":2}]}]}