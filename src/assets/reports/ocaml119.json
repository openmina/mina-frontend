{"filename":"src/lib/mina_base/control.ml","lines":[{"line":"[%%import \"/src/config.mlh\"]","counters":[]},{"line":"","counters":[{"col_start":0,"col_end":0,"count":1}]},{"line":"open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"(* TODO: temporary hack *)","counters":[]},{"line":"[%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"[%%versioned","counters":[]},{"line":"module Stable = struct","counters":[]},{"line":"  module V2 = struct","counters":[]},{"line":"    type t = Mina_wire_types.Mina_base.Control.V2.t =","counters":[{"col_start":4,"col_end":4,"count":2},{"col_start":9,"col_end":9,"count":2}]},{"line":"      | Proof of Pickles.Side_loaded.Proof.Stable.V2.t","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":53,"col_end":53,"count":0}]},{"line":"      | Signature of Signature.Stable.V1.t","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":21,"col_end":21,"count":0},{"col_start":41,"col_end":41,"count":0}]},{"line":"      | None_given","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    [@@deriving sexp, equal, yojson, hash, compare]","counters":[{"col_start":50,"col_end":50,"count":5}]},{"line":"","counters":[]},{"line":"    let to_latest = Fn.id","counters":[]},{"line":"  end","counters":[]},{"line":"end]","counters":[]},{"line":"","counters":[]},{"line":"(* lazy, to prevent spawning Rust threads at startup, which prevents daemonization *)","counters":[]},{"line":"let gen_with_dummies : t Quickcheck.Generator.t =","counters":[]},{"line":"  let gen =","counters":[]},{"line":"    lazy","counters":[]},{"line":"      (Quickcheck.Generator.of_list","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"         (let dummy_proof =","counters":[]},{"line":"            let n2 = Pickles_types.Nat.N2.n in","counters":[]},{"line":"            let proof = Pickles.Proof.dummy n2 n2 n2 ~domain_log2:15 in","counters":[]},{"line":"            Proof proof","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"          in","counters":[]},{"line":"          let dummy_signature = Signature Signature.dummy in","counters":[]},{"line":"          [ dummy_proof; dummy_signature; None_given ] ) )","counters":[]},{"line":"  in","counters":[]},{"line":"  Quickcheck.Generator.create (fun ~size ~random ->","counters":[{"col_start":28,"col_end":28,"count":1}]},{"line":"      Quickcheck.Generator.generate (Lazy.force gen) ~size ~random )","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":46,"col_end":46,"count":0}]},{"line":"","counters":[]},{"line":"[%%else]","counters":[]},{"line":"","counters":[]},{"line":"[%%versioned","counters":[]},{"line":"module Stable = struct","counters":[]},{"line":"  module V2 = struct","counters":[]},{"line":"    type t = Proof of unit | Signature of Signature.Stable.V1.t | None_given","counters":[]},{"line":"    [@@deriving sexp, equal, yojson, hash, compare]","counters":[]},{"line":"","counters":[]},{"line":"    let to_latest = Fn.id","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module V1 = struct","counters":[]},{"line":"    type t =","counters":[]},{"line":"      | Proof of unit","counters":[]},{"line":"      | Signature of Signature.Stable.V1.t","counters":[]},{"line":"      | Both of { signature : Signature.Stable.V1.t; proof : unit }","counters":[]},{"line":"      | None_given","counters":[]},{"line":"    [@@deriving sexp, equal, yojson, hash, compare]","counters":[]},{"line":"","counters":[]},{"line":"    let to_latest : t -> V2.t = function","counters":[]},{"line":"      | Proof proof ->","counters":[]},{"line":"          Proof proof","counters":[]},{"line":"      | Signature signature ->","counters":[]},{"line":"          Signature signature","counters":[]},{"line":"      | None_given ->","counters":[]},{"line":"          None_given","counters":[]},{"line":"      | Both _ ->","counters":[]},{"line":"          failwith","counters":[]},{"line":"            \"Control.Stable.V1.to_latest: Both variant is no longer supported\"","counters":[]},{"line":"  end","counters":[]},{"line":"end]","counters":[]},{"line":"","counters":[]},{"line":"[%%endif]","counters":[]},{"line":"","counters":[]},{"line":"module Tag = struct","counters":[]},{"line":"  type t = Proof | Signature | None_given [@@deriving equal, compare, sexp]","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":11,"col_end":11,"count":0},{"col_start":17,"col_end":17,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"  let gen = Quickcheck.Generator.of_list [ Proof; Signature; None_given ]","counters":[{"col_start":39,"col_end":39,"count":1}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let tag : t -> Tag.t = function","counters":[]},{"line":"  | Proof _ ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Proof","counters":[]},{"line":"  | Signature _ ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Signature","counters":[]},{"line":"  | None_given ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      None_given","counters":[]},{"line":"","counters":[]},{"line":"[%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"let dummy_of_tag : Tag.t -> t = function","counters":[]},{"line":"  | Proof ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      let n2 = Pickles_types.Nat.N2.n in","counters":[]},{"line":"      let proof = Pickles.Proof.dummy n2 n2 n2 ~domain_log2:15 in","counters":[]},{"line":"      Proof proof","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"  | Signature ->","counters":[{"col_start":4,"col_end":4,"count":1}]},{"line":"      Signature Signature.dummy","counters":[]},{"line":"  | None_given ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      None_given","counters":[]},{"line":"","counters":[]},{"line":"let signature_deriver obj =","counters":[]},{"line":"  Fields_derivers_zkapps.Derivers.iso_string obj ~name:\"Signature\"","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    ~js_type:String ~to_string:Signature.to_base58_check","counters":[]},{"line":"    ~of_string:","counters":[]},{"line":"      (Fields_derivers_zkapps.except ~f:Signature.of_base58_check_exn `Signature)","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"module As_record = struct","counters":[]},{"line":"  type t =","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":7,"col_end":7,"count":0}]},{"line":"    { proof : Pickles.Side_loaded.Proof.t option","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    ; signature : Signature.t option","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"    }","counters":[]},{"line":"  [@@deriving annot, fields]","counters":[]},{"line":"","counters":[]},{"line":"  let deriver obj =","counters":[]},{"line":"    let open Fields_derivers_zkapps in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let ( !. ) = ( !. ) ~t_fields_annots in","counters":[]},{"line":"    Fields.make_creator obj","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"      ~proof:!.(option ~js_type:Or_undefined @@ proof @@ o ())","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":43,"col_end":43,"count":0},{"col_start":52,"col_end":52,"count":0},{"col_start":57,"col_end":57,"count":0}]},{"line":"      ~signature:!.(option ~js_type:Or_undefined @@ signature_deriver @@ o ())","counters":[{"col_start":18,"col_end":18,"count":0},{"col_start":47,"col_end":47,"count":0},{"col_start":68,"col_end":68,"count":0},{"col_start":73,"col_end":73,"count":0}]},{"line":"    |> finish \"Control\" ~t_toplevel_annots","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let to_record = function","counters":[]},{"line":"  | Proof p ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      { As_record.proof = Some p; signature = None }","counters":[]},{"line":"  | Signature s ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      { proof = None; signature = Some s }","counters":[]},{"line":"  | None_given ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      { proof = None; signature = None }","counters":[]},{"line":"","counters":[]},{"line":"let of_record = function","counters":[]},{"line":"  | { As_record.proof = Some p; _ } ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Proof p","counters":[]},{"line":"  | { signature = Some s; _ } ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Signature s","counters":[]},{"line":"  | _ ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      None_given","counters":[]},{"line":"","counters":[]},{"line":"let deriver obj =","counters":[]},{"line":"  Fields_derivers_zkapps.Derivers.iso_record ~of_record ~to_record","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    As_record.deriver obj","counters":[]},{"line":"","counters":[]},{"line":"let%test_unit \"json rountrip\" =","counters":[]},{"line":"  let module Fd = Fields_derivers_zkapps.Derivers in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let full = deriver (Fd.o ()) in","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"  let control = dummy_of_tag Proof in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  [%test_eq: t] control (control |> Fd.to_json full |> Fd.of_json full)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":13,"col_end":13,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":64,"col_end":64,"count":0},{"col_start":70,"col_end":70,"count":1}]},{"line":"","counters":[]},{"line":"[%%endif]","counters":[]}]}