{"filename":"src/lib/data_hash_lib/data_hash.ml","lines":[{"line":"(* data_hash.ml *)","counters":[]},{"line":"","counters":[]},{"line":"[%%import \"/src/config.mlh\"]","counters":[]},{"line":"","counters":[{"col_start":0,"col_end":0,"count":1}]},{"line":"open Core_kernel","counters":[]},{"line":"open Snark_params.Tick","counters":[]},{"line":"","counters":[]},{"line":"[%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"open Bitstring_lib","counters":[]},{"line":"","counters":[]},{"line":"[%%endif]","counters":[]},{"line":"","counters":[]},{"line":"module type Full_size = Data_hash_intf.Full_size","counters":[]},{"line":"","counters":[]},{"line":"module Make_basic (M : sig","counters":[]},{"line":"  val length_in_bits : int","counters":[]},{"line":"end) =","counters":[]},{"line":"struct","counters":[]},{"line":"  type t = Field.t [@@deriving sexp, compare, hash]","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"","counters":[]},{"line":"  let to_decimal_string (t : Field.t) = Field.to_string t","counters":[{"col_start":40,"col_end":40,"count":0}]},{"line":"","counters":[]},{"line":"  let of_decimal_string (s : string) = Field.of_string s","counters":[{"col_start":39,"col_end":39,"count":1}]},{"line":"","counters":[]},{"line":"  let to_bytes t =","counters":[]},{"line":"    Fold_lib.(Fold.bool_t_to_string (Fold.of_list (Field.unpack t)))","counters":[{"col_start":4,"col_end":4,"count":5},{"col_start":48,"col_end":48,"count":5},{"col_start":62,"col_end":62,"count":5}]},{"line":"","counters":[]},{"line":"  let length_in_bits = M.length_in_bits","counters":[]},{"line":"","counters":[]},{"line":"  let () = assert (Int.(length_in_bits <= Field.size_in_bits))","counters":[{"col_start":18,"col_end":18,"count":8}]},{"line":"","counters":[]},{"line":"  let to_input t = Random_oracle.Input.Chunked.field t","counters":[{"col_start":19,"col_end":19,"count":309}]},{"line":"","counters":[]},{"line":"  [%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"  (* this is in consensus code, because Bigint comes","counters":[]},{"line":"     from snarky functors","counters":[]},{"line":"  *)","counters":[]},{"line":"  let gen : t Quickcheck.Generator.t =","counters":[]},{"line":"    let m =","counters":[]},{"line":"      if Int.(length_in_bits = Field.size_in_bits) then","counters":[]},{"line":"        Bignum_bigint.(Field.size - one)","counters":[{"col_start":8,"col_end":8,"count":8}]},{"line":"      else Bignum_bigint.(pow (of_int 2) (of_int length_in_bits) - one)","counters":[{"col_start":11,"col_end":11,"count":0},{"col_start":28,"col_end":28,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":47,"col_end":47,"count":0}]},{"line":"    in","counters":[]},{"line":"    Quickcheck.Generator.map","counters":[{"col_start":27,"col_end":27,"count":8}]},{"line":"      Bignum_bigint.(gen_incl zero m)","counters":[{"col_start":28,"col_end":28,"count":8}]},{"line":"      ~f:(fun x -> Bigint.(to_field (of_bignum_bigint x)))","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":52,"col_end":52,"count":0}]},{"line":"","counters":[]},{"line":"  type var =","counters":[]},{"line":"    { digest : Random_oracle.Checked.Digest.t","counters":[]},{"line":"    ; mutable bits : Boolean.var Bitstring.Lsb_first.t option","counters":[]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  let var_of_t t =","counters":[]},{"line":"    let n = Bigint.of_field t in","counters":[{"col_start":4,"col_end":4,"count":3}]},{"line":"    { digest = Field.Var.constant t","counters":[{"col_start":4,"col_end":4,"count":3},{"col_start":32,"col_end":32,"count":3}]},{"line":"    ; bits =","counters":[]},{"line":"        Some","counters":[]},{"line":"          (Bitstring.Lsb_first.of_list","counters":[{"col_start":37,"col_end":37,"count":3}]},{"line":"             (List.init M.length_in_bits ~f:(fun i ->","counters":[{"col_start":22,"col_end":22,"count":3}]},{"line":"                  Boolean.var_of_value (Bigint.test_bit n i) ) ) )","counters":[{"col_start":18,"col_end":18,"count":765},{"col_start":54,"col_end":54,"count":765}]},{"line":"    }","counters":[]},{"line":"","counters":[]},{"line":"  open Let_syntax","counters":[]},{"line":"","counters":[]},{"line":"  let var_to_hash_packed { digest; _ } = digest","counters":[{"col_start":41,"col_end":41,"count":0}]},{"line":"","counters":[]},{"line":"  (* TODO: Audit this usage of choose_preimage *)","counters":[]},{"line":"  let unpack =","counters":[]},{"line":"    if Int.( = ) length_in_bits Field.size_in_bits then fun x ->","counters":[{"col_start":56,"col_end":56,"count":8}]},{"line":"      Field.Checked.choose_preimage_var x ~length:length_in_bits","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"      >>| fun x -> (x :> Boolean.var list)","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"    else Field.Checked.unpack ~length:length_in_bits","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"","counters":[]},{"line":"  let%snarkydef_ var_to_bits t =","counters":[]},{"line":"    match t.bits with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Some bits ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        return (bits :> Boolean.var list)","counters":[]},{"line":"    | None ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let%map bits = unpack t.digest in","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"        t.bits <- Some (Bitstring.Lsb_first.of_list bits) ;","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":50,"col_end":50,"count":0}]},{"line":"        bits","counters":[]},{"line":"","counters":[]},{"line":"  let var_to_input (t : var) = Random_oracle.Input.Chunked.field t.digest","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"","counters":[]},{"line":"  (* TODO : use Random oracle.Digest to satisfy Bits_intf.S, move out of","counters":[]},{"line":"     consensus_mechanism guard","counters":[]},{"line":"  *)","counters":[]},{"line":"  module Bs =","counters":[]},{"line":"    Snark_bits.Bits.Make_field","counters":[]},{"line":"      (Snark_params.Tick.Field)","counters":[]},{"line":"      (Snark_params.Tick.Bigint)","counters":[]},{"line":"","counters":[]},{"line":"  include (Bs : module type of Bs with type t := t)","counters":[]},{"line":"","counters":[]},{"line":"  let assert_equal x y = Field.Checked.Assert.equal x.digest y.digest","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"","counters":[]},{"line":"  let equal_var x y = Field.Checked.equal x.digest y.digest","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"","counters":[]},{"line":"  let typ : (var, t) Typ.t =","counters":[]},{"line":"    Typ.transport_var Typ.field","counters":[{"col_start":20,"col_end":20,"count":8}]},{"line":"      ~there:(fun { digest; bits = _ } -> digest)","counters":[{"col_start":42,"col_end":42,"count":0}]},{"line":"      ~back:(fun digest -> { digest; bits = None })","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"","counters":[]},{"line":"  [%%endif]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module T0 = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"    module V1 = struct","counters":[]},{"line":"      [@@@with_all_version_tags]","counters":[]},{"line":"","counters":[]},{"line":"      type t = (Field.t[@version_asserted]) [@@deriving sexp, compare, hash]","counters":[{"col_start":6,"col_end":6,"count":4},{"col_start":11,"col_end":11,"count":2},{"col_start":75,"col_end":75,"count":15}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make_full_size (B58_data : Data_hash_intf.Data_hash_descriptor) = struct","counters":[]},{"line":"  module Basic = Make_basic (struct","counters":[]},{"line":"    let length_in_bits = Field.size_in_bits","counters":[]},{"line":"  end)","counters":[]},{"line":"","counters":[]},{"line":"  include Basic","counters":[]},{"line":"","counters":[]},{"line":"  module Base58_check = Codable.Make_base58_check (struct","counters":[]},{"line":"    (* for compatibility with legacy Base58Check serializations *)","counters":[]},{"line":"    include T0.Stable.Latest.With_all_version_tags","counters":[]},{"line":"","counters":[]},{"line":"    (* the serialization here is only used for the hash impl which is only","counters":[]},{"line":"       used for hashtbl, it's ok to disagree with the \"real\" serialization *)","counters":[]},{"line":"    include Hashable.Make_binable (T0.Stable.Latest)","counters":[]},{"line":"    include B58_data","counters":[]},{"line":"  end)","counters":[]},{"line":"","counters":[]},{"line":"  [%%define_locally","counters":[]},{"line":"  Base58_check.","counters":[]},{"line":"    (to_base58_check, of_base58_check, of_base58_check_exn, to_yojson, of_yojson)]","counters":[]},{"line":"","counters":[]},{"line":"  module T = struct","counters":[]},{"line":"    type t = Field.t [@@deriving sexp, compare, hash]","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  include Comparable.Make (T)","counters":[]},{"line":"  include Hashable.Make (T)","counters":[]},{"line":"","counters":[]},{"line":"  let of_hash = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"  let to_field = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"  [%%ifdef consensus_mechanism]","counters":[]},{"line":"","counters":[]},{"line":"  let var_of_hash_packed digest = { digest; bits = None }","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"","counters":[]},{"line":"  let var_to_field { digest; _ } = digest","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"","counters":[]},{"line":"  let if_ cond ~then_ ~else_ =","counters":[]},{"line":"    let%map digest =","counters":[]},{"line":"      Field.Checked.if_ cond ~then_:then_.digest ~else_:else_.digest","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"    in","counters":[]},{"line":"    { digest; bits = None }","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  [%%endif]","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":1}]}]}