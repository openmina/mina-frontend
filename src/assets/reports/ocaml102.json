{"filename":"src/lib/pickles_types/shifted_value.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"module type Field_intf = sig","counters":[]},{"line":"  type t","counters":[]},{"line":"","counters":[]},{"line":"  val size_in_bits : int","counters":[]},{"line":"","counters":[]},{"line":"  val negate : t -> t","counters":[]},{"line":"","counters":[]},{"line":"  val ( - ) : t -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"  val ( + ) : t -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"  val ( * ) : t -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"  val ( / ) : t -> t -> t","counters":[]},{"line":"","counters":[]},{"line":"  val inv : t -> t","counters":[]},{"line":"","counters":[]},{"line":"  val one : t","counters":[]},{"line":"","counters":[]},{"line":"  val of_int : int -> t","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let two_to_the (type f) (module F : Field_intf with type t = f) =","counters":[]},{"line":"  let rec two_to_the n =","counters":[{"col_start":2,"col_end":2,"count":10}]},{"line":"    if n = 0 then F.one","counters":[{"col_start":4,"col_end":4,"count":2560},{"col_start":18,"col_end":18,"count":10}]},{"line":"    else","counters":[]},{"line":"      let r = two_to_the (n - 1) in","counters":[{"col_start":6,"col_end":6,"count":2550}]},{"line":"      F.(r + r)","counters":[{"col_start":6,"col_end":6,"count":2550}]},{"line":"  in","counters":[]},{"line":"  two_to_the","counters":[]},{"line":"","counters":[]},{"line":"(* Our custom constraints let us efficiently compute","counters":[]},{"line":"","counters":[]},{"line":"   f = fun (g, t) -> (2 * t + 1 + 2^len(t)) g","counters":[]},{"line":"","counters":[]},{"line":"   We want to compute","counters":[]},{"line":"","counters":[]},{"line":"   f' = fun (g, s) -> s * g","counters":[]},{"line":"","counters":[]},{"line":"   Let n be the field size in bits.","counters":[]},{"line":"","counters":[]},{"line":"   For a scalar s, let t = (s - 2^n - 1)/2.","counters":[]},{"line":"   t can be represented with an n bit string.","counters":[]},{"line":"","counters":[]},{"line":"   Then","counters":[]},{"line":"","counters":[]},{"line":"   f (g, t)","counters":[]},{"line":"   = (2 t + 2^n + 1) * g","counters":[]},{"line":"   = (2 (s - 2^n - 1)/2 + 2^n + 1) * g","counters":[]},{"line":"   = (s - 2^n - 1 + 2^n + 1) * g","counters":[]},{"line":"   = s * g","counters":[]},{"line":"   = f' (g, s)","counters":[]},{"line":"","counters":[]},{"line":"   as desired.","counters":[]},{"line":"*)","counters":[]},{"line":"","counters":[]},{"line":"module type S = sig","counters":[]},{"line":"  [%%versioned:","counters":[]},{"line":"  module Stable : sig","counters":[]},{"line":"    module V1 : sig","counters":[]},{"line":"      type 'f t [@@deriving sexp, compare, equal, yojson, hash]","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  val typ :","counters":[]},{"line":"       ('a, 'b, 'f) Snarky_backendless.Typ.t","counters":[]},{"line":"    -> ('a t, 'b t, 'f) Snarky_backendless.Typ.t","counters":[]},{"line":"","counters":[]},{"line":"  val map : 'a t -> f:('a -> 'b) -> 'b t","counters":[]},{"line":"","counters":[]},{"line":"  module Shift : sig","counters":[]},{"line":"    type _ t","counters":[]},{"line":"","counters":[]},{"line":"    val create : (module Field_intf with type t = 'f) -> 'f t","counters":[]},{"line":"","counters":[]},{"line":"    val map : 'a t -> f:('a -> 'b) -> 'b t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  val of_field :","counters":[]},{"line":"    (module Field_intf with type t = 'f) -> shift:'f Shift.t -> 'f -> 'f t","counters":[]},{"line":"","counters":[]},{"line":"  val to_field :","counters":[]},{"line":"    (module Field_intf with type t = 'f) -> shift:'f Shift.t -> 'f t -> 'f","counters":[]},{"line":"","counters":[]},{"line":"  val equal : ('f, 'res) Sigs.rel2 -> ('f t, 'res) Sigs.rel2","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"[@@@warning \"-4\"]","counters":[]},{"line":"","counters":[]},{"line":"module Type1 = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type 'f t = Shifted_value of 'f","counters":[{"col_start":6,"col_end":6,"count":9},{"col_start":14,"col_end":14,"count":4},{"col_start":18,"col_end":18,"count":4},{"col_start":36,"col_end":36,"count":0}]},{"line":"      [@@deriving sexp, compare, equal, yojson, hash]","counters":[{"col_start":52,"col_end":52,"count":3}]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  let typ f =","counters":[]},{"line":"    let there (Shifted_value x) = x in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"    let back x = Shifted_value x in","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"    Snarky_backendless.Typ.(","counters":[]},{"line":"      transport_var (transport f ~there ~back) ~there ~back)","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"  let map (Shifted_value x) ~f = Shifted_value (f x)","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"","counters":[]},{"line":"  module Shift : sig","counters":[]},{"line":"    type 'f t = private { c : 'f; scale : 'f }","counters":[]},{"line":"","counters":[]},{"line":"    val create : (module Field_intf with type t = 'f) -> 'f t","counters":[]},{"line":"","counters":[]},{"line":"    val map : 'a t -> f:('a -> 'b) -> 'b t","counters":[]},{"line":"  end = struct","counters":[]},{"line":"    type 'f t = { c : 'f; scale : 'f }","counters":[]},{"line":"","counters":[]},{"line":"    let map t ~f = { c = f t.c; scale = f t.scale }","counters":[{"col_start":19,"col_end":19,"count":2},{"col_start":25,"col_end":25,"count":2},{"col_start":40,"col_end":40,"count":2}]},{"line":"","counters":[]},{"line":"    (* 2^{field size in bits} + 1 *)","counters":[]},{"line":"    let create (type f) (module F : Field_intf with type t = f) : f t =","counters":[]},{"line":"      { c = F.(two_to_the (module F) size_in_bits + one)","counters":[{"col_start":6,"col_end":6,"count":4},{"col_start":24,"col_end":24,"count":4}]},{"line":"      ; scale = F.(inv (of_int 2))","counters":[{"col_start":21,"col_end":21,"count":4},{"col_start":29,"col_end":29,"count":4}]},{"line":"      }","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let of_field (type f) (module F : Field_intf with type t = f)","counters":[]},{"line":"      ~(shift : f Shift.t) (s : f) : f t =","counters":[]},{"line":"    Shifted_value F.((s - shift.c) * shift.scale)","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let to_field (type f) (module F : Field_intf with type t = f)","counters":[]},{"line":"      ~(shift : f Shift.t) (Shifted_value t : f t) : f =","counters":[]},{"line":"    F.(t + t + shift.c)","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let equal equal (Shifted_value t1) (Shifted_value t2) = equal t1 t2","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"(* When the scalar field is larger than the inner field of the circuit,","counters":[]},{"line":"   we need to encode a scalar [s] as a pair ((s >> 1), s & 1). In other","counters":[]},{"line":"   words, the high bits, and then the low bit separately.","counters":[]},{"line":"","counters":[]},{"line":"   We can then efficiently compute the function","counters":[]},{"line":"","counters":[]},{"line":"   f = fun (g, s) -> (2 * (s >> 1) + (s & 1) + 2^(5 * ceil(len(s >> 1) / 5))) g","counters":[]},{"line":"     = fun (g, s) -> (s + 2^field_size_in_bits) g","counters":[]},{"line":"","counters":[]},{"line":"   This is a different notion of shifted value, so we have a separate type for it.","counters":[]},{"line":"*)","counters":[]},{"line":"","counters":[]},{"line":"module Type2 = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type 'f t = Shifted_value of 'f","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":14,"col_end":14,"count":4},{"col_start":18,"col_end":18,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"      [@@deriving sexp, compare, equal, yojson, hash]","counters":[{"col_start":52,"col_end":52,"count":1}]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  let typ f =","counters":[]},{"line":"    let there (Shifted_value x) = x in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":34,"col_end":34,"count":0}]},{"line":"    let back x = Shifted_value x in","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"    Snarky_backendless.Typ.(","counters":[]},{"line":"      transport_var (transport f ~there ~back) ~there ~back)","counters":[{"col_start":29,"col_end":29,"count":0}]},{"line":"","counters":[]},{"line":"  let map (Shifted_value x) ~f = Shifted_value (f x)","counters":[{"col_start":33,"col_end":33,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"","counters":[]},{"line":"  module Shift : sig","counters":[]},{"line":"    type 'f t = private 'f","counters":[]},{"line":"","counters":[]},{"line":"    val create : (module Field_intf with type t = 'f) -> 'f t","counters":[]},{"line":"","counters":[]},{"line":"    val map : 'a t -> f:('a -> 'b) -> 'b t","counters":[]},{"line":"  end = struct","counters":[]},{"line":"    type 'f t = 'f","counters":[]},{"line":"","counters":[]},{"line":"    let map t ~f = f t","counters":[{"col_start":19,"col_end":19,"count":2}]},{"line":"","counters":[]},{"line":"    (* 2^{field size in bits} *)","counters":[]},{"line":"    let create (type f) (module F : Field_intf with type t = f) : f t =","counters":[]},{"line":"      two_to_the (module F) F.size_in_bits","counters":[{"col_start":6,"col_end":6,"count":6}]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  let of_field (type f) (module F : Field_intf with type t = f)","counters":[]},{"line":"      ~(shift : f Shift.t) (s : f) : f t =","counters":[]},{"line":"    Shifted_value F.(s - (shift :> t))","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let to_field (type f) (module F : Field_intf with type t = f)","counters":[]},{"line":"      ~(shift : f Shift.t) (Shifted_value t : f t) : f =","counters":[]},{"line":"    F.(t + (shift :> t))","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let equal equal (Shifted_value t1) (Shifted_value t2) = equal t1 t2","counters":[{"col_start":58,"col_end":58,"count":0}]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}