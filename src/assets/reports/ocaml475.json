{"filename":"src/lib/mina_base/user_command.ml","lines":[{"line":"open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"module Poly = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V2 = struct","counters":[]},{"line":"      type ('u, 's) t =","counters":[{"col_start":6,"col_end":6,"count":3},{"col_start":20,"col_end":20,"count":5}]},{"line":"            ('u, 's) Mina_wire_types.Mina_base.User_command.Poly.V2.t =","counters":[]},{"line":"        | Signed_command of 'u","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":29,"col_end":29,"count":0}]},{"line":"        | Zkapp_command of 's","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"      [@@deriving sexp, compare, equal, hash, yojson]","counters":[{"col_start":52,"col_end":52,"count":7}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type ('u, 's) t = Signed_command of 'u | Snapp_command of 's","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":20,"col_end":20,"count":5},{"col_start":24,"col_end":24,"count":0},{"col_start":43,"col_end":43,"count":0},{"col_start":45,"col_end":45,"count":0},{"col_start":65,"col_end":65,"count":0}]},{"line":"      [@@deriving sexp, compare, equal, hash, yojson]","counters":[{"col_start":52,"col_end":52,"count":1}]},{"line":"","counters":[]},{"line":"      let to_latest : _ t -> _ V2.t = function","counters":[]},{"line":"        | Signed_command x ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            Signed_command x","counters":[]},{"line":"        | Snapp_command _ ->","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            failwith \"Snapp_command\"","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"type ('u, 's) t_ = ('u, 's) Poly.Stable.Latest.t =","counters":[]},{"line":"  | Signed_command of 'u","counters":[]},{"line":"  | Zkapp_command of 's","counters":[]},{"line":"","counters":[]},{"line":"module Gen_make (C : Signed_command_intf.Gen_intf) = struct","counters":[]},{"line":"  let to_signed_command f =","counters":[]},{"line":"    Quickcheck.Generator.map f ~f:(fun c -> Signed_command c)","counters":[{"col_start":4,"col_end":4,"count":1},{"col_start":44,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"  open C.Gen","counters":[]},{"line":"","counters":[]},{"line":"  let payment ?sign_type ~key_gen ?nonce ~max_amount ~fee_range () =","counters":[]},{"line":"    to_signed_command","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (payment ?sign_type ~key_gen ?nonce ~max_amount ~fee_range ())","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"  let payment_with_random_participants ?sign_type ~keys ?nonce ~max_amount","counters":[]},{"line":"      ~fee_range () =","counters":[]},{"line":"    to_signed_command","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (payment_with_random_participants ?sign_type ~keys ?nonce ~max_amount","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"         ~fee_range () )","counters":[]},{"line":"","counters":[]},{"line":"  let stake_delegation ~key_gen ?nonce ~fee_range () =","counters":[]},{"line":"    to_signed_command (stake_delegation ~key_gen ?nonce ~fee_range ())","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":38,"col_end":38,"count":0}]},{"line":"","counters":[]},{"line":"  let stake_delegation_with_random_participants ~keys ?nonce ~fee_range () =","counters":[]},{"line":"    to_signed_command","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (stake_delegation_with_random_participants ~keys ?nonce ~fee_range ())","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"","counters":[]},{"line":"  let sequence ?length ?sign_type a =","counters":[]},{"line":"    Quickcheck.Generator.map","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      (sequence ?length ?sign_type a)","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"      ~f:(List.map ~f:(fun c -> Signed_command c))","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Gen = Gen_make (Signed_command)","counters":[]},{"line":"","counters":[]},{"line":"let gen_signed =","counters":[]},{"line":"  let module G = Signed_command.Gen in","counters":[]},{"line":"  let open Quickcheck.Let_syntax in","counters":[]},{"line":"  let%bind keys =","counters":[]},{"line":"    Quickcheck.Generator.list_with_length 2","counters":[{"col_start":40,"col_end":40,"count":1}]},{"line":"      Mina_base_import.Signature_keypair.gen","counters":[]},{"line":"  in","counters":[]},{"line":"  G.payment_with_random_participants ~sign_type:`Real ~keys:(Array.of_list keys)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":73,"col_end":73,"count":0}]},{"line":"    ~max_amount:10000 ~fee_range:1000 ()","counters":[]},{"line":"","counters":[]},{"line":"let gen = Gen.to_signed_command gen_signed","counters":[{"col_start":30,"col_end":30,"count":1}]},{"line":"","counters":[]},{"line":"[%%versioned","counters":[]},{"line":"module Stable = struct","counters":[]},{"line":"  module V2 = struct","counters":[]},{"line":"    type t =","counters":[{"col_start":4,"col_end":4,"count":2},{"col_start":9,"col_end":9,"count":1}]},{"line":"      (Signed_command.Stable.V2.t, Zkapp_command.Stable.V1.t) Poly.Stable.V2.t","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":7,"col_end":7,"count":0},{"col_start":35,"col_end":35,"count":0},{"col_start":62,"col_end":62,"count":0}]},{"line":"    [@@deriving sexp, compare, equal, hash, yojson]","counters":[{"col_start":50,"col_end":50,"count":5}]},{"line":"","counters":[]},{"line":"    let to_latest = Fn.id","counters":[]},{"line":"  end","counters":[]},{"line":"end]","counters":[]},{"line":"","counters":[]},{"line":"let to_base64 : t -> string = function","counters":[]},{"line":"  | Signed_command sc ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Signed_command.to_base64 sc","counters":[]},{"line":"  | Zkapp_command zc ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Zkapp_command.to_base64 zc","counters":[]},{"line":"","counters":[]},{"line":"let of_base64 s : t Or_error.t =","counters":[]},{"line":"  match Signed_command.of_base64 s with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | Ok sc ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Ok (Signed_command sc)","counters":[]},{"line":"  | Error err1 -> (","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      match Zkapp_command.of_base64 s with","counters":[]},{"line":"      | Ok zc ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Ok (Zkapp_command zc)","counters":[]},{"line":"      | Error err2 ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Error","counters":[]},{"line":"            (Error.of_string","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"               (sprintf","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                  \"Could decode Base64 neither to signed command (%s), nor to \\","counters":[]},{"line":"                   zkApp (%s)\"","counters":[]},{"line":"                  (Error.to_string_hum err1) (Error.to_string_hum err2) ) ) )","counters":[{"col_start":37,"col_end":37,"count":0},{"col_start":64,"col_end":64,"count":0}]},{"line":"","counters":[]},{"line":"(*","counters":[]},{"line":"include Allocation_functor.Make.Versioned_v1.Full_compare_eq_hash (struct","counters":[]},{"line":"  let id = \"user_command\"","counters":[]},{"line":"","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type t =","counters":[]},{"line":"        (Signed_command.Stable.V1.t, Snapp_command.Stable.V1.t) Poly.Stable.V1.t","counters":[]},{"line":"      [@@deriving sexp, compare, equal, hash, yojson]","counters":[]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"","counters":[]},{"line":"      type 'a creator : Signed_command.t -> Snapp_command.t -> 'a","counters":[]},{"line":"","counters":[]},{"line":"      let create cmd1 cmd2 = (cmd1, cmd2)","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"end)","counters":[]},{"line":"*)","counters":[]},{"line":"","counters":[]},{"line":"module Zero_one_or_two = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V1 = struct","counters":[]},{"line":"      type 'a t = [ `Zero | `One of 'a | `Two of 'a * 'a ]","counters":[{"col_start":6,"col_end":6,"count":0},{"col_start":11,"col_end":11,"count":0},{"col_start":14,"col_end":14,"count":3},{"col_start":18,"col_end":18,"count":0},{"col_start":36,"col_end":36,"count":0},{"col_start":37,"col_end":37,"count":0},{"col_start":49,"col_end":49,"count":0},{"col_start":50,"col_end":50,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"      [@@deriving sexp, compare, equal, hash, yojson]","counters":[{"col_start":52,"col_end":52,"count":1}]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Verifiable = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V2 = struct","counters":[]},{"line":"      type t =","counters":[{"col_start":6,"col_end":6,"count":2},{"col_start":11,"col_end":11,"count":1}]},{"line":"        ( Signed_command.Stable.V2.t","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":10,"col_end":10,"count":0}]},{"line":"        , Zkapp_command.Verifiable.Stable.V1.t )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        Poly.Stable.V2.t","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      [@@deriving sexp, compare, equal, hash, yojson]","counters":[{"col_start":52,"col_end":52,"count":5}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  let fee_payer (t : t) =","counters":[]},{"line":"    match t with","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    | Signed_command x ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Signed_command.fee_payer x","counters":[]},{"line":"    | Zkapp_command p ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        Account_update.Fee_payer.account_id p.fee_payer","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let to_verifiable (t : t) ~ledger ~get ~location_of_account : Verifiable.t =","counters":[]},{"line":"  let find_vk (p : Account_update.t) =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    let ( ! ) x = Option.value_exn x in","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"    let id = Account_update.account_id p in","counters":[]},{"line":"    Option.try_with (fun () ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        let account : Account.t =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          !(get ledger !(location_of_account ledger id))","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":43,"col_end":43,"count":0}]},{"line":"        in","counters":[]},{"line":"        !(!(account.zkapp).verification_key) )","counters":[]},{"line":"  in","counters":[]},{"line":"  match t with","counters":[]},{"line":"  | Signed_command c ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Signed_command c","counters":[]},{"line":"  | Zkapp_command { fee_payer; account_updates; memo } ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Zkapp_command","counters":[]},{"line":"        { fee_payer","counters":[]},{"line":"        ; account_updates =","counters":[]},{"line":"            account_updates","counters":[]},{"line":"            |> Zkapp_command.Call_forest.map ~f:(fun account_update ->","counters":[{"col_start":43,"col_end":43,"count":0}]},{"line":"                   (account_update, find_vk account_update) )","counters":[{"col_start":19,"col_end":19,"count":0},{"col_start":42,"col_end":42,"count":0}]},{"line":"        ; memo","counters":[]},{"line":"        }","counters":[]},{"line":"","counters":[]},{"line":"let of_verifiable (t : Verifiable.t) : t =","counters":[]},{"line":"  match t with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | Signed_command x ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Signed_command x","counters":[]},{"line":"  | Zkapp_command p ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Zkapp_command (Zkapp_command.of_verifiable p)","counters":[{"col_start":47,"col_end":47,"count":0}]},{"line":"","counters":[]},{"line":"let fee : t -> Currency.Fee.t = function","counters":[]},{"line":"  | Signed_command x ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Signed_command.fee x","counters":[]},{"line":"  | Zkapp_command p ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Zkapp_command.fee p","counters":[]},{"line":"","counters":[]},{"line":"(* for filtering *)","counters":[]},{"line":"let minimum_fee = Mina_compile_config.minimum_user_command_fee","counters":[]},{"line":"","counters":[]},{"line":"let has_insufficient_fee t = Currency.Fee.(fee t < minimum_fee)","counters":[{"col_start":29,"col_end":29,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"","counters":[]},{"line":"let accounts_accessed (t : t) (status : Transaction_status.t) =","counters":[]},{"line":"  match t with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | Signed_command x ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Signed_command.accounts_accessed x status","counters":[]},{"line":"  | Zkapp_command ps ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Zkapp_command.accounts_accessed ps status","counters":[]},{"line":"","counters":[]},{"line":"let accounts_referenced (t : t) = accounts_accessed t Applied","counters":[{"col_start":34,"col_end":34,"count":0}]},{"line":"","counters":[]},{"line":"let fee_payer (t : t) =","counters":[]},{"line":"  match t with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | Signed_command x ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Signed_command.fee_payer x","counters":[]},{"line":"  | Zkapp_command p ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Zkapp_command.fee_payer p","counters":[]},{"line":"","counters":[]},{"line":"(** The application nonce is the nonce of the fee payer at which a user command can be applied. *)","counters":[]},{"line":"let applicable_at_nonce (t : t) =","counters":[]},{"line":"  match t with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | Signed_command x ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Signed_command.nonce x","counters":[]},{"line":"  | Zkapp_command p ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Zkapp_command.applicable_at_nonce p","counters":[]},{"line":"","counters":[]},{"line":"let expected_target_nonce t = Account.Nonce.succ (applicable_at_nonce t)","counters":[{"col_start":30,"col_end":30,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"","counters":[]},{"line":"(** The target nonce is what the nonce of the fee payer will be after a user command is successfully applied. *)","counters":[]},{"line":"let target_nonce_on_success (t : t) =","counters":[]},{"line":"  match t with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | Signed_command x ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Account.Nonce.succ (Signed_command.nonce x)","counters":[{"col_start":45,"col_end":45,"count":0}]},{"line":"  | Zkapp_command p ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Zkapp_command.target_nonce_on_success p","counters":[]},{"line":"","counters":[]},{"line":"let fee_token (t : t) =","counters":[]},{"line":"  match t with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | Signed_command x ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Signed_command.fee_token x","counters":[]},{"line":"  | Zkapp_command x ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Zkapp_command.fee_token x","counters":[]},{"line":"","counters":[]},{"line":"let valid_until (t : t) =","counters":[]},{"line":"  match t with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | Signed_command x ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Signed_command.valid_until x","counters":[]},{"line":"  | Zkapp_command _ ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Mina_numbers.Global_slot.max_value","counters":[]},{"line":"","counters":[]},{"line":"module Valid = struct","counters":[]},{"line":"  [%%versioned","counters":[]},{"line":"  module Stable = struct","counters":[]},{"line":"    module V2 = struct","counters":[]},{"line":"      type t =","counters":[{"col_start":6,"col_end":6,"count":2},{"col_start":11,"col_end":11,"count":1}]},{"line":"        ( Signed_command.With_valid_signature.Stable.V2.t","counters":[{"col_start":8,"col_end":8,"count":0},{"col_start":10,"col_end":10,"count":0}]},{"line":"        , Zkapp_command.Valid.Stable.V1.t )","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        Poly.Stable.V2.t","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"      [@@deriving sexp, compare, equal, hash, yojson]","counters":[{"col_start":52,"col_end":52,"count":5}]},{"line":"","counters":[]},{"line":"      let to_latest = Fn.id","counters":[]},{"line":"    end","counters":[]},{"line":"  end]","counters":[]},{"line":"","counters":[]},{"line":"  module Gen = Gen_make (Signed_command.With_valid_signature)","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"let check ~ledger ~get ~location_of_account (t : t) : Valid.t option =","counters":[]},{"line":"  match t with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | Signed_command x ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Option.map (Signed_command.check x) ~f:(fun c -> Signed_command c)","counters":[{"col_start":37,"col_end":37,"count":0},{"col_start":55,"col_end":55,"count":0}]},{"line":"  | Zkapp_command p ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Option.map","counters":[]},{"line":"        (Zkapp_command.Valid.to_valid ~ledger ~get ~location_of_account p)","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"        ~f:(fun p -> Zkapp_command p)","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"","counters":[]},{"line":"let forget_check (t : Valid.t) : t =","counters":[]},{"line":"  match t with","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  | Zkapp_command x ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Zkapp_command (Zkapp_command.Valid.forget x)","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"  | Signed_command c ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Signed_command (c :> Signed_command.t)","counters":[]},{"line":"","counters":[]},{"line":"let to_valid_unsafe (t : t) =","counters":[]},{"line":"  `If_this_is_used_it_should_have_a_comment_justifying_it","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    ( match t with","counters":[]},{"line":"    | Zkapp_command x ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        let (`If_this_is_used_it_should_have_a_comment_justifying_it x) =","counters":[]},{"line":"          Zkapp_command.Valid.to_valid_unsafe x","counters":[]},{"line":"        in","counters":[]},{"line":"        Zkapp_command x","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"    | Signed_command x ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (* This is safe due to being immediately wrapped again. *)","counters":[]},{"line":"        let (`If_this_is_used_it_should_have_a_comment_justifying_it x) =","counters":[]},{"line":"          Signed_command.to_valid_unsafe x","counters":[]},{"line":"        in","counters":[]},{"line":"        Signed_command x )","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"","counters":[]},{"line":"let filter_by_participant (commands : t list) public_key =","counters":[]},{"line":"  List.filter commands ~f:(fun user_command ->","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"      Core_kernel.List.exists","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (accounts_referenced user_command)","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"        ~f:","counters":[]},{"line":"          (Fn.compose","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"             (Signature_lib.Public_key.Compressed.equal public_key)","counters":[{"col_start":54,"col_end":54,"count":0}]},{"line":"             Account_id.public_key ) )","counters":[]},{"line":"","counters":[]},{"line":"(* A metric on user commands that should correspond roughly to resource costs","counters":[]},{"line":"   for validation/application *)","counters":[]},{"line":"let weight : t -> int = function","counters":[]},{"line":"  | Signed_command signed_command ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Signed_command.payload signed_command |> Signed_command_payload.weight","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"  | Zkapp_command zkapp_command ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Zkapp_command.weight zkapp_command","counters":[]},{"line":"","counters":[]},{"line":"(* Fee per weight unit *)","counters":[]},{"line":"let fee_per_wu (user_command : Stable.Latest.t) : Currency.Fee_rate.t =","counters":[]},{"line":"  (*TODO: return Or_error*)","counters":[]},{"line":"  Currency.Fee_rate.make_exn (fee user_command) (weight user_command)","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":32,"col_end":32,"count":0},{"col_start":54,"col_end":54,"count":0}]},{"line":"","counters":[]},{"line":"let valid_size ~genesis_constants = function","counters":[]},{"line":"  | Signed_command _ ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Ok ()","counters":[]},{"line":"  | Zkapp_command zkapp_command ->","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Zkapp_command.valid_size ~genesis_constants zkapp_command","counters":[{"col_start":62,"col_end":62,"count":1}]}]}