{"filename":"src/lib/crypto/kimchi_backend/common/dlog_plonk_based_keypair.ml","lines":[{"line":"module Poly_comm0 = Poly_comm","counters":[]},{"line":"open Unsigned.Size_t","counters":[]},{"line":"","counters":[]},{"line":"module type Stable_v1 = sig","counters":[]},{"line":"  module Stable : sig","counters":[]},{"line":"    module V1 : sig","counters":[]},{"line":"      type t [@@deriving version, bin_io, sexp, compare, yojson, hash, equal]","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Latest = V1","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  type t = Stable.V1.t [@@deriving sexp, compare, yojson]","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module type Inputs_intf = sig","counters":[]},{"line":"  open Intf","counters":[]},{"line":"","counters":[]},{"line":"  val name : string","counters":[]},{"line":"","counters":[]},{"line":"  module Rounds : Pickles_types.Nat.Intf","counters":[]},{"line":"","counters":[]},{"line":"  module Gate_vector : sig","counters":[]},{"line":"    open Unsigned","counters":[]},{"line":"","counters":[]},{"line":"    type t","counters":[]},{"line":"","counters":[]},{"line":"    val wrap : t -> Kimchi_types.wire -> Kimchi_types.wire -> unit","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Urs : sig","counters":[]},{"line":"    type t","counters":[]},{"line":"","counters":[]},{"line":"    val read : int option -> string -> t option","counters":[]},{"line":"","counters":[]},{"line":"    val write : bool option -> t -> string -> unit","counters":[]},{"line":"","counters":[]},{"line":"    val create : int -> t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Scalar_field : sig","counters":[]},{"line":"    include Stable_v1","counters":[]},{"line":"","counters":[]},{"line":"    val one : t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Constraint_system : sig","counters":[]},{"line":"    type t","counters":[]},{"line":"","counters":[]},{"line":"    val get_primary_input_size : t -> int","counters":[]},{"line":"","counters":[]},{"line":"    val get_prev_challenges : t -> int option","counters":[]},{"line":"","counters":[]},{"line":"    val set_prev_challenges : t -> int -> unit","counters":[]},{"line":"","counters":[]},{"line":"    val finalize_and_get_gates : t -> Gate_vector.t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Index : sig","counters":[]},{"line":"    type t","counters":[]},{"line":"","counters":[]},{"line":"    val create : Gate_vector.t -> int -> int -> Urs.t -> t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Curve : sig","counters":[]},{"line":"    module Base_field : sig","counters":[]},{"line":"      type t","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    module Affine : sig","counters":[]},{"line":"      type t = Base_field.t * Base_field.t","counters":[]},{"line":"    end","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Poly_comm : sig","counters":[]},{"line":"    module Backend : sig","counters":[]},{"line":"      type t","counters":[]},{"line":"    end","counters":[]},{"line":"","counters":[]},{"line":"    type t = Curve.Base_field.t Poly_comm0.t","counters":[]},{"line":"","counters":[]},{"line":"    val of_backend_without_degree_bound : Backend.t -> t","counters":[]},{"line":"  end","counters":[]},{"line":"","counters":[]},{"line":"  module Verifier_index : sig","counters":[]},{"line":"    type t =","counters":[]},{"line":"      ( Scalar_field.t","counters":[]},{"line":"      , Urs.t","counters":[]},{"line":"      , Poly_comm.Backend.t )","counters":[]},{"line":"      Kimchi_types.VerifierIndex.verifier_index","counters":[]},{"line":"","counters":[]},{"line":"    val create : Index.t -> t","counters":[]},{"line":"  end","counters":[]},{"line":"end","counters":[]},{"line":"","counters":[]},{"line":"module Make (Inputs : Inputs_intf) = struct","counters":[]},{"line":"  open Core_kernel","counters":[]},{"line":"","counters":[]},{"line":"  type t = { index : Inputs.Index.t; cs : Inputs.Constraint_system.t }","counters":[]},{"line":"","counters":[]},{"line":"  let name =","counters":[]},{"line":"    sprintf \"%s_%d_v4\" Inputs.name (Pickles_types.Nat.to_int Inputs.Rounds.n)","counters":[{"col_start":10,"col_end":10,"count":2},{"col_start":59,"col_end":59,"count":2}]},{"line":"","counters":[]},{"line":"  let set_urs_info, load_urs =","counters":[]},{"line":"    let urs_info = Set_once.create () in","counters":[]},{"line":"    let urs = ref None in","counters":[{"col_start":4,"col_end":4,"count":2}]},{"line":"    let degree = 1 lsl Pickles_types.Nat.to_int Inputs.Rounds.n in","counters":[{"col_start":46,"col_end":46,"count":2}]},{"line":"    let set_urs_info specs = Set_once.set_exn urs_info Lexing.dummy_pos specs in","counters":[{"col_start":29,"col_end":29,"count":2}]},{"line":"    let load () =","counters":[]},{"line":"      match !urs with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | Some urs ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          urs","counters":[]},{"line":"      | None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let specs =","counters":[]},{"line":"            match Set_once.get urs_info with","counters":[]},{"line":"            | None ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                failwith \"Dlog_based.urs: Info not set\"","counters":[]},{"line":"            | Some t ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                t","counters":[]},{"line":"          in","counters":[]},{"line":"          let store =","counters":[]},{"line":"            Key_cache.Sync.Disk_storable.simple","counters":[]},{"line":"              (fun () -> name)","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"              (fun () ~path ->","counters":[]},{"line":"                Or_error.try_with_join (fun () ->","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                    match Inputs.Urs.read None path with","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                    | Some urs ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        Ok urs","counters":[]},{"line":"                    | None ->","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                        Or_error.errorf","counters":[]},{"line":"                          \"Could not read the URS from disk; its format did \\","counters":[]},{"line":"                           not match the expected format\" ) )","counters":[]},{"line":"              (fun _ urs path ->","counters":[]},{"line":"                Or_error.try_with (fun () -> Inputs.Urs.write None urs path) )","counters":[{"col_start":16,"col_end":16,"count":0},{"col_start":45,"col_end":45,"count":0}]},{"line":"          in","counters":[]},{"line":"          let u =","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            match Key_cache.Sync.read specs store () with","counters":[]},{"line":"            | Ok (u, _) ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                u","counters":[]},{"line":"            | Error _e ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                let urs = Inputs.Urs.create degree in","counters":[]},{"line":"                let (_ : (unit, Error.t) Result.t) =","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  Key_cache.Sync.write","counters":[]},{"line":"                    (List.filter specs ~f:(function","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"                      | On_disk _ ->","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          true","counters":[]},{"line":"                      | S3 _ ->","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          false ) )","counters":[]},{"line":"                    store () urs","counters":[]},{"line":"                in","counters":[]},{"line":"                urs","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"          in","counters":[]},{"line":"          urs := Some u ;","counters":[]},{"line":"          u","counters":[]},{"line":"    in","counters":[]},{"line":"    (set_urs_info, load)","counters":[]},{"line":"","counters":[]},{"line":"  let create ~prev_challenges cs =","counters":[]},{"line":"    let gates = Inputs.Constraint_system.finalize_and_get_gates cs in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let public_input_size =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      Inputs.Constraint_system.get_primary_input_size cs","counters":[]},{"line":"    in","counters":[]},{"line":"    let prev_challenges =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      match Inputs.Constraint_system.get_prev_challenges cs with","counters":[]},{"line":"      | None ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          Inputs.Constraint_system.set_prev_challenges cs prev_challenges ;","counters":[]},{"line":"          prev_challenges","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"      | Some prev_challenges' ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          assert (prev_challenges = prev_challenges') ;","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"          prev_challenges'","counters":[]},{"line":"    in","counters":[]},{"line":"    let index =","counters":[]},{"line":"      Inputs.Index.create gates public_input_size prev_challenges (load_urs ())","counters":[{"col_start":74,"col_end":74,"count":0}]},{"line":"    in","counters":[]},{"line":"    { index; cs }","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"","counters":[]},{"line":"  let vk t = Inputs.Verifier_index.create t.index","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"  let pk t = t","counters":[{"col_start":13,"col_end":13,"count":0}]},{"line":"","counters":[]},{"line":"  let array_to_vector a = Pickles_types.Vector.of_list (Array.to_list a)","counters":[{"col_start":26,"col_end":26,"count":0},{"col_start":68,"col_end":68,"count":0}]},{"line":"","counters":[]},{"line":"  (** does this convert a backend.verifier_index to a pickles_types.verifier_index? *)","counters":[]},{"line":"  let vk_commitments (t : Inputs.Verifier_index.t) :","counters":[]},{"line":"      Inputs.Curve.Affine.t Pickles_types.Plonk_verification_key_evals.t =","counters":[]},{"line":"    let g c : Inputs.Curve.Affine.t =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"      match Inputs.Poly_comm.of_backend_without_degree_bound c with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | `Without_degree_bound x ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          x.(0)","counters":[]},{"line":"      | `With_degree_bound _ ->","counters":[]},{"line":"          assert false","counters":[]},{"line":"    in","counters":[]},{"line":"    { sigma_comm =","counters":[]},{"line":"        Pickles_types.Vector.init Pickles_types.Plonk_types.Permuts.n","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"          ~f:(fun i -> g t.evals.sigma_comm.(i))","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"    ; coefficients_comm =","counters":[]},{"line":"        Pickles_types.Vector.init Pickles_types.Plonk_types.Columns.n","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"          ~f:(fun i -> g t.evals.coefficients_comm.(i))","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"    ; generic_comm = g t.evals.generic_comm","counters":[{"col_start":21,"col_end":21,"count":0}]},{"line":"    ; psm_comm = g t.evals.psm_comm","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"    ; complete_add_comm = g t.evals.complete_add_comm","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"    ; mul_comm = g t.evals.mul_comm","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"    ; emul_comm = g t.evals.emul_comm","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"    ; endomul_scalar_comm = g t.evals.endomul_scalar_comm","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"    }","counters":[]},{"line":"end","counters":[{"col_start":2,"col_end":2,"count":2}]}]}