{"filename":"src/lib/pickles/step_main.ml","lines":[{"line":"module S = Sponge","counters":[]},{"line":"open Core_kernel","counters":[]},{"line":"open Pickles_types","counters":[]},{"line":"open Common","counters":[]},{"line":"open Poly_types","counters":[]},{"line":"open Hlist","counters":[]},{"line":"open Import","counters":[]},{"line":"open Impls.Step","counters":[]},{"line":"open Step_main_inputs","counters":[]},{"line":"open Step_verifier","counters":[]},{"line":"module B = Inductive_rule.B","counters":[]},{"line":"","counters":[]},{"line":"(* Converts from the one hot vector representation of a number","counters":[]},{"line":"   0 <= i < n","counters":[]},{"line":"","counters":[]},{"line":"     0  1  ... i-1  i  i+1       n-1","counters":[]},{"line":"   [ 0; 0; ... 0;   1; 0;   ...; 0 ]","counters":[]},{"line":"","counters":[]},{"line":"   to the numeric representation i. *)","counters":[]},{"line":"","counters":[]},{"line":"let one_hot_vector_to_num (type n) (v : n Per_proof_witness.One_hot_vector.t) :","counters":[]},{"line":"    Field.t =","counters":[]},{"line":"  let n = Vector.length (v :> (Boolean.var, n) Vector.t) in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  Pseudo.choose (v, Vector.init n ~f:Field.of_int) ~f:Fn.id","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":30,"col_end":30,"count":0}]},{"line":"","counters":[]},{"line":"let verify_one","counters":[]},{"line":"    ({ app_state","counters":[]},{"line":"     ; wrap_proof","counters":[]},{"line":"     ; proof_state","counters":[]},{"line":"     ; prev_proof_evals","counters":[]},{"line":"     ; prev_challenges","counters":[]},{"line":"     ; prev_challenge_polynomial_commitments","counters":[]},{"line":"     } :","counters":[]},{"line":"      _ Per_proof_witness.t ) (d : _ Types_map.For_step.t)","counters":[]},{"line":"    (messages_for_next_wrap_proof : Digest.t) (unfinalized : Unfinalized.t)","counters":[]},{"line":"    (should_verify : B.t) : _ Vector.t * B.t =","counters":[]},{"line":"  Boolean.Assert.( = ) unfinalized.should_finalize should_verify ;","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let finalized, chals =","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    with_label __LOC__ (fun () ->","counters":[]},{"line":"        let sponge_digest = proof_state.sponge_digest_before_evaluations in","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"        let sponge =","counters":[]},{"line":"          let open Step_main_inputs in","counters":[]},{"line":"          let sponge = Sponge.create sponge_params in","counters":[]},{"line":"          Sponge.absorb sponge (`Field sponge_digest) ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          sponge","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"        in","counters":[]},{"line":"        (* TODO: Refactor args into an \"unfinalized proof\" struct *)","counters":[]},{"line":"        finalize_other_proof d.max_proofs_verified ~step_domains:d.step_domains","counters":[]},{"line":"          ~step_uses_lookup:d.step_uses_lookup ~sponge ~prev_challenges","counters":[]},{"line":"          proof_state.deferred_values prev_proof_evals )","counters":[]},{"line":"  in","counters":[]},{"line":"  let branch_data = proof_state.deferred_values.branch_data in","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"  let sponge_after_index, hash_messages_for_next_step_proof =","counters":[]},{"line":"    let to_field_elements =","counters":[]},{"line":"      let (Typ typ) = d.public_input in","counters":[]},{"line":"      fun x -> fst (typ.var_to_fields x)","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":36,"col_end":36,"count":0}]},{"line":"    in","counters":[]},{"line":"    let sponge_after_index, hash_messages_for_next_step_proof =","counters":[]},{"line":"      (* TODO: Don't rehash when it's not necessary *)","counters":[]},{"line":"      hash_messages_for_next_step_proof_opt ~index:d.wrap_key to_field_elements","counters":[]},{"line":"    in","counters":[]},{"line":"    (sponge_after_index, unstage hash_messages_for_next_step_proof)","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":31,"col_end":31,"count":0}]},{"line":"  in","counters":[]},{"line":"  let statement =","counters":[]},{"line":"    let prev_messages_for_next_step_proof =","counters":[]},{"line":"      with_label __LOC__ (fun () ->","counters":[]},{"line":"          hash_messages_for_next_step_proof ~widths:d.proofs_verifieds","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"            ~max_width:(Nat.Add.n d.max_proofs_verified)","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"            ~proofs_verified_mask:","counters":[]},{"line":"              (Vector.trim branch_data.proofs_verified_mask","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                 (Nat.lte_exn","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                    (Vector.length prev_challenge_polynomial_commitments)","counters":[{"col_start":33,"col_end":33,"count":0}]},{"line":"                    Nat.N2.n ) )","counters":[]},{"line":"            (* Use opt sponge for cutting off the bulletproof challenges early *)","counters":[]},{"line":"            { app_state","counters":[]},{"line":"            ; dlog_plonk_index = d.wrap_key","counters":[]},{"line":"            ; challenge_polynomial_commitments =","counters":[]},{"line":"                prev_challenge_polynomial_commitments","counters":[]},{"line":"            ; old_bulletproof_challenges = prev_challenges","counters":[]},{"line":"            } )","counters":[]},{"line":"    in","counters":[]},{"line":"    { Types.Wrap.Statement.messages_for_next_step_proof =","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"        prev_messages_for_next_step_proof","counters":[]},{"line":"    ; proof_state = { proof_state with messages_for_next_wrap_proof }","counters":[]},{"line":"    }","counters":[]},{"line":"  in","counters":[]},{"line":"  let verified =","counters":[]},{"line":"    with_label __LOC__ (fun () ->","counters":[]},{"line":"        verify","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          ~lookup_parameters:","counters":[]},{"line":"            { use = d.step_uses_lookup","counters":[]},{"line":"            ; zero =","counters":[]},{"line":"                { var =","counters":[]},{"line":"                    { challenge = Field.zero","counters":[]},{"line":"                    ; scalar = Shifted_value Field.zero","counters":[]},{"line":"                    }","counters":[]},{"line":"                ; value =","counters":[]},{"line":"                    { challenge = Limb_vector.Challenge.Constant.zero","counters":[]},{"line":"                    ; scalar =","counters":[]},{"line":"                        Shifted_value.Type1.Shifted_value Field.Constant.zero","counters":[]},{"line":"                    }","counters":[]},{"line":"                }","counters":[]},{"line":"            }","counters":[]},{"line":"          ~proofs_verified:d.max_proofs_verified ~wrap_domain:d.wrap_domain","counters":[]},{"line":"          ~is_base_case:(Boolean.not should_verify)","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"          ~sponge_after_index ~sg_old:prev_challenge_polynomial_commitments","counters":[]},{"line":"          ~proof:wrap_proof ~wrap_verification_key:d.wrap_key statement","counters":[]},{"line":"          unfinalized )","counters":[]},{"line":"  in","counters":[]},{"line":"  if debug then","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    as_prover","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":12,"col_end":12,"count":0}]},{"line":"      As_prover.(","counters":[]},{"line":"        fun () ->","counters":[]},{"line":"          let finalized = read Boolean.typ finalized in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let verified = read Boolean.typ verified in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          let should_verify = read Boolean.typ should_verify in","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          printf \"finalized: %b\\n%!\" finalized ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          printf \"verified: %b\\n%!\" verified ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"          printf \"should_verify: %b\\n\\n%!\" should_verify) ;","counters":[{"col_start":10,"col_end":10,"count":0}]},{"line":"  (chals, Boolean.(verified &&& finalized ||| not should_verify))","counters":[{"col_start":2,"col_end":2,"count":0},{"col_start":30,"col_end":30,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"","counters":[]},{"line":"let finalize_previous_and_verify = ()","counters":[]},{"line":"","counters":[]},{"line":"(* The SNARK function corresponding to the input inductive rule. *)","counters":[]},{"line":"let step_main :","counters":[]},{"line":"    type proofs_verified self_branches prev_vars prev_values prev_ret_vars var value a_var a_value ret_var ret_value auxiliary_var auxiliary_value max_proofs_verified local_branches local_signature.","counters":[]},{"line":"       (module Requests.Step.S","counters":[]},{"line":"          with type local_signature = local_signature","counters":[]},{"line":"           and type local_branches = local_branches","counters":[]},{"line":"           and type statement = a_value","counters":[]},{"line":"           and type prev_values = prev_values","counters":[]},{"line":"           and type max_proofs_verified = max_proofs_verified","counters":[]},{"line":"           and type return_value = ret_value","counters":[]},{"line":"           and type auxiliary_value = auxiliary_value )","counters":[]},{"line":"    -> (module Nat.Add.Intf with type n = max_proofs_verified)","counters":[]},{"line":"    -> self_branches:self_branches Nat.t","counters":[]},{"line":"         (* How many branches does this proof system have *)","counters":[]},{"line":"    -> local_signature:local_signature H1.T(Nat).t","counters":[]},{"line":"         (* The specification, for each proof that this step circuit verifies, of the maximum width used","counters":[]},{"line":"            by that proof system. *)","counters":[]},{"line":"    -> local_signature_length:(local_signature, proofs_verified) Hlist.Length.t","counters":[]},{"line":"    -> local_branches:","counters":[]},{"line":"         (* For each inner proof of type T , the number of branches that type T has. *)","counters":[]},{"line":"         local_branches H1.T(Nat).t","counters":[]},{"line":"    -> local_branches_length:(local_branches, proofs_verified) Hlist.Length.t","counters":[]},{"line":"    -> proofs_verified:(prev_vars, proofs_verified) Hlist.Length.t","counters":[]},{"line":"    -> lte:(proofs_verified, max_proofs_verified) Nat.Lte.t","counters":[]},{"line":"    -> public_input:","counters":[]},{"line":"         ( var","counters":[]},{"line":"         , value","counters":[]},{"line":"         , a_var","counters":[]},{"line":"         , a_value","counters":[]},{"line":"         , ret_var","counters":[]},{"line":"         , ret_value )","counters":[]},{"line":"         Inductive_rule.public_input","counters":[]},{"line":"    -> auxiliary_typ:(auxiliary_var, auxiliary_value) Typ.t","counters":[]},{"line":"    -> basic:","counters":[]},{"line":"         ( var","counters":[]},{"line":"         , value","counters":[]},{"line":"         , max_proofs_verified","counters":[]},{"line":"         , self_branches )","counters":[]},{"line":"         Types_map.Compiled.basic","counters":[]},{"line":"    -> self:(var, value, max_proofs_verified, self_branches) Tag.t","counters":[]},{"line":"    -> ( prev_vars","counters":[]},{"line":"       , prev_values","counters":[]},{"line":"       , local_signature","counters":[]},{"line":"       , local_branches","counters":[]},{"line":"       , a_var","counters":[]},{"line":"       , a_value","counters":[]},{"line":"       , ret_var","counters":[]},{"line":"       , ret_value","counters":[]},{"line":"       , auxiliary_var","counters":[]},{"line":"       , auxiliary_value )","counters":[]},{"line":"       Inductive_rule.t","counters":[]},{"line":"    -> (   unit","counters":[]},{"line":"        -> ( (Unfinalized.t, max_proofs_verified) Vector.t","counters":[]},{"line":"           , Field.t","counters":[]},{"line":"           , (Field.t, max_proofs_verified) Vector.t )","counters":[]},{"line":"           Types.Step.Statement.t )","counters":[]},{"line":"       Staged.t =","counters":[]},{"line":" fun (module Req) max_proofs_verified ~self_branches ~local_signature","counters":[]},{"line":"     ~local_signature_length ~local_branches ~local_branches_length","counters":[]},{"line":"     ~proofs_verified ~lte ~public_input ~auxiliary_typ ~basic ~self rule ->","counters":[]},{"line":"  let module T (F : T4) = struct","counters":[{"col_start":2,"col_end":2,"count":0}]},{"line":"    type ('a, 'b, 'n, 'm) t =","counters":[]},{"line":"      | Other of ('a, 'b, 'n, 'm) F.t","counters":[]},{"line":"      | Self : (a_var, a_value, max_proofs_verified, self_branches) t","counters":[]},{"line":"  end in","counters":[]},{"line":"  let module Typ_with_max_proofs_verified = struct","counters":[]},{"line":"    type ('var, 'value, 'local_max_proofs_verified, 'local_branches) t =","counters":[]},{"line":"      ( ( 'var","counters":[]},{"line":"        , 'local_max_proofs_verified","counters":[]},{"line":"        , 'local_branches )","counters":[]},{"line":"        Per_proof_witness.No_app_state.t","counters":[]},{"line":"      , ( 'value","counters":[]},{"line":"        , 'local_max_proofs_verified","counters":[]},{"line":"        , 'local_branches )","counters":[]},{"line":"        Per_proof_witness.Constant.No_app_state.t )","counters":[]},{"line":"      Typ.t","counters":[]},{"line":"  end in","counters":[]},{"line":"  let uses_lookup (d : _ Tag.t) =","counters":[]},{"line":"    if Type_equal.Id.same self.id d.id then basic.step_uses_lookup","counters":[{"col_start":4,"col_end":4,"count":0},{"col_start":44,"col_end":44,"count":0}]},{"line":"    else Types_map.uses_lookup d","counters":[{"col_start":9,"col_end":9,"count":0}]},{"line":"  in","counters":[]},{"line":"  let lookup_usage =","counters":[]},{"line":"    let rec go :","counters":[]},{"line":"        type e pvars pvals ns1 ns2 br.","counters":[]},{"line":"           (pvars, pvals, ns1, ns2) H4.T(Tag).t","counters":[]},{"line":"        -> (pvars, br) Length.t","counters":[]},{"line":"        -> (Plonk_types.Opt.Flag.t, br) Vector.t =","counters":[]},{"line":"     fun ds ld ->","counters":[]},{"line":"      match (ds, ld) with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | [], Z ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          []","counters":[]},{"line":"      | d :: ds, S ld ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          uses_lookup d :: go ds ld","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":28,"col_end":28,"count":0}]},{"line":"      | [], _ ->","counters":[]},{"line":"          .","counters":[]},{"line":"      | _ :: _, _ ->","counters":[]},{"line":"          .","counters":[]},{"line":"    in","counters":[]},{"line":"    go rule.prevs proofs_verified","counters":[{"col_start":5,"col_end":5,"count":0}]},{"line":"  in","counters":[]},{"line":"  let prev_proof_typs =","counters":[]},{"line":"    let rec join :","counters":[]},{"line":"        type e pvars pvals ns1 ns2 br.","counters":[]},{"line":"           (pvars, pvals, ns1, ns2) H4.T(Tag).t","counters":[]},{"line":"        -> ns1 H1.T(Nat).t","counters":[]},{"line":"        -> ns2 H1.T(Nat).t","counters":[]},{"line":"        -> (pvars, br) Length.t","counters":[]},{"line":"        -> (ns1, br) Length.t","counters":[]},{"line":"        -> (ns2, br) Length.t","counters":[]},{"line":"        -> (pvars, pvals, ns1, ns2) H4.T(Typ_with_max_proofs_verified).t =","counters":[]},{"line":"     fun ds ns1 ns2 ld ln1 ln2 ->","counters":[]},{"line":"      match (ds, ns1, ns2, ld, ln1, ln2) with","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"      | [], [], [], Z, Z, Z ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          []","counters":[]},{"line":"      | d :: ds, n1 :: ns1, n2 :: ns2, S ld, S ln1, S ln2 ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let t =","counters":[]},{"line":"            Per_proof_witness.typ Typ.unit n1 n2 ~lookup:(uses_lookup d)","counters":[{"col_start":68,"col_end":68,"count":0}]},{"line":"          in","counters":[]},{"line":"          t :: join ds ns1 ns2 ld ln1 ln2","counters":[{"col_start":10,"col_end":10,"count":0},{"col_start":18,"col_end":18,"count":0}]},{"line":"      | [], _, _, _, _, _ ->","counters":[]},{"line":"          .","counters":[]},{"line":"      | _ :: _, _, _, _, _, _ ->","counters":[]},{"line":"          .","counters":[]},{"line":"    in","counters":[]},{"line":"    join rule.prevs local_signature local_branches proofs_verified","counters":[{"col_start":7,"col_end":7,"count":0}]},{"line":"      local_signature_length local_branches_length","counters":[]},{"line":"  in","counters":[]},{"line":"  let module Prev_typ =","counters":[]},{"line":"    H4.Typ (Impls.Step) (Typ_with_max_proofs_verified)","counters":[]},{"line":"      (Per_proof_witness.No_app_state)","counters":[]},{"line":"      (Per_proof_witness.Constant.No_app_state)","counters":[]},{"line":"      (struct","counters":[]},{"line":"        let f = Fn.id","counters":[]},{"line":"      end)","counters":[]},{"line":"  in","counters":[]},{"line":"  let (input_typ, output_typ)","counters":[]},{"line":"        : (a_var, a_value) Typ.t * (ret_var, ret_value) Typ.t =","counters":[]},{"line":"    match public_input with","counters":[]},{"line":"    | Input typ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (typ, Typ.unit)","counters":[]},{"line":"    | Output typ ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (Typ.unit, typ)","counters":[]},{"line":"    | Input_and_output (input_typ, output_typ) ->","counters":[{"col_start":6,"col_end":6,"count":0}]},{"line":"        (input_typ, output_typ)","counters":[]},{"line":"  in","counters":[]},{"line":"  let main () : _ Types.Step.Statement.t =","counters":[]},{"line":"    let open Requests.Step in","counters":[{"col_start":4,"col_end":4,"count":0}]},{"line":"    let open Impls.Step in","counters":[]},{"line":"    with_label \"step_main\" (fun () ->","counters":[]},{"line":"        let module Max_proofs_verified = ( val max_proofs_verified : Nat.Add.Intf","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"                                             with type n = max_proofs_verified","counters":[]},{"line":"                                         )","counters":[]},{"line":"        in","counters":[]},{"line":"        let T = Max_proofs_verified.eq in","counters":[]},{"line":"        let app_state = exists input_typ ~request:(fun () -> Req.App_state) in","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"        let { Inductive_rule.previous_proof_statements","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            ; public_output = ret_var","counters":[]},{"line":"            ; auxiliary_output = auxiliary_var","counters":[]},{"line":"            } =","counters":[]},{"line":"          (* Run the application logic of the rule on the predecessor statements *)","counters":[]},{"line":"          with_label \"rule_main\" (fun () ->","counters":[]},{"line":"              rule.main { public_input = app_state } )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"        in","counters":[]},{"line":"        let () =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          exists Typ.unit ~request:(fun () ->","counters":[]},{"line":"              let ret_value = As_prover.read output_typ ret_var in","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"              Req.Return_value ret_value )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"        in","counters":[]},{"line":"        let () =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          exists Typ.unit ~request:(fun () ->","counters":[]},{"line":"              let auxiliary_value =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                As_prover.read auxiliary_typ auxiliary_var","counters":[]},{"line":"              in","counters":[]},{"line":"              Req.Auxiliary_value auxiliary_value )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"        in","counters":[]},{"line":"        (* Compute proof parts outside of the prover before requesting values.","counters":[]},{"line":"        *)","counters":[]},{"line":"        exists Typ.unit ~request:(fun () ->","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"            let previous_proof_statements =","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"              let rec go :","counters":[]},{"line":"                  type prev_vars prev_values ns1 ns2.","counters":[]},{"line":"                     ( prev_vars","counters":[]},{"line":"                     , ns1 )","counters":[]},{"line":"                     H2.T(Inductive_rule.Previous_proof_statement).t","counters":[]},{"line":"                  -> (prev_vars, prev_values, ns1, ns2) H4.T(Tag).t","counters":[]},{"line":"                  -> ( prev_values","counters":[]},{"line":"                     , ns1 )","counters":[]},{"line":"                     H2.T(Inductive_rule.Previous_proof_statement.Constant).t =","counters":[]},{"line":"               fun previous_proof_statement tags ->","counters":[]},{"line":"                match (previous_proof_statement, tags) with","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                | [], [] ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    []","counters":[]},{"line":"                | ( { public_input; proof; proof_must_verify } :: stmts","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  , tag :: tags ) ->","counters":[]},{"line":"                    let public_input =","counters":[]},{"line":"                      (fun (type var value n m) (tag : (var, value, n, m) Tag.t)","counters":[]},{"line":"                           (var : var) : value ->","counters":[]},{"line":"                        let typ : (var, value) Typ.t =","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"                          match Type_equal.Id.same_witness self.id tag.id with","counters":[]},{"line":"                          | Some T ->","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                              basic.public_input","counters":[]},{"line":"                          | None ->","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                              Types_map.public_input tag","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                        in","counters":[]},{"line":"                        As_prover.read typ var )","counters":[]},{"line":"                        tag public_input","counters":[]},{"line":"                    in","counters":[]},{"line":"                    { public_input","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                    ; proof = As_prover.Ref.get proof","counters":[{"col_start":46,"col_end":46,"count":0}]},{"line":"                    ; proof_must_verify =","counters":[]},{"line":"                        As_prover.read Boolean.typ proof_must_verify","counters":[{"col_start":37,"col_end":37,"count":0}]},{"line":"                    }","counters":[]},{"line":"                    :: go stmts tags","counters":[{"col_start":24,"col_end":24,"count":0}]},{"line":"              in","counters":[]},{"line":"              go previous_proof_statements rule.prevs","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"            in","counters":[]},{"line":"            Req.Compute_prev_proof_parts previous_proof_statements ) ;","counters":[]},{"line":"        let dlog_plonk_index =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          exists","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"            ~request:(fun () -> Req.Wrap_index)","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"            (Plonk_verification_key_evals.typ Inner_curve.typ)","counters":[{"col_start":44,"col_end":44,"count":0}]},{"line":"        and prevs =","counters":[]},{"line":"          exists (Prev_typ.f prev_proof_typs) ~request:(fun () ->","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"              Req.Proof_with_datas )","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"        and unfinalized_proofs =","counters":[]},{"line":"          exists","counters":[{"col_start":15,"col_end":15,"count":0}]},{"line":"            (Vector.typ'","counters":[{"col_start":23,"col_end":23,"count":0}]},{"line":"               (Vector.map","counters":[{"col_start":25,"col_end":25,"count":0}]},{"line":"                  ~f:(fun uses_lookup ->","counters":[]},{"line":"                    Unfinalized.typ ~wrap_rounds:Backend.Tock.Rounds.n","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      ~uses_lookup )","counters":[]},{"line":"                  (Vector.extend lookup_usage lte Max_proofs_verified.n No) ) )","counters":[{"col_start":31,"col_end":31,"count":0}]},{"line":"            ~request:(fun () -> Req.Unfinalized_proofs)","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"        and messages_for_next_wrap_proof =","counters":[]},{"line":"          exists (Vector.typ Digest.typ Max_proofs_verified.n)","counters":[{"col_start":15,"col_end":15,"count":0},{"col_start":27,"col_end":27,"count":0}]},{"line":"            ~request:(fun () -> Req.Messages_for_next_wrap_proof)","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"        in","counters":[]},{"line":"        let prevs =","counters":[]},{"line":"          (* Inject the app-state values into the per-proof witnesses. *)","counters":[]},{"line":"          let rec go :","counters":[]},{"line":"              type vars ns1 ns2.","counters":[]},{"line":"                 (vars, ns1, ns2) H3.T(Per_proof_witness.No_app_state).t","counters":[]},{"line":"              -> (vars, ns1) H2.T(Inductive_rule.Previous_proof_statement).t","counters":[]},{"line":"              -> (vars, ns1, ns2) H3.T(Per_proof_witness).t =","counters":[]},{"line":"           fun proofs stmts ->","counters":[]},{"line":"            match (proofs, stmts) with","counters":[{"col_start":12,"col_end":12,"count":0}]},{"line":"            | [], [] ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                []","counters":[]},{"line":"            | proof :: proofs, stmt :: stmts ->","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                { proof with app_state = stmt.public_input } :: go proofs stmts","counters":[{"col_start":65,"col_end":65,"count":0}]},{"line":"          in","counters":[]},{"line":"          go prevs previous_proof_statements","counters":[{"col_start":11,"col_end":11,"count":0}]},{"line":"        in","counters":[]},{"line":"        let bulletproof_challenges =","counters":[]},{"line":"          with_label \"prevs_verified\" (fun () ->","counters":[]},{"line":"              let rec go :","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                  type vars vals prev_vals ns1 ns2 n.","counters":[]},{"line":"                     (vars, ns1, ns2) H3.T(Per_proof_witness).t","counters":[]},{"line":"                  -> (vars, vals, ns1, ns2) H4.T(Types_map.For_step).t","counters":[]},{"line":"                  -> vars H1.T(E01(Digest)).t","counters":[]},{"line":"                  -> vars H1.T(E01(Unfinalized)).t","counters":[]},{"line":"                  -> (vars, ns1) H2.T(Inductive_rule.Previous_proof_statement).t","counters":[]},{"line":"                  -> (vars, n) Length.t","counters":[]},{"line":"                  -> (_, n) Vector.t * B.t list =","counters":[]},{"line":"               fun proofs datas messages_for_next_wrap_proofs unfinalizeds stmts","counters":[]},{"line":"                   pi ->","counters":[]},{"line":"                match","counters":[{"col_start":16,"col_end":16,"count":0}]},{"line":"                  ( proofs","counters":[]},{"line":"                  , datas","counters":[]},{"line":"                  , messages_for_next_wrap_proofs","counters":[]},{"line":"                  , unfinalizeds","counters":[]},{"line":"                  , stmts","counters":[]},{"line":"                  , pi )","counters":[]},{"line":"                with","counters":[]},{"line":"                | [], [], [], [], [], Z ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    ([], [])","counters":[]},{"line":"                | ( p :: proofs","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                  , d :: datas","counters":[]},{"line":"                  , messages_for_next_wrap_proof","counters":[]},{"line":"                    :: messages_for_next_wrap_proofs","counters":[]},{"line":"                  , unfinalized :: unfinalizeds","counters":[]},{"line":"                  , { proof_must_verify = should_verify; _ } :: stmts","counters":[]},{"line":"                  , S pi ) ->","counters":[]},{"line":"                    let chals, v =","counters":[]},{"line":"                      verify_one p d messages_for_next_wrap_proof unfinalized","counters":[]},{"line":"                        should_verify","counters":[]},{"line":"                    in","counters":[]},{"line":"                    let chalss, vs =","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                      go proofs datas messages_for_next_wrap_proofs unfinalizeds","counters":[]},{"line":"                        stmts pi","counters":[]},{"line":"                    in","counters":[]},{"line":"                    (chals :: chalss, v :: vs)","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"              in","counters":[]},{"line":"              let chalss, vs =","counters":[]},{"line":"                let messages_for_next_wrap_proofs =","counters":[]},{"line":"                  with_label \"messages_for_next_wrap_proofs\" (fun () ->","counters":[{"col_start":27,"col_end":27,"count":0}]},{"line":"                      let module V = H1.Of_vector (Digest) in","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                      V.f proofs_verified","counters":[]},{"line":"                        (Vector.trim messages_for_next_wrap_proof lte) )","counters":[{"col_start":35,"col_end":35,"count":0}]},{"line":"                and unfinalized_proofs =","counters":[]},{"line":"                  let module H = H1.Of_vector (Unfinalized) in","counters":[]},{"line":"                  H.f proofs_verified (Vector.trim unfinalized_proofs lte)","counters":[{"col_start":20,"col_end":20,"count":0},{"col_start":49,"col_end":49,"count":0}]},{"line":"                and datas =","counters":[]},{"line":"                  let self_data :","counters":[]},{"line":"                      ( var","counters":[]},{"line":"                      , value","counters":[]},{"line":"                      , max_proofs_verified","counters":[]},{"line":"                      , self_branches )","counters":[]},{"line":"                      Types_map.For_step.t =","counters":[]},{"line":"                    { branches = self_branches","counters":[]},{"line":"                    ; proofs_verifieds =","counters":[]},{"line":"                        `Known","counters":[]},{"line":"                          (Vector.map basic.proofs_verifieds ~f:Field.of_int)","counters":[{"col_start":36,"col_end":36,"count":0}]},{"line":"                    ; max_proofs_verified","counters":[]},{"line":"                    ; public_input = basic.public_input","counters":[]},{"line":"                    ; wrap_domain = `Known basic.wrap_domains.h","counters":[]},{"line":"                    ; step_domains = `Known basic.step_domains","counters":[]},{"line":"                    ; wrap_key = dlog_plonk_index","counters":[]},{"line":"                    ; step_uses_lookup = basic.step_uses_lookup","counters":[]},{"line":"                    }","counters":[]},{"line":"                  in","counters":[]},{"line":"                  let module M =","counters":[]},{"line":"                    H4.Map (Tag) (Types_map.For_step)","counters":[]},{"line":"                      (struct","counters":[]},{"line":"                        let f :","counters":[]},{"line":"                            type a1 a2 n m.","counters":[]},{"line":"                               (a1, a2, n, m) Tag.t","counters":[]},{"line":"                            -> (a1, a2, n, m) Types_map.For_step.t =","counters":[]},{"line":"                         fun tag ->","counters":[]},{"line":"                          match Type_equal.Id.same_witness self.id tag.id with","counters":[{"col_start":26,"col_end":26,"count":0}]},{"line":"                          | Some T ->","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                              self_data","counters":[]},{"line":"                          | None -> (","counters":[{"col_start":28,"col_end":28,"count":0}]},{"line":"                              match tag.kind with","counters":[]},{"line":"                              | Compiled ->","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                                  Types_map.For_step.of_compiled","counters":[]},{"line":"                                    (Types_map.lookup_compiled tag.id)","counters":[{"col_start":61,"col_end":61,"count":0}]},{"line":"                              | Side_loaded ->","counters":[{"col_start":32,"col_end":32,"count":0}]},{"line":"                                  Types_map.For_step.of_side_loaded","counters":[]},{"line":"                                    (Types_map.lookup_side_loaded tag.id) )","counters":[{"col_start":64,"col_end":64,"count":0}]},{"line":"                      end)","counters":[]},{"line":"                  in","counters":[]},{"line":"                  M.f rule.prevs","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                in","counters":[]},{"line":"                go prevs datas messages_for_next_wrap_proofs unfinalized_proofs","counters":[{"col_start":17,"col_end":17,"count":0}]},{"line":"                  previous_proof_statements proofs_verified","counters":[]},{"line":"              in","counters":[]},{"line":"              Boolean.Assert.all vs ; chalss )","counters":[{"col_start":38,"col_end":38,"count":0}]},{"line":"        in","counters":[]},{"line":"        let messages_for_next_step_proof =","counters":[{"col_start":8,"col_end":8,"count":0}]},{"line":"          let challenge_polynomial_commitments =","counters":[]},{"line":"            let module M =","counters":[]},{"line":"              H3.Map (Per_proof_witness) (E03 (Inner_curve))","counters":[]},{"line":"                (struct","counters":[]},{"line":"                  let f :","counters":[]},{"line":"                      type a b c. (a, b, c) Per_proof_witness.t -> Inner_curve.t","counters":[]},{"line":"                      =","counters":[]},{"line":"                   fun acc ->","counters":[]},{"line":"                    acc.wrap_proof.opening.challenge_polynomial_commitment","counters":[{"col_start":20,"col_end":20,"count":0}]},{"line":"                end)","counters":[]},{"line":"            in","counters":[]},{"line":"            let module V = H3.To_vector (Inner_curve) in","counters":[]},{"line":"            V.f proofs_verified (M.f prevs)","counters":[{"col_start":14,"col_end":14,"count":0},{"col_start":35,"col_end":35,"count":0}]},{"line":"          in","counters":[]},{"line":"          with_label \"hash_messages_for_next_step_proof\" (fun () ->","counters":[{"col_start":19,"col_end":19,"count":0}]},{"line":"              let hash_messages_for_next_step_proof =","counters":[{"col_start":14,"col_end":14,"count":0}]},{"line":"                let to_field_elements =","counters":[]},{"line":"                  let (Typ typ) = basic.public_input in","counters":[]},{"line":"                  fun x -> fst (typ.var_to_fields x)","counters":[{"col_start":27,"col_end":27,"count":0},{"col_start":48,"col_end":48,"count":0}]},{"line":"                in","counters":[]},{"line":"                unstage","counters":[{"col_start":22,"col_end":22,"count":0}]},{"line":"                  (hash_messages_for_next_step_proof ~index:dlog_plonk_index","counters":[{"col_start":51,"col_end":51,"count":0}]},{"line":"                     to_field_elements )","counters":[]},{"line":"              in","counters":[]},{"line":"              let (app_state : var) =","counters":[]},{"line":"                match public_input with","counters":[]},{"line":"                | Input _ ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    app_state","counters":[]},{"line":"                | Output _ ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    ret_var","counters":[]},{"line":"                | Input_and_output _ ->","counters":[{"col_start":18,"col_end":18,"count":0}]},{"line":"                    (app_state, ret_var)","counters":[]},{"line":"              in","counters":[]},{"line":"              hash_messages_for_next_step_proof","counters":[]},{"line":"                { app_state","counters":[]},{"line":"                ; dlog_plonk_index","counters":[]},{"line":"                ; challenge_polynomial_commitments","counters":[]},{"line":"                ; old_bulletproof_challenges =","counters":[]},{"line":"                    (* Note: the bulletproof_challenges here are unpadded! *)","counters":[]},{"line":"                    bulletproof_challenges","counters":[]},{"line":"                } )","counters":[]},{"line":"        in","counters":[]},{"line":"        ( { Types.Step.Statement.proof_state =","counters":[]},{"line":"              { unfinalized_proofs; messages_for_next_step_proof }","counters":[]},{"line":"          ; messages_for_next_wrap_proof","counters":[]},{"line":"          }","counters":[]},{"line":"          : ( (Unfinalized.t, max_proofs_verified) Vector.t","counters":[]},{"line":"            , Field.t","counters":[]},{"line":"            , (Field.t, max_proofs_verified) Vector.t )","counters":[]},{"line":"            Types.Step.Statement.t ) )","counters":[]},{"line":"  in","counters":[]},{"line":"  stage main","counters":[{"col_start":11,"col_end":11,"count":2}]}]}